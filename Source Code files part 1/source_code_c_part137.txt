e WM_INITDIALOG:

        // Store all device strings into the selection area.

        hwndCombo = GetDlgItem(hDlg, IDC_CDROM_NAMES);
        cdrom = currentCdrom = CdRomChainBase;
        currentSelectionLetter = (CHAR) cdrom->DriveLetter;
        while (cdrom) {
            sprintf(string, "CdRom%d", cdrom->DeviceNumber);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)string);
            cdrom = cdrom->Next;
        }
        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);

        // Update the drive letter selections.

        selection = index = 0;
        hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
        string[1] = TEXT(':');
        string[2] = 0;
        for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
            if ((DriveLetterIsAvailable((CHAR)driveLetter)) ||
                (driveLetter == currentSelectionLetter)) {
                *string = driveLetter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)string);
                if (driveLetter == currentSelectionLetter) {
                    selection = index;
                }
                index++;
            }
        }

        // set the current selection to the appropriate index

        SendMessage(hwndCombo, CB_SETCURSEL, selection, 0);
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:
            DialogHelp(HC_DM_DLG_CDROM);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            // User has selected the drive letter and wants the mount to occur.

            hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)string);
            currentCdrom->NewDriveLetter = (WCHAR) string[0];
            CdRomChanged = currentCdrom;
            EndDialog(hDlg, TRUE);
            break;

        default:

            if (HIWORD(wParam) == LBN_SELCHANGE) {
                TCHAR *cp;

                if (LOWORD(wParam) != IDC_CDROM_NAMES) {
                    break;
                }

                // The state of something in the dialog changed.

                hwndCombo = GetDlgItem(hDlg, IDC_CDROM_NAMES);
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                SendMessage(hwndCombo,
                            CB_GETLBTEXT,
                            selection,
                            (LONG)string);

                // The format of the string returned is "cdrom#".  Parse the
                // value of # in order to find the selection.

                cp = string;
                while (*cp) {
                    cp++;
                }
                cp--;
                while ((*cp >= (TCHAR) '0') && (*cp <= (TCHAR) '9')) {
                    cp--;
                }
                cp++;

                selection = 0;
                while (*cp) {
                    selection = (selection * 10) + (*cp - (TCHAR) '0');
                    cp++;
                }

                // Find the matching device name.

                for (cdrom = CdRomChainBase; cdrom; cdrom = cdrom->Next) {

                    if (selection == cdrom->DeviceNumber) {

                        // found the match

                        currentSelectionLetter = (CHAR) cdrom->DriveLetter;
                        currentCdrom = cdrom;
                        break;
                    }
                }

                // The only thing that is important is to track the cdrom
                // device name selected and update the drive letter list.

                selection = index = 0;
                hwndCombo = GetDlgItem(hDlg, IDC_DRIVELET_COMBOBOX);
                SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
                string[1] = TEXT(':');
                string[2] = 0;
                for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
                    if ((DriveLetterIsAvailable((CHAR)driveLetter)) ||
                        (driveLetter == currentSelectionLetter)) {
                        *string = driveLetter;
                        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)string);
                        if (driveLetter == currentSelectionLetter) {
                            selection = index;
                        }
                        index++;
                    }
                }

                // set the current selection to the appropriate index

                SendMessage(hwndCombo, CB_SETCURSEL, selection, 0);
            }
            break;
        }
    }

    return FALSE;
}


VOID
CdRom(
    IN HWND  Dialog,
    IN PVOID Param
    )

/*++

Routine Description:

    Start the CdRom dialogs.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN result = 0;
    DWORD   action,
            ec;
    TCHAR   name[40];
    TCHAR   letter[10];
    PWSTR   linkTarget;
    OBJECT_ATTRIBUTES oa;
    WCHAR             dosName[20];
    HANDLE            handle;
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;
    ANSI_STRING       ansiName;
    UNICODE_STRING    unicodeName;
    UINT              errorMode;

    result = DialogBoxParam(hModule,
                            MAKEINTRESOURCE(IDD_CDROM),
                            Dialog,
                            CdRomDlgProc,
                            (ULONG) NULL);
    if (result) {

        action = ConfirmationDialog(MSG_DRIVE_RENAME_WARNING, MB_ICONQUESTION | MB_YESNOCANCEL);

        if (!action) {
            return;
        }

        // Attempt to open and lock the cdrom.

        sprintf(name, "\\Device\\CdRom%d", CdRomChanged->DeviceNumber);

        RtlInitAnsiString(&ansiName, name);
        status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);

        if (!NT_SUCCESS(status)) {
            ErrorDialog(MSG_CDROM_LETTER_ERROR);
            return;
        }

        memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
        oa.Length = sizeof(OBJECT_ATTRIBUTES);
        oa.ObjectName = &unicodeName;
        oa.Attributes = OBJ_CASE_INSENSITIVE;

        errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        status = NtOpenFile(&handle,
                            SYNCHRONIZE | FILE_READ_DATA,
                            &oa,
                            &statusBlock,
                            FILE_SHARE_READ,
                            FILE_SYNCHRONOUS_IO_ALERT);
        RtlFreeUnicodeString(&unicodeName);
        SetErrorMode(errorMode);

        if (!NT_SUCCESS(status)) {
            ErrorDialog(MSG_CANNOT_LOCK_CDROM);
            return;
        }

        // Lock the drive to insure that no other access is occurring
        // to the volume.  This is done via the "Low" routine for
        // convenience

        status = LowLockDrive(handle);

        if (!NT_SUCCESS(status)) {
            LowCloseDisk(handle);
            ErrorDialog(MSG_CANNOT_LOCK_CDROM);
            return;
        }

        // Before attempting to move the name, see if the letter
        // is currently in use - could be a new network connection
        // or a partition that is scheduled for deletion.

        wsprintfW(dosName, L"\\DosDevices\\%wc:", (WCHAR) CdRomChanged->NewDriveLetter);
        ec = GetDriveLetterLinkTarget(dosName, &linkTarget);
        if (ec == NO_ERROR) {

            // Something is using this letter.

            LowCloseDisk(handle);
            ErrorDialog(MSG_CANNOT_MOVE_CDROM);
            return;
        }

        // remove existing definition - if this fails don't continue.

        sprintf(letter, "%c:", (UCHAR) CdRomChanged->DriveLetter);
        if (!DefineDosDevice(DDD_REMOVE_DEFINITION, (LPCTSTR) letter, (LPCTSTR) NULL)) {
            LowCloseDisk(handle);
            ErrorDialog(MSG_CDROM_LETTER_ERROR);
            return;
        }
        status = DiskRegistryAssignCdRomLetter(CdRomChanged->DeviceName,
                                               CdRomChanged->NewDriveLetter);
        MarkDriveLetterFree((UCHAR)CdRomChanged->DriveLetter);

        // See if this was the device used to install NT

        if (SourcePathLetter) {
            if (SourcePathLetter == CdRomChanged->DriveLetter) {
                LONG   error;
                HKEY   keyHandle;
                DWORD  valueType;
                ULONG  size;
                TCHAR *string;


                // Update the source path

                error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     SourcePathKeyName,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &keyHandle);
                if (error == NO_ERROR) {
                    error = RegQueryValueEx(keyHandle,
                                            SourcePathValueName,
                                            NULL,
                                            &valueType,
                                            (PUCHAR)NULL,
                                            &size);

                    if (error == NO_ERROR) {
                        string = (PUCHAR) LocalAlloc(LMEM_FIXED, size);
                        if (string) {
                            error = RegQueryValueEx(keyHandle,
                                                    SourcePathValueName,
                                                    NULL,
                                                    &valueType,
                                                    string,
                                                    &size);
                            if (error == NO_ERROR) {
                                *string = SourcePathLetter = (UCHAR) CdRomChanged->NewDriveLetter;
                                RegSetValueEx(keyHandle,
                                              SourcePathValueName,
                                              0,
                                              REG_SZ,
                                              string,
                                              size);
                            }
                        }
                        LocalFree(string);
                    }
                    RegCloseKey(keyHandle);
                }
            }
        }

        // set up new device letter - name is already set up

        sprintf(letter, "%c:", (UCHAR) CdRomChanged->NewDriveLetter);
        if (DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) letter, (LPCTSTR) name)) {
            CdRomChanged->DriveLetter = CdRomChanged->NewDriveLetter;
            MarkDriveLetterUsed((UCHAR)CdRomChanged->DriveLetter);
        } else {
            RegistryChanged = TRUE;
        }
        LowCloseDisk(handle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdconst.h ===
#define SYSID_FT    0x80



#define LEGEND_STRING_COUNT 5

#define STATUS_TEXT_SIZE 250

#define NUM_AVAILABLE_COLORS        16
#define NUM_AVAILABLE_HATCHES       5


// brushes for drawing rectangles

#define     BRUSH_USEDPRIMARY       0
#define     BRUSH_USEDLOGICAL       1
#define     BRUSH_STRIPESET         2
#define     BRUSH_MIRROR            3
#define     BRUSH_VOLUMESET         4
#define     BRUSH_ARRAY_SIZE        LEGEND_STRING_COUNT

// see AvailableHatches[] in fddata.c
#define     DEFAULT_HATCH_USEDPRIMARY   4
#define     DEFAULT_HATCH_USEDLOGICAL   4
#define     DEFAULT_HATCH_STRIPESET     4
#define     DEFAULT_HATCH_MIRROR        4
#define     DEFAULT_HATCH_VOLUMESET     4

// see AvailableColors[] in fddata.c
#define     DEFAULT_COLOR_USEDPRIMARY   9
#define     DEFAULT_COLOR_USEDLOGICAL   15
#define     DEFAULT_COLOR_STRIPESET     14
#define     DEFAULT_COLOR_MIRROR        5
#define     DEFAULT_COLOR_VOLUMESET     10


#define     MESSAGE_BUFFER_SIZE 4096

#define     ID_LISTBOX      0xcac


// thickness of the border indicating selection of a region

#define SELECTION_THICKNESS 2


//
// define constants for use with drive letter assignments.
// use arbitrary symbols that won't ever be drive letters themselves.

#define     NO_DRIVE_LETTER_YET         '#'
#define     NO_DRIVE_LETTER_EVER        '%'




// notification codes

#define RN_CLICKED                  213

// window messages

#define RM_SELECT                   WM_USER

// window extra

#define RECTCONTROL_WNDEXTRA        2
#define GWW_SELECTED                0


// custom windows message for F1 key

#define WM_F1DOWN           (WM_USER + 0x17a)



#define     MBOOT_CODE_SIZE     0x1b8
#define     MBOOT_SIG_OFFSET    0x1fe
#define     MBOOT_SIG1          0x55
#define     MBOOT_SIG2          0xaa
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdft.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fddlgs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fddlgs.c

Abstract:

    Dialog routines and dialog support subroutines.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/

#include "fdisk.h"

// used in color dialog to indicate what the user has chosen for
// the various graph element types

DWORD SelectedColor[LEGEND_STRING_COUNT];
DWORD SelectedHatch[LEGEND_STRING_COUNT];

// used in color dialog, contains element (ie, partition, logical volume,
// etc) we're selecting for (ie, which item is diaplyed in static text of
// combo box).

DWORD CurrentElement;

// handle of active color dialogs box.  Used by rectangle custom control.

HWND hDlgColor;

BOOL
InitColorDlg(
    IN HWND  hdlg
    );

VOID
CenterDialog(
    HWND hwnd
    )

/*++

Routine Description:

    Centers a dialog relative to the app's main window

Arguments:

    hwnd - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    LONG  sx = GetSystemMetrics(SM_CXSCREEN),
          sy = GetSystemMetrics(SM_CYSCREEN);

    point.x = point.y = 0;
    ClientToScreen(hwndFrame,&point);
    GetWindowRect (hwnd     ,&rcWindow);
    GetClientRect (hwndFrame,&rcFrame );

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    if (x + w > sx) {
        x = sx - w;
    } else if (x < 0) {
        x = 0;
    }
    if (y + h > sy) {
        y = sy - h;
    } else if (y < 0) {
        y = 0;
    }

    MoveWindow(hwnd,x,y,w,h,FALSE);
}

BOOL CALLBACK
MinMaxDlgProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the enter size dialog box.  This dialog
    allows the user to enter a size for a partition, or use
    spin controls (a tiny scroll bar) to select the size.
    Possible outcomes are cancel or OK.  In the latter case the
    EndDialog code is the size.  In the former it is 0.

Arguments:

    hwnd - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    TCHAR             outputString[MESSAGE_BUFFER_SIZE];
    PMINMAXDLG_PARAMS params;
    BOOL              validNumber;
    DWORD             sizeMB;
    static DWORD      minSizeMB,
                      maxSizeMB,
                      helpContextId;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hwnd);
        params = (PMINMAXDLG_PARAMS)lParam;
        // set up caption

        LoadString(hModule, params->CaptionStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetWindowText(hwnd, outputString);

        // set up minimum/maximum text

        LoadString(hModule, params->MinimumStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hwnd, IDC_MINMAX_MINLABEL, outputString);
        LoadString(hModule, params->MaximumStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hwnd, IDC_MINMAX_MAXLABEL, outputString);
        LoadString(hModule, params->SizeStringID, outputString, sizeof(outputString)/sizeof(TCHAR));
        SetDlgItemText(hwnd, IDC_MINMAX_SIZLABEL, outputString);

        minSizeMB = params->MinSizeMB;
        maxSizeMB = params->MaxSizeMB;
        helpContextId = params->HelpContextId;

        wsprintf(outputString, TEXT("%u"), minSizeMB);
        SetDlgItemText(hwnd, IDC_MINMAX_MIN, outputString);
        wsprintf(outputString, TEXT("%u"), maxSizeMB);
        SetDlgItemText(hwnd, IDC_MINMAX_MAX, outputString);

        // also put the size in the edit control and select the text

        wsprintf(outputString, TEXT("%u"), maxSizeMB);
        SetDlgItemText(hwnd, IDC_MINMAX_SIZE, outputString);
        SendDlgItemMessage(hwnd, IDC_MINMAX_SIZE, EM_SETSEL, 0, -1);
        SetFocus(GetDlgItem(hwnd, IDC_MINMAX_SIZE));
        return FALSE;      // indicate focus set to a control

    case WM_VSCROLL:

        switch (LOWORD(wParam)) {
        case SB_LINEDOWN:
        case SB_LINEUP:
            sizeMB = GetDlgItemInt(hwnd, IDC_MINMAX_SIZE, &validNumber, FALSE);
            if (!validNumber) {
                Beep(500,100);
            } else {
                if (((sizeMB > minSizeMB) && (LOWORD(wParam) == SB_LINEDOWN))
                 || ((sizeMB < maxSizeMB) && (LOWORD(wParam) == SB_LINEUP  )))
                {
                    if (sizeMB > maxSizeMB) {
                        sizeMB = maxSizeMB;
                    } else if (LOWORD(wParam) == SB_LINEUP) {
                        sizeMB++;
                    } else {
                        sizeMB--;
                    }
                    wsprintf(outputString, TEXT("%u"), sizeMB);
                    SetDlgItemText(hwnd, IDC_MINMAX_SIZE, outputString);
                    SendDlgItemMessage(hwnd, IDC_MINMAX_SIZE, EM_SETSEL, 0, -1);
                } else {
                    Beep(500,100);
                }
            }
        }
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            sizeMB = GetDlgItemInt(hwnd, IDC_MINMAX_SIZE, &validNumber, FALSE);
            if (!validNumber || !sizeMB || (sizeMB > maxSizeMB) || (sizeMB < minSizeMB)) {
                ErrorDialog(MSG_INVALID_SIZE);
            } else {
                EndDialog(hwnd, sizeMB);
            }
            break;

        case IDCANCEL:

            EndDialog(hwnd, 0);
            break;

        case FD_IDHELP:

            DialogHelp(helpContextId);
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK
DriveLetterDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog for allowing the user to select a drive letter for a
    partition, logical drive, volume set, or stripe set.

    The EndDialog codes are as follows:

        0 - user cancelled
        NO_DRIVE_LETTER_EVER - user opted not to assign a drive letter
        other - the drive letter chosen by the user

Arguments:

    hdlg - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    static HWND        hwndCombo;
    static DWORD       currentSelection;
    TCHAR              driveLetter;
    TCHAR              driveLetterString[3];
    DWORD              defRadioButton,
                       selection;
    PREGION_DESCRIPTOR regionDescriptor;
    PFT_OBJECT         ftObject;
    TCHAR              description[256];

    switch (msg) {

    case WM_INITDIALOG:

        // lParam points to the region descriptor

        regionDescriptor = (PREGION_DESCRIPTOR)lParam;
        FDASSERT(DmSignificantRegion(regionDescriptor));

        hwndCombo = GetDlgItem(hdlg,IDC_DRIVELET_COMBOBOX);
        CenterDialog(hdlg);

        // Add each available drive letter to the list of available
        // drive letters.

        driveLetterString[1] = TEXT(':');
        driveLetterString[2] = 0;
        for (driveLetter='C'; driveLetter <= 'Z'; driveLetter++) {
            if (DriveLetterIsAvailable((CHAR)driveLetter)) {
                *driveLetterString = driveLetter;
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            }
        }

        // Format the description of the partition.

        if (ftObject = GET_FT_OBJECT(regionDescriptor)) {

            TCHAR descr[256];
            DWORD resid = 0;

            // Ft.  Description is something like "Stripe set with parity #0"

            switch (ftObject->Set->Type) {
            case Mirror:
                resid = IDS_DLGCAP_MIRROR;
                break;
            case Stripe:
                resid = IDS_STATUS_STRIPESET;
                break;
            case StripeWithParity:
                resid = IDS_DLGCAP_PARITY;
                break;
            case VolumeSet:
                resid = IDS_STATUS_VOLUMESET;
                break;
            default:
                FDASSERT(FALSE);
            }

            LoadString(hModule, resid, descr, sizeof(descr)/sizeof(TCHAR));
            wsprintf(description, descr, ftObject->Set->Ordinal);

        } else {

            // Non-ft.  Description is something like '500 MB Unformatted
            // logical drive on disk 3' or '400 MB HPFS partition on disk 4'

            LPTSTR args[4];
            TCHAR  sizeStr[20],
                   partTypeStr[100],
                   diskNoStr[10],
                   typeName[150];
            TCHAR  formatString[256];

            args[0] = sizeStr;
            args[1] = typeName;
            args[2] = partTypeStr;
            args[3] = diskNoStr;

            wsprintf(sizeStr, "%u", regionDescriptor->SizeMB);
            wsprintf(typeName, "%ws", PERSISTENT_DATA(regionDescriptor)->TypeName);
            LoadString(hModule, regionDescriptor->RegionType == REGION_LOGICAL ? IDS_LOGICALVOLUME : IDS_PARTITION, partTypeStr, sizeof(partTypeStr)/sizeof(TCHAR));
            wsprintf(diskNoStr, "%u", regionDescriptor->Disk);

            LoadString(hModule, IDS_DRIVELET_DESCR, formatString, sizeof(formatString)/sizeof(TCHAR));
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          formatString,
                          0,
                          0,
                          description,
                          sizeof(description),
                          (va_list *)args);
        }

        SetWindowText(GetDlgItem(hdlg, IDC_DRIVELET_DESCR), description);
        driveLetter = (TCHAR)PERSISTENT_DATA(regionDescriptor)->DriveLetter;

        if ((driveLetter != NO_DRIVE_LETTER_YET) && (driveLetter != NO_DRIVE_LETTER_EVER)) {

            DWORD itemIndex;

            // There is a default drive letter.  Place it on the list,
            // check the correct radio button, and set the correct default
            // in the combo box.

            driveLetterString[0] = (TCHAR)driveLetter;
            itemIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)driveLetterString);
            SendMessage(hwndCombo, CB_SETCURSEL, itemIndex, 0);
            defRadioButton = IDC_DRIVELET_RBASSIGN;
            SetFocus(hwndCombo);
            currentSelection = itemIndex;

        } else {

            // Default is no drive letter.  Disable the combo box.  Select
            // the correct radio button.

            EnableWindow(hwndCombo, FALSE);
            defRadioButton = IDC_DRIVELET_RBNOASSIGN;
            SendMessage(hwndCombo, CB_SETCURSEL, (DWORD)(-1), 0);
            SetFocus(GetDlgItem(hdlg, IDC_DRIVELET_RBNOASSIGN));
            currentSelection = 0;
        }

        CheckRadioButton(hdlg, IDC_DRIVELET_RBASSIGN, IDC_DRIVELET_RBNOASSIGN, defRadioButton);
        return FALSE;      // focus set to control

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            // If the 'no letter' button is checked, return NO_DRIVE_LETTER_EVER

            if (IsDlgButtonChecked(hdlg, IDC_DRIVELET_RBNOASSIGN)) {
                EndDialog(hdlg, NO_DRIVE_LETTER_EVER);
                break;
            }

            // Otherwise, get the currently selected item in the listbox.

            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo, CB_GETLBTEXT, selection, (LONG)driveLetterString);
            EndDialog(hdlg,(int)(unsigned)(*driveLetterString));
            break;

        case IDCANCEL:

            EndDialog(hdlg, 0);
            break;

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_DRIVELETTER);
            break;

        case IDC_DRIVELET_RBASSIGN:

            if (HIWORD(wParam) == BN_CLICKED) {
                EnableWindow(hwndCombo, TRUE);
                SendMessage(hwndCombo, CB_SETCURSEL, currentSelection, 0);
                SetFocus(hwndCombo);
            }
            break;

        case IDC_DRIVELET_RBNOASSIGN:

            if (HIWORD(wParam) == BN_CLICKED) {
                currentSelection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                SendMessage(hwndCombo, CB_SETCURSEL, (DWORD)-1, 0);
                EnableWindow(hwndCombo, FALSE);
            }
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK
DisplayOptionsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for display options.  Currently the only display option
    is to alter the graph type (proportional/equal) on each disk.

    For this dialog, lParam on creation must point to a buffer into which
    this dialog procedure will place the user's new choices for the graph
    display type for each disk.

Arguments:

    hdlg - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    static PBAR_TYPE newBarTypes;
    static HWND      hwndCombo;
    DWORD            selection;
    DWORD            i;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hdlg);
        newBarTypes = (PBAR_TYPE)lParam;
        hwndCombo = GetDlgItem(hdlg, IDC_DISK_COMBOBOX);

        // Add each disk to the combo box.

        for (i=0; i<DiskCount; i++) {

            TCHAR str[10];

            wsprintf(str,TEXT("%u"),i);
            SendMessage(hwndCombo, CB_ADDSTRING, 0, (DWORD)str);
        }

        // select the zeroth item in the combobox
        SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
        SendMessage(hdlg,
                    WM_COMMAND,
                    MAKELONG(IDC_DISK_COMBOBOX,CBN_SELCHANGE),
                    0);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            EndDialog(hdlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case FD_IDHELP:
            DialogHelp(HC_DM_DLG_DISPLAYOPTION);
            break;

        case IDC_DISK_COMBOBOX:

            if (HIWORD(wParam) == CBN_SELCHANGE) {

                int rb = 0;

                // Selection in the combobox has changed; update the radio buttons

                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);

                switch (newBarTypes[selection]) {
                case BarProportional:
                    rb = IDC_RBPROPORTIONAL;
                    break;
                case BarEqual:
                    rb = IDC_RBEQUAL;
                    break;
                case BarAuto:
                    rb = IDC_RBAUTO;
                    break;
                default:
                    FDASSERT(0);
                }

                CheckRadioButton(hdlg, IDC_RBPROPORTIONAL, IDC_RBAUTO, rb);
            }
            break;

        case IDC_RESETALL:

            if (HIWORD(wParam) == BN_CLICKED) {
                for (i=0; i<DiskCount; i++) {
                    newBarTypes[i] = BarAuto;
                }
                CheckRadioButton(hdlg, IDC_RBPROPORTIONAL, IDC_RBAUTO, IDC_RBAUTO);
            }
            break;

        case IDC_RBPROPORTIONAL:

            if (HIWORD(wParam) == BN_CLICKED) {
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                newBarTypes[selection] = BarProportional;
            }
            break;

        case IDC_RBEQUAL:

            if (HIWORD(wParam) == BN_CLICKED) {
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                newBarTypes[selection] = BarEqual;
            }
            break;

        case IDC_RBAUTO:

            if (HIWORD(wParam) == BN_CLICKED) {
                selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                newBarTypes[selection] = BarAuto;
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK
ColorDlgProc(
    IN HWND    hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog for the select colors/patterns dialog box.  Note that this dialog
    uses a rectangle custom control, defined below.

Arguments:

    hwnd - window handle of dialog box

    msg - message #

    wParam - msg specific data

    lParam - msg specific data

Return Value:

    msg dependent

--*/

{
    unsigned i;

    switch (msg) {

    case WM_INITDIALOG:

        #if BRUSH_ARRAY_SIZE != LEGEND_STRING_COUNT
        #error legend label array and brush array are out of sync
        #endif

        if (!InitColorDlg(hdlg)) {
            EndDialog(hdlg, -1);
        }
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            for (i=0; i<LEGEND_STRING_COUNT; i++) {
                SelectedColor[i] -= IDC_COLOR1;
                SelectedHatch[i] -= IDC_PATTERN1;
            }
            EndDialog(hdlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case FD_IDHELP:
            DialogHelp(HC_DM_COLORSANDPATTERNS);
            break;

        case IDC_COLORDLGCOMBO:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                // deselect previous color
                SendMessage(GetDlgItem(hdlg, SelectedColor[CurrentElement]),
                            RM_SELECT,
                            FALSE,
                            0);
                // deselect previous pattern
                SendMessage(GetDlgItem(hdlg, SelectedHatch[CurrentElement]),
                            RM_SELECT,
                            FALSE,
                            0);
                CurrentElement = SendMessage((HWND)lParam, CB_GETCURSEL, 0, 0);
                SendMessage(hdlg, WM_COMMAND, MAKELONG(SelectedColor[CurrentElement], 0), 0);
                SendMessage(hdlg, WM_COMMAND, MAKELONG(SelectedHatch[CurrentElement], 0), 0);
                break;
            default:
                return FALSE;
            }
            break;

        case IDC_COLOR1:
        case IDC_COLOR2:
        case IDC_COLOR3:
        case IDC_COLOR4:
        case IDC_COLOR5:
        case IDC_COLOR6:
        case IDC_COLOR7:
        case IDC_COLOR8:
        case IDC_COLOR9:
        case IDC_COLOR10:
        case IDC_COLOR11:
        case IDC_COLOR12:
        case IDC_COLOR13:
        case IDC_COLOR14:
        case IDC_COLOR15:
        case IDC_COLOR16:
            // deselect previous color

            SendMessage(GetDlgItem(hdlg, SelectedColor[CurrentElement]),
                        RM_SELECT,
                        FALSE,
                        0);
            SendMessage(GetDlgItem(hdlg, LOWORD(wParam)),
                        RM_SELECT,
                        TRUE,
                        0);
            SelectedColor[CurrentElement] = LOWORD(wParam);

            // now force patterns to be redrawn in selected color

            for (i=IDC_PATTERN1; i<=IDC_PATTERN5; i++) {
                InvalidateRect(GetDlgItem(hdlg, i), NULL, FALSE);
            }
            break;

        case IDC_PATTERN1:
        case IDC_PATTERN2:
        case IDC_PATTERN3:
        case IDC_PATTERN4:
        case IDC_PATTERN5:
            // deselect previous pattern
            SendMessage(GetDlgItem(hdlg, SelectedHatch[CurrentElement]),
                        RM_SELECT,
                        FALSE,
                        0);
            SendMessage(GetDlgItem(hdlg, LOWORD(wParam)),
                        RM_SELECT,
                        TRUE,
                        0);
            SelectedHatch[CurrentElement] = LOWORD(wParam);
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL
InitColorDlg(
    IN HWND  hdlg
    )

/*++

Routine Description:

    Initialize the color selection dialog.

Arguments:

    hdlg - the dialog handle.

Return Value:

    TRUE - successfully set up the dialog.

--*/

{
    unsigned i;
    LONG     ec;
    HWND     hwndCombo = GetDlgItem(hdlg, IDC_COLORDLGCOMBO);

    hDlgColor = hdlg;

    CenterDialog(hdlg);

    for (i=0; i<LEGEND_STRING_COUNT; i++) {
        ec = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)LegendLabels[i]);
        if ((ec == CB_ERR) || (ec == CB_ERRSPACE)) {
            return FALSE;
        }
        SelectedColor[i] = IDC_COLOR1 + BrushColors[i];
        SelectedHatch[i] = IDC_PATTERN1 + BrushHatches[i];
    }
    SendMessage(hwndCombo, CB_SETCURSEL, CurrentElement=0, 0);
    SendMessage(hdlg, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndCombo), CBN_SELCHANGE), (LONG)hwndCombo);
    return TRUE;
}

LONG
RectWndProc(
    IN HWND  hwnd,
    IN DWORD msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This is a pre-process routine for all access to the disk
    bar display region of the WinDisk interface.

Arguments:

    hwnd - the dialog handle
    msg  - the windows message for the dialog
    wParam/lParam - windows dialog parameters.

Return Value:

    Standard dialog requirements.

--*/

{
    LONG        res = 1;
    PAINTSTRUCT ps;
    RECT        rc;
    int         CtlID;
    HBRUSH      hbr,
                hbrT;
    DWORD       style;

    switch (msg) {

    case WM_CREATE:

        FDASSERT(GetWindowLong(hwnd, GWL_STYLE) & (RS_PATTERN | RS_COLOR));
        SetWindowWord(hwnd, GWW_SELECTED, FALSE);
        break;

    case WM_LBUTTONDOWN:

        SetFocus(hwnd);
        break;

    case WM_SETFOCUS:

        SendMessage(GetParent(hwnd), WM_COMMAND, MAKELONG(GetDlgCtrlID(hwnd), RN_CLICKED), (LONG)hwnd);
        break;

    case WM_PAINT:

        GetClientRect(hwnd, &rc);
        CtlID = GetDlgCtrlID(hwnd);
        BeginPaint(hwnd, &ps);

        hbr = CreateSolidBrush(GetWindowWord(hwnd, GWW_SELECTED)
                               ? (~GetSysColor(COLOR_WINDOW)) & 0xffffff
                               : GetSysColor(COLOR_WINDOW));
        hbrT = SelectObject(ps.hdc,hbr);
        SelectObject(ps.hdc, hPenNull);
        Rectangle(ps.hdc, rc.left, rc.top, rc.right, rc.bottom);

        if (hbrT) {
            SelectObject(ps.hdc, hbrT);
        }
        DeleteObject(hbr);

        InflateRect(&rc, -2, -2);
        rc.right--;
        rc.bottom--;

        if (GetWindowLong(hwnd, GWL_STYLE) & RS_COLOR) {
            hbr = CreateSolidBrush(AvailableColors[CtlID-IDC_COLOR1]);
        } else {
            hbr = CreateHatchBrush(AvailableHatches[CtlID-IDC_PATTERN1], AvailableColors[SelectedColor[SendMessage(GetDlgItem(hDlgColor, IDC_COLORDLGCOMBO), CB_GETCURSEL, 0, 0)]-IDC_COLOR1]);
        }

        hbrT = SelectObject(ps.hdc, hbr);
        SelectObject(ps.hdc, hPenThinSolid);
        Rectangle(ps.hdc, rc.left, rc.top, rc.right, rc.bottom);

        if (hbrT) {
            SelectObject(ps.hdc, hbrT);
        }

        DeleteObject(hbr);

        EndPaint(hwnd, &ps);
        break;

    case RM_SELECT:

        // wParam = TRUE/FALSE for selected/not selected

        if (GetWindowWord(hwnd, GWW_SELECTED) != (WORD)wParam) {

            SetWindowWord(hwnd, GWW_SELECTED, (WORD)wParam);
            InvalidateRect(hwnd, NULL, FALSE);

            // make keyboard interface work correctly

            style = (DWORD)GetWindowLong(hwnd, GWL_STYLE);
            style = wParam ? style | WS_TABSTOP : style & ~WS_TABSTOP;
            SetWindowLong(hwnd, GWL_STYLE, (LONG)style);
        }

        break;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return res;
}

VOID
InitRectControl(
    VOID
    )

/*++

Routine Description:

    Register the windows class for the selection control.

Arguments:

    None

Return Value:

    None

--*/

{
    WNDCLASS wc;

    wc.style         = 0;
    wc.lpfnWndProc   = RectWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = RECTCONTROL_WNDEXTRA;
    wc.hInstance     = hModule;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = TEXT(RECTCONTROL);

    RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fddata.c ===
#include "fdisk.h"


HANDLE  hModule;

// IsDiskRemovable is an array of BOOLEANs each of which indicates
// whether the corresponding physical disk is removable.

PBOOLEAN IsDiskRemovable = NULL;

// RemovableDiskReservedDriveLetters is an array of CHARs which
// shows the reserved drive letter for each disk if that disk is
// removable.

PCHAR        RemovableDiskReservedDriveLetters;

// This will be an array of pointers to DISKSTATE structures, indexed
// by disk number.

PDISKSTATE *Disks;

// BootDiskNumber is the number of the disk on which the boot partition
// (ie. the disk with the WinNt files) resides.  BootPartitionNumber is
// the original partition number of this partition.

ULONG   BootDiskNumber;
ULONG   BootPartitionNumber;


// window handles

HANDLE  hwndFrame,
        hwndList;

// GDI objects

HBITMAP  hBitmapSmallDisk;
HBITMAP  hBitmapRemovableDisk;
HDC      hDC;
HFONT    hFontGraph,
         hFontGraphBold;
HBRUSH   Brushes[BRUSH_ARRAY_SIZE];
HBRUSH   hBrushFreeLogical,
         hBrushFreePrimary;
HPEN     hPenNull,
         hPenThinSolid;
HCURSOR  hcurWait,
         hcurNormal;


// initial stuff for the disk graphs, used when there is
// no info in win.ini.

int      BrushHatches[BRUSH_ARRAY_SIZE] = { DEFAULT_HATCH_USEDPRIMARY,
                                            DEFAULT_HATCH_USEDLOGICAL,
                                            DEFAULT_HATCH_STRIPESET,
                                            DEFAULT_HATCH_MIRROR,
                                            DEFAULT_HATCH_VOLUMESET
                                          };

int      BrushColors[BRUSH_ARRAY_SIZE] = { DEFAULT_COLOR_USEDPRIMARY,
                                           DEFAULT_COLOR_USEDLOGICAL,
                                           DEFAULT_COLOR_STRIPESET,
                                           DEFAULT_COLOR_MIRROR,
                                           DEFAULT_COLOR_VOLUMESET
                                         };

// colors and patterns available for the disk graphs

COLORREF AvailableColors[NUM_AVAILABLE_COLORS] = { RGB(0,0,0),       // black
                                                   RGB(128,128,128), // dark gray
                                                   RGB(192,192,192), // light gray
                                                   RGB(255,255,255), // white
                                                   RGB(128,128,0),   // dark yellow
                                                   RGB(128,0,128),   // violet
                                                   RGB(128,0,0),     // dark red
                                                   RGB(0,128,128),   // dark cyan
                                                   RGB(0,128,0),     // dark green
                                                   RGB(0,0,128),     // dark blue
                                                   RGB(255,255,0),   // yellow
                                                   RGB(255,0,255),   // light violet
                                                   RGB(255,0,0),     // red
                                                   RGB(0,255,255),   // cyan
                                                   RGB(0,255,0),     // green
                                                   RGB(0,0,255)      // blue
                                                 };

int      AvailableHatches[NUM_AVAILABLE_HATCHES] = { 2,3,4,5,6 };


// positions for various items in a disk graph

DWORD GraphWidth,
      GraphHeight;
DWORD BarTopYOffset,
      BarBottomYOffset,
      BarHeight;
DWORD dxDriveLetterStatusArea;
DWORD dxBarTextMargin,
      dyBarTextLine;
DWORD dxSmallDisk,
      dySmallDisk,
      xSmallDisk,
      ySmallDisk;
DWORD dxRemovableDisk,
      dyRemovableDisk,
      xRemovableDisk,
      yRemovableDisk;
DWORD BarLeftX,
      BarWidth;


// if a single disk region is selected, these vars describe the selection.

PDISKSTATE SingleSel;
DWORD      SingleSelIndex;

// name of help file

PTCHAR HelpFile;
TCHAR  WinHelpFile[] = TEXT("windisk.hlp");
TCHAR  LanmanHelpFile[] = TEXT("windiska.hlp");


// number of hard disks attached to the system

unsigned DiskCount = 0;

// class name for frame window

TCHAR   szFrame[] = TEXT("fdFrame");

// "Disk %u"

LPTSTR  DiskN;

PWSTR wszUnformatted,
      wszNewUnformatted,
      wszUnknown;

// If the following is TRUE, the registry needs to be updated and the user will
// be prompted to save changed just as if he had made changes to any partitions.

BOOL RegistryChanged = FALSE;

// Restart required to make changes work.

BOOL RestartRequired = FALSE;


// If the following is TRUE, the main window will pass WM_ENTERIDLE
// messages on to the child dialog box; this will trigger the
// configuration search.

BOOL ConfigurationSearchIdleTrigger = FALSE;

// This flag indicates whether this is a Server
// or just regular Windows NT Workstation.

BOOL IsLanmanNt = FALSE;

// This flag indicates whether double space volume creation
// and deletion is allowed.

BOOL IsFullDoubleSpace = FALSE;

// Cdrom is present in the system.

ULONG AllowCdRom = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdhelpid.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fdhelpid.h

Abstract:

    Context ids for context-sensitive help for the disk manager

Author:

    Ted Miller (tedm) 18-March-1992

Revision History:

--*/


//
// All ids in this file start with HC_DM, as in "Help Context for Disk Manager"
//

//
// Menu items.  In the form HC_DM_MENU_xxx, where xxx matches the name used
// in the resource file (fdisk.rc) for the menu item (of the form IDM_xxx).
//

//
// The partition menu
//

#define         HC_DM_MENU_PARTITIONCREATE          110
#define         HC_DM_MENU_PARTITIONCREATEEX        111
#define         HC_DM_MENU_PARTITIONDELETE          112
#define         HC_DM_MENU_FTCREATEVOLUMESET        113
#define         HC_DM_MENU_FTEXTENDVOLUMESET        114
#define         HC_DM_MENU_FTCREATESTRIPE           115
#if i386
#define         HC_DM_MENU_PARTITIONACTIVE          116
#endif
#define         HC_DM_MENU_PARTITIONLETTER          117 // really in tools menu
#define         HC_DM_MENU_PARTITIONEXIT            118
#define         HC_DM_MENU_SECURESYSTEM             119
#define         HC_DM_MENU_COMMIT                   120

//
// The configuration menu
//

#define         HC_DM_MENU_CONFIGMIGRATE            210
#define         HC_DM_MENU_CONFIGSAVE               211
#define         HC_DM_MENU_CONFIGRESTORE            212
#define         HC_DM_MENU_CONFIG                   213

//
// The fault tolerance menu
//

#define         HC_DM_MENU_FTESTABLISHMIRROR        310
#define         HC_DM_MENU_FTBREAKMIRROR            311
#define         HC_DM_MENU_FTCREATEPSTRIPE          312
#define         HC_DM_MENU_FTRECOVERSTRIPE          313

//
// The tools menu
//

#define         HC_DM_MENU_AUTOMOUNT                610
#define         HC_DM_MENU_DBLSPACE                 611
#define         HC_DM_MENU_CDROM                    612
#define         HC_DM_MENU_FORMAT                   613
#define         HC_DM_MENU_LABEL                    614

//
// The options menu
//

#define         HC_DM_MENU_OPTIONSSTATUS            410
#define         HC_DM_MENU_OPTIONSLEGEND            411
#define         HC_DM_MENU_OPTIONSCOLORS            412
#define         HC_DM_MENU_OPTIONSDISPLAY           413

//
// The help menu
//

#define         HC_DM_MENU_HELPCONTENTS             510
#define         HC_DM_MENU_HELPSEARCH               511
#define         HC_DM_MENU_HELPHELP                 512
#define         HC_DM_MENU_HELPABOUT                513


//
// The system menu
//

#define         HC_DM_SYSMENU_RESTORE               910
#define         HC_DM_SYSMENU_MOVE                  911
#define         HC_DM_SYSMENU_SIZE                  912
#define         HC_DM_SYSMENU_MINIMIZE              913
#define         HC_DM_SYSMENU_MAXIMIZE              914
#define         HC_DM_SYSMENU_CLOSE                 915
#define         HC_DM_SYSMENU_SWITCHTO              916

//
// Dialog boxes.  In the form HC_DM_DLG_xxx, where xxx is some reasonably
// descriptive name for the dialog.
//
//
// These dialog boxes do not have help buttons:
//
//      - About
//      - Searching for Previous Installation
//      - Confirmation dialogs

//
// Min/Max dialogs for creating various items
//

#define         HC_DM_DLG_CREATEPRIMARY             1010
#define         HC_DM_DLG_CREATEEXTENDED            1011
#define         HC_DM_DLG_CREATELOGICAL             1012
#define         HC_DM_DLG_CREATEVOLUMESET           1013
#define         HC_DM_DLG_EXTENDVOLUMESET           1014
#define         HC_DM_DLG_CREATESTRIPESET           1015
#define         HC_DM_DLG_CREATEPARITYSTRIPE        1016

//
// Dialog for assigning drive letters
//

#define         HC_DM_DLG_DRIVELETTER               1020

//
// Dialog for determining display sizing
//

#define         HC_DM_DLG_DISPLAYOPTION             1030

//
// Configuration migration dialog to select previous installation
//

#define         HC_DM_DLG_SELECTINSTALLATION        1040

//
// Colors and patterns dialog
//

#define         HC_DM_COLORSANDPATTERNS             1050

//
// DoubleSpace dialog
//

#define         HC_DM_DLG_DOUBLESPACE               1060
#define         HC_DM_DLG_DOUBLESPACE_MOUNT         1061

//
// Format dialog
//

#define         HC_DM_DLG_FORMAT                    1070

//
// Label dialog
//

#define         HC_DM_DLG_LABEL                     1080

//
// CdRom dialog
//

#define         HC_DM_DLG_CDROM                     1090
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdglob.h ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    fdglob.h

Abstract:

    Global data

Author:

    Ted Miller (tedm) 7-Jan-1992

Revisions:

    11-Nov-93 (bobri) double space and commit support.

--*/

// from fddata.c

extern HANDLE       hModule;
extern PBOOLEAN     IsDiskRemovable;
extern PCHAR        RemovableDiskReservedDriveLetters;
extern PDISKSTATE  *Disks;
extern ULONG        BootDiskNumber;
extern ULONG        BootPartitionNumber;
extern HANDLE       hwndFrame,
                    hwndList;

extern HBITMAP      hBitmapSmallDisk;
extern HBITMAP      hBitmapRemovableDisk;
extern HDC          hDC;
extern HFONT        hFontGraph,
                    hFontGraphBold;
extern HBRUSH       Brushes[BRUSH_ARRAY_SIZE];
extern HBRUSH       hBrushFreeLogical,
                    hBrushFreePrimary;
extern HPEN         hPenNull,
                    hPenThinSolid;
extern HCURSOR      hcurWait,
                    hcurNormal;

extern int          BrushHatches[BRUSH_ARRAY_SIZE];
extern int          BrushColors[BRUSH_ARRAY_SIZE];

extern COLORREF     AvailableColors[NUM_AVAILABLE_COLORS];
extern int          AvailableHatches[NUM_AVAILABLE_HATCHES];

extern DWORD        GraphWidth,
                    GraphHeight;
extern DWORD        BarTopYOffset,
                    BarBottomYOffset,
                    BarHeight;
extern DWORD        dxDriveLetterStatusArea;
extern DWORD        dxBarTextMargin,
                    dyBarTextLine;
extern DWORD        dxSmallDisk,
                    dySmallDisk,
                    xSmallDisk,
                    ySmallDisk;
extern DWORD        dxRemovableDisk,
                    dyRemovableDisk,
                    xRemovableDisk,
                    yRemovableDisk;
extern DWORD        BarLeftX,BarWidth;

extern PDISKSTATE   SingleSel;
extern DWORD        SingleSelIndex;

extern TCHAR        WinHelpFile[];
extern TCHAR        LanmanHelpFile[];
extern PTCHAR       HelpFile;

extern unsigned     DiskCount;

extern TCHAR        szFrame[];
extern LPTSTR       DiskN;
extern PWSTR        wszUnformatted,
                    wszNewUnformatted,
                    wszUnknown;

extern BOOL         RegistryChanged;
extern BOOL         RestartRequired;

extern BOOL         ConfigurationSearchIdleTrigger;
extern BOOL         IsLanmanNt;
extern BOOL         IsFullDoubleSpace;

// from fdstleg.c

extern HFONT        hFontStatus,
                    hFontLegend;
extern DWORD        dyLegend,
                    wLegendItem;
extern DWORD        dyStatus,
                    dyBorder;
extern TCHAR       *LegendLabels[LEGEND_STRING_COUNT];
extern BOOL         StatusBar,
                    Legend;
extern TCHAR        StatusTextStat[STATUS_TEXT_SIZE];
extern TCHAR        StatusTextSize[STATUS_TEXT_SIZE];
extern WCHAR        StatusTextDrlt[3];
extern WCHAR        StatusTextType[STATUS_TEXT_SIZE];
extern WCHAR        StatusTextVoll[STATUS_TEXT_SIZE];

// from fdlistbx.c

extern DWORD        LBCursorListBoxItem,
                    LBCursorRegion;

// from fdprof.c

extern int          ProfileWindowX,
                    ProfileWindowY,
                    ProfileWindowW,
                    ProfileWindowH;
extern BOOL         ProfileIsMaximized,
                    ProfileIsIconic;

// from fddlgs.c

extern DWORD        SelectedColor[LEGEND_STRING_COUNT];
extern DWORD        SelectedHatch[LEGEND_STRING_COUNT];

// from fdft.c

extern PFT_OBJECT_SET FtObjects;

// For CdRoms

extern ULONG          AllowCdRom;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdengine.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fdengine.c

Abstract:

    This module contains the disk partitioning engine.  The code
    in this module can be compiled for either the NT platform
    or the ARC platform (-DARC).

Author:

    Ted Miller        (tedm)    Nov-1991

Revision History:

    Bob Rinne         (bobri)   Feb-1994
    Moved as actual part of Disk Administrator enlistment instead of being
    copied from ArcInst.  This is due to dynamic partition changes.  Removed
    string table that made this an internationalized file.

--*/

#include "fdisk.h"

#include <stdio.h>
#include <stdlib.h>

// Attached disk devices.

ULONG              CountOfDisks;
PCHAR             *DiskNames;

// Information about attached disks.

DISKGEOM          *DiskGeometryArray;

PPARTITION        *PrimaryPartitions,
                  *LogicalVolumes;

// A 'signature' is a unique 4-byte value immediately preceeding the
// partition table in the MBR.

PULONG             Signatures;

// Array keeping track of whether each disk is off line.

PBOOLEAN           OffLine;

// Keeps track of whether changes have been requested
// to each disk's partition structure.

BOOLEAN           *ChangesRequested;
BOOLEAN           *ChangesCommitted;


// Value used to indicate that the partition entry has changed but in a non-
// destructive way (ie, made active/inactive).

#define CHANGED_DONT_ZAP ((BOOLEAN)(5))

// forward declarations


STATUS_CODE
OpenDisks(
    VOID
    );

VOID
CloseDisks(
    VOID
    );

STATUS_CODE
GetGeometry(
    VOID
    );

BOOLEAN
CheckIfDiskIsOffLine(
    IN ULONG Disk
    );

STATUS_CODE
InitializePartitionLists(
    VOID
    );

STATUS_CODE
GetRegions(
    IN  ULONG               Disk,
    IN  PPARTITION          p,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount,
    IN  REGION_TYPE         RegionType
    );

BOOLEAN
AddRegionEntry(
    IN OUT PREGION_DESCRIPTOR *Regions,
    IN OUT ULONG              *RegionCount,
    IN     ULONG               SizeMB,
    IN     REGION_TYPE         RegionType,
    IN     PPARTITION          Partition,
    IN     LARGE_INTEGER       AlignedRegionOffset,
    IN     LARGE_INTEGER       AlignedRegionSize
    );

VOID
AddPartitionToLinkedList(
    IN PARTITION **Head,
    IN PARTITION *p
    );

BOOLEAN
IsInLinkedList(
    IN PPARTITION p,
    IN PPARTITION List
    );

BOOLEAN
IsInLogicalList(
    IN ULONG      Disk,
    IN PPARTITION p
    );

BOOLEAN
IsInPartitionList(
    IN ULONG      Disk,
    IN PPARTITION p
    );

LARGE_INTEGER
AlignTowardsDiskStart(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    );

LARGE_INTEGER
AlignTowardsDiskEnd(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    );

VOID
FreeLinkedPartitionList(
    IN PARTITION **q
    );

VOID
MergeFreePartitions(
    IN PPARTITION p
    );

VOID
FreePartitionInfoLinkedLists(
    IN PARTITION **ListHeadArray
    );

LARGE_INTEGER
DiskLengthBytes(
    IN ULONG Disk
    );

PPARTITION
AllocatePartitionStructure(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN UCHAR         SysID,
    IN BOOLEAN       Update,
    IN BOOLEAN       Active,
    IN BOOLEAN       Recognized
    );

STATUS_CODE
LowFreeFdiskPathList(
    IN OUT  PCHAR*  PathList,
    IN      ULONG   ListLength
    );

STATUS_CODE
LowQueryFdiskPathList(
    OUT PCHAR  **PathList,
    OUT PULONG   ListLength
    );


STATUS_CODE
FdiskInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the partitioning engine, including allocating
    arrays, determining attached disk devices, and reading their
    partition tables.

Arguments:

    None.

Return Value:

    OK_STATUS or error code.

--*/

{
    STATUS_CODE status;
    ULONG        i;


    if ((status = LowQueryFdiskPathList(&DiskNames, &CountOfDisks)) != OK_STATUS) {
        return status;
    }

    DiskGeometryArray = NULL;
    PrimaryPartitions = NULL;
    LogicalVolumes = NULL;

    if (((DiskGeometryArray      = AllocateMemory(CountOfDisks * sizeof(DISKGEOM  ))) == NULL)
     || ((ChangesRequested       = AllocateMemory(CountOfDisks * sizeof(BOOLEAN   ))) == NULL)
     || ((ChangesCommitted       = AllocateMemory(CountOfDisks * sizeof(BOOLEAN   ))) == NULL)
     || ((PrimaryPartitions      = AllocateMemory(CountOfDisks * sizeof(PPARTITION))) == NULL)
     || ((Signatures             = AllocateMemory(CountOfDisks * sizeof(ULONG     ))) == NULL)
     || ((OffLine                = AllocateMemory(CountOfDisks * sizeof(BOOLEAN   ))) == NULL)
     || ((LogicalVolumes         = AllocateMemory(CountOfDisks * sizeof(PPARTITION))) == NULL))
    {
        RETURN_OUT_OF_MEMORY;
    }

    for (i=0; i<CountOfDisks; i++) {
        PrimaryPartitions[i] = NULL;
        LogicalVolumes[i] = NULL;
        ChangesRequested[i] = FALSE;
        ChangesCommitted[i] = FALSE;
        OffLine[i] = CheckIfDiskIsOffLine(i);
    }

    if (((status = GetGeometry()             ) != OK_STATUS)
     || ((status = InitializePartitionLists()) != OK_STATUS)) {
        return status;
    }

    return OK_STATUS;
}


VOID
FdiskCleanUp(
    VOID
    )

/*++

Routine Description:

    This routine deallocates storage used by the partitioning engine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LowFreeFdiskPathList(DiskNames, CountOfDisks);

    if (DiskGeometryArray != NULL) {
        FreeMemory(DiskGeometryArray);
    }
    if (PrimaryPartitions != NULL) {
        FreePartitionInfoLinkedLists(PrimaryPartitions);
        FreeMemory(PrimaryPartitions);
    }
    if (LogicalVolumes != NULL) {
        FreePartitionInfoLinkedLists(LogicalVolumes);
        FreeMemory(LogicalVolumes);
    }
    if (ChangesRequested != NULL) {
        FreeMemory(ChangesRequested);
    }
    if (ChangesCommitted != NULL) {
        FreeMemory(ChangesCommitted);
    }
    if (OffLine != NULL) {
        FreeMemory(OffLine);
    }
    if (Signatures != NULL) {
        FreeMemory(Signatures);
    }
}


BOOLEAN
CheckIfDiskIsOffLine(
    IN ULONG Disk
    )

/*++

Routine Description:

    Determine whether a disk is off-line by attempting to open it.
    If this is diskman, also attempt to read from it.

Arguments:

    Disk - supplies number of the disk to check

Return Value:

    TRUE if disk is off-line, FALSE is disk is on-line.

--*/

{
    HANDLE_T handle;
    UINT     errorMode;
    BOOLEAN  isOffLine = TRUE;

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    if (LowOpenDisk(GetDiskName(Disk), &handle) == OK_STATUS) {

        ULONG dummy,
              bps;
        PVOID unalignedBuffer,
              buffer;

        // The open might succeed even if the disk is off line.  So to be
        // sure, read the first sector from the disk.

        if (NT_SUCCESS(LowGetDriveGeometry(GetDiskName(Disk), &dummy, &bps, &dummy, &dummy))) {

            unalignedBuffer = Malloc(2*bps);
            buffer = (PVOID)(((ULONG)unalignedBuffer+bps) & ~(bps-1));

            if (NT_SUCCESS(LowReadSectors(handle,bps,0,1,buffer))) {
                isOffLine = FALSE;
            }

            Free(unalignedBuffer);
        } else {

            // It is possible this is a removable drive.

            if (IsRemovable(Disk)) {
                isOffLine = FALSE;
            }
        }
        LowCloseDisk(handle);
    }
    SetErrorMode(errorMode);

    return isOffLine;
}


STATUS_CODE
GetGeometry(
    VOID
    )

/*++

Routine Description:

    This routine determines disk geometry for each disk device.
    Disk geometry includes heads, sectors per track, cylinder count,
    and bytes per sector.  It also includes bytes per track and
    bytes per cylinder, which are calculated from the other values
    for the convenience of the rest of this module.

    Geometry information is placed in the DiskGeometryArray global variable.

    Geometry information is undefined for an off-line disk.

Arguments:

    None.

Return Value:

    OK_STATUS or error code.

--*/

{
    ULONG       i;
    STATUS_CODE status;
    ULONG       TotalSectorCount,
                SectorSize,
                SectorsPerTrack,
                Heads;

    for (i=0; i<CountOfDisks; i++) {

        if (OffLine[i]) {
            continue;
        }

        if ((status = LowGetDriveGeometry(DiskNames[i],&TotalSectorCount,&SectorSize,&SectorsPerTrack,&Heads)) != OK_STATUS) {
            return(status);
        }

        DiskGeometryArray[i].BytesPerSector   = SectorSize;
        DiskGeometryArray[i].SectorsPerTrack  = SectorsPerTrack;
        DiskGeometryArray[i].Heads            = Heads;
        DiskGeometryArray[i].Cylinders.QuadPart = (TotalSectorCount / (SectorsPerTrack * Heads));
        DiskGeometryArray[i].BytesPerTrack    = SectorsPerTrack * SectorSize;
        DiskGeometryArray[i].BytesPerCylinder = SectorsPerTrack * SectorSize * Heads;
    }
    return(OK_STATUS);
}


#if i386
VOID
SetPartitionActiveFlag(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              value
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PPARTITION p = ((PREGION_DATA)Region->Reserved)->Partition;

    if((UCHAR)p->Active != value) {

        //
        // Unfortuneately, the Update flag becomes the RewritePartition flag
        // at commit time.  This causes us to zap the boot sector.  To avoid
        // this, we use a spacial non-boolean value that can be checked for
        // at commit time and that will cause us NOT to zap the bootsector
        // even though RewritePartition will be TRUE.
        //

        p->Active = value;
        if(!p->Update) {
            p->Update = CHANGED_DONT_ZAP;
        }
        ChangesRequested[p->Disk] = TRUE;
    }
}
#endif


VOID
DetermineCreateSizeAndOffset(
    IN  PREGION_DESCRIPTOR Region,
    IN  LARGE_INTEGER      MinimumSize,
    IN  ULONG              CreationSizeMB,
    IN  REGION_TYPE        Type,
    OUT PLARGE_INTEGER     CreationStart,
    OUT PLARGE_INTEGER     CreationSize
    )

/*++

Routine Description:

    Determine the actual offset and size of the partition, given the
    size in megabytes.

Arguments:

    Region  - a region descriptor returned by GetDiskRegions().  Must
              be an unused region.

    MinimumSize - if non-0, this is the minimum size that the partition
        or logical drive can be.

    CreationSizeMB - If MinimumSize is 0, size of partition to create, in MB.

    Type    - REGION_PRIMARY, REGION_EXTENDED, or REGION_LOGICAL, for
              creating a primary partition, extended partition, or
              logical volume, respectively.

    CreationStart - receives the offset where the partition should be placed.

    CreationSize - receives the exact size for the partition.

Return Value:

    None.

--*/

{
    PREGION_DATA  createData = Region->Reserved;
    ULONG         bpc = DiskGeometryArray[Region->Disk].BytesPerCylinder;
    ULONG         bpt = DiskGeometryArray[Region->Disk].BytesPerTrack;
    LARGE_INTEGER cSize,
                  cStart,
                  mod;

    //
    // If we are creating a partition at offset 0, adjust the aligned region
    // offset and the aligned region size, because no partition can actually
    // start at offset 0.
    //

    if (!createData->AlignedRegionOffset.QuadPart) {

        LARGE_INTEGER delta;

        if (Type == REGION_EXTENDED) {
            delta.QuadPart = bpc;
        } else {
            delta.QuadPart = bpt;
        }

        createData->AlignedRegionOffset = delta;
        createData->AlignedRegionSize.QuadPart -= delta.QuadPart;
    }

    cStart = createData->AlignedRegionOffset;
    if (!MinimumSize.QuadPart) {
        cSize.QuadPart = UInt32x32To64(CreationSizeMB, ONE_MEG);
    } else {
        cSize = MinimumSize;
        if (Type == REGION_LOGICAL) {
            cSize.QuadPart += bpt;
        }
    }

    //
    // Decide whether to align the ending cylinder up or down.
    // If the offset of end of the partition is more than half way into the
    // final cylinder, align towrds the disk end.  Otherwise align toward
    // the disk start.
    //

    mod.QuadPart = (cStart.QuadPart + cSize.QuadPart) % bpc;
    if (mod.QuadPart) {

        if ((MinimumSize.QuadPart) || (mod.QuadPart > (bpc/2))) {
            cSize.QuadPart += ((LONGLONG)bpc - mod.QuadPart);
        } else {
            cSize.QuadPart -= mod.QuadPart;  // snap downwards to cyl boundary
        }
    }

    if (cSize.QuadPart > createData->AlignedRegionSize.QuadPart) {

        //
        // Space available in the free space isn't large enough to accomodate
        // the request;  just use the entire free space.
        //

        cSize  = createData->AlignedRegionSize;
    }

    *CreationStart = cStart;
    *CreationSize  = cSize;
}


STATUS_CODE
CreatePartitionEx(
    IN PREGION_DESCRIPTOR Region,
    IN LARGE_INTEGER      MinimumSize,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type,
    IN UCHAR              SysId
    )

/*++

Routine Description:

    This routine creates a partition from a free region on the disk.  The
    partition is always created at the beginning of the free space, and any
    left over space at the end is kept on the free space list.

Arguments:

    Region  - a region descriptor returned by GetDiskRegions().  Must
              be an unused region.

    CreationSizeMB - size of partition to create, in MB.

    Type    - REGION_PRIMARY, REGION_EXTENDED, or REGION_LOGICAL, for
              creating a primary partition, extended pasrtition, or
              logical volume, respectively.

    SysId - system ID byte to be assigned to the partition

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION    p1,
                  p2,
                  p3;
    PREGION_DATA  createData = Region->Reserved;
    LARGE_INTEGER creationStart,
                  creationSize,
                  leftOver,
                  offset,
                  length;
    PPARTITION   *partitionList;

    DetermineCreateSizeAndOffset(Region,
                                 MinimumSize,
                                 CreationSizeMB,
                                 Type,
                                 &creationStart,
                                 &creationSize);

    // now we've got the start and size of the partition to be created.
    // If there's left-over at the beginning of the free space (after
    // alignment), make a new PARTITION structure.

    p1 = NULL;
    offset = createData->Partition->Offset;
    length = createData->Partition->Length;
    leftOver.QuadPart = creationStart.QuadPart - offset.QuadPart;

    if (leftOver.QuadPart > 0) {

        p1 = AllocatePartitionStructure(Region->Disk,
                                        createData->Partition->Offset,
                                        leftOver,
                                        SYSID_UNUSED,
                                        FALSE,
                                        FALSE,
                                        FALSE);
        if (p1 == NULL) {
            RETURN_OUT_OF_MEMORY;
        }
    }

    // make a new partition structure for space being left free as
    // a result of this creation.

    p2 = NULL;
    leftOver.QuadPart = (offset.QuadPart + length.QuadPart) -
                        (creationStart.QuadPart + creationSize.QuadPart);

    if (leftOver.QuadPart) {
        LARGE_INTEGER temp;

        temp.QuadPart = creationStart.QuadPart + creationSize.QuadPart;
        p2 = AllocatePartitionStructure(Region->Disk,
                                        temp,
                                        leftOver,
                                        SYSID_UNUSED,
                                        FALSE,
                                        FALSE,
                                        FALSE);
        if (p2 == NULL) {
            RETURN_OUT_OF_MEMORY;
        }
    }

    // adjust the free partition's fields.

    createData->Partition->Offset = creationStart;
    createData->Partition->Length = creationSize;
    createData->Partition->SysID  = SysId;
    createData->Partition->Update = TRUE;
    createData->Partition->Recognized = TRUE;

    // if we just created an extended partition, show the whole thing
    // as one free logical region.

    if (Type == REGION_EXTENDED) {

        p3 = AllocatePartitionStructure(Region->Disk,
                                        creationStart,
                                        creationSize,
                                        SYSID_UNUSED,
                                        FALSE,
                                        FALSE,
                                        FALSE);
        if (p3 == NULL) {
            RETURN_OUT_OF_MEMORY;
        }
        AddPartitionToLinkedList(&LogicalVolumes[Region->Disk], p3);
    }

    partitionList = (Type == REGION_LOGICAL)
                  ? &LogicalVolumes[Region->Disk]
                  : &PrimaryPartitions[Region->Disk];

    if (p1) {
        AddPartitionToLinkedList(partitionList, p1);
    }
    if (p2) {
        AddPartitionToLinkedList(partitionList, p2);
    }

    MergeFreePartitions(*partitionList);
    ChangesRequested[Region->Disk] = TRUE;
    return(OK_STATUS);
}


STATUS_CODE
CreatePartition(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type
    )
/*++

Routine Description:

    Create a partition.

Arguments:

    Region - A region descriptor pointer.
    CreationSizeMB - the size for the new region.
    Type - the type of region being created.

Return Value:

    OK_STATUS or error code

--*/

{
    LARGE_INTEGER zero;

    zero.QuadPart = 0;
    return CreatePartitionEx(Region,
                             zero,
                             CreationSizeMB,
                             Type,
                             (UCHAR)((Type == REGION_EXTENDED) ? SYSID_EXTENDED
                                                               : SYSID_BIGFAT));
}


STATUS_CODE
DeletePartition(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    This routine deletes a partition, returning its space to the
    free space on the disk.  If deleting the extended partition,
    all logical volumes within it are also deleted.

Arguments:

    Region  - a region descriptor returned by GetDiskRegions().  Must
              be a used region.

Return Value:

    OK_STATUS or error code.

--*/

{
    PREGION_DATA  RegionData = Region->Reserved;
    PPARTITION   *PartitionList;

    if(IsExtended(Region->SysID)) {

        // Deleting extended partition.  Also delete all logical volumes.

        FreeLinkedPartitionList(&LogicalVolumes[Region->Disk]);
    }

    RegionData->Partition->SysID  = SYSID_UNUSED;
    RegionData->Partition->Update = TRUE;
    RegionData->Partition->Active = FALSE;
    RegionData->Partition->OriginalPartitionNumber = 0;

    PartitionList = (Region->RegionType == REGION_LOGICAL)
                  ? &LogicalVolumes[Region->Disk]
                  : &PrimaryPartitions[Region->Disk];

    MergeFreePartitions(*PartitionList);
    ChangesRequested[Region->Disk] = TRUE;
    return OK_STATUS;
}


STATUS_CODE
GetDiskRegions(
    IN  ULONG               Disk,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantPrimaryRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount
    )

/*++

Routine Description:

    This routine returns an array of region descriptors to the caller.
    A region desscriptor describes a space on the disk, either used
    or free.  The caller can control which type of regions are returned.

    The caller must free the returned array via FreeRegionArray().

Arguments:

    Disk            - index of disk whose regions are to be returned

    WantUsedRegions - whether to return used disk regions

    WantFreeRegions - whether to return free disk regions

    WantPrimaryRegions - whether to return regions not in the
                         extended partition

    WantLogicalRegions - whether to return regions within the
                         extended partition

    Region          - where to put a pointer to the array of regions

    RegionCount     - where to put the number of items in the returned
                      Region array

Return Value:

    OK_STATUS or error code.

--*/

{
    *Region = AllocateMemory(0);
    *RegionCount = 0;

    if (WantPrimaryRegions) {
        return GetRegions(Disk,
                          PrimaryPartitions[Disk],
                          WantUsedRegions,
                          WantFreeRegions,
                          WantLogicalRegions,
                          Region,
                          RegionCount,
                          REGION_PRIMARY);
    } else if (WantLogicalRegions) {
        return GetRegions(Disk,
                          LogicalVolumes[Disk],
                          WantUsedRegions,
                          WantFreeRegions,
                          FALSE,
                          Region,
                          RegionCount,
                          REGION_LOGICAL);
    }
    return OK_STATUS;
}


// workers for GetDiskRegions

STATUS_CODE
GetRegions(
    IN  ULONG               Disk,
    IN  PPARTITION          p,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount,
    IN  REGION_TYPE         RegionType
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    STATUS_CODE   status;
    LARGE_INTEGER alignedOffset,
                  alignedSize,
                  temp;
    ULONG         sizeMB;

    while (p) {

        if (p->SysID == SYSID_UNUSED) {

            if (WantFreeRegions) {

                alignedOffset = AlignTowardsDiskEnd(p->Disk,p->Offset);
                temp.QuadPart = p->Offset.QuadPart + p->Length.QuadPart;
                temp = AlignTowardsDiskStart(p->Disk, temp);
                alignedSize.QuadPart = temp.QuadPart - alignedOffset.QuadPart;
                sizeMB        = SIZEMB(alignedSize);

                // Show the space free if it is greater than 1 meg, AND
                // it is not a space starting at the beginning of the disk
                // and of length <= 1 cylinder.
                // This prevents the user from seeing the first cylinder
                // of the disk as free (could otherwise happen with an
                // extended partition starting on cylinder 1 and cylinders
                // of 1 megabyte or larger).

                if ((alignedSize.QuadPart > 0) && sizeMB &&
                    ((p->Offset.QuadPart) ||
                      (p->Length.QuadPart > (DiskGeometryArray[p->Disk].BytesPerCylinder)))) {
                    if (!AddRegionEntry(Region,
                                        RegionCount,
                                        sizeMB,
                                        RegionType,
                                        p,
                                        alignedOffset,
                                        alignedSize)) {
                        RETURN_OUT_OF_MEMORY;
                    }
                }
            }
        } else {

            if (WantUsedRegions) {

                alignedOffset = p->Offset;
                alignedSize   = p->Length;
                sizeMB        = SIZEMB(alignedSize);

                if (!AddRegionEntry(Region,
                                    RegionCount,
                                    sizeMB,
                                    RegionType,
                                    p,
                                    alignedOffset,
                                    alignedSize)) {
                    RETURN_OUT_OF_MEMORY;
                }
            }

            if (IsExtended(p->SysID) && WantLogicalRegions) {
                status = GetRegions(Disk,
                                    LogicalVolumes[Disk],
                                    WantUsedRegions,
                                    WantFreeRegions,
                                    FALSE,
                                    Region,
                                    RegionCount,
                                    REGION_LOGICAL);
                if (status != OK_STATUS) {
                    return status;
                }
            }
        }
        p = p->Next;
    }
    return OK_STATUS;
}


BOOLEAN
AddRegionEntry(
    OUT PREGION_DESCRIPTOR *Regions,
    OUT ULONG              *RegionCount,
    IN  ULONG               SizeMB,
    IN  REGION_TYPE         RegionType,
    IN  PPARTITION          Partition,
    IN  LARGE_INTEGER       AlignedRegionOffset,
    IN  LARGE_INTEGER       AlignedRegionSize
    )

/*++

Routine Description:

    Allocate space for the region descriptor and copy the provided data.

Arguments:

    Regions - return the pointer to the new region
    RegionCount - number of regions on the disk so far
    SizeMB - size of the region
    RegionType - type of the region
    Partition - partition structure with other related information
    AlignedRegionOffset - region starting location
    AlignedRegionSize - region size.

Return Value:

    TRUE - The region was added successfully
    FALSE - it wasn't

--*/

{
    PREGION_DESCRIPTOR regionDescriptor;
    PREGION_DATA       regionData;

    regionDescriptor = ReallocateMemory(*Regions,(((*RegionCount) + 1) * sizeof(REGION_DESCRIPTOR)) + 20);
    if (regionDescriptor == NULL) {
        return FALSE;
    } else {
        *Regions = regionDescriptor;
        (*RegionCount)++;
    }

    regionDescriptor = &(*Regions)[(*RegionCount)-1];

    if (!(regionDescriptor->Reserved = AllocateMemory(sizeof(REGION_DATA)))) {
        return FALSE;
    }

    regionDescriptor->Disk                    = Partition->Disk;
    regionDescriptor->SysID                   = Partition->SysID;
    regionDescriptor->SizeMB                  = SizeMB;
    regionDescriptor->Active                  = Partition->Active;
    regionDescriptor->Recognized              = Partition->Recognized;
    regionDescriptor->PartitionNumber         = Partition->PartitionNumber;
    regionDescriptor->OriginalPartitionNumber = Partition->OriginalPartitionNumber;
    regionDescriptor->RegionType              = RegionType;
    regionDescriptor->PersistentData          = Partition->PersistentData;

    regionData = regionDescriptor->Reserved;

    regionData->Partition             = Partition;
    regionData->AlignedRegionOffset   = AlignedRegionOffset;
    regionData->AlignedRegionSize     = AlignedRegionSize;

    return TRUE;
}


VOID
FreeRegionArray(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              RegionCount
    )

/*++

Routine Description:

    This routine frees a region array returned by GetDiskRegions().

Arguments:

    Region          - pointer to the array of regions to be freed

    RegionCount     - number of items in the Region array

Return Value:

    None.

--*/

{
    ULONG i;

    for (i = 0; i < RegionCount; i++) {

        if (Region[i].Reserved) {
            FreeMemory(Region[i].Reserved);
        }
    }
    FreeMemory(Region);
}


VOID
AddPartitionToLinkedList(
    IN OUT PARTITION **Head,
    IN     PARTITION *p
    )

/*++

Routine Description:

    This routine adds a PARTITION structure to a doubly-linked
    list, sorted by the Offset field in ascending order.

Arguments:

    Head    - pointer to pointer to first element in list
    p       - pointer to item to be added to list

Return Value:

    None.

--*/

{
    PARTITION *cur,
              *prev;

    if ((cur = *Head) == NULL) {
        *Head = p;
        return;
    }

    if (p->Offset.QuadPart < cur->Offset.QuadPart) {
        p->Next = cur;
        cur->Prev = p;
        *Head = p;
        return;
    }

    prev = *Head;
    cur = cur->Next;

    while (cur) {
        if (p->Offset.QuadPart < cur->Offset.QuadPart) {

            p->Next = cur;
            p->Prev = prev;
            prev->Next = p;
            cur->Prev = p;
            return;
        }
        prev = cur;
        cur = cur->Next;
    }

    prev->Next = p;
    p->Prev = prev;
    return;
}


BOOLEAN
IsInLinkedList(
    IN PPARTITION p,
    IN PPARTITION List
    )

/*++

Routine Description:

    This routine determines whether a PARTITION element is in
    a given linked list of PARTITION elements.

Arguments:

    p       - pointer to element to be checked for
    List    - first element in list to be scanned

Return Value:

    true if p found in List, false otherwise

--*/

{
    while (List) {
        if (p == List) {
            return TRUE;
        }
        List = List->Next;
    }
    return FALSE;
}


BOOLEAN
IsInLogicalList(
    IN ULONG      Disk,
    IN PPARTITION p
    )

/*++

Routine Description:

    This routine determines whether a PARTITION element is in
    the logical volume list for a given disk.

Arguments:

    Disk    - index of disk to be checked
    p       - pointer to element to be checked for

Return Value:

    true if p found in Disk's logical volume list, false otherwise

--*/

{
    return IsInLinkedList(p, LogicalVolumes[Disk]);
}


BOOLEAN
IsInPartitionList(
    IN ULONG      Disk,
    IN PPARTITION p
    )

/*++

Routine Description:

    This routine determines whether a PARTITION element is in
    the primary partition list for a given disk.

Arguments:

    Disk    - index of disk to be checked
    p       - pointer to element to be checked for

Return Value:

    true if p found in Disk's primary partition list, false otherwise

--*/

{
    return IsInLinkedList(p, PrimaryPartitions[Disk]);
}


VOID
MergeFreePartitions(
    IN PPARTITION p
    )

/*++

Routine Description:

    This routine merges adjacent free space elements in the
    given linked list of PARTITION elements.  It is designed
    to be called after adding or deleting a partition.

Arguments:

    p - pointer to first item in list whose free elements are to
        be merged.

Return Value:

    None.

--*/

{
    PPARTITION next;

    while (p && p->Next) {

        if ((p->SysID == SYSID_UNUSED) && (p->Next->SysID == SYSID_UNUSED)) {

            next = p->Next;
            p->Length.QuadPart = (next->Offset.QuadPart + next->Length.QuadPart) - p->Offset.QuadPart;

            if (p->Next = next->Next) {
                next->Next->Prev = p;
            }

            FreeMemory(next);

        } else {
            p = p->Next;
        }
    }
}


PPARTITION
FindPartitionElement(
    IN ULONG Disk,
    IN ULONG Partition
    )

/*++

Routine Description:

    This routine locates a PARTITION element for a disk/partition
    number pair.  The partition number is the number that the
    system assigns to the partition.

Arguments:

    Disk - index of relevent disk

    Partition - partition number of partition to find

Return Value:

    pointer to PARTITION element, or NULL if not found.

--*/

{
    PPARTITION p;

    p = PrimaryPartitions[Disk];
    while (p) {
        if ((p->SysID != SYSID_UNUSED) && !IsExtended(p->SysID) && (p->PartitionNumber == Partition)) {
            return p;
        }
        p = p->Next;
    }
    p = LogicalVolumes[Disk];
    while (p) {
        if ((p->SysID != SYSID_UNUSED) && (p->PartitionNumber == Partition)) {
            return p;
        }
        p = p->Next;
    }
    return NULL;
}


VOID
SetSysID(
    IN ULONG Disk,
    IN ULONG Partition,
    IN UCHAR SysID
    )

/*++

Routine Description:

    This routine sets the system id of the given partition
    on the given disk.

Arguments:

    Disk - index of relevent disk

    Partition - partition number of relevent partition

    SysID - new system ID for Partition on Disk

Return Value:

    None.

--*/

{
    PPARTITION p = FindPartitionElement(Disk,Partition);

    if (p) {
        p->SysID = SysID;
        if (!p->Update) {
            p->Update = CHANGED_DONT_ZAP;
        }
        ChangesRequested[p->Disk] = TRUE;
    }
}


VOID
SetSysID2(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              SysID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PPARTITION p = ((PREGION_DATA)(Region->Reserved))->Partition;

    p->SysID = SysID;
    if (!p->Update) {
        p->Update = CHANGED_DONT_ZAP;
    }
    ChangesRequested[p->Disk] = TRUE;
}


VOID
FreeLinkedPartitionList(
    IN OUT PPARTITION *q
    )

/*++

Routine Description:

    This routine frees a linked list of PARTITION elements. The head
    pointer is set to NULL.

Arguments:

    p - pointer to pointer to first element of list to free.

Return Value:

    None.

--*/

{
    PARTITION *n;
    PARTITION *p = *q;

    while(p) {
        n = p->Next;
        FreeMemory(p);
        p = n;
    }
    *q = NULL;
}


VOID
FreePartitionInfoLinkedLists(
    IN PPARTITION *ListHeadArray
    )

/*++

Routine Description:

    This routine frees the linked lists of PARTITION elements
    for each disk.

Arguments:

    ListHeadArray - pointer to array of pointers to first elements of
                    PARTITION element lists.

Return Value:

    None.

--*/

{
    ULONG i;

    for (i = 0; i < CountOfDisks; i++) {

        FreeLinkedPartitionList(&ListHeadArray[i]);
    }
}


PPARTITION
AllocatePartitionStructure(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN UCHAR         SysID,
    IN BOOLEAN       Update,
    IN BOOLEAN       Active,
    IN BOOLEAN       Recognized
    )

/*++

Routine Description:

    This routine allocates space for, and initializes a PARTITION
    structure.

Arguments:

    Disk    - index of disk, one of whose regions the new PARTITION
              strucure describes.
    Offset  - byte offset of region on the disk
    Length  - length in bytes of the region
    SysID   - system id of region, of SYSID_UNUSED of this PARTITION
              is actually a free space.
    Update  - whether this PARTITION is dirty, ie, has changed and needs
              to be written to disk.
    Active  - flag for the BootIndicator field in a partition table entry,
              indicates to the x86 master boot program which partition
              is active.
    Recognized - whether the partition is a type recognized by NT

Return Value:

    NULL if allocation failed, or new initialized PARTITION strucure.

--*/

{
    PPARTITION p = AllocateMemory(sizeof(PARTITION));

    if (p) {
        p->Next                    = NULL;
        p->Prev                    = NULL;
        p->Offset                  = Offset;
        p->Length                  = Length;
        p->Disk                    = Disk;
        p->Update                  = Update;
        p->Active                  = Active;
        p->Recognized              = Recognized;
        p->SysID                   = SysID;
        p->OriginalPartitionNumber = 0;
        p->PartitionNumber         = 0;
        p->PersistentData          = 0;
        p->CommitMirrorBreakNeeded = FALSE;
    }
    return(p);
}


STATUS_CODE
InitializeFreeSpace(
    IN ULONG             Disk,
    IN PPARTITION       *PartitionList,      // list the free space goes in
    IN LARGE_INTEGER     StartOffset,
    IN LARGE_INTEGER     Length
    )

/*++

Routine Description:

    This routine determines all the free spaces within a given area
    on a disk, allocates PARTITION structures to describe them,
    and adds these structures to the relevent partition list
    (primary partitions or logical volumes).

    No rounding or alignment is performed here.  Spaces of even one
    byte will be counted and inserted in the partition list.

Arguments:

    Disk    - index of disk whose free spaces are being sought.

    PartitionList - pointer to first element on PARTITION list that
                    the free spaces will go in.

    StartOffset - start offset of area on disk to consider (ie, 0 for
                  primary spaces or the first byte of the extended
                  partition for logical spaces).

    Length - length of area on disk to consider (ie, size of disk
             for primary spaces or size of extended partition for
             logical spaces).

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION    p = *PartitionList,
                  q;
    LARGE_INTEGER start,
                  size;

    start = StartOffset;
    while (p) {

        size.QuadPart = p->Offset.QuadPart - start.QuadPart;
        if (size.QuadPart > 0) {
            if (!(q = AllocatePartitionStructure(Disk,
                                                 start,
                                                 size,
                                                 SYSID_UNUSED,
                                                 FALSE,
                                                 FALSE,
                                                 FALSE))) {
                RETURN_OUT_OF_MEMORY;
            }

            AddPartitionToLinkedList(PartitionList, q);
        }

        start.QuadPart = p->Offset.QuadPart + p->Length.QuadPart;
        p = p->Next;
    }

    size.QuadPart = (StartOffset.QuadPart + Length.QuadPart) - start.QuadPart;
    if (size.QuadPart > 0) {

        if (!(q = AllocatePartitionStructure(Disk,
                                             start,
                                             size,
                                             SYSID_UNUSED,
                                             FALSE,
                                             FALSE,
                                             FALSE))) {
            RETURN_OUT_OF_MEMORY;
        }

        AddPartitionToLinkedList(PartitionList, q);
    }

    return OK_STATUS;
}


STATUS_CODE
InitializeLogicalVolumeList(
    IN ULONG                      Disk,
    IN PDRIVE_LAYOUT_INFORMATION  DriveLayout
    )

/*++

Routine Description:

    This routine creates the logical volume linked list of
    PARTITION structures for the given disk.

Arguments:

    Disk    - index of disk

    DriveLayout - pointer to structure describing the raw partition
                  layout of the disk.

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION             p,
                           q;
    ULONG                  i,
                           j;
    PPARTITION_INFORMATION d;
    LARGE_INTEGER          HiddenBytes;
    ULONG                  BytesPerSector = DiskGeometryArray[Disk].BytesPerSector;

    FreeLinkedPartitionList(&LogicalVolumes[Disk]);

    p = PrimaryPartitions[Disk];
    while (p) {
        if (IsExtended(p->SysID)) {
            break;
        }
        p = p->Next;
    }

    if (p) {
        for (i=ENTRIES_PER_BOOTSECTOR; i<DriveLayout->PartitionCount; i+=ENTRIES_PER_BOOTSECTOR) {

            for (j=i; j<i+ENTRIES_PER_BOOTSECTOR; j++) {

                d = &DriveLayout->PartitionEntry[j];

                if ((d->PartitionType != SYSID_UNUSED) && (d->PartitionType != SYSID_EXTENDED)) {
                    LARGE_INTEGER t1,
                                  t2;

                    HiddenBytes.QuadPart = (LONGLONG)d->HiddenSectors * (LONGLONG)BytesPerSector;

                    t1.QuadPart = d->StartingOffset.QuadPart - HiddenBytes.QuadPart;
                    t2.QuadPart = d->PartitionLength.QuadPart + HiddenBytes.QuadPart;
                    if (!(q = AllocatePartitionStructure(Disk,
                                                        t1,
                                                        t2,
                                                        d->PartitionType,
                                                        FALSE,
                                                        d->BootIndicator,
                                                        d->RecognizedPartition))) {
                        RETURN_OUT_OF_MEMORY;
                    }

                    q->PartitionNumber =
                        q->OriginalPartitionNumber = d->PartitionNumber;
                    AddPartitionToLinkedList(&LogicalVolumes[Disk],q);

                    break;
                }
            }
        }
        return InitializeFreeSpace(Disk,
                                   &LogicalVolumes[Disk],
                                   p->Offset,
                                   p->Length);
    }
    return OK_STATUS;
}


STATUS_CODE
InitializePrimaryPartitionList(
    IN  ULONG                     Disk,
    IN  PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    This routine creates the primary partition linked list of
    PARTITION structures for the given disk.

Arguments:

    Disk    - index of disk

    DriveLayout - pointer to structure describing the raw partition
                  layout of the disk.

Return Value:

    OK_STATUS or error code.

--*/

{
    LARGE_INTEGER          zero;
    ULONG                  i;
    PPARTITION             p;
    PPARTITION_INFORMATION d;

    zero.QuadPart = 0;
    FreeLinkedPartitionList(&PrimaryPartitions[Disk]);

    if (DriveLayout->PartitionCount >= ENTRIES_PER_BOOTSECTOR) {

        for (i=0; i<ENTRIES_PER_BOOTSECTOR; i++) {

            d = &DriveLayout->PartitionEntry[i];

            if (d->PartitionType != SYSID_UNUSED) {

                if (!(p = AllocatePartitionStructure(Disk,
                                                     d->StartingOffset,
                                                     d->PartitionLength,
                                                     d->PartitionType,
                                                     FALSE,
                                                     d->BootIndicator,
                                                     d->RecognizedPartition))) {
                    RETURN_OUT_OF_MEMORY;
                }

                p->PartitionNumber =
                    p->OriginalPartitionNumber = IsExtended(p->SysID)
                                                 ? 0
                                                 : d->PartitionNumber;

                AddPartitionToLinkedList(&PrimaryPartitions[Disk],p);
            }
        }
    }
    return InitializeFreeSpace(Disk,
                               &PrimaryPartitions[Disk],
                               zero,
                               DiskLengthBytes(Disk));
}


VOID
ReconcilePartitionNumbers(
    ULONG Disk,
    PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    With dynamic partitioning, the partitions on the disk will no longer
    follow sequencial numbering schemes.  It will be possible for a disk
    to have a partition #1 that is the last partition on the disk and a
    partition #3 that is the first.  This routine runs through the NT
    namespace for harddisks to resolve this inconsistency.

    This routine has the problem that it will not locate partitions that
    are part of an FT set because the partition information for these
    partitions will be modified to reflect the size of the set, not the
    size of the partition.

Arguments:

    Disk - the disk number
    DriveLayout - the partitioning information

Return Value:

    None

--*/

{
#define BUFFERSIZE 1024
    NTSTATUS                      status;
    IO_STATUS_BLOCK               statusBlock;
    HANDLE                        directoryHandle,
                                  partitionHandle;
    CLONG                         continueProcessing;
    ULONG                         context = 0,
                                  returnedLength,
                                  index;
    POBJECT_DIRECTORY_INFORMATION dirInfo;
    PARTITION_INFORMATION         partitionInfo;
    PPARTITION_INFORMATION        partitionInfoPtr;
    OBJECT_ATTRIBUTES             attributes;
    UNICODE_STRING                unicodeString;
    ANSI_STRING                   ansiName;
    PUCHAR                        deviceName;
    PUCHAR                        buffer;

    deviceName = Malloc(100);
    if (!deviceName) {
        return;
    }

    buffer = Malloc(BUFFERSIZE);
    if (!buffer) {
        Free(deviceName);
        return;
    }

    sprintf(deviceName, "\\Device\\Harddisk%d", Disk);
    RtlInitAnsiString(&ansiName, deviceName);
    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiName, TRUE);

    if (!NT_SUCCESS(status)) {
        Free(deviceName);
        Free(buffer);
        return;
    }
    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    status = NtOpenDirectoryObject(&directoryHandle,
                                   DIRECTORY_QUERY,
                                   &attributes);
    if (!NT_SUCCESS(status)) {

        Free(deviceName);
        Free(buffer);
        return;
    }

    //  Query the entire directory in one sweep

    continueProcessing = 1;
    while (continueProcessing) {
        RtlZeroMemory(buffer, BUFFERSIZE);
        status = NtQueryDirectoryObject(directoryHandle,
                                        buffer,
                                        BUFFERSIZE,
                                        FALSE,
                                        FALSE,
                                        &context,
                                        &returnedLength);

        //  Check the status of the operation.

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_NO_MORE_FILES) {
                break;
            }
            continueProcessing = 0;
        }

        //  For every record in the buffer check for partition name


        for (dirInfo = (POBJECT_DIRECTORY_INFORMATION) buffer;
             TRUE;
             dirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) dirInfo) +
                          sizeof(OBJECT_DIRECTORY_INFORMATION))) {

            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now

            if (dirInfo->Name.Length == 0) {
                break;
            }

            // compare the name to see if it is a Partition

            if (!_wcsnicmp(dirInfo->Name.Buffer, L"Partition", 9)) {
                UCHAR digits[3];
                ULONG partitionNumber;

                // Located a partition.  This restricts the # of partitions
                // to 99.

                digits[0] = (UCHAR) dirInfo->Name.Buffer[9];
                digits[1] = (UCHAR) dirInfo->Name.Buffer[10];
                digits[2] = 0;
                partitionNumber = atoi(digits);

                if (partitionNumber <= 0) {

                    // less than zero is really an error...
                    // partition zero is always the same.

                    continue;
                }

                // Have a numbered partition -- match it to the drive layout

                status = LowOpenPartition(deviceName, partitionNumber, &partitionHandle);
                if (!NT_SUCCESS(status)) {

                    // If it cannot be opened perhaps it isn't really a partition

                    continue;
                }

                status = NtDeviceIoControlFile(partitionHandle,
                                               0,
                                               NULL,
                                               NULL,
                                               &statusBlock,
                                               IOCTL_DISK_GET_PARTITION_INFO,
                                               NULL,
                                               0,
                                               &partitionInfo,
                                               sizeof(PARTITION_INFORMATION));

               if (!NT_SUCCESS(status)) {
                   LowCloseDisk(partitionHandle);
                   continue;
               }

               // match partition information with drive layout.

               for (index = 0; index < DriveLayout->PartitionCount; index++) {

                   partitionInfoPtr = &DriveLayout->PartitionEntry[index];
                   if ((partitionInfoPtr->StartingOffset.QuadPart == partitionInfo.StartingOffset.QuadPart) &&
                       (partitionInfoPtr->PartitionLength.QuadPart == partitionInfo.PartitionLength.QuadPart)) {

                       // This is a match.

                       partitionInfoPtr->PartitionNumber = partitionNumber;
                       break;
                   }
               }
               LowCloseDisk(partitionHandle);
            }

        }
    }

    //  Now close the directory object

    Free(deviceName);
    Free(buffer);
    (VOID) NtClose(directoryHandle);
    return;
}


VOID
CheckForOldDrivers(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine determines if an old release 3.1 drive is in the
    system.  If so, it calculates the partition number for each region
    on a disk.  For a used region, the partition number is the number
    that the system will assign to the partition.  All partitions
    (except the extended partition) are numbered first starting at 1,
    and then all logical volumes in the extended partition.
    For a free region, the partition number is the number that the
    system WOULD assign to the partition if the space were to be
    converted to a partition and all other regions on the disk were
    left as is.

    The partition numbers are stored in the PARTITION elements.

Arguments:

    Disk - index of disk whose partitions are to be renumbered.

Return Value:

    None.

--*/

{
    PPARTITION p = PrimaryPartitions[Disk];
    ULONG      n = 1;

    while (p) {
        if (p->SysID != SYSID_UNUSED) {
            if ((!IsExtended(p->SysID)) && (IsRecognizedPartition(p->SysID))) {

                // If there is already a partition number, nothing need be
                // done here.

                if (p->PartitionNumber) {
                    return;
                } else {
                    RestartRequired = TRUE;
                }
                p->PartitionNumber = n;
                if (p->SysID != SYSID_UNUSED) {
                    n++;
                }
            }
        }
        p = p->Next;
    }
    p = LogicalVolumes[Disk];
    while (p) {
        if (p->SysID != SYSID_UNUSED) {
            if (p->PartitionNumber) {
                return;
            } else {
                RestartRequired = TRUE;
            }
            p->PartitionNumber = n;
            n++;
        }
        p = p->Next;
    }
}


STATUS_CODE
InitializePartitionLists(
    VOID
    )

/*++

Routine Description:

    This routine scans the PARTITION_INFO array returned for each disk
    by the OS.  A linked list of PARTITION structures is layered on top
    of each array;  the net result is a sorted list that covers an entire
    disk, because free spaces are also factored in as 'dummy' partitions.

Arguments:

    None.

Return Value:

    OK_STATUS or error code.

--*/

{
    STATUS_CODE               status;
    ULONG                     disk;
    PDRIVE_LAYOUT_INFORMATION driveLayout;

    for (disk = 0; disk < CountOfDisks; disk++) {

        if (OffLine[disk]) {
            continue;
        }

        if ((status = LowGetDiskLayout(DiskNames[disk], &driveLayout)) != OK_STATUS) {
            return status;
        }

        // ReconcilePartitionNumbers(disk, driveLayout);

        if ((status = InitializePrimaryPartitionList(disk, driveLayout)) == OK_STATUS) {
            status = InitializeLogicalVolumeList(disk, driveLayout);
        }
        if (status != OK_STATUS) {
            FreeMemory(driveLayout);
            return status;
        }

        Signatures[disk] = driveLayout->Signature;
        FreeMemory(driveLayout);
        CheckForOldDrivers(disk);
    }
    return OK_STATUS;
}


LARGE_INTEGER
DiskLengthBytes(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine determines the disk length in bytes.  This value
    is calculated from the disk geometry information.

Arguments:

    Disk - index of disk whose size is desired

Return Value:

    Size of Disk.

--*/

{
    LARGE_INTEGER result;

    result.QuadPart = DiskGeometryArray[Disk].Cylinders.QuadPart *
                      DiskGeometryArray[Disk].BytesPerCylinder;
    return result;
}


ULONG
SIZEMB(
    IN LARGE_INTEGER ByteCount
    )

/*++

Routine Description:

    Calculate the size in megabytes of a given byte count. The value is
    properly rounded (ie, not merely truncated).

    This function replaces a macro of the same name that was truncating
    instead of rounding.

Arguments:

    ByteCount - supplies number of bytes

Return Value:

    Size in MB equivalent to ByteCount.

--*/

{
    ULONG Remainder;
    ULONG SizeMB;

    SizeMB = RtlExtendedLargeIntegerDivide(ByteCount,
                                           ONE_MEG,
                                           &Remainder).LowPart;

    if (Remainder >= ONE_MEG/2) {
        SizeMB++;
    }

    return SizeMB;
}


ULONG
DiskSizeMB(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine determines the disk length in megabytes.  The returned
    value is rounded down after division by 1024*1024.

Arguments:

    Disk - index of disk whose size is desired

Return Value:

    Size of Disk.

--*/

{
    return SIZEMB(DiskLengthBytes(Disk));
}


LARGE_INTEGER
AlignTowardsDiskStart(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    )

/*++

Routine Description:

    This routine snaps a byte offset to a cylinder boundary, towards
    the start of the disk.

Arguments:

    Disk - index of disk whose offset is to be snapped
    Offset - byte offset to be aligned (snapped to cylinder boundary)

Return Value:

    Aligned offset.

--*/

{
    LARGE_INTEGER mod;
    LARGE_INTEGER result;

    mod.QuadPart = Offset.QuadPart % DiskGeometryArray[Disk].BytesPerCylinder;
    result.QuadPart = Offset.QuadPart - mod.QuadPart;
    return result;
}


LARGE_INTEGER
AlignTowardsDiskEnd(
    IN ULONG         Disk,
    IN LARGE_INTEGER Offset
    )

/*++

Routine Description:

    This routine snaps a byte offset to a cylinder boundary, towards
    the end of the disk.

Arguments:

    Disk - index of disk whose offset is to be snapped
    Offset - byte offset to be aligned (snapped to cylinder boundary)

Return Value:

    Aligned offset.

--*/

{
    LARGE_INTEGER mod,
                  temp;

    mod.QuadPart = Offset.QuadPart % DiskGeometryArray[Disk].BytesPerCylinder;
    if (mod.QuadPart) {

        temp.QuadPart = Offset.QuadPart + DiskGeometryArray[Disk].BytesPerCylinder;
        Offset = AlignTowardsDiskStart(Disk, temp);
    }
    return Offset;
}


BOOLEAN
IsExtended(
    IN UCHAR SysID
    )

/*++

Routine Description:

    This routine determines whether a given system id is for an
    extended type (ie, link) entry.

Arguments:

    SysID - system id to be tested.

Return Value:

    true/false based on whether SysID is for an extended type.

--*/

{
    return (BOOLEAN)(SysID == SYSID_EXTENDED);
}


STATUS_CODE
IsAnyCreationAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT PBOOLEAN AnyAllowed,
    OUT PBOOLEAN PrimaryAllowed,
    OUT PBOOLEAN ExtendedAllowed,
    OUT PBOOLEAN LogicalAllowed
    )

/*++

Routine Description:

    This routine determines whether any partition may be created on a
    given disk, based on three sub-queries -- whether creation is allowed
    of a primary partition, an extended partition, or a logical volume.

Arguments:

    Disk            - index of disk to check
    AllowMultiplePrimaries - whether to allow multiple primary partitions
    AnyAllowed - returns whether any creation is allowed
    PrimaryAllowed - returns whether creation of a primary partition
                     is allowed
    ExtendedAllowed - returns whether creation of an extended partition
                      is allowed
    Logical Allowed - returns whether creation of a logical volume is allowed.

Return Value:

    OK_STATUS or error code

--*/

{
    STATUS_CODE status;

    if ((status = IsCreationOfPrimaryAllowed(Disk,AllowMultiplePrimaries,PrimaryAllowed)) != OK_STATUS) {
        return status;
    }
    if ((status = IsCreationOfExtendedAllowed(Disk,ExtendedAllowed)) != OK_STATUS) {
        return status;
    }
    if ((status = IsCreationOfLogicalAllowed(Disk,LogicalAllowed)) != OK_STATUS) {
        return status;
    }
    *AnyAllowed = (BOOLEAN)(*PrimaryAllowed || *ExtendedAllowed || *LogicalAllowed);
    return OK_STATUS;
}


STATUS_CODE
IsCreationOfPrimaryAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT BOOLEAN *Allowed
    )

/*++

Routine Description:

    This routine determines whether creation of a primary partition is
    allowed.  This is true when there is a free entry in the MBR and
    there is free primary space on the disk.  If multiple primaries
    are not allowed, then there must also not exist any primary partitions
    in order for a primary creation to be allowed.

Arguments:

    Disk            - index of disk to check
    AllowMultiplePrimaries - whether existnace of primary partition
                             disallows creation of a primary partition
    Allowed - returns whether creation of a primary partition
              is allowed

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    ULONG              UsedCount,
                       RecogCount,
                       i;
    STATUS_CODE        status;
    BOOLEAN            FreeSpace = FALSE;

    status = GetPrimaryDiskRegions(Disk, &Regions, &RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    for (UsedCount = RecogCount = i = 0; i<RegionCount; i++) {
        if (Regions[i].SysID == SYSID_UNUSED) {
            FreeSpace = TRUE;
        } else {
            UsedCount++;
            if (!IsExtended(Regions[i].SysID) && Regions[i].Recognized) {
                RecogCount++;
            }
        }
    }

    if ((UsedCount < ENTRIES_PER_BOOTSECTOR)
     && FreeSpace
     && (!RecogCount || AllowMultiplePrimaries)) {
        *Allowed = TRUE;
    } else {
        *Allowed = FALSE;
    }

    FreeRegionArray(Regions, RegionCount);
    return OK_STATUS;
}


STATUS_CODE
IsCreationOfExtendedAllowed(
    IN  ULONG    Disk,
    OUT BOOLEAN *Allowed
    )

/*++

Routine Description:

    This routine determines whether creation of an extended partition is
    allowed.  This is true when there is a free entry in the MBR,
    there is free primary space on the disk, and there is no existing
    extended partition.

Arguments:

    Disk            - index of disk to check

    Allowed - returns whether creation of an extended partition
              is allowed

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    ULONG              UsedCount,
                       FreeCount,
                       i;
    STATUS_CODE        status;

    status = GetPrimaryDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    for (UsedCount = FreeCount = i = 0; i<RegionCount; i++) {
        if (Regions[i].SysID == SYSID_UNUSED) {

            // BUGBUG should adjust the size here and see if it's non0 first
            // (ie, take into account that the extended partition can't
            // start on cyl 0).

            FreeCount++;
        } else {
            UsedCount++;
            if (IsExtended(Regions[i].SysID)) {
                FreeRegionArray(Regions,RegionCount);
                *Allowed = FALSE;
                return OK_STATUS;
            }
        }
    }
    *Allowed = (BOOLEAN)((UsedCount < ENTRIES_PER_BOOTSECTOR) && FreeCount);
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
IsCreationOfLogicalAllowed(
    IN  ULONG    Disk,
    OUT BOOLEAN *Allowed
    )

/*++

Routine Description:

    This routine determines whether creation of a logical volume is
    allowed.  This is true when there is an extended partition and
    free space within it.

Arguments:

    Disk            - index of disk to check

    Allowed - returns whether creation of a logical volume is allowed

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    ULONG              i;
    STATUS_CODE        status;
    BOOLEAN            ExtendedExists;

    *Allowed = FALSE;

    status = DoesExtendedExist(Disk,&ExtendedExists);
    if (status != OK_STATUS) {
        return status;
    }
    if (!ExtendedExists) {
        return OK_STATUS;
    }

    status = GetLogicalDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    for (i = 0; i<RegionCount; i++) {
        if (Regions[i].SysID == SYSID_UNUSED) {
            *Allowed = TRUE;
            break;
        }
    }
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
DoesAnyPartitionExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN AnyExists,
    OUT PBOOLEAN PrimaryExists,
    OUT PBOOLEAN ExtendedExists,
    OUT PBOOLEAN LogicalExists
    )

/*++

Routine Description:

    This routine determines whether any partition exists on a given disk.
    This is based on three sub queries: whether there are any primary or
    extended partitions, or logical volumes on the disk.

Arguments:

    Disk            - index of disk to check
    AnyExists - returns whether any partitions exist on Disk
    PrimaryExists - returns whether any primary partitions exist on Disk
    ExtendedExists - returns whether there is an extended partition on Disk
    LogicalExists - returns whether any logical volumes exist on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    STATUS_CODE status;

    if ((status = DoesAnyPrimaryExist(Disk,PrimaryExists )) != OK_STATUS) {
        return status;
    }
    if ((status = DoesExtendedExist  (Disk,ExtendedExists)) != OK_STATUS) {
        return status;
    }
    if ((status = DoesAnyLogicalExist(Disk,LogicalExists )) != OK_STATUS) {
        return status;
    }
    *AnyExists = (BOOLEAN)(*PrimaryExists || *ExtendedExists || *LogicalExists);
    return OK_STATUS;
}


STATUS_CODE
DoesAnyPrimaryExist(
    IN  ULONG    Disk,
    OUT BOOLEAN *Exists
    )

/*++

Routine Description:

    This routine determines whether any non-extended primary partition exists
    on a given disk.

Arguments:

    Disk   - index of disk to check
    Exists - returns whether any primary partitions exist on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount,
                       i;
    STATUS_CODE        status;

    status = GetUsedPrimaryDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    *Exists = FALSE;

    for (i=0; i<RegionCount; i++) {
        if (!IsExtended(Regions[i].SysID)) {
            *Exists = TRUE;
            break;
        }
    }
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
DoesExtendedExist(
    IN  ULONG    Disk,
    OUT BOOLEAN *Exists
    )

/*++

Routine Description:

    This routine determines whether an extended partition exists
    on a given disk.

Arguments:

    Disk   - index of disk to check
    Exists - returns whether an extended partition exists on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount,
                       i;
    STATUS_CODE        status;

    status = GetUsedPrimaryDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    *Exists = FALSE;

    for (i=0; i<RegionCount; i++) {
        if (IsExtended(Regions[i].SysID)) {
            *Exists = TRUE;
            break;
        }
    }
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


STATUS_CODE
DoesAnyLogicalExist(
    IN  ULONG    Disk,
    OUT BOOLEAN *Exists
    )

/*++

Routine Description:

    This routine determines whether any logical volumes exist
    on a given disk.

Arguments:

    Disk   - index of disk to check
    Exists - returns whether any logical volumes exist on Disk

Return Value:

    OK_STATUS or error code

--*/

{
    PREGION_DESCRIPTOR Regions;
    ULONG              RegionCount;
    STATUS_CODE        status;

    status = GetUsedLogicalDiskRegions(Disk,&Regions,&RegionCount);
    if (status != OK_STATUS) {
        return status;
    }

    *Exists = (BOOLEAN)(RegionCount != 0);
    FreeRegionArray(Regions,RegionCount);
    return OK_STATUS;
}


ULONG
GetDiskCount(
    VOID
    )

/*++

Routine Description:

    This routine returns the number of attached partitionable disk
    devices.  The returned value is one greater than the maximum index
    allowed for Disk parameters to partitioning engine routines.

Arguments:

    None.

Return Value:

    Count of disks.

--*/

{
    return CountOfDisks;
}


PCHAR
GetDiskName(
    ULONG Disk
    )

/*++

Routine Description:

    This routine returns the system name for the disk device whose
    index is given.

Arguments:

    Disk - index of disk whose name is desired.

Return Value:

    System name for the disk device.  The caller must not attempt to
    free this buffer or modify it.

--*/

{
    return DiskNames[Disk];
}


// worker routines for WriteDriveLayout

VOID
UnusedEntryFill(
    IN PPARTITION_INFORMATION pinfo,
    IN ULONG                  EntryCount
    )

/*++

Routine Description:

    Initialize a partition information structure.

Arguments:

    pinfo - the partition information structure to fill in.
    EntryCount - the number of entries in the structure to fill.

Return Value:

    None

--*/

{
    ULONG         i;
    LARGE_INTEGER zero;

    zero.QuadPart = 0;
    for (i = 0; i < EntryCount; i++) {

        pinfo[i].StartingOffset   = zero;
        pinfo[i].PartitionLength  = zero;
        pinfo[i].HiddenSectors    = 0;
        pinfo[i].PartitionType    = SYSID_UNUSED;
        pinfo[i].BootIndicator    = FALSE;
        pinfo[i].RewritePartition = TRUE;
    }
}


LARGE_INTEGER
MakeBootRec(
    ULONG                  Disk,
    PPARTITION_INFORMATION pInfo,
    PPARTITION             pLogical,
    PPARTITION             pNextLogical
    )

/*++

Routine Description:

Arguments:

    Disk - the disk number
    pinfo - the partition information for the disk.
    pLogical
    pNextLogical

Return Value:

    The starting offset.

--*/

{
    ULONG         entry = 0;
    LARGE_INTEGER bytesPerTrack;
    LARGE_INTEGER sectorsPerTrack;
    LARGE_INTEGER startingOffset;

    bytesPerTrack.QuadPart = DiskGeometryArray[Disk].BytesPerTrack;
    sectorsPerTrack.QuadPart = DiskGeometryArray[Disk].SectorsPerTrack;
    startingOffset.QuadPart = 0;

    if (pLogical) {

        pInfo[entry].StartingOffset.QuadPart = pLogical->Offset.QuadPart + bytesPerTrack.QuadPart;
        pInfo[entry].PartitionLength.QuadPart = pLogical->Length.QuadPart - bytesPerTrack.QuadPart;
        pInfo[entry].HiddenSectors    = sectorsPerTrack.LowPart;
        pInfo[entry].RewritePartition = pLogical->Update;
        pInfo[entry].BootIndicator    = pLogical->Active;
        pInfo[entry].PartitionType    = pLogical->SysID;

        if(pInfo[entry].RewritePartition) {
            startingOffset = pInfo[entry].StartingOffset;
        }

        entry++;
    }

    if (pNextLogical) {

        pInfo[entry].StartingOffset   = pNextLogical->Offset;
        pInfo[entry].PartitionLength  = pNextLogical->Length;
        pInfo[entry].HiddenSectors    = 0;
        pInfo[entry].RewritePartition = TRUE;
        pInfo[entry].BootIndicator    = FALSE;
        pInfo[entry].PartitionType    = SYSID_EXTENDED;

        entry++;
    }

    UnusedEntryFill(pInfo + entry, ENTRIES_PER_BOOTSECTOR - entry);
    return startingOffset;
}


STATUS_CODE
ZapSector(
    ULONG         Disk,
    LARGE_INTEGER Offset
    )

/*++

Routine Description:

    This routine writes zeros into a sector at a given offset.  This is
    used to clear out a new partition's filesystem boot record, so that
    no previous filesystem appears in a new partition; or to clear out the
    first EBR in the extended partition if there are to be no logical vols.

Arguments:

    Disk - disk to write to

    Offset - byte offset to a newly created partition on Disk

Return Value:

    OK_STATUS or error code.

--*/

{
    ULONG       sectorSize = DiskGeometryArray[Disk].BytesPerSector;
    ULONG       i;
    PCHAR       sectorBuffer,
                alignedSectorBuffer;
    STATUS_CODE status;
    HANDLE_T    handle;
    LARGE_INTEGER temp;

    if ((sectorBuffer = AllocateMemory(2*sectorSize)) == NULL) {
        RETURN_OUT_OF_MEMORY;
    }

    alignedSectorBuffer = (PCHAR)(((ULONG)sectorBuffer+sectorSize) & ~(sectorSize-1));

    for (i=0; i<sectorSize; alignedSectorBuffer[i++] = 0);

    if ((status = LowOpenDisk(GetDiskName(Disk),&handle)) != OK_STATUS) {
        FreeMemory(sectorBuffer);
        return status;
    }

    temp.QuadPart = Offset.QuadPart / sectorSize;
    status = LowWriteSectors(handle,
                             sectorSize,
                             temp.LowPart,
                             1,
                             alignedSectorBuffer);
    LowCloseDisk(handle);

    // Now to make sure the file system really did a dismount,
    // force a mount/verify of the partition.  This avoids a
    // problem where HPFS doesn't dismount when asked, but instead
    // marks the volume for verify.

    if ((status = LowOpenDisk(GetDiskName(Disk), &handle)) == OK_STATUS) {
        LowCloseDisk(handle);
    }

    FreeMemory(sectorBuffer);
    return status;
}


STATUS_CODE
WriteDriveLayout(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine writes the current partition layout for a given disk
    out to disk.  The high-level PARTITION lists are transformed into
    a DRIVE_LAYOUT_INFORMATION structure before being passed down
    to the low-level partition table writing routine.

Arguments:

    Disk - index of disk whose on-disk partition structure is to be updated.

Return Value:

    OK_STATUS or error code.

--*/

{
#define MAX_DISKS 250
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION    pinfo;
    ULONG                     entryCount;
    ULONG                     sectorSize;
    STATUS_CODE               status;
    LARGE_INTEGER             startingOffset,
                              extendedStartingOffset;
    PPARTITION                nextPartition,
                              partition,
                              partitionHash[MAX_DISKS];

    extendedStartingOffset.QuadPart = 0;
    memset(partitionHash, 0, sizeof(partitionHash));

    // allocate a huge buffer now to avoid complicated dynamic
    // reallocation schemes later.

    if (!(driveLayout = AllocateMemory((MAX_DISKS + 1) * sizeof(PARTITION_INFORMATION)))) {
        RETURN_OUT_OF_MEMORY;
    }

    pinfo = &driveLayout->PartitionEntry[0];

    // first do the mbr.

    entryCount = 0;
    partition = PrimaryPartitions[Disk];
    sectorSize = DiskGeometryArray[Disk].BytesPerSector;

    while (partition) {

        if (partition->SysID != SYSID_UNUSED) {

            if (IsExtended(partition->SysID)) {
                extendedStartingOffset = partition->Offset;
            } else {
                partitionHash[entryCount] = partition;
            }

            pinfo[entryCount].StartingOffset   = partition->Offset;
            pinfo[entryCount].PartitionLength  = partition->Length;
            pinfo[entryCount].PartitionType    = partition->SysID;
            pinfo[entryCount].BootIndicator    = partition->Active;
            pinfo[entryCount].RewritePartition = partition->Update;
            pinfo[entryCount].HiddenSectors    = (ULONG) (partition->Offset.QuadPart / sectorSize);

            // if we're creating this partition, clear out the
            // filesystem boot sector.

            if (pinfo[entryCount].RewritePartition
             && (partition->Update != CHANGED_DONT_ZAP)
             && !IsExtended(pinfo[entryCount].PartitionType)) {
                status = ZapSector(Disk,pinfo[entryCount].StartingOffset);
                if (status != OK_STATUS) {
                    FreeMemory(driveLayout);
                    return status;
                }
            }

            entryCount++;
        }
        partition = partition->Next;
    }

    // fill the remainder of the MBR with unused entries.
    // NOTE that there will thus always be an MBR even if there
    // are no partitions defined.

    UnusedEntryFill(pinfo+entryCount, ENTRIES_PER_BOOTSECTOR - entryCount);
    entryCount = ENTRIES_PER_BOOTSECTOR;

    // now handle the logical volumes.
    // first check to see whether we need a dummy EBR at the beginning
    // of the extended partition.  This is the case when there is
    // free space at the beginning of the extended partition.
#if 0
    // Also handle the case where we are creating an empty extended
    // partition -- need to zap the first sector to eliminate any residue
    // that might start an EBR chain.
#else
    // BUGBUG 4/24/92 tedm:  Currently the io subsystem returns an error
    // status (status_bad_master_boot_record) if any mbr or ebr is bad.
    // Zeroing the first sector of the extended partition therefore causes
    // the whole disk to be seen as empty.  So create a blank, but valid,
    // EBR in the 'empty extended partition' case.  Code is in the 'else'
    // part of the #if 0, below.
#endif

    if ((partition = LogicalVolumes[Disk]) && (partition->SysID == SYSID_UNUSED)) {
        if (partition->Next) {

            partitionHash[entryCount] = partition;
            MakeBootRec(Disk, pinfo+entryCount, NULL, partition->Next);
            entryCount += ENTRIES_PER_BOOTSECTOR;
            partition = partition->Next;
        } else {

#if 0
            status = ZapSector(Disk, extendedStartingOffset);
            if (status != OK_STATUS) {
                FreeMemory(driveLayout);
                return status;
            }
#else
            MakeBootRec(Disk, pinfo+entryCount, NULL, NULL);
            entryCount += ENTRIES_PER_BOOTSECTOR;
#endif
        }
    }

    while (partition) {
        if (partition->SysID != SYSID_UNUSED) {

            // find the next logical volume.

            nextPartition = partition->Next;
            while (nextPartition) {
                if (nextPartition->SysID != SYSID_UNUSED) {
                    break;
                }
                nextPartition = nextPartition->Next;
            }

            partitionHash[entryCount] = partition;
            startingOffset = MakeBootRec(Disk, pinfo+entryCount, partition, nextPartition);

            // if we're creating a volume, clear out its filesystem
            // boot sector so it starts out fresh.

            if ((startingOffset.QuadPart) && (partition->Update != CHANGED_DONT_ZAP)) {
                status = ZapSector(Disk,startingOffset);
                if (status != OK_STATUS) {
                    FreeMemory(driveLayout);
                    return status;
                }
            }

            entryCount += ENTRIES_PER_BOOTSECTOR;
        }
        partition = partition->Next;
    }

    driveLayout->PartitionCount = entryCount;
    driveLayout->Signature = Signatures[Disk];
    status = LowSetDiskLayout(DiskNames[Disk], driveLayout);

    if (NT_SUCCESS(status)) {

        // Update the partition numbers in the region structures.

        // ReconcilePartitionNumbers(Disk, driveLayout);

        for (entryCount = 0; entryCount < MAX_DISKS; entryCount++) {
            if (partition = partitionHash[entryCount]) {
                if (partition->Update) {
                    pinfo = &driveLayout->PartitionEntry[entryCount];
                    partition->PartitionNumber = pinfo->PartitionNumber;
                }
            }
        }
    }

    FreeMemory(driveLayout);
    return status;
}


STATUS_CODE
CommitPartitionChanges(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine is the entry point for updating the on-disk partition
    structures of a disk.  The disk is only written to if the partition
    structure has been changed by adding or deleting partitions.

Arguments:

    Disk - index of disk whose on-disk partition structure is to be updated.

Return Value:

    OK_STATUS or error code.

--*/

{
    PPARTITION              p;
    STATUS_CODE             status;

    if (!HavePartitionsBeenChanged(Disk)) {
        return OK_STATUS;
    }

    if ((status = WriteDriveLayout(Disk)) != OK_STATUS) {
        return status;
    }

    // BUGBUG for ARC and NT MIPS, update NVRAM vars so partitions are right.
    //        Do that here, before partition numbers are reassigned.

    p = PrimaryPartitions[Disk];
    while (p) {
        p->Update = FALSE;
        p->OriginalPartitionNumber = p->PartitionNumber;
        p = p->Next;
    }
    p = LogicalVolumes[Disk];
    while (p) {
        p->Update = FALSE;
        p->OriginalPartitionNumber = p->PartitionNumber;
        p = p->Next;
    }

    ChangesRequested[Disk] = FALSE;
    ChangesCommitted[Disk] = TRUE;
    return OK_STATUS;
}


BOOLEAN
IsRegionCommitted(
    PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Given a region descriptor, return TRUE if it actually exists on disk,
    FALSE otherwise.

Arguments:

    RegionDescriptor - the region to check

Return Value:

    TRUE - if the region actually exists on disk
    FALSE otherwise.

--*/

{
    PPERSISTENT_REGION_DATA regionData;

    regionData = PERSISTENT_DATA(RegionDescriptor);
    if (!regionData) {
        return FALSE;
    }
    return regionData->VolumeExists;
}


BOOLEAN
HavePartitionsBeenChanged(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine returns TRUE if the given disk's partition structures
    have been modified by adding or deleting partitions, since the
    on-disk structures were last written by a call to CommitPartitionChanges
    (or first read).

Arguments:

    Disk - index of disk to check

Return Value:

    true if Disk's partition structure has changed.

--*/

{
    return ChangesRequested[Disk];
}


BOOLEAN
ChangeCommittedOnDisk(
    IN ULONG Disk
    )

/*++

Routine Description:

    This routine will inform the caller if a change was actually committed
    to the disk given.

Arguments:

    Disk - index of disk to check

Return Value:

    TRUE if disk was changed
    FALSE otherwise.

--*/

{
    return ChangesCommitted[Disk];
}


VOID
ClearCommittedDiskInformation(
    )

/*++

Routine Description:

    Clear all knowledge about any changes that have occurred to the
    disks.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG i;

    for (i=0; i<CountOfDisks; i++) {
        ChangesCommitted[i] = FALSE;
    }
}


VOID
FdMarkDiskDirty(
    IN ULONG Disk
    )

/*++

Routine Description:

    Remember that this disk has had some partitioning changes.

Arguments:

    Disk - the disk number

Return Value:

    None

--*/

{
    ChangesRequested[Disk] = TRUE;
}


VOID
FdSetPersistentData(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              Data
    )

/*++

Routine Description:

    Set the persistent data area for the specified region.

Arguments:

    Region - the region for which the persistent data is to be set
    Data   - the persistent data for the region.

Return Value:

    None

--*/

{
    ((PREGION_DATA)(Region->Reserved))->Partition->PersistentData =
                                                  (PPERSISTENT_REGION_DATA) Data;
}


ULONG
FdGetMinimumSizeMB(
    IN ULONG Disk
    )

/*++

Routine Description:

    Return the minimum size for a partition on a given disk.

    This is the rounded size of one cylinder or 1, whichever is greater.

Arguments:

    Region - region describing the partition to check.

Return Value:

    Actual offset

--*/

{
    LARGE_INTEGER temp;

    temp.QuadPart = DiskGeometryArray[Disk].BytesPerCylinder;
    return max(SIZEMB(temp), 1);
}


ULONG
FdGetMaximumSizeMB(
    IN PREGION_DESCRIPTOR Region,
    IN REGION_TYPE        CreationType
    )

/*++

Routine Description:

    Given a region of disk determine how much of it may be used to
    create the specified partition type.  This code take into consideration
    the many alignment restrictions imposed by early DOS software versions.

Arguments:

    Region - The affected region
    CreationType - What is being created
                   (extended partition/primary partition)

Return Value:

    The maximum size that a partition of the specified type can be
    to fit within the space available in the region.

--*/

{
    PREGION_DATA  createData = Region->Reserved;
    LARGE_INTEGER maxSize;

    maxSize = createData->AlignedRegionSize;
    if (!(createData->AlignedRegionOffset.QuadPart)) {
        ULONG delta;

        delta = (CreationType == REGION_EXTENDED)
              ? DiskGeometryArray[Region->Disk].BytesPerCylinder
              : DiskGeometryArray[Region->Disk].BytesPerTrack;

        maxSize.QuadPart -= delta;
    }

    return SIZEMB(maxSize);
}


LARGE_INTEGER
FdGetExactSize(
    IN PREGION_DESCRIPTOR Region,
    IN BOOLEAN            ForExtended
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PREGION_DATA  regionData = Region->Reserved;
    LARGE_INTEGER largeSize = regionData->AlignedRegionSize;
    LARGE_INTEGER bytesPerTrack;
    LARGE_INTEGER bytesPerCylinder;

    bytesPerTrack.QuadPart = DiskGeometryArray[Region->Disk].BytesPerTrack;
    bytesPerCylinder.QuadPart = DiskGeometryArray[Region->Disk].BytesPerCylinder;

    if (Region->RegionType == REGION_LOGICAL) {

        //
        // The region is within the extended partition.  It doesn't matter
        // whether it's free space or used -- in either case, we need to
        // account for the reserved EBR track.
        //

        largeSize.QuadPart -= bytesPerTrack.QuadPart;

    } else if (Region->SysID == SYSID_UNUSED) {

        //
        // The region is unused space not inside the extended partition.
        // We must know whether the caller will put a primary or extended
        // partition there -- a primary partition can use all the space, but
        // a logical volume in the extended partition won't include the first
        // track.  If the free space starts at offset 0 on the disk, a special
        // calculation must be used to move the start of the partition to
        // skip a track for a primary or a cylinder and a track for an
        // extended+logical.
        //

        if ((!regionData->AlignedRegionOffset.QuadPart) || ForExtended) {
            largeSize.QuadPart -= bytesPerTrack.QuadPart;
        }

        if ((!regionData->AlignedRegionOffset.QuadPart) && ForExtended) {
            largeSize.QuadPart -= bytesPerCylinder.QuadPart;
        }
    }

    return largeSize;
}


LARGE_INTEGER
FdGetExactOffset(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    Determine where a given partition _actually_ starts, which may be
    different than where is appears because of EBR reserved tracks, etc.

    NOTE: This routine is not meant to operate on unused regions or
    extended partitions.  In these cases, it just returns the apparant offset.

Arguments:

    Region - region describing the partition to check.

Return Value:

    Actual offset

--*/

{
    LARGE_INTEGER offset = ((PREGION_DATA)(Region->Reserved))->Partition->Offset;

    if ((Region->SysID != SYSID_UNUSED) && (Region->RegionType == REGION_LOGICAL)) {

        //
        // The region is a logical volume.
        // Account for the reserved EBR track.
        //

        offset.QuadPart += DiskGeometryArray[Region->Disk].BytesPerTrack;
    }

    return offset;
}


BOOLEAN
FdCrosses1024Cylinder(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        RegionType
    )

/*++

Routine Description:

    Determine whether a used region corsses the 1024th cylinder, or whether
    a partition created within a free space will cross the 1024th cylinder.

Arguments:

    Region - region describing the partition to check.
    CreationSizeMB - if the Region is for a free space, this is the size of
        the partition to be checked.
    RegionType - one of REGION_PRIMARY, REGION_EXTENDED, or REGION_LOGICAL

Return Value:

    TRUE if the end cylinder >= 1024.

--*/

{
    LARGE_INTEGER start,
                  size,
                  end,
                  zero;

    if (Region->SysID == SYSID_UNUSED) {

        // Determine the exact size and offset of the partition, according
        // to how CreatePartitionEx() will do it.

        zero.QuadPart = 0;
        DetermineCreateSizeAndOffset(Region,
                                     zero,
                                     CreationSizeMB,
                                     RegionType,
                                     &start,
                                     &size);
    } else {

        start = ((PREGION_DATA)(Region->Reserved))->Partition->Offset;
        size  = ((PREGION_DATA)(Region->Reserved))->Partition->Length;
    }

    end.QuadPart = (start.QuadPart + size.QuadPart) - 1;

    // End is the last byte in the partition.  Divide by the number of
    // bytes in a cylinder and see whether the result is > 1023.

    end.QuadPart = end.QuadPart / DiskGeometryArray[Region->Disk].BytesPerCylinder;
    return (end.QuadPart > 1023);
}


BOOLEAN
IsDiskOffLine(
    IN ULONG Disk
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    return OffLine[Disk];
}

ULONG
FdGetDiskSignature(
    IN ULONG Disk
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    return Signatures[Disk];
}

VOID
FdSetDiskSignature(
    IN ULONG Disk,
    IN ULONG Signature
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    Signatures[Disk] = Signature;
}

BOOLEAN
SignatureIsUniqueToSystem(
    IN ULONG Disk,
    IN ULONG Signature
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG index;

    for (index = 0; index < Disk; index++) {
        if (Signatures[index] == Signature) {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdft.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    fdft.c

Abstract:

    This module contains FT support routines for Disk Administrator

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) minor changes - mostly cosmetic.

--*/

#include "fdisk.h"
#include <string.h>


// This variable heads a linked list of ft object sets.

PFT_OBJECT_SET FtObjects = NULL;

// Array of pointers to registry disk descriptors that we
// remember, ie, save for later use when a disk is not physically
// present on the machine.

PDISK_DESCRIPTION *RememberedDisks;
ULONG              RememberedDiskCount;



ULONG
FdpDetermineDiskDescriptionSize(
    PDISKSTATE DiskState
    );

ULONG
FdpConstructDiskDescription(
    IN  PDISKSTATE        DiskState,
    OUT PDISK_DESCRIPTION DiskDescription
    );

VOID
FdpRememberDisk(
    IN PDISK_DESCRIPTION DiskDescription
    );

VOID
FdpInitializeMirrors(
    VOID
    );

#define MAX_FT_SET_TYPES 4
ULONG OrdinalToAllocate[MAX_FT_SET_TYPES] = {0, 0, 0, 0};

VOID
MaintainOrdinalTables(
    IN FT_TYPE FtType,
    IN ULONG   Ordinal
    )

/*++

Routine Description:

    Maintain the minimum and maximum Ordinal value recorded.

Arguments:

    FtType - the type of the FT set.
    Ordinal - the in use FtGroup (or ordinal) number

Return Value:

    None

--*/

{
    if (Ordinal > OrdinalToAllocate[FtType]) {
        OrdinalToAllocate[FtType] = Ordinal;
    }
}

DWORD
FdftNextOrdinal(
    IN FT_TYPE FtType
    )

/*++

Routine Description:

    Allocate a number that will uniquely identify the FT set
    from other sets of the same type.  This number must be unique
    from any given or used by FT sets of the same type due to
    requirements of FT dynamic partitioning.

Arguments:

    FtType - The type of the FT set.

Return Value:

    The FtGroup number -- called an "ordinal" in the internal
    structures.

--*/

{
    DWORD          ord;
    PFT_OBJECT_SET pftset;
    BOOL           looping;

    // The Ordinal value is going to be used as an FtGroup number
    // FtGroups are USHORTs so don't wrap on the Ordinal.  Try
    // to keep the next ordinal in the largest opening range, that
    // is if the minimum found is > half way through a USHORT, start
    // the ordinals over at zero.

    if (OrdinalToAllocate[FtType] > 0x7FFE) {
        OrdinalToAllocate[FtType] = 0;
    }

    ord = OrdinalToAllocate[FtType];
    ord++;

    do {
        looping = FALSE;
        pftset = FtObjects;
        while (pftset) {
            if ((pftset->Type == FtType) && (pftset->Ordinal == ord)) {
                ord++;
                looping = TRUE;
                break;
            }
            pftset = pftset->Next;
        }
    } while (looping);

    OrdinalToAllocate[FtType] = (ord + 1);
    return ord;
}


VOID
FdftCreateFtObjectSet(
    IN FT_TYPE             FtType,
    IN PREGION_DESCRIPTOR *Regions,
    IN DWORD               RegionCount,
    IN FT_SET_STATUS       Status
    )

/*++

Routine Description:

    Create the FT set structures for the give collection of
    region pointers.

Arguments:

    FtType
    Regions
    RegionCount
    Status

Return Value:

    None

--*/

{
    DWORD           Ord;
    PFT_OBJECT_SET  FtSet;
    PFT_OBJECT      FtObject;


    FtSet = Malloc(sizeof(FT_OBJECT_SET));

    // Figure out an ordinal for the new object set.

    FtSet->Ordinal = FdftNextOrdinal(FtType);
    FtSet->Type = FtType;
    FtSet->Members = NULL;
    FtSet->Member0 = NULL;
    FtSet->Status = Status;

    // Link the new object set into the list.

    FtSet->Next = FtObjects;
    FtObjects = FtSet;

    // For each region in the set, associate the ft info with it.

    for (Ord=0; Ord<RegionCount; Ord++) {

        FtObject = Malloc(sizeof(FT_OBJECT));

        // If this is a creation of a stripe set with parity, then
        // we must mark the 0th item 'Initializing' instead of 'Healthy'.

        if ((Ord == 0)
         && (FtType == StripeWithParity)
         && (Status == FtSetNewNeedsInitialization)) {
            FtObject->State = Initializing;
        } else {
            FtObject->State = Healthy;
        }

        if (!Ord) {
            FtSet->Member0 = FtObject;
        }

        FtObject->Set = FtSet;
        FtObject->MemberIndex = Ord;
        FtObject->Next = FtSet->Members;
        FtSet->Members = FtObject;

        SET_FT_OBJECT(Regions[Ord],FtObject);
    }
}

BOOL
FdftUpdateFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN FT_SET_STATUS  SetState
    )

/*++

Routine Description:

    Given an FT set, go back to the registry information and
    update the state of the members with the state in the registry.

    NOTE:  The following condition may exist.  It is possible for
    the FtDisk driver to return that the set is in an initializing
    or regenerating state and not have this fact reflected in the
    registry.  This can happen when the system has crashed and
    on restart the FtDisk driver started the regeneration of the
    check data (parity).

Arguments:

    FtSet - the set to update.

Return Value:

    TRUE if the set state provided has a strong likelyhood of being correct
    FALSE if the NOTE condition above is occuring.

--*/

{
    BOOLEAN            allHealthy = TRUE;
    PFT_OBJECT         ftObject;
    PDISK_REGISTRY     diskRegistry;
    PDISK_PARTITION    partition;
    PDISK_DESCRIPTION  diskDescription;
    DWORD              ec;
    ULONG              diskIndex,
                       partitionIndex;

    ec = MyDiskRegistryGet(&diskRegistry);
    if (ec != NO_ERROR) {

        // No registry information.

        return TRUE;
    }

    diskDescription = diskRegistry->Disks;
    for (diskIndex=0; diskIndex<diskRegistry->NumberOfDisks; diskIndex++) {

        for (partitionIndex=0; partitionIndex<diskDescription->NumberOfPartitions; partitionIndex++) {

            partition = &diskDescription->Partitions[partitionIndex];
            if ((partition->FtType == FtSet->Type) && (partition->FtGroup == (USHORT) FtSet->Ordinal)) {

                // Have a match for a partition within this set.
                // Find the region descriptor for this partition and
                // update its state accordingly.

                for (ftObject = FtSet->Members; ftObject; ftObject = ftObject->Next) {

                    if (ftObject->MemberIndex == (ULONG) partition->FtMember) {
                        ftObject->State = partition->FtState;
                        break;
                    }

                    if (partition->FtState != Healthy) {
                        allHealthy = FALSE;
                    }
                }
            }
        }
        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    Free(diskRegistry);
    if ((allHealthy) && (SetState != FtSetHealthy)) {

        // This is a condition where the system must be
        // updating the check data for redundant sets.

        return FALSE;
    }

    return TRUE;
}

VOID
FdftDeleteFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN BOOL           OffLineDisksOnly
    )

/*++

Routine Description:

    Delete an ft set, or rather its internal representation as a linked
    list of ft member structures.

Arguments:

    FtSet - supplies pointer to ft set structure for set to delete.

    OffLineDisksOnly - if TRUE, then do not delete the set but instead
        scan remembered disks for members of the set and remove such members.

Return Value:

    None.

--*/

{
    PFT_OBJECT        ftObject = FtSet->Members;
    PFT_OBJECT        next;
    PFT_OBJECT_SET    ftSetTemp;
    PDISK_DESCRIPTION diskDescription;
    PDISK_PARTITION   diskPartition;
    ULONG             partitionCount,
                      size,
                      i,
                      j;

    // Locate any members of the ft set on remembered disks and
    // remove the entries for such partitions.

    for (i=0; i<RememberedDiskCount; i++) {

        diskDescription = RememberedDisks[i];
        partitionCount = diskDescription->NumberOfPartitions;

        for (j=0; j<partitionCount; j++) {

            diskPartition = &diskDescription->Partitions[j];

            if ((diskPartition->FtType  == FtSet->Type)
             && (diskPartition->FtGroup == (USHORT)FtSet->Ordinal)) {

                // Found a member of the ft set being deleted on a
                // remembered disk.  Remove the partition from the
                // remembered disk.

                RtlMoveMemory( diskPartition,
                               diskPartition+1,
                               (partitionCount - j - 1) * sizeof(DISK_PARTITION)
                             );

                partitionCount--;
                j--;
            }
        }

        if (partitionCount != diskDescription->NumberOfPartitions) {

            diskDescription->NumberOfPartitions = (USHORT)partitionCount;

            size = sizeof(DISK_DESCRIPTION);
            if (partitionCount > 1) {
                size += (partitionCount - 1) * sizeof(DISK_PARTITION);
            }
            RememberedDisks[i] = Realloc(RememberedDisks[i], size);
        }
    }

    if (OffLineDisksOnly) {
        return;
    }

    // First, free all members of the set

    while (ftObject) {
        next = ftObject->Next;
        Free(ftObject);
        ftObject = next;
    }

    // now, remove the set from the linked list of sets.

    if (FtObjects == FtSet) {
        FtObjects = FtSet->Next;
    } else {
        ftSetTemp = FtObjects;
        while (1) {
            FDASSERT(ftSetTemp);
            if (ftSetTemp == NULL) {
                break;
            }
            if (ftSetTemp->Next == FtSet) {
                ftSetTemp->Next = FtSet->Next;
                break;
            }
            ftSetTemp = ftSetTemp->Next;
        }
    }
    Free(FtSet);
}

VOID
FdftExtendFtObjectSet(
    IN OUT  PFT_OBJECT_SET      FtSet,
    IN OUT  PREGION_DESCRIPTOR* Regions,
    IN      DWORD               RegionCount
    )
/*++

Routine Description:

    This function adds regions to an existing FT-set.

Arguments:

    FtSet       --  Supplies the set to extend.
    Regions     --  Supplies the regions to add to the set.  Note
                    that these regions are updated with the FT
                    information.
    RegionCount --  Supplies the number of regions to add.

Return Value:

    None.

--*/
{
    PFT_OBJECT FtObject;
    DWORD   i, StartingIndex;

    // Determine the starting member index for the new regions.
    // It is the greatest of the existing member indices plus one.

    StartingIndex = 0;

    for( FtObject = FtSet->Members; FtObject; FtObject = FtObject->Next ) {

        if( FtObject->MemberIndex > StartingIndex ) {

            StartingIndex = FtObject->MemberIndex;
        }
    }

    StartingIndex++;


    // Associate the ft-set's information with each of the
    // new regions.

    for( i = 0; i < RegionCount; i++ ) {

        FtObject = Malloc( sizeof(FT_OBJECT) );

        FtObject->Set = FtSet;
        FtObject->MemberIndex = StartingIndex + i;
        FtObject->Next = FtSet->Members;
        FtObject->State = Healthy;
        FtSet->Members = FtObject;

        SET_FT_OBJECT(Regions[i],FtObject);
    }

    FtSet->Status = FtSetExtended;
}


PULONG DiskHadRegistryEntry;

ULONG
ActualPartitionCount(
    IN PDISKSTATE DiskState
    )

/*++

Routine Description:

    Given a disk, this routine counts the number of partitions on it.
    The number of partitions is the number of regions that appear in
    the NT name space (ie, the maximum value of <x> in
    \device\harddiskn\partition<x>).

Arguments:

    DiskState - descriptor for the disk in question.

Return Value:

    Partition count (may be 0).

--*/

{
    ULONG i,PartitionCount=0;
    PREGION_DESCRIPTOR region;

    for(i=0; i<DiskState->RegionCount; i++) {
        region = &DiskState->RegionArray[i];
        if((region->SysID != SYSID_UNUSED) &&
           !IsExtended(region->SysID) &&
           IsRecognizedPartition(region->SysID)) {

            PartitionCount++;
        }
    }
    return(PartitionCount);
}


PDISKSTATE
LookUpDiskBySignature(
    IN ULONG Signature
    )

/*++

Routine Description:

    This routine will look through the disk descriptors created by the
    fdisk back end looking for a disk with a particular signature.

Arguments:

    Signature - signature of disk to locate

Return Value:

    Pointer to disk descriptor or NULL if no disk with the given signature
    was found.

--*/

{
    ULONG disk;
    PDISKSTATE ds;

    for(disk=0; disk<DiskCount; disk++) {
        ds = Disks[disk];
        if(ds->Signature == Signature) {
            return(ds);
        }
    }
    return(NULL);
}


PREGION_DESCRIPTOR
LookUpPartition(
    IN PDISKSTATE    DiskState,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length
    )

/*++

Routine Description:

    This routine will look through a region descriptor array for a
    partition with a particular length and starting offset.

Arguments:

    DiskState       - disk on which to locate the partition
    Offset          - offset of partition on the disk to find
    Length          - size of the partition to find

Return Value:

    Pointer to region descriptor or NULL if no such partition on that disk

--*/

{
    ULONG              regionIndex,
                       maxRegion = DiskState->RegionCount;
    PREGION_DESCRIPTOR regionDescriptor;
    LARGE_INTEGER      offset,
                       length;

    for (regionIndex=0; regionIndex<maxRegion; regionIndex++) {

        regionDescriptor = &DiskState->RegionArray[regionIndex];

        if ((regionDescriptor->SysID != SYSID_UNUSED) && !IsExtended(regionDescriptor->SysID)) {

            offset = FdGetExactOffset(regionDescriptor);
            length = FdGetExactSize(regionDescriptor, FALSE);

            if ((offset.LowPart  == Offset.LowPart )
             && (offset.HighPart == Offset.HighPart)
             && (length.LowPart  == Length.LowPart)
             && (length.HighPart == Length.HighPart)) {
                return regionDescriptor;
            }
        }
    }
    return NULL;
}


VOID
AddObjectToSet(
    IN PFT_OBJECT FtObjectToAdd,
    IN FT_TYPE    FtType,
    IN USHORT     FtGroup
    )

/*++

Routine Description:

    Find the FtSet for that this object belongs to and insert
    it into the chain of members.  If the set cannot be found
    in the existing collection of sets, create a new one.

Arguments:

    FtObjectToAdd - the object point to be added.
    FtType        - the type of the FT set.
    FtGroup       - group for this object.

Return Value:

    None

--*/

{
    PFT_OBJECT_SET ftSet = FtObjects;

    while (ftSet) {

        if ((ftSet->Type == FtType) && (ftSet->Ordinal == FtGroup)) {
            break;
        }
        ftSet = ftSet->Next;
    }

    if (!ftSet) {

        // There is no such existing ft set.  Create one.

        ftSet = Malloc(sizeof(FT_OBJECT_SET));

        ftSet->Status = FtSetHealthy;
        ftSet->Type = FtType;
        ftSet->Ordinal = FtGroup;
        ftSet->Members = NULL;
        ftSet->Next = FtObjects;
        ftSet->Member0 = NULL;
        ftSet->NumberOfMembers = 0;
        FtObjects = ftSet;
    }

    FDASSERT(ftSet);

    FtObjectToAdd->Next = ftSet->Members;
    ftSet->Members = FtObjectToAdd;
    ftSet->NumberOfMembers++;
    FtObjectToAdd->Set = ftSet;

    if (FtObjectToAdd->MemberIndex == 0) {
        ftSet->Member0 = FtObjectToAdd;
    }

    if (FtType == StripeWithParity || FtType == Mirror) {

        // Update the set's state based on the state of the new member:

        switch (FtObjectToAdd->State) {

        case Healthy:

            // Doesn't change state of set.

            break;

        case Regenerating:
            ftSet->Status = (ftSet->Status == FtSetHealthy ||
                             ftSet->Status == FtSetRegenerating)
                          ? FtSetRegenerating
                          : FtSetBroken;
            break;

        case Initializing:
            ftSet->Status = (ftSet->Status == FtSetHealthy ||
                             ftSet->Status == FtSetInitializing)
                          ? FtSetInitializing
                          : FtSetBroken;
            break;

        default:

            // If only one member is bad, the set is recoverable;
            // otherwise, it's broken.

            ftSet->Status = (ftSet->Status == FtSetHealthy)
                          ? FtSetRecoverable
                          : FtSetDisabled;
            break;
        }
    }
}


ULONG
InitializeFt(
    IN BOOL DiskSignaturesCreated
    )

/*++

Routine Description:

    Search the disk registry information to construct the FT
    relationships in the system.

Arguments:

    DiskSignaturesCreated - boolean to indicate that new disks
                            were located in the system.

Return Value:

    An error code if the disk registry could not be obtained.

--*/

{
    ULONG              disk,
                       partitionIndex,
                       partitionCount;
    PDISK_REGISTRY     diskRegistry;
    PDISK_PARTITION    partition;
    PDISK_DESCRIPTION  diskDescription;
    PDISKSTATE         diskState;
    PREGION_DESCRIPTOR regionDescriptor;
    DWORD              ec;
    BOOL               configDiskChanged = FALSE,
                       configMissingDisk = FALSE,
                       configExtraDisk   = FALSE;
    PFT_OBJECT         ftObject;
    BOOL               anyDisksOffLine;
    TCHAR              name[100];


    RememberedDisks = Malloc(0);
    RememberedDiskCount = 0;

    ec = MyDiskRegistryGet(&diskRegistry);
    if (ec != NO_ERROR) {

        FDLOG((0,"InitializeFt: Error %u from MyDiskRegistryGet\n",ec));

        return ec;
    }

    DiskHadRegistryEntry = Malloc(DiskCount * sizeof(ULONG));
    memset(DiskHadRegistryEntry,0,DiskCount * sizeof(ULONG));

    diskDescription = diskRegistry->Disks;

    for (disk = 0; disk < diskRegistry->NumberOfDisks; disk++) {

        // For the disk described in the registry, look up the
        // corresponding actual disk found by the fdisk init code.

        diskState = LookUpDiskBySignature(diskDescription->Signature);

        if (diskState) {

            FDLOG((2,
                  "InitializeFt: disk w/ signature %08lx is disk #%u\n",
                  diskDescription->Signature,
                  diskState->Disk));

            DiskHadRegistryEntry[diskState->Disk]++;

            partitionCount = ActualPartitionCount(diskState);

            if (partitionCount != diskDescription->NumberOfPartitions) {

                FDLOG((1,"InitializeFt: partition counts for disk %08lx don't match:\n", diskState->Signature));
                FDLOG((1,"    Count from actual disk: %u\n",partitionCount));
                FDLOG((1,"    Count from registry   : %u\n",diskDescription->NumberOfPartitions));

                configDiskChanged = TRUE;
            }
        } else {

            // there's an entry in the registry that does not have a
            // real disk to match.  Remember this disk; if it has any
            // FT partitions, we also want to display a message telling
            // the user that something's missing.

            FDLOG((1,"InitializeFt: Entry for disk w/ signature %08lx has no matching real disk\n", diskDescription->Signature));

            for (partitionIndex = 0; partitionIndex < diskDescription->NumberOfPartitions; partitionIndex++) {

                partition = &diskDescription->Partitions[partitionIndex];
                if (partition->FtType != NotAnFtMember) {

                    // This disk has an FT partition, so Windisk will
                    // want to tell the user that some disks are missing.

                    configMissingDisk = TRUE;
                    break;
                }
            }

            FdpRememberDisk(diskDescription);
        }

        for (partitionIndex = 0; partitionIndex < diskDescription->NumberOfPartitions; partitionIndex++) {

            partition = &diskDescription->Partitions[partitionIndex];
            regionDescriptor = NULL;

            if (diskState) {
                regionDescriptor = LookUpPartition(diskState,
                                                   partition->StartingOffset,
                                                   partition->Length);
            }

            // At this point one of three conditions exists.
            //
            // 1. There is no disk related to this registry information
            //    diskState == NULL && regionDescriptor == NULL
            // 2. There is a disk, but no partition related to this information
            //    diskState != NULL && regionDescriptor == NULL
            // 3. There is a disk and a partition related to this information
            //    diskState != NULL && regionDescriptor != NULL
            //
            // In any of these conditions, if the registry entry is part
            // of an FT set and FT object must be created.
            //
            // that corresponds to a partition's entry in the
            // disk registry database.

            if (partition->FtType != NotAnFtMember) {
                ftObject = Malloc(sizeof(FT_OBJECT));
                ftObject->Next = NULL;
                ftObject->Set = NULL;
                ftObject->MemberIndex = partition->FtMember;
                ftObject->State = partition->FtState;

                // if a partition was actually found there will be a
                // regionDescriptor that needs to be updated.

                if (regionDescriptor && regionDescriptor->PersistentData) {
                    FT_SET_STATUS setState;
                    ULONG         numberOfMembers;

                    SET_FT_OBJECT(regionDescriptor, ftObject);

                    // Before the drive letter is moved into the region
                    // data, be certain that the FT volume exists at this
                    // drive letter.

                    LowFtVolumeStatusByLetter(partition->DriveLetter,
                                              &setState,
                                              &numberOfMembers);

                    // If the numberOfMembers gets set to 1 then
                    // this letter is not the letter for the FT set,
                    // but rather a default letter assigned because the
                    // FT sets letter could not be assigned.

                    if (numberOfMembers > 1) {
                        PERSISTENT_DATA(regionDescriptor)->DriveLetter = partition->DriveLetter;
                    }
                } else {

                    // There is no region for this partition
                    // so update the set state.

                    ftObject->State = Orphaned;
                }

                // Now place the ft object in the correct set,
                // creating the set if necessary.

                AddObjectToSet(ftObject, partition->FtType, partition->FtGroup);
                MaintainOrdinalTables(partition->FtType, (ULONG) partition->FtGroup);
            }
        }

        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }
    Free(diskRegistry);

    // Check to see if every disk found by the fdisk back end has a
    // corresponding registry entry.

    for (disk = 0; disk < DiskCount; disk++) {

        if (Disks[disk]->OffLine) {
            continue;
        }

        if ((!DiskHadRegistryEntry[disk]) && (!IsRemovable(disk))) {

            // a real disk does not have a matching registry entry.

            FDLOG((1,"InitializeFt: Disk %u does not have a registry entry (disk sig = %08lx)\n",disk,Disks[disk]->Signature));
            configExtraDisk = TRUE;
        }
    }

    // Determine whether any disks are off line

    anyDisksOffLine = FALSE;
    for (disk = 0; disk < DiskCount; disk++) {
        if (Disks[disk]->OffLine) {
            anyDisksOffLine = TRUE;
            break;
        }
    }

    if (configMissingDisk || anyDisksOffLine) {
        WarningDialog(MSG_CONFIG_MISSING_DISK);
    }
    if (configDiskChanged) {
        RegistryChanged = TRUE;
        WarningDialog(MSG_CONFIG_DISK_CHANGED);
    }
    if (configExtraDisk || DiskSignaturesCreated) {

        BOOL BadConfigSet = FALSE;

        WarningDialog(MSG_CONFIG_EXTRA_DISK);

        // Update ft signature on each disk for which a new signature
        // was created. and update registry for each disk with
        // DiskHadRegistryEntry[Disk] == 0.

        for (disk = 0; disk < DiskCount; disk++) {
            BOOL b1 = TRUE,
                 b2 = TRUE;

            if (Disks[disk]->OffLine) {
                continue;
            }

            wsprintf(name, DiskN, disk);
            if (Disks[disk]->SigWasCreated) {
                if (ConfirmationDialog(MSG_NO_SIGNATURE, MB_ICONEXCLAMATION | MB_YESNO, name) == IDYES) {
                    b1 = (MasterBootCode(disk, Disks[disk]->Signature, TRUE, TRUE) == NO_ERROR);
                } else {
                    Disks[disk]->OffLine = TRUE;
                    continue;
                }
            }

            if (!DiskHadRegistryEntry[disk]) {
                ULONG size;

                size = FdpDetermineDiskDescriptionSize(Disks[disk]);

                diskDescription = Malloc(size);
                FdpConstructDiskDescription(Disks[disk], diskDescription);

                FDLOG((2,"InitializeFt: Adding new disk %08lx to registry.\n", diskDescription->Signature));
                LOG_ONE_DISK_REGISTRY_DISK_ENTRY("InitializeFt", diskDescription);

                b2 = (EC(DiskRegistryAddNewDisk(diskDescription)) == NO_ERROR);
                Free(diskDescription);
            }

            if (!(b1 && b2)) {
                BadConfigSet = TRUE;
            }
        }

        if (BadConfigSet) {
            ErrorDialog(MSG_BAD_CONFIG_SET);
        }
    }

    return NO_ERROR;
}

BOOLEAN
NewConfigurationRequiresFt(
    VOID
    )

/*++

Routine Description:

    Search the diskstate and region arrays to determine if a single
    FtDisk element (i.e. stripe, stripe set with parity, mirror or
    volume set) is contained in the configuration.

Arguments:

    None

Return Value:

    TRUE if the new configuration requires the FtDisk driver.
    FALSE otherwise.

--*/

{
    ULONG              disk,
                       region;
    PDISKSTATE         diskState;
    PREGION_DESCRIPTOR regionDescriptor;

    // Look at all disks in the system.

    for (disk = 0; disk < DiskCount; disk++) {

        diskState = Disks[disk];
        if (diskState->OffLine || IsDiskRemovable[disk]) {
            continue;
        }

        // Check each region on the disk.

        for (region = 0; region < diskState->RegionCount; region++) {

            regionDescriptor = &diskState->RegionArray[region];
            if ((regionDescriptor->SysID != SYSID_UNUSED) && !IsExtended(regionDescriptor->SysID) && IsRecognizedPartition(regionDescriptor->SysID)) {

                // If a single region has an FT Object, then FT
                // is required and the search may be stopped.

                if (GET_FT_OBJECT(regionDescriptor)) {
                    return TRUE;
                }
            }
        }
    }

    // no FtObject was found.

    return FALSE;
}

ULONG
SaveFt(
    VOID
    )

/*++

Routine Description:

    This routine walks all of the internal structures and creates
    the interface structure for the DiskRegistry interface.

Arguments:

    None

Return Value:

    success/failure code.  NO_ERROR is success.

--*/

{
    ULONG             i;
    ULONG             disk,
                      partition;
    ULONG             size;
    PDISK_REGISTRY    diskRegistry;
    PDISK_DESCRIPTION diskDescription;
    PBYTE             start,
                      end;
    DWORD             ec;
    ULONG             offLineDiskCount;
    ULONG             removableDiskCount;

    // First count partitions and disks so we can allocate a structure
    // of the correct size.

    size = sizeof(DISK_REGISTRY) - sizeof(DISK_DESCRIPTION);
    offLineDiskCount = 0;
    removableDiskCount = 0;

    for (i=0; i<DiskCount; i++) {

        if (Disks[i]->OffLine) {
            offLineDiskCount++;
        } else if (IsDiskRemovable[i]) {
            removableDiskCount++;
        } else {
            size += FdpDetermineDiskDescriptionSize(Disks[i]);
        }
    }

    // Account for remembered disks.

    size += RememberedDiskCount * sizeof(DISK_DESCRIPTION);
    for (i=0; i<RememberedDiskCount; i++) {
        if (RememberedDisks[i]->NumberOfPartitions > 1) {
            size += (RememberedDisks[i]->NumberOfPartitions - 1) * sizeof(DISK_PARTITION);
        }
    }

    diskRegistry = Malloc(size);
    diskRegistry->NumberOfDisks = (USHORT)(   DiskCount
                                            + RememberedDiskCount
                                            - offLineDiskCount
                                            - removableDiskCount);
    diskRegistry->ReservedShort = 0;
    diskDescription = diskRegistry->Disks;
    for (disk=0; disk<DiskCount; disk++) {

        if (Disks[disk]->OffLine || IsDiskRemovable[disk]) {
            continue;
        }

        partition = FdpConstructDiskDescription(Disks[disk], diskDescription);

        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[partition];
    }

    // Toss in remembered disks.

    for (i=0; i<RememberedDiskCount; i++) {

        // Compute the beginning and end of this remembered disk's
        // Disk Description:

        partition =  RememberedDisks[i]->NumberOfPartitions;
        start = (PBYTE)RememberedDisks[i];
        end   = (PBYTE)&(RememberedDisks[i]->Partitions[partition]);

        RtlMoveMemory(diskDescription, RememberedDisks[i], end - start);
        diskDescription = (PDISK_DESCRIPTION)&diskDescription->Partitions[partition];
    }

    LOG_DISK_REGISTRY("SaveFt", diskRegistry);

    ec = EC(DiskRegistrySet(diskRegistry));
    Free(diskRegistry);

    if (ec == NO_ERROR) {
        FdpInitializeMirrors();
    }

    return(ec);
}


ULONG
FdpDetermineDiskDescriptionSize(
    PDISKSTATE DiskState
    )

/*++

Routine Description:

    This routine takes a pointer to a disk and determines how much
    memory is needed to contain the description of the disk by
    counting the number of partitions on the disk and multiplying
    the appropriate counts by the appropriate size of the structures.

Arguments:

    DiskState - the disk in question.

Return Value:

    The memory size needed to contain all of the information on the disk.

--*/

{
    ULONG partitionCount;
    ULONG size;

    if (DiskState->OffLine) {
        return(0);
    }

    size = sizeof(DISK_DESCRIPTION);
    partitionCount = ActualPartitionCount(DiskState);
    size += (partitionCount ? partitionCount-1 : 0) * sizeof(DISK_PARTITION);

    return(size);
}


ULONG
FdpConstructDiskDescription(
    IN  PDISKSTATE        DiskState,
    OUT PDISK_DESCRIPTION DiskDescription
    )

/*++

Routine Description:

    Given a disk state pointer as input, construct the FtRegistry
    structure to describe the partitions on the disk.

Arguments:

    DiskState - the disk for which to construct the information
    DiskDescription - the memory location where the registry
                      structure is to be created.

Return Value:

    The number of partitions described in the DiskDescription.

--*/

{
    PDISKSTATE         ds = DiskState;
    ULONG              partition,
                       region;
    PREGION_DESCRIPTOR regionDescriptor;
    PDISK_PARTITION    diskPartition;
    CHAR               driveLetter;
    BOOLEAN            assignDriveLetter;
    PFT_OBJECT         ftObject;
    PFT_OBJECT_SET     ftSet;

    partition = 0;

    for (region=0; region<ds->RegionCount; region++) {

        regionDescriptor = &ds->RegionArray[region];

        if ((regionDescriptor->SysID != SYSID_UNUSED) && !IsExtended(regionDescriptor->SysID) && IsRecognizedPartition(regionDescriptor->SysID)) {

            diskPartition = &DiskDescription->Partitions[partition++];

            diskPartition->StartingOffset = FdGetExactOffset(regionDescriptor);
            diskPartition->Length = FdGetExactSize(regionDescriptor, FALSE);
            diskPartition->LogicalNumber = (USHORT)regionDescriptor->PartitionNumber;

            switch (driveLetter = PERSISTENT_DATA(regionDescriptor)->DriveLetter) {
            case NO_DRIVE_LETTER_YET:
                assignDriveLetter = TRUE;
                driveLetter = 0;
                break;
            case NO_DRIVE_LETTER_EVER:
                assignDriveLetter = FALSE;
                driveLetter = 0;
                break;
            default:
                assignDriveLetter = TRUE;
                break;
            }

            diskPartition->DriveLetter = driveLetter;
            diskPartition->FtLength.LowPart = 0;
            diskPartition->FtLength.HighPart = 0;
            diskPartition->ReservedTwoLongs[0] = 0;
            diskPartition->ReservedTwoLongs[1] = 0;
            diskPartition->Modified = TRUE;

            if (ftObject = GET_FT_OBJECT(regionDescriptor)) {
                PREGION_DESCRIPTOR tmpDescriptor;

                ftSet = ftObject->Set;

                tmpDescriptor = LocateRegionForFtObject(ftSet->Member0);

                // Only update status if member zero is present.
                // otherwise the status is know to be Orphaned or
                // needs regeneration.
#if 0

// need to do something here, but currently this does not work.

                if (tmpDescriptor) {
                ULONG          numberOfMembers;
                FT_SET_STATUS  setState;
                STATUS_CODE    status;

                    // If the partition number is zero, then this set
                    // has not been committed to the disk yet.  Only
                    // update status for existing sets.

                    if ((tmpDescriptor->PartitionNumber) &&
                        (ftSet->Status != FtSetNew) &&
                        (ftSet->Status != FtSetNewNeedsInitialization)) {
                        status = LowFtVolumeStatus(tmpDescriptor->Disk,
                                                   tmpDescriptor->PartitionNumber,
                                                   &setState,
                                                   &numberOfMembers);
                        if (status == OK_STATUS) {
                            if (ftSet->Status != setState) {

                                // Problem here - the FT driver has
                                // updated the status of the set after
                                // windisk last got the status.  Need
                                // to restart the process of building
                                // the FT information after updating
                                // the set to the new state.

                                FdftUpdateFtObjectSet(ftSet, setState);

                                // now recurse and start over

                                status =
                                FdpConstructDiskDescription(DiskState,
                                                            DiskDescription);
                                return status;
                            }
                        }
                    }
                }
#endif
                diskPartition->FtState = ftObject->State;
                diskPartition->FtType = ftSet->Type;
                diskPartition->FtGroup = (USHORT)ftSet->Ordinal;
                diskPartition->FtMember = (USHORT)ftObject->MemberIndex;
                if (assignDriveLetter && (ftObject == ftObject->Set->Member0)) {
                    diskPartition->AssignDriveLetter = TRUE;
                } else {
                    diskPartition->AssignDriveLetter = FALSE;
                }

            } else {

                diskPartition->FtState = Healthy;
                diskPartition->FtType = NotAnFtMember;
                diskPartition->FtGroup = (USHORT)(-1);
                diskPartition->FtMember = 0;
                diskPartition->AssignDriveLetter = assignDriveLetter;
            }
        }
    }

    DiskDescription->NumberOfPartitions = (USHORT)partition;
    DiskDescription->Signature = ds->Signature;
    DiskDescription->ReservedShort = 0;
    return(partition);
}


VOID
FdpRememberDisk(
    IN PDISK_DESCRIPTION DiskDescription
    )

/*++

Routine Description:

    Make a copy of a registry disk description structure for later use.

Arguments:

    DiskDescription - supplies pointer to the registry descriptor for
        the disk in question.

Return Value:

    None.

--*/

{
    PDISK_DESCRIPTION diskDescription;
    ULONG Size;

    // Only bother remembering disks with at least one partition.

    if (DiskDescription->NumberOfPartitions == 0) {

        return;
    }

    // Compute the size of the structure

    Size = sizeof(DISK_DESCRIPTION);
    if (DiskDescription->NumberOfPartitions > 1) {
        Size += (DiskDescription->NumberOfPartitions - 1) * sizeof(DISK_PARTITION);
    }

    diskDescription = Malloc(Size);
    RtlMoveMemory(diskDescription, DiskDescription, Size);

    RememberedDisks = Realloc(RememberedDisks,
                              (RememberedDiskCount + 1) * sizeof(PDISK_DESCRIPTION));
    RememberedDisks[RememberedDiskCount++] = diskDescription;

    FDLOG((2,
          "FdpRememberDisk: remembered disk %08lx, remembered count = %u\n",
          diskDescription->Signature,
          RememberedDiskCount));
}


VOID
FdpInitializeMirrors(
    VOID
    )

/*++

Routine Description:

    For each existing partition that was mirrored by the user during this Disk Manager
    session, call the FT driver to register initialization of the mirror (ie, cause
    the primary to be copied to the secondary).  Perform a similar initialization for
    each stripe set with parity created by the user.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFT_OBJECT_SET ftSet;
    PFT_OBJECT     ftMember;

    // Look through the list of FT sets for mirrored pairs and parity stripes

    for (ftSet = FtObjects; ftSet; ftSet = ftSet->Next) {

        // If the set needs initialization, or was recovered,
        // call the FT driver.

        switch (ftSet->Status) {

        case FtSetNewNeedsInitialization:

            DiskRegistryInitializeSet((USHORT)ftSet->Type,
                                      (USHORT)ftSet->Ordinal);
            ftSet->Status = FtSetInitializing;
            break;

        case FtSetRecovered:

            // Find the member that needs to be addressed.

            for (ftMember=ftSet->Members; ftMember; ftMember=ftMember->Next) {
                if (ftMember->State == Regenerating) {
                    break;
                }
            }

            DiskRegistryRegenerateSet((USHORT)ftSet->Type,
                                      (USHORT)ftSet->Ordinal,
                                      (USHORT)ftMember->MemberIndex);
            ftSet->Status = FtSetRegenerating;
            break;

        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fc\fc.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    FC

Abstract:

    FC is a DOS-5 compatible file comparison utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Notes:

    This FC is a port of the DOS5 FC code. It has been slightly modified
    to use some of the ULIB functionality (e.g. argument parsing), however
    it does not make full use of the ULIB functionality (e.g. it uses
    stdio.h functions for file handling).



Revision History:

--*/


/****************************************************************************
    File Compare

    Fcom compares two files in either a line-by-line mode or in a strict
    BYTE-by-BYTE mode.

    The BYTE-by-BYTE mode is simple; merely read both files and print the
    offsets where they differ and the contents.

    The line compare mode attempts to isolate differences in ranges of lines.
    Two buffers of lines are read and compared.  No hashing of lines needs
    to be done; hashing only speedily tells you when things are different,
    not the same.  Most files run through this are expected to be largely
    the same.  Thus, hashing buys nothing.


***********************************************************************
The algorithm that immediately follows does not work.  There is an error
somewhere in the range of lines 11 on. An alternative explanation follows.
                                                            KGS
************************************************************************

    [0]     Fill buffers
    [1]     If both buffers are empty then
    [1.1]       Done
    [2]     Adjust buffers so 1st differing lines are at top.
    [3]     If buffers are empty then
    [3.1]       Goto [0]

    This is the difficult part.  We assume that there is a sequence of inserts,
    deletes and replacements that will bring the buffers back into alignment.

    [4]     xd = yd = FALSE
    [5]     xc = yc = 1
    [6]     xp = yp = 1
    [7]     If buffer1[xc] and buffer2[yp] begin a "sync" range then
    [7.1]       Output lines 1 through xc-1 in buffer 1
    [7.2]       Output lines 1 through yp-1 in buffer 2
    [7.3]       Adjust buffer 1 so line xc is at beginning
    [7.4]       Adjust buffer 2 so line yp is at beginning
    [7.5]       Goto [0]
    [8]     If buffer1[xp] and buffer2[yc] begin a "sync" range then
    [8.1]       Output lines 1 through xp-1 in buffer 1
    [8.2]       Output lines 1 through yc-1 in buffer 2
    [8.3]       Adjust buffer 1 so line xp is at beginning
    [8.4]       Adjust buffer 2 so line yc is at beginning
    [8.5]       Goto [0]
    [9]     xp = xp + 1
    [10]    if xp > xc then
    [10.1]      xp = 1
    [10.2]      xc = xc + 1
    [10.3]      if xc > number of lines in buffer 1 then
    [10.4]          xc = number of lines
    [10.5]          xd = TRUE
    [11]    if yp > yc then
    [11.1]      yp = 1
    [11.2]      yc = yc + 1
    [11.3]      if yc > number of lines in buffer 2 then
    [11.4]          yc = number of lines
    [11.5]          yd = TRUE
    [12]    if not xd or not yd then
    [12.1]      goto [6]

    At this point there is no possible match between the buffers.  For
    simplicity, we punt.

    [13]    Display error message.

EXPLANATION 2

    This is a variation of the Largest Common Subsequence problem.  A
    detailed explanation of this can be found on p 189 of Data Structures
    and Algorithms by Aho Hopcroft and Ulman.

    FC maintains two buffers within which it tries to find the Largest Common
    Subsequence (The largest common subsequence is simply the pattern in
    buffer1 that yields the most matches with the pattern in buffer2, or the
    pattern in buffer2 that yields the most matches with the pattern in buffer1)

    FC makes a simplifying assumption that the contents of one buffer can be
    converted to the contents of the other buffer by deleting the lines that are
    different between the two buffers.

    Two indices into each buffer are maintained:

            xc, yc == point to the last line that has been scanned up to now

            xp, yp == point to the first line that has not been exhaustively
                      compared to lines 0 - #c in the other buffer.

    FC now makes a second simplifying assumption:
        It is unnecessary to do any calculations on lines that are equal.

    Hence FC scans File1 and File two line by line until a difference is
    encountered.

    When a difference is encountered the two buffers are filled such that
    the line containing the first difference heads the buffer. The following
    exhaustive search algorithm is applied to find the first "sync" occurance.
    (The below is simplified to use == for comparison.  In practice more than
    one line needs to match for a "sync" to be established).

            FOR xc,yc = 1; xc,yx <= sizeof( BUFFERS ); xc++, yc++

                FOR xp,yp = 1; xp,yp <= xc,yc; xp++, yp++

                    IF ( BUFFER1[xp] == BUFFER2[yc] )

                        Then the range of lines BUFFER1[ 1 ... xp ] and
                        BUFFER2[ 1 ... yc ] need to be deleted for the
                        two files to be equal.  Therefore DISPLAY these
                        ranges, and begin scanning both files starting at
                        the matching lines.
                    FI

                    IF ( BUFFER1[yp] == BUFFER2[xc] )

                        Then the range of lines BUFFER2[ 1 ... yp ] and
                        BUFFER1[ 1 ... xc ] need to be deleted for the
                        two files to be equal.  Therefore DISPLAY these
                        ranges, and begin scanning both files starting at
                        the matching lines.
                    FI
                FOREND
            FOREND

    If a match is not found within the buffers, the message "RESYNC FAILED"
    is issued and further comparison is aborted since there is no valid way
    to find further matching lines.

END EXPLANATION 2

    Certain flags may be set to modify the behavior of the comparison:

    -a      abbreviated output.  Rather than displaying all of the modified
            ranges, just display the beginning, ... and the ending difference
    -b      compare the files in binary (or BYTE-by-BYTE) mode.  This mode is
            default on .EXE, .OBJ, .LIB, .COM, .BIN, and .SYS files
    -c      ignore case on compare (cmp = strcmpi instead of strcmp)
    -l      compare files in line-by-line mode
    -lb n   set the size of the internal line buffer to n lines from default
            of 100
    -u      Files to be compared are UNICODE text files
    -w      ignore blank lines and white space (ignore len 0, use strcmps)
    -t      do not untabify (use fgets instead of fgetl)
    -n      output the line number also
    -NNNN   set the number of lines to resynchronize to n which defaults
            to 2.  Failure to have this value set correctly can result in
            odd output:
              file1:        file2:
                    abcdefg       abcdefg
                    aaaaaaa       aaaaaab
                    aaaaaaa       aaaaaaa
                    aaaaaaa       aaaaaaa
                    abcdefg       abcdefg

            with default sync of 2 yields:          with sync => 3 yields:

                    *****f1                             *****f1
                    abcdefg                             abcdefg
                    aaaaaaa                             aaaaaaa
                    *****f2                             aaaaaaa
                    abcdefg                             *****f2
                    aaaaaab                             abcdefg
                    aaaaaaa                             aaaaaab
                                                        aaaaaaa
                    *****f1
                    aaaaaaa
                    aaaaaaa
                    abcdefg
                    *****f2
                    aaaaaaa
                    abcdefg

WARNING:
        This program makes use of GOTO's and hence is not as straightforward
        as it could be!  CAVEAT PROGRAMMER.
****************************************************************************/


#include "ulib.hxx"
#include "fc.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "bytestrm.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "mbstr.hxx"
#include "system.hxx"
#include "wstring.hxx"

#include <malloc.h>
#include <process.h>
#include <stdlib.h>
#include <math.h>
#include <locale.h>

/**************************************************************************/
/* main                                                                   */
/**************************************************************************/

INT __cdecl
main (
    )
{
    DEFINE_CLASS_DESCRIPTOR( FC );

    {
        FC Fc;

        if ( Fc.Initialize() ) {

            return Fc.Fcmain();
        }
    }

    return FAILURE;
}




CHAR *ExtBin[] = { "EXE", "OBJ", "LIB",
                 "COM", "BIN", "SYS", NULL };




DEFINE_CONSTRUCTOR( FC,  PROGRAM );


FC::~FC () {
}



BOOLEAN FC::Initialize() {


    if ( PROGRAM::Initialize() ) {

        ValidateVersion();

        ctSync  = -1;                 // number of lines required to sync
        cLine   = -1;                 // number of lines in internal buffs

        fAbbrev = FALSE;              // abbreviated output
        fBinary = FALSE;              // binary comparison
        fLine   = FALSE;              // line comparison
        fNumb   = FALSE;              // display line numbers
        fCase   = TRUE;               // case is significant
        fIgnore = FALSE;              // ignore spaces and blank lines
        fSkipOffline = TRUE;          // skip offline files

        fOfflineSkipped = FALSE;      // no files are skipped

#ifdef  DEBUG
        fDebug = FALSE;
#endif

        fExpandTabs = TRUE;
        // funcRead = (int (*)(char *,int,FILE *))fgetl;

        extBin = (CHAR **)ExtBin;

        return  ParseArguments();
    }

    return FALSE;
}





BOOLEAN
FC::ParseArguments(
    )
{

    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    ARRAY               ArrayOfArg;

    PATH_ARGUMENT       ProgramName;
    FLAG_ARGUMENT       FlagAbbreviate;
    FLAG_ARGUMENT       FlagAsciiCompare;
    FLAG_ARGUMENT       FlagBinaryCompare;
    FLAG_ARGUMENT       FlagCaseInsensitive;
    FLAG_ARGUMENT       FlagCompression;
    FLAG_ARGUMENT       FlagExpansion;
    FLAG_ARGUMENT       FlagLineNumber;
    FLAG_ARGUMENT       FlagRequestHelp;
    FLAG_ARGUMENT       FlagUnicode;
    FLAG_ARGUMENT       FlagIncludeOffline;
    FLAG_ARGUMENT       FlagIncludeOffline2;
    LONG_ARGUMENT       LongBufferSize;
#ifdef DEBUG
    FLAG_ARGUMENT       FlagDebug;
#endif
    STRING_ARGUMENT     LongMatch;
    PATH_ARGUMENT       InFile1;
    PATH_ARGUMENT       InFile2;

    LONG                Long;
    INT                 i;


    if( !LexArray.Initialize() ) {
        DebugAbort( "LexArray.Initialize() Failed!\n" );
        return( FALSE );
    }
    if( !ArgLex.Initialize(&LexArray) ) {
        DebugAbort( "ArgLex.Initialize() Failed!\n" );
        return( FALSE );
    }

    // Allow only the '/' as a valid switch
    ArgLex.PutSwitches("/");
    ArgLex.SetCaseSensitive( FALSE );

    ArgLex.PutStartQuotes("\"");
    ArgLex.PutEndQuotes("\"");
    ArgLex.PutSeparators(" \t");

    if( !ArgLex.PrepareToParse() ) {
        DebugAbort( "ArgLex.PrepareToParse() Failed!\n" );
        return( FALSE );
    }

    if( !ProgramName.Initialize("*")                ||
        !FlagAbbreviate.Initialize("/A")            ||
        !FlagAsciiCompare.Initialize("/L")          ||
        !FlagBinaryCompare.Initialize("/B")         ||
        !FlagCaseInsensitive.Initialize("/C")       ||
        !FlagCompression.Initialize("/W")           ||
        !FlagExpansion.Initialize("/T")             ||
        !FlagLineNumber.Initialize("/N")            ||
        !FlagRequestHelp.Initialize("/?")           ||
        !FlagUnicode.Initialize("/U")               ||
        !FlagIncludeOffline.Initialize("/OFFLINE")  ||
        !FlagIncludeOffline2.Initialize("/OFF")     ||
#ifdef DEBUG
        !FlagDebug.Initialize("/D")                 ||
#endif
        !LongBufferSize.Initialize("/LB#")          ||
        !LongMatch.Initialize("/*")                 ||
        !InFile1.Initialize("*")                    ||
        !InFile2.Initialize("*") ) {

        DebugAbort( "Unable to Initialize some or all of the Arguments!\n" );
        return( FALSE );
    }


    if( !ArrayOfArg.Initialize() ) {
        DebugAbort( "ArrayOfArg.Initialize() Failed\n" );
        return( FALSE );
    }

    if( !ArrayOfArg.Put(&ProgramName)           ||
        !ArrayOfArg.Put(&FlagAbbreviate)        ||
        !ArrayOfArg.Put(&FlagAsciiCompare)      ||
        !ArrayOfArg.Put(&FlagBinaryCompare)     ||
        !ArrayOfArg.Put(&FlagCaseInsensitive)   ||
        !ArrayOfArg.Put(&FlagCompression)       ||
        !ArrayOfArg.Put(&FlagExpansion)         ||
        !ArrayOfArg.Put(&FlagLineNumber)        ||
        !ArrayOfArg.Put(&FlagRequestHelp)       ||
        !ArrayOfArg.Put(&FlagUnicode)           ||
        !ArrayOfArg.Put(&FlagIncludeOffline)    ||
        !ArrayOfArg.Put(&FlagIncludeOffline2)   ||
#ifdef DEBUG
        !ArrayOfArg.Put(&FlagDebug)             ||
#endif
        !ArrayOfArg.Put(&LongBufferSize)        ||
        !ArrayOfArg.Put(&LongMatch)             ||
        !ArrayOfArg.Put(&InFile1)               ||
        !ArrayOfArg.Put(&InFile2) ) {

        DebugAbort( "ArrayOfArg.Put() Failed!\n" );
        return( FALSE );
    }


    if( !( ArgLex.DoParsing( &ArrayOfArg ) ) ) {
        // For each incorrect command line parameter, FC displays the
        // following message:
        //
        //      FC: Invalid Switch
        //
        // It does *not* die if a parameter is unrecognized...(Dos does...)
        //
        DisplayMessage( MSG_FC_INVALID_SWITCH, ERROR_MESSAGE, "" );
        // return( FALSE );
    }



    //
    // It should now be safe to test the arguments for their values...
    //
    if( FlagRequestHelp.QueryFlag() ) {
        DisplayMessage( MSG_FC_HELP_MESSAGE, NORMAL_MESSAGE, "" );
        return( FALSE );
    }

    if( FlagBinaryCompare.QueryFlag() &&
        ( FlagAsciiCompare.QueryFlag() || FlagLineNumber.QueryFlag() ) ) {

        DisplayMessage( MSG_FC_INCOMPATIBLE_SWITCHES, ERROR_MESSAGE, "" );
        return( FALSE );
    }

    if( !InFile1.IsValueSet() ||
        !InFile2.IsValueSet() ) {
        DisplayMessage( MSG_FC_INSUFFICIENT_FILES, ERROR_MESSAGE, "" );
        return( FALSE );
    }


    //
    //   Convert filenames to upper case
    //
    _File1.Initialize( InFile1.GetPath() );
    _File2.Initialize( InFile2.GetPath() );

    ((PWSTRING)_File1.GetPathString())->Strupr();
    ((PWSTRING)_File2.GetPathString())->Strupr();


    fUnicode        = FlagUnicode.QueryFlag();
    fAbbrev         = FlagAbbreviate.QueryFlag();
    fCase           = !FlagCaseInsensitive.QueryFlag();
    fIgnore         = FlagCompression.QueryFlag();
    fNumb           = FlagLineNumber.QueryFlag();
    fBinary         = FlagBinaryCompare.QueryFlag();
    fSkipOffline    = ( !FlagIncludeOffline.QueryFlag() ) &&
                      ( !FlagIncludeOffline2.QueryFlag() );

    if ( FlagExpansion.QueryFlag() ) {
        fExpandTabs = FALSE;
        //funcRead = (int (*)(char *,int,FILE *))fgets;
    }

#ifdef DEBUG
    fDebug      = FlagDebug.QueryFlag();
#endif


    if ( LongBufferSize.IsValueSet() ) {
        cLine = (INT)LongBufferSize.QueryLong();
        fLine  = TRUE;
    } else {
        cLine = 100;
    }

    if ( LongMatch.IsValueSet() ) {
        if ( LongMatch.GetString()->QueryNumber( &Long ) ) {
            ctSync = (INT)Long;
            fLine  = TRUE;
        } else {

            DisplayMessage( MSG_FC_INVALID_SWITCH, ERROR_MESSAGE, "" );
            ctSync = 2;
        }
    } else {
        ctSync = 2;
    }

    if (!fBinary && !fLine) {

        DSTRING             ExtBin;
        PWSTRING            Ext = _File1.QueryExt();

        if ( Ext ) {
            for (i=0; extBin[i]; i++) {
                ExtBin.Initialize( extBin[i] );
                if ( !ExtBin.Stricmp( Ext ) ) {
                    fBinary = TRUE;
                    break;
                }
            }

            DELETE( Ext );
        }

        if (!fBinary) {
            fLine = TRUE;
        }
    }

    if (!fUnicode) {
        if (fIgnore) {
            if (fCase) {
                fCmp = MBSTR::Strcmps;
            } else {
                fCmp = MBSTR::Strcmpis;
            }
        } else {

            if (fCase) {
                fCmp = MBSTR::Strcmp;
            } else {
                fCmp = MBSTR::Stricmp;
            }
        }
    } else {
        if (fIgnore) {
            if (fCase) {
                fCmp_U = WSTRING::Strcmps;
            } else {
                fCmp_U = WSTRING::Strcmpis;
            }
        } else {

            if (fCase) {
                fCmp_U = WSTRING::Strcmp;
            } else {
                fCmp_U = WSTRING::Stricmp;
            }
        }
    }

    return( TRUE );

}





INT
FC::Fcmain
    (
    )
{
  return ParseFileNames();
}




/**************************************************************************/
/* BinaryCompare                                                          */
/**************************************************************************/

int
FC::BinaryCompare (
    PCWSTRING f1,
    PCWSTRING f2
    )
{

    PATH            FileName;
    PFSN_FILE       File1   = NULL;
    PFSN_FILE       File2   = NULL;
    PFILE_STREAM    Stream1 = NULL;
    PFILE_STREAM    Stream2 = NULL;;
    BYTE_STREAM     Bs1;
    BYTE_STREAM     Bs2;
    BYTE            c1, c2;
    ULONG64         pos;
    BOOLEAN         fSame;
    char            buffer[128];
    BOOLEAN         fFileSkipped;


    if ( !FileName.Initialize( f1 )                     ||
         !(File1 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream1 = File1->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL )) ||
         !Bs1.Initialize( Stream1 )
       ) {

        DELETE( Stream2 );
        DELETE( File2 );
        DELETE( Stream1 );
        DELETE( File1 );
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f1 );
            return FILES_NOT_FOUND;
        }
    }

    if ( !FileName.Initialize( f2 )                     ||
         !(File2 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream2 = File2->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL )) ||
         !Bs2.Initialize( Stream2 )
       ) {

        DELETE( Stream2 );
        DELETE( File2 );
        DELETE( Stream1 );
        DELETE( File1 );
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f2 );
            return FILES_NOT_FOUND;
        }
    }

    fSame = TRUE;
    pos   = 0;

    while ( TRUE ) {

      if ( Bs1.ReadByte( &c1 ) ) {

        if ( Bs2.ReadByte( &c2 ) ) {

          if (c1 != c2) {

            if (pos > MAXULONG) {
                sprintf( buffer, "%016I64X: %02X %02X", pos, c1, c2 );
            } else {
                sprintf( buffer, "%08I64X: %02X %02X", pos, c1, c2 );
            }
            DisplayMessage( MSG_FC_DATA, NORMAL_MESSAGE, "%s", buffer );
            fSame = FALSE;

          }

        } else {

          DisplayMessage( MSG_FC_FILES_DIFFERENT_LENGTH, NORMAL_MESSAGE, "%W%W", f1, f2 );
          fSame = FALSE;
          break;

        }

      } else {

        if ( Bs2.ReadByte( &c2 ) ) {

          DisplayMessage( MSG_FC_FILES_DIFFERENT_LENGTH, NORMAL_MESSAGE, "%W%W", f2, f1 );
          fSame = FALSE;
          break;

        } else {

          if (fSame) {
              DisplayMessage( MSG_FC_NO_DIFFERENCES, NORMAL_MESSAGE );
          }

          break;

        }
      }

      pos++;
    }

    DELETE( Stream2 );
    DELETE( File2 );
    DELETE( Stream1 );
    DELETE( File1 );

    return fSame ? SUCCESS : FILES_ARE_DIFFERENT;
}


/**************************************************************************/
/* Compare a range of lines.                                              */
/**************************************************************************/

BOOLEAN FC::compare (int l1, register int s1, int l2, register int s2, int ct)
{
#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("compare (%d, %d, %d, %d, %d)\n", l1, s1, l2, s2, ct));
#endif

  if (ct <= 0 || s1+ct > l1 || s2+ct > l2)
    return (FALSE);

  while (ct--)
  {

#ifdef  DEBUG
    if (fDebug)
      DebugPrintTrace(("'%s' == '%s'? ", buffer1[s1].text, buffer2[s2].text));
#endif
  if(!fUnicode) {
        if ((*fCmp)(buffer1[s1++].text, buffer2[s2++].text)) {

#ifdef  DEBUG
          if (fDebug)
            DebugPrintTrace(("No\n"));
#endif
          return (FALSE);
        }
  } else {
        if ((*fCmp_U)(buffer1[s1++].wtext, buffer2[s2++].wtext)) {

#ifdef  DEBUG
          if (fDebug)
            DebugPrintTrace(("No\n"));
#endif
          return (FALSE);
        }
  }
  }

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("Yes\n"));
#endif

  return (TRUE);
}


/**************************************************************************/
/* LineCompare                                                            */
/**************************************************************************/


INT
FC::LineCompare(
    PCWSTRING f1,
    PCWSTRING f2
    )
{

    PATH            FileName;
    PFSN_FILE       File1   = NULL;
    PFSN_FILE       File2   = NULL;
    PFILE_STREAM    Stream1 = NULL;
    PFILE_STREAM    Stream2 = NULL;
    int             result;
    BOOLEAN         fFileSkipped;


    buffer1 = buffer2 = NULL;

    if ( !FileName.Initialize( f1 )    ||
         !(File1 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream1 = File1->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ))
       ) {

        FREE(buffer1);
        FREE(buffer2);
        DELETE(Stream2);
        DELETE(File2);
        DELETE(Stream1);
        DELETE(File1);
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f1 );
            return FILES_NOT_FOUND;
        }
    }

    if ( !FileName.Initialize( f2 )    ||
         !(File2 = SYSTEM::QueryFile( &FileName, fSkipOffline, &fFileSkipped ))      ||
         !(Stream2 = File2->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ))
       ) {

        FREE(buffer1);
        FREE(buffer2);
        DELETE(Stream2);
        DELETE(File2);
        DELETE(Stream1);
        DELETE(File1);
        if (fFileSkipped) {
            // Skipping offline files is not an error, just track this happened
            fOfflineSkipped = TRUE;
            return FILES_OFFLINE;

        } else {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", f2 );
            return FILES_NOT_FOUND;
        }
    }


    if ( (buffer1 = (struct lineType *)MALLOC(cLine * (sizeof *buffer1))) == NULL ||
         (buffer2 = (struct lineType *)MALLOC(cLine * (sizeof *buffer1))) == NULL) {

        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        FREE(buffer1);
        FREE(buffer2);
        DELETE(Stream2);
        DELETE(File2);
        DELETE(Stream1);
        DELETE(File1);
        return FAILURE;
    }

    result = RealLineCompare( f1, f2, Stream1, Stream2 );

    FREE(buffer1);
    FREE(buffer2);
    DELETE(Stream2);
    DELETE(File2);
    DELETE(Stream1);
    DELETE(File1);

    return result;
}

int
FC::RealLineCompare (
    PCWSTRING f1,
    PCWSTRING f2,
    PSTREAM Stream1,
    PSTREAM Stream2
    )
{

    int             l1, l2, i, xp, yp, xc, yc;
    BOOLEAN         xd, yd, fSame;
    int             line1, line2;


    fSame = TRUE;
    l1    = l2    = 0;
    line1 = line2 = 0;

l0:

#ifdef  DEBUG
    if (fDebug) {
        DebugPrintTrace(("At scan beginning\n"));
    }
#endif

    l1 += xfill (buffer1+l1, Stream1, cLine-l1, &line1);
    l2 += xfill (buffer2+l2, Stream2, cLine-l2, &line2);

    if (l1 == 0 && l2 == 0) {

        if (fSame) {
            DisplayMessage( MSG_FC_NO_DIFFERENCES, NORMAL_MESSAGE );
        }
        return fSame ? SUCCESS : FILES_ARE_DIFFERENT;
    }

    xc = min (l1, l2);

    for (i=0; i < xc; i++) {

        if (!compare (l1, i, l2, i, 1)) {
            break;
        }
    }

    if (i != xc) {
        i = ( i-1 > 0 )? ( i-1 ) : 0;
    }

    l1 = adjust (buffer1, l1, i);
    l2 = adjust (buffer2, l2, i);

    if (l1 == 0 && l2 == 0) {
        goto l0;
    }

    l1 += xfill (buffer1+l1, Stream1, cLine-l1, &line1);
    l2 += xfill (buffer2+l2, Stream2, cLine-l2, &line2);

#ifdef  DEBUG
    if (fDebug) {
        DebugPrintTrace(("buffers are adjusted, %d, %d remain\n", l1, l2));
    }
#endif

    xd = yd = FALSE;
    xc = yc = 1;
    xp = yp = 1;

l6:

#ifdef  DEBUG
    if (fDebug) {
        DebugPrintTrace(("Trying resync %d,%d  %d,%d\n", xc, xp, yc, yp));
    }
#endif

    i = min (l1-xc,l2-yp);
    i = min (i, ctSync);

    if (compare (l1, xc, l2, yp, i)) {

        fSame = FALSE;
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f1 );
        dump (buffer1, 0, xc);
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f2 );
        dump (buffer2, 0, yp);
        DisplayMessage( MSG_FC_DUMP_END, NORMAL_MESSAGE );

        l1 = adjust (buffer1, l1, xc);
        l2 = adjust (buffer2, l2, yp);

        goto l0;
    }

    i = min (l1-xp, l2-yc);
    i = min (i, ctSync);

    if (compare (l1, xp, l2, yc, i)) {

        fSame = FALSE;
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f1 );
        dump (buffer1, 0, xp);
        DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f2 );
        dump (buffer2, 0, yc);
        DisplayMessage( MSG_FC_DUMP_END, NORMAL_MESSAGE );

        l1 = adjust (buffer1, l1, xp);
        l2 = adjust (buffer2, l2, yc);

        goto l0;
    }

    if (++xp > xc) {

        xp = 1;
        if (++xc >= l1) {

            xc = l1;
            xd = TRUE;
        }
    }

    if (++yp > yc) {

        yp = 1;
        if (++yc >= l2) {

            yc = l2;
            yd = TRUE;
        }
    }

    if (!xd || !yd) {
        goto l6;
    }

    fSame = FALSE;

    if (l1 >= cLine || l2 >= cLine) {
        DisplayMessage( MSG_FC_RESYNC_FAILED, NORMAL_MESSAGE );
    }

    DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f1 );
    dump (buffer1, 0, l1-1);
    DisplayMessage( MSG_FC_OUTPUT_FILENAME, NORMAL_MESSAGE, "%W", f2 );
    dump (buffer2, 0, l2-1);
    DisplayMessage( MSG_FC_DUMP_END, NORMAL_MESSAGE );

    return fSame ? SUCCESS : FILES_ARE_DIFFERENT;
}


/**************************************************************************/
/* Return number of lines read in.                                        */
/**************************************************************************/

FC::xfill (struct lineType *pl, PSTREAM Stream, int ct, int *plnum)
{
  int i;
  DWORD StrSize;

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("xfill (%04x, %04x)\n", pl, fh));
#endif

  i = 0;

  if (!fUnicode) {
    while ( ct-- && !Stream->IsAtEnd() && Stream->ReadMbLine( pl->text, MAXLINESIZE, &StrSize, fExpandTabs, 8 ) ) {

      if (fIgnore && !MBSTR::Strcmps(pl->text, "")) {

        pl->text[0] = 0;
        ++*plnum;
      }

      if (strlen (pl->text) != 0 || !fIgnore)
      {
        pl->line = ++*plnum;
        pl++;
        i++;
      }
    }
  } else {
    while( ct-- && !Stream->IsAtEnd() &&  Stream->ReadWLine( pl->wtext,MAXLINESIZE, &StrSize, fExpandTabs, 8 ) ) {
    //while( ct-- && !Stream->IsAtEnd() &&  Stream->ReadLine( &_String , TRUE )) {

      //_String.QueryWSTR(0,TO_END,pl->wtext,MAXLINESIZE,TRUE);

      if (fIgnore && !WSTRING::Strcmps((PWSTR)pl->wtext, (PWSTR)L"")) {

        pl->wtext[0] = 0;
        ++*plnum;
      }

      if (wcslen (pl->wtext) != 0 || !fIgnore)
      {
        pl->line = ++*plnum;
        pl++;
        i++;
      }
    }
  }

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("xfill returns %d\n", i));
#endif

  return (i);

#if 0

  while (ct-- && (*funcRead) (pl->text, MAXLINESIZE, fh) != NULL)
  {
    if (funcRead == ( int (*) (char *,int, FILE *))fgets)
      pl->text[strlen(pl->text)-1] = 0;
    if (fIgnore && !MBSTR::Strcmps(pl->text, ""))
    {
      pl->text[0] = 0;
      ++*plnum;
    }
    if (strlen (pl->text) != 0 || !fIgnore)
    {
      pl->line = ++*plnum;
      pl++;
      i++;
    }
  }

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("xfill returns %d\n", i));
#endif

  return (i);

#   endif

}


/**************************************************************************/
/* Adjust returns number of lines in buffer.                              */
/**************************************************************************/

FC::adjust (struct lineType *pl, int ml, int lt)
{
#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("adjust (%04x, %d, %d) = ", pl, ml, lt));
  if (fDebug)
    DebugPrintTrace(("%d\n", ml-lt));
#endif

  if (ml <= lt)
    return (0);

#ifdef  DEBUG
  if (fDebug)
    DebugPrintTrace(("move (%04x, %04x, %04x)\n", &pl[lt], &pl[0], sizeof (*pl)*(ml-lt)));
#endif

  // Move((char  *)&pl[lt], (char  *)&pl[0], sizeof (*pl)*(ml-lt));
  memmove( (char  *)&pl[0], (char  *)&pl[lt],  sizeof (*pl)*(ml-lt) );
  return ml-lt;
}


/**************************************************************************/
/* dump                                                                   */
/*      dump outputs a range of lines.                                    */
/*                                                                        */
/*  INPUTS                                                                */
/*          pl      pointer to current lineType structure                 */
/*          start   starting line number                                  */
/*          end     ending line number                                    */
/*                                                                        */
/*  CALLS                                                                 */
/*          pline, printf                                                 */
/**************************************************************************/

void FC::dump (struct lineType *pl, int start, int end)
{
  if (fAbbrev && end-start > 2)
  {
    pline (pl+start);
    DisplayMessage( MSG_FC_ABBREVIATE_SYMBOL, NORMAL_MESSAGE );
    pline (pl+end);
  }
  else
  {
    while (start <= end)
      pline (pl+start++);
  }
}


/**************************************************************************/
/* PrintLINE                                                              */
/*      pline prints a single line of output.  If the /n flag             */
/*  has been specified, the line number of the printed text is added.     */
/*                                                                        */
/*  Inputs                                                                */
/*          pl      pointer to current lineType structure                 */
/*          fNumb   TRUE if /n specified                                  */
/**************************************************************************/

void FC::pline (struct lineType *pl)
{
  if (!fUnicode) {
    if (fNumb)
      DisplayMessage( MSG_FC_NUMBERED_DATA, NORMAL_MESSAGE, "%5d%s",
                      pl->line, pl->text );
    else
      DisplayMessage( MSG_FC_DATA, NORMAL_MESSAGE, "%s", pl->text );
  } else {
    FSTRING f;
    if (fNumb)
      DisplayMessage( MSG_FC_NUMBERED_DATA, NORMAL_MESSAGE, "%5d%W",
                      pl->line, f.Initialize(pl->wtext) );
    else
      DisplayMessage( MSG_FC_DATA, NORMAL_MESSAGE, "%W",
                      f.Initialize(pl->wtext) );
  }
}


/*********************************************************************/
/* Routine:   ParseFileNames                                         */
/*                                                                   */
/* Function:  Parses the two given filenames and then compares the   */
/*            appropriate filenames.  This routine handles wildcard  */
/*            characters in both filenames.                          */
/*********************************************************************/

INT
FC::ParseFileNames()
{
    PATH                File1;
    PATH                File2;
    FSN_FILTER          Filter;
    PWSTRING            Name;
    PARRAY              NodeArray;
    PITERATOR           Iterator;
    PFSN_DIRECTORY      Dir;
    PFSNODE             File;
    PPATH               ExpandedPath;
    PATH                TmpPath;
    int                 result = SUCCESS;
    char                *locale;

    if (!File1.Initialize( &_File1 ) ||
        !File2.Initialize( &_File2 ) ||
        !Filter.Initialize()) {
        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        return FAILURE;
    }

    if (!(Name = File1.QueryName())) {
        DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", File1.GetPathString() );
        return FILES_NOT_FOUND;
    }

    if (!Filter.SetFileName( Name ) ||
        !Filter.SetAttributes( (FSN_ATTRIBUTE)0,                // ALL
                                FSN_ATTRIBUTE_FILES,            // ANY
                                FSN_ATTRIBUTE_DIRECTORY )) {    // NONE
        DELETE( Name );
        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        return FAILURE;
    }

    DELETE( Name );

    if (!TmpPath.Initialize( &File1, TRUE ) ||
        !TmpPath.TruncateBase()) {
        DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
        return FAILURE;
    }

    if ( !(Dir = SYSTEM::QueryDirectory( &TmpPath ))        ||
         !(NodeArray = Dir->QueryFsnodeArray( &Filter ))    ||
         !(Iterator = NodeArray->QueryIterator())           ||
         !(File = (PFSNODE)Iterator->GetNext())
       ) {
        DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", File1.GetPathString() );
        return FILES_NOT_FOUND;
    }

    Iterator->Reset();

    while ( File = (PFSNODE)Iterator->GetNext() ) {

        PWSTRING Name1;
        PWSTRING Name2;

        if (!(Name1 = File->QueryName())) {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", File->GetPath()->GetPathString() );
            return FILES_NOT_FOUND;
        }

        if ( _File2.HasWildCard() ) {

            if ( !(ExpandedPath = _File2.QueryWCExpansion( (PPATH)File->GetPath() ))) {

                if (!(Name2 = _File2.QueryName())) {
                    DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", _File2.GetPathString() );
                    return FILES_NOT_FOUND;
                }

                DisplayMessage( MSG_FC_CANT_EXPAND_TO_MATCH, ERROR_MESSAGE, "%W%W", Name1, Name2 );
                DELETE( Name2 );
                DELETE( Name1 );
                DELETE( Iterator );
                DELETE( NodeArray );
                DELETE( Dir );
                return FAILURE;
            }

        } else {

            if ( !(ExpandedPath = NEW PATH) ||
                 !ExpandedPath->Initialize( &_File2 ) ) {

                DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
                DELETE( Name1 );
                DELETE( Iterator );
                DELETE( NodeArray );
                DELETE( Dir );
                return FAILURE;

            }
        }

        if (!(Name2 = ExpandedPath->QueryName())) {
            DisplayMessage( MSG_FC_UNABLE_TO_OPEN, ERROR_MESSAGE, "%W", ExpandedPath->GetPathString() );
            return FILES_NOT_FOUND;
        }

        if (!File1.SetName( Name1 ) ||
            !File2.SetName( Name2 )) {
            DisplayMessage( MSG_FC_OUT_OF_MEMORY, ERROR_MESSAGE );
            return FAILURE;
        }

        switch (comp( File1.GetPathString(), File2.GetPathString() )) {
            case FAILURE:
                return FAILURE;

            case SUCCESS:
                break;

            case FILES_ARE_DIFFERENT:
                result |= FILES_ARE_DIFFERENT;
                break;

            case FILES_NOT_FOUND:
                result |= FILES_NOT_FOUND;
                break;

            case FILES_OFFLINE:
                result |= FILES_OFFLINE;
                break;

            default:
                DebugAssert(FALSE);
        }

        DELETE( Name2 );
        DELETE( Name1 );
        DELETE( ExpandedPath );

    }

    // Print a warning in case that offline files were skipped
    if (fOfflineSkipped) {
        DisplayMessage(MSG_FC_OFFLINE_FILES_SKIPPED, ERROR_MESSAGE);
    }

    DELETE( Iterator );
    NodeArray->DeleteAllMembers();
    DELETE( NodeArray );
    DELETE( Dir );

    return result;
}




/*********************************************************************/
/* Routine:   comp                                                   */
/*                                                                   */
/* Function:  Compares the two files.                                */
/*********************************************************************/

INT
FC::comp(PCWSTRING file1, PCWSTRING file2)
{
  DisplayMessage( MSG_FC_COMPARING_FILES, NORMAL_MESSAGE, "%W%W", file1, file2 );
  if (fBinary) {
      return BinaryCompare (file1, file2);
  } else {
      return LineCompare (file1, file2);
  }

}


#if 0
/* returns line from file (no CRLFs); returns NULL if EOF */
FC::fgetl ( char *buf, int len, FILE *fh)
{
    register int c;
    register char *p;

    /* remember NUL at end */
    len--;
    p = buf;
    while (len) {
        c = getc (fh);
        if (c == EOF || c == '\n')
            break;
#if MSDOS
        if (c != '\r')
#endif
            if (c != '\t') {
                *p++ = (char)c;
                len--;
                }
            else {
                c = min (8 - ((int)(p-buf) & 0x0007), len);
        memset(p, ' ', c);
                p += c;
                len -= c;
                }
        }
    *p = 0;
    return ! ( (c == EOF) && (p == buf) );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdhelp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fdhelp.c

Abstract:

    Routines to support context-sensitive help in the disk manager.

Author:

    Ted Miller (tedm) 18-March-1992

Revision History:

--*/


#include "fdisk.h"


//
// Define macro to convert between a menu id and its corresponding
// context-sensitive help id, in a switch statement.
//

#define     MENUID_TO_HELPID(name)      case IDM_##name :                    \
                                            HelpContext = HC_DM_MENU_##name; \
                                            break;


//
// Current help context
//

DWORD   HelpContext = (DWORD)(-1);


//
// Handle to windows hook for F1 key
//
HHOOK hHook;



DWORD
HookProc(
    IN int  nCode,
    IN UINT wParam,
    IN LONG lParam
    )

/*++

Routine Description:

    Hook proc to detect F1 key presses.

Arguments:

Return Value:

--*/

{
    PMSG pmsg = (PMSG)lParam;

    if(nCode < 0) {
        return(CallNextHookEx(hHook,nCode,wParam,lParam));
    }

    if(((nCode == MSGF_DIALOGBOX) || (nCode == MSGF_MENU))
     && (pmsg->message == WM_KEYDOWN)
     && (LOWORD(pmsg->wParam) == VK_F1))
    {
        PostMessage(hwndFrame,WM_F1DOWN,nCode,0);
        return(TRUE);
    }

    return(FALSE);
}



VOID
Help(
    IN LONG Code
    )

/*++

Routine Description:

    Display context-sensitive help.

Arguments:

    Code - supplies type of message (MSGF_DIALOGBOX, MSGF_MENU, etc).

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(Code);

    if(HelpContext != -1) {
        WinHelp(hwndFrame,HelpFile,HELP_CONTEXT,HelpContext);
        DrawMenuBar(hwndFrame);
    }
}

VOID
DialogHelp(
    IN DWORD HelpId
    )
/*++

Routine Description:

    Display help on a specific item.

Arguments:

    HelpId  --  Supplies the help item to display.

Return Value:

    None.

--*/
{
    WinHelp(hwndFrame,HelpFile,HELP_CONTEXT,HelpId);
    DrawMenuBar(hwndFrame);
}

VOID
SetMenuItemHelpContext(
    IN LONG wParam,
    IN DWORD lParam
    )

/*++

Routine Description:

    Routine to set help context based on which menu item is currently
    selected.

Arguments:

    wParam,lParam - params to window proc in WM_MENUSELECT case

Return Value:

    None.

--*/

{
    if(HIWORD(lParam) == 0) {                   // menu closed

        HelpContext = (DWORD)(-1);

    } else if (HIWORD(wParam) & MF_POPUP) {     // popup selected

        HelpContext = (DWORD)(-1);

    } else {                                    // regular old menu item
        switch(LOWORD(wParam)) {

        MENUID_TO_HELPID(PARTITIONCREATE)
        MENUID_TO_HELPID(PARTITIONCREATEEX)
        MENUID_TO_HELPID(PARTITIONDELETE)
#if i386
        MENUID_TO_HELPID(PARTITIONACTIVE)
#else
        MENUID_TO_HELPID(SECURESYSTEM)
#endif
        MENUID_TO_HELPID(PARTITIONLETTER)
        MENUID_TO_HELPID(PARTITIONEXIT)

        MENUID_TO_HELPID(CONFIGMIGRATE)
        MENUID_TO_HELPID(CONFIGSAVE)
        MENUID_TO_HELPID(CONFIGRESTORE)

        MENUID_TO_HELPID(FTESTABLISHMIRROR)
        MENUID_TO_HELPID(FTBREAKMIRROR)
        MENUID_TO_HELPID(FTCREATESTRIPE)
        MENUID_TO_HELPID(FTCREATEPSTRIPE)
        MENUID_TO_HELPID(FTCREATEVOLUMESET)
        MENUID_TO_HELPID(FTEXTENDVOLUMESET)
        MENUID_TO_HELPID(FTRECOVERSTRIPE)

        MENUID_TO_HELPID(OPTIONSSTATUS)
        MENUID_TO_HELPID(OPTIONSLEGEND)
        MENUID_TO_HELPID(OPTIONSCOLORS)
        MENUID_TO_HELPID(OPTIONSDISPLAY)

        MENUID_TO_HELPID(HELPCONTENTS)
        MENUID_TO_HELPID(HELPSEARCH)
        MENUID_TO_HELPID(HELPHELP)
        MENUID_TO_HELPID(HELPABOUT)

        default:
            HelpContext = (DWORD)(-1);
        }
    }
}


VOID
InitHelp(
    VOID
    )
{
    hHook = SetWindowsHookEx(WH_MSGFILTER,(HOOKPROC)HookProc,NULL,GetCurrentThreadId());
}


VOID
TermHelp(
    VOID
    )
{
    UnhookWindowsHookEx(hHook);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdisk.h ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fdisk.h

Abstract:

    Central include file for Disk Administrator

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) added doublespace and commit support.
    2-Feb-94  (bobri) removed ArcInst dependency in build.

--*/

//#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntdskreg.h>
#include <ntddft.h>

//
// These defines are for virtualized types in partitp.h, low.h,
// fdengine.c, etc.
//
#define STATUS_CODE             NTSTATUS
#define OK_STATUS               STATUS_SUCCESS
#define RETURN_OUT_OF_MEMORY    return(STATUS_NO_MEMORY);
#define HANDLE_T                HANDLE
#define HANDLE_PT               PHANDLE
#define AllocateMemory          Malloc
#define ReallocateMemory        Realloc
#define FreeMemory              Free

#include <windows.h>

#include <stdarg.h>

#include "fdtypes.h"
#include "fdproto.h"
#include "fdconst.h"
#include "fdglob.h"
#include "fdres.h"
#include "fdiskmsg.h"
#include "fdhelpid.h"


#define PERSISTENT_DATA(region) ((PPERSISTENT_REGION_DATA)((region)->PersistentData))

#define GET_FT_OBJECT(region)   ((region)->PersistentData ? PERSISTENT_DATA(region)->FtObject : NULL)
#define SET_FT_OBJECT(region,o) (PERSISTENT_DATA(region)->FtObject = o)


#define EC(x) RtlNtStatusToDosError(x)

// assertion checking, logging

#if DBG

#define     FDASSERT(expr)  if(!(expr)) FdiskAssertFailedRoutine(#expr,__FILE__,__LINE__);
#define     FDLOG(X) FdLog X

VOID
FdLog(
    IN int   Level,
    IN PCHAR FormatString,
    ...
    );

VOID
LOG_DISK_REGISTRY(
    IN PCHAR          RoutineName,
    IN PDISK_REGISTRY DiskRegistry
    );

VOID
LOG_ONE_DISK_REGISTRY_DISK_ENTRY(
    IN PCHAR             RoutineName     OPTIONAL,
    IN PDISK_DESCRIPTION DiskDescription
    );

VOID
LOG_DRIVE_LAYOUT(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    );

VOID
InitLogging(
    VOID
    );

extern PVOID LogFile;

#else

#define     FDASSERT(expr)
#define     FDLOG(X)
#define     LOG_DISK_REGISTRY(x,y)
#define     LOG_ONE_DISK_REGISTRY_DISK_ENTRY(x,y)
#define     LOG_DRIVE_LAYOUT(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fdinit.c

Abstract:

    Code for initializing the fdisk application.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/

#include "fdisk.h"

HWND    InitDlg;
BOOLEAN StartedAsIcon = FALSE;
BOOLEAN InitDlgComplete = FALSE;

BOOL
InitializeApp(
    VOID
    )

/*++

Routine Description:

    This routine initializes the fdisk app.  This includes registering
    the frame window class and creating the frame window.

Arguments:

    None.

Return Value:

    boolean value indicating success or failure.

--*/

{
    WNDCLASS   wc;
    TCHAR      szTitle[80];
    DWORD      ec;
    HDC        hdcScreen = GetDC(NULL);
    TEXTMETRIC tm;
    BITMAP     bitmap;
    HFONT      hfontT;
    unsigned   i;

    ReadProfile();

    // Load cursors

    hcurWait   = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
    hcurNormal = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));

    // fonts

#ifdef JAPAN
    hFontGraph =  CreateFont(GetHeightFromPoints(10), 0,
                             0, 0, 400, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET,
                             OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS,
                             TEXT("System")
                            );
#else
    hFontGraph =  CreateFont(GetHeightFromPoints(8), 0,
                             0, 0, 400, FALSE, FALSE, FALSE, ANSI_CHARSET,
                             OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS,
                             TEXT("Helv"));
#endif

    hFontLegend = hFontGraph;
    hFontStatus = hFontGraph;

#ifdef JAPAN
    hFontGraphBold = CreateFont(GetHeightFromPoints(10), 0,
                                0, 0, 700, FALSE, FALSE, FALSE,
                                                                SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
                                                                CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                                                VARIABLE_PITCH | FF_SWISS, TEXT("System")
                               );
#else
    hFontGraphBold = CreateFont(GetHeightFromPoints(8), 0,
                                0, 0, 700, FALSE, FALSE, FALSE, ANSI_CHARSET,
                                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS,
                                TEXT("Helv"));
#endif

    hfontT = SelectObject(hdcScreen, hFontGraph);
    GetTextMetrics(hdcScreen, &tm);
    if (hfontT) {
        SelectObject(hdcScreen, hfontT);
    }

    hPenNull      = CreatePen(PS_NULL, 0, 0);
    hPenThinSolid = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));

    GraphWidth = (DWORD)GetSystemMetrics(SM_CXSCREEN);
    GraphHeight = 25 * tm.tmHeight / 4;     // 6.25 x font height

    // set up the legend off-screen bitmap

    wLegendItem = GetSystemMetrics(SM_CXHTHUMB);
    dyLegend = 2 * wLegendItem;     // 7*wLegendItem/2 for a double-height legend

    ReleaseDC(NULL, hdcScreen);

    dyBorder = GetSystemMetrics(SM_CYBORDER);
    dyStatus = tm.tmHeight + tm.tmExternalLeading + 7 * dyBorder;

    // set up brushes

    for (i=0; i<BRUSH_ARRAY_SIZE; i++) {
        Brushes[i] = CreateHatchBrush(AvailableHatches[BrushHatches[i]], AvailableColors[BrushColors[i]]);
    }

    hBrushFreeLogical = CreateHatchBrush(HS_FDIAGONAL, RGB(128, 128, 128));
    hBrushFreePrimary = CreateHatchBrush(HS_BDIAGONAL, RGB(128, 128, 128));

    // load legend strings

    for (i=IDS_LEGEND_FIRST; i<=IDS_LEGEND_LAST; i++) {
        if (!(LegendLabels[i-IDS_LEGEND_FIRST] = LoadAString(i))) {
            return FALSE;
        }
    }

    if (((wszUnformatted    = LoadWString(IDS_UNFORMATTED))     == NULL)
    ||  ((wszNewUnformatted = LoadWString(IDS_NEW_UNFORMATTED)) == NULL)
    ||  ((wszUnknown        = LoadWString(IDS_UNKNOWN    ))     == NULL)) {
        return FALSE;
    }

    // register the frame class

    wc.style         = CS_OWNDC | CS_VREDRAW;
    wc.lpfnWndProc   = MyFrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hModule;
    wc.hIcon         = LoadIcon(hModule, MAKEINTRESOURCE(IDFDISK));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName  = MAKEINTRESOURCE(IDFDISK);
    wc.lpszClassName = szFrame;

    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    if (!RegisterArrowClass(hModule)) {
        return FALSE;
    }

    LoadString(hModule, IDS_APPNAME, szTitle, sizeof(szTitle)/sizeof(TCHAR));

    // create the frame window.  Note that this also creates the listbox.

    hwndFrame = CreateWindow(szFrame,
                             szTitle,
                             WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                             ProfileWindowX,
                             ProfileWindowY,
                             ProfileWindowW,
                             ProfileWindowH,
                             NULL,
                             NULL,
                             hModule,
                             NULL);
    if (!hwndFrame) {
        return FALSE;
    }

    if (!hwndList) {
        DestroyWindow(hwndFrame);
        return FALSE;
    }

    hDC = GetDC(hwndFrame);
    BarTopYOffset = tm.tmHeight;
    BarHeight = 21 * tm.tmHeight / 4;
    BarBottomYOffset = BarTopYOffset + BarHeight;
    dxBarTextMargin = 5*tm.tmAveCharWidth/4;
    dyBarTextLine = tm.tmHeight;

    dxDriveLetterStatusArea = 5 * tm.tmAveCharWidth / 2;

    hBitmapSmallDisk = LoadBitmap(hModule, MAKEINTRESOURCE(IDB_SMALLDISK));
    GetObject(hBitmapSmallDisk, sizeof(BITMAP), &bitmap);
    dxSmallDisk = bitmap.bmWidth;
    dySmallDisk = bitmap.bmHeight;
    xSmallDisk = dxSmallDisk / 2;
    ySmallDisk = BarTopYOffset + (2*dyBarTextLine) - dySmallDisk - tm.tmDescent;

    hBitmapRemovableDisk = LoadBitmap(hModule, MAKEINTRESOURCE(IDB_REMOVABLE));
    GetObject(hBitmapRemovableDisk, sizeof(BITMAP), &bitmap);
    dxRemovableDisk = bitmap.bmWidth;
    dyRemovableDisk = bitmap.bmHeight;
    xRemovableDisk = dxRemovableDisk / 2;
    yRemovableDisk = BarTopYOffset + (2*dyBarTextLine) - dyRemovableDisk - tm.tmDescent;


    BarLeftX = 7 * dxSmallDisk;
    BarWidth = GraphWidth - BarLeftX - (5 * tm.tmAveCharWidth);

    DiskN = LoadAString(IDS_DISKN);

    if ((ec = InitializeListBox(hwndList)) != NO_ERROR) {
        DestroyWindow(hwndList);
        DestroyWindow(hwndFrame);
        return FALSE;
    }

    // initial list box selection cursor (don't allow to fall on
    // extended partition).
    LBCursorListBoxItem = 0;
    ResetLBCursorRegion();

    ShowWindow(hwndFrame,
               ProfileIsIconic ? SW_SHOWMINIMIZED
                               : ProfileIsMaximized ? SW_SHOWMAXIMIZED : SW_SHOWDEFAULT);
    UpdateWindow(hwndFrame);
    return TRUE;
}

VOID
CreateDiskState(
    OUT PDISKSTATE *DiskState,
    IN  DWORD       Disk,
    OUT PBOOL       SignatureCreated
    )

/*++

Routine Description:

    This routine is designed to be called once, at initialization time,
    per disk.  It creates and initializes a disk state -- which includes
    creating a memory DC and compatible bitmap for drawing the disk's
    graph, and getting some information that is static in nature about
    the disk (ie, its total size.)

Arguments:

    DiskState - structure whose fields are to be intialized

    Disk - number of disk

    SignatureCreated - received boolean indicating whether an FT signature was created for
        the disk.

Return Value:

    None.

--*/

{
    HDC        hDCMem;
    PDISKSTATE pDiskState = Malloc(sizeof(DISKSTATE));


    *DiskState = pDiskState;

    pDiskState->LeftRight = Malloc(0);
    pDiskState->Selected  = Malloc(0);

    pDiskState->Disk = Disk;

    // create a memory DC for drawing the bar off-screen,
    // and the correct bitmap

#if 0
    pDiskState->hDCMem = NULL;
    pDiskState->hbmMem = NULL;
    hDCMem = CreateCompatibleDC(hDC);
#else
    pDiskState->hDCMem   = hDCMem = CreateCompatibleDC(hDC);
    pDiskState->hbmMem   = CreateCompatibleBitmap(hDC, GraphWidth, GraphHeight);
#endif
    SelectObject(hDCMem,pDiskState->hbmMem);


    pDiskState->RegionArray = NULL;
    pDiskState->RegionCount = 0;
    pDiskState->BarType = BarAuto;
    pDiskState->OffLine = IsDiskOffLine(Disk);

    if (pDiskState->OffLine) {

        pDiskState->SigWasCreated = FALSE;
        pDiskState->Signature = 0;
        pDiskState->DiskSizeMB = 0;
        FDLOG((1, "CreateDiskState: Disk %u is off-line\n", Disk));
    } else {

        pDiskState->DiskSizeMB = DiskSizeMB(Disk);
        if (pDiskState->Signature = FdGetDiskSignature(Disk)) {

            if (SignatureIsUniqueToSystem(Disk, pDiskState->Signature)) {
                pDiskState->SigWasCreated = FALSE;
                FDLOG((2,
                      "CreateDiskState: Found signature %08lx on disk %u\n",
                      pDiskState->Signature,
                      Disk));
            } else {
                goto createSignature;
            }
        } else {

createSignature:
            pDiskState->Signature = FormDiskSignature();
            FdSetDiskSignature(Disk, pDiskState->Signature);
            pDiskState->SigWasCreated = TRUE;
            FDLOG((1,
                  "CreateDiskState: No signature on disk %u; created signature %08lx\n",
                  Disk,
                  pDiskState->Signature));
        }
    }

    *SignatureCreated = (BOOL)pDiskState->SigWasCreated;
}

BOOL CALLBACK
InitializationDlgProc(
    IN HWND   hDlg,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    standard Windows dialog procedure

Return Values:

    standard Windows dialog procedure

--*/

{
    static DWORD          percentDrawn;
    static RECT           rectGG;              // GasGauge rectangle
    static BOOL           captionIsLoaded;
    static PFORMAT_PARAMS formatParams;
           TCHAR          title[100],
                          templateString[100];

    switch (uMsg) {
    case WM_INITDIALOG: {
        HWND   hwndGauge = GetDlgItem(hDlg, IDC_GASGAUGE);

        InitDlg = hDlg;
        percentDrawn = 0;
        StartedAsIcon = IsIconic(hDlg);

        // Get the coordinates of the gas gauge static control rectangle,
        // and convert them to dialog client area coordinates

        GetClientRect(hwndGauge, &rectGG);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.left);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.right);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.left);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.right);
        return TRUE;
    }

    case WM_PAINT: {
        INT         width  = rectGG.right - rectGG.left;
        INT         height = rectGG.bottom - rectGG.top;
        INT         nDivideRects;
        HDC         hDC;
        PAINTSTRUCT ps;
        TCHAR       buffer[10];
        SIZE        size;
        INT         xText,
                    yText,
                    byteCount;
        RECT        rectDone,
                    rectLeftToDo;

        hDC = BeginPaint(hDlg, &ps);
        byteCount = wsprintf(buffer, TEXT("%3d%%"), percentDrawn);
        GetTextExtentPoint(hDC, buffer, lstrlen(buffer), &size);
        xText = rectGG.left + (width  - size.cx) / 2;
        yText = rectGG.top  + (height - size.cy) / 2;

        // Paint in the "done so far" rectangle of the gas
        // gauge with blue background and white text

        nDivideRects = (width * percentDrawn) / 100;
        SetRect(&rectDone,
                rectGG.left,
                rectGG.top,
                rectGG.left + nDivideRects,
                rectGG.bottom);

        SetTextColor(hDC, RGB(255, 255, 255));
        SetBkColor(hDC, RGB(0, 0, 255));
        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectDone,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);

        // Paint in the "still left to do" rectangle of the gas
        // gauge with white background and blue text

        SetRect(&rectLeftToDo,
                rectGG.left + nDivideRects,
                rectGG.top,
                rectGG.right,
                rectGG.bottom);
        SetBkColor(hDC, RGB(255, 255, 255));
        SetTextColor(hDC, RGB(0, 0, 255));
        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectLeftToDo,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);
        EndPaint(hDlg, &ps);

        if (percentDrawn == 100) {
            InitDlgComplete = TRUE;
        }
        return TRUE;
    }

    case WM_USER:
         percentDrawn = (INT)wParam;
         InvalidateRect(hDlg, &rectGG, TRUE);
         UpdateWindow(hDlg);
         return TRUE;

    case (WM_USER + 1):
        EndDialog(hDlg, FALSE);
        return TRUE;

    default:

        return FALSE;
    }
}

VOID
InitializationMessageThread(
    PVOID ThreadParameter
    )

/*++

Routine Description:

    This is the entry for the initialization message thread.  It creates
    a dialog that simply tells the user to be patient.

Arguments:

    ThreadParameter - not used.

Return Value:

    None

--*/

{
    DialogBoxParam(hModule,
                   MAKEINTRESOURCE(IDD_INITIALIZING),
                   hwndFrame,
                   InitializationDlgProc,
                   (ULONG) NULL);
    InitDlg = (HWND) 0;
    ExitThread(0L);
}

VOID
DisplayInitializationMessage(
    VOID
    )

/*++

Routine Description:

    Create a 2nd thread to display an initialization message.

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE threadHandle;
    DWORD  threadId;

    threadHandle = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) InitializationMessageThread,
                                (LPVOID) NULL,
                                (DWORD) 0,
                                (LPDWORD) &threadId);
    if (!threadHandle) {
        CloseHandle(threadHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdprof.c ===
#include "fdisk.h"
#include <stdio.h>


int  ProfileWindowX,
     ProfileWindowY,
     ProfileWindowW,
     ProfileWindowH;

BOOL ProfileIsMaximized,ProfileIsIconic;

#ifdef JAPAN
//Don't use IDS_APPNAME as registry key,
//because it is also used window's caption and it was localized.
CHAR SectionName[]             = "Disk Administrator";
#else
CHAR SectionName[80];
#endif

CHAR szWindowPosition[]        = "WindowPosition";
CHAR szWindowMaximized[]       = "WindowMaximized";
CHAR szWindowIconic[]          = "WindowIconic";
CHAR szWindowPosFormatString[] = "%d,%d,%d,%d";
CHAR szStatusBar[]             = "StatusBar";
CHAR szLegend[]                = "Legend";
CHAR szElementN[]              = "Element %u Color/Pattern";


VOID
WriteProfile(
    VOID
    )
{
    CHAR  SectionLocation[128], SectionMapping[128];
    HKEY  Key1, Key2;
    RECT  rc;
    CHAR  text[100],text2[100];
    int   i;
    DWORD Disposition;
    LONG  Err;


#ifdef JAPAN
//Don't use IDS_APPNAME as registry key,
//because it is also used window's caption and it was localized.
#else
    LoadStringA(hModule,IDS_APPNAME,SectionName,sizeof(SectionName));
#endif

    // Make sure that the appropriate registry keys exits:
    //
    // windisk.ini key:
    //
    Err = RegCreateKeyExA( HKEY_LOCAL_MACHINE,
                           "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\windisk.ini",
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &Key1,
                           &Disposition );

    if( Err != ERROR_SUCCESS ) {

        return;
    }

    if( Disposition == REG_CREATED_NEW_KEY ) {

        // We need to set up the registry keys for the INI mapping.
        // First, create the Disk Administrator value on the windisk.ini
        // key, which indicates the location of the key which maps
        // the Disk Administrator section.
        //
        strcpy( SectionLocation, "Software\\Microsoft\\" );
        strcat( SectionLocation, SectionName );

        strcpy( SectionMapping, "USR:" );
        strcat( SectionMapping, SectionLocation );

        Err = RegSetValueEx( Key1,
                             SectionName,
                             0,
                             REG_SZ,
                             SectionMapping,
                             strlen( SectionMapping ) + 1 );

        if( Err != ERROR_SUCCESS ) {

            RegCloseKey( Key1 );
            return;
        }

        // Now create the key to which the section mapping points:
        //
        Err = RegCreateKeyEx( HKEY_CURRENT_USER,
                              SectionLocation,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key2,
                              &Disposition );

        RegCloseKey( Key2 );
    }

    RegCloseKey( Key1 );


    // OK, the registry location is set up.  Write the initialization
    // information.
    //

    // write window position

    GetWindowRect(hwndFrame,&rc);
    wsprintf(text,
             szWindowPosFormatString,
             ProfileWindowX,
             ProfileWindowY,
             ProfileWindowW,
             ProfileWindowH
            );
    WritePrivateProfileStringA(SectionName,szWindowPosition,text,"windisk.ini");
    wsprintf(text,"%u",IsZoomed(hwndFrame));
    WritePrivateProfileStringA(SectionName,szWindowMaximized,text,"windisk.ini");
    wsprintf(text,"%u",IsIconic(hwndFrame));
    WritePrivateProfileStringA(SectionName,szWindowIconic,text,"windisk.ini");

    // status bar and legend stuff

    wsprintf(text,
             "%u",
             StatusBar
            );
    WritePrivateProfileStringA(SectionName,szStatusBar,text,"windisk.ini");

    wsprintf(text,
             "%u",
             Legend
            );
    WritePrivateProfileStringA(SectionName,szLegend,text,"windisk.ini");

    // disk graph colors/patterns

    for(i=0; i<LEGEND_STRING_COUNT; i++) {
        wsprintf(text2,szElementN,i);
        wsprintf(text,"%u/%u",BrushColors[i],BrushHatches[i]);
        WritePrivateProfileStringA(SectionName,text2,text,"windisk.ini");
    }
}


VOID
ReadProfile(
    VOID
    )
{
    CHAR text[100],text2[100];
    int  i;

#ifdef JAPAN
//Don't use IDS_APPNAME as registry key,
//because it is also used window's caption and it was localized.
#else
    LoadStringA(hModule,IDS_APPNAME,SectionName,sizeof(SectionName));
#endif

    // get the window position data

    ProfileIsMaximized = GetPrivateProfileIntA(SectionName,szWindowMaximized,0,"windisk.ini");
    ProfileIsIconic    = GetPrivateProfileIntA(SectionName,szWindowIconic   ,0,"windisk.ini");

    *text = 0;
    if(GetPrivateProfileStringA(SectionName,szWindowPosition,"",text,sizeof(text),"windisk.ini")
    && *text)
    {
        sscanf(text,
               szWindowPosFormatString,
               &ProfileWindowX,
               &ProfileWindowY,
               &ProfileWindowW,
               &ProfileWindowH
              );
    } else {
        ProfileWindowX = CW_USEDEFAULT;
        ProfileWindowY = 0;
        ProfileWindowW = CW_USEDEFAULT;
        ProfileWindowH = 0;
    }

    // status bar and legend stuff

    StatusBar = GetPrivateProfileIntA(SectionName,szStatusBar,1,"windisk.ini");
    Legend    = GetPrivateProfileIntA(SectionName,szLegend   ,1,"windisk.ini");

    // disk graph colors/patterns

    for(i=0; i<LEGEND_STRING_COUNT; i++) {
        wsprintf(text2,szElementN,i);
        *text = 0;
        if(GetPrivateProfileStringA(SectionName,text2,"",text,sizeof(text),"windisk.ini") && *text) {
            sscanf(text,"%u/%u",&BrushColors[i],&BrushHatches[i]);
            if( BrushHatches[i] >= NUM_AVAILABLE_HATCHES ) {
                    BrushHatches[i] = NUM_AVAILABLE_HATCHES - 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdlistbx.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fdlistbx.c

Abstract:

    Routines for handling the subclassed owner-draw listbox used by NT fdisk
    to display the state of attached disks.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/

#include "fdisk.h"

// constants used when listbox or its focus rectangle is
// scrolled/moved.

#define    DIR_NONE     0
#define    DIR_UP       1
#define    DIR_DN       2

// original window procedure for our subclassed listbox

WNDPROC OldListBoxProc;

// item which has focus

DWORD LBCursorListBoxItem,LBCursorRegion;

BOOL LBCursorOn = FALSE;

VOID
ToggleLBCursor(
    IN HDC hdc
    );

VOID
ToggleRegion(
    IN PDISKSTATE DiskState,
    IN DWORD      RegionIndex,
    IN HDC        hdc
    );

LONG
ListBoxSubProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This routine is the window procedure used for our subclassed listbox.
    We subclass the listbox so that we can handle keyboard input processing.
    All other messages are passed through to the original listbox procedure.

    Significant keys are arrows, pageup/dn, tab, space, return, home, and end.
    Control may be used to modify space and return.
    Shift may be used to modify tab.

Arguments:

    hwnd    - window handle of listbox

    msg     - message #

    wParam  - user param # 1

    lParam  - user param # 2

Return Value:

    see below

--*/

{
    int        focusDir = DIR_NONE;
    USHORT     vKey;
    DWORD      maxRegion;
    PDISKSTATE diskState;
    LONG       topItem,
               bottomWholeItem,
               visibleItems;
    RECT       rc;

    switch (msg) {

    case WM_CHAR:

        break;

    case WM_KEYDOWN:

        switch (vKey = LOWORD(wParam)) {
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:

            ToggleLBCursor(NULL);
            switch (vKey) {
            case VK_LEFT:
                LBCursorRegion = LBCursorRegion ? LBCursorRegion-1 : 0;
                break;
            case VK_RIGHT:
                maxRegion = Disks[LBCursorListBoxItem]->RegionCount - 1;
                if (LBCursorRegion < maxRegion) {
                    LBCursorRegion++;
                }
                break;
            case VK_UP:
                if (LBCursorListBoxItem) {
                    LBCursorListBoxItem--;
                    LBCursorRegion = 0;
                    focusDir = DIR_UP;
                }
                break;
            case VK_DOWN:
                if (LBCursorListBoxItem < DiskCount-1) {
                    LBCursorListBoxItem++;
                    LBCursorRegion = 0;
                    focusDir = DIR_DN;
                }
                break;
            }

            // don't allow list box cursor to fall on extended partition

            diskState = Disks[LBCursorListBoxItem];
            maxRegion = diskState->RegionCount - 1;
            if (IsExtended(diskState->RegionArray[LBCursorRegion].SysID)) {
                if (LBCursorRegion && ((vKey == VK_LEFT) || (LBCursorRegion == maxRegion))) {
                    LBCursorRegion--;
                } else {
                    LBCursorRegion++;
                }
            }

            ToggleLBCursor(NULL);
            break;

        case VK_TAB:

            ToggleLBCursor(NULL);

            if (GetKeyState(VK_SHIFT) & ~1) {    // shift-tab
                LBCursorListBoxItem--;
                focusDir = DIR_UP;
            } else {
                LBCursorListBoxItem++;
                focusDir = DIR_DN;
            }
            if (LBCursorListBoxItem == (DWORD)(-1)) {
                LBCursorListBoxItem = DiskCount-1;
                focusDir = DIR_DN;
            } else if (LBCursorListBoxItem == DiskCount) {
                LBCursorListBoxItem = 0;
                focusDir = DIR_UP;
            }
            ResetLBCursorRegion();

            ToggleLBCursor(NULL);
            break;

        case VK_HOME:
        case VK_END:

            ToggleLBCursor(NULL);
            topItem = (vKey == VK_HOME) ? 0 : DiskCount-1;
            SendMessage(hwndList, LB_SETTOPINDEX, (DWORD)topItem, 0);
            LBCursorListBoxItem = topItem;
            ResetLBCursorRegion();
            ToggleLBCursor(NULL);
            break;

        case VK_PRIOR:
        case VK_NEXT:

            ToggleLBCursor(NULL);
            topItem = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
            GetClientRect(hwndList,&rc);
            visibleItems = (rc.bottom - rc.top) / GraphHeight;
            if (!visibleItems) {
                visibleItems = 1;
            }
            topItem = (vKey == VK_PRIOR)
                    ? max(topItem - visibleItems, 0)
                    : min(topItem + visibleItems, (LONG)DiskCount-1);
            SendMessage(hwndList, LB_SETTOPINDEX, (DWORD)topItem, 0);
            LBCursorListBoxItem = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
            ResetLBCursorRegion();
            ToggleLBCursor(NULL);
            break;


        case VK_RETURN:
        case VK_SPACE:

            // Select the region that currently has the list box selection cursor.

            if (!Disks[LBCursorListBoxItem]->OffLine) {

                Selection(GetKeyState(VK_CONTROL) & ~1,     // strip toggle bit
                          Disks[LBCursorListBoxItem],
                          LBCursorRegion);
            }
            break;
        }

        // now scroll the newly focused item into view if necessary

        switch (focusDir) {
        case DIR_UP:
            if (LBCursorListBoxItem < (DWORD)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0)) {
                SendMessage(hwndList, LB_SETTOPINDEX, LBCursorListBoxItem, 0);
            }
            break;
        case DIR_DN:
            GetClientRect(hwndList, &rc);
            topItem = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
            bottomWholeItem = topItem + ((rc.bottom - rc.top) / GraphHeight) - 1;
            if (bottomWholeItem < topItem) {
                bottomWholeItem = topItem;
            }
            if ((DWORD)bottomWholeItem > DiskCount-1) {
                bottomWholeItem = DiskCount-1;
            }
            if (LBCursorListBoxItem > (DWORD)bottomWholeItem) {
                SendMessage(hwndList,
                            LB_SETTOPINDEX,
                            topItem + LBCursorListBoxItem - bottomWholeItem,
                            0);
            }
            break;
        }
        break;

    default:
        return CallWindowProc(OldListBoxProc, hwnd, msg, wParam, lParam);
    }
    return 0;
}

VOID
SubclassListBox(
    IN HWND hwnd
    )
{
    OldListBoxProc = (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
    SetWindowLong(hwnd, GWL_WNDPROC, (LONG)ListBoxSubProc);

    // There is a scantily documented 'feature' of a listbox wherein it will
    // use its parent's DC.  This means that drawing is not always clipped to
    // the client area of the listbox.  Seeing as we're subclassing listboxes
    // anyway, take care of this here.

    SetClassLong(hwnd, GCL_STYLE, GetClassLong(hwnd, GCL_STYLE) & ~CS_PARENTDC);
}

VOID
DeselectSelectedRegions(
    VOID
    )

/*++

Routine Description:

    This routine visually unselects all selected regions.  The selection
    state is also updated in the master disk structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD      i,
               j;
    PDISKSTATE diskState;

    for (i=0; i<DiskCount; i++) {
        diskState = Disks[i];
        for (j=0; j<diskState->RegionCount; j++) {
            if (diskState->Selected[j]) {
                diskState->Selected[j] = FALSE;
                ToggleRegion(diskState, j, NULL);
            }
        }
    }
}

VOID
Selection(
    IN BOOL       MultipleSel,
    IN PDISKSTATE DiskState,
    IN DWORD      RegionIndex
    )

/*++

Routine Description:

    This routine handles a user selection of a disk region.  It is called
    directly for a keyboard selection or indirectly for a mouse selection.
    If not a multiple selection, all selected regions are deselected.
    The focus rectangle is moved to the selected region, which is then
    visually selected.

Arguments:

    MultipleSel - whether the user has made a multiple selection
                  (ie, control-clicked).

    DiskState - master disk structure for disk containing selected region

    RegionIndex - index of selected region on the disk

Return Value:

    None.

--*/

{
    PFT_OBJECT     ftObject,
                   ftObj;
    PFT_OBJECT_SET ftSet;
    ULONG          disk,
                   r;

    if (!MultipleSel) {

        // need to deselect all selected regions first.

        DeselectSelectedRegions();
    }

    // remove the list box selection cursor from its previous region

    ToggleLBCursor(NULL);

    // The selected region might be part of an ft object set.  If it is,
    // scan each region in each disk and select each item in the set.

    if (ftObject = GET_FT_OBJECT(&DiskState->RegionArray[RegionIndex])) {

        ftSet = ftObject->Set;
        for (disk=0; disk<DiskCount; disk++) {
            PDISKSTATE diskState = Disks[disk];

            for (r=0; r<diskState->RegionCount; r++) {
                PREGION_DESCRIPTOR regionDescriptor = &diskState->RegionArray[r];

                if (DmSignificantRegion(regionDescriptor)) {

                    if (ftObj = GET_FT_OBJECT(regionDescriptor)) {

                        if (ftObj->Set == ftSet) {

                            diskState->Selected[r] = (BOOLEAN)(!diskState->Selected[r]);
                            ToggleRegion(diskState, r, NULL);
                        }
                    }
                }
            }
        }
    } else {
        DiskState->Selected[RegionIndex] = (BOOLEAN)(!DiskState->Selected[RegionIndex]);
        ToggleRegion(DiskState, RegionIndex, NULL);
    }

    LBCursorListBoxItem = DiskState->Disk;
    LBCursorRegion      = RegionIndex;
    ToggleLBCursor(NULL);
    AdjustMenuAndStatus();
}

VOID
MouseSelection(
    IN     BOOL   MultipleSel,
    IN OUT PPOINT Point
    )

/*++

Routine Description:

    This routine is called when the user clicks in the list box.  It determines
    which disk region the user has clicked on before calling the common
    selection subroutine.

Arguments:

    MultipleSel - whether the user has made a multiple selection
                  (ie, control-clicked).

    point - screen coords of the click

Return Value:

    None.

--*/

{
    PDISKSTATE  diskState;
    DWORD       selectedItem;
    DWORD       x,
                y;
    DWORD       i;
    RECT        rc;
    BOOL        valid;

    if ((selectedItem = SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR) {
        return;
    }

    // user has clicked on a list box item.

    diskState = Disks[selectedItem];

    // Ignore clicks on off-line disks.

    if (diskState->OffLine) {
        return;
    }

    ScreenToClient(hwndList, Point);

    x = Point->x;
    y = Point->y;
    GetClientRect(hwndList,&rc);

    // first make sure that the click was within a bar and not in space
    // between two bars

    for (valid=FALSE, i=rc.top; i<=(DWORD)rc.bottom; i+=GraphHeight) {
        if ((y >= i+BarTopYOffset) && (y <= i+BarBottomYOffset)) {
            valid = TRUE;
            break;
        }
    }
    if (!valid) {
        return;
    }

    // determine which region he has clicked on

    for (i=0; i<diskState->RegionCount; i++) {
        if ((x >= (unsigned)diskState->LeftRight[i].Left) && (x <= (unsigned)diskState->LeftRight[i].Right)) {
            break;
        }
    }
    if (i == diskState->RegionCount) {
        return;     // region not found.  Ignore the click.
    }

    Selection(MultipleSel, diskState, i);
}

LONG
CalcBarTop(
    DWORD Bar
    )

/*++

Routine Description:

    This routine calculates the current top y coord of a given bar.
    The value is in listbox client coords.

Arguments:

    Bar - # of bar whose position is desired

Return Value:

    Y-coord, or -1 if bar is not visible.

--*/

{
    LONG  barDelta = (LONG)Bar - SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
    LONG  pos = -1;
    RECT  rc;

    if (barDelta >= 0) {                 // BUGBUG check bottom too
        GetClientRect(hwndList,&rc);
        pos = rc.top + (barDelta * GraphHeight);
    }
    return pos;
}

VOID
ResetLBCursorRegion(
    VOID
    )

/*++

Routine Description:

    This routine resets the list box focus cursor to the 0th (leftmost)
    region on the current disk.  If the 0th region is the extended
    partition, focus is set to the first logical volume or free space
    with the extended partition instead.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PDISKSTATE diskState = Disks[LBCursorListBoxItem];
    unsigned   i;

    LBCursorRegion = 0;
    if (IsExtended(diskState->RegionArray[LBCursorRegion].SysID)) {
        for (i=0; i<diskState->RegionCount; i++) {
            if (diskState->RegionArray[i].RegionType == REGION_LOGICAL) {
                LBCursorRegion = i;
                return;
            }
        }
        FDASSERT(0);
    }
}

VOID
ToggleLBCursor(
    IN HDC hdc
    )

/*++

Routine Description:

    This routine visually toggles the focus state of the disk region
    described by the LBCursorListBoxItem and LBCursorRegion globals.

Arguments:

    hdc - If non-NULL, device context to use for drawing.  If NULL,
          we'll first get a DC via GetDC().

Return Value:

    None.

--*/

{
    PDISKSTATE lBCursorDisk = Disks[LBCursorListBoxItem];
    LONG       barTop = CalcBarTop(LBCursorListBoxItem);
    RECT       rc;
    HDC        hdcActual;

    if (barTop != -1) {

        hdcActual = hdc ? hdc : GetDC(hwndList);

        LBCursorOn = !LBCursorOn;

        rc.left   = lBCursorDisk->LeftRight[LBCursorRegion].Left;
        rc.right  = lBCursorDisk->LeftRight[LBCursorRegion].Right + 1;
        rc.top    = barTop + BarTopYOffset;
        rc.bottom = barTop + BarBottomYOffset;

        FrameRect(hdcActual,
                  &rc,
                  GetStockObject(LBCursorOn ? WHITE_BRUSH : BLACK_BRUSH));

        if (LBCursorOn) {

            // BUGBUG really want a dotted line.
            DrawFocusRect(hdcActual, &rc);
        }

        if (!hdc) {
            ReleaseDC(hwndList, hdcActual);
        }
    }
}

VOID
ForceLBRedraw(
    VOID
    )

/*++

Routine Description:

    This routine forces redraw of the listbox by invalidating its
    entire client area.

Arguments:

    None.

Return Value:

    None.

--*/

{
    InvalidateRect(hwndList,NULL,FALSE);
    UpdateWindow(hwndList);
}

VOID
ToggleRegion(
    IN PDISKSTATE DiskState,
    IN DWORD      RegionIndex,
    IN HDC        hdc
    )

/*++

Routine Description:

    This routine visually toggles the selection state of a given disk region.

Arguments:

    DiskState - master structure for disk containing region to select

    RegionIndex - which region on the disk to toggle

    hdc - if non-NULL, device context to use for drawing.  If NULL, we'll
          first get a device context via GetDC().


Return Value:

    None.

--*/

{
    PLEFTRIGHT leftRight = &DiskState->LeftRight[RegionIndex];
    LONG       barTop    = CalcBarTop(DiskState->Disk);  // BUGBUG disk# as lb index#
    BOOL       selected  = (BOOL)DiskState->Selected[RegionIndex];
    HBRUSH     hbr       = GetStockObject(BLACK_BRUSH);
    HDC        hdcActual;
    RECT       rc;
    int        i;

    if (barTop != -1) {

        hdcActual = hdc ? hdc : GetDC(hwndList);

        rc.left   = leftRight->Left + 1;
        rc.right  = leftRight->Right;
        rc.top    = barTop + BarTopYOffset + 1;
        rc.bottom = barTop + BarBottomYOffset - 1;

        if (selected) {

            for (i=0; i<SELECTION_THICKNESS; i++) {
                FrameRect(hdcActual, &rc, hbr);
                InflateRect(&rc, -1, -1);
            }

        } else {

            // Blt the region from the off-screen bitmap onto the
            // screen.  But first exclude the center of the region
            // from the clip region so we only blt the necessary bits.
            // This sppeds up selections noticably.

            InflateRect(&rc, -SELECTION_THICKNESS, -SELECTION_THICKNESS);
            ExcludeClipRect(hdcActual, rc.left, rc.top, rc.right, rc.bottom);
            BitBlt(hdcActual,
                   leftRight->Left,
                   barTop + BarTopYOffset,
                   leftRight->Right - leftRight->Left,
                   barTop + BarBottomYOffset,
                   DiskState->hDCMem,
                   leftRight->Left,
                   BarTopYOffset,
                   SRCCOPY);
        }

        if (!hdc) {
            ReleaseDC(hwndList, hdcActual);
        }
    }
}

DWORD
InitializeListBox(
    IN HWND  hwndListBox
    )

/*++

Routine Description:

    This routine sets up the list box.  This includes creating disk state
    structures, drawing the graphs for each disk off screen, and adding the
    disks to the list box.

    It also includes determining the initial volume labels and type names
    for all significant partitions.

Arguments:

    hwndListBox - handle of the list box that will hold the disk graphs

Return Value:

    Windows error code (esp. out of memory)

--*/

{
    PPERSISTENT_REGION_DATA regionData;
    TCHAR                   windowsDir[MAX_PATH];
    unsigned                i;
    PDISKSTATE              diskState;
    DWORD                   ec;
    ULONG                   r;
    BOOL                    diskSignaturesCreated,
                            temp;

    // First, create the array that will hold the diskstates,
    // the IsDiskRemovable array and the RemovableDiskReservedDriveLetters
    // array.

    Disks = Malloc(DiskCount * sizeof(PDISKSTATE));
    IsDiskRemovable = (PBOOLEAN)Malloc(DiskCount * sizeof(BOOLEAN));
    RemovableDiskReservedDriveLetters = (PCHAR)Malloc(DiskCount * sizeof(CHAR));

    // Determine which disks are removable and which are unpartitioned.

    for (i=0; i<DiskCount; i++) {

        IsDiskRemovable[i] = IsRemovable( i );
    }

    // next, create all disk states

    FDASSERT(DiskCount);
    diskSignaturesCreated = FALSE;
    for (i=0; i<DiskCount; i++) {

        // first create the disk state structure

        CreateDiskState(&diskState, i, &temp);
        diskSignaturesCreated = diskSignaturesCreated || temp;

        Disks[i] = diskState;

        // next determine the state of the disk's partitioning scheme

        DeterminePartitioningState(diskState);

        // Next create a blank logical disk structure for each region.

        for (r=0; r<diskState->RegionCount; r++) {
            if (DmSignificantRegion(&diskState->RegionArray[r])) {
                regionData = Malloc(sizeof(PERSISTENT_REGION_DATA));
                DmInitPersistentRegionData(regionData, NULL, NULL, NULL, NO_DRIVE_LETTER_YET);
                regionData->VolumeExists = TRUE;
            } else {
                regionData = NULL;
            }
            DmSetPersistentRegionData(&diskState->RegionArray[r], regionData);
        }

        // add the item to the listbox

        while (((ec = SendMessage(hwndListBox, LB_ADDSTRING, 0, 0)) == LB_ERR) || (ec == LB_ERRSPACE)) {
            ConfirmOutOfMemory();
        }
    }

    // Read the configuration registry

    if ((ec = InitializeFt(diskSignaturesCreated)) != NO_ERROR) {
        ErrorDialog(ec);
        return ec;
    }

    // Determine drive letter mappings

    InitializeDriveLetterInfo();

    // Determine volume labels and type names.

    InitVolumeLabelsAndTypeNames();

    // Determine which disk is the boot disk.

    if (GetWindowsDirectory(windowsDir, sizeof(windowsDir)/sizeof(TCHAR)) < 2 ||
        windowsDir[1] != TEXT(':')) {

        BootDiskNumber = (ULONG)-1;
        BootPartitionNumber = (ULONG)-1;
    } else {
        BootDiskNumber = GetDiskNumberFromDriveLetter((CHAR)windowsDir[0]);
        BootPartitionNumber = GetPartitionNumberFromDriveLetter((CHAR)windowsDir[0]);
    }

    // Locate and create data structures for any DoubleSpace volumes

    DblSpaceInitialize();

    for (i=0; i<DiskCount; i++) {

        DrawDiskBar(Disks[i]);
    }

    return NO_ERROR;
}

VOID
WMDrawItem(
    IN PDRAWITEMSTRUCT pDrawItem
    )
{
    DWORD      temp;
    PDISKSTATE pDiskState;

    if ((pDrawItem->itemID != (DWORD)(-1))
    && (pDrawItem->itemAction == ODA_DRAWENTIRE)) {
        pDiskState = Disks[pDrawItem->itemID];

        // blt the disk's bar from the off-screen bitmap to the screen

        BitBlt(pDrawItem->hDC,
               pDrawItem->rcItem.left,
               pDrawItem->rcItem.top,
               pDrawItem->rcItem.right  - pDrawItem->rcItem.left + 1,
               pDrawItem->rcItem.bottom - pDrawItem->rcItem.top  + 1,
               pDiskState->hDCMem,
               0,
               0,
               SRCCOPY);

        // if we just overwrote the focus cursor, redraw it

        if (pDrawItem->itemID == LBCursorListBoxItem) {
            LBCursorOn = FALSE;
            ToggleLBCursor(pDrawItem->hDC);
        }

        // select any items selected in this bar

        for (temp=0; temp<pDiskState->RegionCount; temp++) {
            if (pDiskState->Selected[temp]) {
                ToggleRegion(pDiskState, temp, pDrawItem->hDC);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdproto.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    fdproto.h

Abstract:

    Function prototypes.

Author:

    Ted Miller (tedm) 7-Jan-1992

Revision:

    Bob Rinne  (bobri) 2-Feb-1994
    Moved definitions from ArcInst here to get rid of dependency with
    that source project.

--*/

// stuff in fdengine.c

BOOLEAN
SignatureIsUniqueToSystem(
    IN ULONG Disk,
    IN ULONG Signature
    );

VOID
FdSetDiskSignature(
    IN ULONG Disk,
    IN ULONG Signature
    );

ULONG
FdGetDiskSignature(
    IN ULONG Disk
    );

BOOLEAN
IsDiskOffLine(
    IN ULONG Disk
    );

BOOLEAN
IsRegionCommitted(
    PREGION_DESCRIPTOR RegionDescriptor
    );

BOOLEAN
ChangeCommittedOnDisk(
    IN ULONG Disk
    );

VOID
ClearCommittedDiskInformation(
    );

// stuff in fdisk.c

LONG
MyFrameWndProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN UINT  wParam,
    IN LONG  lParam
    );

VOID
DeterminePartitioningState(
    IN OUT PDISKSTATE DiskState
    );

VOID
DrawDiskBar(
    IN PDISKSTATE DiskState
    );

VOID
AdjustMenuAndStatus(
    VOID
    );

// stuff in fdinit.c

BOOL
InitializeApp(
    VOID
    );

VOID
CreateDiskState(
    OUT PDISKSTATE *DiskState,
    IN  DWORD       Disk,
    OUT PBOOL       SignatureCreated
    );

#if DBG && DEVL

VOID
StartThread2(
    VOID
    );

#endif

VOID
DisplayInitializationMessage(
    VOID
    );

// stuff in fdlistbx.c

VOID
Selection(
    IN BOOL       MultipleSel,
    IN PDISKSTATE DiskState,
    IN DWORD      region
    );

VOID
MouseSelection(
    IN     BOOL   MultipleSel,
    IN OUT PPOINT point
    );

VOID
SubclassListBox(
    IN HWND hwnd
    );

DWORD
InitializeListBox(
    IN HWND hwndListBox
    );

VOID
ResetLBCursorRegion(
    VOID
    );

VOID
WMDrawItem(
    IN PDRAWITEMSTRUCT pDrawItem
    );

VOID
ForceLBRedraw(
    VOID
    );


// stuff in fdmisc.c

BOOL
AllDisksOffLine(
    VOID
    );

VOID
FdShutdownTheSystem(
    VOID
    );

LPTSTR
LoadAString(
    IN DWORD StringID
    );

PWSTR
LoadWString(
    IN DWORD StringID
    );

int
GetHeightFromPoints(
    IN int Points
    );

VOID
UnicodeHack(
    IN  PCHAR  Source,
    OUT LPTSTR Dest
    );

VOID
TotalRedrawAndRepaint(
    VOID
    );

DWORD
CommonDialog(
    IN DWORD   MsgCode,
    IN LPTSTR  Caption,
    IN DWORD   Flags,
    IN va_list arglist
    );

VOID
ErrorDialog(
    IN DWORD ErrorCode,
    ...
    );

VOID
WarningDialog(
    IN DWORD MsgCode,
    ...
    );

DWORD
ConfirmationDialog(
    IN DWORD MsgCode,
    IN DWORD Flags,
    ...
    );

VOID
InfoDialog(
    IN DWORD MsgCode,
    ...
    );

VOID
InitVolumeLabelsAndTypeNames(
    VOID
    );

VOID
DetermineRegionInfo(
    IN PREGION_DESCRIPTOR Region,
    OUT PWSTR *TypeName,
    OUT PWSTR *VolumeLabel,
    OUT PWCH   DriveLetter
    );

VOID
InitializeDriveLetterInfo(
    VOID
    );

CHAR
GetAvailableDriveLetter(
    VOID
    );

VOID
MarkDriveLetterUsed(
    IN CHAR DriveLetter
    );

VOID
MarkDriveLetterFree(
    IN CHAR DriveLetter
    );

BOOL
DriveLetterIsAvailable(
    IN CHAR DriveLetter
    );

BOOL
AllDriveLettersAreUsed(
    VOID
    );

ULONG
GetDiskNumberFromDriveLetter(
    IN CHAR DriveLetter
    );

ULONG
GetPartitionNumberFromDriveLetter(
    IN CHAR DriveLetter
    );

PREGION_DESCRIPTOR
LocateRegionForFtObject(
    IN PFT_OBJECT FtObject
    );

#if DBG

VOID
FdiskAssertFailedRoutine(
    IN char *Expression,
    IN char *FileName,
    IN int   LineNumber
    );

#endif


// stuff in fddlgs.c

VOID
CenterDialog(
    HWND hwnd
    );

VOID
SubclassListBox(
    IN HWND hwnd
    );

INT_PTR CALLBACK
MinMaxDlgProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
DriveLetterDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
ColorDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
DisplayOptionsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
InitRectControl(
    VOID
    );


// Format and label support routines - dmfmifs.c

VOID
FormatPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    );

VOID
LabelPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    );

INT_PTR CALLBACK
FormatDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
LabelDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
CancelDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
UnloadIfsDll(
    VOID
    );

// stuff in fdmem.c

PVOID
Malloc(
    IN ULONG Size
    );

PVOID
Realloc(
    IN PVOID Block,
    IN ULONG NewSize
    );

VOID
Free(
    IN PVOID Block
    );

VOID
ConfirmOutOfMemory(
    VOID
    );


// stuff in fdstleg.c

VOID
UpdateStatusBarDisplay(
    VOID
    );

VOID
ClearStatusArea(
    VOID
    );

VOID
DrawLegend(
    IN HDC   hdc,
    IN PRECT rc
    );

VOID
DrawStatusAreaItem(
    IN PRECT  rc,
    IN HDC    hdc,
    IN LPTSTR Text,
    IN BOOL   Unicode
    );


// stuff in fdprof.c

VOID
WriteProfile(
    VOID
    );

VOID
ReadProfile(
    VOID
    );


// stuff in fdft.c

ULONG
InitializeFt(
    IN BOOL DiskSignaturesCreated
    );

ULONG
SaveFt(
    VOID
    );

VOID
FdftCreateFtObjectSet(
    IN FT_TYPE             FtType,
    IN PREGION_DESCRIPTOR *Regions,
    IN DWORD               RegionCount,
    IN FT_SET_STATUS       Status
    );

BOOL
FdftUpdateFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN FT_SET_STATUS  SetState
    );

VOID
FdftDeleteFtObjectSet(
    IN PFT_OBJECT_SET FtSet,
    IN BOOL           OffLineDisksOnly
    );

BOOLEAN
NewConfigurationRequiresFt(
    VOID
    );

VOID
FdftExtendFtObjectSet(
    IN OUT  PFT_OBJECT_SET      FtSet,
    IN OUT  PREGION_DESCRIPTOR* Regions,
    IN      DWORD               RegionCount
    );

DWORD
FdftNextOrdinal(
    IN FT_TYPE FtType
    );

// commit.c

VOID
FtConfigure(
    VOID
    );

VOID
CommitAssignLetterList(
    VOID
    );

VOID
CommitToAssignLetterList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               MoveLetter
    );

VOID
CommitAllChanges(
    IN PVOID Param
    );

VOID
CommitDeleteLockLetter(
    IN CHAR DriveLetter
    );

BOOL
CommitAllowed(
    VOID
    );


VOID
RescanDevices(
    VOID
    );

// Commit interface routines.

LETTER_ASSIGNMENT_RESULT
CommitDriveLetter(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN CHAR OldDrive,
    IN CHAR NewDrive
    );

LONG
CommitToLockList(
    IN PREGION_DESCRIPTOR RegionDescriptor,
    IN BOOL               RemoveDriveLetter,
    IN BOOL               LockNow,
    IN BOOL               FailOk
    );

LONG
CommitLockVolumes(
    IN ULONG Disk
    );

LONG
CommitUnlockVolumes(
    IN ULONG   Disk,
    IN BOOLEAN FreeList
    );

VOID
CommitUpdateRegionStructures(
    VOID
    );

// windisk.c

INT_PTR CALLBACK
SizeDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

extern WNDPROC OldSizeDlgProc;

DWORD
CommitChanges(
    VOID
    );

BOOLEAN
BootPartitionNumberChanged(
    PULONG OldNumber,
    PULONG NewNumber
    );

DWORD
DeletionIsAllowed(
    IN PREGION_DESCRIPTOR Region
    );

BOOL
RegisterFileSystemExtend(
    VOID
    );

// stuff in fd_nt.c

BOOLEAN
IsPagefileOnDrive(
    CHAR DriveLetter
    );

VOID
LoadExistingPageFileInfo(
    IN VOID
    );

BOOLEAN
GetVolumeSizeMB(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PULONG Size
    );

ULONG
GetVolumeTypeAndSize(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label,
    OUT PWSTR *Type,
    OUT PULONG Size
    );

PWSTR
GetWideSysIDName(
    IN UCHAR SysID
    );

ULONG
MyDiskRegistryGet(
    OUT PDISK_REGISTRY *DiskRegistry
    );

ULONG
MasterBootCode(
    IN ULONG   Disk,
    IN ULONG   Signature,
    IN BOOLEAN SetBootCode,
    IN BOOLEAN SetSignature
    );

ULONG
UpdateMasterBootCode(
    IN ULONG   Disk
    );

ULONG
FormDiskSignature(
    VOID
    );

ULONG
GetVolumeLabel(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label
    );

ULONG
GetTypeName(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Name
    );

BOOLEAN
IsRemovable(
    IN ULONG DiskNumber
    );

ULONG
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    );

#if i386
VOID
MakePartitionActive(
    IN PREGION_DESCRIPTOR DiskRegionArray,
    IN ULONG              RegionCount,
    IN ULONG              RegionIndex
    );
#endif


// stuff in arrowin.c

BOOL
RegisterArrowClass(
    IN HANDLE hModule
    );


// stuff in fdhelp.c

VOID
InitHelp(
    VOID
    );

VOID
TermHelp(
    VOID
    );

VOID
Help(
    IN LONG Code
    );

VOID
DialogHelp(
    IN DWORD HelpId
    );

VOID
SetMenuItemHelpContext(
    IN LONG wParam,
    IN DWORD lParam
    );


// stuff in ftreg.c

BOOL
DoMigratePreviousFtConfig(
    VOID
    );

BOOL
DoRestoreFtConfig(
    VOID
    );

VOID
DoSaveFtConfig(
    VOID
    );


// Double Space support routines.

BOOL
DblSpaceVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    );

BOOL
DblSpaceDismountedVolumeExists(
    IN PREGION_DESCRIPTOR RegionDescriptor
    );

BOOLEAN
DblSpaceCreate(
    IN HWND  Dialog,
    IN PVOID Param
    );

VOID
DblSpaceDelete(
    IN PVOID Param
    );

VOID
DblSpaceMount(
    IN PVOID Param
    );

VOID
DblSpaceDismount(
    IN PVOID Param
    );

VOID
DblSpaceInitialize(
    VOID
    );

VOID
DblSpace(
    IN HWND  Dialog,
    IN PVOID Param
    );

PDBLSPACE_DESCRIPTOR
DblSpaceGetNextVolume(
    IN PREGION_DESCRIPTOR   RegionDescriptor,
    IN PDBLSPACE_DESCRIPTOR DblSpace
    );

// FmIfs interface routines

BOOL
LoadIfsDll(
    VOID
    );

BOOL
FmIfsDismountDblspace(
    IN CHAR DriveLetter
    );

BOOL
FmIfsMountDblspace(
    IN PCHAR FileName,
    IN CHAR  HostDrive,
    IN CHAR  NewDrive
    );

BOOLEAN
FmIfsQueryInformation(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    );


// Cdrom interface routines.

VOID
CdRom(
    IN HWND  Dialog,
    IN PVOID Param
    );

VOID
CdRomAddDevice(
    IN PWSTR NtName,
    IN WCHAR DriveLetter
    );

//
// Macros
//

//
// BOOLEAN
// DmSignificantRegion(
//      IN PREGION_DESCRIPTOR Region
//      );
//

#define DmSignificantRegion(Region)     (((Region)->SysID != SYSID_UNUSED) \
                                     &&  (!IsExtended((Region)->SysID))    \
                                     &&  (IsRecognizedPartition((Region)->SysID)))

//
// VOID
// DmSetPersistentRegionData(
//      IN PPERSISTENT_REGION_DATA RegionData
//      );
//

#define DmSetPersistentRegionData(Region,RegionData)            \
            FdSetPersistentData((Region),(ULONG)RegionData);    \
            (Region)->PersistentData = RegionData


//
// VOID
// DmInitPersistentRegionData(
//      OUT PPERSISTENT_REGION_DATA RegionData,
//      IN  PFT_OBJECT ftObject,
//      IN  PWSTR volumeLabel,
//      IN  PWSTR typeName,
//      IN  CHAR driveLetter,
//      );
//

#define DmInitPersistentRegionData(RegionData,ftObject,volumeLabel,typeName,driveLetter) \
            RegionData->DblSpace    = NULL;             \
            RegionData->FtObject    = ftObject;         \
            RegionData->VolumeLabel = volumeLabel;      \
            RegionData->TypeName    = typeName;         \
            RegionData->VolumeExists = FALSE;           \
            RegionData->DriveLetter = driveLetter

// ntlow definitions

STATUS_CODE
LowOpenNtName(
    IN PCHAR     Name,
    IN HANDLE_PT Handle
    );

STATUS_CODE
LowOpenDisk(
    IN  PCHAR       DevicePath,
    OUT HANDLE_PT   DiskId
    );

STATUS_CODE
LowOpenPartition(
    IN  PCHAR       DevicePath,
    IN  ULONG       Partition,
    OUT HANDLE_PT   Handle
    );

STATUS_CODE
LowOpenDriveLetter(
    IN CHAR      DriveLetter,
    IN HANDLE_PT Handle
    );

STATUS_CODE
LowCloseDisk(
    IN  HANDLE_T    DiskId
    );

STATUS_CODE
LowGetDriveGeometry(
    IN  PCHAR   DevicePath,
    OUT PULONG  TotalSectorCount,
    OUT PULONG  SectorSize,
    OUT PULONG  SectorsPerTrack,
    OUT PULONG  Heads
    );

STATUS_CODE
LowGetPartitionGeometry(
    IN  PCHAR   PartitionPath,
    OUT PULONG  TotalSectorCount,
    OUT PULONG  SectorSize,
    OUT PULONG  SectorsPerTrack,
    OUT PULONG  Heads
    );

STATUS_CODE
LowReadSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    OUT PVOID       Buffer
    );

STATUS_CODE
LowWriteSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    IN  PVOID       Buffer
    );

STATUS_CODE
LowLockDrive(
    IN HANDLE_T DiskId
    );

STATUS_CODE
LowUnlockDrive(
    IN HANDLE_T DiskId
    );

STATUS_CODE
LowFtVolumeStatus(
    IN ULONG          Disk,
    IN ULONG          Partition,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    );

STATUS_CODE
LowFtVolumeStatusByLetter(
    IN CHAR           DriveLetter,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    );

STATUS_CODE
LowSetDiskLayout(
    IN PCHAR                     Path,
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    );

STATUS_CODE
LowGetDiskLayout(
    IN  PCHAR                      Path,
    OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout
    );

// Partition engine definitions

ULONG
GetDiskCount(
    VOID
    );

PCHAR
GetDiskName(
    ULONG Disk
    );

ULONG
DiskSizeMB(
    IN ULONG Disk
    );

STATUS_CODE
GetDiskRegions(
    IN  ULONG               Disk,
    IN  BOOLEAN             WantUsedRegions,
    IN  BOOLEAN             WantFreeRegions,
    IN  BOOLEAN             WantPrimaryRegions,
    IN  BOOLEAN             WantLogicalRegions,
    OUT PREGION_DESCRIPTOR *Region,
    OUT ULONG              *RegionCount
    );

#define GetAllDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,TRUE,TRUE,TRUE,regions,count)

#define GetFreeDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,FALSE,TRUE,TRUE,TRUE,regions,count)

#define GetUsedDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,FALSE,TRUE,TRUE,regions,count)

#define GetPrimaryDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,TRUE,TRUE,FALSE,regions,count)

#define GetLogicalDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,TRUE,FALSE,TRUE,regions,count)

#define GetUsedPrimaryDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,FALSE,TRUE,FALSE,regions,count)

#define GetUsedLogicalDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,TRUE,FALSE,FALSE,TRUE,regions,count)

#define GetFreePrimaryDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,FALSE,TRUE,TRUE,FALSE,regions,count)

#define GetFreeLogicalDiskRegions(disk,regions,count) \
        GetDiskRegions(disk,FALSE,TRUE,FALSE,TRUE,regions,count)

VOID
FreeRegionArray(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              RegionCount
    );

STATUS_CODE
IsAnyCreationAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT PBOOLEAN AnyAllowed,
    OUT PBOOLEAN PrimaryAllowed,
    OUT PBOOLEAN ExtendedAllowed,
    OUT PBOOLEAN LogicalAllowed
    );

STATUS_CODE
IsCreationOfPrimaryAllowed(
    IN  ULONG    Disk,
    IN  BOOLEAN  AllowMultiplePrimaries,
    OUT PBOOLEAN Allowed
    );

STATUS_CODE
IsCreationOfExtendedAllowed(
    IN  ULONG    Disk,
    OUT PBOOLEAN Allowed
    );

STATUS_CODE
IsCreationOfLogicalAllowed(
    IN  ULONG    Disk,
    OUT PBOOLEAN Allowed
    );

STATUS_CODE
DoesAnyPartitionExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN AnyExists,
    OUT PBOOLEAN PrimaryExists,
    OUT PBOOLEAN ExtendedExists,
    OUT PBOOLEAN LogicalExists
    );

STATUS_CODE
DoesAnyPrimaryExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN Exists
    );

STATUS_CODE
DoesExtendedExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN Exists
    );

STATUS_CODE
DoesAnyLogicalExist(
    IN  ULONG    Disk,
    OUT PBOOLEAN Exists
    );

BOOLEAN
IsExtended(
    IN UCHAR SysID
    );

VOID
SetPartitionActiveFlag(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              value
    );

STATUS_CODE
CreatePartition(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type
    );

STATUS_CODE
CreatePartitionEx(
    IN PREGION_DESCRIPTOR Region,
    IN LARGE_INTEGER      MinimumSize,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        Type,
    IN UCHAR              SysId
    );

STATUS_CODE
DeletePartition(
    IN PREGION_DESCRIPTOR Region
    );

ULONG
GetHiddenSectorCount(
    ULONG Disk,
    ULONG Partition
    );

VOID
SetSysID(
    IN ULONG Disk,
    IN ULONG Partition,
    IN UCHAR SysID
    );

VOID
SetSysID2(
    IN PREGION_DESCRIPTOR Region,
    IN UCHAR              SysID
    );

PCHAR
GetSysIDName(
    UCHAR SysID
    );

STATUS_CODE
CommitPartitionChanges(
    IN ULONG Disk
    );

BOOLEAN
HavePartitionsBeenChanged(
    IN ULONG Disk
    );

VOID
FdMarkDiskDirty(
    IN ULONG Disk
    );

VOID
FdSetPersistentData(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              Data
    );

ULONG
FdGetMinimumSizeMB(
    IN ULONG Disk
    );

ULONG
FdGetMaximumSizeMB(
    IN PREGION_DESCRIPTOR Region,
    IN REGION_TYPE        CreationType
    );

LARGE_INTEGER
FdGetExactSize(
    IN PREGION_DESCRIPTOR Region,
    IN BOOLEAN            ForExtended
    );

LARGE_INTEGER
FdGetExactOffset(
    IN PREGION_DESCRIPTOR Region
    );

BOOLEAN
FdCrosses1024Cylinder(
    IN PREGION_DESCRIPTOR Region,
    IN ULONG              CreationSizeMB,
    IN REGION_TYPE        RegionType
    );

ULONG
FdGetDiskSignature(
    IN ULONG Disk
    );

VOID
FdSetDiskSignature(
    IN ULONG Disk,
    IN ULONG Signature
    );

BOOLEAN
IsDiskOffLine(
    IN ULONG Disk
    );


STATUS_CODE
FdiskInitialize(
    VOID
    );

VOID
FdiskCleanUp(
    VOID
    );

VOID
ConfigureSystemPartitions(
    VOID
    );


VOID
ConfigureOSPartitions(
    VOID
    );

// Network support function definitions.  stuff from network.c

VOID
NetworkRemoveShare(
    IN LPCTSTR DriveLetter
    );

VOID
NetworkShare(
    IN LPCTSTR DriveLetter
    );

VOID
NetworkInitialize(
    );

// Debugging support for opens

#ifdef DBG

NTSTATUS
DmOpenFile(
    OUT PHANDLE           FileHandle,
    IN ACCESS_MASK        DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK  IoStatusBlock,
    IN ULONG              ShareAccess,
    IN ULONG              OpenOptions
    );

NTSTATUS
DmClose(
    IN HANDLE Handle
    );
#else
#define DmOpenFile NtOpenFile
#define DmClose    NtClose
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdmisc.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    fdmisc.c

Abstract:

    Miscellaneous routines for NT fdisk.

Author:

    Ted Miller (tedm) 7-Jan-1992

Modifications:

    13-Dec-1993 (bobri) CdRom initialization support.

--*/


#include "fdisk.h"
#include <process.h>

extern HWND    InitDlg;
extern BOOLEAN StartedAsIcon;

BOOL
AllDisksOffLine(
    VOID
    )

/*++

Routine Description:

    Determine whether all hard disks are off line.

Arguments:

    None.

Return Value:

    TRUE if all disks off-line, false otherwise.

--*/

{
    ULONG i;

    FDASSERT(DiskCount);

    for (i=0; i<DiskCount; i++) {
        if (!IsDiskOffLine(i)) {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
FdShutdownTheSystem(
    VOID
    )

/*++

Routine Description:

    This routine attempts to update the caller privilege, then shutdown the
    Windows NT system.  If it fails it prints a warning dialog.  If it
    succeeds then it doesn't return to the caller.

Arguments:

    None

Return Value:

    None

--*/

{
    NTSTATUS Status;
    BOOLEAN  PreviousPriv;

    InfoDialog(MSG_MUST_REBOOT);
    SetCursor(hcurWait);
    WriteProfile();

    // Enable shutdown privilege

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &PreviousPriv);

#if DBG
    if (Status) {
        DbgPrint("DISKMAN: Status %lx attempting to enable shutdown privilege\n",Status);
    }
#endif

    Sleep(3000);
    if (!ExitWindowsEx(EWX_REBOOT,(DWORD)(-1))) {
        WarningDialog(MSG_COULDNT_REBOOT);
    }
}


LPTSTR
LoadAString(
    IN DWORD StringID
    )

/*++

Routine Description:

    Loads a string from the resource file and allocates a buffer of exactly
    the right size to hold it.

Arguments:

    StringID - resource ID of string to load

Return Value:

    pointer to buffer.  If string is not found, the first
    (and only) char in the returned buffer will be 0.

--*/

{
    TCHAR  text[500];
    LPTSTR buffer;

    text[0] = 0;
    LoadString(hModule, StringID, text, sizeof(text)/sizeof(TCHAR));
    buffer = Malloc((lstrlen(text)+1)*sizeof(TCHAR));
    lstrcpy(buffer, text);
    return buffer;
}


PWSTR
LoadWString(
    IN DWORD StringID
    )

/*++

Routine Description:

    Loads a wide-char string from the resource file and allocates a
    buffer of exactly the right size to hold it.

Arguments:

    StringID - resource ID of string to load

Return Value:

    pointer to buffer.  If string is not found, the first
    (and only) char in the returned buffer will be 0.

--*/

{
    WCHAR text[500];
    PWSTR buffer;

    text[0] = 0;
    LoadStringW(hModule, StringID, text, sizeof(text)/sizeof(WCHAR));
    buffer = Malloc((lstrlenW(text)+1)*sizeof(WCHAR));
    lstrcpyW(buffer, text);
    return buffer;
}


int
GetHeightFromPoints(
    IN int Points
    )

/*++

Routine Description:

    This routine calculates the height of a font given a point value.
    The calculation is based on 72 points per inch and the display's
    pixels/inch device capability.

Arguments:

    Points - number of points

Return Value:

    pixel count (negative and therefore suitable for passing to
    CreateFont())

--*/

{
    HDC hdc    = GetDC(NULL);
    int height = MulDiv(-Points, GetDeviceCaps(hdc, LOGPIXELSY), 72);

    ReleaseDC(NULL, hdc);
    return height;
}


VOID
UnicodeHack(
    IN  PCHAR  Source,
    OUT LPTSTR Dest
    )

/*++

Routine Description:

    Given a non-Unicode ASCII string, this routine will either convert it
    to Unicode or copy it, depending on the current definition of TCHAR.
    The 'conversion' is a simple hack that casts to TCHAR.

Arguments:

    Source - source (ansi ascii) string
    Dest   - destination string or wide string

Return Value:

    None.

--*/

{
    int i;
    int j = lstrlen(Source);

    for (i=0; i<=j; i++) {
        Dest[i] = (TCHAR)(UCHAR)Source[i];
    }
}


VOID
_RetreiveAndFormatMessage(
    IN  DWORD   Msg,
    OUT LPTSTR  Buffer,
    IN  DWORD   BufferSize,
    IN  va_list arglist
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD x;
    TCHAR text[500];

    // get message from system or app msg file.

    x = FormatMessage( Msg >= MSG_FIRST_FDISK_MSG
                     ? FORMAT_MESSAGE_FROM_HMODULE
                     : FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       Msg,
                       0,
                       Buffer,
                       BufferSize,
                       &arglist);

    if (!x) {                // couldn't find message

        LoadString(hModule,
                   Msg >= MSG_FIRST_FDISK_MSG ? IDS_NOT_IN_APP_MSG_FILE : IDS_NOT_IN_SYS_MSG_FILE,
                   text,
                   sizeof(text)/sizeof(TCHAR));

        wsprintf(Buffer, text, Msg);
    }
}


DWORD
CommonDialog(
    IN DWORD   MsgCode,
    IN LPTSTR  Caption,
    IN DWORD   Flags,
    IN va_list arglist
    )

/*++

Routine Description:

    Simple dialog routine to get dialogs out of the resource
    for the program and run them as a message box.

Arguments:

    MsgCode - dialog message code
    Caption - message box caption
    Flags   - standard message box flags
    arglist - list to be given when pulling the message text

Return Value:

    The MessageBox() return value

--*/

{
    TCHAR   MsgBuf[MESSAGE_BUFFER_SIZE];

    if (!StartedAsIcon) {
//        Flags |= MB_SETFOREGROUND;
    }

    if (InitDlg) {

        PostMessage(InitDlg,
                    (WM_USER + 1),
                    0,
                    0);
        InitDlg = (HWND) 0;
    }
    _RetreiveAndFormatMessage(MsgCode, MsgBuf, sizeof(MsgBuf), arglist);
    return MessageBox(GetActiveWindow(), MsgBuf, Caption, Flags);
}


VOID
ErrorDialog(
    IN DWORD ErrorCode,
    ...
    )

/*++

-Routine Description:

    This routine retreives a message from the app or system message file
    and displays it in a message box.

Arguments:

    ErrorCode - number of message

    ...       - strings for insertion into message

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist, ErrorCode);
    CommonDialog(ErrorCode, NULL, MB_ICONHAND | MB_OK | MB_SYSTEMMODAL, arglist);
    va_end(arglist);
}




VOID
WarningDialog(
    IN DWORD MsgCode,
    ...
    )

/*++

Routine Description:

    This routine retreives a message from the app or system message file
    and displays it in a message box.

Arguments:

    MsgCode - number of message

    ...     - strings for insertion into message

Return Value:

    None.

--*/

{
    TCHAR Caption[100];
    va_list arglist;

    va_start(arglist, MsgCode);
    LoadString(hModule, IDS_APPNAME, Caption, sizeof(Caption)/sizeof(TCHAR));
    CommonDialog(MsgCode, Caption, MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL, arglist);
    va_end(arglist);
}


DWORD
ConfirmationDialog(
    IN DWORD MsgCode,
    IN DWORD Flags,
    ...
    )

/*++

Routine Description:

    Support for a simple confirmation dialog

Arguments:

    MsgCode - resource code for message
    Flags   - dialog flags

Return Value:

    Result from the CommonDialog() performed.

--*/

{
    TCHAR Caption[100];
    DWORD x;
    va_list arglist;

    va_start(arglist, Flags);
    LoadString(hModule, IDS_CONFIRM, Caption, sizeof(Caption)/sizeof(TCHAR));
    x = CommonDialog(MsgCode, Caption, Flags | MB_TASKMODAL, arglist);
    va_end(arglist);
    return x;
}


VOID
InfoDialog(
    IN DWORD MsgCode,
    ...
    )

/*++

Routine Description:

    This routine retreives a message from the app or system message file
    and displays it in a message box.

Arguments:

    MsgCode - number of message

    ...     - strings for insertion into message

Return Value:

    None.

--*/

{
    TCHAR Caption[100];
    va_list arglist;

    va_start(arglist, MsgCode);
    LoadString(hModule, IDS_APPNAME, Caption, sizeof(Caption)/sizeof(TCHAR));
    CommonDialog(MsgCode, Caption, MB_ICONINFORMATION | MB_OK | MB_TASKMODAL, arglist);
    va_end(arglist);
}

PREGION_DESCRIPTOR
LocateRegionForFtObject(
    IN PFT_OBJECT FtObject
    )

/*++

Routine Description:

    Given an FtObject, find the associated region descriptor

Arguments:

    FtObject - the ft object to search for.

Return Value:

    NULL - no descriptor found
    !NULL - a pointer to the region descriptor for the FT object

++*/

{
    PDISKSTATE         diskState;
    PREGION_DESCRIPTOR regionDescriptor;
    DWORD              disk,
                       region;
    PPERSISTENT_REGION_DATA regionData;

    for (disk = 0; disk < DiskCount; disk++) {

        diskState = Disks[disk];

        for (region = 0; region < diskState->RegionCount; region++) {

            regionDescriptor = &diskState->RegionArray[region];
            regionData = PERSISTENT_DATA(regionDescriptor);

            if (regionData) {
                if (regionData->FtObject == FtObject) {
                    return regionDescriptor;
                }
            }
        }
    }
    return NULL;
}

VOID
InitVolumeLabelsAndTypeNames(
    VOID
    )

/*++

Routine Description:

    Determine the volume label and type name for each significant
    (non-extended, non-free, recognized) partition.

    Assumes that persistent data has already been set up, and drive letters
    determined.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD              disk,
                       region;
    PDISKSTATE         ds;
    PREGION_DESCRIPTOR rd;
    PPERSISTENT_REGION_DATA regionData;
    WCHAR              diskName[4];
    WCHAR              volumeLabel[100];
    WCHAR              typeName[100];
    UINT               errorMode;

    lstrcpyW(diskName, L"x:\\");

    for (disk=0; disk<DiskCount; disk++) {

        ds = Disks[disk];

        for (region=0; region<ds->RegionCount; region++) {

            rd = &ds->RegionArray[region];

            if (DmSignificantRegion(rd)) {

                // If the region has a drive letter, use the drive letter
                // to get the info via the Windows API.  Otherwise we'll
                // have to use the NT API.

                regionData = PERSISTENT_DATA(rd);

                if (!regionData) {
                    continue;
                }

                if ((regionData->DriveLetter == NO_DRIVE_LETTER_YET)
                ||  (regionData->DriveLetter == NO_DRIVE_LETTER_EVER)) {
                    PWSTR tempLabel,
                          tempName;

                    // No drive letter.  Use NT API.
                    // If this is an FT set use the zero member disk for the
                    // call so all members get the right type and label

                    if (regionData->FtObject) {
                        PFT_OBJECT searchFtObject;

                        // Want to get rd pointing to the zeroth member

                        searchFtObject = regionData->FtObject->Set->Member0;

                        // Now search regions for this match

                        rd = LocateRegionForFtObject(searchFtObject);

                        if (!rd) {
                            continue;
                        }
                    }

                    if (GetVolumeLabel(rd->Disk, rd->PartitionNumber, &tempLabel) == NO_ERROR) {
                        lstrcpyW(volumeLabel, tempLabel);
                        Free(tempLabel);
                    } else {
                        *volumeLabel = 0;
                    }

                    if (GetTypeName(rd->Disk, rd->PartitionNumber, &tempName) == NO_ERROR) {
                        lstrcpyW(typeName, tempName);
                        Free(tempName);
                    } else {
                        lstrcpyW(typeName, wszUnknown);
                    }

                } else {

                    // Use Windows API.

                    diskName[0] = (WCHAR)(UCHAR)regionData->DriveLetter;

                    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
                    if (!GetVolumeInformationW(diskName, volumeLabel, sizeof(volumeLabel)/2, NULL, NULL, NULL, typeName, sizeof(typeName)/2)) {
                        lstrcpyW(typeName, wszUnknown);
                        *volumeLabel = 0;
                    }
                    SetErrorMode(errorMode);
                }

                if (!lstrcmpiW(typeName, L"raw")) {
                    lstrcpyW(typeName, wszUnknown);
                }

                regionData->TypeName    = Malloc((lstrlenW(typeName)    + 1) * sizeof(WCHAR));
                regionData->VolumeLabel = Malloc((lstrlenW(volumeLabel) + 1) * sizeof(WCHAR));

                lstrcpyW(regionData->TypeName, typeName);
                lstrcpyW(regionData->VolumeLabel, volumeLabel);
            }
        }
    }
}


VOID
DetermineRegionInfo(
    IN PREGION_DESCRIPTOR Region,
    OUT PWSTR *TypeName,
    OUT PWSTR *VolumeLabel,
    OUT PWCH   DriveLetter
    )

/*++

Routine Description:

    For a given region, fetch the persistent data, appropriately modified
    depending on whether the region is used or free, recognized, etc.

Arguments:

    Region - supplies a pointer to the region whose data is to be fetched.

    TypeName - receives a pointer to the type name.  If the region is
        unrecognized, the type is determined based on the system id of
        the partition.

    VolumeLabel - receives a pointer to the volume label.  If the region is
        free space or unrecognized, the volume label is "".

    DriveLetter - receices the drive letter.  If the region is free space
        or unrecognized, the drive letter is ' ' (space).

Return Value:

    None.

--*/

{
    PWSTR typeName,
          volumeLabel;
    WCHAR driveLetter;
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(Region);

    if (DmSignificantRegion(Region)) {

        typeName = regionData->TypeName;
        volumeLabel = regionData->VolumeLabel;
        driveLetter = (WCHAR)(UCHAR)regionData->DriveLetter;
        if ((driveLetter == NO_DRIVE_LETTER_YET) || (driveLetter == NO_DRIVE_LETTER_EVER)) {
            driveLetter = L' ';
        }
    } else {
        typeName = GetWideSysIDName(Region->SysID);
        volumeLabel = L"";
        driveLetter = L' ';
    }

    *TypeName = typeName;
    *VolumeLabel = volumeLabel;
    *DriveLetter = driveLetter;
}


PREGION_DESCRIPTOR
RegionFromFtObject(
    IN PFT_OBJECT FtObject
    )

/*++

Routine Description:

    Given an ft object, determine which region it belongs to.  The algorithm
    is brute force -- look at each region on each disk until a match is found.

Arguments:

    FtObject - ft member whose region is to be located.

Return Value:

    pointer to region descriptor

--*/

{
    PREGION_DESCRIPTOR reg;
    DWORD region,
          disk;
    PDISKSTATE ds;

    for (disk=0; disk<DiskCount; disk++) {

        ds = Disks[disk];

        for (region=0; region<ds->RegionCount; region++) {

            reg = &ds->RegionArray[region];

            if (DmSignificantRegion(reg) && (GET_FT_OBJECT(reg) == FtObject)) {

                return reg;
            }
        }
    }
    return NULL;
}


//
// For each drive letter, these arrays hold the disk and partition number
// the the drive letter is linked to.
//

#define M1  ((unsigned)(-1))

unsigned
DriveLetterDiskNumbers[26]      = { M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,
                                    M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1
                                  },

DriveLetterPartitionNumbers[24] = { M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,
                                    M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1,M1
                                  };

#undef M1

//
// Drive letter usage map.  Bit n set means that drive letter 'C'+n is in use.
//

ULONG DriveLetterUsageMap = 0;

#define     DRIVELETTERBIT(letter)  (1 << (unsigned)((UCHAR)letter-(UCHAR)'C'))

#define     SetDriveLetterUsed(letter)   DriveLetterUsageMap |= DRIVELETTERBIT(letter)
#define     SetDriveLetterFree(letter)   DriveLetterUsageMap &= (~DRIVELETTERBIT(letter))
#define     IsDriveLetterUsed(letter)    (DriveLetterUsageMap & DRIVELETTERBIT(letter))


CHAR
GetAvailableDriveLetter(
    VOID
    )

/*++

Routine Description:

    Scan the drive letter usage bitmap and return the next available
    drive letter.  May also mark the drivee letter used.

Arguments:

    None.

Return Value:

    The next available drive letter, or 0 if all are used.

--*/

{
    CHAR driveLetter;

    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
        if (!IsDriveLetterUsed(driveLetter)) {
            return driveLetter;
        }
    }
    return 0;
}


VOID
MarkDriveLetterUsed(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given an ASCII drive letter, mark it in the usage map as being used.

Arguments:

    DriveLetter - the letter to mark

Return Value:

    None

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    if ((DriveLetter != NO_DRIVE_LETTER_YET) && (DriveLetter != NO_DRIVE_LETTER_EVER)) {
        SetDriveLetterUsed(DriveLetter);
    }
}

VOID
MarkDriveLetterFree(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter, remove it from the usage map, thereby making it available
    for reuse.

Arguments:

    Drive Letter - the letter to free

Return Value:

    None

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    if ((DriveLetter != NO_DRIVE_LETTER_YET) && (DriveLetter != NO_DRIVE_LETTER_EVER)) {
        SetDriveLetterFree(DriveLetter);
    }
}

BOOL
DriveLetterIsAvailable(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Determine if the drive letter given is available for use.

Arguments:

    DriveLetter - the letter to check in the usage map

Return Value:

    TRUE if it is free and can be used.
    FALSE if it is currently in use.

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    FDASSERT((DriveLetter != NO_DRIVE_LETTER_YET) && (DriveLetter != NO_DRIVE_LETTER_EVER));
    return !IsDriveLetterUsed(DriveLetter);
}

BOOL
AllDriveLettersAreUsed(
    VOID
    )

/*++

Routine Description:

    Determine if all possible drive letters are in use.

Arguments:

    None

Return Value:

    TRUE if all letters are in use - FALSE otherwise

--*/

{
    FDASSERT(!(DriveLetterUsageMap & 0xff000000));
    return(DriveLetterUsageMap == 0x00ffffff);
}

ULONG
GetDiskNumberFromDriveLetter(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter return the disk number that contains the partition
    that is the drive letter.

Arguments:

    DriveLetter - the drive letter to check.

Return Value:

    -1 if the letter is invalid.
    The disk number for the drive letter if it is valid.

--*/

{
    DriveLetter = toupper( DriveLetter );

    if (DriveLetter >= 'C' && DriveLetter <= 'Z') {
        return DriveLetterDiskNumbers[ DriveLetter - 'C' ];
    } else {
        return (ULONG)(-1);
    }
}

ULONG
GetPartitionNumberFromDriveLetter(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter return the numeric value for the partition that
    the letter is associated with.

Arguments:

    DriveLetter - the letter in question.

Return Value:

    -1 if letter is invalid
    Partition number for partition that is the drive letter

--*/

{
    DriveLetter = toupper( DriveLetter );

    if (DriveLetter >= 'C' && DriveLetter <= 'Z') {
        return DriveLetterPartitionNumbers[ DriveLetter - 'C' ];
    } else {
        return (ULONG)(-1);
    }
}


CHAR
LocateDriveLetterFromDiskAndPartition(
    IN ULONG Disk,
    IN ULONG Partition
    )

/*++

Routine Description:

    Given a disk and partition number return the drive letter assigned to it.

Arguments:

    Disk - the disk index
    Partition - the partition index

Return Value:

    The drive letter for the specific partition or
    NO_DRIVE_LETTER_YET if it is not assigned a letter.

--*/

{
    unsigned i;

    for (i=0; i<24; i++) {

        if (Disk == DriveLetterDiskNumbers[i] &&
            Partition == DriveLetterPartitionNumbers[i]) {

            return((CHAR)(i+(unsigned)(UCHAR)'C'));
        }
    }
    return NO_DRIVE_LETTER_YET;
}

CHAR
LocateDriveLetter(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    Return the drive letter associated to a region.

Arguments:

    Region - the region wanted.

Return Value:

    The drive letter or NO_DRIVE_LETTER_YET

--*/

{
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(Region);

    if (regionData) {
        if (regionData->FtObject) {
            if (regionData->DriveLetter) {
                return regionData->DriveLetter;
            }
        }
    }

    return LocateDriveLetterFromDiskAndPartition(Region->Disk,
                                                 Region->OriginalPartitionNumber);
}


#define IsDigitW(digit)     (((digit) >= L'0') && ((digit) <= L'9'))

VOID
InitializeDriveLetterInfo(
    VOID
    )

/*++

Routine Description:

    Initialze all of the external support structures for drive letter maintainence.

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR DriveLetterW;
    CHAR  DriveLetter = '\0';
    PWSTR LinkTarget;
    WCHAR DosDevicesName[sizeof(L"\\DosDevices\\A:")];
    int   DiskNo,
          PartNo;
    PWSTR Pattern,
          String;
    DWORD x,
          ec;
    PFT_OBJECT         FtObject;
    PFT_OBJECT_SET     FtSet;
    PREGION_DESCRIPTOR Region;

    // Construct list of drives with pagefiles

    LoadExistingPageFileInfo();

    // Initialize network information.
    
    NetworkInitialize();

    // For each drive letter c-z, query the symbolic link.

    for (DriveLetterW=L'C'; DriveLetterW<=L'Z'; DriveLetterW++) {

        wsprintfW(DosDevicesName, L"%ws%wc:", L"\\DosDevices\\", DriveLetterW);

        if ((ec = GetDriveLetterLinkTarget(DosDevicesName, &LinkTarget)) == NO_ERROR) {

            // Check if it is a Cdrom

            if (_wcsnicmp(LinkTarget, L"\\Device\\CdRom", 13) == 0) {

                // Save the information on this CdRom away

                CdRomAddDevice(LinkTarget, DriveLetterW);
            }

            // The drive letter is used because it is linked to something,
            // even if we can't figure out what.  So mark it used here.

            SetDriveLetterUsed(DriveLetterW);
            CharUpperW(LinkTarget);
            Pattern = L"\\DEVICE\\HARDDISK";
            String = LinkTarget;

            // Attempt to match the '\device\harddisk' part

            for (x=0; x < (sizeof(L"\\DEVICE\\HARDDISK") / sizeof(WCHAR)) - 1; x++) {
                if (*Pattern++ != *String++) {
                    goto next_letter;
                }
            }

            // Now get the hard disk #

            if (!IsDigitW(*String)) {
                continue;
            }

            DiskNo = 0;
            while (IsDigitW(*String)) {
                DiskNo = (DiskNo * 10) + (*String - L'0');
                *String++;
            }

            // Attempt to match the '\partition' part

            Pattern = L"\\PARTITION";
            for (x=0; x < (sizeof(L"\\PARTITION") / sizeof(WCHAR)) - 1; x++) {
                if (*Pattern++ != *String++) {
                    goto next_letter;
                }
            }

            // Now get the partition #, which cannot be 0

            PartNo = 0;
            while (IsDigitW(*String)) {
                PartNo = (PartNo * 10) + (*String - L'0');
                *String++;
            }

            if (!PartNo) {
                continue;
            }

            // Make sure there is nothing left in the link target's name

            if (*String) {
                continue;
            }

            // We understand the link target. Store the disk and partition.

            DriveLetterDiskNumbers[DriveLetterW-L'C'] = DiskNo;
            DriveLetterPartitionNumbers[DriveLetterW-L'C'] = PartNo;
        } else {
            if (ec == ERROR_ACCESS_DENIED) {
                ErrorDialog(MSG_ACCESS_DENIED);

                // BUGBUG When system and workstation manager are the same
                // thing, then we'd never have gotten here.  We can't just
                // send a WM_DESTROY message to hwndFrame because we're not
                // in the message loop here -- we end up doing a bunch of
                // processing before the quit message is pulled our of the
                // queue.  So just exit.

                SendMessage(hwndFrame,WM_DESTROY,0,0);
                exit(1);
            }
        }
        next_letter:
        {}
    }

    // Now for each non-ft, significant region on each disk, figure out its
    // drive letter.

    for (x=0; x<DiskCount; x++) {

        PDISKSTATE ds = Disks[x];
        unsigned reg;

        for (reg=0; reg<ds->RegionCount; reg++) {

            PREGION_DESCRIPTOR region = &ds->RegionArray[reg];

            if (DmSignificantRegion(region)) {

                // Handle drive letters for FT sets specially.

                if (!GET_FT_OBJECT(region)) {
                    PERSISTENT_DATA(region)->DriveLetter = LocateDriveLetter(region);
                }
            }
        }

        // If this is a removable disk, record the reserved drive
        // letter for that disk.

        if (IsDiskRemovable[x]) {
            RemovableDiskReservedDriveLetters[x] = LocateDriveLetterFromDiskAndPartition(x, 1);
        } else {
            RemovableDiskReservedDriveLetters[x] = NO_DRIVE_LETTER_YET;
        }
    }

    // Now handle ft sets.  For each set, loop through the objects twice.
    // On the first pass, figure out which object actually is linked to the
    // drive letter.  On the second pass, assign the drive letter found to
    // each of the objects in the set.

    for (FtSet = FtObjects; FtSet; FtSet = FtSet->Next) {

        for (FtObject = FtSet->Members; FtObject; FtObject = FtObject->Next) {

            Region = RegionFromFtObject(FtObject);

            if (Region) {
                if ((DriveLetter = LocateDriveLetter(Region)) != NO_DRIVE_LETTER_YET) {
                    break;
                }
            }
        }

        for (FtObject = FtSet->Members; FtObject; FtObject = FtObject->Next) {

            Region = RegionFromFtObject(FtObject);

            if (Region) {
                PERSISTENT_DATA(Region)->DriveLetter = DriveLetter;
            }
        }
    }
}


#if DBG

VOID
FdiskAssertFailedRoutine(
    IN char *Expression,
    IN char *FileName,
    IN int   LineNumber
    )

/*++

Routine Description:

    Routine that is called when an assertion fails in the debug version.
    Throw up a list box giving appriopriate information and terminate
    the program.

Arguments:

    Source - source (ansi ascii) string
    Dest   - destination string or wide string

Return Value:

    None.

--*/

{
    char text[500];

    wsprintf(text,
             "Line #%u in File '%s'\n[%s]\n\nClick OK to exit.",
             LineNumber,
             FileName,
             Expression
            );

    MessageBoxA(NULL,text,"Assertion Failure",MB_TASKMODAL | MB_OK);
    exit(1);
}


#include <stdio.h>

PVOID LogFile;
int LoggingLevel = 1000;


VOID
InitLogging(
    VOID
    )

/*++

Routine Description:

    Open the log file for debug logging.

Arguments:

    None

Return Value:

    None

--*/

{
    LogFile = (PVOID)fopen("c:\\fdisk.log","wt");
    if(LogFile == NULL) {
        MessageBox(GetActiveWindow(),"Can't open log file; logging turned off","DEBUG",MB_SYSTEMMODAL|MB_OK);
        LoggingLevel = -1;
    }
}


VOID
FdLog(
    IN int   Level,
    IN PCHAR FormatString,
    ...
    )

/*++

Routine Description:

    Write a line into the log file for debugging.

Arguments:

    Debug level and "printf" like argument string.

Return Value:

    None

--*/

{
    va_list arglist;

    if(Level <= LoggingLevel) {

        va_start(arglist,FormatString);

        if(vfprintf((FILE *)LogFile,FormatString,arglist) < 0) {
            LoggingLevel = -1;
            MessageBox(GetActiveWindow(),"Error writing to log file; logging turned off","DEBUG",MB_SYSTEMMODAL|MB_OK);
            fclose((FILE *)LogFile);
        } else {
            fflush((FILE *)LogFile);
        }

        va_end(arglist);
    }
}


VOID
LOG_DISK_REGISTRY(
    IN PCHAR          RoutineName,
    IN PDISK_REGISTRY DiskRegistry
    )

/*++

Routine Description:

    Log what was in the disk registry into the debugging log file.

Arguments:

    RoutineName - calling routines name
    DiskRegistry - registry information for disks

Return Value:

    None

--*/

{
    ULONG i;
    PDISK_DESCRIPTION diskDesc;

    FDLOG((2,"%s: %u disks; registry info follows:\n",RoutineName,DiskRegistry->NumberOfDisks));

    diskDesc = DiskRegistry->Disks;

    for(i=0; i<DiskRegistry->NumberOfDisks; i++) {
        LOG_ONE_DISK_REGISTRY_DISK_ENTRY(NULL,diskDesc);
        diskDesc = (PDISK_DESCRIPTION)&diskDesc->Partitions[diskDesc->NumberOfPartitions];
    }
}


VOID
LOG_ONE_DISK_REGISTRY_DISK_ENTRY(
    IN PCHAR             RoutineName     OPTIONAL,
    IN PDISK_DESCRIPTION DiskDescription
    )

/*++

Routine Description:

    This routine walks through the partition information from
    the registry for a single disk and writes lines in the
    debugging log file.

Arguments:

    RoutineName - the name of the calling routine
    DiskDescription - the disk description portion of the registry

Return Value:

    None

--*/

{
    USHORT j;
    PDISK_PARTITION partDesc;
    PDISK_DESCRIPTION diskDesc = DiskDescription;

    if(ARGUMENT_PRESENT(RoutineName)) {
        FDLOG((2,"%s: disk registry entry follows:\n",RoutineName));
    }

    FDLOG((2,"    Disk signature : %08lx\n",diskDesc->Signature));
    FDLOG((2,"    Partition count: %u\n",diskDesc->NumberOfPartitions));
    if(diskDesc->NumberOfPartitions) {
        FDLOG((2,"    #   Dr  FtTyp  FtGrp  FtMem  Start              Length\n"));
    }

    for(j=0; j<diskDesc->NumberOfPartitions; j++) {

        CHAR dr1,dr2;

        partDesc = &diskDesc->Partitions[j];

        if(partDesc->AssignDriveLetter) {

            if(partDesc->DriveLetter) {
                dr1 = partDesc->DriveLetter;
                dr2 = ':';
            } else {
                dr1 = dr2 = ' ';
            }

        } else {
            dr1 = 'n';
            dr2 = 'o';
        }

        FDLOG((2,
               "    %02u  %c%c  %-5u  %-5u  %-5u  %08lx:%08lx  %08lx:%08lx\n",
               partDesc->LogicalNumber,
               dr1,dr2,
               partDesc->FtType,
               partDesc->FtGroup,
               partDesc->FtMember,
               partDesc->StartingOffset.HighPart,
               partDesc->StartingOffset.LowPart,
               partDesc->Length.HighPart,
               partDesc->Length.LowPart
             ));
    }
}


VOID
LOG_DRIVE_LAYOUT(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    Write the drive layout into the debugging log file.

Arguments:

    DriveLayout - the layout to write

Return Value:

    None

--*/

{
    ULONG i;

    FDLOG((2,"   Disk signature : %08lx\n",DriveLayout->Signature));
    FDLOG((2,"   Partition count: %u\n",DriveLayout->PartitionCount));

    for(i=0; i<DriveLayout->PartitionCount; i++) {

        if(!i) {
            FDLOG((2,"    ID  Active  Recog  Start              Size               Hidden\n"));
        }

        FDLOG((2,
               "    %02x  %s     %s    %08lx:%08lx  %08lx:%08lx  %08lx\n",
               DriveLayout->PartitionEntry[i].PartitionType,
               DriveLayout->PartitionEntry[i].BootIndicator ? "yes" : "no ",
               DriveLayout->PartitionEntry[i].RecognizedPartition ? "yes" : "no ",
               DriveLayout->PartitionEntry[i].StartingOffset.HighPart,
               DriveLayout->PartitionEntry[i].StartingOffset.LowPart,
               DriveLayout->PartitionEntry[i].PartitionLength.HighPart,
               DriveLayout->PartitionEntry[i].PartitionLength.LowPart,
               DriveLayout->PartitionEntry[i].HiddenSectors
             ));
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdres.h ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fdres.h

Abstract:

    Central include file for Disk Administrator

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) added doublespace and commit support.

--*/

// If double space is included this define should turn it on in the sources
//#define DOUBLE_SPACE_SUPPORT_INCLUDED 1

#define     IDFDISK                 1

#define     IDB_SMALLDISK           100
#define     IDB_REMOVABLE           101


// dialogs

#define     IDD_ABOUT               200
#define     IDD_MINMAX              201
#define     IDD_COLORS              202
#define     IDD_DRIVELET            203
#define     IDD_DISPLAYOPTIONS      204
#define     IDD_DBLSPACE_CREATE     205
#define     IDD_DBLSPACE_DELETE     206
#define     IDD_DBLSPACE_MOUNT      207
#define     IDD_DBLSPACE_DISMOUNT   208
#define     IDD_DBLSPACE            209
#define     IDD_PARTITIONFORMAT     210
#define     IDD_PARTITIONLABEL      211
#define     IDD_DBLSPACE_DRIVELET   212
#define     IDD_FORMATCANCEL        213
#define     IDD_DBLSPACE_CANCEL     214
#define     IDD_DBLSPACE_FULL       215
#define     IDD_CDROM               216
#define     IDD_INITIALIZING        217

// menu IDs

#define     IDM_PARTITIONCREATE     1000
#define     IDM_PARTITIONCREATEEX   1001
#define     IDM_PARTITIONDELETE     1002
#if i386
#define     IDM_PARTITIONACTIVE     1003
#endif
#define     IDM_PARTITIONLETTER     1004
#define     IDM_PARTITIONEXIT       1005
#define     IDM_SECURESYSTEM        1006
#define     IDM_PARTITIONFORMAT     1007
#define     IDM_PARTITIONLABEL      1008

#define     IDM_CONFIGMIGRATE       2000
#define     IDM_CONFIGSAVE          2001
#define     IDM_CONFIGRESTORE       2002

#define     IDM_FTESTABLISHMIRROR   3000
#define     IDM_FTBREAKMIRROR       3001
#define     IDM_FTCREATESTRIPE      3002
#define     IDM_FTCREATEVOLUMESET   3004
#define     IDM_FTRECOVERSTRIPE     3006
#define     IDM_FTCREATEPSTRIPE     3007
#define     IDM_FTEXTENDVOLUMESET   3009

#define     IDM_DBLSPACE            3100
#define     IDM_AUTOMOUNT           3101
#define     IDM_CDROM               3102

#define     IDM_OPTIONSSTATUS       4000
#define     IDM_OPTIONSLEGEND       4001
#define     IDM_OPTIONSCOLORS       4002
#define     IDM_OPTIONSDISPLAY      4003

#define     IDM_COMMIT              4100

#define     IDM_HELPCONTENTS        5000
#define     IDM_HELPSEARCH          5001
#define     IDM_HELPHELP            5002
#define     IDM_HELPABOUT           5003

#if DBG && DEVL
#define     IDM_DEBUGALLOWDELETES   10001
#endif

// accelerator keys

#define     IDM_HELP                6000

//controls

#define     IDC_MINMAX_MINLABEL     100
#define     IDC_MINMAX_MAXLABEL     101
#define     IDC_MINMAX_SIZLABEL     102
#define     IDC_MINMAX_MIN          103
#define     IDC_MINMAX_MAX          104
#define     IDC_MINMAX_SIZE         105
#define     IDC_MINMAX_SCROLL       106
#define     IDC_DBLSPACE_LETTER     107
#define     IDC_DBLSPACE_LETTER_INDICATOR 108
#define     IDC_DBLSPACE_ALLOCATED  100
#define     IDC_DBLSPACE_COMPRESSED 110
#define     IDC_DBLSPACE_SIZE       111
#define     IDC_DBLSPACE_VOLUME     112
#define     IDC_DBLSPACE_RATIO      113
#define     IDC_MOUNT_STATE         114

#define     IDC_TEXT                200
#define     IDC_NAME                201
#define     IDC_VERIFY              202
#define     IDC_FSTYPE              203
#define     IDC_PROGRESS            204
#define     IDC_GASGAUGE            205
#define     IDC_HIDE                206

#define     IDC_COLOR1              501
#define     IDC_COLOR2              502
#define     IDC_COLOR3              503
#define     IDC_COLOR4              504
#define     IDC_COLOR5              505
#define     IDC_COLOR6              506
#define     IDC_COLOR7              507
#define     IDC_COLOR8              508
#define     IDC_COLOR9              509
#define     IDC_COLOR10             510
#define     IDC_COLOR11             511
#define     IDC_COLOR12             512
#define     IDC_COLOR13             513
#define     IDC_COLOR14             514
#define     IDC_COLOR15             515
#define     IDC_COLOR16             516

#define     IDC_PATTERN1            601
#define     IDC_PATTERN2            602
#define     IDC_PATTERN3            603
#define     IDC_PATTERN4            604
#define     IDC_PATTERN5            605

#define     IDC_COLORDLGCOMBO       100

#define     IDC_DRIVELET_RBASSIGN   700
#define     IDC_DRIVELET_RBNOASSIGN 701
#define     IDC_DRIVELET_DESCR      702
#define     IDC_DRIVELET_COMBOBOX   703
#define     IDC_CDROM_NAMES         704

#define     IDC_DISK_COMBOBOX       100
#define     IDC_RESETALL            101
#define     IDC_RBPROPORTIONAL      200
#define     IDC_RBEQUAL             201
#define     IDC_RBAUTO              202


// buttons

#define     FD_IDHELP               22
#define     IDADD                   23
#define     IDDELETE                24
#define     ID_MOUNT_OR_DISMOUNT    25

// strings

#define     IDS_APPNAME             1
#define     IDS_MULTIPLEITEMS       2
#define     IDS_FREESPACE           3
#define     IDS_PARTITION           4
#define     IDS_LOGICALVOLUME       5
#define     IDS_DISKN               6
#define     IDS_CONFIRM             7
#define     IDS_NOT_IN_APP_MSG_FILE 8
#define     IDS_NOT_IN_SYS_MSG_FILE 9
#define     IDS_UNFORMATTED         10
#define     IDS_UNKNOWN             11
#define     IDS_STRIPESET           12
#define     IDS_VOLUMESET           13
#define     IDS_EXTENDEDPARTITION   14
#define     IDS_FREEEXT             15
#define     IDS_DRIVELET_DESCR      16
#define     IDS_HEALTHY             17
#define     IDS_BROKEN              18
#define     IDS_RECOVERABLE         19
#define     IDS_REGENERATED         20
#define     IDS_NEW                 21
#define     IDS_OFFLINE             22
#define     IDS_INSERT_DISK         23
#define     IDS_MEGABYTES_ABBREV    24
#define     IDS_INITIALIZING        25
#define     IDS_REGENERATING        26
#define     IDS_NO_CONFIG_INFO      27
#define     IDS_NEW_UNFORMATTED     28
#define     IDS_DISABLED            29
#define     IDS_INIT_FAILED         70

#define     IDS_CRTPART_CAPTION_P   30
#define     IDS_CRTPART_CAPTION_E   31
#define     IDS_CRTPART_CAPTION_L   32
#define     IDS_CRTPART_MIN_P       33
#define     IDS_CRTPART_MAX_P       34
#define     IDS_CRTPART_MIN_L       35
#define     IDS_CRTPART_MAX_L       36
#define     IDS_CRTPART_SIZE_P      37
#define     IDS_CRTPART_SIZE_L      38

#define     IDS_CRTSTRP_CAPTION     39
#define     IDS_CRTSTRP_MIN         40
#define     IDS_CRTSTRP_MAX         41
#define     IDS_CRTSTRP_SIZE        42

#define     IDS_CRTVSET_CAPTION     43
#define     IDS_EXPVSET_CAPTION     44
#define     IDS_CRTVSET_MIN         45
#define     IDS_CRTVSET_MAX         46
#define     IDS_CRTVSET_SIZE        47

#define     IDS_STATUS_STRIPESET    48
#define     IDS_STATUS_PARITY       49
#define     IDS_STATUS_VOLUMESET    50
#define     IDS_STATUS_MIRROR       51

#define     IDS_CRTPSTRP_CAPTION    52

#define     IDS_DLGCAP_PARITY       53
#define     IDS_DLGCAP_MIRROR       54

// these must be contigous, and kept in sync with BRUSH_xxx constants

#define     IDS_LEGEND_PRIMARY      100
#define     IDS_LEGEND_LOGICAL      101
#define     IDS_LEGEND_STRIPESET    102
#define     IDS_LEGEND_MIRROR       103
#define     IDS_LEGEND_VOLUMESET    104
#define     IDS_LEGEND_LAST         IDS_LEGEND_VOLUMESET
#define     IDS_LEGEND_FIRST        IDS_LEGEND_PRIMARY


// These are the strings for system-names other than those which are
// meaningful to NT.

#define     IDS_PARTITION_FREE      120
#define     IDS_PARTITION_XENIX1    121
#define     IDS_PARTITION_XENIX2    122
#define     IDS_PARTITION_OS2_BOOT  123
#define     IDS_PARTITION_EISA      124
#define     IDS_PARTITION_UNIX      125
#define     IDS_PARTITION_POWERPC   126


// Double space support strings

#define     IDS_DBLSPACE_DELETE     150
#define     IDS_WITH_DBLSPACE       151
#define     IDS_DBLSPACE_MOUNTED    152
#define     IDS_DBLSPACE_DISMOUNTED 153
#define     IDS_MOUNT               154
#define     IDS_DISMOUNT            155
#define     IDS_CREATING_DBLSPACE   156
#define     IDS_DBLSPACECOMPLETE    157

// format strings.

#define     IDS_QUICK_FORMAT        170
#define     IDS_PERCENTCOMPLETE     171
#define     IDS_FORMATSTATS         172
#define     IDS_FORMATCOMPLETE      173
#define     IDS_FORMAT_TITLE        174
#define     IDS_LABEL_TITLE         175

// Registry paths.

#define     IDS_SOURCE_PATH         180
#define     IDS_SOURCE_PATH_NAME    181

#if i386
#define     IDS_ACTIVEPARTITION     200
#endif


// name of rectangle custom control class

#define RECTCONTROL "RectControl"

// rectangle control styles

#define RS_PATTERN                  0x00000001
#define RS_COLOR                    0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdmem.c ===
#include "fdisk.h"
#include <malloc.h>
#include <process.h>



PVOID
Malloc(
    IN ULONG Size
    )
{
    PVOID p;

    while((p = malloc(Size)) == NULL) {
        ConfirmOutOfMemory();
    }
    return(p);
}


PVOID
Realloc(
    IN PVOID Block,
    IN ULONG NewSize
    )
{
    PVOID p;

    if(NewSize) {
        while((p = realloc(Block,NewSize)) == NULL) {
            ConfirmOutOfMemory();
        }
    } else {

        //
        // realloc with a size of 0 is the same as free,
        // so special case that here.
        //

        free(Block);
        while((p = malloc(0)) == NULL) {
            ConfirmOutOfMemory();
        }
    }
    return(p);
}


VOID
Free(
    IN PVOID Block
    )
{
    free(Block);
}



VOID
ConfirmOutOfMemory(
    VOID
    )
{
    va_list arglist =
#ifdef _ALPHA_
    {0};      // Alpha defines va_list as a struct.  Init as such.
#else
    NULL;
#endif

    if(CommonDialog(MSG_OUT_OF_MEMORY,
                    NULL,
                    MB_ICONHAND | MB_RETRYCANCEL | MB_SYSTEMMODAL,
                    arglist) != IDRETRY) {
        exit(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdtypes.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    fdtypes.h

Abstract:

    Support types definitions for Disk Administrator

Author:

    Ted Miller (tedm) 7-Jan-1992

Revisions:

    11-Nov-93 (bobri) double space and commit support.
    2-Feb-94  (bobri) moved ArcInst data items into this file.

--*/

// Partition data items

typedef enum { REGION_PRIMARY,
               REGION_EXTENDED,
               REGION_LOGICAL
             } REGION_TYPE;

enum {
        SYSID_UNUSED     = 0,
        SYSID_EXTENDED   = 5,
        SYSID_BIGFAT     = 6,
        SYSID_IFS        = 7
     };

//    These structures are used in doubly-linked per disk lists that
//    describe the layout of the disk.
//
//    Free spaces are indicated by entries with a SysID of 0 (note that
//    these entries don't actually appear anywhere on-disk!)
//
//    The partition number is the number the system will assign to
//    the partition in naming it.  For free spaces, this is the number
//    that the system WOULD assign to it if it was a partition.
//    The number is good only for one transaction (create or delete),
//    after which partitions must be renumbered.

struct _PERSISTENT_REGION_DATA;
typedef struct _PARTITION {
    struct _PARTITION  *Next;
    struct _PARTITION  *Prev;
    struct _PERSISTENT_REGION_DATA *PersistentData;
    LARGE_INTEGER          Offset;
    LARGE_INTEGER          Length;
    ULONG                  Disk;
    ULONG                  OriginalPartitionNumber;
    ULONG                  PartitionNumber;
    BOOLEAN                Update;
    BOOLEAN                Active;
    BOOLEAN                Recognized;
    UCHAR                  SysID;
    BOOLEAN                CommitMirrorBreakNeeded;
} PARTITION,*PPARTITION;

typedef struct _REGION_DATA {
    PPARTITION      Partition;
    LARGE_INTEGER   AlignedRegionOffset;
    LARGE_INTEGER   AlignedRegionSize;
} REGION_DATA,*PREGION_DATA;

// structure that describes an ft object (mirror, stripe component, etc).

struct _FT_OBJECT_SET;
typedef struct _FT_OBJECT {
    struct _FT_OBJECT     *Next;
    struct _FT_OBJECT_SET *Set;
    ULONG                  MemberIndex;
    FT_PARTITION_STATE     State;
} FT_OBJECT, *PFT_OBJECT;

// DoubleSpace support structure.  This is tagged off of the persistent data for
// each region.

typedef struct _DBLSPACE_DESCRIPTOR {
    struct _DBLSPACE_DESCRIPTOR *Next;
    struct _DBLSPACE_DESCRIPTOR *DblChainNext;
    ULONG   AllocatedSize;
    PCHAR   FileName;
    UCHAR   DriveLetter;
    CHAR    DriveLetterEOS;
    BOOLEAN Mounted;
    BOOLEAN ChangeMountState;
    UCHAR   NewDriveLetter;
    CHAR    NewDriveLetterEOS;
    BOOLEAN ChangeDriveLetter;
} DBLSPACE_DESCRIPTOR, *PDBLSPACE_DESCRIPTOR;

// Define the structure that is associated with each non-extended, recognized
// partition.  This structure is associated with the partition, and persists
// across region array free/get from the back end.  It is used for logical
// and ft information.

typedef struct _PERSISTENT_REGION_DATA {
    PFT_OBJECT           FtObject;
    PDBLSPACE_DESCRIPTOR DblSpace;
    PWSTR                VolumeLabel;
    PWSTR                TypeName;
    CHAR                 DriveLetter;
    BOOLEAN              VolumeExists;
} PERSISTENT_REGION_DATA, *PPERSISTENT_REGION_DATA;

typedef struct _REGION_DESCRIPTOR {
    PPERSISTENT_REGION_DATA PersistentData;
    PREGION_DATA    Reserved;
    ULONG           Disk;
    ULONG           PartitionNumber;
    ULONG           OriginalPartitionNumber;
    ULONG           SizeMB;
    REGION_TYPE     RegionType;
    BOOLEAN         Active;
    BOOLEAN         Recognized;
    UCHAR           SysID;
} REGION_DESCRIPTOR,*PREGION_DESCRIPTOR;

// params for the MinMax dialog -- used at WM_INITDIALOG time

typedef struct _MINMAXDLG_PARAMS {
    DWORD CaptionStringID;
    DWORD MinimumStringID;
    DWORD MaximumStringID;
    DWORD SizeStringID;
    DWORD MinSizeMB;
    DWORD MaxSizeMB;
    DWORD HelpContextId;
} MINMAXDLG_PARAMS,*PMINMAXDLG_PARAMS;

typedef struct _FORMAT_PARAMS {
    PREGION_DESCRIPTOR RegionDescriptor;
    PVOID   RegionData;
    BOOL    QuickFormat;
    BOOL    Cancel;
    BOOL    DoubleSpace;
    UCHAR   NewLetter;
    PUCHAR  Label;
    PUCHAR  FileSystem;
    PWSTR   DblspaceFileName;
    HWND    DialogHwnd;
    DWORD   Result;
    ULONG   TotalSpace;
    ULONG   SpaceAvailable;
    ULONG   ThreadIsDone;
} FORMAT_PARAMS, *PFORMAT_PARAMS;

typedef struct _LABEL_PARAMS {
    PREGION_DESCRIPTOR RegionDescriptor;
    LPTSTR             NewLabel;
} LABEL_PARAMS, *PLABEL_PARAMS;

typedef struct _LEFTRIGHT {
    LONG Left;
    LONG Right;
} LEFTRIGHT, *PLEFTRIGHT;


//
// Types of views that can be used for a disk bar.
// Proportional means that the amount of space taken up in the bar is
// directly proportional to the size of the partition or free space
// Equal means that all free spaces and partitions are sized equally on
// screen regardless of their actual size

typedef enum _BAR_TYPE {
    BarProportional,
    BarEqual,
    BarAuto
} BAR_TYPE, *PBAR_TYPE;

// One of these structures is associated with each item in the
// listbox.  The structure is the crux of the implementation.

typedef struct _DISKSTATE {
    DWORD               Disk;           // number of disk
    DWORD               DiskSizeMB;     // size in MB of disk
    PREGION_DESCRIPTOR  RegionArray;    // region array for disk
    DWORD               RegionCount;    // # items in region array
    PBOOLEAN            Selected;       // whether each region is selected
    PLEFTRIGHT          LeftRight;      // left/right coords of boxes in graph
    DWORD               BoxCount;       // # boxes in this disk's graph
    BOOLEAN             CreateAny;      // any creations allowed on disk
    BOOLEAN             CreatePrimary;  // allowed to create primary partition
    BOOLEAN             CreateExtended; // allowed to create extended partition
    BOOLEAN             CreateLogical;  // allowed to create logical volume
    BOOLEAN             ExistAny;       // any partitions/logicals exist
    BOOLEAN             ExistPrimary;   // primary partition(s) exist
    BOOLEAN             ExistExtended;  // extended partition exists
    BOOLEAN             ExistLogical;   // logical volume(s) exist
    HDC                 hDCMem;         // for off-screen drawing
    HBITMAP             hbmMem;         // for offscreen bitmap
    ULONG               Signature;      // unique disk registry index
    BAR_TYPE            BarType;        // how to display the disk's bar
    BOOLEAN             SigWasCreated;  // whether we had to make up a sig
    BOOLEAN             OffLine;        // FALSE if disk is accessible.
} DISKSTATE, *PDISKSTATE;

// Enum for the states in which an ft set can be.

typedef enum _FT_SET_STATUS {
    FtSetHealthy,
    FtSetBroken,
    FtSetRecoverable,
    FtSetRecovered,
    FtSetNew,
    FtSetNewNeedsInitialization,
    FtSetExtended,
    FtSetInitializing,
    FtSetRegenerating,
    FtSetInitializationFailed,
    FtSetDisabled
} FT_SET_STATUS, *PFT_SET_STATUS;

// structure that describes an ft object set (ie, mirrored pair, stripe set).

typedef struct _FT_OBJECT_SET {
    struct _FT_OBJECT_SET *Next;
    FT_TYPE                Type;
    ULONG                  Ordinal;
    PFT_OBJECT             Members;
    PFT_OBJECT             Member0;
    FT_SET_STATUS          Status;
    ULONG                  NumberOfMembers;
} FT_OBJECT_SET, *PFT_OBJECT_SET;

typedef struct _DBLSPACE_PARAMS {
    DWORD                   CaptionStringID;
    PVOID                   RegionDescriptor;
    PPERSISTENT_REGION_DATA RegionData;
    PDBLSPACE_DESCRIPTOR    DblSpace;
} DBLSPACE_PARAMS, *PDBLSPACE_PARAMS;

// CdRom support structures.

typedef struct _CDROM_DESCRIPTOR {
    struct _CDROM_DESCRIPTOR *Next;
    PWSTR   DeviceName;
    ULONG   DeviceNumber;
    WCHAR   DriveLetter;
    WCHAR   NewDriveLetter;
} CDROM_DESCRIPTOR, *PCDROM_DESCRIPTOR;

// Commit support structures

typedef struct _DRIVE_LOCKLIST {
    struct _DRIVE_LOCKLIST *Next;
    HANDLE                  LockHandle;
    ULONG                   DiskNumber;
    ULONG                   PartitionNumber;
    ULONG                   LockOnDiskNumber;
    ULONG                   UnlockOnDiskNumber;
    UCHAR                   DriveLetter;
    BOOLEAN                 RemoveOnUnlock;
    BOOLEAN                 FailOk;
    BOOLEAN                 CurrentlyLocked;
} DRIVE_LOCKLIST, *PDRIVE_LOCKLIST;

// Commit support enum for drive letter assignment

typedef enum _LETTER_ASSIGNMENT_RESULT {
    Failure = 0,
    Complete,
    MustReboot
} LETTER_ASSIGNMENT_RESULT;

// Items below used to be in fdenginp.h -- have been moved here to
// remove dependency on ArcInst project.

#define LOWPART(x)      ((x).LowPart)

#define ONE_MEG         (1024*1024)

ULONG
SIZEMB(
    IN LARGE_INTEGER ByteCount
    );

#define ENTRIES_PER_BOOTSECTOR          4

//  This structure is used to hold the information returned by the
//  get drive geometry call.

typedef struct _DISKGEOM {
    LARGE_INTEGER   Cylinders;
    ULONG           Heads;
    ULONG           SectorsPerTrack;
    ULONG           BytesPerSector;
    // These two are not part of drive geometry info, but calculated from it.
    ULONG           BytesPerCylinder;
    ULONG           BytesPerTrack;
} DISKGEOM,*PDISKGEOM;



#if DBG

#include <process.h>
char _ASRTFAILEDSTR_[256];
#define ASRT(x)   if(!(x)) { sprintf( _ASRTFAILEDSTR_,                                      \
                                      "file %s\nline %u",                                   \
                                      __FILE__,__LINE__                                     \
                                    );                                                      \
                             MessageBoxA(NULL,_ASRTFAILEDSTR_,"Assertion Failure",0);       \
                             exit(1);                                                       \
                           }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fdstleg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fdstleg.c

Abstract:

    Routines to support the status bar and legend displays.

Author:

    Ted Miller (tedm) 7-Jan-1992

--*/


#include "fdisk.h"


HFONT hFontStatus,hFontLegend;

DWORD dyLegend,wLegendItem;
DWORD dyStatus,dyBorder;


// text for status area

TCHAR   StatusTextStat[STATUS_TEXT_SIZE];
TCHAR   StatusTextSize[STATUS_TEXT_SIZE];

WCHAR   StatusTextDrlt[3];

WCHAR   StatusTextType[STATUS_TEXT_SIZE];
WCHAR   StatusTextVoll[STATUS_TEXT_SIZE];

TCHAR  *LegendLabels[LEGEND_STRING_COUNT];


// whether status bar and legend are currently shown

BOOL    StatusBar = TRUE,
        Legend    = TRUE;



VOID
UpdateStatusBarDisplay(
    VOID
    )
{
    RECT rc;

    if(StatusBar) {
        GetClientRect(hwndFrame,&rc);
        rc.top = rc.bottom - dyStatus;
        InvalidateRect(hwndFrame,&rc,FALSE);
    }
}


VOID
ClearStatusArea(
    VOID
    )
{
    StatusTextStat[0] = StatusTextSize[0] = 0;
    StatusTextVoll[0] = StatusTextType[0] = 0;
    StatusTextDrlt[0] = 0;
    UpdateStatusBarDisplay();
}


VOID
DrawLegend(
    IN HDC   hdc,
    IN PRECT rc
    )

/*++

Routine Description:

    This routine draws the legend onto the given device context.  The legend
    lists the brush styles used to indicate various region types in the
    disk graphs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD  i,
           left,
           delta = GraphWidth / BRUSH_ARRAY_SIZE;
    HBRUSH hBrush;
    RECT   rc1,rc2;
    HFONT  hfontOld;
    SIZE   size;
    DWORD  dx;
    COLORREF OldTextColor,OldBkColor;

    rc1 = *rc;
    rc2 = *rc;

    // first draw the background.

    hBrush  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    rc1.right = rc1.left + GetSystemMetrics(SM_CXSCREEN);   // erase it all
    FillRect(hdc,&rc1,hBrush);
    DeleteObject(hBrush);

    // now draw the nice container

    rc2.left  += 8 * dyBorder;
    rc2.right -= 8 * dyBorder;
    DrawStatusAreaItem(&rc2,hdc,NULL,FALSE);

    // now draw the legend items

    SelectObject(hdc,hPenThinSolid);

    left = rc2.left + (wLegendItem / 2);
    SetBkColor(hdc,GetSysColor(COLOR_BTNFACE));
    hfontOld = SelectObject(hdc,hFontLegend);

    OldTextColor = SetTextColor(hdc,GetSysColor(COLOR_BTNTEXT));
    SetBkMode(hdc,OPAQUE);

    for(i=0; i<BRUSH_ARRAY_SIZE; i++) {

        hBrush = SelectObject(hdc,Brushes[i]);

        OldBkColor = SetBkColor(hdc,RGB(255,255,255));

        Rectangle(hdc,
                  left,
                  rc->top + (wLegendItem / 2),
                  left + wLegendItem,
                  rc->top + (3 * wLegendItem / 2)
                 );

        SetBkColor(hdc,OldBkColor);

        // BUGBUG unicode lstrlen?
        GetTextExtentPoint(hdc,LegendLabels[i],lstrlen(LegendLabels[i]),&size);
        dx = (DWORD)size.cx;
        TextOut(hdc,
                left + (3*wLegendItem/2),
                rc->top + (wLegendItem / 2) + ((wLegendItem-size.cy)/2),
                LegendLabels[i],
                lstrlen(LegendLabels[i])
               );
#if 0
        SelectObject(hdc,Brushes[++i]);

        OldBkColor = SetBkColor(hdc,RGB(255,255,255));

        Rectangle(hdc,
                  left,
                  rc->top + (2 * wLegendItem),
                  left + wLegendItem,
                  rc->top + (3 * wLegendItem)
                 );

        SetBkColor(hdc,OldBkColor);

        GetTextExtentPoint(hdc,LegendLabels[i],lstrlen(LegendLabels[i]),&size);
        TextOut(hdc,
                left + (3*wLegendItem/2),
                rc->top + (2 * wLegendItem) + ((wLegendItem-size.cy)/2),
                LegendLabels[i],
                lstrlen(LegendLabels[i])
               );

        if((DWORD)size.cx > dx) {
            dx = (DWORD)size.cx;
        }
#endif
        left += dx + (5*wLegendItem/2);

        if(hBrush) {
            SelectObject(hdc,hBrush);
        }
    }
    if(hfontOld) {
        SelectObject(hdc,hfontOld);
    }
    SetTextColor(hdc,OldTextColor);
}



VOID
DrawStatusAreaItem(
    IN PRECT  rc,
    IN HDC    hdc,
    IN LPTSTR Text,
    IN BOOL   Unicode
    )

/*++

Routine Description:

    This routine draws a status area item into a given dc.  This
    includes drawing the nice shaded button-like container, and
    then drawing text within it.

Arguments:

    rc      - rectangle describing the status area item

    hdc     - device context into which to draw

    Text    - optional parameter that if present represents text to
              be placed in the item.

    Unicode - if TRUE, Text points to a wide character string regardless
              of the type of LPTSTR

Return Value:

    None.

--*/

{
    HBRUSH hBrush;
    RECT   rcx;


    // the shadow

    if(hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW))) {

        // left edge

        rcx.left    = rc->left;
        rcx.right   = rc->left   + dyBorder;
        rcx.top     = rc->top    + (2*dyBorder);
        rcx.bottom  = rc->bottom - (2*dyBorder);
        FillRect(hdc,&rcx,hBrush);

        // top edge

        rcx.right    = rc->right;
        rcx.bottom   = rcx.top + dyBorder;
        FillRect(hdc,&rcx,hBrush);

        DeleteObject(hBrush);
    }

    // the highlight

    if(hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT))) {

        // right edge

        rcx.left    = rc->right - dyBorder;
        rcx.right   = rc->right;
        rcx.top     = rc->top    + (2*dyBorder);
        rcx.bottom  = rc->bottom - (2*dyBorder);
        FillRect(hdc,&rcx,hBrush);

        // top edge

        rcx.left    = rc->left;
        rcx.right   = rc->right;
        rcx.top     = rc->bottom - (3*dyBorder);
        rcx.bottom  = rcx.top + dyBorder;
        FillRect(hdc,&rcx,hBrush);

        DeleteObject(hBrush);
    }

    if(Text) {

        // draw the text

        SetTextColor(hdc,GetSysColor(COLOR_BTNTEXT));
        SetBkColor(hdc,GetSysColor(COLOR_BTNFACE));

        rcx.top    = rc->top    + (3*dyBorder);
        rcx.bottom = rc->bottom - (3*dyBorder);
        rcx.left   = rc->left   + dyBorder;
        rcx.right  = rc->right  - dyBorder;

        if(Unicode && (sizeof(TCHAR) != sizeof(WCHAR))) {

            ExtTextOutW(hdc,
                        rcx.left+(2*dyBorder),
                        rcx.top,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rcx,
                        (PWSTR)Text,
                        lstrlenW((PWSTR)Text),
                        NULL
                       );

        } else {
            ExtTextOut(hdc,
                       rcx.left+(2*dyBorder),
                       rcx.top,
                       ETO_OPAQUE | ETO_CLIPPED,
                       &rcx,
                       Text,
                       lstrlen(Text),
                       NULL
                      );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\ftregres.h ===
#define IDC_LISTBOX                 101
#define IDD_SELDIR                  100
#define IDC_SIMPLE_TEXT_LINE        201
#define IDD_SIMPLETEXT              300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\makefile.inc ===
fdiskmsg.h fdiskmsg.rc msg00001.bin: fdiskmsg.mc
    mc -v fdiskmsg.mc

$(O)\fdisk.res: fdisk.dlg fdiskmsg.rc ftreg.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\ftreg.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    ftreg.c

Abstract:

    This module contains the routines for Disk Administrator that deal
    with registry manipulation

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    1-Feb-94 (bobri) Clean up and handle missing floppy disk on registry
                     save/restore.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "fdisk.h"
#include "ftregres.h"



// attempt to avoid conflict

#define TEMP_KEY_NAME       TEXT("xzss3___$$Temp$Hive$$___")

#define DISK_KEY_NAME       TEXT("DISK")
#define DISK_VALUE_NAME     TEXT("Information")


LONG
FdpLoadHiveIntoRegistry(
    IN LPTSTR HiveFilename
    )

/*++

Routine Description:

    This routine writes the contents of a given hive file into the registry,
    rooted at a temporary key in HKEY_LOCAL_MACHINE.

Arguments:

    HiveFilename - supplies filename of the hive to be loaded into
        the registry

Return Value:

    Windows error code.

--*/

{
    NTSTATUS Status;
    BOOLEAN  OldPrivState;
    LONG     Err;

    // Attempt to get restore privilege

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPrivState);
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    // Load the hive into our registry

    Err = RegLoadKey(HKEY_LOCAL_MACHINE,TEMP_KEY_NAME,HiveFilename);

    // Restore old privilege if necessary

    if (!OldPrivState) {

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                           FALSE,
                           FALSE,
                           &OldPrivState);
    }

    return Err;
}


LONG
FdpUnloadHiveFromRegistry(
    VOID
    )

/*++

Routine Description:

    This routine removes a tree (previously loaded with
    FdpLoadHiveIntoRegistry) from the temporary key in HKEY_LOCAL_MACHINE.

Arguments:

    None.

Return Value:

    Windows error code.

--*/

{
    NTSTATUS Status;
    BOOLEAN  OldPrivState;
    LONG     Err;

    // Attempt to get restore privilege

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &OldPrivState);
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    // Unload the hive from our registry

    Err = RegUnLoadKey(HKEY_LOCAL_MACHINE,TEMP_KEY_NAME);

    // Restore old privilege if necessary

    if (!OldPrivState) {

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                           FALSE,
                           FALSE,
                           &OldPrivState);
    }

    return Err;
}


LONG
FdpGetDiskInfoFromKey(
    IN  LPTSTR  RootKeyName,
    OUT PVOID  *DiskInfo,
    OUT PULONG  DiskInfoSize
    )

/*++

Routine Description:

    This routine pulls the binary blob containing disk ft, drive letter,
    and layout information out of a given registry key.

    The info is found in HKEY_LOCAL_MACHINE,<RootKeyName>\DISK:Information.

Arguments:

    RootKeyName - name of the subkey of HKEY_LOCAL_MACHINE that is to
        contain the DISK key.

    DiskInfo - receives a pointer to a buffer containing the disk info.

    DiskInfoSize - receives size of the disk buffer.

Return Value:

    Windows error code.  If NO_ERROR, DiskInfo and DiskInfoSize are
    filled in, and it is the caller's responsibility to free the buffer
    when it is finished (via LocalFree()).

--*/

{
    LONG     Err;
    HKEY     hkeyDisk;
    ULONG    BufferSize;
    ULONG    ValueType;
    PVOID    Buffer;
    LPTSTR   DiskKeyName;

    // Form the name of the DISK key

    DiskKeyName = (LPTSTR)LocalAlloc( LMEM_FIXED,
                                        (   lstrlen(RootKeyName)
                                          + lstrlen(DISK_KEY_NAME)
                                          + 2           //  the \ and nul
                                        )
                                      * sizeof(TCHAR)
                                    );

    if (DiskKeyName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    lstrcpy(DiskKeyName,RootKeyName);
    lstrcat(DiskKeyName,TEXT("\\"));
    lstrcat(DiskKeyName,DISK_KEY_NAME);

    // Open the DISK key.

    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DiskKeyName,
                       REG_OPTION_RESERVED,
                       KEY_READ,
                       &hkeyDisk);

    if (Err != NO_ERROR) {
        goto CleanUp2;
    }

    // Determine how large we need the buffer to be

    Err = RegQueryValueEx(hkeyDisk,
                          DISK_VALUE_NAME,
                          NULL,
                          &ValueType,
                          NULL,
                          &BufferSize);

    if ((Err != NO_ERROR) && (Err != ERROR_MORE_DATA)) {
        goto CleanUp1;
    }

    // Allocate a buffer of appropriate size

    Buffer = (PVOID)LocalAlloc(LMEM_FIXED,BufferSize);
    if (Buffer == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp1;
    }

    // Query the data

    Err = RegQueryValueEx(hkeyDisk,
                          DISK_VALUE_NAME,
                          NULL,
                          &ValueType,
                          Buffer,
                          &BufferSize);

    if (Err != NO_ERROR) {
        LocalFree(Buffer);
        goto CleanUp1;
    }

    *DiskInfo = Buffer;
    *DiskInfoSize = BufferSize;

  CleanUp1:

    RegCloseKey(hkeyDisk);

  CleanUp2:

    LocalFree(DiskKeyName);

    return Err;
}


LONG
FdpGetDiskInfoFromHive(
    IN  PCHAR   HiveFilename,
    OUT PVOID  *DiskInfo,
    OUT PULONG  DiskInfoSize
    )

/*++

Routine Description:

    This routine pulls the binary blob containing disk ft, drive letter,
    and layout information out of a given registry hive, which must be
    a file in an alternate NT tree (ie, can't be an active hive).

    The info is found in \DISK:Information within the hive.

Arguments:

    HiveFilename - supplies filename of hive

    DiskInfo - receives a pointer to a buffer containing the disk info.

    DiskInfoSize - receives size of the disk buffer.

Return Value:

    Windows error code.  If NO_ERROR, DiskInfo and DiskInfoSize are
    filled in, and it is the caller's responsibility to free the buffer
    when it is finished (via LocalFree()).

--*/

{
    ULONG windowsError;

    windowsError = FdpLoadHiveIntoRegistry(HiveFilename);
    if (windowsError == NO_ERROR) {
        windowsError = FdpGetDiskInfoFromKey(TEMP_KEY_NAME,DiskInfo,DiskInfoSize);
        FdpUnloadHiveFromRegistry();
    }

    return windowsError;
}


LONG
FdTransferOldDiskInfoToRegistry(
    IN PCHAR HiveFilename
    )

/*++

Routine Description:

    This routine transfers disk configuration from a given hive file
    (which should be an inactive system hive) to the current registry.

Arguments:

    HiveFilename - supplies filename of source hive

Return Value:

    Windows error code.

--*/

{
    LONG  windowsError;
    PVOID diskInfo;
    ULONG diskInfoSize;
    HKEY  hkeyDisk;


    // Load up the hive and pull the disk info from it.

    windowsError = FdpGetDiskInfoFromHive(HiveFilename,&diskInfo,&diskInfoSize);
    if (windowsError != NO_ERROR) {
        return windowsError;
    }

    // Propogate the disk info into the current registry.
    //
    // Start by opening HKEY_LOCAL_MACHINE,System\DISK

    windowsError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("System\\") DISK_KEY_NAME,
                                REG_OPTION_RESERVED,
                                KEY_WRITE,
                                &hkeyDisk);

    if (windowsError != NO_ERROR) {
        LocalFree(diskInfo);
        return windowsError;
    }

    // Set the Information value in the DISK key.

    windowsError = RegSetValueEx(hkeyDisk,
                                 DISK_VALUE_NAME,
                                 0,
                                 REG_BINARY,
                                 diskInfo,
                                 diskInfoSize);
    RegCloseKey(hkeyDisk);
    LocalFree(diskInfo);
    return windowsError;
}


typedef struct _STRING_LIST_NODE {
    struct _STRING_LIST_NODE *Next;
    LPTSTR                    String;
} STRING_LIST_NODE, *PSTRING_LIST_NODE;

PSTRING_LIST_NODE FoundDirectoryList;
ULONG             FoundDirectoryCount;

TCHAR Pattern[MAX_PATH+1];
WIN32_FIND_DATA FindData;
OFSTRUCT OfStruct;
HWND hwndStatus;
BOOLEAN ScanDrive[26];
BOOLEAN UserCancelled;


typedef
BOOL
(*PFOUND_HIVE_ROUTINE)(
    IN LPTSTR Directory
    );

VOID
ProcessPendingMessages(
    VOID
    )

/*++

Routine Description:

    Preprocess messages.

Arguments:

    None

Return Value:

    None

--*/

{
    MSG msg;

    while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }
}



PUCHAR ConfigRegistryPath = "\\system32\\config\\system";
BOOL
FdpSearchTreeForSystemHives(
    IN LPTSTR                CurrentDirectory,
    IN PFOUND_HIVE_ROUTINE   FoundHiveRoutine,
    IN HWND                  hdlg
    )

/*++

Routine Description:

    Search an entire directory tree for system and system.alt hive files.
    When found, call a callback function with the directory in which
    system32\config\system[.alt] was found, and the full path of the hive
    file.

    The root directory is not included in the search.

    The top-level call to this function should have a current directory
    like "C:." (ie, no slash for the root directory).

Arguments:

    CurrentDirectory - supplies current directory search path

Return Value:

    FALSE if error (callback function returned FALSE when we found an entry).

--*/

{
    HANDLE findHandle;
    TCHAR  newDirectory[MAX_PATH+1];
    BOOL   found = FALSE;

    // Iterate through the current directory, looking for subdirectories.

    lstrcpy(Pattern, CurrentDirectory);
    lstrcat(Pattern, "\\*");
    findHandle = FindFirstFile(Pattern, &FindData);

    if (findHandle != INVALID_HANDLE_VALUE) {

        do {

            ProcessPendingMessages();
            if (UserCancelled) {
                return FALSE;
            }

            // If the current match is not a directory then skip it.

            if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            || !lstrcmp(FindData.cFileName,TEXT("."))
            || !lstrcmp(FindData.cFileName,TEXT(".."))) {
                continue;
            }

            found = FALSE;

            // Form the name of the file we are looking for
            // [<currentdirectory>\<match>\system32\config\system]

            lstrcpy(Pattern, CurrentDirectory);
            lstrcat(Pattern, "\\");
            lstrcat(Pattern, FindData. cFileName);

            lstrcpy(newDirectory, Pattern);

            // Don't decend into the directory unless the path to the
            // hive.alt name is within MAX_PATH length.

            if ((ULONG)(lstrlen(newDirectory) / sizeof(TCHAR)) < (MAX_PATH - strlen(ConfigRegistryPath) - 4)) {

                SetDlgItemText(hdlg, IDC_SIMPLE_TEXT_LINE, newDirectory);

                lstrcat(Pattern, TEXT(ConfigRegistryPath));

                if (OpenFile(Pattern, &OfStruct, OF_EXIST) != (HFILE)(-1)) {
                    found = TRUE;
                }

                // Also check for a system.alt file there

                lstrcat(Pattern,TEXT(".alt"));

                if (OpenFile(Pattern, &OfStruct, OF_EXIST) != (HFILE)(-1)) {
                    found = TRUE;
                }

                if (found) {
                    if (!FoundHiveRoutine(newDirectory)) {
                        return FALSE;
                    }
                }

                // Descend into the directory we just found

                if (!FdpSearchTreeForSystemHives(newDirectory, FoundHiveRoutine, hdlg)) {
                    return FALSE;
                }
            }

        } while (FindNextFile(findHandle,&FindData));

        FindClose(findHandle);
    }

    return TRUE;
}


BOOL
FdpFoundHiveCallback(
    IN PCHAR Directory
    )

/*++

Routine Description:

    This routine is called when a directory containing a system hive
    has been located.  If all goes well (allocate memory and the like)
    this routine will save the directory name in a list for later use.
    NOTE: No checks are made on the directory name being greater in
    length than MAX_PATH.  It is the responsibility of the caller to
    insure that this is true.

Arguments:

    Directory - the pointer to the character string for the directory
                where a hive has been located.

Return Value:

    TRUE - did something with it.
    FALSE - did not save the directory.

--*/

{
    TCHAR             windowsDir[MAX_PATH+1];
    PSTRING_LIST_NODE dirItem;
    LPTSTR            p;

    // If this is the current windows directory, skip it.

    GetWindowsDirectory(windowsDir, sizeof(windowsDir)/sizeof(TCHAR));

    if (!lstrcmpi(Directory, windowsDir)) {
        return TRUE;
    }

    // Save the directory information away

    dirItem = (PSTRING_LIST_NODE)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(STRING_LIST_NODE));
    if (dirItem == NULL) {
        return FALSE;
    }

    p = (LPTSTR)LocalAlloc(LMEM_FIXED,(lstrlen(Directory)+1) * sizeof(TCHAR));
    if (p == NULL) {
        LocalFree(dirItem);
        return FALSE;
    }

    dirItem->String = p;
    lstrcpy(p, Directory);

    // Update the global chain of found directories.

    dirItem->Next = FoundDirectoryList;
    FoundDirectoryList = dirItem;
    FoundDirectoryCount++;
    return TRUE;
}


VOID
FdpFreeDirectoryList(
    VOID
    )

/*++

Routine Description:

    Go through the list of directories containing system hives and
    free the entries.

Arguments:

    None

Return Value:

    None

--*/

{
    PSTRING_LIST_NODE n,
                      p = FoundDirectoryList;

    while (p) {
        n = p->Next;
        if (p->String) {
            LocalFree(p->String);
        }
        LocalFree(p);
        p = n;
    }

    FoundDirectoryCount = 0;
    FoundDirectoryList = NULL;
}


BOOL CALLBACK
FdpScanningDirsDlgProc(
    IN HWND    hwnd,
    IN UINT    msg,
    IN WPARAM  wParam,
    IN LPARAM  lParam
    )

/*++

Routine Description:

    Display the "scanning" dialog, then when the IDLE message arrives
    process all drive letters and search for system hives.

Arguments:

    Windows dialog proc

Return Value:

    Windows dialog proc

--*/

{
    TCHAR LetterColon[3];
    TCHAR Letter;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hwnd);
        break;

    case WM_ENTERIDLE:

        // Sent to us by the main window after the dialog is displayed.
        // Perform the search here.

        ConfigurationSearchIdleTrigger = FALSE;

        UserCancelled = FALSE;

        lstrcpy(LetterColon,TEXT("?:"));
        for (Letter = TEXT('A'); Letter <= TEXT('Z'); Letter++) {

            if (!ScanDrive[Letter-TEXT('A')]) {
                continue;
            }

            LetterColon[0] = Letter;

            if (!FdpSearchTreeForSystemHives(LetterColon, FdpFoundHiveCallback, hwnd)) {
                EndDialog(hwnd,IDCANCEL);
                return TRUE;
            }

        }

        EndDialog(hwnd,IDOK);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDCANCEL:

            UserCancelled = TRUE;
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }
    return TRUE;
}


BOOL CALLBACK
FdpSelectDirDlgProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Using the list of directories containing system hives, display the
    selections to the user and save the selected item if the user so
    chooses.

Arguments:

    Windows dialog proc.

Return Value:

    Windows dialog proc.

--*/

{
    PSTRING_LIST_NODE Str;
    LONG i;
    static HANDLE ListBoxHandle;

    switch (msg) {

    case WM_INITDIALOG:

        CenterDialog(hwnd);

        // Add each item in the directory list to the listbox

        ListBoxHandle = GetDlgItem(hwnd,IDC_LISTBOX);

        for (Str = FoundDirectoryList; Str; Str = Str->Next) {

            i = SendMessage(ListBoxHandle,LB_ADDSTRING  ,0,(LONG)Str->String);
                SendMessage(ListBoxHandle,LB_SETITEMDATA,i,(LONG)Str        );
        }

        // select the zeroth item

        SendMessage(ListBoxHandle,LB_SETCURSEL,0,0);

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:

            // Get the index of the current list box selection and the
            // pointer to the string node associated with it.

            i = SendMessage(ListBoxHandle,LB_GETCURSEL,0,0);
            EndDialog(hwnd,SendMessage(ListBoxHandle,LB_GETITEMDATA,i,0));
            break;

        case IDCANCEL:

            EndDialog(hwnd,(int)NULL);
            break;

        default:

            return FALSE;
        }
        break;

    default:

        return FALSE;
    }

    return TRUE;
}


BOOL
DoMigratePreviousFtConfig(
    VOID
    )

/*++

Routine Description:

    Allow the user to move the disk config info from a different Windows NT
    installation into the current registry.

    For each fixed disk volume, scan it for system hives and present the
    results to the user so he can select the installation to migrate.

    Then load the system hive from that instllation (system.alt if the system
    hive is corrupt, etc) and transfer the DISK:Information binary blob.

Arguments:

    None.

Return Value:

    FALSE if error or user cancelled, TRUE if info was migrated and reboot
    is required.

--*/

{
    LONG              windowsError;
    TCHAR             letter;
    TCHAR             letterColon[4];
    PSTRING_LIST_NODE stringNode;

    // Tell the user what this will do and prompt for confirmation

    if (ConfirmationDialog(MSG_CONFIRM_MIGRATE_CONFIG, MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        return FALSE;
    }

    ProcessPendingMessages();

    // Figure out which drives are relevent

    SetCursor(hcurWait);

    RtlZeroMemory(ScanDrive,sizeof(ScanDrive));
    lstrcpy(letterColon,TEXT("?:\\"));
    for (letter=TEXT('A'); letter<=TEXT('Z'); letter++) {

        letterColon[0] = letter;

        if (GetDriveType(letterColon) == DRIVE_FIXED) {

            ScanDrive[letter-TEXT('A')] = TRUE;
        }
    }

    SetCursor(hcurNormal);

    // Create a window that will list the directories being scanned, to
    // keep the user entertained.

    ConfigurationSearchIdleTrigger = TRUE;

    windowsError = DialogBox(hModule,
                             MAKEINTRESOURCE(IDD_SIMPLETEXT),
                             hwndFrame,
                             FdpScanningDirsDlgProc);

    if (windowsError == IDCANCEL) {
        FdpFreeDirectoryList();
        return FALSE;
    }

    ProcessPendingMessages();

    if (!FoundDirectoryCount) {

        InfoDialog(MSG_NO_OTHER_NTS);
        return FALSE;
    }

    // Display a dialog box that allows the user to select one of the
    // directories we found.

    stringNode = (PSTRING_LIST_NODE)DialogBox(hModule,
                                              MAKEINTRESOURCE(IDD_SELDIR),
                                              hwndFrame,
                                              FdpSelectDirDlgProc);

    if (stringNode == NULL) {
        FdpFreeDirectoryList();
        return FALSE;
    }

    // User made a selection.  One last confirmation.

    if (ConfirmationDialog(MSG_ABSOLUTELY_SURE,MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        FdpFreeDirectoryList();
        return FALSE;
    }

    ProcessPendingMessages();

    SetCursor(hcurWait);

    lstrcpy(Pattern,stringNode->String);
    lstrcat(Pattern,TEXT(ConfigRegistryPath));

    windowsError = FdTransferOldDiskInfoToRegistry(Pattern);
    if (windowsError != NO_ERROR) {
        lstrcat(Pattern,TEXT(".alt"));
        windowsError = FdTransferOldDiskInfoToRegistry(Pattern);
    }
    FdpFreeDirectoryList();
    SetCursor(hcurNormal);

    if (windowsError != NO_ERROR) {

        if (windowsError == ERROR_FILE_NOT_FOUND) {
            ErrorDialog(MSG_NO_DISK_INFO);
        } else if (windowsError == ERROR_SHARING_VIOLATION) {
            ErrorDialog(MSG_DISK_INFO_BUSY);
        } else {
            ErrorDialog(windowsError);
        }
        return FALSE;
    }
    return TRUE;
}



BOOL
DoRestoreFtConfig(
    VOID
    )

/*++

Routine Description:

    Restore previously saved disk configuration information into the
    active registry.

    The saved config info will come from a floppy that the user is
    prompted to insert.

Arguments:

    None.

Return Value:

    FALSE if error or user cancelled, TRUE if info was restored and reboot
    is required.

--*/

{
    LONG    Err;
    TCHAR   caption[256];
    UINT    errorMode;
    va_list arglist =
#ifdef _ALPHA_    // Alpha defines va_list as a struct.  Init as such
    {0};
#else
    NULL;
#endif


    // Get confirmation

    if (ConfirmationDialog(MSG_CONFIRM_RESTORE_CONFIG, MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        return FALSE;
    }

    // Get the diskette into A:.

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    LoadString(hModule,IDS_INSERT_DISK,caption,sizeof(caption)/sizeof(TCHAR));
    if (CommonDialog(MSG_INSERT_REGSAVEDISK,caption,MB_OKCANCEL | MB_TASKMODAL, arglist) != IDOK) {
        return FALSE;
    }

    ProcessPendingMessages();
    SetCursor(hcurWait);

    // If there is no file called SYSTEM on a:\, it appears that the registry
    // creates one and then keeps it open.  To avoid this, check to see
    // whether there is one first.

    if (OpenFile(TEXT("A:\\SYSTEM"),&OfStruct,OF_EXIST) == (HFILE)(-1)) {
        Err = ERROR_FILE_NOT_FOUND;
    } else {
        Err = FdTransferOldDiskInfoToRegistry(TEXT("A:\\SYSTEM"));
    }

    SetErrorMode(errorMode);
    SetCursor(hcurNormal);

    if (Err != NO_ERROR) {
        ErrorDialog(Err);
        return FALSE;
    }

    return TRUE;
}



VOID
DoSaveFtConfig(
    VOID
    )

/*++

Routine Description:

    Allow the user to update the registry save diskette with the currently
    defined disk configuration.  The saved info excludes any changes made
    during this session of disk manager.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LONG    Err,
            ErrAlt;
    LPTSTR  SystemHiveName = TEXT("a:\\system");
    HKEY    hkey;
    TCHAR   caption[256];
    DWORD   disposition;
    UINT    errorMode;
    va_list arglist =
#ifdef _ALPHA_
    {0};        // Alpha defines va_list as a struct.  Init as such.
#else
    NULL;
#endif

    // Get a diskette into A:.

    LoadString(hModule,
               IDS_INSERT_DISK,
               caption,
               sizeof(caption)/sizeof(TCHAR));
    if (CommonDialog(MSG_INSERT_REGSAVEDISK2,caption,MB_OKCANCEL | MB_TASKMODAL, arglist) != IDOK) {
        return;
    }

    // Decide what to do based on the presence of a a:\system.  If that file
    // is present, just update the DISK entry in it.  If it is not present,
    // then blast out the entire system hive.

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    ProcessPendingMessages();
    SetCursor(hcurWait);

    if (OpenFile(SystemHiveName,&OfStruct,OF_EXIST) == (HFILE)(-1)) {

        BOOLEAN OldPrivState;
        NTSTATUS Status;

        // Blast the entire system hive out to the floppy.
        // Start by attempting to get backup privilege.

        Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &OldPrivState);

        Err = RtlNtStatusToDosError(Status);
        if (Err == NO_ERROR) {

            Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               TEXT("system"),
                               REG_OPTION_RESERVED,
                               KEY_READ,
                               &hkey);

            if (Err == NO_ERROR) {

                Err = RegSaveKey(hkey,SystemHiveName,NULL);
                RegCloseKey(hkey);
            }

            if (!OldPrivState) {
                RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,FALSE,FALSE,&OldPrivState);
            }
        }
    } else {

        PVOID DiskInfo;
        ULONG DiskInfoSize;

        // Load up the saved system hive

        Err = FdpLoadHiveIntoRegistry(SystemHiveName);
        if (Err == NO_ERROR) {

            // Get the current DISK information

            Err = FdpGetDiskInfoFromKey(TEXT("system"),&DiskInfo,&DiskInfoSize);
            if (Err == NO_ERROR) {

                // Place the current disk information into the saved hive

                Err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                     TEMP_KEY_NAME TEXT("\\") DISK_KEY_NAME,
                                     0,
                                     "Disk and fault tolerance information.",
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &disposition );

                if (Err == NO_ERROR) {

                    Err = RegSetValueEx(hkey,
                                        DISK_VALUE_NAME,
                                        REG_OPTION_RESERVED,
                                        REG_BINARY,
                                        DiskInfo,
                                        DiskInfoSize);

                    RegFlushKey(hkey);
                    RegCloseKey(hkey);
                }

                LocalFree(DiskInfo);
            }

            ErrAlt = FdpUnloadHiveFromRegistry();

            if (Err == NO_ERROR && ErrAlt != NO_ERROR) {

                Err = ErrAlt;
            }
        }
    }

    SetCursor(hcurNormal);
    SetErrorMode(errorMode);

    if (Err == NO_ERROR) {
        InfoDialog(MSG_CONFIG_SAVED_OK);
    } else {
        ErrorDialog(Err);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fmifs.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    fmifs.c

Abstract:

    This module contains the set of routines that work with the fmifs.dll

Author:

    Bob Rinne (bobri)  11/15/93

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include "fmifs.h"
#include <string.h>
#include <stdio.h>

//
// defines unique to this module
//

#define FS_CANCELUPDATE (WM_USER + 0)
#define FS_FINISHED     (WM_USER + 1)

BOOLEAN
FmIfsCallback(
    IN FMIFS_PACKET_TYPE    PacketType,
    IN DWORD                PacketLength,
    IN PVOID                PacketData
    );

//
// Externals needed for IFS Dll support (format and label)
//

HINSTANCE                           IfsDllHandle            = NULL;
PFMIFS_FORMAT_ROUTINE               FormatRoutine           = NULL;
PFMIFS_SETLABEL_ROUTINE             LabelRoutine            = NULL;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
PFMIFS_DOUBLESPACE_CREATE_ROUTINE   DblSpaceCreateRoutine   = NULL;
PFMIFS_DOUBLESPACE_MOUNT_ROUTINE    DblSpaceMountRoutine    = NULL;
PFMIFS_DOUBLESPACE_DELETE_ROUTINE   DblSpaceDeleteRoutine   = NULL;
PFMIFS_DOUBLESPACE_DISMOUNT_ROUTINE DblSpaceDismountRoutine = NULL;
PFMIFS_DOUBLESPACE_QUERY_INFO_ROUTINE DblSpaceQueryInfoRoutine = NULL;

BOOLEAN DoubleSpaceSupported = TRUE;
#endif

// HACK HACK - clean this up if it works.

#define    SELECTED_REGION(i)  (SelectedDS[i]->RegionArray[SelectedRG[i]])
#define     MaxMembersInFtSet   32
extern DWORD      SelectionCount;
extern PDISKSTATE SelectedDS[MaxMembersInFtSet];
extern ULONG      SelectedRG[MaxMembersInFtSet];

VOID
setUnicode(
    char *astring,
    WCHAR *wstring
    )
/*++

Routine Description:

    Convert an ansii string to Unicode.  Internal routine to fmifs module.

Arguments:

    astring - ansii string to convert to Unicode
    wstring - resulting string location

Return Value:

    None

--*/
{

    int len = lstrlen(astring)+1;

    MultiByteToWideChar( CP_ACP, 0, astring, len, wstring, len );
}

BOOL
LoadIfsDll(
    VOID
    )

/*++

Routine Description:

    This routine will determine if the IFS Dll needs to be loaded.  If
    so, it will load it and locate the format and label routines in the
    dll.

Arguments:

    None

Return Value:

    TRUE if Dll is loaded and the routines needed have been found
    FALSE if something fails

--*/

{
    if (FormatRoutine) {

        // Library is already loaded and the routines needed
        // have been located.

        return TRUE;
    }

    IfsDllHandle = LoadLibrary(TEXT("fmifs.dll"));
    if (IfsDllHandle == (HANDLE)NULL) {

         // FMIFS not available.

         return FALSE;
    }

    // Library is loaded.  Locate the two routines needed by
    // Disk Administrator.

    FormatRoutine = (PVOID)GetProcAddress(IfsDllHandle, "Format");
    LabelRoutine  = (PVOID)GetProcAddress(IfsDllHandle, "SetLabel");
    if (!FormatRoutine || !LabelRoutine) {

        // something didn't get found so shut down all accesses
        // to the library by insuring FormatRoutine is NULL

        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        return FALSE;
    }

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    DblSpaceMountRoutine    = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceMount");
    DblSpaceDismountRoutine = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceDismount");
    DblSpaceCreateRoutine   = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceCreate");
    DblSpaceDeleteRoutine   = (PVOID)GetProcAddress(IfsDllHandle, "DoubleSpaceDelete");
    DblSpaceQueryInfoRoutine = (PVOID)GetProcAddress(IfsDllHandle, "FmifsQueryDriveInformation");

    if (!DblSpaceMountRoutine || !DblSpaceDismountRoutine || !DblSpaceQueryInfoRoutine)  {

        // didn't get all of the DoubleSpace support routines
        // Allow format and label, just don't do DoubleSpace

        DoubleSpaceSupported = FALSE;
    }

    if (DblSpaceCreateRoutine && DblSpaceDeleteRoutine) {

        // Everything is there for read/write double space support.
        // This will change certain dialogs to allow creation and
        // deletion of double space volumes.

        IsFullDoubleSpace = TRUE;
    }
#endif
    return TRUE;
}

VOID
UnloadIfsDll(
    VOID
    )

/*++

Routine Description:

    This routine will free the FmIfs DLL if it was loaded.

Arguments:

    None

Return Value:

    None

--*/

{
    if (FormatRoutine) {
        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        IfsDllHandle  = NULL;
        LabelRoutine  = NULL;
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
        DblSpaceDismountRoutine = NULL;
        DblSpaceMountRoutine    = NULL;
        DblSpaceCreateRoutine   = NULL;
        DblSpaceDeleteRoutine   = NULL;
#endif
    }
}

PFORMAT_PARAMS ParamsForCallBack = NULL;

BOOLEAN
FmIfsCallback(
    IN FMIFS_PACKET_TYPE    PacketType,
    IN DWORD                PacketLength,
    IN PVOID                PacketData
    )

/*++

Routine Description:

    This routine gets callbacks from fmifs.dll regarding
    progress and status of the ongoing format or doublespace
    create.  It runs in the same thread as the format or create,
    which is a separate thread from the "cancel" button.  If
    the user hits "cancel", this routine notices on the next
    callback and cancels the format or double space create.

Arguments:

    [PacketType] -- an fmifs packet type
    [PacketLength] -- length of the packet data
    [PacketData] -- data associated with the packet

Return Value:

    TRUE if the fmifs activity should continue, FALSE if the
    activity should halt immediately.  Thus, we return FALSE if
    the user has hit "cancel" and we wish fmifs to clean up and
    return from the Format() entrypoint call.

--*/

{
    PFORMAT_PARAMS formatParams = ParamsForCallBack;
    HWND           hDlg = formatParams->DialogHwnd;

    // Quit if told to do so..

    if (formatParams->Cancel) {
        formatParams->Result = MSG_FORMAT_CANCELLED;
        return FALSE;
    }

    switch (PacketType) {
    case FmIfsPercentCompleted:

        PostMessage(hDlg,
                    FS_CANCELUPDATE,
                    ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted,
                    0);
        break;

    case FmIfsFormatReport:

        formatParams->TotalSpace = ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesTotalDiskSpace;
        formatParams->SpaceAvailable = ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesAvailable;
        break;

    case FmIfsIncompatibleFileSystem:

        formatParams->Result = MSG_INCOMPATIBLE_FILE_SYSTEM;
        break;

    case FmIfsInsertDisk:

        break;

    case FmIfsFormattingDestination:

        break;

    case FmIfsIncompatibleMedia:

        formatParams->Result = MSG_INCOMPATIBLE_MEDIA;
        break;

    case FmIfsAccessDenied:

        formatParams->Result = MSG_FORMAT_ACCESS_DENIED;
        break;

    case FmIfsMediaWriteProtected:

        formatParams->Result = MSG_WRITE_PROTECTED;
        break;

    case FmIfsCantLock:

        formatParams->Result = MSG_FORMAT_CANT_LOCK;
        break;

    case FmIfsBadLabel:

        formatParams->Result = MSG_BAD_LABEL;
        break;

    case FmIfsCantQuickFormat:

        formatParams->Result = MSG_CANT_QUICK_FORMAT;
        break;

    case FmIfsIoError:

        formatParams->Result = MSG_IO_ERROR;
        break;

    case FmIfsFinished:

        PostMessage(hDlg,
                    FS_FINISHED,
                    0,
                    0);
        return FALSE;
        break;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    case FmIfsDblspaceCreateFailed:
        formatParams->Result = MSG_CANT_CREATE_DBLSPACE;
        break;

    case FmIfsDblspaceMountFailed:
        formatParams->Result = MSG_CANT_MOUNT_DBLSPACE;
        break;

    case FmIfsDblspaceDriveLetterFailed:
        formatParams->Result = MSG_DBLSPACE_LETTER_FAILED;
        break;

    case FmIfsDblspaceCreated:

        // Save the name of the double space file.

        if (formatParams->DblspaceFileName = (PWSTR) Malloc(PacketLength)) {
            memcpy(formatParams->DblspaceFileName, PacketData, PacketLength);
        }
        break;

    case FmIfsDblspaceMounted:
        break;
#endif
    default:
        break;
    }

    return (formatParams->Result) ? FALSE : TRUE;
}

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
ULONG MountDismountResult;
#define MOUNT_DISMOUNT_SUCCESS 0

BOOLEAN
FmIfsMountDismountCallback(
    IN FMIFS_PACKET_TYPE    PacketType,
    IN DWORD                PacketLength,
    IN PVOID                PacketData
    )

/*++

Routine Description:

    This routine gets callbacks from fmifs.dll regarding
    progress and status of the ongoing format or doublespace

Arguments:

    [PacketType] -- an fmifs packet type
    [PacketLength] -- length of the packet data
    [PacketData] -- data associated with the packet

Return Value:

    TRUE if the fmifs activity should continue, FALSE if the
    activity should halt immediately.  Thus, we return FALSE if
    the user has hit "cancel" and we wish fmifs to clean up and
    return from the Format() entrypoint call.

--*/

{
    switch (PacketType) {
    case FmIfsDblspaceMounted:
        MountDismountResult = MOUNT_DISMOUNT_SUCCESS;
        break;
    }
    return TRUE;
}
#endif

VOID
FormatVolume(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This routine converts the strings in the formatParams structure
    and calls the fmifs routines to perform the format.

    It assumes it is called by a separate thread and will exit the
    thread on completion of the format.

Arguments:

    ThreadParameter - a pointer to the FORMAT_PARAMS structure

Return Value:

    None

--*/

{
    PFORMAT_PARAMS formatParams = (PFORMAT_PARAMS) ThreadParameter;
    PPERSISTENT_REGION_DATA regionData;
    DWORD          index;
    WCHAR          unicodeLabel[100],
                   unicodeFsType[20],
                   driveLetter[4];

    // The fmifs interface doesn't allow for a context parameter
    // therefore the formatparams must be passed through an external.

    ParamsForCallBack = formatParams;

    // set up a unicode drive letter.

    regionData = (PPERSISTENT_REGION_DATA) formatParams->RegionData;
    driveLetter[1] = L':';
    driveLetter[2] = 0;
    driveLetter[0] = (WCHAR) regionData->DriveLetter;

    // convert label to unicode

    setUnicode(formatParams->Label,
               unicodeLabel);

    // convert filesystem type to unicode

    for (index = 0;
         unicodeFsType[index] = (WCHAR)(formatParams->FileSystem[index]);
         index++) {
        // operation done in for loop
    }

    (*FormatRoutine)(driveLetter,
                     FmMediaUnknown,
                     unicodeFsType,
                     unicodeLabel,
                     (BOOLEAN)formatParams->QuickFormat,
                     &FmIfsCallback);

    // Set the synchronization event to inform the windisk thread
    // that this is complete and all handles have been closed.

    formatParams->ThreadIsDone = 1;
    ExitThread(0L);
}

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
VOID
FmIfsCreateDblspace(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This routine converts the strings in the formatParams structure
    and calls the fmifs routines to perform the double space create.

    It assumes it is called by a separate thread and will exit the
    thread on completion of the create.

Arguments:

    ThreadParameter - a pointer to the FORMAT_PARAMS structure

Return Value:

    None

--*/

{
    PFORMAT_PARAMS formatParams = (PFORMAT_PARAMS) ThreadParameter;
    PPERSISTENT_REGION_DATA regionData;
    DWORD          index;
    UCHAR          letter;
    WCHAR          unicodeLabel[100],
                   newDriveLetter[4],
                   driveLetter[4];

    // The fmifs interface doesn't allow for a context parameter
    // therefore the formatparams must be passed through an external.

    ParamsForCallBack = formatParams;

    // set up a unicode drive letter.

    regionData = (PPERSISTENT_REGION_DATA) formatParams->RegionData;
    driveLetter[1] = L':';
    driveLetter[2] = 0;
    driveLetter[0] = (WCHAR) regionData->DriveLetter;

    // set up the new letter

    newDriveLetter[1] = L':';
    newDriveLetter[2] = 0;

    // Choose the first available.  This should come from the dialog
    // newDriveLetter[0] = (WCHAR) formatParams->NewLetter;

    for (letter='C'; letter <= 'Z'; letter++) {
        if (DriveLetterIsAvailable((CHAR)letter)) {
            newDriveLetter[0] = (WCHAR) letter;
            break;
        }
    }

    // convert label to unicode

    setUnicode(formatParams->Label,
               unicodeLabel);

    (*DblSpaceCreateRoutine)(driveLetter,
                             formatParams->SpaceAvailable * 1024 * 1024,
                             unicodeLabel,
                             newDriveLetter,
                             &FmIfsCallback);
    ExitThread(0L);
}

BOOL
FmIfsDismountDblspace(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Convert the name provided into unicode and call the
    FmIfs support routine.

Arguments:

    DriveLetter - the drive letter to dismount.

Return Value:

    TRUE - it worked.

--*/

{
    WCHAR unicodeLetter[4];
    ULONG index;

    unicodeLetter[0] = (WCHAR) DriveLetter;
    unicodeLetter[1] = (WCHAR) ':';
    unicodeLetter[2] = 0;

    // The only way to communicate with the fmifs callback
    // is through global externals.

    MountDismountResult = MSG_CANT_DISMOUNT_DBLSPACE;

    (*DblSpaceDismountRoutine)(unicodeLetter, &FmIfsMountDismountCallback);

    return MountDismountResult;
}

BOOL
FmIfsMountDblspace(
    IN PCHAR FileName,
    IN CHAR  HostDrive,
    IN CHAR  NewDrive
    )

/*++

Routine Description:

    Convert the arguments into unicode characters and
    call the FmIfs support routine to mount the double
    space volume.

Arguments:

    FileName  - ASCII file name (i.e. dblspace.xxx)
    HostDrive - Drive drive letter containing double space volume
    NewDrive  - Drive letter to be assigned to the volume

Return Value:

    TRUE it worked.

--*/

{
    WCHAR wideFileName[40];
    WCHAR wideHostDrive[4];
    WCHAR wideNewDrive[4];
    ULONG index;

    // convert the double space file name.

    for (index = 0; wideFileName[index] = (WCHAR) FileName[index]; index++) {
        // all work done in for expression
    }

    // convert the drive names.

    wideNewDrive[1] = wideHostDrive[1] = (WCHAR) ':';
    wideNewDrive[2] = wideHostDrive[2] = 0;

    wideNewDrive[0]  = (WCHAR) NewDrive;
    wideHostDrive[0] = (WCHAR) HostDrive;

    // The only way to communicate with the fmifs callback
    // is through global externals.

    MountDismountResult = MSG_CANT_MOUNT_DBLSPACE;

    (*DblSpaceMountRoutine)(wideHostDrive,
                            wideFileName,
                            wideNewDrive,
                            &FmIfsMountDismountCallback);
    return MountDismountResult;
}

BOOLEAN
FmIfsQueryInformation(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    )

/*++

Routine Description:

    Call through the pointer to the routine in the fmifs dll.

Arguments:

    Same as the Fmifs routine in the DLL.

Return Value:

--*/

{
    if (!DblSpaceQueryInfoRoutine) {
        return FALSE;
    }
    return (*DblSpaceQueryInfoRoutine)(DosDriveName,
                                       IsRemovable,
                                       IsFloppy,
                                       IsCompressed,
                                       Error,
                                       NtDriveName,
                                       MaxNtDriveNameLength,
                                       CvfFileName,
                                       MaxCvfFileNameLength,
                                       HostDriveName,
                                       MaxHostDriveNameLength);
}
#endif

BOOL CALLBACK
CancelDlgProc(
    IN HWND   hDlg,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the modeless progress & cancel dialog
    Two main purposes here:
       1. if the user chooses CANCEL we set bCancel to TRUE
          which will end the PeekMessage background processing loop
       2. handle the private FS_CANCELUPDATE message and draw
          a "gas gauge" indication of how far the background job
          has progressed

Arguments:

    standard Windows dialog procedure

Return Values:

    standard Windows dialog procedure

--*/

{
    static DWORD          percentDrawn;
    static RECT           rectGG;              // GasGauge rectangle
    static BOOL           captionIsLoaded;
    static PFORMAT_PARAMS formatParams;
           TCHAR          title[100],
                          templateString[100];

    switch (uMsg) {
    case WM_INITDIALOG: {
        PPERSISTENT_REGION_DATA regionData;
        HANDLE threadHandle;
        DWORD  threadId;
        HWND   hwndGauge = GetDlgItem(hDlg, IDC_GASGAUGE);

        // set up the dialog handle in the parameter block so the
        // call back routine can communicate with this routine
        // and initialize static variables.

        formatParams = (PFORMAT_PARAMS) lParam;
        formatParams->DialogHwnd = hDlg;
        regionData = (PPERSISTENT_REGION_DATA) formatParams->RegionData;
        percentDrawn = 0;
        captionIsLoaded = FALSE;

        // Set the caption string.

        LoadString(hModule, IDS_FORMAT_TITLE, templateString, sizeof(templateString)/sizeof(TCHAR));
        wsprintf(title,
                 templateString,
                 regionData->DriveLetter);
        SetWindowText(hDlg, title);

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
        if (formatParams->DoubleSpace) {

             // start the double space create thread

             threadHandle = CreateThread(NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE) FmIfsCreateDblspace,
                                         (LPVOID) formatParams,
                                         (DWORD) 0,
                                         (LPDWORD) &threadId);
        } else {
#endif

             // start the format thread

             threadHandle = CreateThread(NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE) FormatVolume,
                                         (LPVOID) formatParams,
                                         (DWORD) 0,
                                         (LPDWORD) &threadId);
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
        }
#endif
        if (!threadHandle) {
            // can't do it now.

            formatParams->Result = MSG_COULDNT_CREATE_THREAD;
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        // no need to keep the handle around.

        CloseHandle(threadHandle);

        // Get the coordinates of the gas gauge static control rectangle,
        // and convert them to dialog client area coordinates

        GetClientRect(hwndGauge, &rectGG);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.left);
        ClientToScreen(hwndGauge, (LPPOINT)&rectGG.right);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.left);
        ScreenToClient(hDlg, (LPPOINT)&rectGG.right);
        return TRUE;
    }

    case WM_COMMAND:

        switch (wParam) {
        case IDCANCEL:

            formatParams->Result = MSG_FORMAT_CANCELLED;
            formatParams->Cancel = TRUE;
            EndDialog(hDlg, FALSE);
        }
        return TRUE;

    case WM_PAINT: {
        INT         width  = rectGG.right - rectGG.left;
        INT         height = rectGG.bottom - rectGG.top;
        INT         nDivideRects;
        HDC         hDC;
        PAINTSTRUCT ps;
        TCHAR       buffer[100];
        SIZE        size;
        INT         xText,
                    yText,
                    byteCount;
        RECT        rectDone,
                    rectLeftToDo;

        // The gas gauge is drawn by drawing a text string stating
        // what percentage of the job is done into the middle of
        // the gas gauge rectangle, and by separating that rectangle
        // into two parts: rectDone (the left part, filled in blue)
        // and rectLeftToDo(the right part, filled in white).
        // nDivideRects is the x coordinate that divides these two rects.
        //
        // The text in the blue rectangle is drawn white, and vice versa
        // This is easy to do with ExtTextOut()!

        hDC = BeginPaint(hDlg, &ps);

        // If formatting quick, set this display

        if (!captionIsLoaded) {
            UINT resourceId = IDS_PERCENTCOMPLETE;

            if (formatParams->QuickFormat) {
                resourceId = IDS_QUICK_FORMAT;
            }
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
            if (formatParams->DoubleSpace) {
                resourceId = IDS_CREATING_DBLSPACE;
            }
#endif
            LoadString(hModule,
                       resourceId,
                       buffer,
                       sizeof(buffer)/sizeof(TCHAR));
            if (!formatParams->QuickFormat) {
                SetDlgItemText(hDlg, IDC_TEXT, buffer);
            }
            captionIsLoaded = TRUE;
        }

        if (formatParams->QuickFormat) {
            nDivideRects = 0;
            byteCount = lstrlen(buffer);
        } else {
            byteCount = wsprintf(buffer, TEXT("%3d%%"), percentDrawn);
            nDivideRects = (width * percentDrawn) / 100;
        }

        GetTextExtentPoint(hDC, buffer, lstrlen(buffer), &size);
        xText = rectGG.left + (width  - size.cx) / 2;
        yText = rectGG.top  + (height - size.cy) / 2;


        // Paint in the "done so far" rectangle of the gas
        // gauge with blue background and white text

        SetRect(&rectDone,
                rectGG.left,
                rectGG.top,
                rectGG.left + nDivideRects,
                rectGG.bottom);

        SetTextColor(hDC, RGB(255, 255, 255));
        SetBkColor(hDC, RGB(0, 0, 255));

        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectDone,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);

        // Paint in the "still left to do" rectangle of the gas
        // gauge with white background and blue text

        SetRect(&rectLeftToDo,
                rectGG.left + nDivideRects,
                rectGG.top,
                rectGG.right,
                rectGG.bottom);
        SetTextColor(hDC, RGB(0, 0, 255));
        SetBkColor(hDC, RGB(255, 255, 255));

        ExtTextOut(hDC,
                   xText,
                   yText,
                   ETO_CLIPPED | ETO_OPAQUE,
                   &rectLeftToDo,
                   buffer,
                   byteCount/sizeof(TCHAR),
                   NULL);
        EndPaint(hDlg, &ps);
        return TRUE;
    }

    case FS_CANCELUPDATE:

         // wParam = % completed

         percentDrawn = (INT)wParam;
         InvalidateRect(hDlg, &rectGG, TRUE);
         UpdateWindow(hDlg);
         return TRUE;

    case FS_FINISHED:

        EndDialog(hDlg, TRUE);
        return TRUE;

    default:

        return FALSE;
    }
}

INT
LabelDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)

/*++

Routine Description:

    This routine manages the label dialog.
    Upon completion of the dialog it will end the dialog with a result of
    TRUE to indicate that all is set up for the label operation.  FALSE if
    the label operation has been cancelled by the user.

Arguments:

    Standard Windows dialog procedure.

Return Value:

    Standard Windows dialog procedure.

--*/

{
    static PLABEL_PARAMS      labelParams;
    static PREGION_DESCRIPTOR regionDescriptor;
    static PPERSISTENT_REGION_DATA regionData;
    char     text[100];
    TCHAR    uniText[100];
    int      labelSize;
    TCHAR    title[100],
             templateString[100];

    switch (wMsg) {
    case WM_INITDIALOG:

        labelParams = (PLABEL_PARAMS) lParam;
        regionDescriptor = labelParams->RegionDescriptor;
        regionData = PERSISTENT_DATA(regionDescriptor);

        // Set the caption string.
        //
        LoadString(hModule, IDS_LABEL_TITLE, templateString, sizeof(templateString)/sizeof(TCHAR));
        wsprintf(title,
                 templateString,
                 regionData->DriveLetter);
        SetWindowText(hDlg, title);

        // Convert the volume label into the proper type for windows.

        wsprintf(text, "%ws", regionData->VolumeLabel);
        UnicodeHack(text, uniText);
        SetDlgItemText(hDlg, IDC_NAME, uniText);
        return TRUE;

    case WM_COMMAND:
        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_LABEL);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK:

            labelSize = GetDlgItemText(hDlg, IDC_NAME, text, 100);
            UnicodeHack(text, labelParams->NewLabel);
            EndDialog(hDlg, TRUE);
            break;
        }
        break;
    }
    return FALSE;
}

#define NUM_FSTYPES 2
#define MAX_FSTYPENAME_SIZE 6

// HPFS is not supported -- therefore commented out.

TCHAR *FsTypes[NUM_FSTYPES + 1] = { "NTFS",
                                 /* "HPFS", */
                                    "FAT" };
WCHAR *UnicodeFsTypes[NUM_FSTYPES] = { L"NTFS",
                                    /* L"HPFS", */
                                       L"FAT" };

BOOL CALLBACK
FormatDlgProc(
    IN HWND   hDlg,
    IN UINT   wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)

/*++

Routine Description:

    This routine manages the format dialog.  Upon completion it ends the
    dialog with a result value of TRUE to indicate that the format operation
    is to take place.  FALSE is the result if the user cancels out of the
    dialog.

Arguments:

    Standard Windows dialog procedure.

Return Value:

    Standard Windows dialog procedure.

--*/

{
    static HWND                    hwndCombo;
    static PFORMAT_PARAMS          formatParams;
    static PREGION_DESCRIPTOR      regionDescriptor;
    static PPERSISTENT_REGION_DATA regionData;
    char  text[40];
    TCHAR uniText[40];
    INT   i;
    DWORD selection;
    BOOL  quickFormat = FALSE;
    HWND  hwndButton;
    TCHAR title[100],
          templateString[100];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
    case WM_INITDIALOG: {
        PWSTR typeName    = NULL,
              volumeLabel = NULL;
        WCHAR driveLetter = L' ';

        // since the format params are static reset the quick format boolean.

        formatParams = (PFORMAT_PARAMS) lParam;
        formatParams->QuickFormat = FALSE;

        // get format params, set static values and
        // get information about the volume

        hwndCombo = GetDlgItem(hDlg, IDC_FSTYPE);
        regionDescriptor = formatParams->RegionDescriptor;
        DetermineRegionInfo(regionDescriptor,
                            &typeName,
                            &volumeLabel,
                            &driveLetter);
        regionData = PERSISTENT_DATA(regionDescriptor);

        // Set the caption string.

        LoadString(hModule, IDS_FORMAT_TITLE, templateString, sizeof(templateString)/sizeof(TCHAR));
        wsprintf(title,
                 templateString,
                 regionData->DriveLetter);
        SetWindowText(hDlg, title);

        // Convert the volume label into the proper type for windows
        // and set default values.

        wsprintf(text, "%ws", regionData->VolumeLabel);
        UnicodeHack(text, uniText);
        SetDlgItemText(hDlg, IDC_NAME, uniText);
        CheckDlgButton(hDlg, IDC_VERIFY, quickFormat);
        SendDlgItemMessage(hDlg, IDOK, EM_SETSEL, 0, -1);

        // If this volume is a mirror or stripe with parity,
        // disable Quick Format.

        if (regionData->FtObject != NULL &&
            (regionData->FtObject->Set->Type == Mirror ||
             regionData->FtObject->Set->Type == StripeWithParity)) {

            hwndButton = GetDlgItem(hDlg, IDC_VERIFY);

            if (hwndButton != NULL) {

                EnableWindow(hwndButton, FALSE);
            }
        }

        selection = 0;
        if (IsDiskRemovable[regionDescriptor->Disk]) {

            // If removable, start from the bottom of the list so FAT is first.
            // Load the available File system types.

            for (i = NUM_FSTYPES - 1; i >= 0; i--) {

                // Fill the drop down list.

                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)FsTypes[i]);
            }

        } else {

            // Load the available File system types.

            for (i = 0; i < NUM_FSTYPES; i++) {

                // While filling in the drop down, determine which FS
                // this volume is already formated for and make it the
                // default (if not found, NTFS is the default).

                if (wcscmp(typeName, UnicodeFsTypes[i]) == 0) {
                    selection = i;
                }

                // set the FS type into the dialog.

                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LONG)FsTypes[i]);
            }
        }

        SendMessage(hwndCombo, CB_SETCURSEL, selection, 0);
        return TRUE;
        break;
    }

    case WM_COMMAND:

        switch (wParam) {

        case FD_IDHELP:

            DialogHelp(HC_DM_DLG_FORMAT);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        case IDOK: {
            int labelSize;

            // pull the parameters from the dialog
            // and return with success.

            selection = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
            SendMessage(hwndCombo,
                        CB_GETLBTEXT,
                        selection,
                        (LONG)formatParams->FileSystem);
            labelSize = GetDlgItemText(hDlg,
                                       IDC_NAME,
                                       (LPTSTR) formatParams->Label,
                                       100);
            if (IsDlgButtonChecked(hDlg, IDC_VERIFY)) {
                formatParams->QuickFormat = TRUE;
            }
            EndDialog(hDlg, TRUE);
            break;
        }

        default:

            return FALSE;
        }

    default:
        break;
    }
    return FALSE;
}

VOID
FormatPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Insure the IFS Dll is loaded and start the dialog for format
    of a volume.

Arguments:

    RegionDescriptor - The region to format.

Return Value:

    None

--*/

{
    static FORMAT_PARAMS formatParams;  // this is passed to other threads
                                        // it cannot be located on the stack
    PPERSISTENT_REGION_DATA regionData;
    int   doFormat;
    ULONG diskSize;
    PWSTR tempName,
          tempLabel,
          typeName;
    TCHAR label[100],
          fileSystem[10],
          message[300],
          msgProto[300],
          title[200];

    // Make sure format of this partition is allowed.  It is not allowed
    // if it is the boot partition (or sys partition on x86).

    if ((DeletionIsAllowed(RegionDescriptor)) != NO_ERROR) {
        ErrorDialog(MSG_CANT_FORMAT_WINNT);
        return;
    }

    // must have a drive letter

    regionData = PERSISTENT_DATA(RegionDescriptor);
    if (!regionData->DriveLetter) {
        ErrorDialog(MSG_CANT_FORMAT_NO_LETTER);
        return;
    }

    // can only do this is the dll is loaded.

    if (!LoadIfsDll()) {

        // could not load the dll

        ErrorDialog(MSG_CANT_LOAD_FMIFS);
        return;
    }

    // set up the parameters and get the information from the user.

    formatParams.RegionDescriptor = RegionDescriptor;
    formatParams.Result           = 0;
    formatParams.RegionData       = regionData;
    formatParams.Label            = (PUCHAR) label;
    formatParams.FileSystem       = (PUCHAR) fileSystem;
    formatParams.QuickFormat = formatParams.Cancel =
                               formatParams.DoubleSpace = FALSE;
    formatParams.TotalSpace       = formatParams.SpaceAvailable = 0;
    doFormat = DialogBoxParam(hModule,
                              MAKEINTRESOURCE(IDD_PARTITIONFORMAT),
                              hwndFrame,
                              FormatDlgProc,
                              (ULONG) &formatParams);
    if (doFormat) {

        // do an are you sure message.

        doFormat = ConfirmationDialog(MSG_CONFIRM_FORMAT,
                                      MB_ICONQUESTION | MB_YESNO);
        if (doFormat == IDYES) {

            if (IsDiskRemovable[RegionDescriptor->Disk]) {
                PWSTR   typeName,
                        volumeLabel;
                BOOLEAN volumeChanged = FALSE;

                if (!RegionDescriptor->PartitionNumber) {

                    // TODO: something has changed where the code gets to this
                    // point with an incorrect partition number - This happens
                    // when a partition is deleted and added to removable media.
                    // For removable media the partition number is always 1.

                    RegionDescriptor->PartitionNumber = 1;
                }
                if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                         RegionDescriptor->PartitionNumber,
                                         &volumeLabel,
                                         &typeName,
                                         &diskSize) == OK_STATUS) {

                    // Verify that this is still the same device.

                    if (typeName) {
                        if (!lstrcmpiW(typeName, L"raw")) {
                            Free(typeName);
                            typeName = Malloc((wcslen(wszUnknown) * sizeof(WCHAR)) + sizeof(WCHAR));
                            lstrcpyW(typeName, wszUnknown);
                        }
                    } else {
                        typeName = Malloc((wcslen(wszUnknown) * sizeof(WCHAR)) + sizeof(WCHAR));
                        lstrcpyW(typeName, wszUnknown);
                    }
                    if (regionData) {
                        if (regionData->VolumeLabel) {
                            if (wcscmp(regionData->VolumeLabel, volumeLabel)) {
                                volumeChanged = TRUE;
                            }
                        }
                        if (regionData->TypeName) {

                            // It is possible the region has no type
                            // or is of type "Unformatted".
                            // This says it is ok to format.

                            if (*regionData->TypeName) {

                                if (wcscmp(regionData->TypeName, wszUnformatted)) {

                                    // It has a type and it isn't
                                    // unformatted - see if it is
                                    // the same as before.

                                    if (wcscmp(regionData->TypeName, typeName)) {
                                        volumeChanged = TRUE;
                                    }
                                }
                            }
                        }
                    }

                    if (Disks[RegionDescriptor->Disk]->DiskSizeMB != (diskSize/1024)) {
                        volumeChanged = TRUE;
                    }
                    if (volumeChanged) {

                        ErrorDialog(MSG_VOLUME_CHANGED);

                        // since the user was told the volume changed,
                        // update the display.

                        SetCursor(hcurWait);
                        if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                                 RegionDescriptor->PartitionNumber,
                                                 &tempLabel,
                                                 &tempName,
                                                 &diskSize) == OK_STATUS) {
                            Free(typeName);
                            typeName = tempName;
                            Free(volumeLabel);
                            volumeLabel = tempLabel;
                        }
                        if (regionData->VolumeLabel) {
                            Free(regionData->VolumeLabel);
                        }
                        regionData->VolumeLabel = volumeLabel;
                        if (regionData->TypeName) {
                            Free(regionData->TypeName);
                        }
                        regionData->TypeName = typeName;
                        SetCursor(hcurNormal);
                        TotalRedrawAndRepaint();
                        return;
                    } else {
                        if (volumeLabel) {
                            Free(volumeLabel);
                        }
                        if (typeName) {
                            Free(typeName);
                        }
                    }
                }
            }

            // Insure the partition is not to big if the requested format
            // is FAT.

            if (!strcmpi(formatParams.FileSystem, "FAT")) {

                if (GetVolumeSizeMB(RegionDescriptor->Disk,
                                    RegionDescriptor->PartitionNumber,
                                    &diskSize)) {
                    if (diskSize > (4*1024)) {
                        ErrorDialog(MSG_TOO_BIG_FOR_FAT);
                        TotalRedrawAndRepaint();
                        return;
                    }
                } else {

                    // Just try the format anyway.

                }
            }

            // Initialize synchronization event to know when the
            // format thread is really complete.

            formatParams.ThreadIsDone = 0;

            // user still wants to format.

            DialogBoxParam(hModule,
                           MAKEINTRESOURCE(IDD_FORMATCANCEL),
                           hwndFrame,
                           CancelDlgProc,
                           (ULONG) &formatParams);
            if (formatParams.Result) {

                // the format failed.

                ErrorDialog(formatParams.Result);
            } else {

                LoadString(hModule,
                           IDS_FORMATCOMPLETE,
                           title,
                           sizeof(title)/sizeof(TCHAR));
                LoadString(hModule,
                           IDS_FORMATSTATS,
                           msgProto,
                           sizeof(msgProto)/sizeof(TCHAR));
                wsprintf(message,
                         msgProto,
                         formatParams.TotalSpace,
                         formatParams.SpaceAvailable);
                MessageBox(GetActiveWindow(),
                           message,
                           title,
                           MB_ICONINFORMATION | MB_OK);

            }

            // Synchronize with the format thread just in case
            // the user did a cancel and the format thread is
            // still buzy verifying 50MB or some such thing.
            // Rather than use an event this is a polling loop.

            SetCursor(hcurWait);
            while (!formatParams.ThreadIsDone) {
                Sleep(1000);
            }
            SetCursor(hcurNormal);

            // If the format was successful, update the volume
            // information in the data structures.

            if (!formatParams.Result) {

                // get the new label and FsType regardless of success of the
                // format (i.e. user cancel may have occurred, so this stuff
                // is not what it used to be even if the format failed.

                {
                    // force mount by filesystem.  This is done with the
                    // extra \ on the end of the path.  This must be done
                    // in order to get the FS type.  Otherwise the filesystem
                    // recognisor may allow the open without actually getting
                    // the file system involved.

                    char        ntDeviceName[100];
                    STATUS_CODE sc;
                    HANDLE_T    handle;

                    sprintf(ntDeviceName, "\\DosDevices\\%c:\\", regionData->DriveLetter);
                    sc = LowOpenNtName(ntDeviceName, &handle);
                    if (sc == OK_STATUS) {
                        LowCloseDisk(handle);
                    }
                }
                typeName = NULL;
                GetTypeName(RegionDescriptor->Disk, RegionDescriptor->PartitionNumber, &typeName);

                if (!typeName) {

                    // Failed to get the type after a cancel.  This means
                    // GetTypeName() could not open the volume for some reason.
                    // This has been seen on Alpha's and x86 with large
                    // hardware raid devices.  Exiting and starting
                    // over will get an FS type.  For now, don't change the
                    // data structures.

                    TotalRedrawAndRepaint();
                    return;
                }

                tempLabel = NULL;
                if (GetVolumeLabel(RegionDescriptor->Disk, RegionDescriptor->PartitionNumber, &tempLabel) == NO_ERROR) {

                    if (tempLabel) {
                        Free(regionData->VolumeLabel);
                        regionData->VolumeLabel = Malloc((lstrlenW(tempLabel) + 1) * sizeof(WCHAR));
                        lstrcpyW(regionData->VolumeLabel, tempLabel);
                    }
                } else {
                    *regionData->VolumeLabel = 0;
                }

                // update the type name.

                if (regionData->TypeName) {
                    Free(regionData->TypeName);
                    regionData->TypeName = typeName;
                }

                // update the file system type information for all
                // components of this region (i.e. fix up FT structures if
                // it is an FT item).  This is done via knowledge about multiple
                // selections as opposed to walking through the FtObject list.

                if (SelectionCount > 1) {
                    PPERSISTENT_REGION_DATA passedRegionData;
                    ULONG index;

                    // Need to update all involved.

                    passedRegionData = regionData;

                    for (index = 0; index < SelectionCount; index++) {
                        RegionDescriptor = &SELECTED_REGION(index);
                        regionData = PERSISTENT_DATA(RegionDescriptor);

                        if (regionData == passedRegionData) {
                            continue;
                        }

                        if (regionData->VolumeLabel) {
                            Free(regionData->VolumeLabel);
                            regionData->VolumeLabel = NULL;
                        }
                        if (tempLabel) {
                            regionData->VolumeLabel = Malloc((lstrlenW(tempLabel) + 1) * sizeof(WCHAR));
                            lstrcpyW(regionData->VolumeLabel, tempLabel);
                        }

                        if (regionData->TypeName) {
                            Free(regionData->TypeName);
                        }
                        regionData->TypeName = Malloc((lstrlenW(passedRegionData->TypeName) + 1) * sizeof(WCHAR));
                        lstrcpyW(regionData->TypeName, passedRegionData->TypeName);
                    }
                }

                if (tempLabel) {
                    Free(tempLabel);
                }
            }

            // force screen update.

            TotalRedrawAndRepaint();
        }
    }
}

VOID
LabelPartition(
    PREGION_DESCRIPTOR RegionDescriptor
    )

/*++

Routine Description:

    Insure the IFS Dll is loaded and start the dialog for label
    of a volume.

Arguments:

    RegionDescriptor - the region for the label.

Return Value:

    None

--*/

{
    int          doLabel;
    DWORD        ec;
    TCHAR        label[100];
    WCHAR        unicodeLabel[100];
    LABEL_PARAMS labelParams;
    WCHAR        driveLetter[4];
    PWSTR        tmpLabel;
    PPERSISTENT_REGION_DATA regionData;

    if (!LoadIfsDll()) {

        // could not load the Dll

        ErrorDialog(MSG_CANT_LOAD_FMIFS);
        return;
    }
    labelParams.RegionDescriptor = RegionDescriptor;
    labelParams.NewLabel = (LPTSTR)label;
    doLabel = DialogBoxParam(hModule,
                             MAKEINTRESOURCE(IDD_PARTITIONLABEL),
                             hwndFrame,
                             LabelDlgProc,
                             (ULONG) &labelParams);
    if (doLabel) {

        regionData = PERSISTENT_DATA(RegionDescriptor);

        if (IsDiskRemovable[RegionDescriptor->Disk]) {
            PWSTR   typeName,
                    volumeLabel;
            ULONG   diskSize;
            BOOLEAN volumeChanged = FALSE;

            if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                     RegionDescriptor->PartitionNumber,
                                     &volumeLabel,
                                     &typeName,
                                     &diskSize) == OK_STATUS) {
                // Verify that this is still the same device.

                if (regionData) {
                    if (regionData->VolumeLabel) {
                        if (wcscmp(regionData->VolumeLabel, volumeLabel)) {
                            volumeChanged = TRUE;
                        }
                    }
                    if (regionData->TypeName) {
                        if (wcscmp(regionData->TypeName, typeName)) {
                            volumeChanged = TRUE;
                        }
                    }
                }

                if (Disks[RegionDescriptor->Disk]->DiskSizeMB != (diskSize/1024)) {
                    volumeChanged = TRUE;
                }

                if (volumeChanged) {
                    PWSTR   tempName,
                            tempLabel;

                    ErrorDialog(MSG_VOLUME_CHANGED);

                    // since the user was told the volume changed,
                    // update the display.

                    SetCursor(hcurWait);
                    if (GetVolumeTypeAndSize(RegionDescriptor->Disk,
                                             RegionDescriptor->PartitionNumber,
                                             &tempLabel,
                                             &tempName,
                                             &diskSize) == OK_STATUS) {
                        Free(typeName);
                        typeName = tempName;
                        Free(volumeLabel);
                        volumeLabel = tempLabel;
                    }
                    if (regionData->VolumeLabel) {
                        Free(regionData->VolumeLabel);
                    }
                    regionData->VolumeLabel = volumeLabel;
                    if (regionData->TypeName) {
                        Free(regionData->TypeName);
                    }
                    regionData->TypeName = typeName;
                    SetCursor(hcurNormal);
                    TotalRedrawAndRepaint();
                    return;
                } else {
                    Free(volumeLabel);
                    Free(typeName);
                }
            }
        }
        driveLetter[1] = L':';
        driveLetter[2] = 0;
        driveLetter[0] = (WCHAR)regionData->DriveLetter;

        // convert to unicode - use variable doLabel as an index.

        setUnicode(label,
                   unicodeLabel);

        // perform the label.

        SetCursor(hcurWait);
        (*LabelRoutine)(driveLetter, unicodeLabel);

        ec = GetLastError();

        if (ec != NO_ERROR) {
            SetCursor(hcurNormal);
            ErrorDialog(ec);
            SetCursor(hcurWait);
        }

        // get the new label to be certain it took and update
        // the internal structures.

        if (GetVolumeLabel(RegionDescriptor->Disk, RegionDescriptor->PartitionNumber, &tmpLabel) == NO_ERROR) {
            Free(regionData->VolumeLabel);
            regionData->VolumeLabel = Malloc((lstrlenW(tmpLabel) + 1) * sizeof(WCHAR));
            lstrcpyW(regionData->VolumeLabel, tmpLabel);
        } else {
            *regionData->VolumeLabel = 0;
        }

        // update the label for all
        // components of this region (i.e. fix up FT structures if
        // it is an FT item).  This is done via knowledge about multiple
        // selections as opposed to walking through the FtObject list.

        if (SelectionCount > 1) {
            PPERSISTENT_REGION_DATA passedRegionData;
            ULONG index;

            // Need to update all involved.

            passedRegionData = regionData;

            for (index = 0; index < SelectionCount; index++) {
                RegionDescriptor = &SELECTED_REGION(index);
                regionData = PERSISTENT_DATA(RegionDescriptor);

                if (regionData == passedRegionData) {
                    continue;
                }

                if (regionData->VolumeLabel) {
                    Free(regionData->VolumeLabel);
                    regionData->VolumeLabel = NULL;
                }
                if (tmpLabel) {
                    regionData->VolumeLabel = Malloc((lstrlenW(tmpLabel) + 1) * sizeof(WCHAR));
                    lstrcpyW(regionData->VolumeLabel, tmpLabel);
                } else {
                    *regionData->VolumeLabel = 0;
                }
            }
        }
        if (tmpLabel) {
            Free(tmpLabel);
        }
        SetCursor(hcurNormal);

        // force screen update.

        TotalRedrawAndRepaint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\ntlow.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    ntlow.c

Abstract:

    This file contains the low-level I/O routines, implemented
    to run on NT.

Author:

    Ted Miller        (tedm)    8-Nov-1991

Revision History:

    Bob Rinne         (bobri)   2-Feb-1994
    Dynamic partitioning changes.

--*/


#include "fdisk.h"
#include <stdio.h>
#include <string.h>


STATUS_CODE
LowQueryFdiskPathList(
    OUT PCHAR  **PathList,
    OUT PULONG   ListLength
    )

/*++

Routine Description:

    This routine determines how many drives are present in the
    system and returns a list of Ascii strings for the names of
    each of the drives found.

    When a drive is located, a check is made to insure that the
    associated DosName for the physical drive is also present in
    the system.

Arguments:

    PathList   - pointer to a pointer for the list
    ListLength - the number of entries returned in the list

Return Value:

    Error status if there is a problem.

--*/

{
    HANDLE      dummyHandle;
    STATUS_CODE status;
    ULONG       count = 0;
    ULONG       i;
    char        buffer[100];
    PCHAR      *pathArray;

    while (1) {

        sprintf(buffer, "\\device\\harddisk%u", count);
        status = LowOpenDisk(buffer, &dummyHandle);

        // Only STATUS_OBJECT_PATH_NOT_FOUND can terminate the count.

        if (NT_SUCCESS(status)) {
            char dosNameBuffer[80];

            LowCloseDisk(dummyHandle);

            // Insure that the physicaldrive name is present

            sprintf(dosNameBuffer, "\\dosdevices\\PhysicalDrive%u", count);
            status = LowOpenNtName(dosNameBuffer, &dummyHandle);
            if (NT_SUCCESS(status)) {
                LowCloseDisk(dummyHandle);
            } else {

                // Not there, create it.

                sprintf(buffer, "\\device\\harddisk%u\\Partition0", count);
                DefineDosDevice(DDD_RAW_TARGET_PATH, (LPCTSTR) dosNameBuffer, (LPCTSTR) buffer);
            }
        } else if (status == STATUS_OBJECT_PATH_NOT_FOUND) {

            break;
        } else if (status == STATUS_ACCESS_DENIED) {

            return status;
        }
        count++;
    }

    pathArray = Malloc(count * sizeof(PCHAR));

    for (i=0; i<count; i++) {

        sprintf(buffer, "\\device\\harddisk%u", i);
        pathArray[i] = Malloc(lstrlenA(buffer)+1);
        strcpy(pathArray[i], buffer);
    }

    *PathList = pathArray;
    *ListLength = count;
    return OK_STATUS;
}


STATUS_CODE
LowFreeFdiskPathList(
    IN OUT  PCHAR*  PathList,
    IN      ULONG   ListLength
    )

/*++

Routine Description:

    Walk the provided list up to its length and free the memory
    allocated.  Upon completion, free the memory for the list
    itself.

Arguments:

    PathList   - pointer to base of path list
    ListLength - number of entries in the list

Return Value:

    Always OK_STATUS

--*/

{
    ULONG i;

    for (i=0; i<ListLength; i++) {
        FreeMemory(PathList[i]);
    }
    FreeMemory(PathList);
    return OK_STATUS;
}


STATUS_CODE
LowOpenNtName(
    IN PCHAR     Name,
    IN HANDLE_PT Handle
    )

/*++

Routine Description:

    This is an internal "Low" routine to handle open requests.

Arguments:

    Name - pointer to the NT name for the open.
    Handle - pointer for the handle returned.

Return Value:

    NT status

--*/

{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;
    ANSI_STRING       ansiName;
    UNICODE_STRING    unicodeName;

    RtlInitAnsiString(&ansiName, Name);
    status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &unicodeName;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    status = DmOpenFile(Handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);


    if (!NT_SUCCESS(status)) {

        FDLOG((1,"LowOpen: 1st open failed with 0x%x\n", status));

        // try a 2nd time to get around an FS glitch or a test
        // bug where this doesn't work on an attempt to delete a
        // partition

        Sleep(500);
        status = DmOpenFile(Handle,
                            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                            &oa,
                            &statusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_ALERT);
        FDLOG((1,"LowOpen: 2nd open 0x%x\n", status));
    }
    RtlFreeUnicodeString(&unicodeName);
    return status;
}


STATUS_CODE
LowOpenDriveLetter(
    IN CHAR      DriveLetter,
    IN HANDLE_PT Handle
    )

/*++

Routine Description:

    Given a drive letter, open it and return a handle.

Arguments:

    DriveLetter - the letter to open
    Handle      - a pointer to a handle

Return Value:

    NT status

--*/

{
    char        ntDeviceName[100];

    sprintf(ntDeviceName,
            "\\DosDevices\\%c:",
            DriveLetter);
    return LowOpenNtName(ntDeviceName, Handle);
}


STATUS_CODE
LowOpenPartition(
    IN  PCHAR     DevicePath,
    IN  ULONG     Partition,
    OUT HANDLE_PT Handle
    )

/*++

Routine Description:

    Construct the NT device name for the Partition value given
    and perform the NT APIs to open the device.

Arguments:

    DevicePath - the string to the device without the partition
                 portion of the name.  This is constructed using
                 the Partition value passed
    Partition  - the partion desired
    Handle     - pointer to a handle pointer for the result

Return Value:

    NT status

--*/

{
    char        ntDeviceName[100];

    sprintf(ntDeviceName,
            "%s\\partition%u",
            DevicePath,
            Partition);
    return LowOpenNtName(ntDeviceName, Handle);
}


STATUS_CODE
LowOpenDisk(
    IN  PCHAR     DevicePath,
    OUT HANDLE_PT DiskId
    )

/*++

Routine Description:

    Perform the NT actions to open a device.

Arguments:

    DevicePath - Ascii device name
    DiskId     - pointer to a handle pointer for the returned
                 handle value

Return Value:

    NT status

--*/

{
    return(LowOpenPartition(DevicePath, 0, DiskId));
}


STATUS_CODE
LowCloseDisk(
    IN HANDLE_T DiskId
    )

/*++

Routine Description:

    Close a disk handle.

Arguments:

    DiskId - the actual NT handle

Return Value:

    NT status

--*/

{
    return(DmClose(DiskId));
}


STATUS_CODE
LowLockDrive(
    IN HANDLE_T DiskId
    )

/*++

Routine Description:

    Perform the NT API to cause a volume to be locked.
    This is a File System device control.

Arguments:

    DiskId - the actual NT handle to the drive

Return Value:

    NT status

--*/

{
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;

    status = NtFsControlFile(DiskId,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             FSCTL_LOCK_VOLUME,
                             NULL,
                             0,
                             NULL,
                             0);

    if (!NT_SUCCESS(status)) {
            FDLOG((1, "LowLock: failed with 0x%x\n", status));
    }
    return status;
}


STATUS_CODE
LowUnlockDrive(
    IN HANDLE_T DiskId
    )

/*++

Routine Description:

    Perform the NT API to cause a volume to be unlocked.
    This is a File System device control.

Arguments:

    DiskId - the actual NT handle to the drive

Return Value:

    NT status

--*/

{
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;

    status = NtFsControlFile(DiskId,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             FSCTL_DISMOUNT_VOLUME,
                             NULL,
                             0,
                             NULL,
                             0);
    status = NtFsControlFile(DiskId,
                             0,
                             NULL,
                             NULL,
                             &statusBlock,
                             FSCTL_UNLOCK_VOLUME,
                             NULL,
                             0,
                             NULL,
                             0);
    return status;
}


STATUS_CODE
LowGetDriveGeometry(
    IN  PCHAR  Path,
    OUT PULONG TotalSectorCount,
    OUT PULONG SectorSize,
    OUT PULONG SectorsPerTrack,
    OUT PULONG Heads
    )

/*++

Routine Description:

    Routine collects information concerning the geometry
    of a specific drive.

Arguments:

    Path        - Ascii path name to get to disk object
                  this is not a full path, but rather
                  a path without the Partition indicator
                  \device\harddiskX
    TotalSectorCount- pointer to ULONG for result
    SectorSize      - pointer to ULONG for result
    SectorsPerTrack - pointer to ULONG for result
    Heads           - pointer to ULONG for result

Return Value:

    NT status

--*/

{
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY   diskGeometry;
    STATUS_CODE     status;
    HANDLE          handle;

    if ((status = LowOpenDisk(Path, &handle)) != OK_STATUS) {
        return status;
    }

    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                   NULL,
                                   0,
                                   &diskGeometry,
                                   sizeof(DISK_GEOMETRY));
    if (!NT_SUCCESS(status)) {
        return (STATUS_CODE)status;
    }
    LowCloseDisk(handle);

    *SectorSize       = diskGeometry.BytesPerSector;
    *SectorsPerTrack  = diskGeometry.SectorsPerTrack;
    *Heads            = diskGeometry.TracksPerCylinder;
    *TotalSectorCount = (RtlExtendedIntegerMultiply(diskGeometry.Cylinders,
                                                    *SectorsPerTrack * *Heads)).LowPart;
    return(OK_STATUS);
}


STATUS_CODE
LowGetDiskLayout(
    IN  PCHAR                      Path,
    OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout
    )

/*++

Routine Description:

    Perform the necessary NT API calls to get the drive
    layout from the disk and return it in a memory buffer
    allocated by this routine.

Arguments:

    Path        - Ascii path name to get to disk object
                  this is not a full path, but rather
                  a path without the Partition indicator
                  \device\harddiskX

    DriveLayout - pointer to pointer for the drive layout result

Return Value:

    NT status

--*/

{
    PDRIVE_LAYOUT_INFORMATION layout;
    IO_STATUS_BLOCK statusBlock;
    STATUS_CODE     status;
    ULONG           bufferSize;
    HANDLE          handle;

    bufferSize = sizeof(DRIVE_LAYOUT_INFORMATION)
               + (500 * sizeof(PARTITION_INFORMATION));

    if ((layout = AllocateMemory(bufferSize)) == NULL) {
        RETURN_OUT_OF_MEMORY;
    }

    if ((status = LowOpenDisk(Path, &handle)) != OK_STATUS) {
        FreeMemory(layout);
        return status;
    }

    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_DRIVE_LAYOUT,
                                   NULL,
                                   0,
                                   layout,
                                   bufferSize);
    LowCloseDisk(handle);

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_BAD_MASTER_BOOT_RECORD) {

            FDLOG((1,"LowGetDiskLayout: Disk device %s has bad MBR\n",Path));

            // Zero the drive layout information for the fdengine to process.

            RtlZeroMemory(layout, bufferSize);
        } else {
            FDLOG((0,"LowGetDiskLayout: Status %lx getting layout for disk device %s\n",status,Path));
            FreeMemory(layout);
            return status;
        }
    } else {

        FDLOG((2,"LowGetDiskLayout: layout received from ioctl for %s follows:\n",Path));
        LOG_DRIVE_LAYOUT(layout);
    }

    // Check to insure that the drive supports dynamic partitioning.

    *DriveLayout = layout;
    return OK_STATUS;
}


STATUS_CODE
LowSetDiskLayout(
    IN PCHAR                     Path,
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout
    )

/*++

Routine Description:

    Perform the NT API actions of opening Partition0 for
    the specified drive and setting the drive layout.

Arguments:

    Path        - Ascii path name to get to disk object
                  this is not a full path, but rather
                  a path without the Partition indicator
                  \device\harddiskX

    DriveLayout - new layout to set

Return Value:

    NT status

--*/

{
    IO_STATUS_BLOCK statusBlock;
    STATUS_CODE     status;
    HANDLE          handle;
    ULONG           bufferSize;

    if ((status = LowOpenDisk(Path, &handle)) != OK_STATUS) {

        return status;
    }  else {

        FDLOG((2, "LowSetDiskLayout: calling ioctl for %s, layout follows:\n", Path));
        LOG_DRIVE_LAYOUT(DriveLayout);
    }

    bufferSize = sizeof(DRIVE_LAYOUT_INFORMATION)
               + (  (DriveLayout->PartitionCount - 1)
                   * sizeof(PARTITION_INFORMATION));
    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_SET_DRIVE_LAYOUT,
                                   DriveLayout,
                                   bufferSize,
                                   DriveLayout,
                                   bufferSize);
    LowCloseDisk(handle);
    return status;
}


STATUS_CODE
LowWriteSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    IN  PVOID       Buffer
    )

/*++

Routine Description:

    Routine to write to a volume handle.  This routine
    insulates the NT issues concerning the call from the
    caller.

Arguments:

    VolumeId        - actually the NT handle.
    SectorSize      - used to calculate starting byte offset for I/O
    StartingSector  - starting sector for write.
    NumberOfSectors - size of I/O in sectors
    Buffer          - the location for the data

Return Value:

    Standard NT status values

--*/

{
    IO_STATUS_BLOCK statusBlock;
    LARGE_INTEGER   byteOffset;

    byteOffset = RtlExtendedIntegerMultiply(RtlConvertUlongToLargeInteger(StartingSector), (LONG)SectorSize);

    statusBlock.Status = 0;
    statusBlock.Information = 0;
    return(NtWriteFile(VolumeId,
                       0,
                       NULL,
                       NULL,
                       &statusBlock,
                       Buffer,
                       NumberOfSectors * SectorSize,
                       &byteOffset,
                       NULL));
}


STATUS_CODE
LowReadSectors(
    IN  HANDLE_T    VolumeId,
    IN  ULONG       SectorSize,
    IN  ULONG       StartingSector,
    IN  ULONG       NumberOfSectors,
    IN  PVOID       Buffer
    )

/*++

Routine Description:

    Routine to read from a volume handle.  This routine
    insulates the NT issues concerning the call from the
    caller.

Arguments:

    VolumeId        - actually the NT handle.
    SectorSize      - used to calculate starting byte offset for I/O
    StartingSector  - starting sector for write.
    NumberOfSectors - size of I/O in sectors
    Buffer          - the location for the data

Return Value:

    Standard NT status values

--*/

{
    IO_STATUS_BLOCK statusBlock;
    LARGE_INTEGER   byteOffset;

    byteOffset = RtlExtendedIntegerMultiply(RtlConvertUlongToLargeInteger(StartingSector), (LONG)SectorSize);

    statusBlock.Status = 0;
    statusBlock.Information = 0;
    return(NtReadFile(VolumeId,
                      0,
                      NULL,
                      NULL,
                      &statusBlock,
                      Buffer,
                      NumberOfSectors * SectorSize,
                      &byteOffset,
                      NULL));
}


STATUS_CODE
LowFtVolumeStatus(
    IN ULONG          Disk,
    IN ULONG          Partition,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    )

/*++

Routine Description:

    Open the requested partition and query the FT state.

Arguments:

    DriveLetter - the letter for the current state
    FtState     - a pointer to a location to return state
    NumberOfMembers - a pointer to a ULONG for number of members
                      in the FT set.

Return Value:

    Standard NT status values

--*/

{
    HANDLE             handle;
    STATUS_CODE        status;
    IO_STATUS_BLOCK    statusBlock;
    FT_SET_INFORMATION setInfo;

    status = LowOpenPartition(GetDiskName(Disk),
                              Partition,
                              &handle);

    if (status == OK_STATUS) {

        status = NtDeviceIoControlFile(handle,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       FT_QUERY_SET_STATE,
                                       NULL,
                                       0,
                                       &setInfo,
                                       sizeof(setInfo));
        LowCloseDisk(handle);

        if (status == OK_STATUS) {
            switch (setInfo.SetState) {
            case FtStateOk:
                *FtStatus = FtSetHealthy;
                break;

            case FtHasOrphan:
                switch (setInfo.Type) {
                case Mirror:
                    *FtStatus = FtSetBroken;
                    break;
                case StripeWithParity:
                    *FtStatus = FtSetRecoverable;
                    break;
                }
                break;

            case FtRegenerating:
                *FtStatus = FtSetRegenerating;
                break;

            case FtCheckParity:
                *FtStatus = FtSetInitializationFailed;
                break;

            case FtInitializing:
                *FtStatus = FtSetInitializing;
                break;

            case FtDisabled:

                // This will never happen.

                *FtStatus = FtSetDisabled;
                break;

            case FtNoCheckData:
            default:

                // BUGBUG: there is no mapping here.

                *FtStatus = FtSetHealthy;
                break;
            }
            *NumberOfMembers = setInfo.NumberOfMembers;
        }
    } else {

        // If the FT set could not be opened, then it must be
        // disabled if the return code is "No such device".

        if (status == 0xc000000e) {
            *FtStatus = FtSetDisabled;
            status = OK_STATUS;
        }
    }

    // Always update the state to the caller.

    return status;
}


STATUS_CODE
LowFtVolumeStatusByLetter(
    IN CHAR           DriveLetter,
    IN PFT_SET_STATUS FtStatus,
    IN PULONG         NumberOfMembers
    )

/*++

Routine Description:

    Open the requested drive letter and query the FT state.

Arguments:

    DriveLetter - the letter for the current state
    FtState     - a pointer to a location to return state
    NumberOfMembers - a pointer to a ULONG for number of members
                      in the FT set.

Return Value:

    Standard NT status values

--*/

{
    HANDLE             handle;
    STATUS_CODE        status;
    IO_STATUS_BLOCK    statusBlock;
    FT_SET_INFORMATION setInfo;

    *NumberOfMembers = 1;
    status = LowOpenDriveLetter(DriveLetter,
                                &handle);

    if (status == OK_STATUS) {

        status = NtDeviceIoControlFile(handle,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       FT_QUERY_SET_STATE,
                                       NULL,
                                       0,
                                       &setInfo,
                                       sizeof(setInfo));
        LowCloseDisk(handle);

        if (status == OK_STATUS) {
            switch (setInfo.SetState) {
            case FtStateOk:
                *FtStatus = FtSetHealthy;
                break;

            case FtHasOrphan:
                switch (setInfo.Type) {
                case Mirror:
                    *FtStatus = FtSetBroken;
                    break;
                case StripeWithParity:
                    *FtStatus = FtSetRecoverable;
                    break;
                }
                break;

            case FtRegenerating:
                *FtStatus = FtSetRegenerating;
                break;

            case FtCheckParity:
                *FtStatus = FtSetInitializationFailed;
                break;

            case FtInitializing:
                *FtStatus = FtSetInitializing;
                break;

            case FtDisabled:

                // This will never happen.

                *FtStatus = FtSetDisabled;
                break;

            case FtNoCheckData:
            default:

                // BUGBUG: there is no mapping here.

                *FtStatus = FtSetHealthy;
                break;
            }
            *NumberOfMembers = setInfo.NumberOfMembers;
        }
    } else {

        // If the FT set could not be opened, then it must be
        // disabled if the return code is "No such device".

        if (status == 0xc000000e) {
            *FtStatus = FtSetDisabled;
            status = OK_STATUS;
        }
    }

    // Always update the state to the caller.

    return status;
}



#define NUMBER_OF_HANDLES_TRACKED 500
HANDLE OpenHandleArray[NUMBER_OF_HANDLES_TRACKED];
BOOLEAN DmFirstTime = TRUE;
ULONG   HandleHighWaterMark = 0;

NTSTATUS
DmOpenFile(
    OUT PHANDLE           FileHandle,
    IN ACCESS_MASK        DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK  IoStatusBlock,
    IN ULONG              ShareAccess,
    IN ULONG              OpenOptions
    )

/*++

Routine Description:

    A debugging aid to track open and closes of partitions.

Arguments:

    Same as for NtOpenFile()

Return Value:

    Same as for NtOpenFile()

--*/

{
    ULONG    index;
    NTSTATUS status;

    if (DmFirstTime) {
        DmFirstTime = FALSE;
        for (index = 0; index < NUMBER_OF_HANDLES_TRACKED; index++) {
            OpenHandleArray[index] = (HANDLE) 0;
        }
    }

    status = NtOpenFile(FileHandle,
                        DesiredAccess,
                        ObjectAttributes,
                        IoStatusBlock,
                        ShareAccess,
                        OpenOptions);
    if (NT_SUCCESS(status)) {
        for (index = 0; index < NUMBER_OF_HANDLES_TRACKED; index++) {
            if (OpenHandleArray[index] == (HANDLE) 0) {
                OpenHandleArray[index] = *FileHandle;

                if (index > HandleHighWaterMark) {
                    HandleHighWaterMark = index;
                }
                break;
            }
        }
    }
    return status;
}


NTSTATUS
DmClose(
    IN HANDLE Handle
    )

/*++

Routine Description:

    A debugging aid for tracking open and closes

Arguments:

    Same as for NtClose()

Return Value:

    Same as for NtClose()

--*/

{
    ULONG index;

    for (index = 0; index < NUMBER_OF_HANDLES_TRACKED; index++) {
        if (OpenHandleArray[index] == Handle) {
            OpenHandleArray[index] = (HANDLE) 0;
            break;
        }
    }

    return NtClose(Handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\network.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains the set of routines that support updating network
    drive shares when adding and deleting drive letters.

Author:

    Bob Rinne (bobri)  12/26/94

Environment:

    User process.

Notes:

Revision History:

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <winbase.h>
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <lm.h>

// Data area to hold the permissions that are to be assigned to the
// administrative shares C$, D$, etc.  This is obtained during initialization
// and not changed, just used when a new administrator share needes to
// be made.

LPBYTE ShareInformationBuffer;

// Only perform network actions if this value is true.  This value
// is set if the initialization of this module completes successfully.

BOOLEAN NetworkEnabled;


VOID
NetworkInitialize(
    )

/*++

Routine Description:

    Intialize the permissions constants for any new administrator
    driver letter shares.

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR           shareName[4];
    NET_API_STATUS  status;
    PSHARE_INFO_502 info;
    LPTSTR          string;

    shareName[1] = (WCHAR) '$';
    shareName[2] = (WCHAR) 0;

    for (shareName[0] = (WCHAR) 'C'; shareName[0] <= (WCHAR) 'Z'; shareName[0]++) {

        // Since windisk is still built as a non-unicode application,
        // the parameter "shareName" must be unicode, but the prototype
        // specifies that it is a (char *).  Do the typecast to remove
        // warnings.

         status = NetShareGetInfo(NULL,
                                  (char *) shareName,
                                  502,
                                  &ShareInformationBuffer);
         if (status == NERR_Success) {

             // Update the remarks and password to be NULL.

             info = (PSHARE_INFO_502) ShareInformationBuffer;
             string = info->shi502_remark;
             if (string) {
                 *string = (TCHAR) 0;
             }
             string = info->shi502_passwd;
             if (string) {
                 *string = (TCHAR) 0;
             }

             // Network shares are to be updated.

             NetworkEnabled = TRUE;
             return;
         }
    }

    // Can't find any network shares - do not attempt updates
    // of administrator shares.

    NetworkEnabled = FALSE;
}

VOID
NetworkShare(
    IN LPCTSTR DriveLetter
    )

/*++

Routine Description:

    Given a drive letter, construct the default administrator share
    for the letter.  This is the C$, D$, etc share for the drive.

Arguments:

    DriveLetter - the drive letter to share.

Return Value:

    None

--*/

{
    NET_API_STATUS  status;
    PSHARE_INFO_502 info;
    LPTSTR          string;

    if (NetworkEnabled) {
        info = (PSHARE_INFO_502) ShareInformationBuffer;

        // Set up the new network name.

        string = info->shi502_netname;
        *string = *DriveLetter;

        // Set up the path.  All that need be added is the drive letter
        // the rest of the path (":\") is already in the structure.

        string = info->shi502_path;
        *string = *DriveLetter;

        status = NetShareAdd(NULL,
                             502,
                             ShareInformationBuffer,
                             NULL);
    }
}


VOID
NetworkRemoveShare(
    IN LPCTSTR DriveLetter
    )

/*++

Routine Description:

    Remove the administrator share for the given letter.

Arguments:

    DriveLetter - the drive letter to share.

Return Value:

    None

--*/

{
    NET_API_STATUS status;
    WCHAR shareName[4];

    if (NetworkEnabled) {
        shareName[0] = (WCHAR) *DriveLetter;
        shareName[1] = (WCHAR) '$';
        shareName[2] = (WCHAR) 0;

        // Since windisk is still built as a non-unicode application,
        // the parameter "shareName" must be unicode, but the prototype
        // specifies that it is a (char *).  Do the typecast to remove
        // warnings.

        status = NetShareDel(NULL,
                             (char *) shareName,
                             0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\fd_nt.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    fd_nt.c

Abstract:

    This module wraps fdisk engine functions.  This is done
    to avoid having files that include both the full windows
    and the full nt include file sets.

    Functions that manipulate engine structures (REGIONs, for example)
    are also placed here.

    This file is targeted at NT, not Windows.

Author:

    Ted Miller        (tedm)    5-Dec-1991

Revision History:

    Misc cleanup      (BobRi)   22-Jan-1994

--*/

#include "fdisk.h"
#include <string.h>
#include <stdio.h>

// These partition ID's are for systems recognized by WINDISK,
// even though they don't appear in ntdddisk.h.

#define PARTITION_OS2_BOOT              0xa
#define PARTITION_EISA                  0x12


WCHAR UnicodeSysIdName[100];
BYTE StringBuffer[100];

// Pagefile support structures.

typedef struct _PAGEFILE_LOCATION {
    struct _PAGEFILE_LOCATION *Next;
    CHAR                       DriveLetter;
} PAGEFILE_LOCATION, *PPAGEFILE_LOCATION;

PPAGEFILE_LOCATION PagefileHead = NULL;

// For some reason the file systems don't like being accessed shortly after
// a format or lock event.

#define SLEEP_TIME (1000*2) // 2 seconds


PWSTR
GetWideSysIDName(
    IN UCHAR SysID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ANSI_STRING    ansiString;
    UNICODE_STRING unicodeString;
    DWORD          stringId;

    // Get the name, which is a byte-string.

    switch (SysID) {

    case PARTITION_ENTRY_UNUSED:
        stringId = IDS_PARTITION_FREE;
        break;

    case PARTITION_XENIX_1:
        stringId = IDS_PARTITION_XENIX1;
        break;

    case PARTITION_XENIX_2:
        stringId = IDS_PARTITION_XENIX2;
        break;

    case PARTITION_OS2_BOOT:
        stringId = IDS_PARTITION_OS2_BOOT;
        break;

    case PARTITION_EISA:
        stringId = IDS_PARTITION_EISA;
        break;

    case PARTITION_UNIX:
        stringId = IDS_PARTITION_UNIX;
        break;

    case PARTITION_PREP:
#ifdef _PPC_
        stringId = IDS_PARTITION_POWERPC;
#else

        // If not on a PPC platform, assume this is Eisa related

        stringId = IDS_PARTITION_EISA;
#endif
        break;

    default:
        stringId = IDS_UNKNOWN;
        break;
    }

    LoadString(hModule, stringId, StringBuffer, sizeof(StringBuffer));
    RtlInitAnsiString(&ansiString, StringBuffer);

    //
    // Convert to Unicode
    //

    unicodeString.Buffer = UnicodeSysIdName;
    unicodeString.MaximumLength = sizeof(UnicodeSysIdName);
    RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
    return UnicodeSysIdName;
}


ULONG
MyDiskRegistryGet(
    OUT PDISK_REGISTRY *DiskRegistry
    )

/*++

Routine Description:

    Allocate memory for the size of the disk registry, obtain
    the registry contents (if any) and return the pointer to the
    allocated memory.

Arguments:

    A pointer to a disk registry pointer.

Return Value:

    status indicating success or failure.

--*/

{
    ULONG          length;
    PDISK_REGISTRY diskRegistry;
    NTSTATUS       status;


    while (((status = DiskRegistryGet(NULL, &length)) == STATUS_NO_MEMORY)
      ||    (status == STATUS_INSUFFICIENT_RESOURCES))
    {
        ConfirmOutOfMemory();
    }

    if (!NT_SUCCESS(status)) {
        return EC(status);
    }

    diskRegistry = Malloc(length);

    while (((status = DiskRegistryGet(diskRegistry, &length)) == STATUS_NO_MEMORY)
      ||    (status == STATUS_INSUFFICIENT_RESOURCES))
    {
        ConfirmOutOfMemory();
    }

    if (NT_SUCCESS(status)) {

        LOG_DISK_REGISTRY("MyDiskRegistryGet", diskRegistry);
        *DiskRegistry = diskRegistry;
    }
    return EC(status);
}


ULONG
FormDiskSignature(
    VOID
    )

/*++

Routine Description:

    Return a ULONG disk signature.  This is derived from the current
    system time.

Arguments:

    None

Return Value:

    A 32-bit signature

--*/

{
    LARGE_INTEGER time;
    static ULONG  baseSignature = 0;

    if (!baseSignature) {

        NtQuerySystemTime(&time);
        time.QuadPart = time.QuadPart >> 16;
        baseSignature = time.LowPart;
    }
    return baseSignature++;
}


BOOLEAN
GetVolumeSizeMB(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PULONG Size
    )

/*++

Routine Description:

    Given a disk and a partition, query the "volume" to get its size.
    By performing the query on the 1st partition of a potential FT set,
    the total size of the set will be returned.  If the partition isn't
    an FT set, it will work too.

Arguments:

    Disk - the disk number
    Partition - the partition number
    Size - the size of the "volume"

Return Value:

    TRUE - a size was returned.
    FALSE - something failed in getting the size.

--*/

{
    BOOLEAN                     retValue = FALSE;
    IO_STATUS_BLOCK             statusBlock;
    HANDLE                      handle;
    STATUS_CODE                 sc;
    PARTITION_INFORMATION       partitionInfo;
    LARGE_INTEGER               partitionLength;

    *Size = 0;
    sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);
    if (sc == OK_STATUS) {

        sc = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_PARTITION_INFO,
                                   NULL,
                                   0,
                                   &partitionInfo,
                                   sizeof(PARTITION_INFORMATION));

        if (sc == OK_STATUS) {

            // Convert to MB

            partitionLength.QuadPart = partitionInfo.PartitionLength.QuadPart >> 20;
            *Size = partitionLength.LowPart;
            retValue = TRUE;
        }
        LowCloseDisk(handle);
    }
    return retValue;
}


ULONG
GetVolumeTypeAndSize(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label,
    OUT PWSTR *Type,
    OUT PULONG Size
    )

/*++

Routine Description:

    Given a disk and partition number, determine its size, label and file
    system type.  This routine will allocate the space for label and file
    system type.  It is the responsibility of the caller to free this memory.

Arguments:

    Disk - the disk number
    Partition - the partition number
    Label - a pointer to a pointer for a WCHAR string to contain the label
    Type - a pointer to a pointer for a WCHAR string to contain the file system
           type.
    Size - a pointer to a ULONG for the size of the disk in KB.

Return Value:

    OK_STATUS - everything was performed.
    !OK_STATUS - the error code that was returned in the process of performing
                 this work.

--*/

{
    IO_STATUS_BLOCK             statusBlock;
    HANDLE                      handle;
    unsigned char               buffer[256];
    PWSTR                       label,
                                name;
    ULONG                       length;
    DISK_GEOMETRY               diskGeometry;
    STATUS_CODE                 sc;
    BOOLEAN                     firstTime = TRUE;
    PFILE_FS_VOLUME_INFORMATION labelInfo = (PFILE_FS_VOLUME_INFORMATION)buffer;
    PFILE_FS_ATTRIBUTE_INFORMATION info = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;

    while (1) {
        sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);
        if (sc == OK_STATUS) {

            sc = NtQueryVolumeInformationFile(handle,
                                              &statusBlock,
                                              buffer,
                                              sizeof(buffer),
                                              FileFsVolumeInformation);
            if (sc == OK_STATUS) {

                length = labelInfo->VolumeLabelLength;
                labelInfo->VolumeLabel[length/sizeof(WCHAR)] = 0;
                length = (length+1) * sizeof(WCHAR);

                label = Malloc(length);
                RtlMoveMemory(label, labelInfo->VolumeLabel, length);
            } else {

                label = Malloc(sizeof(WCHAR));
                *label = 0;
            }
            *Label = label;

            if (sc == OK_STATUS) {
                sc = NtQueryVolumeInformationFile(handle,
                                                  &statusBlock,
                                                  buffer,
                                                  sizeof(buffer),
                                                  FileFsAttributeInformation);
                if (sc == OK_STATUS) {

                    length = info->FileSystemNameLength;
                    info->FileSystemName[length/sizeof(WCHAR)] = 0;
                    length = (length+1)*sizeof(WCHAR);
                    name = Malloc(length);
                    RtlMoveMemory(name, info->FileSystemName, length);
                } else {

                    name = Malloc(sizeof(WCHAR));
                    *name = 0;
                }
                *Type = name;
            }

            if (sc == OK_STATUS) {
                sc = NtDeviceIoControlFile(handle,
                                           0,
                                           NULL,
                                           NULL,
                                           &statusBlock,
                                           IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                           NULL,
                                           0,
                                           (PVOID)&diskGeometry,
                                           sizeof(diskGeometry));
                if (NT_SUCCESS(sc)) {
                    LARGE_INTEGER sizeInBytes;
                    ULONG         cylinderBytes;

                    cylinderBytes = diskGeometry.TracksPerCylinder *
                                    diskGeometry.SectorsPerTrack *
                                    diskGeometry.BytesPerSector;

                    sizeInBytes.QuadPart = diskGeometry.Cylinders.QuadPart * cylinderBytes;

                    // Now convert everything to KB

                    sizeInBytes.QuadPart = sizeInBytes.QuadPart >> 10;
                    *Size = (ULONG) sizeInBytes.LowPart;
                }
            }
            DmClose(handle);
            sc = OK_STATUS;
            break;
        } else {
            if (firstTime) {
                firstTime = FALSE;
            } else {
                break;
            }
            Sleep(SLEEP_TIME);
        }
    }

    return EC(sc);
}

ULONG
GetVolumeLabel(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Label
    )

/*++

Routine Description:

    Given a disk number and a partition number return the volume label (if
    any).

Arguments:

    Disk - the disk number
    Partition - the partition number
    Label - a pointer to a pointer for a WCHAR string to contain the label

Return Value:

    OK_STATUS - everything was performed.
    !OK_STATUS - the error code that was returned in the process of performing
                 this work.
--*/

{
    IO_STATUS_BLOCK             statusBlock;
    HANDLE                      handle;
    unsigned char               buffer[256];
    PWSTR                       label;
    ULONG                       length;
    STATUS_CODE                 sc;
    BOOLEAN                     firstTime = TRUE;
    PFILE_FS_VOLUME_INFORMATION labelInfo = (PFILE_FS_VOLUME_INFORMATION)buffer;

    while (1) {
        sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);
        if (sc == OK_STATUS) {

            sc = NtQueryVolumeInformationFile(handle,
                                              &statusBlock,
                                              buffer,
                                              sizeof(buffer),
                                              FileFsVolumeInformation);
            DmClose(handle);
            if (sc == OK_STATUS) {

                length = labelInfo->VolumeLabelLength;
                labelInfo->VolumeLabel[length/sizeof(WCHAR)] = 0;
                length = (length+1) * sizeof(WCHAR);

                label = Malloc(length);
                RtlMoveMemory(label, labelInfo->VolumeLabel, length);
            } else {

                label = Malloc(sizeof(WCHAR));
                sc = OK_STATUS;
                *label = 0;
            }
            *Label = label;
            break;
        } else {
            if (firstTime) {
                firstTime = FALSE;
            } else {
                *Label = NULL;
                break;
            }
            Sleep(SLEEP_TIME);
        }
    }
    return EC(sc);
}


ULONG
GetTypeName(
    IN  ULONG  Disk,
    IN  ULONG  Partition,
    OUT PWSTR *Name
    )

/*++

Routine Description:

    Given a disk number and partition number return the file system type
    string.

Arguments:

    Disk - the disk number
    Partition - the partition number
    Name - a pointer to a pointer for a WCHAR string to contain the file system
           type.

Return Value:

    OK_STATUS - everything was performed.
    !OK_STATUS - the error code that was returned in the process of performing
                 this work.
--*/

{
    PWSTR                          name;
    STATUS_CODE                    sc;
    HANDLE                         handle;
    unsigned char                  buffer[256];
    IO_STATUS_BLOCK                statusBlock;
    ULONG                          length;
    BOOLEAN                        firstTime = TRUE;
    PFILE_FS_ATTRIBUTE_INFORMATION info = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;

    // For some reason, the file systems believe they are locked or need
    // to be verified after formats and the like.  Therefore this is attempted
    // twice before it actually gives up.

    while (1) {
        sc = LowOpenPartition(GetDiskName(Disk), Partition, &handle);

        if (sc == OK_STATUS) {
            sc = NtQueryVolumeInformationFile(handle,
                                              &statusBlock,
                                              buffer,
                                              sizeof(buffer),
                                              FileFsAttributeInformation);
            DmClose(handle);
            if (sc == OK_STATUS) {

                length = info->FileSystemNameLength;
                info->FileSystemName[length/sizeof(WCHAR)] = 0;
                length = (length+1)*sizeof(WCHAR);
                name = Malloc(length);
                RtlMoveMemory(name, info->FileSystemName, length);
            } else {

                name = Malloc(sizeof(WCHAR));
                *name = 0;
                sc = OK_STATUS;
            }
            *Name = name;
            break;
        } else {
            if (firstTime) {
                firstTime = FALSE;
            } else {
                break;
            }
            Sleep(SLEEP_TIME);
        }
    }

    return EC(sc);
}


BOOLEAN
IsRemovable(
    IN ULONG DiskNumber
    )

/*++

Routine Description:

    This function determines whether the specified physical
    disk is removable.

Arguments:

    DiskNumber  --  The Physical Disk Number of the disk in question.

Return Value:

    TRUE if the disk is removable.

--*/

{
    STATUS_CODE     sc;
    NTSTATUS        status;
    HANDLE          handle;
    DISK_GEOMETRY   diskGeometry;
    IO_STATUS_BLOCK statusBlock;
    PCHAR           name;

    name = GetDiskName(DiskNumber);
    sc = LowOpenDisk(name, &handle);

    if (sc == OK_STATUS) {
        status = NtDeviceIoControlFile(handle,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                       NULL,
                                       0,
                                       (PVOID)&diskGeometry,
                                       sizeof(diskGeometry));
        LowCloseDisk(handle);
        if (NT_SUCCESS(status)) {
            if (diskGeometry.MediaType == RemovableMedia) {
                char  ntDeviceName[100];

                // Do a dismount/force mount sequence to make sure
                // the media hasn't changed since last mount.
                // Dismount partition 1 by lock/unlock/close.

                sprintf(ntDeviceName, "%s\\Partition1", name);
                status= LowOpenNtName(ntDeviceName, &handle);
                if (NT_SUCCESS(status)) {

                    LowLockDrive(handle);
                    LowUnlockDrive(handle);
                    LowCloseDisk(handle);

                    // Now force the mount by opening the device with a '\'
                    // This is done on partition 1 of the device.

                    sprintf(ntDeviceName, "%s\\Partition1\\", name);
                    status= LowOpenNtName(ntDeviceName, &handle);
                    if (NT_SUCCESS(status)) {
                        LowCloseDisk(handle);
                    }
                }
                return TRUE;
            }
        }
    }
    return FALSE;
}


ULONG
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    static WCHAR      targetNameBuffer[50];
    UNICODE_STRING    sourceName,
                      targetName;
    NTSTATUS          status;
    OBJECT_ATTRIBUTES attributes;
    HANDLE            handle;


    RtlInitUnicodeString(&sourceName, SourceNameStr);
    InitializeObjectAttributes(&attributes, &sourceName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenSymbolicLinkObject(&handle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &attributes);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(targetNameBuffer, 50 * sizeof(WCHAR));
        targetName.Buffer = targetNameBuffer;
        targetName.MaximumLength = sizeof(targetNameBuffer);
        status = NtQuerySymbolicLinkObject(handle, &targetName, NULL);
        NtClose(handle);
    }

    if (NT_SUCCESS(status)) {
        *LinkTarget = targetName.Buffer;
    } else {
        *LinkTarget = NULL;
    }

    return EC(status);
}


#include "bootmbr.h"

#if X86BOOTCODE_SIZE < MBOOT_CODE_SIZE
#error Something is wrong with the boot code (it's too small)!
#endif


ULONG
MasterBootCode(
    IN ULONG   Disk,
    IN ULONG   Signature,
    IN BOOLEAN SetBootCode,
    IN BOOLEAN SetSignature
    )

/*++

Routine Description:

    If the zero sector of the disk does not have a valid MBR
    signature (i.e. AA55), update it such that it has a valid
    MBR and fill in the disk signature and bootcode in the
    process.

Arguments:

    Disk - the disk ordinal to be affected
    SetSignature - if TRUE update the disk signature
    Signature    - the disk signature for the update

Return Value:

    status

--*/

{
    HANDLE      handle;
    STATUS_CODE status;
    PUCHAR      unalignedSectorBuffer,
                sectorBuffer;
    ULONG       bps,
                dummy,
                i;
    BOOLEAN     writeIt;
    PCHAR       diskName = GetDiskName(Disk);

#ifndef     max
#define     max(a,b) ((a > b) ? a : b)
#endif

    if (SetBootCode) {
        writeIt = FALSE;

        // allocate sector buffer

        status = LowGetDriveGeometry(diskName, &dummy, &bps, &dummy, &dummy);
        if (status != OK_STATUS) {
            return EC(status);
        }
        if (bps < 512) {
            bps = 512;
        }
        unalignedSectorBuffer = Malloc(2*bps);
        sectorBuffer = (PUCHAR)(((ULONG)unalignedSectorBuffer+bps) & ~(bps-1));

        // open entire disk (partition 0)

        if ((status = LowOpenDisk(diskName, &handle)) != OK_STATUS) {
            return EC(status);
        }

        // read (at least) first 512 bytes

        status = LowReadSectors(handle, bps, 0, 1, sectorBuffer);
        if (status == OK_STATUS) {

            if ((sectorBuffer[MBOOT_SIG_OFFSET+0] != MBOOT_SIG1)
            ||  (sectorBuffer[MBOOT_SIG_OFFSET+1] != MBOOT_SIG2)) {

                // xfer boot code into sectorBuffer

                for (i=0; i<MBOOT_CODE_SIZE; i++) {
                    sectorBuffer[i] = x86BootCode[i];
                }

                // wipe partition table

                for (i=MBOOT_CODE_SIZE; i<MBOOT_SIG_OFFSET; i++) {
                    sectorBuffer[i] = 0;
                }

                // set the signature

                sectorBuffer[MBOOT_SIG_OFFSET+0] = MBOOT_SIG1;
                sectorBuffer[MBOOT_SIG_OFFSET+1] = MBOOT_SIG2;

                writeIt = TRUE;
            }

            if (writeIt) {
                status = LowWriteSectors(handle, bps, 0, 1, sectorBuffer);
            }
        }

        LowCloseDisk(handle);
        Free(unalignedSectorBuffer);
    }

    if (SetSignature) {
        PDRIVE_LAYOUT_INFORMATION layout;

        // Use the IOCTL to set the signature.  This code really does
        // not know where the MBR exists.  (ezDrive extensions).

        status = LowGetDiskLayout(diskName, &layout);

        if (status == OK_STATUS) {
            layout->Signature = Signature;
            LowSetDiskLayout(diskName, layout);
        }
    }

    return EC(status);
}


ULONG
UpdateMasterBootCode(
    IN ULONG   Disk
    )

/*++

Routine Description:

    This routine updates the zero sector of the disk to insure that boot
    code is present.

Arguments:

    Disk - the disk number onto which to put the boot code.

Return Value:

    status

--*/

{
    HANDLE      handle;
    STATUS_CODE status;
    PUCHAR      unalignedSectorBuffer,
                sectorBuffer;
    ULONG       bps,
                dummy,
                i;
    PCHAR       diskName = GetDiskName(Disk);

#ifndef     max
#define     max(a,b) ((a > b) ? a : b)
#endif

    // allocate sector buffer

    status = LowGetDriveGeometry(diskName, &dummy, &bps, &dummy, &dummy);
    if (status != OK_STATUS) {
        return EC(status);
    }
    if (bps < 512) {
        bps = 512;
    }
    unalignedSectorBuffer = Malloc(2*bps);
    sectorBuffer = (PUCHAR)(((ULONG)unalignedSectorBuffer+bps) & ~(bps-1));

    // open entire disk (partition 0)

    if ((status = LowOpenDisk(diskName, &handle)) != OK_STATUS) {
        return EC(status);
    }

    // read (at least) first 512 bytes

    status = LowReadSectors(handle, bps, 0, 1, sectorBuffer);
    if (status == OK_STATUS) {


        // xfer boot code into sectorBuffer.  This avoids changing the
        // disk signature and the partition table information.

        for (i=0; i<MBOOT_CODE_SIZE; i++) {
            sectorBuffer[i] = x86BootCode[i];
        }

        status = LowWriteSectors(handle, bps, 0, 1, sectorBuffer);
    }

    LowCloseDisk(handle);

    // free the sector buffer

    Free(unalignedSectorBuffer);
    return EC(status);
}


#if i386

VOID
MakePartitionActive(
    IN PREGION_DESCRIPTOR DiskRegionArray,
    IN ULONG              RegionCount,
    IN ULONG              RegionIndex
    )

/*++

Routine Description:

    Update the information in the internal structures to indicate
    that the specified partition is active.

Arguments:

    DiskRegionArray
    RegionCount
    RegionIndex

Return Value:

    None

--*/

{
    unsigned i;

    for (i=0; i<RegionCount; i++) {
        if (DiskRegionArray[i].RegionType == REGION_PRIMARY) {
            DiskRegionArray[i].Active = FALSE;
            SetPartitionActiveFlag(&DiskRegionArray[i], FALSE);
        }
    }
    DiskRegionArray[RegionIndex].Active = (BOOLEAN)0x80;
    SetPartitionActiveFlag(&DiskRegionArray[RegionIndex], 0x80);
}

#endif

VOID
LoadExistingPageFileInfo(
    IN VOID
    )

/*++

Routine Description:

    This routine finds all pagefiles in the system and updates the internal
    structures.

Arguments:

    None

Return Values:

    None

--*/

{
    NTSTATUS                     status;
    SYSTEM_INFO                  sysInfo;
    UCHAR                        genericBuffer[0x10000];
    PSYSTEM_PAGEFILE_INFORMATION pageFileInfo;
    ANSI_STRING                  ansiPageFileName;
    PPAGEFILE_LOCATION           pageFileListEntry;
    PCHAR                        p;

    GetSystemInfo(&sysInfo);

    status = NtQuerySystemInformation(SystemPageFileInformation,
                                      genericBuffer,
                                      sizeof(genericBuffer),
                                      NULL);
    if (!NT_SUCCESS(status)) {

        // It's possible that this call will fail if the
        // the system is running without ANY paging files.

        return;
    }

    pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) genericBuffer;

    for (;;) {

        RtlUnicodeStringToAnsiString(&ansiPageFileName,
                                     &pageFileInfo->PageFileName,
                                     TRUE);

        // Since the format of the pagefile name generally
        // looks something like "\DosDevices\h:\pagefile.sys",
        // just use the first character before the colon
        // and assume that's the drive letter.

        p = strchr(_strlwr(ansiPageFileName.Buffer), ':');

        if ((p-- != NULL) && (*p >= 'a') && (*p <= 'z')) {

            pageFileListEntry = Malloc(sizeof(PAGEFILE_LOCATION));
            if (pageFileListEntry) {
                if (PagefileHead) {
                    pageFileListEntry->Next = PagefileHead;
                } else {
                    PagefileHead = pageFileListEntry;
                    pageFileListEntry->Next = NULL;
                }
                pageFileListEntry->DriveLetter = *p;
            }

        }

        RtlFreeAnsiString(&ansiPageFileName);

        if (pageFileInfo->NextEntryOffset == 0) {
            break;
        }

        pageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR) pageFileInfo
                      + pageFileInfo->NextEntryOffset);
    }
}

BOOLEAN
IsPagefileOnDrive(
    CHAR DriveLetter
    )

/*++

Routine Description:

    Walk the page file list and determine if the drive letter given has
    a paging file.  NOTE:  The assumption is that drive letters that
    contain paging files can never get changed during the execution of
    Disk Administrator.  Therefore this list is never updated, but
    can be used during the execution of Disk Administrator.

Arguments:

    DriveLetter - the drive in question.

Return Value:

    TRUE if this drive contains a page file.

--*/

{
    PPAGEFILE_LOCATION pageFileListEntry = PagefileHead;

    while (pageFileListEntry) {
        if (pageFileListEntry->DriveLetter == DriveLetter) {
            return TRUE;
        }
        pageFileListEntry = pageFileListEntry->Next;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\scsi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    This is a subset of the header file for SCSI definitions that is
    located in the kernel tree.

Authors:

    Mike Glass (mglass)

Revision History:

--*/

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\windisk.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    windisk.c

Abstract:

    This module contains the main dialog and support routines for
    Disk Administrator.

Author:

    Edward (Ted) Miller  (TedM)  11/15/91

Environment:

    User process.

Notes:

Revision History:

    11-Nov-93 (bobri) added doublespace and commit support.

--*/

#include "fdisk.h"
#include "shellapi.h"
#include <string.h>
#include <stdio.h>

#if DBG && DEVL

// stuff used in debug version

BOOL AllowAllDeletes = FALSE;   // whether to allow deleting boot/sys parts

#endif

// External from fdinit.

extern HWND    InitDlg;
extern BOOLEAN InitDlgComplete;
extern BOOLEAN StartedAsIcon;
HANDLE         hAccelerator;

// This is the maximum number of members that WinDisk will support
// in an FT Set.

#define     MaxMembersInFtSet   32

// The following vars keep track of the currently selected regions.

DWORD      SelectionCount = 0;
PDISKSTATE SelectedDS[MaxMembersInFtSet];
ULONG      SelectedRG[MaxMembersInFtSet];

#define    SELECTED_REGION(i)  (SelectedDS[i]->RegionArray[SelectedRG[i]])

FT_TYPE FtSelectionType;

// This variable tracks whether the system partition is secure.

BOOL SystemPartitionIsSecure = FALSE;

// Deleted a partition with no drive letter

BOOLEAN CommitDueToDelete = FALSE;
BOOLEAN CommitDueToMirror = FALSE;
BOOLEAN CommitDueToExtended = FALSE;

// If a mirror is made of the boot partition, this will become
// non-zero and indicate which disk should get some boot code in
// the MBR.

ULONG UpdateMbrOnDisk = 0;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED

// If FmIfs.dll doesn't have double space routines this
// flag will reflect that fact.

extern BOOLEAN DoubleSpaceSupported;
BOOLEAN DoubleSpaceAutomount;
#endif


VOID
FrameCommandHandler(
    IN HWND  hwnd,
    IN DWORD wParam,
    IN LONG  lParam
    );

DWORD
SetUpMenu(
    IN PDISKSTATE *SinglySelectedDisk,
    IN DWORD      *SinglySelectedRegion
    );

BOOL
AssignDriveLetter(
    IN  BOOL  WarnIfNoLetter,
    IN  DWORD StringId,
    OUT PCHAR DriveLetter
    );

VOID
AdjustOptionsMenu(
    VOID
    );

ULONG
PartitionCount(
    IN ULONG Disk
    );

VOID
CheckForBootNumberChange(
    IN ULONG Disk
    )

/*++

Routine Description:

    Determine if the disk that has just changed is the boot disk.
    If so, determine if the boot partition number changed.  If it
    did, warn the user.

Arguments:

    RegionDescriptor - the region that has just changed.

Return Value:

    None

--*/

{
    ULONG newPart;
    CHAR  oldNumberString[8],
          newNumberString[8];
    DWORD msgCode;

    if (Disk == BootDiskNumber) {

        // Pass a pointer to Disk even though this is just to get the
        // old partition number back.

        if (BootPartitionNumberChanged(&Disk, &newPart)) {
#if i386
            msgCode = MSG_CHANGED_BOOT_PARTITION_X86;
#else
            msgCode = MSG_CHANGED_BOOT_PARTITION_ARC;
#endif
            sprintf(oldNumberString, "%d", Disk);
            sprintf(newNumberString, "%d", newPart);
            InfoDialog(msgCode, oldNumberString, newNumberString);
        }
    }
}


BOOL
IsSystemPartitionSecure(
    )

/*++

Routine Description:

    This routine knows where to go in the Registry to determine
    if the system partition for this boot is to be protected from
    modification.

Arguments:

    None

Return Value:

    TRUE if the system partition is secure
    FALSE otherwise.

--*/

{
    LONG ec;
    HKEY hkey;
    DWORD type;
    DWORD size;
    ULONG value;

    value = FALSE;

    ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                      0,
                      KEY_QUERY_VALUE,
                      &hkey);

    if (ec == NO_ERROR) {

        size = sizeof(ULONG);
        ec = RegQueryValueExA(hkey,
                              TEXT("Protect System Partition"),
                              NULL,
                              &type,
                              (PBYTE)&value,
                              &size);

        if ((ec != NO_ERROR) || (type != REG_DWORD)) {
            value = FALSE;
        }
        RegCloseKey(hkey);
    }
    return value;
}

VOID __cdecl
main(
    IN int     argc,
    IN char   *argv[],
    IN char   *envp[]
    )

/*++

Routine Description:

    This is were control is given to Disk Administrator when it
    is started.  This routine initializes the application and
    contains the control loop for getting and processing Windows
    messages.

Arguments:

    Standard "main" entry

Return Value:

    Standard "main" entry

--*/

{
    MSG      msg;
    NTSTATUS status;
    HANDLE   mutex;

    hModule = GetModuleHandle(NULL);

    mutex = CreateMutex(NULL,FALSE,"Disk Administrator Is Running");

    if (mutex == NULL) {
        // An error (like out of memory) has occurred.
        return;
    }

    // Make sure we are the only process with a handle to our named mutex.

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(mutex);
        InfoDialog(MSG_ALREADY_RUNNING);
        return;
    } else {
        DisplayInitializationMessage();
    }

    // Determine whether this is LanmanNt or Windows NT by looking at
    // HKEY_LOCAL_MACHINE,System\CurrentControlSet\Control\ProductOptions.
    // If the ProductType value therein is "LanmanNt" then this is LanmanNt.

    {
        LONG ec;
        HKEY hkey;
        DWORD type;
        DWORD size;
        UCHAR buf[100];

        IsLanmanNt = FALSE;

#if DBG
        // The code below will allow users to run WinDisk in Lanman
        // mode on WinNt.  It should never be enabled in a released
        // build, but is very useful for internal users.

        if (argc >= 2 && !_stricmp(argv[1], "-p:lanman")) {
            IsLanmanNt = TRUE;
        }
#endif
        ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                          0,
                          KEY_QUERY_VALUE,
                          &hkey);

        if (ec == NO_ERROR) {

            size = sizeof(buf);
            ec = RegQueryValueExA(hkey,
                                  TEXT("ProductType"),
                                  NULL,
                                  &type,
                                  buf,
                                  &size);

            if ((ec == NO_ERROR) && (type == REG_SZ)) {

                if (!lstrcmpiA(buf,"lanmannt")) {
                    IsLanmanNt = TRUE;
                }
                if (!lstrcmpiA(buf,"servernt")) {
                    IsLanmanNt = TRUE;
                }
            }

            RegCloseKey(hkey);
        }
    }

    // Set the Help file name to the file appropriate to
    // the product.

    HelpFile = IsLanmanNt ? LanmanHelpFile : WinHelpFile;

    // Determine whether the system partition is protected:

    SystemPartitionIsSecure = IsSystemPartitionSecure();

    try {

#if DBG
        InitLogging();
#endif

        // Insure that all drives are present before looking.

        RescanDevices();

        if (!NT_SUCCESS(status = FdiskInitialize())) {
            ErrorDialog(status == STATUS_ACCESS_DENIED ? MSG_ACCESS_DENIED : EC(status));
            goto xx1;
        }

        if (((DiskCount = GetDiskCount()) == 0) || AllDisksOffLine()) {
            ErrorDialog(MSG_NO_DISKS);
            goto xx2;
        }

        if (!InitializeApp()) {
            ErrorDialog(MSG_CANT_CREATE_WINDOWS);
            goto xx2;
        }

        InitRectControl();

        SetUpMenu(&SingleSel,&SingleSelIndex);
        AdjustOptionsMenu();

        InitHelp();
        hAccelerator = LoadAccelerators(hModule, TEXT("MainAcc"));

        if (InitDlg) {

            PostMessage(InitDlg,
                        (WM_USER + 1),
                        0,
                        0);
            InitDlg = (HWND) 0;
        }
        while (GetMessage(&msg,NULL,0,0)) {
            if (!TranslateAccelerator(hwndFrame, hAccelerator, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        TermHelp();
        UnloadIfsDll();

      xx2:

        FdiskCleanUp();

      xx1:

        ;

    } finally {

        // Destroy the mutex.

        CloseHandle(mutex);
    }
}

LONG
MyFrameWndProc(
    IN HWND  hwnd,
    IN UINT  msg,
    IN UINT  wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This is the window handler for the main display of Disk Administrator.

Arguments:

    Standard window handler procedure

Return Value:

    Standard window handler procedure

--*/

{
    static BOOLEAN     oneTime = TRUE;
    PMEASUREITEMSTRUCT pMeasureItem;
    DWORD              ec;
    DWORD              action;
    DWORD              temp;
    RECT               rc;
    BOOL               profileWritten,
                       changesMade,
                       mustReboot,
                       configureFt;
    HMENU              hMenu;

    switch (msg) {
    case WM_CREATE:

        // create the listbox

        if (!StartedAsIcon) {
            StartedAsIcon = IsIconic(hwnd);
        }
        GetClientRect(hwnd,&rc);
#if 1
        hwndList = CreateWindow(TEXT("listbox"),
                                NULL,
                                WS_CHILD | WS_HSCROLL | WS_VSCROLL | WS_VISIBLE | LBS_NOTIFY |
                                    LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED,
                                0,
                                dyLegend,
                                rc.right - rc.left,
                                rc.bottom - rc.top - (StatusBar ? dyStatus : 0) - (Legend ? dyLegend : 0),
                                hwnd,
                                (HMENU)ID_LISTBOX,
                                hModule,
                                NULL);
#else
        hwndList = CreateWindow(TEXT("listbox"),
                                NULL,
                                WS_CHILD | WS_HSCROLL | WS_VSCROLL | WS_VISIBLE | LBS_NOTIFY |
                                    LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED,
                                0,
                                dyLegend,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                hwnd,
                                (HMENU)ID_LISTBOX,
                                hModule,
                                NULL);
#endif
        if (hwndList) {

            SetFocus(hwndList);

            // subclass the listbox so we can handle keyboard
            // input our way.

            SubclassListBox(hwndList);
        }

        // If we are not running the LanmanNt version of
        // Windisk, remove the Fault-Tolerance menu item.

        if (!IsLanmanNt && (hMenu = GetMenu( hwnd )) != NULL ) {

            DeleteMenu( hMenu, 1, MF_BYPOSITION );
            DrawMenuBar( hwnd );
        }

        StatusTextDrlt[0] = 0;
        StatusTextStat[0] = StatusTextSize[0] = 0;
        StatusTextType[0] = StatusTextVoll[0] = 0;
        break;

    case WM_SETFOCUS:

        SetFocus(hwndList);
        break;

    case WM_WININICHANGE:

        if ((lParam == (LONG)NULL) || !lstrcmpi((LPTSTR)lParam,TEXT("colors"))) {
            TotalRedrawAndRepaint();
            InvalidateRect(hwnd,NULL,FALSE);
        }
        break;

    case WM_SIZE:

        // resize the listbox

        GetClientRect(hwnd,&rc);
#if 0
        temp = rc.right - rc.left;

        if (GraphWidth != temp) {

            GraphWidth = temp;
            BarWidth = GraphWidth - dxBarTextMargin;
        }
#endif
        MoveWindow(hwndList,
                   rc.left,
                   rc.top,
                   rc.right  - rc.left,
                   rc.bottom - rc.top - (StatusBar ? dyStatus : 0) - (Legend ? dyLegend : 0),
                   TRUE);

        // invalidate status/legend area so that the clipping
        // rectangle is right for redraws

        rc.top = rc.bottom;

        if (StatusBar) {
            rc.top -= dyStatus;
        }
        if (Legend) {
            rc.top -= dyLegend;
        }
        if (rc.top != rc.bottom) {
            InvalidateRect(hwnd,&rc,FALSE);
        }

        // FALL THROUGH

    case WM_MOVE:

        // if not iconic or minimized, save new position for profile

        if (!IsZoomed(hwndFrame) && !IsIconic(hwndFrame)) {
            GetWindowRect(hwndFrame,&rc);
            ProfileWindowX = rc.left;
            ProfileWindowY = rc.top;
            ProfileWindowW = rc.right - rc.left;
            ProfileWindowH = rc.bottom - rc.top;
        }
        break;

    case WM_ENTERIDLE:

        if (ConfigurationSearchIdleTrigger == TRUE && wParam == MSGF_DIALOGBOX) {

            PostMessage((HWND)lParam,WM_ENTERIDLE,wParam,lParam);

        } else {

            // If we're coming from a dialog box and the F1 key is down,
            // kick the dialog box and make it spit out help.

            if ((wParam == MSGF_DIALOGBOX) &&
                (GetKeyState(VK_F1) & 0x8000) &&
                GetDlgItem((HANDLE) lParam, FD_IDHELP)) {

                PostMessage((HANDLE) lParam, WM_COMMAND, FD_IDHELP, 0L);
            }
        }

        return 1;      // indicate we did not process the message

    case WM_PAINT:

#if 1
        if ((!IsIconic(hwnd)) && !(InitDlg && StartedAsIcon)) {
#else
        if (!StartedAsIcon) {
#endif
            HDC         hdcTemp,hdcScr;
            HBITMAP     hbmTemp;
            PAINTSTRUCT ps;
            HBRUSH      hBrush;
            HFONT       hFontOld;
            RECT        rcTemp,rcTemp2;
            DWORD       ClientRight;

            BeginPaint(hwnd,&ps);
            hdcScr = ps.hdc;

            GetClientRect(hwnd,&rc);

            rcTemp2 = rc;
            ClientRight = rc.right;
            rc.top = rc.bottom - dyStatus + dyBorder;

            if (StatusBar) {

                hdcTemp = CreateCompatibleDC(hdcScr);
                hbmTemp = CreateCompatibleBitmap(hdcScr,rc.right-rc.left+1,rc.bottom-rc.top+1);
                SelectObject(hdcTemp,hbmTemp);

                // adjust position for off-screen bitmap

                rcTemp = rc;
                rc.bottom -= rc.top;
                rc.top = 0;

                hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
                if (hBrush) {
                    FillRect(hdcTemp,&rc,hBrush);
                    DeleteObject(hBrush);
                }

                // draw the status bar at the bottom of the window

                hFontOld = SelectObject(hdcTemp,hFontStatus);

                // Status text
                rc.left  = 8 * dyBorder;
                rc.right = 2 * GraphWidth / 5;
                DrawStatusAreaItem(&rc,hdcTemp,StatusTextStat,FALSE);

                // size
                rc.left  = rc.right + (8*dyBorder);
                rc.right = rc.left + (GraphWidth / 9);
                DrawStatusAreaItem(&rc,hdcTemp,StatusTextSize,FALSE);

                // type
                rc.left  = rc.right + (8*dyBorder);
                rc.right = rc.left + (GraphWidth / 5);
                DrawStatusAreaItem(&rc,hdcTemp,(LPTSTR)StatusTextType,TRUE);

                // drive letter
                rc.left  = rc.right + (8*dyBorder);
                rc.right = rc.left + (8*dyBorder) + dxDriveLetterStatusArea;
                DrawStatusAreaItem(&rc,hdcTemp,(LPTSTR)StatusTextDrlt,TRUE);

                // vol label
                rc.left  = rc.right + (8*dyBorder);
                rc.right = GraphWidth - (8*dyBorder);
                DrawStatusAreaItem(&rc,hdcTemp,(LPTSTR)StatusTextVoll,TRUE);

                BitBlt(hdcScr,
                       rcTemp.left,
                       rcTemp.top,
                       rcTemp.right-rcTemp.left+1,
                       rcTemp.bottom-rcTemp.top+1,
                       hdcTemp,
                       0,
                       0,
                       SRCCOPY);

                if (hFontOld) {
                    SelectObject(hdcTemp,hFontOld);
                }
                DeleteObject(hbmTemp);
                DeleteDC(hdcTemp);
            } else {
                rcTemp = rcTemp2;
                rcTemp.top = rcTemp.bottom;
            }

            if (Legend) {

                // draw the legend onto the screen

                if (StatusBar) {
                    rcTemp2.bottom -= dyStatus;
                }
                rcTemp2.top = rcTemp2.bottom - dyLegend + (2*dyBorder);
                if (StatusBar) {
                    rcTemp2.top += dyBorder;
                }
                rcTemp2.right = GraphWidth;
                DrawLegend(hdcScr,&rcTemp2);
            }

            // dark line across top of status/legend area

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNTEXT))) {

                if (StatusBar || Legend) {
                    rcTemp.bottom = rcTemp.top;
                    if (Legend) {
                        rcTemp.bottom -= dyLegend - 1;
                        rcTemp.top -= dyLegend - 1;
                    }
                    rcTemp.top -= dyBorder;
                    FillRect(hdcScr,&rcTemp,hBrush);
                }
                DeleteObject(hBrush);
            }

            EndPaint(hwnd,&ps);

        }
        if (InitDlg) {

            if (InitDlgComplete) {
                PostMessage(InitDlg,
                            (WM_USER + 1),
                            0,
                            0);
                InitDlg = (HWND) 0;
            }

        }
        if (oneTime) {
            if (!StartedAsIcon) {
                SetForegroundWindow(hwnd);
            }
            oneTime = FALSE;
        }
        break;

    case WM_COMMAND:

        FrameCommandHandler(hwnd,wParam,lParam);
        break;

    case WM_MEASUREITEM:

        pMeasureItem = (PMEASUREITEMSTRUCT)lParam;
        pMeasureItem->itemHeight = GraphHeight;
        break;

    case WM_DRAWITEM:

        WMDrawItem((PDRAWITEMSTRUCT)lParam);
        break;

    case WM_CTLCOLORLISTBOX:

        if (lParam == (LONG)hwndList) {
            return (LONG)GetStockObject(LTGRAY_BRUSH);
        } else {
            return DefWindowProc(hwnd,msg,wParam,lParam);
        }

    case WM_CLOSE:

        // Determine whether any disks have been changed, and whether
        // the system must be rebooted.  The system must be rebooted
        // if the registry has changed, if any non-removable disk has
        // changed, or if any removable disk that was not originally
        // unpartitioned has changed.

        changesMade = FALSE;
        configureFt = FALSE;
        mustReboot = RestartRequired;

        for (temp=0; temp<DiskCount; temp++) {
            if (HavePartitionsBeenChanged(temp)) {

                changesMade = TRUE;
                break;
            }
        }

        profileWritten = FALSE;

        // Determine if the commit can be done without a reboot.
        // If FT is in the system then it must be notified to
        // reconfigure if a reboot is not performed.  If it is
        // not in the system, but the new disk information requires
        // it, then a reboot must be forced.

        if (FtInstalled()) {
            configureFt = TRUE;
        }
        if (NewConfigurationRequiresFt()) {
            if (!configureFt) {

                // The FT driver is not loaded currently.

                mustReboot = TRUE;
            } else {

                // If the system is going to be rebooted, don't
                // have FT reconfigure prior to shutdown.

                if (mustReboot) {
                    configureFt = FALSE;
                }
            }
        }

        if (RegistryChanged | changesMade | RestartRequired) {
            if (RestartRequired) {
                action = IDYES;
            } else {
                action = ConfirmationDialog(MSG_CONFIRM_EXIT, MB_ICONQUESTION | MB_YESNOCANCEL);
            }

            if (action == IDYES) {
                ec = CommitLockVolumes(0);
                if (ec) {

                    // could not lock all volumes

                    ErrorDialog(MSG_CANNOT_LOCK_FOR_COMMIT);
                    CommitUnlockVolumes(DiskCount, FALSE);
                    break;
                }
                if (mustReboot) {
                    if (RestartRequired) {
                        action = IDYES;
                    } else {
                        action = ConfirmationDialog(MSG_REQUIRE_REBOOT, MB_ICONQUESTION | MB_YESNO);
                    }

                    if (action != IDYES) {

                        CommitUnlockVolumes(DiskCount, FALSE);
                        break;
                    }
                }

                SetCursor(hcurWait);
                ec = CommitChanges();
                SetCursor(hcurNormal);

                CommitUnlockVolumes(DiskCount, TRUE);
                if (ec != NO_ERROR) {
                    ErrorDialog(MSG_BAD_CONFIG_SET);
                } else {
                    ULONG oldBootPartitionNumber,
                          newBootPartitionNumber;
                    CHAR  oldNumberString[8],
                          newNumberString[8];
                    DWORD msgCode;

                    // Update the configuration registry

                    ec = SaveFt();
                    if (configureFt) {

                        // Issue device control to ftdisk driver to reconfigure.

                        FtConfigure();
                    }

                    // Register autochk to fix up file systems
                    // in newly extended volume sets, if necessary

                    if (RegisterFileSystemExtend()) {
                        mustReboot = TRUE;
                    }

                    // Determine if the FT driver must be enabled.

                    if (DiskRegistryRequiresFt() == TRUE) {
                        if (!FtInstalled()) {
                            mustReboot = TRUE;
                        }
                        DiskRegistryEnableFt();
                    } else {
                        DiskRegistryDisableFt();
                    }

                    if (ec == NO_ERROR) {
                        InfoDialog(MSG_OK_COMMIT);
                    } else {
                        ErrorDialog(MSG_BAD_CONFIG_SET);
                    }

                    // Has the partition number of the boot
                    // partition changed?

                    if (BootPartitionNumberChanged(&oldBootPartitionNumber, &newBootPartitionNumber)) {
#if i386
                        msgCode = MSG_BOOT_PARTITION_CHANGED_X86;
#else
                        msgCode = MSG_BOOT_PARTITION_CHANGED_ARC;
#endif
                        sprintf(oldNumberString, "%d", oldBootPartitionNumber);
                        sprintf(newNumberString, "%d", newBootPartitionNumber);
                        InfoDialog(msgCode, oldNumberString, newNumberString);
                    }

                    ClearCommittedDiskInformation();

                    if (UpdateMbrOnDisk) {

                        UpdateMasterBootCode(UpdateMbrOnDisk);
                        UpdateMbrOnDisk = 0;
                    }

                    // Reboot if necessary.

                    if (mustReboot) {

                        SetCursor(hcurWait);
                        Sleep(5000);
                        SetCursor(hcurNormal);
                        FdShutdownTheSystem();
                        profileWritten = TRUE;
                    }
                    CommitDueToDelete = CommitDueToMirror = FALSE;
                    CommitAssignLetterList();
                }
            } else if (action == IDCANCEL) {
                return 0;      // don't exit
            } else {
                FDASSERT(action == IDNO);
            }
        }

        if (!profileWritten) {
            WriteProfile();
        }
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:

        // BUGBUG clean up here -- release dc's, free DiskStates, etc.

        WinHelp(hwndFrame,HelpFile,HELP_QUIT,0);
        PostQuitMessage(0);
        break;

    case WM_MENUSELECT:

        SetMenuItemHelpContext(wParam,lParam);
        break;

    case WM_F1DOWN:

        Help(wParam);
        break;

    default:

        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

#if i386

VOID
SetUpMenui386(
    HMENU hMenu,
    DWORD SelectionCount
    )

/*++

Routine Description:

    X86 SPECIFIC

    This routine understands the X86 specific feature of
    "Active Partition".  It determines if the "set partition
    active" menu item should be enabled.

Arguments:

    hMenu          - menu handle
    SelectionCount - number of items currently selected.

Return Value:

    None

--*/

{
    BOOL                allowActive = FALSE;
    PREGION_DESCRIPTOR  regionDescriptor;

    if ((SelectionCount == 1) && (FtSelectionType == -1)) {

        regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];

        // allow it to be made active if
        // -  it is not free space
        // -  it is a primary partition
        // -  it is on disk 0
        // -  it is not already active
        // -  it is not part of an ft set

        if ((regionDescriptor->SysID != SYSID_UNUSED)
         && (regionDescriptor->RegionType == REGION_PRIMARY)
         && !regionDescriptor->Active
         && (GET_FT_OBJECT(regionDescriptor) == NULL)) {
            allowActive = TRUE;
        }
    }

    EnableMenuItem(hMenu,
                   IDM_PARTITIONACTIVE,
                   allowActive ? MF_ENABLED : MF_GRAYED);
}

#endif

DWORD
SetUpMenu(
    IN PDISKSTATE *SinglySelectedDisk,
    IN DWORD      *SinglySelectedRegion
    )

/*++

Routine Description:

    This routine sets up the menu bar based on the state of the app and
    the disks.

    If multiple items are selected, allow neither create nor delete.
    If a single partition is selected, allow delete.
    If a single free space is selected, allow create.
    If the free space is the only free space in the extended partitions,
    also allow delete.  (This is how to delete the extended partition).

Arguments:

    SinglySelectedDisk -- if there is only one selected item, the PDISKSTATE
                          pointed to by this paramater will get a pointer
                          to the selected region's disk structure.  If there are
                          multiple selected items (or none), then the value
                          will be set to NULL.

    SinglySelectedRegion -- if there is only one selected item, the DWORD
                            pointed to by this paramater will get the selected
                            region #.  Otherwise the DWORD gets -1.

Return Value:

    Count of selected regions.

--*/

{
    BOOL  allowCreate           = FALSE,
          allowCreateEx         = FALSE,
          allowDelete           = FALSE,
          allowFormat           = FALSE,
          allowLabel            = FALSE,
          allowBreakMirror      = FALSE,
          allowCreateMirror     = FALSE,
          allowCreateStripe     = FALSE,
          allowCreateVolumeSet  = FALSE,
          allowExtendVolumeSet  = FALSE,
          allowCreatePStripe    = FALSE,
          allowDriveLetter      = FALSE,
          allowRecoverParity    = FALSE,
          ftSetSelected         = FALSE,
          nonFtItemSelected     = FALSE,
          multipleItemsSelected = FALSE,
          volumeSetAndFreeSpaceSelected = FALSE,
          onDifferentDisks,
          possibleRecover;
    BOOL  allowCommit = CommitAllowed();
    WCHAR driveLetter = L' ';
    PWSTR typeName = NULL,
          volumeLabel = NULL;
    PDISKSTATE diskState,
               selDiskState = NULL;
    DWORD      i,
               j,
               selectedRegion = 0;
    ULONG      ordinal                 = 0,
               selectedFreeSpaces      = 0,
               freeSpaceIndex          = 0,
               componentsInFtSet       = 0,
               selectedNonFtPartitions = 0;
    HMENU      hMenu = GetMenu(hwndFrame);
    FT_TYPE    type = (FT_TYPE) 0;
    PULONG     diskSeenCounts;
    PFT_OBJECT_SET     ftSet = NULL;
    PFT_OBJECT         ftObject = NULL;
    PREGION_DESCRIPTOR regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;

    diskSeenCounts = Malloc(DiskCount * sizeof(ULONG));
    RtlZeroMemory(diskSeenCounts,DiskCount * sizeof(ULONG));

    SelectionCount = 0;
    for (i=0; i<DiskCount; i++) {
        diskState = Disks[i];
        for (j=0; j<diskState->RegionCount; j++) {
            if (diskState->Selected[j]) {
                selDiskState = diskState;
                selectedRegion = j;
                SelectionCount++;
                if (SelectionCount <= MaxMembersInFtSet) {
                    SelectedDS[SelectionCount-1] = diskState;
                    SelectedRG[SelectionCount-1] = j;
                }
                diskSeenCounts[diskState->Disk]++;
                if (ftObject = GET_FT_OBJECT(&diskState->RegionArray[j])) {
                    ftSet = ftObject->Set;
                    if (componentsInFtSet == 0) {
                        ordinal = ftSet->Ordinal;
                        type = ftSet->Type;
                        ftSetSelected = TRUE;
                        componentsInFtSet = 1;
                    } else if ((ftSet->Ordinal == ordinal) && (ftSet->Type == type)) {
                        componentsInFtSet++;
                    } else {
                        ftSetSelected = FALSE;
                    }
                } else {

                    nonFtItemSelected = TRUE;

                    if (IsRecognizedPartition(diskState->RegionArray[j].SysID) ) {
                        selectedNonFtPartitions += 1;
                    }
                }
            }
        }
    }

    // Determine the number of free-space regions selected:

    selectedFreeSpaces = 0;
    for (i=0; i<SelectionCount && i < MaxMembersInFtSet; i++) {
        if (SELECTED_REGION(i).SysID == SYSID_UNUSED) {
            freeSpaceIndex = i;
            selectedFreeSpaces++;
        }
    }

    FtSelectionType = -1;
    possibleRecover = FALSE;
    if (nonFtItemSelected && ftSetSelected) {

        // Both FT and Non-FT items have been selected.  First,
        // check to see if a volume set and free space have been
        // selected; then reset the state to indicate that the
        // selection does not consists of a mix of FT and non-FT
        // objects.

        if (type == VolumeSet && selectedFreeSpaces + componentsInFtSet == SelectionCount ) {

            volumeSetAndFreeSpaceSelected = TRUE;
        }

        possibleRecover = TRUE;
        ftSetSelected = FALSE;
        nonFtItemSelected = FALSE;
        multipleItemsSelected = TRUE;
    }

    if ((SelectionCount == 1) && !ftSetSelected) {

        *SinglySelectedDisk = selDiskState;
        *SinglySelectedRegion = selectedRegion;

        regionDescriptor = &selDiskState->RegionArray[selectedRegion];

        if (regionDescriptor->SysID == SYSID_UNUSED) {

            // Free region.  Always allow create; let DoCreate() sort out
            // details about whether partition table is full, etc.

            allowCreate = TRUE;

            if (regionDescriptor->RegionType == REGION_PRIMARY) {
                allowCreateEx = TRUE;
            }

            // special case -- allow deletion of the extended partition if
            // there are no logicals in it.

            if ((regionDescriptor->RegionType == REGION_LOGICAL)
             &&  selDiskState->ExistExtended
             && !selDiskState->ExistLogical) {
                FDASSERT(regionDescriptor->SysID == SYSID_UNUSED);
                allowDelete = TRUE;
            }
        } else {

            // used region.  Delete always allowed.

            allowDelete = TRUE;
            regionData = (PPERSISTENT_REGION_DATA)(PERSISTENT_DATA(regionDescriptor));

            if (regionData) {
                if (regionData->VolumeExists) {
                    if ((regionData->DriveLetter != NO_DRIVE_LETTER_YET) && (regionData->DriveLetter != NO_DRIVE_LETTER_EVER)) {
                        allowFormat = TRUE;
                    }
                }
            }

            // If the region is recognized, then also allow drive letter
            // manipulation.

            if (IsRecognizedPartition(regionDescriptor->SysID)) {

                allowDriveLetter = TRUE;

                // DblSpace volumes are allowed on non-FT, FAT volumes only

                DetermineRegionInfo(regionDescriptor,
                                    &typeName,
                                    &volumeLabel,
                                    &driveLetter);

                if ((driveLetter != NO_DRIVE_LETTER_YET) && (driveLetter != NO_DRIVE_LETTER_EVER)) {
                    if (wcscmp(typeName, L"FAT") == 0) {
                        allowLabel = allowFormat;
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
                        allowDblSpace = allowFormat;
#endif

                        // Force the dll in now to know if Double Space
                        // support is offerred by the dll.

                        LoadIfsDll();
                    }

                    if ((wcscmp(typeName, L"NTFS") == 0) ||
                        (wcscmp(typeName, L"HPFS") == 0)) {
                        allowLabel = allowFormat;
                    }
                }
            }
        }
    } else {

        if (SelectionCount) {

            *SinglySelectedDisk = NULL;
            *SinglySelectedRegion = (DWORD)(-1);

            // Multiple regions are selected.  This might be an existing ft set,
            // a set of regions that allow creation of an ft set, or just plain
            // old multiple items.
            //
            // First deal with a selected ft set.

            if (ftSetSelected) {

                regionDescriptor = &SELECTED_REGION(0);
                regionData = (PPERSISTENT_REGION_DATA)(PERSISTENT_DATA(regionDescriptor));

                // RDR - should locate member zero of the set since it
                // may not be committed yet.

                if (regionData) {
                    if (regionData->VolumeExists) {
                        if ((regionData->DriveLetter != NO_DRIVE_LETTER_YET) && (regionData->DriveLetter != NO_DRIVE_LETTER_EVER)) {

                            // Now check for special cases on FT sets

                            ftObject = regionData->FtObject;
                            if (ftObject) {
                                ftSet = ftObject->Set;
                                if (ftSet) {
                                    FT_SET_STATUS setState = ftSet->Status;
                                    ULONG         numberOfMembers;

                                    LowFtVolumeStatus(regionDescriptor->Disk,
                                                      regionDescriptor->PartitionNumber,
                                                      &setState,
                                                      &numberOfMembers);

                                    if ((ftSet->Status != FtSetDisabled) &&
                                        (setState != FtSetDisabled)) {
                                        allowFormat = TRUE;
                                    }
                                }
                            }
                        }

                        if (regionData->TypeName) {
                            typeName = regionData->TypeName;
                        } else {

                            typeName = NULL;
                            DetermineRegionInfo(regionDescriptor,
                                                &typeName,
                                                &volumeLabel,
                                                &driveLetter);
                            if (!typeName) {

                                if (SelectionCount > 1) {

                                    // it is an FT set - try the next member.

                                    regionDescriptor = &SELECTED_REGION(1);
                                    DetermineRegionInfo(regionDescriptor,
                                                        &typeName,
                                                        &volumeLabel,
                                                        &driveLetter);
                                    regionDescriptor = &SELECTED_REGION(0);
                                }
                            }

                        }

                        if (typeName) {
                            if ((wcscmp(typeName, L"NTFS") == 0) ||
                                (wcscmp(typeName, L"HPFS") == 0) ||
                                (wcscmp(typeName, L"FAT") == 0)) {

                                allowLabel = allowFormat;
                            }
                        }
                    }
                }

                // Allow the correct type of ft-related delete.

                switch (type) {

                case Mirror:
                    allowBreakMirror = TRUE;
                    allowDelete = TRUE;
                    break;
                case StripeWithParity:

                    if ((SelectionCount == ftSet->NumberOfMembers) &&
                        (ftSet->Status == FtSetRecoverable)) {
                        allowRecoverParity = TRUE;
                    }
                    allowDelete = TRUE;
                    break;
                case Stripe:
                case VolumeSet:
                    allowDelete = TRUE;
                    break;
                default:
                    FDASSERT(FALSE);
                }

                FtSelectionType = type;

                if (type == StripeWithParity) {

                    // If the set is disabled.  Do not allow drive
                    // letter changes - This is done because there are
                    // conditions whereby the drive letter code will
                    // access violate if this is done.

                    if (ftSet->Status != FtSetDisabled) {

                        // Must have either member 0 or member 1 for access

                        for (ftObject = ftSet->Members; ftObject; ftObject = ftObject->Next) {
                            if ((ftObject->MemberIndex == 0) ||
                                (ftObject->MemberIndex == 1)) {
                                allowDriveLetter = TRUE;
                                break;
                            }
                        }

                        // if the drive letter cannot be done, then no live
                        // action can be done.

                        if (!allowDriveLetter) {

                            ftSet->Status = FtSetDisabled;
                            allowFormat = FALSE;
                            allowLabel = FALSE;
                        }
                    }
                } else {
                    allowDriveLetter = TRUE;
                }

            } else {

                // Next figure out whether some sort of ft object set could
                // be created out of the selected regions.

                if (SelectionCount <= MaxMembersInFtSet) {

                    // Determine whether the selected regions are all on
                    // different disks.

                    onDifferentDisks = TRUE;
                    for (i=0; i<DiskCount; i++) {
                        if (diskSeenCounts[i] > 1) {
                            onDifferentDisks = FALSE;
                            break;
                        }
                    }

                    // Check for allowing mirror creation.  User must have selected
                    // two regions -- one a recognized partition, the other a free space.

                    if (onDifferentDisks && (SelectionCount == 2)
                    &&((SELECTED_REGION(0).SysID == SYSID_UNUSED) != (SELECTED_REGION(1).SysID == SYSID_UNUSED))
                    &&( IsRecognizedPartition(SELECTED_REGION(0).SysID) ||
                        IsRecognizedPartition(SELECTED_REGION(1).SysID))
                    &&!GET_FT_OBJECT(&(SELECTED_REGION(0)))
                    &&!GET_FT_OBJECT(&(SELECTED_REGION(1))))
                    {
                        allowCreateMirror = TRUE;
                    }

                    // Check for allowing volume set or stripe set

                    if (selectedFreeSpaces == SelectionCount) {
                        allowCreateVolumeSet = TRUE;
                        if (onDifferentDisks) {
                            allowCreateStripe = TRUE;
                            if (selectedFreeSpaces > 2) {
                                allowCreatePStripe = TRUE;
                            }
                        }
                    }

                    // Check for allowing volume set expansion.  If
                    // the selected regions consist of one volume set
                    // and free space, then that volume set can be
                    // extended.  If the selection consists of one
                    // recognized non-FT partition and free space,
                    // then we can convert those regions into a
                    // volume set.

                    if (volumeSetAndFreeSpaceSelected ||
                        (SelectionCount > 1 &&
                         selectedFreeSpaces == SelectionCount - 1 &&
                         selectedNonFtPartitions == 1) ) {

                        allowExtendVolumeSet = TRUE;
                    }

                    // Check for allowing non-in-place FT recover

                    if ((SelectionCount > 1)
                     && (selectedFreeSpaces == 1)
                     && possibleRecover
                     && (type == StripeWithParity)
                     && (ftSet->Status == FtSetRecoverable)) {
                        BOOL OrphanOnSameDiskAsFreeSpace = FALSE;

                        if (!onDifferentDisks) {

                            // Determine whether the orphan is on the same
                            // disk as the free space.  First find the orphan.

                            for (i=0; i<SelectionCount; i++) {

                                PREGION_DESCRIPTOR reg = &SELECTED_REGION(i);

                                if ((i != freeSpaceIndex)
                                && (GET_FT_OBJECT(reg)->State == Orphaned))
                                {
                                    if (SELECTED_REGION(freeSpaceIndex).Disk == reg->Disk) {
                                        OrphanOnSameDiskAsFreeSpace = TRUE;
                                    }
                                    break;
                                }
                            }
                        }

                        if (onDifferentDisks || OrphanOnSameDiskAsFreeSpace) {
                            allowRecoverParity = TRUE;
                        }
                    }
                }
            }
        }
    }

    EnableMenuItem(hMenu,
                   IDM_PARTITIONCREATE,
                   allowCreate ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONCREATEEX,
                   allowCreateEx ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONDELETE,
                   allowDelete ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONFORMAT,
                   allowFormat ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu,
                   IDM_PARTITIONLABEL,
                   allowLabel ? MF_ENABLED : MF_GRAYED);

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    EnableMenuItem(hMenu,
                   IDM_DBLSPACE,
                   (allowDblSpace & DoubleSpaceSupported) ? MF_ENABLED : MF_GRAYED);

    if (DoubleSpaceAutomount = DiskRegistryAutomountCurrentState()) {
        CheckMenuItem(hMenu, IDM_AUTOMOUNT, MF_BYCOMMAND | MF_CHECKED);
    }

    EnableMenuItem(hMenu,
                   IDM_AUTOMOUNT,
                   MF_ENABLED);
#endif
    EnableMenuItem(hMenu,
                   IDM_CDROM,
                   AllowCdRom ? MF_ENABLED : MF_GRAYED);
#if i386
    SetUpMenui386(hMenu,SelectionCount);
#else
    EnableMenuItem(hMenu,
                   IDM_SECURESYSTEM,
                   MF_ENABLED);

    CheckMenuItem(hMenu,
                  IDM_SECURESYSTEM,
                  SystemPartitionIsSecure ? MF_CHECKED : MF_UNCHECKED);

#endif

    EnableMenuItem(hMenu,
                   IDM_FTBREAKMIRROR,
                   allowBreakMirror ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTESTABLISHMIRROR,
                   IsLanmanNt &&
                   allowCreateMirror ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTCREATESTRIPE,
                   allowCreateStripe ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTCREATEPSTRIPE,
                   allowCreatePStripe ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTCREATEVOLUMESET,
                   allowCreateVolumeSet ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTEXTENDVOLUMESET,
                   allowExtendVolumeSet ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_PARTITIONLETTER,
                   allowDriveLetter ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu,
                   IDM_FTRECOVERSTRIPE,
                   IsLanmanNt &&
                   allowRecoverParity ? MF_ENABLED : MF_GRAYED);

    // If the registry has change allow commit.

    if (RegistryChanged) {
        allowCommit = TRUE;
    }
    EnableMenuItem(hMenu,
                   IDM_COMMIT,
                   allowCommit ? MF_ENABLED : MF_GRAYED);
    return SelectionCount;
}

VOID
CompleteSingleRegionOperation(
    IN PDISKSTATE DiskState
    )

/*++

Routine Description:

    Redraw the disk bar for the DiskState given and cause the
    display to refresh.

Arguments:

    DiskState - the disk involved.

Return Value:

    None

--*/

{
    RECT   rc;
    signed displayOffset;

    EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_GRAYED);
    DeterminePartitioningState(DiskState);
    DrawDiskBar(DiskState);
    SetUpMenu(&SingleSel, &SingleSelIndex);

    // BUGBUG use of disk# as offset in listbox

    displayOffset = (signed)DiskState->Disk
                  - (signed)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);

    if (displayOffset > 0) {             // otherwise it's not visible

        // make a thin rectangle to force update

        rc.left   = BarLeftX + 5;
        rc.right  = rc.left + 5;
        rc.top    = (displayOffset * GraphHeight) + BarTopYOffset;
        rc.bottom = rc.top + 5;
        InvalidateRect(hwndList, &rc, FALSE);
    }

    ClearStatusArea();
    ResetLBCursorRegion();
    ForceLBRedraw();
}

VOID
TotalRedrawAndRepaint(
    VOID
    )

/*++

Routine Description:

    Invalidate the display and cause all disk bars to be redrawn.

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned i;

    for (i=0; i<DiskCount; i++) {
        DrawDiskBar(Disks[i]);
    }
    ForceLBRedraw();
}


VOID
CompleteMultiRegionOperation(
    VOID
    )

/*++

Routine Description:

    This routine will cause the display to be updated
    after a multi-region action has been completed.

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned i;

    EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_GRAYED);

    for (i=0; i<DiskCount; i++) {
        DeterminePartitioningState(Disks[i]);
    }

    TotalRedrawAndRepaint();
    SetUpMenu(&SingleSel, &SingleSelIndex);
    ClearStatusArea();
    ResetLBCursorRegion();
}

PPERSISTENT_REGION_DATA
DmAllocatePersistentData(
    IN PWSTR VolumeLabel,
    IN PWSTR TypeName,
    IN CHAR  DriveLetter
    )

/*++

Routine Description:

    Allocate a structure to hold persistent region data.  Fill in the volume
    label, type name, and drive letter.  The volume label and type name are
    duplicated.

Arguments:

    VolumeLabel - volume label to be stored in the the persistent data.
        The string will be duplicated first and a pointer to the duplicate
        copy is what is stored in the persistent data.  May be NULL.

    TypeName - name of type of region, ie unformatted, FAT, etc.  May be NULL.

    DriveLetter - drive letter to be stored in persistent data

Return Value:

    pointer to newly allocated persistent data structure.  The structure
    may be freed via DmFreePersistentData(), below.

--*/

{
    PPERSISTENT_REGION_DATA regionData = NULL;
    PWSTR volumeLabel = NULL,
          typeName    = NULL;

    if (VolumeLabel) {
        volumeLabel = Malloc((lstrlenW(VolumeLabel)+1)*sizeof(WCHAR));
        lstrcpyW(volumeLabel,VolumeLabel);
    }

    if (TypeName) {
        typeName = Malloc((lstrlenW(TypeName)+1)*sizeof(WCHAR));
        lstrcpyW(typeName,TypeName);
    }

    regionData = Malloc(sizeof(PERSISTENT_REGION_DATA));
    DmInitPersistentRegionData(regionData, NULL, volumeLabel, typeName, DriveLetter);
    return regionData;
}

VOID
DmFreePersistentData(
    IN OUT PPERSISTENT_REGION_DATA RegionData
    )

/*++

Routine Description:

    Free a persistent data structure and storage used for volume label
    and type name (does not free ft objects).

Arguments:

    RegionData - structure to be freed.

Return Value:

    None.

--*/

{
    if (RegionData->VolumeLabel) {
        Free(RegionData->VolumeLabel);
    }
    if (RegionData->TypeName) {
        Free(RegionData->TypeName);
    }
    Free(RegionData);
}

VOID
DoCreate(
    IN DWORD CreationType       // REGION_EXTENDED or REGION_PRIMARY
    )

/*++

Routine Description:

    This routine creates a new partition.

Arguments:

    CreationType - indicator of partition type (extended or primary).

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    ULONG              diskNumber = regionDescriptor->Disk;
    MINMAXDLG_PARAMS   dlgParams;
    DWORD              creationSize;
    DWORD              ec;
    PPERSISTENT_REGION_DATA regionData;
    BOOLEAN            isRemovable;
    CHAR               driveLetter;


    FDASSERT(SingleSel);
    FDASSERT(regionDescriptor->SysID == SYSID_UNUSED);

    // WinDisk can only create a single partition on a removable
    // disk--no extended partitions and only one primary.

    isRemovable = IsDiskRemovable[diskNumber];

    if (isRemovable) {

        if (CreationType == REGION_EXTENDED) {

            ErrorDialog(MSG_NO_EXTENDED_ON_REMOVABLE);
            return;
        }

        if (Disks[diskNumber]->ExistAny) {

            ErrorDialog(MSG_ONLY_ONE_PARTITION_ON_REMOVABLE);
            return;
        }
    }

    // Make sure the partition table is not full, and that we are allowed to
    // create the type of partition to be created.

    if (regionDescriptor->RegionType == REGION_PRIMARY) {

        if (!SingleSel->CreatePrimary) {
            ErrorDialog(MSG_PART_TABLE_FULL);
            return;
        }

        if ((CreationType == REGION_EXTENDED) && !SingleSel->CreateExtended) {
            ErrorDialog(MSG_EXTENDED_ALREADY_EXISTS);
            return;
        }
    }

    // If not creating an extended partition, allocate a drive letter.
    // If no drive letter is available, warn the user and allow him to cancel.
    // If the new partition is on a removable disk, use the reserved
    // drive letter for that removable disk.

    if (CreationType != REGION_EXTENDED) {

        CreationType = regionDescriptor->RegionType;      // primary or logical

        if (isRemovable) {

            driveLetter = RemovableDiskReservedDriveLetters[diskNumber];

        } else {

            if (!AssignDriveLetter(TRUE, CreationType == REGION_LOGICAL ? IDS_LOGICALVOLUME : IDS_PARTITION, &driveLetter)) {
                return;
            }
        }
    } else {
        CommitDueToExtended = TRUE;
    }

#if i386
    // if the user is creating a primary partition and there are already
    // primary partitions, warn him that the scheme he will create may
    // not be DOS compatible.

    if ((CreationType == REGION_PRIMARY) && SingleSel->ExistPrimary) {

        if (ConfirmationDialog(MSG_CREATE_NOT_COMPAT, MB_ICONQUESTION | MB_YESNO) != IDYES) {
            return;
        }
    }
#endif

    // now get the size.

    dlgParams.MinSizeMB = FdGetMinimumSizeMB(diskNumber);
    dlgParams.MaxSizeMB = FdGetMaximumSizeMB(regionDescriptor, CreationType);

    switch (CreationType) {
    case REGION_PRIMARY:
        dlgParams.CaptionStringID = IDS_CRTPART_CAPTION_P;
        dlgParams.MinimumStringID = IDS_CRTPART_MIN_P;
        dlgParams.MaximumStringID = IDS_CRTPART_MAX_P;
        dlgParams.SizeStringID    = IDS_CRTPART_SIZE_P;
        dlgParams.HelpContextId   = HC_DM_DLG_CREATEPRIMARY;
        break;

    case REGION_EXTENDED:
        dlgParams.CaptionStringID = IDS_CRTPART_CAPTION_E;
        dlgParams.MinimumStringID = IDS_CRTPART_MIN_P;
        dlgParams.MaximumStringID = IDS_CRTPART_MAX_P;
        dlgParams.SizeStringID    = IDS_CRTPART_SIZE_P;
        dlgParams.HelpContextId   = HC_DM_DLG_CREATEEXTENDED;
        break;

    case REGION_LOGICAL:
        dlgParams.CaptionStringID = IDS_CRTPART_CAPTION_L;
        dlgParams.MinimumStringID = IDS_CRTPART_MIN_L;
        dlgParams.MaximumStringID = IDS_CRTPART_MAX_L;
        dlgParams.SizeStringID    = IDS_CRTPART_SIZE_L;
        dlgParams.HelpContextId   = HC_DM_DLG_CREATELOGICAL;
        break;

    default:
        FDASSERT(FALSE);
    }

    creationSize = DialogBoxParam(hModule,
                                  MAKEINTRESOURCE(IDD_MINMAX),
                                  hwndFrame,
                                  MinMaxDlgProc,
                                  (LONG)&dlgParams);

    if (!creationSize) {     // user cancelled
        return;
    }

    // Since the WinDisk can only create one partition on a removable
    // disk, if the user requests a size smaller than the maximum
    // on a removable disk, prompt to confirm:

    if (isRemovable && creationSize != FdGetMaximumSizeMB(regionDescriptor, CreationType)) {

        if (ConfirmationDialog(MSG_REMOVABLE_PARTITION_NOT_FULL_SIZE,MB_ICONQUESTION | MB_YESNO) != IDYES) {
            return;
        }
    }

#if i386

    // See whether the partition will cross over the 1024 cylinder boundary
    // and warn the user if it will.
    //
    // If the extended partition crosses the boundary and the user is creating
    // a logical drive, warn him even though the logical drive itself may not
    // cross the boundary -- he still won't be able to access it.

    {
        DWORD i,
              msgId = (DWORD)(-1);

        if (CreationType == REGION_LOGICAL) {

            PREGION_DESCRIPTOR extReg;

            //
            // Find the extended partition
            //

            for (i=0; i<Disks[diskNumber]->RegionCount; i++) {

                extReg = &Disks[diskNumber]->RegionArray[i];

                if (IsExtended(extReg->SysID)) {
                    break;
                }
                extReg = NULL;
            }

            FDASSERT(extReg);
            if (extReg && FdCrosses1024Cylinder(extReg, 0, REGION_LOGICAL)) {
                msgId = MSG_LOG_1024_CYL;
            }

        } else {
            if (FdCrosses1024Cylinder(regionDescriptor, creationSize, CreationType)) {
                msgId = (CreationType == REGION_PRIMARY) ? MSG_PRI_1024_CYL : MSG_EXT_1024_CYL;
            }
        }

        if ((msgId != (ULONG)(-1)) && (ConfirmationDialog(msgId, MB_ICONQUESTION | MB_YESNO) != IDYES)) {
            return;
        }
    }

#endif

    // If not creating an extended partition, we need to create a new
    // persistent region data structure to associate with the new
    // partition.

    if (CreationType == REGION_EXTENDED) {
        regionData = NULL;
    } else {
        regionData = DmAllocatePersistentData(L"", wszNewUnformatted, driveLetter);
    }

    SetCursor(hcurWait);

    ec = CreatePartition(regionDescriptor,
                         creationSize,
                         CreationType);
    if (ec != NO_ERROR) {
        SetCursor(hcurNormal);
        ErrorDialog(ec);
    }

    DmSetPersistentRegionData(regionDescriptor, regionData);
    if (CreationType != REGION_EXTENDED) {
        if (!isRemovable) {
            MarkDriveLetterUsed(driveLetter);
            CommitToAssignLetterList(regionDescriptor, FALSE);
        }
    }

    // this clears all selections on the disk

    CompleteSingleRegionOperation(SingleSel);
    SetCursor(hcurNormal);
}

VOID
DoDelete(
    VOID
    )

/*++

Routine Description:

    Using the global selection information, delete the partition.

Arguments:

    None

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR regionDescriptor = &SingleSel->RegionArray[SingleSelIndex];
    ULONG              diskNumber = regionDescriptor->Disk;
    DWORD              actualIndex = SingleSelIndex;
    DWORD              i,
                       ec;
    PPERSISTENT_REGION_DATA regionData;
    BOOL               deletingExtended;

    FDASSERT(SingleSel);

    // if deleting a free space in the extended partition, then delete the
    // extended partition itself.

    if ((regionDescriptor->RegionType == REGION_LOGICAL) && !SingleSel->ExistLogical) {

        FDASSERT(SingleSel->ExistExtended);

        // find the extended partition

        for (i=0; i<SingleSel->RegionCount; i++) {
            if (IsExtended(SingleSel->RegionArray[i].SysID)) {
                actualIndex = i;
                break;
            }
        }

        deletingExtended = TRUE;
        FDASSERT(actualIndex != SingleSelIndex);

    } else {

        deletingExtended = FALSE;

        // Make sure deletion of this partition is allowed.  It is not allowed
        // if it is the boot partition (or sys partition on x86).

        if ((ec = DeletionIsAllowed(&SingleSel->RegionArray[actualIndex])) != NO_ERROR) {
            ErrorDialog(ec);
            return;
        }
    }

    // If this is a partition that will become the result of a
    // mirror break, insure that the break has occurred.  Otherwise
    // this delete will have bad results.

    regionDescriptor = &SingleSel->RegionArray[actualIndex];
    if (regionDescriptor->Reserved) {
        if (regionDescriptor->Reserved->Partition) {
            if (regionDescriptor->Reserved->Partition->CommitMirrorBreakNeeded) {
                ErrorDialog(MSG_MUST_COMMIT_BREAK);
                return;
            }
        }
    }

    if (!deletingExtended && (ConfirmationDialog(MSG_CONFIRM_DELETE, MB_ICONQUESTION | MB_YESNO) != IDYES)) {
        return;
    }

    // actualIndex is the thing to delete.

    FDASSERT(regionDescriptor->SysID != SYSID_UNUSED);
    regionData = PERSISTENT_DATA(regionDescriptor);

    if (regionData) {

        // Remember drive letter if there is one in order to lock it for delete.

        if (CommitToLockList(regionDescriptor, !IsDiskRemovable[diskNumber], TRUE, FALSE)) {

            // Could not lock exclusively - do not allow delete.

            if (IsPagefileOnDrive(regionData->DriveLetter)) {
                ErrorDialog(MSG_CANNOT_LOCK_PAGEFILE);
                return;
            } else {
                if (CommitToLockList(regionDescriptor, !IsDiskRemovable[diskNumber], TRUE, FALSE)) {
                    FDLOG((1,"DoDelete: Couldn't lock 2 times - popup shown\n"));
                    ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
                    return;
                }
            }
        }
    } else {

        // Deleting an extended partition - enable commit.

        CommitDueToDelete = TRUE;
    }

    SetCursor(hcurWait);

    // Perform the "delete" of internal structures.

    ec = DeletePartition(regionDescriptor);

    if (ec != NO_ERROR) {
        SetCursor(hcurNormal);
        ErrorDialog(ec);
    }

    if (regionData) {

        // Make the letter available for reuse.

        if (!IsDiskRemovable[diskNumber]) {
            MarkDriveLetterFree(regionData->DriveLetter);
        }

        // Free the persistent data associated with the region.

        DmFreePersistentData(regionData);
        DmSetPersistentRegionData(regionDescriptor,NULL);
    }

    // this clears all selections on the disk

    CompleteSingleRegionOperation(SingleSel);
    SetCursor(hcurNormal);
}

#if i386
VOID
DoMakeActive(
    VOID
    )

/*++

Routine Description:

    This routine sets that active partition bit on for the selected partition.
    This code is x86 specific.

Arguments:

    None

Return Value:

    None

--*/

{

    SetCursor(hcurWait);

    FDASSERT(SingleSel);
    FDASSERT(!SingleSel->RegionArray[SingleSelIndex].Active);
    FDASSERT(SingleSel->RegionArray[SingleSelIndex].RegionType == REGION_PRIMARY);
    FDASSERT(SingleSel->RegionArray[SingleSelIndex].SysID != SYSID_UNUSED);

    MakePartitionActive(SingleSel->RegionArray,
                        SingleSel->RegionCount,
                        SingleSelIndex);

    SetCursor(hcurNormal);
    InfoDialog(MSG_DISK0_ACTIVE);
    SetCursor(hcurWait);
    CompleteSingleRegionOperation(SingleSel);
    SetCursor(hcurNormal);
}
#endif

VOID
DoProtectSystemPartition(
    VOID
    )

/*++

Routine Description:

    This function toggles the state of the system partition security:
    if the system partition is secure, it makes it non-secure; if the
    system partition is not secure, it makes it secure.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG ec;
    HKEY hkey;
    DWORD value;
    DWORD MessageId;

    SetCursor(hcurWait);
    MessageId = SystemPartitionIsSecure ? MSG_CONFIRM_UNPROTECT_SYSTEM :
                                          MSG_CONFIRM_PROTECT_SYSTEM;

    if (ConfirmationDialog(MessageId, MB_ICONEXCLAMATION | MB_YESNO) != IDYES) {
        return;
    }

    ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                      0,
                      KEY_SET_VALUE,
                      &hkey);

    if (ec != ERROR_SUCCESS) {

        MessageId = SystemPartitionIsSecure ? MSG_CANT_UNPROTECT_SYSTEM :
                                              MSG_CANT_PROTECT_SYSTEM;
        ErrorDialog(MessageId);
        return;
    }

    // If the system partition is currently secure, change it
    // to not secure; if it is not secure, make it secure.

    value = SystemPartitionIsSecure ? 0 : 1;

    ec = RegSetValueEx(hkey,
                       TEXT("Protect System Partition"),
                       0,
                       REG_DWORD,
                       (PBYTE)&value,
                       sizeof(DWORD));
    RegCloseKey(hkey);

    if (ec != ERROR_SUCCESS) {

        MessageId = SystemPartitionIsSecure ? MSG_CANT_UNPROTECT_SYSTEM :
                                              MSG_CANT_PROTECT_SYSTEM;
        ErrorDialog(MessageId);
        return;
    }

    SystemPartitionIsSecure = !SystemPartitionIsSecure;

    SetUpMenu(&SingleSel,&SingleSelIndex);
    RestartRequired = TRUE;
    SetCursor(hcurNormal);
}


VOID
DoEstablishMirror(
    VOID
    )

/*++

Routine Description:

    Using the global selection values, this routine will associate
    freespace with an existing partition in order to construct a
    mirror.

Arguments:

    None

Return Value:

    None

--*/

{
    LARGE_INTEGER      partitionSize,
                       freeSpaceSize;
    DWORD              i,
                       part,
                       free = 0;
    PREGION_DESCRIPTOR regionDescriptor,
                       freeSpace = NULL,
                       existingPartition = NULL;
    PREGION_DESCRIPTOR regionArray[MaxMembersInFtSet];
    UCHAR              newSysID;
    PPERSISTENT_REGION_DATA regionData;
    HMENU              hMenu = GetMenu(hwndFrame);

    FDASSERT(SelectionCount == 2);

    // Make sure that the mirror pair does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_MIRROR);
            return;
        }
    }

    for (i=0; i<2; i++) {
        regionDescriptor = &SELECTED_REGION(i);
        if (regionDescriptor->SysID == SYSID_UNUSED) {
            free = i;
            freeSpace = regionDescriptor;
        } else {
            part = i;
            existingPartition = regionDescriptor;
        }
    }

    FDASSERT((freeSpace != NULL) && (existingPartition != NULL));

    // Make sure that we are allowed to create a partition in the free space.

    if (!(    ((freeSpace->RegionType == REGION_LOGICAL) && SelectedDS[free]->CreateLogical)
           || ((freeSpace->RegionType == REGION_PRIMARY) && SelectedDS[free]->CreatePrimary))) {
        ErrorDialog(MSG_CRTSTRP_FULL);
        return;
    }

    // Make sure that the free space is large enough to hold a mirror of
    // the existing partition.  Do this by getting the EXACT size of
    // the existing partition and the free space.

    partitionSize = FdGetExactSize(existingPartition, FALSE);
    freeSpaceSize = FdGetExactSize(freeSpace, FALSE);

    if (freeSpaceSize.QuadPart < partitionSize.QuadPart) {
        ErrorDialog(MSG_CRTMIRROR_BADFREE);
        return;
    }

    if (BootDiskNumber != (ULONG)-1) {

        // If the disk number and original partition number of this
        // region match the recorded disk number and partition number
        // of the boot partition warn the user about mirroring the boot
        // drive.

        if (existingPartition->Disk == BootDiskNumber &&
            existingPartition->OriginalPartitionNumber == BootPartitionNumber) {

            WarningDialog(MSG_MIRROR_OF_BOOT);

            // Set up to write the boot code to the MBR of the mirror.

            UpdateMbrOnDisk = freeSpace->Disk;
        }
    }

    SetCursor(hcurWait);
    regionData = DmAllocatePersistentData(PERSISTENT_DATA(existingPartition)->VolumeLabel,
                                          PERSISTENT_DATA(existingPartition)->TypeName,
                                          PERSISTENT_DATA(existingPartition)->DriveLetter);

    // Finally, create the new partition.

    newSysID = (UCHAR)(existingPartition->SysID | (UCHAR)SYSID_FT);
    CreatePartitionEx(freeSpace,
                      partitionSize,
                      0,
                      freeSpace->RegionType,
                      newSysID);
    DmSetPersistentRegionData(freeSpace, regionData);

    // Set the partition type of the existing partition.

    SetSysID2(existingPartition, newSysID);
    regionArray[0] = existingPartition;
    regionArray[1] = freeSpace;

    FdftCreateFtObjectSet(Mirror,
                          regionArray,
                          2,
                          FtSetNewNeedsInitialization);

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
    CommitDueToMirror = TRUE;
    EnableMenuItem(hMenu,
                   IDM_COMMIT,
                   MF_ENABLED);
}

VOID
DoBreakMirror(
    VOID
    )

/*++

Routine Description:

    Using the global selection variables, this routine will break
    the mirror relationship and modify their region descriptors to
    describe two non-ft partitions giving either the primary member
    of the mirror the drive letter for the mirror, or the only healthy
    member of the mirror the drive letter.  The remaining "new" partition
    will receive the next available drive letter.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD              i;
    PFT_OBJECT_SET     ftSet;
    PFT_OBJECT         ftObject0,
                       ftObject1;
    PREGION_DESCRIPTOR regionDescriptor;
    PPERSISTENT_REGION_DATA regionData;
    ULONG              newDriveLetterRegion;
    CHAR               driveLetter;
    HMENU              hMenu = GetMenu(hwndFrame);

    FDASSERT((SelectionCount) == 1 || (SelectionCount == 2));

    ftObject0 = GET_FT_OBJECT(&SELECTED_REGION(0));
    if (SelectionCount == 2) {
        ftObject1 = GET_FT_OBJECT(&SELECTED_REGION(1));
    } else {
        ftObject1 = NULL;
    }
    ftSet = ftObject0->Set;

    // Determine if the action is allowed.

    switch (ftSet->Status) {

    case FtSetInitializing:
    case FtSetRegenerating:

        ErrorDialog(MSG_CANT_BREAK_INITIALIZING_SET);
        return;
        break;

    default:
        break;
    }

    if (ConfirmationDialog(MSG_CONFIRM_BRK_MIRROR,MB_ICONQUESTION | MB_YESNO) != IDYES) {
        return;
    }

    SetCursor(hcurWait);

    // Figure out which region gets the new drive letter.  A complication is
    // that selection 0 is not necessarily member 0.
    //
    // If there is only one selection, then only one part of the mirror set
    // is present -- no new drive letters are assigned.
    // Otherwise, if one of the members is orphaned, it gets the new
    // drive letter.  Else the secondary member gets the new drive letter.

    if (SelectionCount == 2) {

        if (ftObject0->State == Orphaned) {

            newDriveLetterRegion = 0;
        } else {

            if (ftObject1->State == Orphaned) {

                newDriveLetterRegion = 1;
            } else {

                // Neither member is orphaned;  determine which is
                // member 0 and give the other one the new drive letter.

                if (ftObject0->MemberIndex) {    // secondary member ?

                    newDriveLetterRegion = 0;
                } else {

                    newDriveLetterRegion = 1;
                }
            }
        }
    } else {

        // The one remaining member could be the shadow.
        // The drive letter must move to locate this partition

        regionDescriptor = &SELECTED_REGION(0);
        regionData = PERSISTENT_DATA(regionDescriptor);
        if (!regionData->FtObject->MemberIndex) {

            // The shadow has become the valid partition.
            // move the current letter there.

            CommitToAssignLetterList(regionDescriptor, TRUE);
        }
        newDriveLetterRegion = (ULONG)(-1);
    }

    // if newDriveLetterRegion is -1 this will still work and
    // select the 0 selected region.

    if (CommitToLockList(&SELECTED_REGION(newDriveLetterRegion ? 0 : 1), FALSE, TRUE, FALSE)) {
        if (ConfirmationDialog(MSG_CONFIRM_SHUTDOWN_FOR_MIRROR, MB_ICONQUESTION | MB_YESNO) != IDYES) {
            return;
        }
        RestartRequired = TRUE;
    }

    if (newDriveLetterRegion != (ULONG)(-1)) {
        if (AssignDriveLetter(FALSE, 0, &driveLetter)) {

            // Got a valid drive letter

            MarkDriveLetterUsed(driveLetter);
        } else {

            // didn't get a letter.  Instead the magic value
            // for no drive letter assigned has been returned

        }

        regionDescriptor = &SELECTED_REGION(newDriveLetterRegion);
        regionData = PERSISTENT_DATA(regionDescriptor);
        regionData->DriveLetter = driveLetter;
        CommitToAssignLetterList(regionDescriptor, FALSE);
        if (!regionData->FtObject->MemberIndex) {

            // The shadow has become the valid partition.
            // move the current letter there.

            CommitToAssignLetterList(&SELECTED_REGION(newDriveLetterRegion ? 0 : 1), TRUE);
        }

    } else {
        regionDescriptor = &SELECTED_REGION(0);
        regionData = PERSISTENT_DATA(regionDescriptor);
        if (regionData->FtObject->MemberIndex) {

            // The shadow is all that is left.

            CommitToAssignLetterList(regionDescriptor, TRUE);
        }
    }

    FdftDeleteFtObjectSet(ftSet, FALSE);

    for (i=0; i<SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);
        if (regionDescriptor->Reserved) {
            if (regionDescriptor->Reserved->Partition) {
                regionDescriptor->Reserved->Partition->CommitMirrorBreakNeeded = TRUE;
            }
        }
        SET_FT_OBJECT(regionDescriptor, 0);
        SetSysID2(regionDescriptor, (UCHAR)(regionDescriptor->SysID & ~VALID_NTFT));
    }

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
    CommitDueToMirror = TRUE;
    EnableMenuItem(hMenu,
                   IDM_COMMIT,
                   MF_ENABLED);
}

VOID
DoBreakAndDeleteMirror(
    VOID
    )

/*++

Routine Description:

    This routine will delete the mirror relationship information
    and the member partitions of the mirror.

Arguments:

    None

Return Value:

    None

--*/

{
    PFT_OBJECT_SET      ftSet;
    DWORD               i;
    PREGION_DESCRIPTOR  regionDescriptor;
    CHAR                driveLetter = '\0';

    FDASSERT( SelectionCount == 1 || SelectionCount == 2 );

    // Attempt to lock this before continuing.

    regionDescriptor = &SELECTED_REGION(0);
    if (CommitToLockList(regionDescriptor, TRUE, TRUE, FALSE)) {

        // Could not lock the volume - do not allow delete.

        ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
        return;
    }

    ftSet = (GET_FT_OBJECT(regionDescriptor))->Set;

    // Determine if the action is allowed.

    switch (ftSet->Status) {

    case FtSetInitializing:
    case FtSetRegenerating:

        ErrorDialog(MSG_CANT_DELETE_INITIALIZING_SET);
        return;
        break;

    default:
        break;
    }

    if (ConfirmationDialog(MSG_CONFIRM_BRKANDDEL_MIRROR, MB_ICONQUESTION | MB_YESNO) != IDYES) {
        return;
    }

    SetCursor(hcurWait);
    FdftDeleteFtObjectSet(ftSet, FALSE);
    for (i = 0; i < SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);

        if (i) {
            FDASSERT(PERSISTENT_DATA(regionDescriptor)->DriveLetter == driveLetter);
        } else {
            driveLetter = PERSISTENT_DATA(regionDescriptor)->DriveLetter;
        }

        // Free the pieces of the set.

        DmFreePersistentData(PERSISTENT_DATA(regionDescriptor));
        DmSetPersistentRegionData(regionDescriptor, NULL);
        DeletePartition(regionDescriptor);
    }

    MarkDriveLetterFree(driveLetter);

    // Remember drive letter if there is one in order to lock it for delete.

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}

VOID
DoCreateStripe(
    IN BOOL Parity
    )

/*++

Routine Description:

    This routine starts the dialog with the user to determine
    the parameters of the creation of a stripe or stripe set
    with parity.  Based on the user response it creates the
    internal structures necessary for the creation of a stripe
    or stripe set with parity.

    The regions involved in the stripe creation are located via
    the global parameters for multiple selections.

Arguments:

    Parity - boolean to indicate the presence of parity in the stripe.

Return Value

    None

--*/

{
    MINMAXDLG_PARAMS params;
    DWORD            smallestSize = (DWORD)(-1);
    DWORD            creationSize;
    unsigned         i;
    PREGION_DESCRIPTOR regionDescriptor,
                       regionArray[MaxMembersInFtSet];
    PPERSISTENT_REGION_DATA regionData;
    CHAR             DriveLetter;


    // Make sure that the volume set does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_STRIPE);
            return;
        }
    }

    // Scan the disks to determine the maximum size, which is
    // the size of the smallest partition times the number of
    // partitions.

    for (i=0; i<SelectionCount; i++) {
        FDASSERT(SELECTED_REGION(i).SysID == SYSID_UNUSED);
        if (SELECTED_REGION(i).SizeMB < smallestSize) {
            smallestSize = SELECTED_REGION(i).SizeMB;
        }
    }

    // Figure out a drive letter.

    if (!AssignDriveLetter(TRUE, IDS_STRIPESET, &DriveLetter)) {
        return;
    }

    params.CaptionStringID = Parity ? IDS_CRTPSTRP_CAPTION : IDS_CRTSTRP_CAPTION;
    params.MinimumStringID = IDS_CRTSTRP_MIN;
    params.MaximumStringID = IDS_CRTSTRP_MAX;
    params.SizeStringID    = IDS_CRTSTRP_SIZE;
    params.MinSizeMB       = SelectionCount;
    params.MaxSizeMB       = smallestSize * SelectionCount;
    if (Parity) {
        params.HelpContextId   = HC_DM_DLG_CREATEPARITYSTRIPE;
    } else {
        params.HelpContextId   = HC_DM_DLG_CREATESTRIPESET;
    }

    creationSize = DialogBoxParam(hModule,
                                  MAKEINTRESOURCE(IDD_MINMAX),
                                  hwndFrame,
                                  MinMaxDlgProc,
                                  (LONG)&params);

    if (!creationSize) {     // user cancelled
        return;
    }

    // Determine how large we have to make each member of the stripe set.

    creationSize = (creationSize / SelectionCount);
    FDASSERT(creationSize <= smallestSize);
    if (creationSize % SelectionCount) {
        creationSize++;                             // round up.
    }

    SetCursor(hcurWait);

    // Make sure we are allowed to create all the partitions

    for (i=0; i<SelectionCount; i++) {
        regionDescriptor = &SELECTED_REGION(i);
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        if (!(    ((regionDescriptor->RegionType == REGION_LOGICAL) && SelectedDS[i]->CreateLogical)
               || ((regionDescriptor->RegionType == REGION_PRIMARY) && SelectedDS[i]->CreatePrimary))) {
            SetCursor(hcurNormal);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }

    }

    // Now actually perform the creation.

    for (i=0; i<SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);

        CreatePartitionEx(regionDescriptor,
                          RtlConvertLongToLargeInteger(0L),
                          creationSize,
                          regionDescriptor->RegionType,
                          (UCHAR)(SYSID_BIGFAT | SYSID_FT));

        // Finish setting up the FT set

        regionData = DmAllocatePersistentData(L"", wszNewUnformatted, DriveLetter);
        DmSetPersistentRegionData(regionDescriptor, regionData);
        regionArray[i] = regionDescriptor;
    }

    // The zeroth element is the one to assign the drive letter to.

    CommitToAssignLetterList(&SELECTED_REGION(0), FALSE);

    FdftCreateFtObjectSet(Parity ? StripeWithParity : Stripe,
                          regionArray,
                          SelectionCount,
                          Parity ? FtSetNewNeedsInitialization : FtSetNew);
    MarkDriveLetterUsed(DriveLetter);
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}


VOID
DoDeleteStripeOrVolumeSet(
    IN DWORD ConfirmationMsg
    )

/*++

Routine Description:

    Common code for the deletion of a stripe or volume set.
    This routine will display a message giving the user a 2nd
    chance to change their mind, then based on the answer perform
    the work of deleting the item.  This consists of removing
    the region descriptors (and related information) from the
    collection of Disk structures.

Arguments:

    ConfirmationMsg - text for comfirming what is being deleted.

Return Value:

    None

--*/

{
    DWORD              i;
    PFT_OBJECT_SET     ftSet;
    PFT_OBJECT         ftObject;
    PREGION_DESCRIPTOR regionDescriptor;
    FT_SET_STATUS      setState;
    ULONG              numberOfMembers;
    CHAR               driveLetter = '\0';
    BOOL               setIsHealthy = TRUE;

    regionDescriptor = &SELECTED_REGION(0);

    // Determine if the action is allowed.

    ftObject = GET_FT_OBJECT(regionDescriptor);
    ftSet = ftObject->Set;

    LowFtVolumeStatus(regionDescriptor->Disk,
                      regionDescriptor->PartitionNumber,
                      &setState,
                      &numberOfMembers);

    if (ftSet->Status != setState) {
        ftSet->Status = setState;
    }

    switch (ftSet->Status) {
    case FtSetDisabled:
        setIsHealthy = FALSE;
        break;

    case FtSetInitializing:
    case FtSetRegenerating:

        ErrorDialog(MSG_CANT_DELETE_INITIALIZING_SET);
        return;
        break;

    default:
        break;
    }

    // Attempt to lock this before continuing.

    if (CommitToLockList(regionDescriptor, TRUE, setIsHealthy, TRUE)) {

        // Could not lock the volume - try again, the file systems appear
        // to be confused.

        if (CommitToLockList(regionDescriptor, TRUE, setIsHealthy, TRUE)) {

            // Don't allow the delete.

            ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
            return;
        }
    }

    if (ConfirmationDialog(ConfirmationMsg,MB_ICONQUESTION | MB_YESNO) != IDYES) {
        return;
    }

    // Delete all partitions that are part of the stripe set

    SetCursor(hcurWait);
    FdftDeleteFtObjectSet(ftSet,FALSE);

    for (i=0; i<SelectionCount; i++) {
        ULONG diskNumber;

        regionDescriptor = &SELECTED_REGION(i);

        if (i) {
            FDASSERT(PERSISTENT_DATA(regionDescriptor)->DriveLetter == driveLetter);
        } else {
            driveLetter = PERSISTENT_DATA(regionDescriptor)->DriveLetter;
        }

        diskNumber = regionDescriptor->Disk;
        DmFreePersistentData(PERSISTENT_DATA(regionDescriptor));
        DmSetPersistentRegionData(regionDescriptor, NULL);
        DeletePartition(regionDescriptor);
    }

    // Mark the drive letter that was being used by the stripe or volume
    // set free.

    MarkDriveLetterFree(driveLetter);

    // Remember drive letter if there is one in order to lock it for delete.

    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}


VOID
DoDeleteStripe(
    VOID
    )

/*++

Routine Description:

    Routine is called to delete a stripe.  It calls a general
    routine for stripe and volume set deletion.

Arguments:

    None

Return Value:

    None

--*/

{
    DoDeleteStripeOrVolumeSet(MSG_CONFIRM_DEL_STRP);
}


VOID
DoCreateVolumeSet(
    VOID
    )

/*++

Routine Description:

    This routine uses the global selection information to collect
    a group of freespace regions on the disks and organize them into
    a volume set.

Arguments:

    None

Return Value:

    None

--*/

{
    MINMAXDLG_PARAMS params;
    DWORD            creationSize,
                     size,
                     maxTotalSize=0,
                     totalSizeUsed;
    DWORD            sizes[MaxMembersInFtSet];
    PULONG           primarySpacesToUseOnDisk;
    CHAR             driveLetter;
    unsigned         i;
    PREGION_DESCRIPTOR regionDescriptor,
                       regionArray[MaxMembersInFtSet];
    PPERSISTENT_REGION_DATA regionData;

    // Make sure that the volume set does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_VOLUMESET);
            return;
        }
    }

    for (i=0; i<SelectionCount; i++) {
        FDASSERT(SELECTED_REGION(i).SysID == SYSID_UNUSED);
        size = SELECTED_REGION(i).SizeMB;
        sizes[i] = size;
        maxTotalSize += size;
    }

    // Figure out a drive letter.

    if (!AssignDriveLetter(TRUE, IDS_VOLUMESET, &driveLetter)) {
        return;
    }

    params.CaptionStringID = IDS_CRTVSET_CAPTION;
    params.MinimumStringID = IDS_CRTVSET_MIN;
    params.MaximumStringID = IDS_CRTVSET_MAX;
    params.SizeStringID    = IDS_CRTVSET_SIZE;
    params.MinSizeMB       = SelectionCount;
    params.MaxSizeMB       = maxTotalSize;
    params.HelpContextId   = HC_DM_DLG_CREATEVOLUMESET;

    creationSize = DialogBoxParam(hModule,
                                  MAKEINTRESOURCE(IDD_MINMAX),
                                  hwndFrame,
                                  MinMaxDlgProc,
                                  (LONG)&params);

    if (!creationSize) {     // user cancelled
        return;
    }

    // Determine how large we have to make each member of the volume set.
    // The percentage of each free space that will be used is the ratio
    // of the total space he chose to the total free space.
    //
    // Example: 2 75 meg free spaces for a total set size of 150 MB.
    //          User chooses a set size of 100 MB.  Use 50 MB of each space.

    totalSizeUsed = 0;

    for (i=0; i<SelectionCount; i++) {
        sizes[i] = sizes[i] * creationSize / maxTotalSize;
        if ((sizes[i] * creationSize) % maxTotalSize) {
            sizes[i]++;
        }

        if (sizes[i] == 0) {
            sizes[i]++;
        }

        totalSizeUsed += sizes[i];
    }

    // Make sure that the total amount used is not greater than the
    // maximum amount available.  Note that this loop is certain
    // to terminate because maxTotalSize >= SelectionCount; if
    // each of the sizes goes down to one, we will exit the loop

    while (totalSizeUsed > maxTotalSize) {

        for (i=0; (i<SelectionCount) && (totalSizeUsed > maxTotalSize); i++) {

             if (sizes[i] > 1) {

                sizes[i]--;
                totalSizeUsed--;
            }
        }
    }

    SetCursor(hcurWait);

    // Make sure that we are allowed to create a partition in the space.
    // This is tricky because a volume set could contain more than one
    // primary partition on a disk -- which means that if we're not careful
    // we could create a disk with more than 4 primary partitions!

    primarySpacesToUseOnDisk = Malloc(DiskCount * sizeof(ULONG));
    RtlZeroMemory(primarySpacesToUseOnDisk, DiskCount * sizeof(ULONG));

    for (i=0; i<SelectionCount; i++) {
        regionDescriptor = &SELECTED_REGION(i);
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        if (regionDescriptor->RegionType == REGION_PRIMARY) {
            primarySpacesToUseOnDisk[SelectedDS[i]->Disk]++;
        }

        if (!(    ((regionDescriptor->RegionType == REGION_LOGICAL) && SelectedDS[i]->CreateLogical)
               || ((regionDescriptor->RegionType == REGION_PRIMARY) && SelectedDS[i]->CreatePrimary)))
        {
            SetCursor(hcurNormal);
            Free(primarySpacesToUseOnDisk);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }
    }

    // Look through the array we built to see whether we are supposed to use
    // more than one primary partition on a given disk.  For each such disk,
    // make sure that we can actually create that many primary partitions.

    for (i=0; i<DiskCount; i++) {

        // If there are not enough primary partition slots, fail.

        if ((primarySpacesToUseOnDisk[i] > 1)
        &&  (4 - PartitionCount(i) < primarySpacesToUseOnDisk[i]))
        {
            SetCursor(hcurNormal);
            Free(primarySpacesToUseOnDisk);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }
    }

    Free(primarySpacesToUseOnDisk);

    // Now actually perform the creation.

    for (i=0; i<SelectionCount; i++) {

        regionDescriptor = &SELECTED_REGION(i);
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        CreatePartitionEx(regionDescriptor,
                          RtlConvertLongToLargeInteger(0L),
                          sizes[i],
                          regionDescriptor->RegionType,
                          (UCHAR)(SYSID_BIGFAT | SYSID_FT));

        regionData = DmAllocatePersistentData(L"", wszNewUnformatted, driveLetter);
        DmSetPersistentRegionData(regionDescriptor, regionData);
        regionArray[i] = regionDescriptor;
    }

    // The zeroth element is the one to assign the drive letter to.

    FdftCreateFtObjectSet(VolumeSet, regionArray, SelectionCount, FtSetNew);
    MarkDriveLetterUsed(driveLetter);
    CommitToAssignLetterList(&SELECTED_REGION(0), FALSE);
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}


VOID
DoExtendVolumeSet(
    VOID
    )

/*++

Routine Description:

    This routine uses the global selection item information to
    add additional freespace to an existing volume set or partition.

Arguments:

    None

Return Value:

    None

--*/

{
    MINMAXDLG_PARAMS    params;
    DWORD               currentSize = 0,
                        freeSize = 0,
                        maxTotalSize = 0,
                        newSize = 0,
                        totalFreeSpaceUsed,
                        freeSpaceUsed,
                        Size;
    DWORD               Sizes[MaxMembersInFtSet];
    ULONG               nonFtPartitions = 0,
                        numberOfFreeRegions = 0;
    PULONG              primarySpacesToUseOnDisk;
    WCHAR               driveLetter = L' ';
    PWSTR               typeName = NULL,
                        volumeLabel = NULL;
    PREGION_DESCRIPTOR  regionDescriptor;
    PREGION_DESCRIPTOR  newRegions[MaxMembersInFtSet];
    PREGION_DESCRIPTOR  convertedRegion;
    PFT_OBJECT_SET      ftSet = NULL;
    PPERSISTENT_REGION_DATA regionData;
    unsigned            i;
    DWORD               ec;


    // Make sure that the volume set does not include any
    // partitions on removable media.

    for (i=0; i<SelectionCount; i++) {

        if (IsDiskRemovable[SELECTED_REGION(i).Disk]) {

            ErrorDialog(MSG_NO_REMOVABLE_IN_VOLUMESET);
            return;
        }
    }


    // First, determine the current size of the volume set,
    // it's file system type and associated drive letter,
    // and the size of the selected free space

    for (i = 0; i < SelectionCount; i++) {

        regionDescriptor = &(SELECTED_REGION(i));

        Size = regionDescriptor->SizeMB;
        Sizes[i] = Size;
        maxTotalSize += Size;

        if (regionDescriptor->SysID == SYSID_UNUSED) {

            // This region is a chunk of free space; include it
            // in the free space tallies.

            newRegions[numberOfFreeRegions] = regionDescriptor;
            Sizes[numberOfFreeRegions] = Size;

            numberOfFreeRegions++;
            freeSize += Size;

        } else if (GET_FT_OBJECT(regionDescriptor)) {

            // This is an element of an existing volume set.

            currentSize += Size;

            if ( ftSet == NULL ) {

                DetermineRegionInfo(regionDescriptor,
                                    &typeName,
                                    &volumeLabel,
                                    &driveLetter);
                ftSet = GET_FT_OBJECT(regionDescriptor)->Set;
            }

        } else {

            // This is a non-FT partition.

            nonFtPartitions++;
            DetermineRegionInfo(regionDescriptor,
                                &typeName,
                                &volumeLabel,
                                &driveLetter);
            currentSize = Size;
            convertedRegion = regionDescriptor;
        }
    }

    // Check for consistency: the selection must have either a volume
    // set or a partition, but not both, and cannot have more than
    // one non-FT partition.

    if (nonFtPartitions > 1 ||
        (ftSet != NULL && nonFtPartitions != 0) ||
        (ftSet == NULL && nonFtPartitions == 0)) {

        return;
    }


    if (nonFtPartitions != 0 &&
        (ec = DeletionIsAllowed(convertedRegion)) != NO_ERROR) {

        // If the error-message is delete-specific, remap it.
        //
        switch( ec ) {
#if i386
        case MSG_CANT_DELETE_ACTIVE0:   ec = MSG_CANT_EXTEND_ACTIVE0;
                                        break;
#endif
        case MSG_CANT_DELETE_WINNT:     ec = MSG_CANT_EXTEND_WINNT;
                                        break;
        default:                        break;
        }

        ErrorDialog(ec);
        return;
    }

    if (wcscmp(typeName, L"NTFS") != 0) {

        ErrorDialog(MSG_EXTEND_VOLSET_MUST_BE_NTFS);
        return;
    }


    params.CaptionStringID = IDS_EXPVSET_CAPTION;
    params.MinimumStringID = IDS_CRTVSET_MIN;
    params.MaximumStringID = IDS_CRTVSET_MAX;
    params.SizeStringID    = IDS_CRTVSET_SIZE;
    params.MinSizeMB       = currentSize + numberOfFreeRegions;
    params.MaxSizeMB       = maxTotalSize;
    params.HelpContextId   = HC_DM_DLG_EXTENDVOLUMESET;

    newSize = DialogBoxParam(hModule,
                             MAKEINTRESOURCE(IDD_MINMAX),
                             hwndFrame,
                             MinMaxDlgProc,
                             (LONG)&params);

    if (!newSize) {     // user cancelled
        return;
    }

    // Determine how large to make each new member of the volume
    // set.  The percentage of free space to use is the ratio of
    // the amount by which the volume set will grow to the total
    // free space.

    freeSpaceUsed = newSize - currentSize;
    totalFreeSpaceUsed = 0;

    for ( i = 0; i < numberOfFreeRegions; i++ ) {

        Sizes[i] = Sizes[i] * freeSpaceUsed / freeSize;
        if ((Sizes[i] * freeSpaceUsed) % freeSize) {
            Sizes[i]++;
        }

        if (Sizes[i] == 0) {
            Sizes[i]++;
        }

        totalFreeSpaceUsed += Sizes[i];
    }

    // Make sure that the total amount of free space used is not
    // greater than the amount available.  Note that this loop is
    // certain to terminate because the amount of free space used
    // is >= the number of free regions, so this loop will exit
    // if one megabyte is used in each free region (the degenerate
    // case).

    while (totalFreeSpaceUsed > freeSize) {

        for (i = 0;
             (i < numberOfFreeRegions) && (totalFreeSpaceUsed > freeSize);
             i++) {

            if ( Sizes[i] > 1 ) {

                Sizes[i]--;
                totalFreeSpaceUsed--;
            }
        }
    }

    SetCursor(hcurWait);

    // Make sure that we are allowed to create a partition in the space.
    //
    // This is tricky because a volume set could contain more than one
    // primary partition on a disk -- which means that if we're not careful
    // we could create a disk with more than 4 primary partitions!

    primarySpacesToUseOnDisk = Malloc(DiskCount * sizeof(ULONG));
    RtlZeroMemory(primarySpacesToUseOnDisk, DiskCount * sizeof(ULONG));

    for (i=0; i<SelectionCount; i++) {
        regionDescriptor = &SELECTED_REGION(i);

        if (regionDescriptor->SysID == SYSID_UNUSED) {

            FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

            if (regionDescriptor->RegionType == REGION_PRIMARY) {
                primarySpacesToUseOnDisk[SelectedDS[i]->Disk]++;
            }

            if (!(   ((regionDescriptor->RegionType == REGION_LOGICAL) && SelectedDS[i]->CreateLogical)
                  || ((regionDescriptor->RegionType == REGION_PRIMARY) && SelectedDS[i]->CreatePrimary))) {
                SetCursor(hcurNormal);
                Free(primarySpacesToUseOnDisk);
                ErrorDialog(MSG_CRTSTRP_FULL);
                return;
            }
        }
    }

    // Look through the array we built to see whether we are supposed to use
    // more than one primary partition on a given disk.  For each such disk,
    // make sure that we can actually create that many primary partitions.

    for (i=0; i<DiskCount; i++) {

        // If there are not enough primary partition slots, fail.

        if ((primarySpacesToUseOnDisk[i] > 1)
             && (4 - PartitionCount(i) < primarySpacesToUseOnDisk[i])) {
            SetCursor(hcurNormal);
            Free(primarySpacesToUseOnDisk);
            ErrorDialog(MSG_CRTSTRP_FULL);
            return;
        }
    }

    // Now actually perform the creation.

    for (i=0; i<numberOfFreeRegions; i++) {

        regionDescriptor = newRegions[i];
        FDASSERT(regionDescriptor->RegionType != REGION_EXTENDED);

        CreatePartitionEx(regionDescriptor,
                          RtlConvertLongToLargeInteger(0L),
                          Sizes[i],
                          regionDescriptor->RegionType,
                          (UCHAR)(SYSID_IFS | SYSID_FT));
        regionData = DmAllocatePersistentData(volumeLabel, typeName, (CHAR)driveLetter);
        DmSetPersistentRegionData(regionDescriptor, regionData);
    }

    if (nonFtPartitions != 0) {

        // Create the volume set so we can extend it

        FdftCreateFtObjectSet(VolumeSet, &convertedRegion, 1, FtSetExtended);
        ftSet = GET_FT_OBJECT(convertedRegion)->Set;

        // Set the converted region's partition System Id to indicate
        // that it is now part of a volume set.

        SetSysID2(convertedRegion, (UCHAR)(convertedRegion->SysID | SYSID_FT));
    }

    FdftExtendFtObjectSet(ftSet, newRegions, numberOfFreeRegions);
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}

VOID
DoDeleteVolumeSet(
    VOID
    )

/*++

Routine Description:

    Routine is called to delete a volume set.  It calls a general
    routine for stripe and volume set deletion.

Arguments:

    None

Return Value:

    None

--*/

{
    DoDeleteStripeOrVolumeSet(MSG_CONFIRM_DEL_VSET);
}

extern ULONG OrdinalToAllocate[];

VOID
DoRecoverStripe(
    VOID
    )

/*++

Routine Description:

    Using the global selection information this routine will
    set up a stripe with parity such that a problem member is
    regenerated.  This new member may either be the problem member
    (i.e. regeneration is "in place") or new free space on a
    different disk.

Arguments:

    None

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR freeSpace = NULL;
    PREGION_DESCRIPTOR unhealthy = NULL;
    ULONG              freeSpaceI = 0;
    ULONG              i;
    PREGION_DESCRIPTOR regionArray[MaxMembersInFtSet];
    LARGE_INTEGER      minimumSize;
    PFT_OBJECT         ftObject;

    // Initialize minimumSize to the maximum possible positive value

    minimumSize.HighPart = 0x7FFFFFFF;
    minimumSize.LowPart = 0xFFFFFFFF;

    if ((!IsRegionCommitted(&SELECTED_REGION(0))) &&
        (!IsRegionCommitted(&SELECTED_REGION(1)))) {
        ErrorDialog(MSG_NOT_COMMITTED);
        return;
    }

    FDASSERT(SelectionCount > 1);
    FDASSERT(SelectionCount <= MaxMembersInFtSet);

    SetCursor(hcurWait);

    // Determine the exact size of the smallest member of the stripe set.
    // If the user is regenerating using an additional free space, this
    // will be the size requirement for the free space.
    // Also find the free space (if any).
    // If there is no free space, then we're doing an 'in-place' recover
    // (ie regnerating into the unhealthy member).  If there is a free space,
    // make sure we are allowed to create a partition or logical drive in it.

    for (i=0; i<SelectionCount; i++) {

        regionArray[i] = &SELECTED_REGION(i);

        FDASSERT(!IsExtended(regionArray[i]->SysID));

        if (regionArray[i]->SysID == SYSID_UNUSED) {

            PDISKSTATE ds;

            FDASSERT(freeSpace == NULL);

            freeSpace  = regionArray[i];
            freeSpaceI = i;

            // Make sure we are allowed to create a partition or logical
            // drive in the selected free space.

            ds = SelectedDS[freeSpaceI];

            if (!(  ((freeSpace->RegionType == REGION_LOGICAL) && ds->CreateLogical)
                 || ((freeSpace->RegionType == REGION_PRIMARY) && ds->CreatePrimary))) {
                SetCursor(hcurNormal);
                ErrorDialog(MSG_CRTSTRP_FULL);
                return;
            }
        } else {

            LARGE_INTEGER largeTemp;

            largeTemp = FdGetExactSize(regionArray[i], FALSE);
            if (largeTemp.QuadPart < minimumSize.QuadPart) {
                minimumSize = largeTemp;
            }

            if (GET_FT_OBJECT(regionArray[i])->State != Healthy) {
                FDASSERT(unhealthy == NULL);
                unhealthy = regionArray[i];
            }
        }
    }

    // If there is a free space, place it at item 0 of the regionArray
    // to simplify processing later.

    if (freeSpace) {
        PREGION_DESCRIPTOR tempRegion = regionArray[0];

        regionArray[0] = regionArray[freeSpaceI];
        regionArray[freeSpaceI] = tempRegion;
        i = 1;
    } else {
        i = 0;
    }

    // Get a pointer to the FT object for the broken member.  Can't do this
    // in the loop above because the broken member might be on an off-line
    // disk.

    for (ftObject=GET_FT_OBJECT(regionArray[i])->Set->Members; ftObject; ftObject = ftObject->Next) {
        if (ftObject->State != Healthy) {
            break;
        }
    }
    FDASSERT(ftObject);

    // Determine if the action is allowed.

    if (ftObject->Set) {
        switch (ftObject->Set->Status) {

        case FtSetInitializing:
        case FtSetRegenerating:

            ErrorDialog(MSG_CANT_REGEN_INITIALIZING_SET);
            return;
            break;

        default:
            break;
        }
    }

    // Must lock the volume to perform this operation.

    if (CommitToLockList(regionArray[i], FALSE, TRUE, FALSE)) {

        // Could not lock the volume - try again, the file systems appear
        // to be confused.

        if (CommitToLockList(regionArray[i], FALSE, TRUE, FALSE)) {

            // Don't allow the delete.

            ErrorDialog(MSG_CANNOT_LOCK_TRY_AGAIN);
            return;
        }
    }

    if (freeSpace) {

        LARGE_INTEGER           temp;
        PPERSISTENT_REGION_DATA regionData,
                                regionDataTemp;

        // Make sure the free space region is large enough.

        temp = FdGetExactSize(freeSpace, FALSE);
        if (temp.QuadPart < minimumSize.QuadPart) {
            SetCursor(hcurNormal);
            ErrorDialog(MSG_NOT_LARGE_ENOUGH_FOR_STRIPE);
            return;
        }

        // Create the new partition.

        CreatePartitionEx(freeSpace,
                          minimumSize,
                          0,
                          freeSpace->RegionType,
                          regionArray[1]->SysID);

        // Set up the new partition's persistent data

        regionDataTemp = PERSISTENT_DATA(regionArray[1]);
        regionData = DmAllocatePersistentData(regionDataTemp->VolumeLabel,
                                              regionDataTemp->TypeName,
                                              regionDataTemp->DriveLetter);
        regionData->FtObject = ftObject;
        DmSetPersistentRegionData(freeSpace, regionData);

        // Check to see if member zero of the set changed and
        // the drive letter needs to move.

        if (!ftObject->MemberIndex) {

            // This is member zero.  Move the drive letter to the
            // new region descriptor.

            CommitToAssignLetterList(freeSpace, TRUE);
        }

        // If the unhealthy member is on-line, delete it.
        // Otherwise remove it from the off-line disk.

        if (unhealthy) {
            DmFreePersistentData(PERSISTENT_DATA(unhealthy));
            DmSetPersistentRegionData(unhealthy, NULL);
            DeletePartition(unhealthy);
        }

        // Remove any offline disks - this doesn't really
        // delete the set.

        FdftDeleteFtObjectSet(ftObject->Set, TRUE);
    }

    ftObject->Set->Ordinal = FdftNextOrdinal(StripeWithParity);
    ftObject->State = Regenerating;
    ftObject->Set->Status = FtSetRecovered;
    RegistryChanged = TRUE;
    CompleteMultiRegionOperation();
    SetCursor(hcurNormal);
}

VOID
AdjustOptionsMenu(
    VOID
    )

/*++

Routine Description:

    This routine updates the options menu (i.e. maintains
    the state of the menu items for whether the status bar
    or legend are displayed).

Arguments:

    None

Return Value:

    None

--*/

{
    RECT  rc;

    CheckMenuItem(GetMenu(hwndFrame),
                  IDM_OPTIONSSTATUS,
                  MF_BYCOMMAND | (StatusBar ? MF_CHECKED : MF_UNCHECKED));
    CheckMenuItem(GetMenu(hwndFrame),
                  IDM_OPTIONSLEGEND,
                  MF_BYCOMMAND | (Legend ? MF_CHECKED : MF_UNCHECKED));
    GetClientRect(hwndFrame, &rc);
    SendMessage(hwndFrame, WM_SIZE, SIZENORMAL, MAKELONG(rc.right, rc.bottom));
    InvalidateRect(hwndFrame, NULL, TRUE);
}

VOID
FrameCommandHandler(
    IN HWND  hwnd,
    IN DWORD wParam,
    IN LONG  lParam
    )

/*++

Routine Description:

    This routine handles WM_COMMAND messages for the frame window.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD   i,
            pos;
    DWORD   HelpFlag;
    POINT   point;

    switch (LOWORD(wParam)) {

    case IDM_PARTITIONCREATE:

        DoCreate(REGION_PRIMARY);
        break;

    case IDM_PARTITIONCREATEEX:

        DoCreate(REGION_EXTENDED);
        break;

    case IDM_PARTITIONDELETE:

        switch (FtSelectionType) {

        case Mirror:

            DoBreakAndDeleteMirror();
            break;

        case Stripe:
        case StripeWithParity:
            DoDeleteStripe();
            break;

        case VolumeSet:
            DoDeleteVolumeSet();
            break;

        default:
            DoDelete();
            break;
        }

        break;

#if i386

    case IDM_PARTITIONACTIVE:

        DoMakeActive();
        break;
#endif

    case IDM_SECURESYSTEM:

        DoProtectSystemPartition();
        break;

    case IDM_PARTITIONLETTER:
    {
        int driveLetterIn,
            driveLetterOut;
        PREGION_DESCRIPTOR      regionDescriptor;
        PPERSISTENT_REGION_DATA regionData;
        PFT_OBJECT              ftObject;
        ULONG                   index;

        regionDescriptor = &SELECTED_REGION(0);
        FDASSERT(regionDescriptor);
        regionData = PERSISTENT_DATA(regionDescriptor);
        FDASSERT(regionData);

        if (ftObject = regionData->FtObject) {

            // Must find the zero member of this set for the
            // drive letter assignment.  Search all of the selected
            // regions

            index = 0;
            while (ftObject->MemberIndex) {

                // search the next selected item if there is one

                index++;
                if (index >= SelectionCount) {
                    ftObject = NULL;
                    break;
                }
                regionDescriptor = &SELECTED_REGION(index);
                FDASSERT(regionDescriptor);
                regionData = PERSISTENT_DATA(regionDescriptor);
                FDASSERT(regionData);
                ftObject = regionData->FtObject;

                // must have an FtObject to continue

                if (!ftObject) {
                    break;
                }
            }

            if (!ftObject) {

                // This is really an internal error.
            }

            // regionDescriptor locates the zero element now.
        }
        driveLetterIn = (int)(UCHAR)regionData->DriveLetter;

        if (IsDiskRemovable[regionDescriptor->Disk]) {
            ErrorDialog(MSG_CANT_ASSIGN_LETTER_TO_REMOVABLE);
        } else if (AllDriveLettersAreUsed() && ((driveLetterIn == NO_DRIVE_LETTER_YET) || (driveLetterIn == NO_DRIVE_LETTER_EVER))) {
            ErrorDialog(MSG_ALL_DRIVE_LETTERS_USED);
        } else {
            driveLetterOut = DialogBoxParam(hModule,
                                            MAKEINTRESOURCE(IDD_DRIVELET),
                                            hwndFrame,
                                            DriveLetterDlgProc,
                                            (LONG)regionDescriptor);
            if (driveLetterOut) {
                LETTER_ASSIGNMENT_RESULT result;

                if ((driveLetterIn == NO_DRIVE_LETTER_YET) || (driveLetterIn == NO_DRIVE_LETTER_EVER)) {

                    // Must insure that driveLetterIn maps to same things
                    // as is returned by the dialog when the user selects
                    // no letter.

                    driveLetterIn = NO_DRIVE_LETTER_EVER;
                }
                if (driveLetterOut != driveLetterIn) {
                    if (result = CommitDriveLetter(regionDescriptor, (CHAR) driveLetterIn, (CHAR)driveLetterOut)) {

                        // The following would be more rigorously correct:
                        // if non-ft, just set regionData->DriveLetter.  If
                        // ft, scan all regions on all disks for members of
                        // ft set and set their drive letter fields.
                        //
                        // The below is probably correct, though.

                        for (i=0; i<SelectionCount; i++) {
                            PERSISTENT_DATA(&SELECTED_REGION(i))->DriveLetter = (CHAR)driveLetterOut;
                        }

                        // Don't allow the letter that is actually in use
                        // and will only change on a reboot to cycle back
                        // into the free list.

                        if (result != MustReboot) {

                            // Mark old letter free, new one used.

                            MarkDriveLetterFree((CHAR)driveLetterIn);
                        }
                        MarkDriveLetterUsed((CHAR)driveLetterOut);

                        // force status area and all disk bars to be redrawn

                        if (SelectionCount > 1) {
                            CompleteMultiRegionOperation();
                        } else {
                            CompleteSingleRegionOperation(SingleSel);
                        }
                        EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_GRAYED);
                    }
                }
            }
        }
        break;
    }

    case IDM_PARTITIONFORMAT: {
        PREGION_DESCRIPTOR regionDescriptor;

        regionDescriptor = &SELECTED_REGION(0);
        FDASSERT(regionDescriptor);
        FormatPartition(regionDescriptor);
        break;
    }

    case IDM_PARTITIONLABEL: {
        PREGION_DESCRIPTOR regionDescriptor;

        regionDescriptor = &SELECTED_REGION(0);
        FDASSERT(regionDescriptor);
        LabelPartition(regionDescriptor);
        break;
    }

    case IDM_PARTITIONEXIT:

        SendMessage(hwndFrame,WM_CLOSE,0,0);
        break;

    case IDM_CONFIGMIGRATE:

        if (DoMigratePreviousFtConfig()) {

            // Determine if the FT driver must be enabled.

            SetCursor(hcurWait);
            Sleep(2000);
            if (DiskRegistryRequiresFt() == TRUE) {
                DiskRegistryEnableFt();
            } else {
                DiskRegistryDisableFt();
            }

            // wait four seconds before shutdown

            Sleep(4000);
            SetCursor(hcurNormal);
            FdShutdownTheSystem();
        }
        break;

    case IDM_CONFIGSAVE:

        DoSaveFtConfig();
        break;

    case IDM_CONFIGRESTORE:

        if (DoRestoreFtConfig()) {

            // Determine if the FT driver must be enabled.

            if (DiskRegistryRequiresFt() == TRUE) {
                DiskRegistryEnableFt();
            } else {
                DiskRegistryDisableFt();
            }

            // wait five seconds before shutdown

            SetCursor(hcurWait);
            Sleep(5000);
            SetCursor(hcurNormal);
            FdShutdownTheSystem();
        }
        break;

    case IDM_FTESTABLISHMIRROR:

        DoEstablishMirror();
        break;

    case IDM_FTBREAKMIRROR:

        DoBreakMirror();
        break;

    case IDM_FTCREATESTRIPE:

        DoCreateStripe(FALSE);
        break;

    case IDM_FTCREATEPSTRIPE:

        DoCreateStripe(TRUE);
        break;

    case IDM_FTCREATEVOLUMESET:

        DoCreateVolumeSet();
        break;

    case IDM_FTEXTENDVOLUMESET:

        DoExtendVolumeSet();
        break;

    case IDM_FTRECOVERSTRIPE:

        DoRecoverStripe();
        break;

#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
    case IDM_DBLSPACE:
        DblSpace(hwndFrame, NULL);
        break;

    case IDM_AUTOMOUNT:  {
        HMENU hMenu;

        if (DoubleSpaceAutomount) {
            DoubleSpaceAutomount = FALSE;
        } else {
            DoubleSpaceAutomount = TRUE;
        }
        DiskRegistryDblSpaceRemovable(DoubleSpaceAutomount);
        hMenu = GetMenu(hwndFrame);
        CheckMenuItem(hMenu,
                      IDM_AUTOMOUNT,
                      (DoubleSpaceAutomount) ? MF_CHECKED : MF_UNCHECKED);
        break;
    }
#endif

    case IDM_CDROM:
        CdRom(hwndFrame, NULL);
        break;

    case IDM_COMMIT:
        CommitAllChanges(NULL);
        EnableMenuItem(GetMenu(hwndFrame), IDM_CONFIGSAVE, MF_ENABLED);
        break;

    case IDM_OPTIONSSTATUS:

        StatusBar = !StatusBar;
        AdjustOptionsMenu();
        break;

    case IDM_OPTIONSLEGEND:

        Legend = !Legend;
        AdjustOptionsMenu();
        break;

    case IDM_OPTIONSCOLORS:

        switch(DialogBox(hModule, MAKEINTRESOURCE(IDD_COLORS), hwnd, ColorDlgProc)) {
        case IDOK:
            for (i=0; i<BRUSH_ARRAY_SIZE; i++) {
                DeleteObject(Brushes[i]);
                Brushes[i] = CreateHatchBrush(AvailableHatches[BrushHatches[i] = SelectedHatch[i]],
                                              AvailableColors[BrushColors[i] = SelectedColor[i]]);
            }
            SetCursor(hcurWait);
            TotalRedrawAndRepaint();
            if (Legend) {
                InvalidateRect(hwndFrame, NULL, FALSE);
            }
            SetCursor(hcurNormal);
            break;

        case IDCANCEL:
            break;

        case -1:
            ErrorDialog(ERROR_NOT_ENOUGH_MEMORY);
            break;

        default:
            FDASSERT(0);
        }
        break;

    case IDM_OPTIONSDISPLAY: {

        PBAR_TYPE newBarTypes = Malloc(DiskCount * sizeof(BAR_TYPE));

        for (i=0; i<DiskCount; i++) {
            newBarTypes[i] = Disks[i]->BarType;
        }

        switch (DialogBoxParam(hModule,
                               MAKEINTRESOURCE(IDD_DISPLAYOPTIONS),
                               hwnd,
                               DisplayOptionsDlgProc,
                               (DWORD)newBarTypes)) {
        case IDOK:
            SetCursor(hcurWait);
            for (i=0; i<DiskCount; i++) {
                Disks[i]->BarType = newBarTypes[i];
            }
            TotalRedrawAndRepaint();
            SetCursor(hcurNormal);
            break;

        case IDCANCEL:
            break;

        default:
            FDASSERT(0);
        }

        Free(newBarTypes);
        break;
    }

    case IDM_HELPCONTENTS:
    case IDM_HELP:

        HelpFlag = HELP_INDEX;
        goto CallWinHelp;
        break;

    case IDM_HELPSEARCH:

        HelpFlag = HELP_PARTIALKEY;
        goto CallWinHelp;
        break;

    case IDM_HELPHELP:

        HelpFlag = HELP_HELPONHELP;
        goto CallWinHelp;
        break;

    case IDM_HELPABOUT: {
        TCHAR title[100];

        LoadString(hModule, IDS_APPNAME, title, sizeof(title)/sizeof(TCHAR));
        ShellAbout(hwndFrame, title, NULL, (HICON)GetClassLong(hwndFrame, GCL_HICON));
        break;
    }

#if DBG && DEVL

    case IDM_DEBUGALLOWDELETES:

        AllowAllDeletes = !AllowAllDeletes;
        CheckMenuItem(GetMenu(hwndFrame),
                      IDM_DEBUGALLOWDELETES,
                      AllowAllDeletes ? MF_CHECKED : MF_UNCHECKED);
        break;

#endif

    case ID_LISTBOX:

        switch (HIWORD(wParam)) {
        case LBN_SELCHANGE:
            point.x = LOWORD(pos = GetMessagePos());
            point.y = HIWORD(pos);
            MouseSelection(GetKeyState(VK_CONTROL) & ~1,     // strip toggle bit
                           &point);
            return;
        default:
            DefWindowProc(hwnd, WM_COMMAND, wParam, lParam);
            return;
        }
        break;

    default:

        DefWindowProc(hwnd, WM_COMMAND, wParam, lParam);
    }
    return;

CallWinHelp:

    if (!WinHelp(hwndFrame, HelpFile, HelpFlag, (LONG)"")) {
        WarningDialog(MSG_HELP_ERROR);
    }
}

DWORD
DeletionIsAllowed(
    IN PREGION_DESCRIPTOR Region
    )

/*++

Routine Description:

    This routine makes sure deletion of the partition is allowed.  We do not
    allow the user to delete the Windows NT boot partition or the active
    partition on disk 0 (x86 only).

    Note that this routine is also used to determine whether an existing
    single-partition volume can be extended into a volume set, since the
    criteria are the same.

Arguments:

    Region - points to region descriptor for the region which the user would
        like to delete.

Return Value:

    NO_ERROR if deletion is allowed;  error number for message to display
    if not.

--*/

{
    ULONG                   ec;
    PPERSISTENT_REGION_DATA regionData = PERSISTENT_DATA(Region);

    FDASSERT(!IsExtended(Region->SysID));       // can't be extended partition
    FDASSERT(Region->SysID != SYSID_UNUSED);    // can't be free space

#if DBG && DEVL
    if (AllowAllDeletes) {
        return NO_ERROR;
    }
#endif

    // if this is not an original region, deletion is allowed.

    if (!Region->OriginalPartitionNumber) {
        return NO_ERROR;
    }

    // if there is no persistent data for this region, allow deletion.

    if (regionData == NULL) {
        return NO_ERROR;
    }

    ec = NO_ERROR;

    // Determine the Windows NT drive by determining the windows directory
    // and pulling out the first letter.

    if (BootDiskNumber != (ULONG)-1) {

        // If the disk number and original partition number of this
        // region match the recorded disk number and partition number
        // of the boot partition, don't allow deletion.

        if (Region->Disk == BootDiskNumber &&
            Region->OriginalPartitionNumber == BootPartitionNumber) {

            ec = MSG_CANT_DELETE_WINNT;
        }
    }

#if i386
    if (ec == NO_ERROR) {
        if (!Region->Disk && Region->Active) {
            ec = MSG_CANT_DELETE_ACTIVE0;
        }
    }
#endif

    return ec;
}


BOOLEAN
BootPartitionNumberChanged(
    PULONG OldNumber,
    PULONG NewNumber
    )

/*++

Routine Description

    This function determines whether the partition number of
    the boot partition has changed during this invocation of
    Windisk.  With dynamic partitioning enabled, the work of
    this routine increases.  This routine must guess what the
    partition numbers will be when the system is rebooted to
    determine if the partition number for the boot partition
    has changed.  It does this via the following algorithm:

    1. Count all primary partitions - These get numbers first
       starting from 1.

    2. Count all logical drives - These get numbers second starting
       from the count of primary partitions plus 1.

    The partition numbers located in the region structures cannot
    be assumed to be valid.  This work must be done from the
    region array located in the disk state structure for the
    disk.

Arguments:

    None.

Return Value:

    TRUE if the boot partition's partition number has changed.

--*/

{
    PDISKSTATE         bootDisk;
    PREGION_DESCRIPTOR regionDescriptor,
                       bootDescriptor = NULL;
    ULONG              i,
                       partitionNumber = 0;

    if (BootDiskNumber == (ULONG)(-1) || BootDiskNumber > DiskCount) {

        // Can't tell--assume it hasn't.

        return FALSE;
    }

    if (!ChangeCommittedOnDisk(BootDiskNumber)) {

        // disk wasn't changed - no possibility for a problem.

        return FALSE;
    }

    bootDisk = Disks[BootDiskNumber];

    // Find the region descriptor for the boot partition

    for (i = 0; i < bootDisk->RegionCount; i++) {
        regionDescriptor = &bootDisk->RegionArray[i];
        if (regionDescriptor->OriginalPartitionNumber == BootPartitionNumber) {
           bootDescriptor = regionDescriptor;
           break;
        }
    }

    if (!bootDescriptor) {

        // Can't find boot partition - assume no change

        return FALSE;
    }

    // No go through the region descriptors and count the partition
    // numbers as they will be counted during system boot.
    //
    // If the boot region is located determine if the partition
    // number changed.

    for (i = 0; i < bootDisk->RegionCount; i++) {

        regionDescriptor = &bootDisk->RegionArray[i];
        if ((regionDescriptor->RegionType == REGION_PRIMARY) &&
            (!IsExtended(regionDescriptor->SysID) &&
            (regionDescriptor->SysID != SYSID_UNUSED))) {
            partitionNumber++;
            if (regionDescriptor == bootDescriptor) {
                if (partitionNumber != regionDescriptor->OriginalPartitionNumber) {
                    *OldNumber = regionDescriptor->OriginalPartitionNumber;
                    *NewNumber = partitionNumber;
                    return TRUE;
                } else {

                    // Numbers match, no problem.

                    return FALSE;
                }
            }
        }
    }

    // Check the logical drives as well.

    for (i = 0; i < bootDisk->RegionCount; i++) {
        regionDescriptor = &bootDisk->RegionArray[i];

        if (regionDescriptor->RegionType == REGION_LOGICAL) {
            partitionNumber++;
            if (regionDescriptor == bootDescriptor) {
                if (partitionNumber != regionDescriptor->OriginalPartitionNumber) {
                    *OldNumber = regionDescriptor->OriginalPartitionNumber;
                    *NewNumber = partitionNumber;
                    return TRUE;
                } else {
                    return FALSE;
                }
            }
        }
    }

    return FALSE;
}

DWORD
CommitChanges(
    VOID
    )

/*++

Routine Description:

    This routine updates the disks to reflect changes made by the user
    the partitioning scheme, or to stamp signatures on disks.

    If the partitioning scheme on a disk has changed at all, a check will
    first be made for a valid signature on the mbr in sector 0.  If the
    signature is not valid, x86 boot code will be written to the sector.

Arguments:

    None.

Return Value:

    Windows error code.

--*/

{
    unsigned i;
    DWORD    ec,
             rc = NO_ERROR;

    for (i=0; i<DiskCount; i++) {

        if (HavePartitionsBeenChanged(i)) {
            ec = MasterBootCode(i, 0, TRUE, FALSE);

            // MasterBootCode has already translated the NT error
            // status into a Windows error status.

            if (rc == NO_ERROR) {
                rc = ec;            // save first non-success return code
            }
            ec = CommitPartitionChanges(i);

            // CommitPartitionChanges returns a native NT error, it
            // must be translated before it can be saved.

            if (ec != NO_ERROR) {
                ec = RtlNtStatusToDosError(ec);
            }
            if (rc == NO_ERROR) {   // save first non-success return code
                rc = ec;
            }
        }
    }
    if (rc != NO_ERROR) {

        // If CommitPartitionChanges returns an error, it will be
        // an NT status, which needs to be converted to a DOS status.

        if (rc == ERROR_MR_MID_NOT_FOUND) {
            ErrorDialog(MSG_ERROR_DURING_COMMIT);
        } else {
            ErrorDialog(rc);
        }
    }

    return rc;
}

BOOL
AssignDriveLetter(
    IN  BOOL  WarnIfNoLetter,
    IN  DWORD StringId,
    OUT PCHAR DriveLetter
    )

/*++

Routine Description:

    Determine the next available drive letter.  If no drive letters are
    available, optionally warn the user and allow him to cancel the
    operation.

Arguments:

    WarnIfNoLetter - whether to warn the user if no drive letters are
        available and allow him to cancel the operation.

    StringId - resource containing the name of the object being created
        that will need a drive letter (ie, partition, logical drive, stripe
        set, volume set).

    DriveLetter - receives the drive letter to assign, or NO_DRIVE_LETTER_YET
        if no more left.

Return Value:

    If there were no more drive letters, returns TRUE if the user wants
        to create anyway, FALSE if he canceled.  If there were drive letters
        available, the return value is undefined.

--*/

{
    CHAR driveLetter;
    TCHAR name[256];

    driveLetter = GetAvailableDriveLetter();
    if (WarnIfNoLetter && !driveLetter) {
        LoadString(hModule, StringId, name, sizeof(name)/sizeof(TCHAR));
        if (ConfirmationDialog(MSG_NO_AVAIL_LETTER, MB_ICONQUESTION | MB_YESNO, name) != IDYES) {
            return FALSE;
        }
    }
    if (!driveLetter) {
        driveLetter = NO_DRIVE_LETTER_YET;
    }
    *DriveLetter = driveLetter;
    return TRUE;
}

VOID
DeterminePartitioningState(
    IN OUT PDISKSTATE DiskState
    )

/*++

Routine Description:

    This routine determines the disk's partitioning state (ie, what types
    of partitions exist and may be created), filling out a DISKSTATE
    structure with the info.   It also allocates the array for the
    left/right position pairs for each region's on-screen square.

Arguments:

    DiskState - the CreateXXX and ExistXXX fields will be filled in for the
                disk in the Disk field

Return Value:

    None.

--*/

{
    DWORD i;

    // If there's an existing region array there, free it.

    if (DiskState->RegionArray) {
        FreeRegionArray(DiskState->RegionArray, DiskState->RegionCount);
    }

    // get the region array for the disk in question

    GetAllDiskRegions(DiskState->Disk,
                      &DiskState->RegionArray,
                      &DiskState->RegionCount);

    // Allocate the array for the left/right coords for the graph.
    // This may overallocate by one square (for extended partition).

    DiskState->LeftRight = Realloc(DiskState->LeftRight,
                                   DiskState->RegionCount * sizeof(LEFTRIGHT));
    DiskState->Selected  = Realloc(DiskState->Selected,
                                   DiskState->RegionCount * sizeof(BOOLEAN));

    for (i=0; i<DiskState->RegionCount; i++) {
        DiskState->Selected[i] = FALSE;
    }

    // figure out whether various creations are allowed

    IsAnyCreationAllowed(DiskState->Disk,
                         TRUE,
                         &DiskState->CreateAny,
                         &DiskState->CreatePrimary,
                         &DiskState->CreateExtended,
                         &DiskState->CreateLogical);

    // figure out whether various partition types exist

    DoesAnyPartitionExist(DiskState->Disk,
                          &DiskState->ExistAny,
                          &DiskState->ExistPrimary,
                          &DiskState->ExistExtended,
                          &DiskState->ExistLogical);
}

VOID
DrawDiskBar(
    IN PDISKSTATE DiskState
    )

/*++

Routine Description:

    This routine will draw the disk bar into the window.

Arguments:

    DiskState - current disk to draw.

Return Value:

    None

--*/

{
    PREGION_DESCRIPTOR   regionDescriptor;
    PDISKSTATE           diskState;
    LONGLONG temp1,
             temp2;
    HDC      hDCMem = DiskState->hDCMem;
    DWORD    leftAdjust = BarLeftX,
             xDiskText,
             cx = 0,
             brushIndex = 0;
    HPEN     hpenT;
    char     text[100],
             textBold[5];
    TCHAR    uniText[100],
             uniTextBold[5],
             mbBuffer[16];
    RECT     rc;
    HFONT    hfontT;
    COLORREF previousColor;
    HBRUSH   hbr;
    BOOL     isFree,
             isLogical;
    HDC      hdcTemp;
    HBITMAP  hbmOld;
    PWSTR    typeName,
             volumeLabel;
    WCHAR    driveLetter;
    BAR_TYPE barType;
    ULONG    diskSize,
             largestDiskSize;
    unsigned i;

    // If this is a removable.  Update to whatever its current
    // information may be.

    if (IsDiskRemovable[DiskState->Disk]) {
        PPERSISTENT_REGION_DATA regionData;

        // Update the information on this disk.

        regionDescriptor = &DiskState->RegionArray[0];
        regionData = PERSISTENT_DATA(regionDescriptor);

        if (GetVolumeTypeAndSize(DiskState->Disk,
                                 regionDescriptor->PartitionNumber,
                                 &volumeLabel,
                                 &typeName,
                                 &diskSize)) {

            // Update the values for the removable.

            if (regionData) {

                // Always want RAW file systems to display as "Unknown"

                if (!lstrcmpiW(typeName, L"raw")) {
                     Free(typeName);
                     typeName = Malloc((wcslen(wszUnknown) * sizeof(WCHAR)) + sizeof(WCHAR));
                     lstrcpyW(typeName, wszUnknown);
                }
                if (regionData->VolumeLabel) {
                    Free(regionData->VolumeLabel);
                }
                regionData->VolumeLabel = volumeLabel;
                if (regionData->TypeName) {
                    Free(regionData->TypeName);
                }
                regionData->TypeName = typeName;
            }

            DiskState->DiskSizeMB = diskSize;
        }
    }

    // figure out largest disk's size

    for (largestDiskSize = i = 0, diskState = Disks[0];
         i < DiskCount;
         diskState = Disks[++i]) {

        if (diskState->DiskSizeMB > largestDiskSize) {
            largestDiskSize = diskState->DiskSizeMB;
        }
    }

    // erase the graph background

    rc.left = rc.top = 0;
    rc.right = GraphWidth + 1;
    rc.bottom = GraphHeight + 1;
    FillRect(hDCMem, &rc, GetStockObject(LTGRAY_BRUSH));

    hpenT = SelectObject(hDCMem,hPenThinSolid);

    // Draw the disk info area: small disk bitmap, some text, and a
    // line across the top.
    //
    // First draw the bitmap.

    hdcTemp = CreateCompatibleDC(hDCMem);
    if (IsDiskRemovable[DiskState->Disk]) {
        hbmOld = SelectObject(hdcTemp, hBitmapRemovableDisk);
        BitBlt(hDCMem,
               xRemovableDisk,
               yRemovableDisk,
               dxRemovableDisk,
               dyRemovableDisk,
               hdcTemp,
               0,
               0,
               SRCCOPY);
    } else {
        hbmOld = SelectObject(hdcTemp, hBitmapSmallDisk);
        BitBlt(hDCMem,
               xSmallDisk,
               ySmallDisk,
               dxSmallDisk,
               dySmallDisk,
               hdcTemp,
               0,
               0,
               SRCCOPY);
    }

    if (hbmOld) {
        SelectObject(hdcTemp, hbmOld);
    }
    DeleteDC(hdcTemp);

    // Now draw the line.

    if (IsDiskRemovable[DiskState->Disk]) {
        MoveToEx(hDCMem, xRemovableDisk, BarTopYOffset, NULL);
        LineTo(hDCMem, BarLeftX - xRemovableDisk, BarTopYOffset);
        xDiskText = 2 * dxRemovableDisk;
    } else {
        MoveToEx(hDCMem, xSmallDisk, BarTopYOffset, NULL);
        LineTo(hDCMem, BarLeftX - xSmallDisk, BarTopYOffset);
        xDiskText = 2 * dxSmallDisk;
    }

    // Now draw the text.

    hfontT = SelectObject(hDCMem, hFontGraphBold);
    SetTextColor(hDCMem, RGB(0, 0, 0));
    SetBkColor(hDCMem, RGB(192, 192, 192));
    wsprintf(uniText, DiskN, DiskState->Disk);
    TextOut(hDCMem,
            xDiskText,
            BarTopYOffset + dyBarTextLine,
            uniText,
            lstrlen(uniText));

    SelectObject(hDCMem, hFontGraph);
    if (DiskState->OffLine) {
        LoadString(hModule, IDS_OFFLINE, uniText, sizeof(uniText)/sizeof(TCHAR));
    } else {
        LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));
        wsprintf(uniText, TEXT("%u %s"), DiskState->DiskSizeMB, mbBuffer);
    }

    TextOut(hDCMem,
            xDiskText,
            BarTopYOffset + (4*dyBarTextLine),
            uniText,
            lstrlen(uniText));

    if (DiskState->OffLine) {

        SelectObject(hDCMem, GetStockObject(LTGRAY_BRUSH));
        Rectangle(hDCMem,
                  BarLeftX,
                  BarTopYOffset,
                  BarLeftX + BarWidth,
                  BarBottomYOffset);
        LoadString(hModule, IDS_NO_CONFIG_INFO, uniText, sizeof(uniText)/sizeof(TCHAR));
        TextOut(hDCMem,
                BarLeftX + dxBarTextMargin,
                BarTopYOffset + (4*dyBarTextLine),
                uniText,
                lstrlen(uniText));
    } else {

        // Account for extreme differences in largest to smallest disk
        // by insuring that a disk is always 1/4 the size of the
        // largest disk.

        diskSize = DiskState->DiskSizeMB;
        if (diskSize < largestDiskSize / 4) {
            diskSize = largestDiskSize / 4;
        }
#if 0
        // manage the horizontal size of the list box in order
        // to get a scroll bar.  Perhaps this only needs to be done
        // once.  BUGBUG:  This will cause a horizontal scroll bar
        // that works correctly, but the region selection code is
        // not prepared for this, so selection of regions doesn't
        // operate correctly.

        largestExtent = (WPARAM)(BarWidth + BarLeftX + 2);
        SendMessage(hwndList, LB_SETHORIZONTALEXTENT, largestExtent, 0);
#endif
        // If user wants WinDisk to decide which type of view to use, do that
        // here.  We'll use a proportional view unless any single region would
        // have a width less than the size of a drive letter.

        if ((barType = DiskState->BarType) == BarAuto) {
            ULONG regionSize;

            barType = BarProportional;

            for (i=0; i<DiskState->RegionCount; i++) {

                regionDescriptor = &DiskState->RegionArray[i];

                if (IsExtended(regionDescriptor->SysID)) {
                    continue;
                }

                temp1 = UInt32x32To64(BarWidth, diskSize);
                temp1 *= regionDescriptor->SizeMB;
                temp2 = UInt32x32To64(largestDiskSize, DiskState->DiskSizeMB);
                regionSize = (ULONG) (temp1 / temp2);

                if (regionSize < 12*SELECTION_THICKNESS) {
                    barType = BarEqual;
                    break;
                }
            }
        }

        if (barType == BarEqual) {

            temp1 = UInt32x32To64(BarWidth, diskSize);
            temp2 = UInt32x32To64((DiskState->RegionCount -
                       (DiskState->ExistExtended ? 1 : 0)), largestDiskSize);
            cx = (ULONG) (temp1 / temp2);
        }

        for (i=0; i<DiskState->RegionCount; i++) {
            PFT_OBJECT ftObject = NULL;

            regionDescriptor = &DiskState->RegionArray[i];
            if (!IsExtended(regionDescriptor->SysID)) {

                if (barType == BarProportional) {

                    temp1 = UInt32x32To64(BarWidth, diskSize);
                    temp1 *= regionDescriptor->SizeMB;
                    temp2 = UInt32x32To64(largestDiskSize, DiskState->DiskSizeMB);
                    cx = (ULONG) (temp1 / temp2);
                }

                isFree = (regionDescriptor->SysID == SYSID_UNUSED);
                isLogical = (regionDescriptor->RegionType == REGION_LOGICAL);

                if (!isFree) {

                    // If we've got a mirror or stripe set, use special colors.

                    ftObject = GET_FT_OBJECT(regionDescriptor);
                    switch(ftObject ? ftObject->Set->Type : -1) {
                    case Mirror:
                        brushIndex = BRUSH_MIRROR;
                        break;
                    case Stripe:
                    case StripeWithParity:
                        brushIndex = BRUSH_STRIPESET;
                        break;
                    case VolumeSet:
                        brushIndex = BRUSH_VOLUMESET;
                        break;
                    default:
                        brushIndex = isLogical ? BRUSH_USEDLOGICAL : BRUSH_USEDPRIMARY;
                    }       // end the switch
                }

                previousColor = SetBkColor(hDCMem, RGB(255, 255, 255));
                SetBkMode(hDCMem, OPAQUE);

                if (isFree) {

                    // Free space -- cross hatch the whole block.

                    hbr = SelectObject(hDCMem,isLogical ? hBrushFreeLogical : hBrushFreePrimary);
                    Rectangle(hDCMem,
                              leftAdjust,
                              BarTopYOffset,
                              leftAdjust + cx,
                              BarBottomYOffset);
                } else {

                    // Used space -- make most of the block white except for
                    // a small strip at the top, which gets an identifying color.
                    // If the partition is not recognized, leave it all white.

                    hbr = SelectObject(hDCMem, GetStockObject(WHITE_BRUSH));
                    Rectangle(hDCMem, leftAdjust, BarTopYOffset, leftAdjust + cx, BarBottomYOffset);

                    if (IsRecognizedPartition(regionDescriptor->SysID)) {
                        SelectObject(hDCMem, Brushes[brushIndex]);
                        Rectangle(hDCMem,
                                  leftAdjust,
                                  BarTopYOffset,
                                  leftAdjust + cx,
                                  BarTopYOffset + (4 * dyBarTextLine / 5) + 1);
                    }
                }

                if (hbr) {
                    SelectObject(hDCMem, hbr);
                }

                DiskState->LeftRight[i].Left  = leftAdjust;
                DiskState->LeftRight[i].Right = leftAdjust + cx - 1;

                // Figure out the type name (ie, unformatted, fat, etc) and
                // volume label.

                typeName = NULL;
                volumeLabel = NULL;
                DetermineRegionInfo(regionDescriptor, &typeName, &volumeLabel, &driveLetter);
                LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));

                if (!typeName) {
                    typeName = wszUnknown;
                }
                if (!volumeLabel) {
                    volumeLabel = L"";
                }
                wsprintf(text,
                         "\n%ws\n%ws\n%u %s",
                         volumeLabel,
                         typeName,
                         regionDescriptor->SizeMB,
                         mbBuffer);

                *textBold = 0;
                if (driveLetter != L' ') {
                    wsprintf(textBold, "%wc:", driveLetter);
                }

                UnicodeHack(text, uniText);
                UnicodeHack(textBold, uniTextBold);

                // output the text

                rc.left   = leftAdjust + dxBarTextMargin;
                rc.right  = leftAdjust + cx - dxBarTextMargin;
                rc.top    = BarTopYOffset + dyBarTextLine;
                rc.bottom = BarBottomYOffset;

                SetBkMode(hDCMem, TRANSPARENT);
                SelectObject(hDCMem, hFontGraphBold);

                // If this is an unhealthy ft set member, draw the text in red.

                if (!isFree && ftObject
                && (ftObject->State != Healthy)
                && (ftObject->State != Initializing)) {
                    SetTextColor(hDCMem, RGB(192, 0, 0));
                } else {
                    SetTextColor(hDCMem, RGB(0, 0, 0));
                }

                DrawText(hDCMem, uniTextBold, -1, &rc, DT_LEFT | DT_NOPREFIX);
                SelectObject(hDCMem, hFontGraph);
                DrawText(hDCMem, uniText, -1, &rc, DT_LEFT | DT_NOPREFIX);
#if i386
                // if this guy is active make a mark in the upper left
                // corner of his rectangle.

                if ((regionDescriptor->SysID != SYSID_UNUSED)
                && (regionDescriptor->Disk == 0)
                && (regionDescriptor->RegionType == REGION_PRIMARY)
                && regionDescriptor->Active) {
                    TextOut(hDCMem,
                            leftAdjust + dxBarTextMargin,
                            BarTopYOffset + 2,
                            TEXT("*"),
                            1);
                }
#endif
#ifdef DOUBLE_SPACE_SUPPORT_INCLUDED
                // Check for DoubleSpace volumes and update display accordingly

                dblSpaceIndex = 0;
                dblSpace = NULL;
                while (dblSpace = DblSpaceGetNextVolume(regionDescriptor, dblSpace)) {

                    if (dblSpace->Mounted) {
                        SetTextColor(hDCMem, RGB(192,0,0));
                    } else {
                        SetTextColor(hDCMem, RGB(0,0,0));
                    }
                    wsprintf(uniText,
                             TEXT("%c: %s"),
                             dblSpace->DriveLetter,
                             dblSpace->FileName);
                    rc.left   = leftAdjust + dxBarTextMargin + 60;
                    rc.right  = leftAdjust + cx - dxBarTextMargin;
                    rc.top    = BarTopYOffset + dyBarTextLine + (dblSpaceIndex * 15);
                    rc.bottom = BarBottomYOffset;
                    DrawText(hDCMem, uniText, -1, &rc, DT_LEFT | DT_NOPREFIX);
                    dblSpaceIndex++;
                }
#endif
                SetBkColor(hDCMem, previousColor);
                leftAdjust += cx - 1;
            } else {
                DiskState->LeftRight[i].Left = DiskState->LeftRight[i].Right = 0;
            }
        }
    }

    SelectObject(hDCMem, hpenT);
    SelectObject(hDCMem, hfontT);
}

VOID
AdjustMenuAndStatus(
    VOID
    )

/*++

Routine Description:

    This routine updates the information in the Status bar
    if something is selected and if the status bar is to be
    displayed.

Arguments"

    None

Return Value:

    None

--*/

{
    TCHAR      mbBuffer[16],
               statusBarPartitionString[200],
               dblSpaceString[200];
    DWORD      selectionCount,
               msg,
               regionIndex;
    PDISKSTATE diskState;
    PWSTR      volumeLabel,
               typeName;
    WCHAR      driveLetter;


    switch (selectionCount = SetUpMenu(&SingleSel,&SingleSelIndex)) {

    case 0:

        StatusTextDrlt[0] = 0;
        StatusTextSize[0] = StatusTextStat[0] = 0;
        StatusTextVoll[0] = StatusTextType[0] = 0;
        break;

    case 1:

        // Might be part of a partial FT set.

        if (FtSelectionType != -1) {
            goto FtSet;
        }

        diskState = SingleSel;
        regionIndex = SingleSelIndex;

        DetermineRegionInfo(&diskState->RegionArray[regionIndex],
                            &typeName,
                            &volumeLabel,
                            &driveLetter);
        lstrcpyW(StatusTextType,typeName);
        lstrcpyW(StatusTextVoll,volumeLabel);

        if (diskState->RegionArray[regionIndex].SysID == SYSID_UNUSED) {
            if (diskState->RegionArray[regionIndex].RegionType == REGION_LOGICAL) {
                if (diskState->ExistLogical) {
                    msg = IDS_FREEEXT;
                } else {
                    msg = IDS_EXTENDEDPARTITION;
                }
            } else {
                msg = IDS_FREESPACE;
            }
            driveLetter = L' ';
            StatusTextType[0] = 0;
        } else {
            msg = (diskState->RegionArray[regionIndex].RegionType == REGION_LOGICAL)
                ? IDS_LOGICALVOLUME
                : IDS_PARTITION;

#if i386
            if ((msg == IDS_PARTITION) && (diskState->Disk == 0) && diskState->RegionArray[regionIndex].Active) {
                msg = IDS_ACTIVEPARTITION;
            }
#endif
        }
        LoadString(hModule, msg, statusBarPartitionString, STATUS_TEXT_SIZE/sizeof(StatusTextStat[0]));
        if (DblSpaceVolumeExists(&diskState->RegionArray[regionIndex])) {
            LoadString(hModule, IDS_WITH_DBLSPACE, dblSpaceString, STATUS_TEXT_SIZE/sizeof(StatusTextStat[0]));
        } else {
            dblSpaceString[0] = dblSpaceString[1] = 0;
        }
        wsprintf(StatusTextStat,
                 "%s %s",
                 statusBarPartitionString,
                 dblSpaceString);
        LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));
        wsprintf(StatusTextSize,
                 "%u %s",
                 diskState->RegionArray[regionIndex].SizeMB,
                 mbBuffer);

        StatusTextDrlt[0] = driveLetter;
        StatusTextDrlt[1] = (WCHAR)((driveLetter == L' ') ? 0 : L':');
        break;

    default:
    FtSet:

        // Might be an ft set, might be multiple items

        if (FtSelectionType == -1) {
            LoadString(hModule, IDS_MULTIPLEITEMS, StatusTextStat, STATUS_TEXT_SIZE/sizeof(StatusTextStat[0]));
            StatusTextDrlt[0] = 0;
            StatusTextSize[0] = 0;
            StatusTextType[0] = StatusTextVoll[0] = 0;
        } else {
            PREGION_DESCRIPTOR regionDescriptor;
            DWORD          resid = 0,
                           i;
            DWORD          Size = 0;
            TCHAR          textbuf[STATUS_TEXT_SIZE];
            PFT_OBJECT_SET ftSet;
            PFT_OBJECT     ftObject;
            FT_SET_STATUS  setState;
            ULONG          numberOfMembers;
            WCHAR          ftstat[65];
            STATUS_CODE    status;

            typeName = NULL;
            DetermineRegionInfo(&SELECTED_REGION(0),
                                &typeName,
                                &volumeLabel,
                                &driveLetter);
            if (!typeName) {
                if (SelectionCount > 1) {
                    DetermineRegionInfo(&SELECTED_REGION(0),
                                        &typeName,
                                        &volumeLabel,
                                        &driveLetter);
                }
            }
            if (!typeName) {
                typeName = wszUnknown;
                volumeLabel = L"";
            }
            lstrcpyW(StatusTextType, typeName);
            lstrcpyW(StatusTextVoll, volumeLabel);

            switch (FtSelectionType) {
            case Mirror:
                resid = IDS_STATUS_MIRROR;
                Size = SELECTED_REGION(0).SizeMB;
                break;
            case Stripe:
                resid = IDS_STATUS_STRIPESET;
                goto CalcSize;
            case StripeWithParity:
                resid = IDS_STATUS_PARITY;
                goto CalcSize;
            case VolumeSet:
                resid = IDS_STATUS_VOLUMESET;
                goto CalcSize;
CalcSize:
                for (i=0; i<selectionCount; i++) {
                    Size += SELECTED_REGION(i).SizeMB;
                }
                break;
            default:
                FDASSERT(FALSE);
            }

            ftObject = GET_FT_OBJECT(&SELECTED_REGION(0));
            ftSet = ftObject->Set;

            if (FtSelectionType != VolumeSet) {
                regionDescriptor = LocateRegionForFtObject(ftSet->Member0);

                if (!regionDescriptor) {

                    // The zeroth member is off line

                    ftObject = ftSet->Members;
                    while (ftObject) {

                        // Find member 1

                        if (ftObject->MemberIndex == 1) {
                            regionDescriptor = LocateRegionForFtObject(ftObject);
                            break;
                        }
                        ftObject = ftObject->Next;
                    }
                }

                // If the partition number is zero, then this set has
                // not been committed to the disk yet.

                if ((regionDescriptor) && (regionDescriptor->PartitionNumber)) {
                    status = LowFtVolumeStatus(regionDescriptor->Disk,
                                               regionDescriptor->PartitionNumber,
                                               &setState,
                                               &numberOfMembers);
                    if (status == OK_STATUS) {
                        if ((ftSet->Status != FtSetNewNeedsInitialization) &&
                            (ftSet->Status != FtSetNew)) {

                            if (ftSet->Status != setState) {
                                PFT_OBJECT         tempFtObjectPtr;

                                ftSet->Status = setState;

                                // Determine if each object should be updated.

                                switch (setState) {
                                case FtSetHealthy:

                                    // Each object in the set should have
                                    // the partition state updated.  Determine
                                    // the value for the update and walk
                                    // the chain to perform the update.

                                    for (tempFtObjectPtr = ftSet->Members;
                                         tempFtObjectPtr;
                                         tempFtObjectPtr = tempFtObjectPtr->Next) {
                                        tempFtObjectPtr->State = Healthy;
                                    }
                                    TotalRedrawAndRepaint();
                                    break;

                                case FtSetInitializing:
                                case FtSetRegenerating:
                                case FtSetDisabled:

                                    FdftUpdateFtObjectSet(ftSet, setState);
                                    TotalRedrawAndRepaint();
                                    break;

                                default:
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            LoadString(hModule, resid, textbuf, sizeof(textbuf)/sizeof(TCHAR));

            switch (resid) {
            case IDS_STATUS_STRIPESET:
            case IDS_STATUS_VOLUMESET:
                wsprintf(StatusTextStat, textbuf, ftSet->Ordinal);
                break;
            case IDS_STATUS_PARITY:
            case IDS_STATUS_MIRROR:
                switch(ftSet->Status) {
                case FtSetHealthy:
                    resid = IDS_HEALTHY;
                    break;
                case FtSetNew:
                case FtSetNewNeedsInitialization:
                    resid = IDS_NEW;
                    break;
                case FtSetBroken:
                    resid = IDS_BROKEN;
                    break;
                case FtSetRecoverable:
                    resid = IDS_RECOVERABLE;
                    break;
                case FtSetRecovered:
                    resid = IDS_REGENERATED;
                    break;
                case FtSetInitializing:
                    resid = IDS_INITIALIZING;
                    break;
                case FtSetRegenerating:
                    resid = IDS_REGENERATING;
                    break;
                case FtSetDisabled:
                    resid = IDS_DISABLED;
                    break;
                case FtSetInitializationFailed:
                    resid = IDS_INIT_FAILED;
                    break;
                default:
                    FDASSERT(FALSE);
                }
                LoadStringW(hModule, resid, ftstat, sizeof(ftstat)/sizeof(WCHAR));
                wsprintf(StatusTextStat, textbuf, ftSet->Ordinal,ftstat);
                break;
            default:
                FDASSERT(FALSE);
            }

            LoadString(hModule, IDS_MEGABYTES_ABBREV, mbBuffer, sizeof(mbBuffer)/sizeof(TCHAR));
            wsprintf(StatusTextSize, "%u %s", Size, mbBuffer);

            StatusTextDrlt[0] = driveLetter;
            StatusTextDrlt[1] = (WCHAR)((driveLetter == L' ') ? 0 : L':');
        }
    }
    UpdateStatusBarDisplay();
}

ULONG
PartitionCount(
    IN ULONG Disk
    )

/*++

Routine Description:

    Given a disk index, this routine calculates the number of partitions the
    disk contains.

Arguments:

    Disk - This disk index for the count.

Return Value:

    The number of partitions on the disk

--*/

{
    unsigned i;
    ULONG partitions = 0;
    PREGION_DESCRIPTOR regionDescriptor;

    for (i=0; i<Disks[Disk]->RegionCount; i++) {

        regionDescriptor = &Disks[Disk]->RegionArray[i];

        if ((regionDescriptor->RegionType != REGION_LOGICAL) && (regionDescriptor->SysID != SYSID_UNUSED)) {
            partitions++;
        }
    }

    return partitions;
}


BOOL
RegisterFileSystemExtend(
    VOID
    )

/*++

Routine Description:

    This function adds registry entries to extend the file
    system structures in volume sets that have been extended.

Arguments:

    None.

Return Value:

    non-zero if there was a file system that was extended.

--*/
{
    BYTE                buf[1024];
    PSTR                template = "autochk /x ";
    CHAR                extendedDrives[26];
    PDISKSTATE          diskState;
    PREGION_DESCRIPTOR  regionDescriptor;
    PFT_OBJECT          ftObject;
    DWORD               cExt = 0,
                        i,
                        j,
                        valueType,
                        size,
                        templateLength;
    HKEY                hkey;
    LONG                ec;

    // Traverse the disks to find any volume sets that
    // have been extended.

    for (i = 0; i < DiskCount; i++) {

        diskState = Disks[i];
        for (j = 0; j < diskState->RegionCount; j++) {

            regionDescriptor = &diskState->RegionArray[j];
            if ((ftObject = GET_FT_OBJECT(regionDescriptor)) != NULL
                && ftObject->MemberIndex == 0
                && ftObject->Set->Type == VolumeSet
                && ftObject->Set->Status == FtSetExtended) {

                extendedDrives[cExt++] = PERSISTENT_DATA(regionDescriptor)->DriveLetter;
            }
        }
    }

    if (cExt) {

        // Fetch the BootExecute value of the Session Manager key.

        ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          &hkey);

        if (ec != NO_ERROR) {
            return 0;
        }

        size = sizeof(buf);
        ec = RegQueryValueExA(hkey,
                              TEXT("BootExecute"),
                              NULL,
                              &valueType,
                              buf,
                              &size);

        if (ec != NO_ERROR || valueType != REG_MULTI_SZ) {
            return 0;
        }

        // Decrement size to get rid of the extra trailing null

        if (size) {
            size--;
        }

        templateLength = strlen(template);

        for (i = 0; i < cExt; i++) {

            // Add an entry for this drive to the BootExecute value.

            strncpy(buf+size, template, templateLength);
            size += templateLength;

            buf[size++] = extendedDrives[i];
            buf[size++] = ':';
            buf[size++] = 0;
        }

        // Add an additional trailing null at the end

        buf[size++] = 0;

        // Save the value.

        ec = RegSetValueExA(hkey,
                            TEXT("BootExecute"),
                            0,
                            REG_MULTI_SZ,
                            buf,
                            size);

        RegCloseKey( hkey );
        if (ec != NO_ERROR) {
            return 0;
        }
        return 1;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\find\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=find
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\find.cxx ..\find.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\findstr\makefile.inc ===
fsmsg.rc: msg00001.bin

fsmsg.h msg00001.bin: fsmsg.mc
    mc -v -h .\ fsmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\findstr\qmatch.c ===
// static char *SCCSID = "@(#)qmatch.c   13.7 90/08/13";


#include <stdio.h>
#include <ctype.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdarg.h>
#include "fsmsg.h"

#define ASCLEN          256             // Number of ascii characters
#define BUFLEN          256             // Temporary buffer length
#define EOS             ('\r')          // End of string character
#define EOS2            ('\n')          // Alternate End of string character
#define PATMAX          512             // Maximum parsed pattern length

#define BEGLINE         0x08            // Match at beginning of line
#define DEBUG           0x20            // Print debugging output
#define ENDLINE         0x10            // Match at end of line

#define T_END           0               // End of expression
#define T_STRING        1               // String to match
#define T_SINGLE        2               // Single character to match
#define T_CLASS         3               // Class to match
#define T_ANY           4               // Match any character
#define T_STAR          5               // *-expr


typedef struct exprnode {
    struct exprnode     *ex_next;       // Next node in list
    unsigned char       *ex_pattern;    // Pointer to pattern to match
} EXPR;             // Expression node

static int      clists = 1;     // One is first available index
static int      toklen[] = {    // Table of token lengths
    32767,      // T_END: invalid
    32767,      // T_STRING: invalid
    2,          // T_SINGLE
    ASCLEN/8+1, // T_CLASS
    1,          // T_ANY
    32767       // T_STAR: invalid
};

static int      (__cdecl *ncmp)(const char *,const char *,size_t);
                                // String comparison pointer


extern int      casesen;        // Case-sensitivity flag
extern char     *(*find)(unsigned char *, char *); // Pointer to search function
extern int      flags;          // Flags
extern int      strcnt;         // String count
extern char     transtab[];     // Translation table
EXPR            *stringlist[ASCLEN];
                                // String table


void            addexpr( char *, int ); // Add expression
extern char     *alloc(unsigned);       // User-defined heap allocator
unsigned char   *simpleprefix();        // Match simple prefix
char            *strnupr( char *pch, int cch );
void            printmessage(FILE  *fp, DWORD messagegid, ...);
                // Message display function for internationalization(findstr.c)

unsigned char *
simpleprefix(
    unsigned char *s,          // String pointer
    unsigned char **pp         // Pointer to pattern pointer
    )
{
    register unsigned char  *p;          // Simple pattern pointer
    register int            c;           // Single character
    char                    tmp[2];

    tmp[1] = 0;
    p = *pp;                   // Initialize
    while(*p != T_END && *p != T_STAR) { // While not at end of pattern
        switch(*p++) {                   // Switch on token type
            case T_STRING:               // String to compare
                if((*ncmp)((char *)s, (char *)p + 1, *p) != 0)
                    return(NULL);
                                        // Fail if mismatch found
                s += *p;                // Skip matched portion
                p += *p + 1;            // Skip to next token
                break;

            case T_SINGLE:              // Single character
                c = *s++;               // Get character
                if(!casesen) {
                    tmp[0] = (char)c;
                    c = (unsigned char)(_strupr(tmp))[0];
                }
                                        // Map to upper case if necessary
                if(c != (int)*p++)
                    return(NULL);
                                        // Fail if mismatch found
                break;

            case T_CLASS:               // Class of characters
                if(!(p[*s >> 3] & (1 << (*s & 7))))
                    return(NULL);       // Failure if bit not set
                p += ASCLEN/8;          // Skip bit vector
                ++s;                    // Skip character
                break;

            case T_ANY:                 // Any character

                if(*s == EOS || *s == EOS2)
                    return(NULL);       // Match all but end of string
                ++s;
                break;
        }
    }
    *pp = p;                            // Update pointer
    return(s);                          // Pattern is prefix of s
}


int
match(
    unsigned char  *s,          // String to match
    unsigned char  *p           // Pattern to match against
    )
{
    register unsigned char *q;          // Temporary pointer
    unsigned char       *r;             // Temporary pointer
    register int        c;              // Character
    char                tmp[2];

    if(*p != T_END && *p != T_STAR && (s = simpleprefix(s,&p)) == NULL)
        return(0);                      // Failure if prefix mismatch
    if(*p++ == T_END)
        return(1);                      // Match if end of pattern
    tmp[1] = 0;
    q = r = p;                          // Point to repeated token
    r += toklen[*q];                    // Skip repeated token
    switch(*q++) {                      // Switch on token type
        case T_ANY:                     // Any character
            while(match(s,r) == 0) {    // While match not found
                if(*s == EOS || *s == EOS2)
                    return(0);          // Match all but end of string
                ++s;
            }
            return(1);                    // Success

        case T_SINGLE:                  // Single character
            while(match(s,r) == 0) {    // While match not found
                c = *s++;               // Get character
                if(!casesen) {
                    tmp[0] = (char)c;
                    c = (unsigned char)(_strupr(tmp))[0];     // Map to upper case if necessary
                }
                if((unsigned char) c != *q)
                    return(0);          // Fail if mismatch found
            }
            return(1);                  // Success

        case T_CLASS:                   // Class of characters
            while(match(s,r) == 0) {    // While match not found
                if(!(q[*s >> 3] & (1 << (*s & 7))))
                    return(0);          // Fail if bit not set
                ++s;                    // Else skip character
            }
            return(1);                    // Success
    }
    return(0);                          // Return failure
}


int
exprmatch(
    char *s,                // String
    char *p                 // Pattern
    )
{
    ncmp = _strncoll;                    // Assume case-sensitive
    if(!casesen) {
        ncmp = _strnicoll;
    }                                   // Be case-insensitive if flag set

    // See if pattern matches string
    return(match((unsigned char *)s, (unsigned char *)p));
}


void
bitset(
    char            *bitvec,      // Bit vector
    unsigned char   first,        // First character
    unsigned char   last,         // Last character
    int             bitval        // Bit value (0 or 1)
    )
{
    int             bitno;        // Bit number

    bitvec += first >> 3;               // Point at first byte
    bitno = first & 7;                  // Calculate first bit number
    while(first <= last) {              // Loop to set bits
        if(bitno == 0 && first + 8 <= last) {
                                        // If we have a whole byte's worth
            *bitvec++ = (char)(bitval? '\xFF': '\0');
                                        // Set the bits
            first += 8;                 // Increment the counter
            continue;                   // Next iteration
        }
        *bitvec=(char)(*bitvec & (unsigned char)(~(1 << bitno))) | (unsigned char)(bitval << bitno);
                                        // Set the appropriate bit
        if(++bitno == 8) {              // If we wrap into next byte
            ++bitvec;                   // Increment pointer
            bitno = 0;                  // Reset bit index
        }
        ++first;                        // Increment bit index
    }
}


unsigned char *
exprparse(
    unsigned char  *p   // Raw pattern
    )
{
    register char       *cp;            // Char pointer
    unsigned char       *cp2;           // Char pointer
    int                 i;              // Counter/index
    int                 j;              // Counter/index
    int                 n;
    int                 bitval;         // Bit value
    char                buffer[PATMAX]; // Temporary buffer
    char                tmp1[2];
    char                tmp2[2];
    char                tmp3[2];
    unsigned            x;

    tmp1[1] = tmp2[1] = tmp3[1] =  0;
    if(!casesen)
        strnupr((char *)p, strlen((char *)p));  // Force pattern to upper case
    cp = buffer;                        // Initialize pointer
    if(*p == '^')
        *cp++ = *p++;                   // Copy leading caret if any
    while(*p != '\0') {                 // While not end of pattern
        i = -2;                         // Initialize
        for(n = 0;;) {                  // Loop to delimit ordinary string
            n += strcspn((char *)(p + n),".\\[*");// Look for a special character
            if(p[n] != '\\')
                break;                  // Break if not backslash
            i = n;                      // Remember where backslash is
            if(p[++n] == '\0')
                return(NULL);           // Cannot be at very end
            ++n;                        // Skip escaped character
        }
        if(p[n] == '*') {               // If we found a *-expr.
            if(n-- == 0)
                return(NULL);           // Illegal first character
            if(i == n - 1)
                n = i;                  // Escaped single-char. *-expr.
        }
        if(n > 0) {                     // If we have string or single
            if(n == 1 || (n == 2 && *p == '\\')) {
                                        // If single character
                *cp++ = T_SINGLE;       // Set type
                if(*p == '\\')
                    ++p;                // Skip escape if any
                *cp++ = *p++;           // Copy single character
            } else {                    // Else we have a string
                *cp++ = T_STRING;       // Set type
                cp2 = (unsigned char *)cp++;             // Save pointer to length byte
                while(n-- > 0) {        // While bytes to copy remain
                    if(*p == '\\') {    // If escape found
                        ++p;            // Skip escape
                        --n;            // Adjust length
                    }
                    *cp++ = *p++;       // Copy character
                }
                *cp2 = (unsigned char)((cp - (char *)cp2) - 1);
                                        // Set string length
            }
        }
        if(*p == '\0')
            break;                      // Break if end of pattern
        if(*p == '.') {                 // If matching any
            if(*++p == '*') {           // If star follows any
                ++p;                    // Skip star, too
                *cp++ = T_STAR;         // Insert prefix ahead of token
            }
            *cp++ = T_ANY;              // Match any character
            continue;                   // Next iteration
        }
        if(*p == '[') {                 // If character class
            if(*++p == '\0')
                return(NULL);
                                        // Skip '['
            *cp++ = T_CLASS;            // Set type
            memset(cp,'\0',ASCLEN/8);   // Clear the vector
            bitval = 1;                 // Assume we're setting bits
            if(*p == '^') {             // If inverted class
                ++p;                    // Skip '^'
                memset(cp,'\xFF',ASCLEN/8);
                                        // Set all bits
                bitset(cp,EOS,EOS,0);   // All except end-of-string
                bitset(cp,'\n','\n',0); // And linefeed!
                bitval = 0;             // Now we're clearing bits
            }

            while(*p != ']') {          // Loop to find ']'
                if(*p == '\0')
                    return(NULL);       // Check for malformed string
                if(*p == '\\') {        // If escape found
                    if(*++p == '\0')
                        return(NULL);   // Skip escape
                }
                i = *p++;               // Get first character in range
                if(*p == '-' && p[1] != '\0' && p[1] != ']') {
                                        // If range found
                    ++p;                // Skip hyphen
                    if(*p == '\\' && p[1] != '\0')
                        ++p;            // Skip escape character
                    j = *p++;           // Get end of range
                } else
                    j = i;              // Else just one character

                tmp1[0] = (char)i;
                tmp2[0] = (char)j;
                if (strcoll(tmp1, tmp2) <= 0) {
                    for (x=0; x<ASCLEN; x++) {
                        tmp3[0] = (char)x;
                        if (strcoll(tmp1, tmp3) <= 0 &&
                            strcoll(tmp3, tmp2) <= 0) {
                            bitset(cp, (unsigned char)tmp3[0],
                                   (unsigned char)tmp3[0], bitval);
                            if (!casesen) {
                                if (isupper(x)) {
                                    _strlwr(tmp3);
                                } else if (islower(x))
                                    _strupr(tmp3);
                                else
                                    continue;
                                bitset(cp, (unsigned char)tmp3[0],
                                       (unsigned char)tmp3[0], bitval);
                            }
                        }
                    }
                }
            }

            if(*++p == '*') {           // If repeated class
                memmove(cp,cp - 1,ASCLEN/8 + 1);
                                        // Move vector forward 1 byte
                cp[-1] = T_STAR;        // Insert prefix
                ++cp;                   // Skip to start of vector
                ++p;                    // Skip star
            }
            cp += ASCLEN/8;             // Skip over vector
            continue;                   // Next iteration
        }
        *cp++ = T_STAR;                 // Repeated single character
        *cp++ = T_SINGLE;
        if(*p == '\\')
            ++p;                        // Skip escape if any
        *cp++ = *p++;                   // Copy the character
        assert(*p == '*');              // Validate assumption
        ++p;                            // Skip the star
    }
    *cp++ = T_END;                      // Mark end of parsed expression
    cp2 = (unsigned char *)alloc((int)(cp - buffer));  // Allocate buffer
    memmove(cp2, buffer,(int)(cp - buffer));   // Copy expression to buffer
    return(cp2);                        // Return buffer pointer
}


int
istoken(
    unsigned char  *s,      // String
    int             n       // Length
    )
{
    if(n >= 2 && s[0] == '\\' && s[1] == '<')
        return(1);                      // Token if starts with '\<'

    while(n-- > 0) {                    // Loop to find end of string
        if(*s++ == '\\') {              // If escape found
            if(--n == 0 && *s == '>')
                return(1);              // Token if ends with '\>'
            ++s;                        // Skip escaped character
        }
    }
    return(0);                          // Not a token
}


int
isexpr(
    unsigned char  *s,  // String
    int             n   // Length
    )
{
    unsigned char       *cp;            // Char pointer
    int                 status;         // Return status
    char                buffer[BUFLEN]; // Temporary buffer

    if(istoken(s, n))
        return(1);                      // Tokens are exprs
    memmove(buffer,s,n);                // Copy string to buffer
    buffer[n] = '\0';                   // Null-terminate string
    if (*buffer && buffer[n - 1] == '$')
        return(1);
    if((s = exprparse((unsigned char *)buffer)) == NULL)
        return(0);                      // Not an expression if parse fails
    status = 1;                         // Assume we have an expression
    if(*s != '^' && *s != T_END) {      // If no caret and not empty
        status = 0;                     // Assume not an expression
        cp = s;                         // Initialize
        do {                            // Loop to find special tokens
            switch(*cp++) {             // Switch on token type
                case T_STAR:            // Repeat prefix
                case T_CLASS:           // Character class
                case T_ANY:             // Any character
                    ++status;           // This is an expression
                    break;

                case T_SINGLE:          // Single character
                    ++cp;               // Skip character
                    break;

                case T_STRING:          // String
                    cp += *cp + 1;      // Skip string
                    break;
            }
        }
        while(!status && *cp != T_END)
            ;                           // Do while not at end of expression
    }
    free(s);                            // Free expression
    return(status);                     // Return status
}


#ifdef  gone // for DEBUG

void
exprprint(
    unsigned char *p,       // Pointer to expression
    FILE          *fo       // File pointer
    )
{
    int                 bit;            // Bit value
    int                 count;          // Count of characters in string
    int                 first;          // First character in range
    int                 last;           // Last character in range
    int                 star;           // Repeat prefix flag

    if(*p == '^')
        fputc(*p++,fo);                 // Print leading caret

    while(*p != T_END) {                // While not at end of expression
        star = 0;                       // Assume no prefix
        if(*p == T_STAR) {              // If repeat prefix found
            ++star;                     // Set flag
            ++p;                        // Skip prefix
        }
        switch(*p++) {                  // Switch on token type
            case T_END:                 // End of expression
            case T_STAR:                // Repeat prefix
                fprintf(stderr,"Internal error: exprprint\n");
                                        // Not valid
                exit(2);                // Die abnormal death

            case T_STRING:              // String
                count = *p++;           // Get string length
                goto common;            // Forgive me, Djikstra!

            case T_SINGLE:              // Single character
                count = 1;              // Only one character
common:
                while(count-- > 0) {    // While bytes remain
                    if(*p == EOS || *p == EOS2) {
                                        // If end-of-string found
                        ++p;            // Skip character
                        fputc('$',fo);  // Emit special marker
                        continue;       // Next iteration
                    }
                    if(strchr("*.[\\$",*p) != NULL)
                        fputc('\\',fo); // Emit escape if needed

                    fputc(*p++,fo);     // Emit the character
                }
                break;

            case T_ANY:                         // Match any
                fputc('.',fo);                  // Emit dot
                break;

            case T_CLASS:
                first = -1;                     // Initialize
                fputc('[',fo);                  // Open braces
                for(count = ' '; count <= '~'; ++count) {
                                                // Loop through printable characters
                    if((bit = p[count >> 3] & (1 << (count & 7))) != 0) {
                                                // If bit is set
                        if(first == -1)
                            first = count;
                                                // Set first bit
                        last = count;           // Set last bit
                    }
                    if((!bit || count == '~') && first != -1) {
                                                // If range to print
                        if(strchr("\\]-",first) != NULL)
                            fputc('\\',fo);     // Emit escape if needed
                        fputc(first,fo);        // Print first character in range
                        if(last != first) {     // If we have a range

                            if(last > first + 1)
                                fputc('-',fo);  // Emit hyphen if needed

                            if(strchr("\\]-",last) != NULL)
                                fputc('\\',fo); // Emit escape if needed

                            fputc(last,fo);
                                                // Print last character in range
                        }
                        first = -1;             // Range printed
                    }
                }
                fputc(']',fo);                  // Close braces
                p += ASCLEN/8;                  // Skip bit vector
                break;
        }
        if(star)
            fputc('*',fo);                      // Print star if needed
    }
    fputc('\n',fo);                             // Print newline
}

#endif


char *
get1stcharset(
    unsigned char *e,       // Pointer to expression
    char          *bitvec   // Pointer to bit vector
    )
{
    unsigned char       *cp;            // Char pointer
    int                 i;              // Index/counter
    int                 star;           // Repeat prefix flag

    if(*e == '^')
        ++e;                            // Skip leading caret if any
    memset(bitvec,'\0',ASCLEN/8);       // Clear bit vector
    cp = e;                             // Initialize
    while(*e != T_END) {                // Loop to process leading *-expr.s
        star = 0;                       // Assume no repeat prefix
        if(*e == T_STAR) {              // If repeat prefix found
            ++star;                     // Set flag
            ++e;                        // Skip repeat prefix
        }
        switch(*e++) {                  // Switch on token type
            case T_END:                 // End of expression
            case T_STAR:                // Repeat prefix

                assert(0);              // Not valid
                exit(2);                // Die abnormal death

            case T_STRING:              // String
                if(star || *e++ == '\0') { // If repeat prefix or zero count
                    assert(0);          // Not valid
                    exit(2);            // Die abnormal death
                }
                // Drop through

            case T_SINGLE:              // Single character
                bitset(bitvec,*e,*e,1); // Set the bit
                ++e;                    // Skip the character
                break;

            case T_ANY:                 // Match any
                memset(bitvec,'\xFF',ASCLEN/8);
                                      // Set all the bits
                bitset(bitvec,EOS,EOS,0);   // Except end-of-string
                bitset(bitvec,'\n','\n',0); // And linefeed!
                break;

            case T_CLASS:
                for(i = 0; i < ASCLEN/8; ++i)
                    bitvec[i] |= *e++;  // Or in all the bits
                break;
        }
        if(!star)
            break;                      // Break if not repeated
        cp = e;                         // Update pointer
    }
    return((char *)cp);                 // Point to 1st non-repeated expr.
}


char *
findall(
    unsigned char *buffer,  // Buffer in which to search
    char *bufend            // End of buffer
    )
{
    return(buffer < (unsigned char *) bufend ? (char *) buffer : NULL);  // Fail only on empty buffer
}


void
addtoken(
    char *e,        // Raw token expression
    int   n         // Length of expression
    )
{
    static char         achpref[] = "^";// Prefix
    static char         achprefsuf[] = "[^A-Za-z0-9_]";
                                        // Prefix/suffix
    static char         achsuf[] = "$"; // Suffix
    char                buffer[BUFLEN]; // Temporary buffer

    assert(n >= 2);                     // Must have at least two characters
    if(e[0] == '\\' && e[1] == '<') {   // If begin token
        if(!(flags & BEGLINE)) {        // If not matching at beginning only
            memcpy(buffer,achprefsuf,sizeof achprefsuf - 1);
                                        // Copy first prefix
            memcpy(buffer + sizeof achprefsuf - 1,e + 2,n - 2);
                                        // Attach expression
            addexpr(buffer,n + sizeof achprefsuf - 3);
                                        // Add expression
        }
        memcpy(buffer,achpref,sizeof achpref - 1);
                                        // Copy second prefix
        memcpy(buffer + sizeof achpref - 1,e + 2,n - 2);
                                        // Attach expression
        addexpr(buffer,n + sizeof achpref - 3);
                                        // Add expression
        return;                         // Done
    }
    assert(e[n-2] == '\\' && e[n - 1] == '>');
                                        // Must be end token
    if(!(flags & ENDLINE)) {            // If not matching at end only
        memcpy(buffer,e,n - 2);         // Copy expression
        memcpy(buffer + n - 2,achprefsuf,sizeof achprefsuf - 1);
                                        // Attach first suffix
        addexpr(buffer,n + sizeof achprefsuf - 3);
                                        // Add expression
    }
    memcpy(buffer,e,n - 2);             // Copy expression
    memcpy(buffer + n - 2,achsuf,sizeof achsuf - 1);
                                        // Attach second suffix
    addexpr(buffer,n + sizeof achsuf - 3);
                                        // Add expression
}


void
addexpr(
    char *e,        // Expression to add
    int   n         // Length of expression
    )
{
    EXPR                *expr;          // Expression node pointer
    int                 i;              // Index
    int                 j;              // Index
    int                 locflags;       // Local copy of flags
    char                bitvec[ASCLEN/8];
                                        // First char. bit vector
    char                buffer[BUFLEN]; // Temporary buffer
    char                tmp[2];

    if(find == findall)
        return;                         // Return if matching everything
    if(istoken((unsigned char *)e, n)) {    // If expr is token
        addtoken(e,n);                  // Convert and add tokens
        return;                         // Done
    }
    tmp[1] = 0;
    locflags = flags;                   // Initialize local copy
    if(*e == '^') locflags |= BEGLINE;  // Set flag if match must begin line
    j = -2;                             // Assume no escapes in string
    for(i = 0; i < n - 1; ++i) {        // Loop to find last escape
        if(e[i] == '\\') j = i++;       // Save index of last escape
    }
    if(n > 0 && e[n-1] == '$' && j != n-2) {
                                        // If expr. ends in unescaped '$'
        --n;                            // Skip dollar sign
        locflags |= ENDLINE;            // Match must be at end
    }
    strncpy(buffer,e,n);                // Copy pattern to buffer
    if(locflags & ENDLINE)
        buffer[n++] = EOS;              // Add end character if needed
    buffer[n] = '\0';                   // Null-terminate string
    if((e = (char *)exprparse((unsigned char *)buffer)) == NULL)
        return;                         // Return if invalid expression
    ++strcnt;                           // Increment string count
    if(!(locflags & BEGLINE)) {         // If match needn't be at beginning
        e = get1stcharset((unsigned char *)e, bitvec); // Remove leading *-expr.s
    }

    //  E now points to a buffer containing a preprocessed expression.
    //  We need to find the set of allowable first characters and make
    //  the appropriate entries in the string node table.

    if(*get1stcharset((unsigned char *)e, bitvec) == T_END) {
                                        // If expression will match anything
        find = findall;                 // Match everything
        return;                         // All done
    }

    for(j = 0; j < ASCLEN; ++j) {       // Loop to examine bit vector
        if(bitvec[j >> 3] & (1 << (j & 7))) {       // If the bit is set
            expr = (EXPR *) alloc(sizeof(EXPR));    // Allocate record
            expr->ex_pattern = (unsigned char *)e;  // Point it at pattern
            if((i = (UCHAR)transtab[j]) == 0) {            // If no existing list
                if((i = clists++) >= ASCLEN) {      // If too many string lists

                    printmessage(stderr,MSG_FINDSTR_TOO_MANY_STRING_LISTS,NULL);
                                        // Error message
                    exit(2);            // Die
                }
                stringlist[i] = NULL;   // Initialize
                transtab[j] = (char) i; // Set pointer to new list
                if(!casesen && isalpha(j)) {
                    tmp[0] = (char)j;
                    if ((unsigned char)(_strlwr(tmp))[0] != (unsigned char)j ||
                        (unsigned char)(_strupr(tmp))[0] != (unsigned char)j)
                        transtab[(unsigned char)tmp[0]] = (char)i;  // Set pointer for other case

                }
            }
            expr->ex_next = stringlist[i];          // Link new record into table
            stringlist[i] = expr;
        }
    }

    // if(locflags & DEBUG) exprprint(e,stderr);
                                        // Print the expression if debugging
}


char *
findexpr(
    unsigned char *buffer,  // Buffer in which to search
    char          *bufend   // End of buffer
    )
{
    EXPR          *expr;        // Expression list pointer
    unsigned char *pattern;     // Pattern
    int            i;           // Index
    unsigned char *bufbegin;
    int b;

    bufbegin = buffer;

    while(buffer < (unsigned char *)bufend) {            // Loop to find match
        if((i = (UCHAR)transtab[*buffer++]) == 0)
            continue;                   // Continue if not valid 1st char
        if((expr = (EXPR *) stringlist[i]) == NULL) {
            // If null pointer
            assert(0);
            exit(2);                    // Die
        }
        --buffer;                       // Back up to first character
        while(expr != NULL) {           // Loop to find match
            pattern = expr->ex_pattern; // Point to pattern
            expr = expr->ex_next;       // Point to next record
            if(pattern[0] == '^') {     // If match begin line
                ++pattern;              // Skip caret
                if(buffer > bufbegin && buffer[-1] != '\n') continue;
                                        // Don't bother if not at beginning
            }
            __try {
                b = exprmatch((char *)buffer, (char *)pattern);
            } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) {
                b = 0;
            }
            if (b) {
                return((char *)buffer);
            }
        }
        ++buffer;                       // Skip first character
    }
    return(NULL);                       // No match
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\find\find.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    find.cxx

Abstract:

    This utility allows the user to search for strings in a file
    It is functionaly compatible with DOS 5 find utility.

    SYNTAX (Command line)

      FIND [/?][/V][/C][/N][/I] "string" [[d:][path]filename[.ext]...]

      where:

        /? - Display this help
        /V - Display all lines NOT containing the string
        /C - Display only a count of lines containing string
        /N - Display number of line containing string
        /I - Ignore case

    UTILITY FUNCTION:

      Searches the specified file(s) looking for the string the user
      entered from the command line.  If file name(s) are specifeied,
      those names are displayed, and if the string is found, then the
      entire line containing that string will be displayed.  Optional
      parameters modify that behavior and are described above.  String
      arguments have to be enclosed in double quotes.  (Two double quotes
      if a double quote is to be included).  Only one string argument is
      presently allowed.  The maximum line size is determined by buffer
      size.  Bigger lines will bomb the program.  If no file name is given
      then it will asssume the input is coming from the standard Input.
      No errors are reported when reading from standard Input.


    EXIT:
     The program returns errorlevel:
       0 - OK, and some matches
       1 -
       2 - Some Error


Author:

    Bruce Wilson (w-wilson) 08-May-1991

Environment:

    ULIB, User Mode

Revision History:

    08-May-1991             w-wilson

        created
-----------------------------------------------------------
    8/5/96                  t-reagjo

        Unicode re-enabled. This was broken, presumably by some changes to ulib.

        Non-Unicode files searched will now be converted to Unicode using the CP of the
        console.

        Changed the string comparison to use the NLSAPI call CompareString.
-----------------------------------------------------------
--*/

#include "ulib.hxx"
#include "ulibcl.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "mbstr.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "substrng.hxx"
#include "filestrm.hxx"
#include "file.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "find.hxx"
#include "dir.hxx"
#include <winnls.h>

extern "C" {
    #include <stdio.h>
    #include <string.h>
}

#define MAX_LINE_LEN            1024

static STR              TmpBuf[MAX_LINE_LEN];

DEFINE_CONSTRUCTOR( FIND, PROGRAM );

VOID
FIND::DisplayMessageAndExit(
    IN MSGID        MsgId,
    IN ULONG        ExitCode,
    IN MESSAGE_TYPE Type,
    IN PWSTRING     String
    )
/*++

Routine Description:

    Display an error message and exit.

Arguments:

    MsgId       - Supplies the Id of the message to display.
    String      - Supplies a string parameter for the message.
    ExitCode    - Supplies the exit code to use for exit.

Return Value:

    N/A


--*/
{
    if (MsgId != 0) {
        if (String)
            DisplayMessage(MsgId, Type, "%W", String);
        else
            DisplayMessage(MsgId, Type);
    }

    exit( ExitCode );
}


BOOLEAN
FIND::Initialize(
    )

/*++

Routine Description:

    Initializes an FIND class.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/

{
    ARGUMENT_LEXEMIZER      ArgLex;
    ARRAY                   LexArray;

    ARRAY                   ArgumentArray;

    STRING_ARGUMENT         ProgramNameArgument;
    FLAG_ARGUMENT           FlagCaseInsensitive;
    FLAG_ARGUMENT           FlagNegativeSearch;
    FLAG_ARGUMENT           FlagCountLines;
    FLAG_ARGUMENT           FlagDisplayNumbers;
    FLAG_ARGUMENT           FlagIncludeOfflineFiles;
    FLAG_ARGUMENT           FlagIncludeOfflineFiles2;
    FLAG_ARGUMENT           FlagDisplayHelp;
    FLAG_ARGUMENT           FlagInvalid;
    STRING_ARGUMENT         StringPattern;

    PROGRAM::Initialize();

    // An Error Level return of 1 indicates that no match was
    // found; a return of 0 indicates that a match was found.
    // Set it at 1 until a match is found.
    //
    _ErrorLevel = 1;

    if( !SYSTEM::IsCorrectVersion() ) {
        DisplayMessageAndExit(MSG_FIND_INCORRECT_VERSION, 2);
    }

    //
    // - init the array that will contain the command-line args
    //
    if ( !ArgumentArray.Initialize() ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    // - init the individual arguments
    //
    if( !ProgramNameArgument.Initialize("*")
        || !FlagCaseInsensitive.Initialize( "/I" )
        || !FlagNegativeSearch.Initialize( "/V" )
        || !FlagCountLines.Initialize( "/C" )
        || !FlagDisplayNumbers.Initialize( "/N" )
        || !FlagIncludeOfflineFiles.Initialize( "/OFFLINE" )
        || !FlagIncludeOfflineFiles2.Initialize( "/OFF" )
        || !FlagDisplayHelp.Initialize( "/?" )
        || !FlagInvalid.Initialize( "/*" )          // comment */
        || !StringPattern.Initialize( "\"*\"" )
        || !_PathArguments.Initialize( "*", FALSE, TRUE ) ) {

        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    // - put the arguments in the array
    //
    if( !ArgumentArray.Put( &ProgramNameArgument )
        || !ArgumentArray.Put( &FlagCaseInsensitive )
        || !ArgumentArray.Put( &FlagNegativeSearch )
        || !ArgumentArray.Put( &FlagCountLines )
        || !ArgumentArray.Put( &FlagDisplayNumbers )
        || !ArgumentArray.Put( &FlagIncludeOfflineFiles )
        || !ArgumentArray.Put( &FlagIncludeOfflineFiles2 )
        || !ArgumentArray.Put( &FlagDisplayHelp )
        || !ArgumentArray.Put( &FlagInvalid )
        || !ArgumentArray.Put( &StringPattern )
        || !ArgumentArray.Put( &_PathArguments ) ) {

        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }
    //
    // - init the lexemizer
    //
    if ( !LexArray.Initialize() ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }
    if ( !ArgLex.Initialize( &LexArray ) ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    // - set up the defaults
    //
    ArgLex.PutSwitches( "/" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );
    ArgLex.PutSeparators( " \"\t" );
    ArgLex.SetCaseSensitive( FALSE );
    if( !ArgLex.PrepareToParse() ) {

        //
        // invalid format
        //
        DisplayMessageAndExit(MSG_FIND_INVALID_FORMAT, 2);
    }


    //
    // - now parse the command line.  The args in the array will be set
    //   if they are found on the command line.
    //
    if( !ArgLex.DoParsing( &ArgumentArray ) ) {
        if( FlagInvalid.QueryFlag() ) {
            //
            // invalid switch
            //
            DisplayMessageAndExit(MSG_FIND_INVALID_SWITCH, 2);

        } else {
            //
            // invalid format
            //
           DisplayMessageAndExit(MSG_FIND_INVALID_FORMAT, 2);
        }
    } else if ( _PathArguments.WildCardExpansionFailed() ) {

        //
        //  No files matched
        //
        DisplayMessageAndExit(MSG_FIND_FILE_NOT_FOUND,
                              2,
                              ERROR_MESSAGE,
                              (PWSTRING)_PathArguments.GetLexemeThatFailed());
    }

    if( FlagInvalid.QueryFlag() ) {
        //
        // invalid switch
        //
        DisplayMessageAndExit(MSG_FIND_INVALID_SWITCH, 2);
    }

    //
    // - now do semantic checking/processing
    //    - if they ask for help, do it right away and return
    //    - set flags
    //
    if( FlagDisplayHelp.QueryFlag() ) {
        DisplayMessageAndExit(MSG_FIND_USAGE, 0, NORMAL_MESSAGE);
    }

    if( !StringPattern.IsValueSet() ) {
        DisplayMessageAndExit(MSG_FIND_INVALID_FORMAT, 2);
    } else {
        //
        // - keep a copy of the pattern string
        //

           DebugAssert(StringPattern.GetString());
        _PatternString.Initialize(StringPattern.GetString());

    }

    _CaseSensitive = (BOOLEAN)!FlagCaseInsensitive.QueryFlag();

    _LinesContainingPattern = (BOOLEAN)!FlagNegativeSearch.QueryFlag();

    _OutputLines = (BOOLEAN)!FlagCountLines.QueryFlag();

    _OutputLineNumbers = (BOOLEAN)FlagDisplayNumbers.QueryFlag();

    _SkipOfflineFiles =  ( (BOOLEAN)!FlagIncludeOfflineFiles.QueryFlag() ) &&
                         ( (BOOLEAN)!FlagIncludeOfflineFiles2.QueryFlag() );

    return( TRUE );
}


BOOLEAN
FIND::IsDos5CompatibleFileName(
    IN PCPATH       Path
    )
/*++

Routine Description:

    Parses the path string and returns FALSE if DOS5 would reject
    the path.

Arguments:

    Path    -       Supplies the path

Return Value:

    BOOLEAN -       Returns FALSE if DOS5 would reject the path,
                    TRUE otherwise

--*/

{

    PWSTRING        String;

    DebugPtrAssert( Path );

    String = (PWSTRING)Path->GetPathString();

    DebugPtrAssert( String );

    if ( String->QueryChCount() > 0 ) {

        if ( String->QueryChAt(0) == '\"' ) {
            return FALSE;
        }
    }

    return TRUE;

}



ULONG
FIND::SearchStream(
    PSTREAM                 StreamToSearch
    )

/*++

Routine Description:

    Does the search on an open file_stream.

Arguments:

    None.

Return Value:

    Number of lines found/not found.


--*/

{

    ULONG       LineCount;
    ULONG       FoundCount;
    DWORD       PatternLen;
    DWORD       LineLen;
    DWORD       LastPosInLine;
    BOOLEAN     Found;
    WCHAR       c;
    PWSTR       pLine;
    PWSTR       p;
    WCHAR       CurrentLine[MAX_LINE_LEN];
    WCHAR       PatternString[MAX_LINE_LEN];
    DSTRING     dstring;
    DSTRING     _String;
    DWORD       CompareFlags;


    LineCount   = FoundCount = 0;
    PatternLen  = _PatternString.QueryChCount() ;
    _PatternString.QueryWSTR(0,TO_END,PatternString,MAX_LINE_LEN,TRUE);

    if ( !_String.Initialize() ) {
        DisplayMessageAndExit(MSG_FIND_OUT_OF_MEMORY, 2);
    }

    //
    //  - converting to Unicode from the current console code page
    //          (say -that- ten times fast...)
    //
    _String.SetConsoleConversions();

    //
    //    - for each line from stream
    //       - do strstr to see if pattern string is in line
    //       - if -ve search and not in line || +ve search and in line
    //          - output line and number or inc counter appropriately
    //
    while( !StreamToSearch->IsAtEnd() ) {

        if ( !StreamToSearch->ReadLine( &_String)) {
            DisplayMessageAndExit(MSG_FIND_UNABLE_TO_READ_FILE, 2);
        }
        if (_String.QueryChCount() == 0 &&
            StreamToSearch->IsAtEnd()) {
            break;
        }
        _String.QueryWSTR(0,TO_END,CurrentLine,MAX_LINE_LEN,TRUE);
        LineLen = min ( MAX_LINE_LEN - 1, _String.QueryChCount());
        LineCount++;

        //
        //      - look for pattern string in the current line
        //              - note: a 0-length pattern ("") never matches a line.
        //                A 0-length pattern can produce output with the /v
        //                switch.
        //      - start at the end (saves a var)
        //

        Found = FALSE;

        if ( PatternLen && LineLen >= PatternLen ) {

            CompareFlags = 0;
            if ( !_CaseSensitive ) {
                CompareFlags |= NORM_IGNORECASE;
            }

            LastPosInLine = LineLen - PatternLen + 1;
            pLine = CurrentLine + LastPosInLine;

            while ( pLine >= CurrentLine && !Found ) {

                if ( CompareString ( LOCALE_USER_DEFAULT, CompareFlags, PatternString, PatternLen, pLine, PatternLen ) == 2 ) {

                    Found = TRUE;
                }
                pLine--;

            }
        }

        //
        // - if either (search is +ve and found a match)
        //          or (search is -ve and no match found)
        //   then print line/line number based on options
        //
        if( (_LinesContainingPattern && Found)
            || (!_LinesContainingPattern && !Found) ) {

            FoundCount++;
            if( _OutputLines ) {
                dstring.Initialize(CurrentLine);
                if( _OutputLineNumbers ) {
                    DisplayMessage( MSG_FIND_LINE_AND_NUMBER, NORMAL_MESSAGE, "%d%W", LineCount, &dstring);
                } else {
                    DisplayMessage( MSG_FIND_LINEONLY, NORMAL_MESSAGE, "%W", &dstring);
                }
            }
        }
    }

    if (FoundCount) {

        // Set _ErrorLevel to zero to indicate that at least
        // one match has been found.
        //
        _ErrorLevel = 0;
    }
    return(FoundCount);
}



VOID
FIND::SearchFiles(
    )

/*++

Routine Description:

    Does the search on the files specified on the command line.

Arguments:

    None.

Return Value:

    None.


--*/

{
    PARRAY                  PathArray;
    PARRAY_ITERATOR         PIterator;
    PPATH                   CurrentPath;
    PFSN_FILE               CurrentFSNode   = NULL;
    PFSN_DIRECTORY          CurrentFSDir;
    PFILE_STREAM            CurrentFile     = NULL;
    DSTRING                 CurrentPathString;
    ULONG                   LinesFound;
    BOOLEAN                 PrintSkipWarning = FALSE;
    BOOLEAN                 OfflineSkipped;

    //
    // - if 0 paths on cmdline then open stdin
    // - if more than one path set OutputName flag
    //

    if( (_PathArguments.QueryPathCount() == 0) ) {

        // use stdin
        LinesFound = SearchStream( Get_Standard_Input_Stream() );

        if( !_OutputLines ) {
            DisplayMessage(MSG_FIND_COUNT, NORMAL_MESSAGE, "%d", LinesFound);
        }
        return;
    }

    PathArray = _PathArguments.GetPathArray();
    PIterator = (PARRAY_ITERATOR)PathArray->QueryIterator();

    //
    // - for each path specified on the command line
    //    - open a stream for the path
    //    - print filename if supposed to
    //    - call SearchStream
    //
    while( (CurrentPath = (PPATH)PIterator->GetNext()) != NULL ) {
        CurrentPathString.Initialize( CurrentPath->GetPathString() );
        CurrentPathString.Strupr();

        // if the system object can return a FSN_DIRECTORY for this
        // path then the user is trying to 'find' on a dir so print
        // access denied and skip this file

        if( CurrentFSDir = SYSTEM::QueryDirectory(CurrentPath) ) {

            if (CurrentPath->IsDrive()) {

                DisplayMessage(MSG_FIND_FILE_NOT_FOUND, ERROR_MESSAGE, "%W", &CurrentPathString);

            } else {

                DisplayMessage( MSG_ACCESS_DENIED, ERROR_MESSAGE, "%W", &CurrentPathString);

            }

            DELETE( CurrentFSDir );
            continue;
        }


        if( !(CurrentFSNode = SYSTEM::QueryFile(CurrentPath, _SkipOfflineFiles, &OfflineSkipped)) ||
            !(CurrentFile = CurrentFSNode->QueryStream(READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL)) ) {

            //
            //      If the file name is "", DOS5 prints an invalid parameter
            //      format message.  There is no clean way to filter this
            //      kind of stuff in the ULIB library, so we will have to
            //      parse the path ourselves.
            //
            if ( IsDos5CompatibleFileName( CurrentPath ) ) {
                //
                //  Track whether an offline file was skipped:
                //  We don't want to print an error message for each file,
                //  just a one warning at the end
                //
                if (OfflineSkipped) {
                    PrintSkipWarning = TRUE;
                } else {
                    DisplayMessage(MSG_FIND_FILE_NOT_FOUND, ERROR_MESSAGE, "%W", &CurrentPathString);
                }
            } else {
                DisplayMessage(MSG_FIND_INVALID_FORMAT, ERROR_MESSAGE );
                break;
            }
            DELETE( CurrentFile );
            DELETE( CurrentFSNode );
            CurrentFile     =   NULL;
            CurrentFSNode   =   NULL;
            continue;

        }

        if( _OutputLines ) {
            DisplayMessage( MSG_FIND_BANNER, NORMAL_MESSAGE, "%W", &CurrentPathString);
        }

        LinesFound = SearchStream( CurrentFile );

        if( !_OutputLines ) {
            DisplayMessage(MSG_FIND_COUNT_BANNER, NORMAL_MESSAGE, "%W%d", &CurrentPathString, LinesFound);
        }

        DELETE( CurrentFSNode );
        DELETE( CurrentFile );
        CurrentFSNode   = NULL;
        CurrentFile     = NULL;
    }

    //
    // Print warning message if offline files were skipped
    //
    if(PrintSkipWarning) {
        DisplayMessage(MSG_FIND_OFFLINE_FILES_SKIPPED, ERROR_MESSAGE);
    }

    return;
}



VOID
FIND::Terminate(
    )

/*++

Routine Description:

    Deletes objects created during initialization.

Arguments:

    None.

Return Value:

    None.


--*/

{
   exit(_ErrorLevel);
}


VOID __cdecl
main()
{
   DEFINE_CLASS_DESCRIPTOR( FIND );

   {
       FIND    Find;

        if( Find.Initialize() ) {
            Find.SearchFiles();
        }

        Find.Terminate();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\findstr\recurse.c ===
// recurse.c

#include <ctype.h>
#include <direct.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>

typedef struct patarray_s {
    HANDLE  hfind;           // handle for FindFirstFile/FindNextFile
    BOOLEAN find_next_file;  // TRUE if FindNextFile is to be called
    BOOLEAN IsDir;           // TRUE if current found file is a dir
    char    szfile[MAX_PATH];// Name of file/dir found
} patarray_t;

typedef struct dirstack_s {
    struct dirstack_s *next;    // Next element in stack
    struct dirstack_s *prev;    // Previous element in stack
    HANDLE  hfind;
    patarray_t *ppatarray;      // pointer to an array of pattern records
    char szdir[1];              // Directory name
} dirstack_t;                   // Directory stack

#define FA_ATTR(x)  ((x).dwFileAttributes)
#define FA_CCHNAME(x)   MAX_PATH
#define FA_NAME(x)  ((x).cFileName)
#define FA_ALL      (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | \
                     FILE_ATTRIBUTE_SYSTEM)
#define FA_DIR      FILE_ATTRIBUTE_DIRECTORY

static dirstack_t *pdircur = NULL;  // Current directory pointer

void
makename(
    char *pszfile,
    char *pszname
    )
{
    dirstack_t *pdir;               // Directory stack pointer

    *pszfile = '\0';                // Start with null string
    pdir = pdircur;                 // Point at last entry
    if (pdir->next != pdircur) {    // If not only entry
        do {
            pdir = pdir->next;      // Advance to next subdirectory
            strcat(pszfile,pdir->szdir);// Add the subdirectory
        } while (pdir != pdircur);  // Do until current directory
    } else
        strcpy(pszfile, pdircur->szdir);

    strcat(pszfile,pszname);
}


int
filematch(
    char *pszfile,
    char **ppszpat,
    int cpat,
    int fsubdirs
    )
{
    WIN32_FIND_DATA fi, fi2;
    BOOL            b;
    int i;
    dirstack_t *pdir;
    patarray_t *pPatFind;
    char       drive[_MAX_DRIVE];
    char       dir[_MAX_DIR];
    char       fname[_MAX_FNAME];
    char       ext[_MAX_EXT];

    assert(INVALID_HANDLE_VALUE != NULL);

    if (pdircur == NULL) {

       // If stack empty
       if ((pdircur = (dirstack_t *) malloc(sizeof(dirstack_t)+MAX_PATH+1)) == NULL)
            return(-1);                     // Fail if allocation fails

       if ((pdircur->ppatarray =
                (patarray_t *) malloc(sizeof(patarray_t)*cpat)) == NULL) {
            free(pdircur);
            return(-1);
       }
       pdircur->szdir[0] = '\0';                // Root has no name
       pdircur->hfind = INVALID_HANDLE_VALUE;   // No search handle yet
       pdircur->next = pdircur->prev = pdircur; // Entry points to self

       _splitpath(ppszpat[0], drive, dir, fname, ext);

       strcpy(pdircur->szdir, drive);
       strcat(pdircur->szdir, dir);

       strcpy(ppszpat[0], fname);
       strcat(ppszpat[0], ext);

       for (i=1; i<cpat; i++) {
          _splitpath(ppszpat[i], drive, dir, fname, ext);
          strcpy(ppszpat[i], fname);
          strcat(ppszpat[i], ext);
       }

       for (i=0; i<cpat; i++) {
           pdircur->ppatarray[i].hfind = INVALID_HANDLE_VALUE;
           pdircur->ppatarray[i].szfile[0] = '\0';
       }
    }

    while (pdircur != NULL) {
        // While directories remain

        b = TRUE;

        if (pdircur->hfind == INVALID_HANDLE_VALUE) {
            // If no handle yet

            makename(pszfile,"*.*");        // Make search name

            pdircur->hfind = FindFirstFile((LPSTR) pszfile,
            (LPWIN32_FIND_DATA) &fi);       // Find first matching entry
        } else

           b = FindNextFile(pdircur->hfind,
               (LPWIN32_FIND_DATA) &fi);    // Else find next matching entry

        if (b == FALSE || pdircur->hfind == INVALID_HANDLE_VALUE) {
            // If search fails

            if (pdircur->hfind != INVALID_HANDLE_VALUE)
                FindClose(pdircur->hfind);
            pdir = pdircur;     // Point at record to delete
            if ((pdircur = pdir->prev) != pdir) {
                // If no parent directory

                pdircur->next = pdir->next; // Delete record from list
                pdir->next->prev = pdircur;
            } else
                pdircur = NULL;             // Else cause search to stop

            pPatFind = pdir->ppatarray;
            for (i=0; i<cpat; i++) {
                if (pPatFind[i].hfind != NULL &&
                    pPatFind[i].hfind != INVALID_HANDLE_VALUE)
                    FindClose(pPatFind[i].hfind);
            }
            free(pdir->ppatarray);
            free(pdir);                     // Free the record
            continue;                       // Top of loop
        }


        if (FA_ATTR(fi) & FA_DIR) {
            // If subdirectory found

            if (fsubdirs &&
                strcmp(FA_NAME(fi),".") != 0 && strcmp(FA_NAME(fi),"..") != 0 &&
                (pdir = (dirstack_t *) malloc(sizeof(dirstack_t)+FA_CCHNAME(fi)+1)) != NULL)
            {
                if ((pdir->ppatarray =
                        (patarray_t *) malloc(sizeof(patarray_t)*cpat)) == NULL) {
                     free(pdir);
                     continue;
                }
                // If not "." nor ".." and alloc okay

                strcpy(pdir->szdir,FA_NAME(fi));      // Copy name to buffer
                strcat(pdir->szdir,"\\");             // Add trailing backslash
                pdir->hfind = INVALID_HANDLE_VALUE;   // No search handle yet
                pdir->next = pdircur->next;           // Insert entry in linked list
                pdir->prev = pdircur;
                for (i=0; i<cpat; i++) {
                    pdir->ppatarray[i].hfind = INVALID_HANDLE_VALUE;
                    pdir->ppatarray[i].szfile[0] = '\0';
                }
                pdircur->next = pdir;
                pdir->next->prev = pdir;
                pdircur = pdir;             // Make new entry current
            }
            continue;                       // Top of loop
        }

        pPatFind = pdircur->ppatarray;
        for (i = cpat; i-- > 0; ) {
            // Loop to see if we care
            b = (pPatFind[i].hfind != NULL);
            for (;;) {
                if (pPatFind[i].hfind == INVALID_HANDLE_VALUE) {
                    makename(pszfile, ppszpat[i]);
                    pPatFind[i].hfind = FindFirstFile(pszfile, &fi2);
                    b = (pPatFind[i].hfind != INVALID_HANDLE_VALUE);
                    pPatFind[i].find_next_file = FALSE;
                    if (b) {
                        strcpy(pPatFind[i].szfile, FA_NAME(fi2));
                        pPatFind[i].IsDir = (BOOLEAN)(FA_ATTR(fi2) & FA_DIR);
                    }
                } else if (pPatFind[i].find_next_file) {
                    b = FindNextFile(pPatFind[i].hfind, &fi2);
                    pPatFind[i].find_next_file = FALSE;
                    if (b) {
                        strcpy(pPatFind[i].szfile, FA_NAME(fi2));
                        pPatFind[i].IsDir = (BOOLEAN)(FA_ATTR(fi2) & FA_DIR);
                    }
                }
                if (b) {
                    if (pPatFind[i].IsDir) {
                        pPatFind[i].find_next_file = TRUE;
                    } else
                        break;   // found a file to do matching
                } else {
                    if (pPatFind[i].hfind != NULL &&
                            pPatFind[i].hfind != INVALID_HANDLE_VALUE) {
                        FindClose(pPatFind[i].hfind);
                        pPatFind[i].hfind = NULL;
                    }
                    pPatFind[i].find_next_file = FALSE;
                    break;    // exhausted all entries
                }
            } // for

            if (b) {
                if (strcmp(FA_NAME(fi), pPatFind[i].szfile) == 0) {
                    pPatFind[i].find_next_file = TRUE;
                    makename(pszfile, FA_NAME(fi));
                    return 1;
                }
            }
        }
    }
    return(-1);             // No match found
}



#ifdef  TEST
#include <process.h>
#include <stdio.h>

void
main(
    int carg,
    char **ppszarg
    )
{
    char szfile[MAX_PATH]; // if OS2: CCHPATHMAX];

    while (filematch(szfile,ppszarg,carg) >= 0)
    printf("%s\n",szfile);
    exit(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\chkdsk.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "fmifsmsg.hxx"
#include "chkmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "ifsentry.hxx"
#include "system.hxx"
#include "drive.hxx"
#include "rtmsg.h"

// IFMIFS_CHKDSK_ALGORITHM_SPECIFIED
//  - For NTFS, this indicates an algorithm value is specified
//    This bit cannot be used together with FMIFS_CHKDSK_SKIP_INDEX_SCAN

#define IFMIFS_CHKDSK_ALGORITHM_SPECIFIED      0x00000800UL

//
//
// Values related to the above bits
//
#define IFMIFS_CHKDSK_MAX_ALGORITHM_VALUE      50

VOID
Chkdsk(
    IN  PWSTR               DriveName,
    IN  PWSTR               FileSystemName,
    IN  BOOLEAN             Fix,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             OnlyIfDirty,
    IN  BOOLEAN             Recover,
    IN  PWSTR               PathToCheck,
    IN  BOOLEAN             Extend,
    IN  FMIFS_CALLBACK      Callback
    )

/*++

Routine Description:

    This routine loads and calls the correct DLL to chkdsk the
    given volume.

    This is is for either GUI or text mode.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    FileSystemName  - Supplies the file system name (e.g., FAT) of the volume
    Fix             - Whether or not to fix detected consistency problems
    Verbose         - Whether to print every filename 
    OnlyIfDirty     - Whether to check consistency only if the volume is dirty
    Recover         - Whether to perform a full sector read test
    PathToCheck     - Supplies a path to check for fragmentation
    Extend          - Whether the volume is being extended
    Callback        - Supplies the necessary call back for
                        communication with the client

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if 0

    // test code

    FMIFS_CHKDSKEX_PARAM   Param;


    Param.Major = 1;
    Param.Minor = 0;
    Param.Flags = Verbose ? CHKDSK_VERBOSE : 0;
    Param.Flags |= OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0;
    Param.Flags |= Recover ? CHKDSK_RECOVER : 0;
    Param.Flags |= Extend ? CHKDSK_EXTEND : 0;

    ChkdskEx(
        L"\\\\?\\Volume{d4031341-da5e-11d1-93f6-000000000000}\\pretty\\x",
        FileSystemName,
        Fix,
        &Param,
        Callback
        );
#else
    FMIFS_CHKMSG                message;
    DSTRING                     chkdsk_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    CHKDSK_FN                   chkdsk_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;
    PATH                        check_path;
    ULONG                       chkdsk_result;
    DSTRING                     fat32_name;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !chkdsk_string.Initialize("Chkdsk") ||
        !library_name.Initialize("U") ||

        // Intercept the FAT32 file system name string and convert it into
        // FAT.

        !file_system_name.Initialize(FileSystemName) ||
        !fat32_name.Initialize("FAT32") ||
        !file_system_name.Strupr() ||
        (file_system_name == fat32_name ? !file_system_name.Initialize("FAT") : FALSE) ||
        !library_name.Strcat(&file_system_name) ||
        !(chkdsk_function = (CHKDSK_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &chkdsk_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        (NULL != PathToCheck && !check_path.Initialize(PathToCheck)) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename))
    {
        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Call chkdsk.

    message.SetLoggingEnabled();

    message.Set(MSG_CHK_RUNNING);
    message.Log("%W", &dosdrivename);

    result = chkdsk_function(&ntdrivename,
                             &message,
                             Fix,
                             Verbose,
                             OnlyIfDirty,
                             Recover,
                             (NULL == PathToCheck) ? NULL : &check_path,
                             Extend,
                             FALSE,
                             0,
                             &chkdsk_result);

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
#endif
}


VOID
ChkdskEx(
    IN  PWSTR                   DriveName,
    IN  PWSTR                   FileSystemName,
    IN  BOOLEAN                 Fix,
    IN  PFMIFS_CHKDSKEX_PARAM   Param,
    IN  FMIFS_CALLBACK          Callback
    )

/*++

Routine Description:

    This routine loads and calls the correct DLL to chkdsk the
    given volume.

    This is for either GUI or text mode.

Arguments:

    DriveName       - Supplies the DOS style drive name optionally with a path
    FileSystemName  - Supplies the file system name (e.g., FAT) of the volume
    Fix             - Whether or not to fix detected consistency problems
    Param           - Supplies the parameter block (see fmifs.h for details)
    Callback        - Supplies the necessary call back for
                        communication with the client

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_CHKMSG                message;
    DSTRING                     chkdsk_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    CHKDSKEX_FN                 chkdsk_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;
    PATH                        fullpath;
    PATH                        drivepath;
    DSTRING                     drive_path_string;
    BOOLEAN                     is_drivepath_invalid;
    PATH_ANALYZE_CODE           rst;
    ULONG                       chkdsk_result;
    DSTRING                     fat32_name;
    CHKDSKEX_FN_PARAM           param;

    //
    // This structure is the internal version of FMIFS_CHKDSKEX_PARAM.
    //
    typedef struct {
        UCHAR   Major;      // initial version is 1.0
        UCHAR   Minor;
        ULONG   Flags;
        USHORT  Algorithm;  // version 1.1
    } IFMIFS_CHKDSKEX_PARAM, *PIFMIFS_CHKDSKEX_PARAM;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    DebugPrint("FMIFS: Using new ChkdskEx\n");

    if (Param->Major != 1 ||
        (Param->Minor != 0 && Param->Minor != 1) ||
        !message.Initialize(Callback) ||
        !chkdsk_string.Initialize("ChkdskEx") ||
        !library_name.Initialize("U") ||

        // Intercept the FAT32 file system name string and convert it into
        // FAT.

        !file_system_name.Initialize(FileSystemName) ||
        !fat32_name.Initialize("FAT32") ||
        !file_system_name.Strupr() ||
        (file_system_name == fat32_name ? !file_system_name.Initialize("FAT") : FALSE) ||
        !library_name.Strcat(&file_system_name) ||
        !(chkdsk_function = (CHKDSKEX_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &chkdsk_string,
                                           &dll_handle)) ||
        !drivepath.Initialize(DriveName))
    {
        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    rst = drivepath.AnalyzePath(&dosdrivename,
                                &fullpath,
                                &drive_path_string);

    switch (rst) {
        case PATH_OK:
            is_drivepath_invalid = fullpath.IsDrive() ||
                                   (fullpath.GetPathString()->QueryChCount() == 0);

            message.SetLoggingEnabled();

            message.Set(MSG_CHK_RUNNING);
            message.Log("%W", fullpath.GetPathString());

            if (fullpath.GetPathString()->QueryChCount() == 2 &&
                fullpath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                // if there is a drive letter for this drive, use it
                // instead of the guid volume name
                if (!dosdrivename.Initialize(fullpath.GetPathString())) {
                    finished_info.Success = FALSE;
                    Callback(FmIfsFinished,
                             sizeof(FMIFS_FINISHED_INFORMATION),
                             &finished_info);
                    return;
                }
            }
            if (IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename) &&
                fullpath.AppendString(&drive_path_string) &&
                drivepath.Initialize(&drive_path_string))
                break;

            // fall thru to indicate an error

        default:
            finished_info.Success = FALSE;
            Callback(FmIfsFinished,
                     sizeof(FMIFS_FINISHED_INFORMATION),
                     &finished_info);
            return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if ((FMIFS_CHKDSK_VERBOSE != CHKDSK_VERBOSE) || \
     (FMIFS_CHKDSK_RECOVER != CHKDSK_RECOVER) || \
     (FMIFS_CHKDSK_RECOVER_FREE_SPACE != CHKDSK_RECOVER_FREE_SPACE) || \
     (FMIFS_CHKDSK_RECOVER_ALLOC_SPACE != CHKDSK_RECOVER_ALLOC_SPACE) || \
     (FMIFS_CHKDSK_EXTEND != CHKDSK_EXTEND) || \
     (FMIFS_CHKDSK_DOWNGRADE != CHKDSK_DOWNGRADE) || \
     (FMIFS_CHKDSK_ENABLE_UPGRADE != CHKDSK_ENABLE_UPGRADE) || \
     (FMIFS_CHKDSK_CHECK_IF_DIRTY != CHKDSK_CHECK_IF_DIRTY) || \
     (FMIFS_CHKDSK_SKIP_INDEX_SCAN != CHKDSK_SKIP_INDEX_SCAN) || \
     (FMIFS_CHKDSK_SKIP_CYCLE_SCAN != CHKDSK_SKIP_CYCLE_SCAN) || \
     (FMIFS_CHKDSK_FORCE != CHKDSK_FORCE) || \
     (IFMIFS_CHKDSK_MAX_ALGORITHM_VALUE != CHKDSK_MAX_ALGORITHM_VALUE) || \
     (IFMIFS_CHKDSK_ALGORITHM_SPECIFIED != CHKDSK_ALGORITHM_SPECIFIED))

#error FMIFS_CHKDSK_* definition must be the same as that of CHKDSK_*

#endif

    param.Major = 1;
    param.Minor = 1;
    param.Flags = Param->Flags;
    param.PathToCheck = &fullpath;
    param.RootPath    = (is_drivepath_invalid ? NULL : &drivepath);
    param.LogFileSize = 0;
    if (Param->Major > 1 || (Param->Major == 1 && Param->Minor == 1))
        param.Algorithm = ((PIFMIFS_CHKDSKEX_PARAM)Param)->Algorithm;

    // Call chkdsk.

    result = chkdsk_function(&ntdrivename,
                             &message,
                             Fix,
                             &param,
                             &chkdsk_result);

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\findstr\findstr.c ===
// FINDSTR (used to be QGREP), June 1992
//
// Modification History:
//
//     Aug 1990     PeteS       Created.
//         1990     DaveGi      Ported to Cruiser
//  31-Oct-1990     W-Barry     Removed the #ifdef M_I386 'cause this
//                              code will never see 16bit again.
//  June 1992       t-petes     Added recursive file search in subdirs.
//                              Used file mapping instead of multi-thread.
//                              Disabled internal switches.
//                              Internatioanlized display messages.
//                              Made switches case-insensitive.
//  05/08/93        v-junm      Added Japanese search support.
//  06/03/93        v-junm      Added Bilingual Message support>


/*  About FILEMAP support:
 *  The file mapping object is used to speed up string searches. The new
 *  file mapping method is coded as #ifdef-#else-#endif to show the
 *  changes needed to be made. The old code(non-filemapping) has a read
 *  buffer like this:
 *
 *      filbuf[] = {.....................................}
 *                      ^                           ^
 *                    BegPtr                      EndPtr
 *
 *  This means there are some spare space before BegPtr and after EndPtr
 *  for the search algorithm to work its way. The old code also
 *  occasionally modifies filbuf[](like filbuf[i] = '\n';).
 *
 *  The new code(filemapping) must avoid doing all of the above because
 *  there are no spare space before BegPtr or after EndPtr when mapping
 *  view of the file which is opened as read-only.
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include <windows.h>
#include <ctype.h>
#include <assert.h>
#include <locale.h>
#include <stdarg.h>

#include "fsmsg.h"

#define FILBUFLEN   (SECTORLEN*2)

#define ISCOT       0x0002                          // Handle is console output
#define LG2SECLEN   10                              // Log base two of sector length
#define LNOLEN      12                              // Maximum line number length
#define MAXSTRLEN   128                             // Maximum search string length
#define OUTBUFLEN   (SECTORLEN*2)                   // Output buffer length
#define PATHLEN     (MAX_PATH+2)                    // Path buffer length
#define SECTORLEN   (1 << LG2SECLEN)                // Sector length
#define STKLEN      512                             // Stack length in bytes
#define TRTABLEN    256                             // Translation table length
#define s_text(x)   (((char *)(x)) - ((x)->s_must)) // Text field access macro
#define EOS         ('\r')                          // End of string
#define CURRENT_DIRECTORY_MAX_LENGTH    512
#define MAX_SLASH_C_OPTION          100

//  Bit flag definitions

#define SHOWNAME        0x01            // Print filename
#define NAMEONLY        0x02            // Print filename only
#define LINENOS         0x04            // Print line numbers
#define BEGLINE         0x08            // Match at beginning of line
#define ENDLINE         0x10            // Match at end of line
#define DEBUG           0x20            // Print debugging output
#define TIMER           0x40            // Time execution
#define SEEKOFF         0x80            // Print seek offsets
#define PRINTABLE_ONLY 0x100            // Skip files with non-printable characters
#define OFFLINE_FILES  0x200            // Do not skip offline files

#define DISPLAYBUFFER_SIZE     4096

//  Type definitions

typedef struct stringnode {
    struct stringnode   *s_alt;         // List of alternates
    struct stringnode   *s_suf;         // List of suffixes
    int                 s_must;         // Length of portion that must match
}
                        STRINGNODE;     // String node

typedef ULONG           CBIO;           // I/O byte count
typedef ULONG           PARM;           // Generic parameter

typedef CBIO            *PCBIO;         // Pointer to I/O byte count
typedef PARM            *PPARM;         // Pointer to generic parameter


// Global data

char    *BaseByteAddress = NULL;        // File mapping base address
BOOL    bStdIn = FALSE;                 // Std-input file flag
BOOL    bLargeFile = FALSE;                 // Dealing with non-memory mapped file

#ifdef FE_SB
BOOL    IsDBCSCodePage = TRUE;
#endif

char        filbuf[FILBUFLEN*2L + 12];
char        outbuf[OUTBUFLEN*2];
char        td1[TRTABLEN] = { 0 };
unsigned    cchmin = (unsigned)-1;      // Minimum string length
unsigned    chmax = 0;                  // Maximum character
unsigned    chmin = (unsigned)-1;       // Minimum character
char        transtab[TRTABLEN] = { 0 };
STRINGNODE  *stringlist[TRTABLEN/2];
int         casesen = 1;                // Assume case-sensitivity
long        cbfile;                     // Number of bytes in file
static int  clists = 1;                 // One is first available index
int         flags;                      // Flags
unsigned    lineno;                     // Current line number
char        *program;                   // Program name
int         status = 1;                 // Assume failure
int         strcnt = 0;                 // String count
char        target[MAXSTRLEN];          // Last string added
int         targetlen;                  // Length of last string added
unsigned    waste;                      // Wasted storage in heap
int         arrc;                       // I/O return code for DOSREAD
char        asyncio;                    // Asynchronous I/O flag
int         awrc = TRUE;                // I/O return code for DOSWRITE
char        *bufptr[] = { filbuf + 4, filbuf + FILBUFLEN + 8 };
CBIO        cbread;                     // Bytes read by DOSREAD
CBIO        cbwrite;                    // Bytes written by DOSWRITE
char        *obuf[] = { outbuf, outbuf + OUTBUFLEN };
int         ocnt[] = { OUTBUFLEN, OUTBUFLEN };
int         oi = 0;                     // Output buffer index
char        *optr[] = { outbuf, outbuf + OUTBUFLEN };
char        pmode;                      // Protected mode flag
WORD        wAttrib = 0;                // filename color
CONSOLE_SCREEN_BUFFER_INFO  csbi = {0}; // Our default screen info
CRITICAL_SECTION    critSection;
BOOLEAN             fExiting = FALSE;

BOOLEAN     fOfflineSkipped = FALSE;    // Whether offline files were skipped

//  External functions and forward references

void        printmessage(FILE  *fp, DWORD messagegID, ...);
            // Message display function for internationalization

int         filematch(char *pszfile, char **ppszpat, int cpat, int fsubdirs);

#ifdef FE_SB
// Function to check if a certain location in a string is the second byte
// of a DBCS character.
int  IsTailByte( unsigned const char *, const int );
int _mbsnicmp( const unsigned char *, const unsigned char *, int, BOOL * );
unsigned char *_mbslwr( unsigned char * );
char *_mbsrchr( const char *, int );
#endif

void        addexpr( char *, int );                  // See QMATCH.C
void        addstring( char *, int );                // See below
int         countlines( char *, char * );
char        *findexpr( unsigned char *, char *);     // See QMATCH.C
char        *findlist( unsigned char *, char * );
char        *findone( unsigned char *buffer, char *bufend );
void        flush1buf( void );                       // See below
void        flush1nobuf( void );                     // See below
int         grepbuffer( char *, char *, char * );    // See below
int         isexpr( unsigned char *, int );          // See QMATCH.C
void        matchstrings( char *, char *, int, int *, int * );
int         preveol( char * );
int         strncspn( char *, char *, int );
int         strnspn( char *, char *, int );
char        *strnupr( char *pch, int cch );
void        write1buf( char *, int, WORD );                // See below
void        (*addstr)( char *, int ) = NULL;
char        *(*find)( unsigned char *, char * ) = NULL;
void        (*flush1)( void ) = flush1buf;
int         (*grep)( char *, char *, char * ) = grepbuffer;
void        (*write1)( char *, int, WORD ) = write1buf;
void        write1nobuf( char *, int, WORD );

int
has_wild_cards(
    char* p
    )
{
    if (!p)
        return 0;

    for (; *p; p++) {
        if (*p == '?' || *p == '*') {
            return 1;
        }
    }

    return 0;
}


void
error(
    DWORD messageID
    )
{
    printmessage(stderr, messageID, program);
                                        // Print message
    exit(2);                            // Die
}


char *
alloc(
    unsigned size
    )
{
    char    *cp;        // Char pointer

    if ((cp = (char *) malloc(size)) == NULL) {   // If allocation fails
        printmessage(stderr, MSG_FINDSTR_OUT_OF_MEMORY, program);
                                        // Write error message
        exit(2);                        // Die
    }
    return(cp);                         // Return pointer to buffer
}


void
freenode(
    STRINGNODE *x
    )
{
    register STRINGNODE *y;             // Pointer to next node in list

    while(x != NULL) {                  // While not at end of list
        if (x->s_suf != NULL)
            freenode(x->s_suf);         // Free suffix list if not end
        else
            --strcnt;                   // Else decrement string count
        y = x;                          // Save pointer
        x = x->s_alt;                   // Move down the list
        free((char *)((INT_PTR) s_text(y) & ~(sizeof(void *) - 1)));
                                        // Free the node
    }
}


STRINGNODE  *
newnode(
    char *s,
    int n
    )
{
    register STRINGNODE *newNode;       // Pointer to new node
    char                *t;             // String pointer
    int                  d;             // rounds to a dword boundary

    d = n & (sizeof(void *) - 1) ? sizeof(void *) - (n & (sizeof(void *) - 1)) : 0;        // offset to next dword past n
    t = alloc(sizeof(STRINGNODE) + n + d);
                                        // Allocate string node
    t += d;                             // END of string word-aligned
    strncpy(t, s, n);                     // Copy string text
    newNode = (STRINGNODE *)(t + n);    // Set pointer to node
    newNode->s_alt = NULL;              // No alternates yet
    newNode->s_suf = NULL;              // No suffixes yet
    newNode->s_must = n;                // Set string length
    return(newNode);                    // Return pointer to new node
}


STRINGNODE  *
reallocnode(
    STRINGNODE *node,
    char *s,
    int n
    )
{
    register char       *cp;            // Char pointer

    assert(n <= node->s_must);          // Node must not grow
    waste += (unsigned)(node->s_must - n);
                                        // Add in wasted space
    assert(sizeof(char *) == sizeof(int));
                                        // Optimizer should eliminate this
    cp = (char *)((INT_PTR) s_text(node) & ~(sizeof(void *) - 1));
                                        // Point to start of text
    node->s_must = n;                   // Set new length
    if (n & (sizeof(void *) - 1))
        cp += sizeof(void *) - (n & (sizeof(void *) - 1));              // Adjust non dword-aligned string
    memmove(cp, s, n);                  // Copy new text
    cp += n;                            // Skip over new text
    memmove(cp, node, sizeof(STRINGNODE));// Copy the node
    return((STRINGNODE *) cp);          // Return pointer to moved node
}


/***    maketd1 - add entry for TD1 shift table
 *
 *      This function fills in the TD1 table for the given
 *      search string.  The idea is adapted from Daniel M.
 *      Sunday's QuickSearch algorithm as described in an
 *      article in the August 1990 issue of "Communications
 *      of the ACM".  As described, the algorithm is suitable
 *      for single-string searches.  The idea to extend it for
 *      multiple search strings is mine and is described below.
 *
 *              Think of searching for a match as shifting the search
 *              pattern p of length n over the source text s until the
 *              search pattern is aligned with matching text or until
 *              the end of the source text is reached.
 *
 *              At any point when we find a mismatch, we know
 *              we will shift our pattern to the right in the
 *              source text at least one position.  Thus,
 *              whenever we find a mismatch, we know the character
 *              s[n] will figure in our next attempt to match.
 *
 *              For some character c, TD1[c] is the 1-based index
 *              from right to left of the first occurrence of c
 *              in p.  Put another way, it is the count of places
 *              to shift p to the right on s so that the rightmost
 *              c in p is aligned with s[n].  If p does not contain
 *              c, then TD1[c] = n + 1, meaning we shift p to align
 *              p[0] with s[n + 1] and try our next match there.
 *
 *              Computing TD1 for a single string is easy:
 *
 *                      memset(TD1, n + 1, sizeof TD1);
 *                      for (i = 0; i < n; ++i) {
 *                          TD1[p[i]] = n - i;
 *                      }
 *
 *              Generalizing this computation to a case where there
 *              are multiple strings of differing lengths is trickier.
 *              The key is to generate a TD1 that is as conservative
 *              as necessary, meaning that no shift value can be larger
 *              than one plus the length of the shortest string for
 *              which you are looking.  The other key is to realize
 *              that you must treat each string as though it were only
 *              as long as the shortest string.  This is best illustrated
 *              with an example.  Consider the following two strings:
 *
 *              DYNAMIC PROCEDURE
 *              7654321 927614321
 *
 *              The numbers under each letter indicate the values of the
 *              TD1 entries if we computed the array for each string
 *              separately.  Taking the union of these two sets, and taking
 *              the smallest value where there are conflicts would yield
 *              the following TD1:
 *
 *              DYNAMICPODURE
 *              7654321974321
 *
 *              Note that TD1['P'] equals 9; since n, the length of our
 *              shortest string is 7, we know we should not have any
 *              shift value larger than 8.  If we clamp our shift values
 *              to this value, then we get
 *
 *              DYNAMICPODURE
 *              7654321874321
 *
 *              Already, this looks fishy, but let's try it out on
 *              s = "DYNAMPROCEDURE".  We know we should match on
 *              the trailing procedure, but watch:
 *
 *              DYNAMPROCEDURE
 *              ^^^^^^^|
 *
 *              Since DYNAMPR doesn't match one of our search strings,
 *              we look at TD1[s[n]] == TD1['O'] == 7.  Applying this
 *              shift, we get
 *
 *              DYNAMPROCEDURE
 *                     ^^^^^^^
 *
 *              As you can see, by shifting 7, we have gone too far, and
 *              we miss our match.  When computing TD1 for "PROCEDURE",
 *              we must take only the first 7 characters, "PROCEDU".
 *              Any trailing characters can be ignored (!) since they
 *              have no effect on matching the first 7 characters of
 *              the string.  Our modified TD1 then becomes
 *
 *              DYNAMICPODURE
 *              7654321752163
 *
 *              When applied to s, we get TD1[s[n]] == TD1['O'] == 5,
 *              leaving us with
 *
 *              DYNAMPROCEDURE
 *                   ^^^^^^^
 *              which is just where we need to be to match on "PROCEDURE".
 *
 *      Going to this algorithm has speeded qgrep up on multi-string
 *      searches from 20-30%.  The all-C version with this algorithm
 *      became as fast or faster than the C+ASM version of the old
 *      algorithm.  Thank you, Daniel Sunday, for your inspiration!
 *
 *      Note: if we are case-insensitive, then we expect the input
 *      string to be upper-cased on entry to this routine.
 *
 *      Pete Stewart, August 14, 1990.
 */

void
maketd1(
    unsigned char *pch,
    unsigned cch,
    unsigned cchstart
    )
{
    unsigned ch, ch1;                   // Character
    unsigned i;                         // String index
    unsigned char   s[2];

    s[1] = 0;
    if ((cch += cchstart) > cchmin)
        cch = cchmin;                   // Use smaller count
    for (i = cchstart; i < cch; ++i) {  // Examine each char left to right
        ch = *pch++;                    // Get the character
        for (;;) {                      // Loop to set up entries
            if (ch < chmin)
                chmin = ch;             // Remember if smallest
            if (ch > chmax)
                chmax = ch;             // Remember if largest
            if (cchmin - i < (unsigned) td1[ch])
                td1[ch] = (unsigned char)(cchmin - i);
                                        // Set value if smaller than previous
            if (casesen || !isalpha(ch) || islower(ch))
                break;                  // Exit loop if done
            ch1 = ch;
            s[0] = (char)ch;
            ch = (unsigned char)(_strlwr((char*)s))[0];       // Force to lower case
            if (ch1 == s[0])             // Lower case is the same to previous.
                break;                   // Exit loop if done
        }
    }
}

static int
newstring(
    unsigned char *s,
    int n
    )
{
    register STRINGNODE *cur;           // Current string
    register STRINGNODE **pprev;        // Pointer to previous link
    STRINGNODE          *newNode;       // New string
    int                 i;              // Index
    int                 j;              // Count
    int                 k;              // Count
    unsigned char       c[2];

    c[1] = 0;

    if ( (unsigned)n < cchmin)
        cchmin = n;                     // Remember length of shortest string

    if ((i = (UCHAR)transtab[*s]) == 0) {       // If no existing list

        //  We have to start a new list

        if ((i = clists++) >= TRTABLEN/2)
            error(MSG_FINDSTR_TOO_MANY_STRING_LISTS);       //"Too many string lists");
                                        // Die if too many string lists
        stringlist[i] = NULL;           // Initialize
        transtab[*s] = (char) i;        // Set pointer to new list
        if (!casesen && isalpha(*s)) {
            c[0] = *s;
            if ((unsigned char)(_strlwr((char*)c))[0] != *s ||
                (unsigned char)(_strupr((char*)c))[0] != *s)
                transtab[c[0]] = (char) i;   // Set pointer for other case
        }
    }
    else
        if (stringlist[i] == NULL)
            return(0);                  // Check for existing 1-byte string
    if (--n == 0) {                      // If 1-byte string
        freenode(stringlist[i]);        // Free any existing stuff
        stringlist[i] = NULL;           // No record here
        ++strcnt;                       // We have a new string
        return(1);                      // String added
    }
    ++s;                                // Skip first char
    pprev = stringlist + i;             // Get pointer to link
    cur = *pprev;                       // Get pointer to node
    while(cur != NULL) {                // Loop to traverse match tree
        i = (n > cur->s_must)? cur->s_must: n;
                                        // Find minimum of string lengths
        matchstrings((char *)s, s_text(cur), i, &j, &k);
                                        // Compare the strings
        if (j == 0) {                    // If complete mismatch
            if (k < 0)
                break;                  // Break if insertion point found
            pprev = &(cur->s_alt);      // Get pointer to alternate link
            cur = *pprev;               // Follow the link
        } else if (i == j) {             // Else if strings matched
            if (i == n) {                // If new is prefix of current
                cur = *pprev = reallocnode(cur, s_text(cur), n);
                                        // Shorten text of node
                if (cur->s_suf != NULL) { // If there are suffixes
                    freenode(cur->s_suf);
                                        // Suffixes no longer needed
                    cur->s_suf = NULL;
                    ++strcnt;           // Account for this string
                }
                return(1);              // String added
            }
            pprev = &(cur->s_suf);      // Get pointer to suffix link
            if ((cur = *pprev) == NULL) return(0);
                                        // Done if current is prefix of new
            s += i;                     // Skip matched portion
            n -= i;
        } else {                        // Else partial match

            //  We must split an existing node.
            //  This is the trickiest case.

            newNode = newnode(s_text(cur) + j, cur->s_must - j);
                                        // Unmatched part of current string
            cur = *pprev = reallocnode(cur, s_text(cur), j);
                                        // Set length to matched portion
            newNode->s_suf = cur->s_suf;    // Current string's suffixes
            if (k < 0) {                 // If new preceded current
                cur->s_suf = newnode((char *)s + j, n - j);
                                        // FIrst suffix is new string
                cur->s_suf->s_alt = newNode;// Alternate is part of current
            } else {                    // Else new followed current
                newNode->s_alt = newnode((char *)(s + j), n - j);
                                        // Unmatched new string is alternate
                cur->s_suf = newNode;   // New suffix list
            }
            ++strcnt;                   // One more string
            return(1);                  // String added
        }
    }
    *pprev = newnode((char *)s, n);     // Set pointer to new node
    (*pprev)->s_alt = cur;              // Attach alternates
    ++strcnt;                           // One more string
    return(1);                          // String added
}


void
addstring(
    char *s,
    int n
    )
{
    int                 endline;        // Match-at-end-of-line flag
    register char       *pch;           // Char pointer

    endline = flags & ENDLINE;          // Initialize flag
    pch = target;                       // Initialize pointer
    while(n-- > 0) {                    // While not at end of string
        switch(*pch = *s++) {           // Switch on character
            case '\\':                  // Escape
                if (n > 0 && !isalnum(*s)) {     // If next character "special"
                    --n;                // Decrement counter
                    *pch = *s++;        // Copy next character
                }
                ++pch;                  // Increment pointer
                break;

            default:                    // All others
                if (IsDBCSLeadByte(*pch)) {
                    --n;
                    ++pch;              // Increment pointer
                    *pch = *s++;
                }
                ++pch;                  // Increment pointer
                break;
        }
    }
    if (endline)
        *pch++ = EOS;                   // Add end character if needed
    targetlen = (int)(pch - target);    // Compute target string length
    if (!casesen)
        strnupr(target, targetlen);      // Force to upper case if necessary
    newstring((unsigned char *)target, targetlen);  // Add string
  }


int
addstrings(
    char *buffer,
    char *bufend,
    char *seplist
    )
{
    int     len;        // String length
    char    tmpbuf[MAXSTRLEN+2];

    while(buffer < bufend) {            // While buffer not empty
        len = strnspn(buffer, seplist, (int)(bufend - buffer));
                                        // Count leading separators
        if ((buffer += len) >= bufend) {
            break;                      // Skip leading separators
        }
        len = strncspn(buffer, seplist, (int)(bufend - buffer));
                                        // Get length of search string
			
		// 
		// We need to verify the length of the string before we call
		// isexpr since the size of the buffer used is BUFLEN = 256
		//
        if (len >= MAXSTRLEN)
            error(MSG_FINDSTR_SEARCH_STRING_TOO_LONG);

        if (addstr == NULL) {
            addstr = isexpr( (unsigned char *) buffer, len ) ? addexpr : addstring;
                                        // Select search string type
        }

        memcpy(tmpbuf, buffer, len);
        tmpbuf[len] = '\n';
        tmpbuf[len+1] = 0;

        if ( addstr == addexpr || (flags & BEGLINE) ||
            findlist((unsigned char *)tmpbuf, tmpbuf + len + 1) == NULL) {
            // If no match within string
            (*addstr)(buffer, len);      // Add string to list
        }

        buffer += len;                  // Skip the string
    }
    return(0);                          // Keep looking
}


int
enumlist(
    STRINGNODE *node,
    int cchprev
    )
{
    int                 strcnt;         // String count

    strcnt = 0;                         // Initialize
    while(node != NULL) {               // While not at end of list
        maketd1((unsigned char *)s_text(node), node->s_must, cchprev);
                    // Make TD1 entries

#if DBG
        if (flags & DEBUG) {            // If verbose output wanted
            int  i;      // Counter


            for(i = 0; i < cchprev; ++i)
                fputc(' ', stderr);     // Indent line
            fwrite(s_text(node), sizeof(char), node->s_must, stderr);
                                        // Write this portion
            fprintf(stderr, "\n");       // Newline
        }
#endif

        strcnt += (node->s_suf != NULL) ?
          enumlist(node->s_suf, cchprev + node->s_must): 1;
                                        // Recurse to do suffixes
        node = node->s_alt;             // Do next alternate in list
    }
    return (strcnt ? strcnt: 1);          // Return string count
}

int
enumstrings()
{
    unsigned char       ch;             // Character
    unsigned            i;              // Index
    int                 strcnt;         // String count

    strcnt = 0;                         // Initialize
    for(i = 0; i < TRTABLEN; ++i) {     // Loop through translation table
        if (casesen || !isalpha(i) || !islower(i)) {
                                        // If case sensitive or not lower
            if (transtab[i] == 0)
                continue;               // Skip null entries
            ch = (char) i;              // Get character
            maketd1((unsigned char *)&ch, 1, 0);    // Make TD1 entry

#if DBG
            if (flags & DEBUG)
                fprintf(stderr, "%c\n", i);   // Print the first byte
#endif

            strcnt += enumlist(stringlist[transtab[i]], 1);
                                        // Enumerate the list
        }
    }
    return (strcnt);                     // Return string count
}


HANDLE
openfile(
    char *name
    )
{
    HANDLE  fd;
    DWORD   attr;

    attr = GetFileAttributes(name);

    if (attr != (DWORD) -1 && (attr & FILE_ATTRIBUTE_DIRECTORY))
        return (HANDLE)-1;

    // Skip offline files unless instructed otherwise
    if (attr != (DWORD) -1 && (attr & FILE_ATTRIBUTE_OFFLINE) && !(flags & OFFLINE_FILES)) {
        fOfflineSkipped = TRUE;
        return (HANDLE)-1;
    }

    if ((fd = CreateFile(name,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OPEN_NO_RECALL,
                        NULL)) == (HANDLE)-1) {

        printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program, name);
    }
    return( fd );                       // Return file descriptor
}



void
startread(
    HANDLE fd,
    char *buffer,
    int buflen
    )
{
    if (bStdIn || bLargeFile) {
        arrc = ReadFile(fd,(PVOID)buffer, buflen, &cbread, NULL);
    }
}



int
finishread()
{
    return(arrc ? cbread : -1); // Return number of bytes read
}



void
startwrite( HANDLE fd, char *buffer, int buflen)
{
    awrc = WriteFile(fd,(PVOID)buffer, buflen, &cbwrite, NULL);
    return;
}


int
finishwrite()
{
    return(awrc ? cbwrite : -1);    // Return number of bytes written
}

BOOL
CtrlHandler(DWORD CtrlType)
{
    // We'll handle Ctrl-C events
    switch(CtrlType) {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            if (csbi.wAttributes) {
                EnterCriticalSection(&critSection);
                fExiting = TRUE;
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),
                    csbi.wAttributes);
                LeaveCriticalSection(&critSection);
            }
            break;
    }

    // Deal with all other events as normal
    return (FALSE);
}

void
write1nobuf(
    char *buffer,
    int buflen,
    WORD wAttributes
    )
{
    int                 nT;
    CBIO                cb;             // Count of bytes written
    BOOL                fCR;
    BOOL                fLF;
    char                buf[STKLEN];
    char                *szT;
    static HANDLE       hConOut = INVALID_HANDLE_VALUE;
    int                 remaining_length;

    // Get the console screen buffer info if we haven't yet.
    if (hConOut == INVALID_HANDLE_VALUE) {
        hConOut = GetStdHandle(STD_OUTPUT_HANDLE);
        InitializeCriticalSection(&critSection);
        SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE);
    }

    if (wAttributes) {
        EnterCriticalSection(&critSection);
        // if not exiting, highlight the output
        if (!fExiting)
            SetConsoleTextAttribute(hConOut, wAttributes);
        LeaveCriticalSection(&critSection);
        if (fExiting)
            ExitProcess(2);
    }

    remaining_length = buflen;

    while (remaining_length) {

        buflen = (int)min(sizeof(buf) / sizeof(buf[0]), remaining_length);
        szT = buf;

        if (IsDBCSCodePage) {
            memcpy(buf, buffer, buflen);
        } else {
            for(nT = 0; nT < buflen; nT++) {
                *(szT++) = ((isprint((unsigned char)buffer[nT]) ||
                             isspace((unsigned char)buffer[nT])) ?
                             buffer[nT] : '.');
            }
        }

        if (!WriteFile(hConOut, (PVOID)buf, buflen, &cb, NULL)
            || (cb != (CBIO)(buflen)))
        {
            SetConsoleTextAttribute(hConOut, csbi.wAttributes);
            error(MSG_FINDSTR_WRITE_ERROR); // Die if write fails
        }
        remaining_length -= buflen;
        buffer += buflen;
    }

    if (wAttributes)
        SetConsoleTextAttribute(hConOut, csbi.wAttributes);
}


void
write1buf(
    char *buffer,
    int buflen,
    WORD wAttributes
    )
{
    register int        cb;             // Byte count

    while(buflen > 0) {                 // While bytes remain
        if (!awrc) {                     // If previous write failed
            printmessage(stderr, MSG_FINDSTR_WRITE_ERROR, program);  // Print error message
            exit(2);                    // Die
        }
        if ((cb = ocnt[oi]) == 0) {      // If buffer full
            startwrite( GetStdHandle( STD_OUTPUT_HANDLE ), obuf[oi], OUTBUFLEN );
                                        // Write the buffer
            ocnt[oi] = OUTBUFLEN;       // Reset count and pointer
            optr[oi] = obuf[oi];
            oi ^= 1;                    // Switch buffers
            cb = ocnt[oi];              // Get space remaining
          }
        if (cb > buflen)
            cb = buflen;                // Get minimum
        memmove(optr[oi], buffer, cb);    // Copy bytes to buffer
        ocnt[oi] -= cb;                 // Update buffer length and pointers
        optr[oi] += cb;
        buflen -= cb;
        buffer += cb;
    }
}


void
flush1nobuf(
    void
    )
{
    ;
}


void
flush1buf(
    void
    )
{
    register int        cb;             // Byte count

    if ((cb = OUTBUFLEN - ocnt[oi]) > 0) { // If buffer not empty
        startwrite( GetStdHandle( STD_OUTPUT_HANDLE ), obuf[oi], cb );  // Start write
        if (finishwrite() != cb) {       // If write failed
            printmessage(stderr, MSG_FINDSTR_WRITE_ERROR, program);     // Print error message
            exit(2);                    // Die
        }
    }
}


int
grepbuffer(
    char *startbuf,
    char *endbuf,
    char *name
    )
{
    char  *cp;                          // Buffer pointer
    char  *lastmatch;                   // Last matching line
    int   linelen;                      // Line length
    int   namlen = 0;                   // Length of name
    char  lnobuf[LNOLEN];               // Line number buffer
    char  nambuf[PATHLEN];              // Name buffer

    cp = startbuf;                      // Initialize to start of buffer
    lastmatch = cp;                     // No previous match yet
    while((cp = (*find)((unsigned char *)cp, endbuf)) != NULL) {
                                        // While matches are found
        --cp;                           // Back up to previous character

        // Take care of '\n' as an artificial newline before line 1.
        if ((flags & BEGLINE) && (bStdIn || bLargeFile || cp >= BaseByteAddress) && *cp != '\n' ) {
            // If begin line conditions not met
            cp += strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Skip line
            continue;                   // Keep looking
        }
        status = 0;                     // Match found
        if (flags & NAMEONLY)
            return(1);                  // Return if filename only wanted
        cp -= preveol(cp) - 1;          // Point at start of line
        if (flags & SHOWNAME) {          // If name wanted
            if (namlen == 0) {           // If name not formatted yet
                namlen = sprintf(nambuf, "%s:", name);
                                        // Format name if not done already
            }
            (*write1)(nambuf, namlen, wAttrib);   // Show name
        }
        if (flags & LINENOS) {           // If line number wanted
            lineno += countlines(lastmatch, cp);
                                        // Count lines since last match
            (*write1)(lnobuf, sprintf(lnobuf, "%u:", lineno), wAttrib);
                                        // Print line number
            lastmatch = cp;             // New last match
        }
        if (flags & SEEKOFF) {           // If seek offset wanted
            (*write1)(lnobuf, sprintf(lnobuf, "%lu:",
                      cbfile + (long)(cp - startbuf)), wAttrib);
                                        // Print seek offset
        }
        linelen = strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Calculate line length
        if (linelen > endbuf - cp) {
            linelen = (int)(endbuf - cp);
        }
        (*write1)(cp, linelen, 0);      // Print the line
        cp += linelen;                  // Skip the line
    }
    lineno += countlines(lastmatch, endbuf);
                                        // Count remaining lines in buffer
    return(0);                          // Keep searching
}


void
showv(
    char *name,
    char *startbuf,
    char *lastmatch,
    char *thismatch
    )
{
    register int        linelen;
    int                 namlen = 0;     // Length of name
    char                lnobuf[LNOLEN]; // Line number buffer
    char                nambuf[PATHLEN];// Name buffer

    if (flags & (SHOWNAME | LINENOS | SEEKOFF)) {
        while(lastmatch < thismatch) {
            if (flags & SHOWNAME) {      // If name wanted
                if (namlen == 0) {       // If name not formatted yet
                    namlen = sprintf(nambuf, "%s:", name);
                                        // Format name if not done already
                }
                (*write1)(nambuf, namlen, wAttrib);
                                        // Write the name
            }
            if (flags & LINENOS)         // If line numbers wanted
              {
                (*write1)(lnobuf, sprintf(lnobuf, "%u:", lineno++), wAttrib);
                                        // Print the line number
            }
            if (flags & SEEKOFF) {       // If seek offsets wanted
                (*write1)(lnobuf, sprintf(lnobuf, "%lu:",
                          cbfile + (long)(lastmatch - startbuf)), wAttrib);
                                        // Print the line number
            }
            linelen = strncspn(lastmatch, "\n", (int)(thismatch - lastmatch));
            // If there's room for the '\n' then pull it in.  Otherwise
            // the buffer doesn't have a '\n' within the range here.
            if (linelen < thismatch - lastmatch) {
                linelen++;
            }
            (*write1)(lastmatch, linelen, 0);
            lastmatch += linelen;
        }
    }
    else
        (*write1)(lastmatch, (int)(thismatch - lastmatch), 0);
}


int
grepvbuffer(
    char *startbuf,
    char *endbuf,
    char *name
    )
{
    char   *cp;                         // Buffer pointer
    char   *lastmatch;                  // Pointer to line after last match

    cp = startbuf;                      // Initialize to start of buffer
    lastmatch = cp;
    while((cp = (*find)((unsigned char *)cp, endbuf)) != NULL) {
        --cp;               // Back up to previous character

        // Take care of '\n' as an artificial newline before line 1.
        if ((flags & BEGLINE) && (bStdIn || bLargeFile || cp >= BaseByteAddress) &&  *cp != '\n') {
            // If begin line conditions not met
            cp += strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Skip line
            continue;                   // Keep looking
        }
        cp -= preveol(cp) - 1;          // Point at start of line
        if (cp > lastmatch) {            // If we have lines without matches
            status = 0;                 // Lines without matches found
            if (flags & NAMEONLY) return(1);
                                        // Skip rest of file if NAMEONLY
            showv(name, startbuf, lastmatch, cp);
                                        // Show from last match to this
        }
        cp += strncspn(cp, "\n", (int)(endbuf - cp)) + 1;
                                        // Skip over line with match
        lastmatch = cp;                 // New "last" match
        ++lineno;                       // Increment line count
    }
    if (endbuf > lastmatch) {            // If we have lines without matches
        status = 0;                     // Lines without matches found
        if (flags & NAMEONLY)
            return(1);                  // Skip rest of file if NAMEONLY
        showv(name, startbuf, lastmatch, endbuf);
                                        // Show buffer tail
    }
    return(0);                          // Keep searching file
}


void
qgrep(
    int (*grep)( char *, char *, char * ),
    char *name,
    HANDLE fd
    )
{
    register int  cb;       // Byte count
    char     *cp;           // Buffer pointer
    char     *endbuf;       // End of buffer
    int      taillen;       // Length of buffer tail
    int      bufi;          // Buffer index
    HANDLE   MapHandle;     // File mapping handle
    BOOL     grep_result;

    cbfile = 0L;            // File empty so far
    lineno = 1;             // File starts on line 1
    taillen = 0;            // No buffer tail yet
    bufi = 0;               // Initialize buffer index
    cp = bufptr[0];         // Initialize to start of buffer

    bStdIn = (fd == GetStdHandle(STD_INPUT_HANDLE));

    // If fd is not std-input, use file mapping object method.

    if (!bStdIn) {
        DWORD   cbread_high;

        if ((((cbread = (CBIO)GetFileSize(fd, &cbread_high)) == -1) && (GetLastError() != NO_ERROR)) ||
            (cbread == 0 && cbread_high == 0)) {
            return; // skip the file
        }

        if (cbread_high) {
            bLargeFile = TRUE;  // too large to map and even if it succeed in mapping like under ia64, it
                                // will probably fail in pointer arithmetics
        } else {
            MapHandle = CreateFileMapping(fd,
                                          NULL,
                                          PAGE_READONLY,
                                          0L,
                                          0L,
                                          NULL);
            if (MapHandle == NULL) {
                printmessage(stderr, MSG_FINDSTR_CANNOT_CREATE_FILE_MAPPING, program);
                return;
            }

            BaseByteAddress = (char *) MapViewOfFile(MapHandle,
                                                     FILE_MAP_READ,
                                                     0L,
                                                     0L,
                                                     0);
            CloseHandle(MapHandle);
            if (BaseByteAddress == NULL) {
                bLargeFile = TRUE;   // use alternate method
            } else {
                cp = bufptr[0] = BaseByteAddress;
                arrc = TRUE;
            }
        }

    }

    if (bStdIn || bLargeFile) {
        // Reset buffer pointers since they might have been changed.
        cp = bufptr[0] = filbuf + 4;

        arrc = ReadFile(fd, (PVOID)cp, FILBUFLEN, &cbread, NULL);
    }

    if (flags & PRINTABLE_ONLY) {
        unsigned char *s;
        unsigned long n;

        s = (unsigned char *)cp;
        n = cbread;
        while (--n) {
            if (*s < ' ') {

                // If not backspace, tab, CR, LF, FF or Ctrl-Z then not a printable character.

                if (strchr("\b\t\v\r\n\f\032", *s) == NULL) {
                    goto skipfile;
                }
            }

            s += 1;
        }
    }

    // Note: if FILEMAP && !bStdIn, 'while' is executed once(taillen is 0).
    while((cb = finishread()) + taillen > 0) {
        // While search incomplete

        if (bStdIn || bLargeFile) {
            if (cb == -1) {       // If buffer tail is all that's left
                *cp++ = '\r';   // Add end of line sequence
                *cp++ = '\n';
                endbuf = cp;    // Note end of buffer
                taillen = 0;    // Set tail length to zero

            } else {            // Else start next read

                taillen = preveol(cp + cb - 1); // Find length of partial line
                endbuf = cp + cb - taillen;     // Get pointer to end of buffer
                cp = bufptr[bufi ^ 1];          // Pointer to other buffer
                memmove(cp, endbuf, taillen);   // Copy tail to head of other buffer
                cp += taillen;                  // Skip over tail
                if (taillen > (FILBUFLEN/2)) {
                    if (taillen >= FILBUFLEN) {

                        char    tmp[15];

                        cbfile += taillen;
                        taillen = 0;
                        cp = bufptr[bufi^1];
                        startread(fd, cp, FILBUFLEN);
                        _ultoa((unsigned long)lineno, tmp, 10);
                        printmessage(stderr, MSG_FINDSTR_LINE_TOO_LONG, program, tmp);
                    } else
                        startread(fd, cp, (FILBUFLEN - taillen));
                } else
                    startread(fd, cp, (FILBUFLEN - taillen) & (~0 << LG2SECLEN));
                                            // Start next read
            }
        } else {
            endbuf = cp + cb - taillen; // Get pointer to end of buffer

            // Cause 'while' to terminate(since no next read is needed.)
            cbread = 0;
            arrc = TRUE;
        }

        __try {
            grep_result = (*grep)(bufptr[bufi], endbuf, name);
        } __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            printmessage(stderr, MSG_FINDSTR_READ_ERROR, program, name);
            break;
        }

        if (grep_result) {               // If rest of file can be skipped
            (*write1)(name, strlen(name), 0);
                                        // Write file name
            (*write1)("\r\n", 2, 0);      // Write newline sequence

            if (!bStdIn  && !bLargeFile) {
                if (BaseByteAddress != NULL)
                    UnmapViewOfFile(BaseByteAddress);
            }

            return;                     // Skip rest of file
        }

        cbfile += (long)(endbuf - bufptr[bufi]);
                                        // Increment count of bytes in file
        bufi ^= 1;                      // Switch buffers
    }

skipfile:
    if (!bStdIn && !bLargeFile) {
        if (BaseByteAddress != NULL)
            UnmapViewOfFile(BaseByteAddress);
    }
}


char *
rmpath(
    char *name
    )
{
    char                *cp;            // Char pointer

    if (name[0] != '\0' && name[1] == ':')
        name += 2;                      // Skip drive spec if any
    cp = name;                          // Point to start
    while(*name != '\0') {              // While not at end
        ++name;                         // Skip to next character
        if (name[-1] == '/' || name[-1] == '\\') cp = name;
                                        // Point past path separator
    }
    return(cp);                         // Return pointer to name
}


void
prepend_path(
    char* file_name,
    char* path
    )
{
    int path_len;
    char* last;

    // First figure out how much of the path to take.
    // Check for the last occurance of '\' if there is one.

#ifdef FE_SB
    // DBCS tailbytes can contain '\' character.  Use MBCS function.
    last = _mbsrchr(path, '\\');
#else
    last = strrchr(path, '\\');
#endif

    if (last) {
        path_len = (int)(last - path) + 1;
    } else if (path[1] == ':') {
        path_len = 2;
    } else {
        path_len = 0;
    }

    memmove(file_name + path_len, file_name, strlen(file_name) + 1);
    memmove(file_name, path, path_len);
}


void
ConvertAppToOem(
    unsigned argc,
    char* argv[]
    )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for( i=0; i<argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}


int __cdecl
main(
    int argc,
    char **argv
    )
{
    char           *cp;
    char           *cpaddstrings[MAX_SLASH_C_OPTION];
    int             add_string_count = 0;
    char           *dirlist = NULL;

    HANDLE          fd;

    FILE           *fi;
    int             fsubdirs;           // Search subdirectories
    int             i;
    int             j;
    char           *inpfile = NULL;
    char           *strfile = NULL;
    unsigned long   tstart;             // Start time
    char            filnam[MAX_PATH+1];
    WIN32_FIND_DATA find_data;
    HANDLE          find_handle;
#ifdef FE_SB
    LANGID          LangId;
#endif
    char            *locale;
    BOOLEAN         option_L_specified = FALSE;
    BOOLEAN         option_R_specified = FALSE;

    ConvertAppToOem( argc, argv );
    tstart = clock();                   // Get start time

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    // Default color: just add intensity
    wAttrib = csbi.wAttributes | FOREGROUND_INTENSITY;

    memset(cpaddstrings, 0, sizeof(cpaddstrings));

#ifdef FE_SB
    //
    // Set TEB's language ID to correspond to the console output code page.  This
    // will ensure the correct language message is displayed when FormatMessage is
    // called.
    //

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            IsDBCSCodePage = FALSE;
            break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );

    if ((locale = setlocale(LC_ALL, ".OCP")) == NULL) {

        UINT Codepage;

        if (Codepage = GetConsoleOutputCP()) {

            char achCodepage[10];

            wsprintfA(achCodepage, ".%3.4d", Codepage);
            if ((locale = setlocale(LC_ALL, achCodepage)) == NULL) {
                error(MSG_FINDSTR_UNABLE_TO_SET_LOCALE);
            }
        } else
            error(MSG_FINDSTR_UNABLE_TO_SET_LOCALE);
    }
#endif

    asyncio = pmode = 1;                // Do asynchronous I/O

    // program = rmpath(argv[0]);       // Set program name
    program ="FINDSTR";

    memset(td1, 1, TRTABLEN);           // Set up TD1 for startup
    flags = 0;

    _setmode(_fileno(stdout), O_BINARY); // No linefeed translation on output
    _setmode(_fileno(stderr), O_BINARY); // No linefeed translation on output

    fsubdirs = 0;

    for(i = 1; i < argc && (argv[i][0] == '/' || argv[i][0] == '-'); ++i)
    {
        for(cp = &argv[i][1]; *cp != '\0'; ++cp)
        {
            switch(*cp)
            {
                case '?':
                    printmessage(stdout, MSG_FINDSTR_USAGE, NULL); // Verbose usage message
                    exit(0);

                case 'b':
                case 'B':
                    flags |= BEGLINE;
                    break;

                case 'e':
                case 'E':
                    flags |= ENDLINE;
                    break;

                case 'i':
                case 'I':
                    casesen = 0; // case-insensitive search
                    break;

                case 'l':
                case 'L':
                    addstr = addstring;   // Treat strings literally
                    option_L_specified = TRUE;
                    break;

                case 'm':
                case 'M':
                    flags |= NAMEONLY;
                    break;

                case 'n':
                case 'N':
                    flags |= LINENOS;
                    break;

                case 'o':
                case 'O':
                    // Check whether this is an /o or /offline switch
                    if (0 == _stricmp(cp, "OFFLINE")) {
                        flags |= OFFLINE_FILES;
                        cp += (lstrlen( "OFFLINE" ) - 1);
                    } else if (0 == _stricmp(cp, "OFF")) {
                        flags |= OFFLINE_FILES;
                        cp += (lstrlen( "OFF" ) - 1);
                    } else {
                        flags |= SEEKOFF;
                    }
                    break;

                case 'p':
                case 'P':
                    flags |= PRINTABLE_ONLY;
                    break;

                case 'r':
                case 'R':
                    addstr = addexpr;     // Add expression to list
                    option_R_specified = TRUE;
                    break;

                case 's':
                case 'S':
                    fsubdirs = 1;
                    break;

                case 'v':
                case 'V':
                    grep = grepvbuffer;
                    break;

                case 'x':
                case 'X':
                    flags |= BEGLINE | ENDLINE;
                    break;

#if DBG
                case 'd':
                    // This is kinda cheezy, but I didn't want to change the
                    // debug flag as it's been here a while and I couldn't come
                    // up with a different flag for the dirlist, so...
                    if (*(cp + 1) == ':')
                    {
                        *cp-- = 'D';
                        break;
                    }
                    flags |= DEBUG;
                    break;

                case 't':
                    flags |= TIMER;
                    break;
#endif

                default:
                {
                    int     cch;
                    char    chSwitch;
                    char    tmp[3];

                    chSwitch = *cp;

                    if (*(cp + 1) == ':')
                    {
                        if (!*(cp + 2))
                        {
                            tmp[0]=chSwitch;
                            tmp[1]='\0';
                            printmessage(stderr, MSG_FINDSTR_ARGUMENT_MISSING, program, tmp);
                            exit(2);
                        }

                        cp += 2;       // Point to string
                        cch = lstrlen(cp);
                        switch(chSwitch)
                        {
                            case 'd':
                            case 'D':
                                dirlist = cp;
                                cp += cch - 1;
                                continue;

                            case 'c':
                            case 'C':
                                // Add it after we've gone through all the flags
                                //   don't add it now as things may change with
                                //   later flags
                                addstr = addstring; // Treat strings literally
                                if (add_string_count >= MAX_SLASH_C_OPTION) {
                                    error(MSG_FINDSTR_TOO_MANY_SLASH_C_OPTION);
                                }
                                cpaddstrings[add_string_count++] = cp;
                                cp += cch - 1;
                                continue;

                            case 'g':
                            case 'G':       // Patterns in file
                            case 'f':
                            case 'F':       // Names of files to search in file
                                if (chSwitch == 'f' || chSwitch == 'F')
                                    inpfile = cp;
                                else
                                    strfile = cp;
                                cp += cch - 1;
                                continue;

                            case 'a':
                            case 'A':
                                wAttrib = 0;
                                for(; *cp && isxdigit(*cp); ++cp) {

                                    int digit = (int) (*cp <= TEXT('9'))
                                        ? (int)*cp - (int)'0'
                                        : (int)tolower(*cp)-(int)'W';

                                    wAttrib = (wAttrib << 4) + digit;
                                }
                                cp--;
                                continue;

                            default:
                                cp += cch - 1;
                                // break out and spit out the switch ignored msg
                                break;
                        }
                    }

                    tmp[0]='/';
                    tmp[1]=chSwitch;
                    tmp[2]='\0';
                    printmessage(stderr, MSG_FINDSTR_SWITCH_IGNORED, program, tmp);
                    break;
                }
            }
        }
    } // for( i=1;  )

    if (option_L_specified && option_R_specified)
        error(MSG_FINDSTR_CONFLICTING_OPTIONS_LR);
    else if (option_L_specified)
        addstr = addstring;
    else if (option_R_specified)
        addstr = addexpr;

    // Explicit string (no separators). Add string "as is"
    if (add_string_count) {
        for (j=0; j<add_string_count && cpaddstrings[j]; j++)
            addstrings( cpaddstrings[j], cpaddstrings[j] + lstrlen(cpaddstrings[j]), "" );
    }

    if (i == argc && strcnt == 0 && strfile == NULL)
        error(MSG_FINDSTR_BAD_COMMAND_LINE);

    bufptr[0][-1] = bufptr[1][-1] = '\n';   // Mark beginnings with newline

// Note:  4-Dec-90 w-barry  Since there currently exists no method to query a
//                          handle with the Win32 api (no equivalent to
//                          DosQueryHType() ), the following piece of code
//                          replaces the commented section.

    if (_isatty(_fileno(stdout))) {       // If stdout is a device
        write1 = write1nobuf;           // Use unbuffered output
        flush1 = flush1nobuf;
    }

//    /*
//     *  Check type of handle for std. out.
//     */
//    if (DosQueryHType(fileno(stdout),(PPARM) &j,(PPARM) &fd) != NO_ERROR)
//      {
//        error("Standard output bad handle");
//      }
//                                      // Die if error
//    if (j != 0 && (fd & ISCOT))        // If handle is console output
//#else
//    filbuf[3] = '\n';                 // Mark beginning with newline
//    if (isatty(fileno(stdout)))        // If stdout is a device
//#endif
//      {
//      write1 = write1nobuf;           // Use unbuffered output
//      flush1 = flush1nobuf;
//      }


    if (strfile != NULL) {               // If strings from file
        if ((strcmp(strfile, "/") != 0) && (strcmp(strfile, "-") != 0)) {
            // If strings not from std. input

            if ( ( fd = CreateFile( strfile,
                                    GENERIC_READ,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL ) ) == (HANDLE)-1 )
            {             // If open fails
                printmessage(stderr, MSG_FINDSTR_CANNOT_READ_STRINGS, program, strfile);
                exit(2);                // Die
            }
        }else {
             fd = GetStdHandle( STD_INPUT_HANDLE );     // Else use std. input
        }
        qgrep( addstrings, "\r\n", fd );// Do the work
        if ( fd != GetStdHandle( STD_INPUT_HANDLE ) ) {
            CloseHandle( fd );          // Close strings file
        }
    } else if (strcnt == 0) {            // Else if strings on command line
        cp = argv[i++];                 // Set pointer to strings
        addstrings(cp, cp + strlen(cp), " \t");
                                        // Add strings to list
    }

    if (strcnt == 0)
        error(MSG_FINDSTR_NO_SEARCH_STRINGS);   // Die if no strings

    if (addstr != addexpr) {             // If not using expressions
        memset(td1, cchmin + 1, TRTABLEN);// Initialize table
        find = findlist;                // Assume finding many
        if ((j = enumstrings()) != strcnt) {

            char    t1[15], t2[15];

            _itoa(j, t1, 10);
            _itoa(strcnt, t2, 10);
            printmessage(stderr, MSG_FINDSTR_STRING_COUNT_ERROR, t1, t2);
        }

        // Enumerate strings and verify count

#if DBG
        if (flags & DEBUG) {             // If debugging output wanted
            fprintf(stderr, "%u bytes wasted in heap\n", waste);
                                        // Print storage waste
            assert(chmin <= chmax);     // Must have some entries
            fprintf(stderr, "chmin = %u, chmax = %u, cchmin = %u\n", chmin, chmax, cchmin);
                                        // Print range info
            for (j = (int)chmin; j <= (int)chmax; ++j) {
                // Loop to print TD1 table
                if ( td1[j] <= (char)cchmin ) {  // If not maximum shift
                    if (isascii(j) && isprint(j))
                        fprintf(stderr, "'%c'=%2u  ", j, td1[j]);      // Show literally if printable
                    else
                        fprintf(stderr, "\\%02x=%2u  ", j, td1[j]);    // Else show hex value
                }
            }
            fprintf(stderr, "\n");
        }
#endif

        if (strcnt == 1 && casesen)
            find = findone;             // Find one case-sensitive string
    } else if (find == NULL) {
        find = findexpr;                // Else find expressions
    }

    if (inpfile != NULL) {               // If file list from file
        flags |= SHOWNAME;              // Always show name of file
        if ((strcmp(inpfile, "/") != 0) && (strcmp(inpfile, "-") != 0)) {
            if ((fi = fopen(inpfile, "r")) == NULL) {
                // If open fails
                printmessage(stderr, MSG_FINDSTR_CANNOT_READ_FILE_LIST, program, inpfile);
                exit(2);                // Error exit
            }
        } else
            fi = stdin;                 // Else read file list from stdin

        while(fgets(filnam, MAX_PATH+1, fi) != NULL) {
            // While there are names
            filnam[strcspn(filnam, "\r\n")] = '\0';  // Null-terminate the name
            if ((fd = openfile(filnam)) == (HANDLE)-1) {
                continue;               // Skip file if it cannot be opened
            }
            qgrep(grep, filnam, fd);      // Do the work
            CloseHandle( fd );
        }

        if (fi != stdin)
            fclose(fi);                 // Close the list file
    } else if (i == argc) {
        flags &= ~(NAMEONLY | SHOWNAME);
        qgrep( grep, NULL, GetStdHandle( STD_INPUT_HANDLE ) );
    }

    if (argc > i + 1 || fsubdirs || has_wild_cards(argv[i]))
        flags |= SHOWNAME;


    if (dirlist && *dirlist) {
        char *dir;
        char *dirend = (char *)-1;
        char *original_current_directory = NULL;
        DWORD   size;

        size = GetCurrentDirectory(0, NULL);
        if (size) {
            original_current_directory = (PCHAR)malloc(size);
            if (original_current_directory == NULL) {
                printmessage(stderr, MSG_FINDSTR_OUT_OF_MEMORY, program);
                exit(2);
            }
            size = GetCurrentDirectory(size, original_current_directory);
        }

        if (!size) {
            free(original_current_directory);
            printmessage(stderr, MSG_FINDSTR_UNABLE_TO_GET_CURRENT_DIRECTORY, program);
            exit(2);
        }

        for(dir = dirlist; dirend; dir = dirend + 1) {

            if (dirend = strchr(dir, ';'))
                *dirend = 0;

            if (*dir) {
                (*write1)("  ", 2, wAttrib);      // Indent a couple of spaces
                (*write1)(dir, lstrlen(dir), wAttrib);   // Show name
                (*write1)(":\r\n", 3, wAttrib);      // Write newline sequence

                if (!SetCurrentDirectory(original_current_directory)) {
                    free(original_current_directory);
                    printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program,
                                 original_current_directory);
                    exit(2);
                }
                if (!SetCurrentDirectory(dir)) {
                    printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program, dir);
                } else {
                    while (filematch(filnam, argv + i, argc - i, fsubdirs) >= 0) {
#ifdef FE_SB
//                        _mbslwr((unsigned char *)filnam);
#else
//                        _strlwr(filnam);
#endif
                        if ((fd = openfile(filnam)) != (HANDLE)-1) {
                            qgrep(grep, filnam, fd);
                            CloseHandle( fd );
                        }
                    }
                }
            }
        }
        free(original_current_directory);
    }
    else if (fsubdirs && argc > i) {         // If directory search wanted
        while (filematch(filnam, argv + i, argc - i, fsubdirs) >= 0) {
#ifdef FE_SB
//            _mbslwr((unsigned char *)filnam);
#else
//            _strlwr(filnam);
#endif
            if ((fd = openfile(filnam)) == (HANDLE)-1) {
                continue;
            }

            qgrep(grep, filnam, fd);
            CloseHandle( fd );
        }
    } else {              // Else search files specified
        for(; i < argc; ++i) {
#ifdef FE_SB
//            _mbslwr((unsigned char *) argv[i]);
#else
//            _strlwr(argv[i]);
#endif
            find_handle = FindFirstFile(argv[i], &find_data);
            if (find_handle == INVALID_HANDLE_VALUE) {
                printmessage(stderr, MSG_FINDSTR_CANNOT_OPEN_FILE, program, argv[i]);
                continue;
            }

            do {

#ifdef FE_SB
//                _mbslwr((unsigned char *)find_data.cFileName);
#else
//                _strlwr(find_data.cFileName);
#endif
                prepend_path(find_data.cFileName, argv[i]);
                fd = openfile(find_data.cFileName);

                if (fd != INVALID_HANDLE_VALUE) {
                    qgrep(grep, find_data.cFileName, fd);
                    CloseHandle( fd );
                }
            } while (FindNextFile(find_handle, &find_data));
        }
    }

    (*flush1)();

#if DBG
    if ( flags & TIMER ) {               // If timing wanted
        unsigned long tend;

        tend = clock();
        tstart = tend - tstart;     // Get time in milliseconds
        fprintf(stderr, "%lu.%03lu seconds\n", ( tstart / CLK_TCK ), ( tstart % CLK_TCK ) );
                                        // Print total elapsed time
    }
#endif

    // Print warning in case that offline files were skipped
    if (fOfflineSkipped) {
        printmessage(stderr, MSG_FINDSTR_OFFLINE_FILE_SKIPPED, program);
    }

    return( status );
}  // main


char * findsub( unsigned char *, char * );
char * findsubi( unsigned char *, char * );

char * (*flworker[])(unsigned char *, char *) = {             // Table of workers
    findsubi,
    findsub
};


char *
strnupr(
    char *pch,
    int cch
    )
{
    char    c[2];

#ifdef FE_SB
    int     max = cch;
    c[1] = 0;
    for ( cch = 0; cch < max; cch++ )  {
#else
    c[1] = 0;
    while (cch-- > 0) {                 // Convert string to upper case
#endif
        if (isalpha((unsigned char)pch[cch])) {
            c[0] = pch[cch];
            pch[cch] = (_strupr(c))[0];
        }
#ifdef FE_SB
        else if (IsDBCSCodePage && IsDBCSLeadByte(pch[cch]))
            cch++;
#endif
    }
    return(pch);
}


/*
 *  This is an implementation of the QuickSearch algorith described
 *  by Daniel M. Sunday in the August 1990 issue of CACM.  The TD1
 *  table is computed before this routine is called.
 */

char *
findone(
    unsigned char *buffer,
    char *bufend
    )
{
#ifdef FE_SB // Starting position of string for checking 2nd bytes of DBCS characters.
    unsigned char *bufferhead = buffer;
#endif

    if ((bufend -= targetlen - 1) <= (char *) buffer)
        return((char *) 0);             // Fail if buffer too small

    while (buffer < (unsigned char *) bufend) {     // While space remains
        int cch;                        // Character count
        register char *pch1;            // Char pointer
        register char *pch2;            // Char pointer

        pch1 = target;                  // Point at pattern
        pch2 = (char *) buffer;         // Point at buffer

#ifdef FE_SB
        // If buffer points to the 2nd byte of a DBCS character,
        // skip to next compare position.
        if ( !IsTailByte( bufferhead, (int)(buffer - bufferhead) ) )  {
#endif
            for (cch = targetlen; cch > 0; --cch) {
                                            // Loop to try match
                if (*pch1++ != *pch2++)
                    break;                  // Exit loop on mismatch
            }
            if (cch == 0)
                return((char *)buffer);     // Return pointer to match
#ifdef FE_SB
        }
#endif

        if (buffer + 1 < (unsigned char *) bufend)         // Make sure buffer[targetlen] is valid.
            buffer += ((unsigned char)td1[buffer[targetlen]]); // Skip ahead
        else
            break;
    }
    return((char *) 0);                 // No match
}


int
preveol(
    char *s
    )
{
    register  char   *cp;        // Char pointer

    cp = s + 1;             // Initialize pointer

    if (!bStdIn && !bLargeFile) {
        while((--cp >= BaseByteAddress) && (*cp != '\n'))
            ;    // Find previous end-of-line
    } else {
        while(*--cp != '\n') ;      // Find previous end-of-line
    }

    return (int)(s - cp);         // Return distance to match
}


int
countlines(
    char *start,
    char *finish
    )
{
    register int        count;          // Line count

    for(count = 0; start < finish; ) {
        // Loop to count lines
        if (*start++ == '\n')
            ++count;                    // Increment count if linefeed found
    }
    return(count);                      // Return count
}



char *
findlist(
    unsigned char *buffer,
    char *bufend
    )
{
    char        *match;                 // Pointer to matching string

    // Avoid writting to bufend. bufend[-1] is something(such as '\n') that is not
    // part of search and will cause the search to stop.

    match = (*flworker[casesen])(buffer, bufend);   // Call worker

    return(match);                      // Return matching string
}


char *
findsub(
    unsigned char *buffer,
    char *bufend
    )
{
    register char       *cp;            // Char pointer
    STRINGNODE          *s;             // String node pointer
    int                 i;              // Index
#ifdef FE_SB // Head of buffer for checking if a certain offset is the 2nd byte of a DBCS character.
    unsigned char       *bufhead = buffer;
#endif
    char                *real_bufend = bufend;

    if (cchmin != (unsigned)-1 &&
        cchmin != 0 &&
        (bufend -= cchmin - 1) < (char *) buffer)
        return((char *) 0);     // Compute effective buffer length

    while(buffer < (unsigned char *) bufend) {      // Loop to find match
#ifdef FE_SB
        // Search cannot start at the second byte of a DBCS character,
        // so check for it and skip it if it is a second byte.
        if ((i = (UCHAR)transtab[*buffer]) != 0 &&
            !IsTailByte( bufhead, (int)(buffer-bufhead) ) ) {
#else
        if ((i = (UCHAR)transtab[*buffer]) != 0) {
#endif
            // If valid first character
            if ((s = stringlist[i]) == 0) {
                return((char *)buffer);             // Check for 1-byte match
            }

            for(cp = (char *) buffer + 1; (real_bufend - cp) >= s->s_must; )  {    // Loop to search list

                if ((i = _strncoll(cp, s_text(s), s->s_must)) == 0) {
                                                    // If portions match
                    cp += s->s_must;                // Skip matching portion
                    if ((s = s->s_suf) == 0)
                        return((char *)buffer);     // Return match if end of list
                    continue;                       // Else continue
                }

                if (i < 0 || (s = s->s_alt) == 0) {
                    break;                          // Break if not in this list
                }
            }
        }

        if (buffer + 1 < (unsigned char *) bufend)   // Make sure buffer[cchmin] is valid.
            if (cchmin == (unsigned)-1)
                buffer++;
            else
                buffer += ((unsigned char)td1[buffer[cchmin]]); // Shift as much as possible
        else
            break;
    }
    return((char *) 0);                 // No match
}


char *
findsubi(
    unsigned char *buffer,
    char *bufend
    )
{
    register char       *cp;            // Char pointer
    STRINGNODE          *s;             // String node pointer
    int                 i;              // Index
#ifdef FE_SB
    // Keep head of buffer for checking if a certain offset is the 2nd byte of
    // a DBCS character.
    unsigned char       *bufhead = buffer;
#endif

    if (cchmin != (unsigned)-1 &&
        cchmin != 0 &&
        (bufend -= cchmin - 1) < (char *) buffer)
        return((char *) 0);                 // Compute effective buffer length

    while(buffer < (unsigned char *) bufend) {      // Loop to find match
#ifdef FE_SB
        // Search cannot start at the second byte of a DBCS character, so check for it
        // and skip it if it is a second byte.
        if ((i = (UCHAR)transtab[*buffer]) != 0 &&
            !IsTailByte( bufhead, (int)(buffer-bufhead) ) ) {
                                            // If valid first character
            BOOL    TailByte;               // Flag to check if 1st char is leadbyte.
#else
        if ((i = (UCHAR)transtab[*buffer]) != 0) {  // If valid first character
#endif

            if ((s = stringlist[i]) == 0)
                return((char *) buffer);    // Check for 1-byte match

#ifdef FE_SB
            // Same leadbytes with tailbytes such as 0x41 and 0x61 will become the same
            // character, so become aware of it and use the multibyte function.

            //
            // Check if buffer+1 is a tailbyte character.
            //

            TailByte = IsTailByte(buffer, 1);

            for(cp = (char *) buffer + 1; ; ) {     // Loop to search list
                if ((i = _mbsnicmp((unsigned char *)cp, (unsigned char *) s_text(s), s->s_must, &TailByte)) == 0) {
#else
            for(cp = (char *) buffer + 1; ; ) {     // Loop to search list
                if ((i = memicmp(cp, s_text(s), s->s_must)) == 0) {
#endif
                    // If portions match
                    cp += s->s_must;                // Skip matching portion
                    if ((s = s->s_suf) == 0)
                        return((char *) buffer);    // Return match if end of list
                    continue;                       // And continue
                }
                if (i < 0 || (s = s->s_alt) == 0)
                    break;              // Break if not in this list
            }
        }

        if (buffer + 1 < (unsigned char *) bufend)   // Make sure buffer[cchmin] is valid.
            if (cchmin == (unsigned)-1)
                buffer++;
            else
                buffer += ((unsigned char)td1[buffer[cchmin]]); // Shift as much as possible
        else
            break;
    }
    return((char *) 0);                 // No match
}


int
strnspn(
    char *s,
    char *t,
    int n
    )
/*
    Description:

        Finds the position of the first character in s of length n that is not
        in the character set t.

    Argument:

        s   - string to search from.
        t   - character set to search for
        n   - length of s

    Returns:

        Returns the offset of the first character in s that is not in t
*/
{
    register  char        *s1;          // String pointer
    register  char        *t1;          // String pointer

    for(s1 = s; n-- != 0; ++s1) {           // While not at end of s
        for(t1 = t; *t1 != '\0'; ++t1) {    // While not at end of t
            if (*s1 == *t1)
                break;                  // Break if match found
        }
        if (*t1 == '\0')
            break;                      // Break if no match found
    }
    return (int)(s1 - s);               // Return length
}


int
strncspn(
    char *s,
    char *t,
    int n
    )
/*
    Description:

        Finds the position of the first occurence of characters in t in string
        s of length n.

    Argument:

        s   - string to search from.
        t   - character set to search for
        n   - length of s

    Returns:

        Returns first offset position in s that consists of characters in t
        Returns length of s if not found.
*/
{
    register   char        *s1;         // String pointer
    register   char        *t1;         // String pointer

    for(s1 = s; n-- != 0; ++s1) {           // While not at end of s
        for(t1 = t; *t1 != '\0'; ++t1) {    // While not at end of t
            if (*s1 == *t1)
                return (int)(s1 - s);   // Return if match found
        }
    }
    return (int)(s1 - s);               // Return length
}


void
matchstrings(
    char *s1,
    char *s2,
    int len,
    int *nmatched,
    int *leg
    )
{
    register char       *cp;            // Char pointer
    register int (__cdecl *cmp)(const char*, const char*, size_t);       // Comparison function pointer

    cmp = casesen ? _strncoll: _strnicoll;       // Set pointer
    if ((*leg = (*cmp)(s1, s2, len)) != 0) {   // If strings don't match
        for(cp = s1; (*cmp)(cp, s2++, 1) == 0; ++cp)
            ;
                                        // Find mismatch
        *nmatched = (int)(cp - s1);     // Return number matched
    }
    else *nmatched = len;               // Else all matched
}



void
printmessage (
    FILE* fp,
    DWORD messageID,
    ...
    )
{
    char        messagebuffer[DISPLAYBUFFER_SIZE];
    WCHAR       widemessagebuffer[DISPLAYBUFFER_SIZE];
    ULONG       len;
    NTSTATUS    status;

    va_list     ap;

    va_start(ap, messageID);

    if (len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                            NULL,
                            messageID,
                            0,
                            messagebuffer,
                            DISPLAYBUFFER_SIZE,
                            &ap)) {
        // the messagebuffer should be null terminated
        status = RtlMultiByteToUnicodeN(widemessagebuffer,
                                        DISPLAYBUFFER_SIZE*sizeof(WCHAR),
                                        &len,
                                        messagebuffer,
                                        len);
        // the widemessagebuffer is not null terminated but len tells us how long
        if (NT_SUCCESS(status)) {
            status = RtlUnicodeToOemN(messagebuffer, DISPLAYBUFFER_SIZE-1, &len, widemessagebuffer, len);
            // the messagebuffer is not null terminated but len tells us how long
            if (NT_SUCCESS(status)) {
                messagebuffer[len] = 0;
                fprintf(fp, "%s", messagebuffer);
            } else {
                DbgPrint("Failure to convert Unicode to Oem: %d\n", GetLastError());
            }
        } else {
            DbgPrint("Failure to convert MultiByte to Unicode: %d\n", GetLastError());
        }
    } else {
        DbgPrint("FormatMessage failed: %d\n", GetLastError());
    }

    va_end(ap);
}

#ifdef FE_SB

int
IsTailByte(
    unsigned const char *text,
    const int offset
    )

/*
    Description:

        This routine checks to see if the byte at the offset location is a
        tail byte of a DBCS character.  The offset is calculated such that the
        first location has a value of 0.

    Argument:

        text   - Points to a MBCS text string.

        offset - zero base offset to check character is a tailbyte of a DBCS
                 character.

    Returns:

        TRUE   - offset position is a tailbyte character.

        FALSE  - otherwise.

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    int i = offset;

    if ( !IsDBCSCodePage )
        return( FALSE );

    for ( ; i; i-- )
        if ( !IsDBCSLeadByte ( text[i-1] ) )
            break;

    return( ( offset - i ) % 2 );
}

char *
_mbsrchr(
    const char *string,
    int c
    )

/*
    Description:

        This function is a DBCS enabled version of the STRRCHR function
        included in the MS C/C++ library.  What DBCS enabled means is that
        the SBCS character 'c' is found in a MBCS string 'string'.  'c' is
        a SBCS character that cannot be contained in the tailbyte of a DBCS
        character.

    Argument:

        string - Points to a MBCS text string.

        offset - Character to find in string.

    Returns:

        Returns a pointer to the last occurance of c in string, or a NULL
        pointer if c is not found.

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    register int    i = strlen( string );

    for (; i >= 0; i-- ) {
        if ( ( *(string + i) == (char)c ) && !IsTailByte( (unsigned char *) string, i ) )
            return( (char*)(string + i) );
    }
    return ( NULL );
}


unsigned char *
_mbslwr(
    unsigned char *s
    )

/*
    Description:

        This function is a DBCS aware version of the strlwr function
        included in the MS C/C++ library.  SBCS alphabets contained in
        the tailbyte of a DBCS character is not affected in the conversion.

    Argument:

        s - String to converted to lower case.

    Returns:

        Returns a string that was converted to lower case.

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    //
    // If NonJP code page, use original routine.
    //
    if ( !IsDBCSCodePage )
        return( (unsigned char *) _strlwr( (char *) s ) );

    //
    // While not end of string convert to lower case.
    //
    for( ; *s; s++ )  {

        //
        // if Leadbyte and next character is not NULL
        //     skip tailbyte
        // else if uppercase character
        //     convert it to lowercase
        //
        if ( IsDBCSLeadByte( *s ) && *(s+1) )
            s++;
        else if ( *s >= 0x41 && *s <= 0x5a )
            *s = *s + 0x20;
    }
    return( s );
}

int
_mbsnicmp(
    const unsigned char *s1,
    const unsigned char *s2,
    int n,
    BOOL *TailByte
    )

/*
    Description:

        This is similar to a DBCS aware version of the memicmp function
        contained in the MS C/C++ library.  The only difference is that
        an additional parameter is passed which indicates if the first
        character is a tailbyte of a DBCS character.

    Argument:

        s1  - string 1 to compare.

        s2  - string 2 to compare.

        n   - maximum number of bytes to compare.

        TailByte - flag to indicate first character in s1 and s2 is a tailbyte
                   of a DBCS character.

    Returns:

        RetVal < 0  - s1 < s2

        RetVal = 0  - s1 == s2

        RetVal > 0  - s1 > s2

    Modifications:

        v-junm:     05/06/93 - Original.
*/

{
    BOOL    tail = *TailByte;
    int     i;

    *TailByte = FALSE;

    for( ; n; n--, s1++, s2++ )  {

        if ( *s1 == *s2 )  {

            if ( tail == FALSE && IsDBCSLeadByte( *s1 ) )
                tail = TRUE;
            else
                tail = FALSE;

            continue;

        }
        else if ( !tail )  {

            i = _strnicoll((char *)s1, (char *)s2, 1);
            if (i == 0)
                continue;
            return i;
        }

        return( *s1 - *s2 );
    }

    *TailByte = tail;

    return( 0 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\extend.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "fmifsmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "ifsentry.hxx"
#include "system.hxx"
#include "drive.hxx"


VOID
Extend(
    IN  PWSTR               DriveName,
    IN  BOOLEAN             Verify,
    IN  FMIFS_CALLBACK      Callback
    )

/*++

Routine Description:

    This routine loads and calls the correct DLL to extend the
    given volume.  Currently only NTFS can do this.

	This is is for either GUI or text mode.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    Verify          - Whether or not to verify the extended space
    Callback        - Supplies the necessary call back for
                        communication with the client

Return Value:

    None.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     extend_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    EXTEND_FN                   extend_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !extend_string.Initialize("Extend") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize("NTFS") ||
        !library_name.Strcat(&file_system_name) ||
        !(extend_function = (EXTEND_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &extend_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename))
    {
        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Call chkdsk.

    result = extend_function(&ntdrivename,
                             &message,
                             Verify
                             );

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\diskcopy.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "fmifsmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "mldcopy.hxx"


VOID
DiskCopy(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    )
/*++

Routine Description:

    This routine copies the contents of the floppy in the
    source drive to the floppy in the destination drive.

Arguments:

    SourceDrive - Supplies the dos style name of the source drive.
    DestDrive   - Supplies the dos style name of the destination drive.
    Verify      - Supplies whether or not writes should be verified.
    Callback    - Supplies the file manager call back function.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     src_dos_name, dst_dos_name;
    DSTRING                     src_nt_name, dst_nt_name;
    INT                         r;
    FMIFS_FINISHED_INFORMATION  finished_info;

    if (!message.Initialize(Callback) ||
        !src_dos_name.Initialize(SourceDrive) ||
        !dst_dos_name.Initialize(DestDrive) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&src_dos_name, &src_nt_name) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dst_dos_name, &dst_nt_name)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    r = DiskCopyMainLoop(&src_nt_name,
                         &dst_nt_name,
                         &src_dos_name,
                         &dst_dos_name,
                         Verify,
                         &message,
                         &message);

    finished_info.Success = (r <= 1) ? TRUE : FALSE;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\chkmsg.cxx ===
#include "ulib.hxx"
#include "system.hxx"
#include "chkmsg.hxx"
#include "rtmsg.h"


#define MAX_CHKDSK_MESSAGE_LENGTH 400


DEFINE_CONSTRUCTOR(FMIFS_CHKMSG, FMIFS_MESSAGE);


FMIFS_CHKMSG::~FMIFS_CHKMSG(
    )
/*++

Routine Description:

    Destructor for FMIFS_CHKMSG.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
FMIFS_CHKMSG::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
FMIFS_CHKMSG::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
FMIFS_CHKMSG::Initialize(
    IN  FMIFS_CALLBACK  CallBack
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    CallBack    - Supplies the callback to the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    _lastyesnoquery = UNINITIALIZED_BOOLEAN;
    return FMIFS_MESSAGE::Initialize(CallBack);
}


BOOLEAN
FMIFS_CHKMSG::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN r = TRUE;
    DSTRING string;
    STR sz[MAX_CHKDSK_MESSAGE_LENGTH];
    FMIFS_PERCENT_COMPLETE_INFORMATION  percent_info;
    FMIFS_CHECKONREBOOT_INFORMATION     reboot_info;
    FMIFS_TEXT_MESSAGE                  textMsg;

    if (! (_msgvisual & GUI_MESSAGE) )
    {
        return TRUE;
    }

    switch (GetMessageId())
    {
        case MSG_PERCENT_COMPLETE:
        case MSG_PERCENT_COMPLETE2:
        {
            percent_info.PercentCompleted = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsPercentCompleted,
                          sizeof(FMIFS_PERCENT_COMPLETE_INFORMATION),
                          &percent_info);
            break;
        }

        case MSG_CHKDSK_ON_REBOOT_PROMPT:
        {
            reboot_info.QueryResult = UNINITIALIZED_BOOLEAN;
            r = _callback(FmIfsCheckOnReboot,
                          sizeof(FMIFS_CHECKONREBOOT_INFORMATION),
                          &reboot_info);

            _lastyesnoquery = reboot_info.QueryResult;

            break;
        }

        case MSG_CHK_WRITE_PROTECTED: {
            r = _callback(FmIfsMediaWriteProtected, 0, NULL);
            break;
        }

        case MSG_CHK_NO_MULTI_THREAD: {
            r = _callback(FmIfsCantChkMultiVolumeOfSameFS, 0, NULL);
            break;
        }

        case MSG_DASD_ACCESS_DENIED:
        {
           r = _callback(FmIfsAccessDenied, 0, NULL);
           break;
        }

        default:
        {
            if (!SYSTEM::QueryResourceStringV(
                            &string,
                            GetMessageId(),
                            Format,
                            VarPointer))
            {
                return FALSE;
            }

            if (IsLoggingEnabled() && !IsSuppressedMessage())
                LogMessage(&string);

            string.QuerySTR(0,TO_END,sz,MAX_CHKDSK_MESSAGE_LENGTH);
            textMsg.Message = sz;

            switch (GetMessageId())
            {
            case MSG_CHKDSK_CANNOT_SCHEDULE:
            case MSG_CHKDSK_SCHEDULED:
            case MSG_CHK_NTFS_ERRORS_FOUND:
            {
                textMsg.MessageType = MESSAGE_TYPE_FINAL;

                break;
            }

            default:
            {
                switch (_msgtype)
                {
                case PROGRESS_MESSAGE:
                    textMsg.MessageType = MESSAGE_TYPE_PROGRESS;
                    break;

                default:
                    textMsg.MessageType = MESSAGE_TYPE_RESULTS;
                    break;
                }

                break;
            }
            }

            r = _callback(
                    FmIfsTextMessage,
                    sizeof(FMIFS_TEXT_MESSAGE),
                    &textMsg);

            break;
        }
    }

    return r;
}


BOOLEAN
FMIFS_CHKMSG::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine returns returns the value loaded from the user during
    the previous DisplayV() with a query message, or the default
    if no response (which currently isn't possible...)

Arguments:

    Default - Supplies the default answer

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    DebugPrintTrace((
            "FMIFS_CHKMSG::IsYesResponse: _lastyesnoquery == %d\n",
            _lastyesnoquery));

    return (UNINITIALIZED_BOOLEAN == _lastyesnoquery)
            ? Default
            : _lastyesnoquery
            ;
}


PMESSAGE
FMIFS_CHKMSG::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PFMIFS_CHKMSG  p;

    if (!(p = NEW FMIFS_CHKMSG)) {
        return NULL;
    }

    if (!p->Initialize(_callback)) {
        DELETE(p);
        return NULL;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\label.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
};
#include "ifssys.hxx"
#include "wstring.hxx"

BOOLEAN
SetLabel(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    )
/*++

Routine Description:

    This routine sets the label on the given drive.

Arguments:

    DriveName   - Supplies the drive name on which to place the
                    label.
    Label       - Supplies the label.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   length  = sizeof(FILE_FS_LABEL_INFORMATION) + MAX_PATH*sizeof(WCHAR);

    DSTRING                     dosdrivename, ntdrivename;
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    IO_STATUS_BLOCK             status_block;
    HANDLE                      handle;
    DSTRING                     label;
    PFILE_FS_LABEL_INFORMATION  info;
    STR                         info_buf[length];
    NTSTATUS                    nts;
    BOOLEAN                     result;
    DWORD                       error;

    if (!dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!(string.Buffer = ntdrivename.QueryWSTR())) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    string.Length = (USHORT) (ntdrivename.QueryChCount()*sizeof(WCHAR));
    string.MaximumLength = string.Length;

    InitializeObjectAttributes( &oa, &string, OBJ_CASE_INSENSITIVE, 0, 0 );

    nts = NtOpenFile(&handle,
                     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                     &oa, &status_block,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    if (!NT_SUCCESS(nts)) {

        DELETE(string.Buffer);
        SetLastError(RtlNtStatusToDosError(nts));
        return FALSE;
    }

    DELETE(string.Buffer);

    if (!label.Initialize(Label)) {

        NtClose(handle);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    info =  (PFILE_FS_LABEL_INFORMATION) info_buf;


    label.QueryWSTR(0, TO_END, info->VolumeLabel, length - sizeof(ULONG));

    info->VolumeLabelLength = label.QueryChCount()*sizeof(WCHAR);

    nts = NtSetVolumeInformationFile(
            handle, &status_block, info, length, FileFsLabelInformation);

    if (!NT_SUCCESS(nts)) {

        result = FALSE;
        error = RtlNtStatusToDosError(nts);

        // Remap ERROR_LABEL_TOO_LONG, since its message text is
        // misleading.
        //
        if( error == ERROR_LABEL_TOO_LONG ) {

            error = ERROR_INVALID_NAME;
        }

        SetLastError(error);

    } else {

        result = TRUE;
    }

    NtClose(handle);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=fmifs
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib    \
           ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
           ..\..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib  \
           ..\..\..\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib

USE_MSVCRT=1

DLLENTRY=InitializeFmIfs

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\fmifsmsg.cxx \
        ..\format.cxx \
        ..\label.cxx \
        ..\diskcopy.cxx \
        ..\fmifs.rc \
        ..\fmifs.cxx \
        ..\chkdsk.cxx \
        ..\chkmsg.cxx \
        ..\extend.cxx


INCLUDES=..\..\inc;..\..\..\ulib\inc;..\..\..\ifsutil\inc;..\..\..\ufat\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMTYPE=windows
DLLDEF=..\fmifs.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\fmifsmsg.cxx ===
#include "ulib.hxx"
#include "fmifsmsg.hxx"
#include "rtmsg.h"


DEFINE_CONSTRUCTOR(FMIFS_MESSAGE, MESSAGE);


FMIFS_MESSAGE::~FMIFS_MESSAGE(
    )
/*++

Routine Description:

    Destructor for FMIFS_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
FMIFS_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _callback = NULL;
    _kilobytes_total_disk_space = 0;
    _values_in_mb = 0;
}


VOID
FMIFS_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _callback = NULL;
    _kilobytes_total_disk_space = 0;
}


BOOLEAN
FMIFS_MESSAGE::Initialize(
    IN  FMIFS_CALLBACK  CallBack
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    CallBack    - Supplies the callback to the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    _callback = CallBack;
    return _callback ? MESSAGE::Initialize() : FALSE;
}


BOOLEAN
FMIFS_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_PERCENT_COMPLETE_INFORMATION  percent_info;
    FMIFS_FORMAT_REPORT_INFORMATION     fmt_report;
    FMIFS_INSERT_DISK_INFORMATION       insert_info;
    FMIFS_IO_ERROR_INFORMATION          io_error_info;
    BOOLEAN                             r = TRUE;
    PWSTRING                            drive_name, file_name;
    ULONG                               unit_bits = 0;

    switch (GetMessageId()) {

        case MSG_PERCENT_COMPLETE:
        case MSG_PERCENT_COMPLETE2: // Should never get this on FORMAT (only CHKDSK)
            percent_info.PercentCompleted = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsPercentCompleted,
                          sizeof(FMIFS_PERCENT_COMPLETE_INFORMATION),
                          &percent_info);
            break;

        case MSG_DCOPY_INSERT_TARGET:
            insert_info.DiskType = DISK_TYPE_TARGET;
            r = _callback(FmIfsInsertDisk,
                          sizeof(FMIFS_INSERT_DISK_INFORMATION),
                          &insert_info);
            break;

        case MSG_DCOPY_INSERT_SOURCE:
            insert_info.DiskType = DISK_TYPE_SOURCE;
            r = _callback(FmIfsInsertDisk,
                          sizeof(FMIFS_INSERT_DISK_INFORMATION),
                          &insert_info);
            break;

        case MSG_DCOPY_INSERT_SOURCE_AND_TARGET:
            insert_info.DiskType = DISK_TYPE_SOURCE_AND_TARGET;
            r = _callback(FmIfsInsertDisk,
                          sizeof(FMIFS_INSERT_DISK_INFORMATION),
                          &insert_info);
            break;

        case MSG_DCOPY_FORMATTING_WHILE_COPYING:
            r = _callback(FmIfsFormattingDestination, 0, NULL);
            break;

        case MSG_DCOPY_BAD_DEST:
            r = _callback(FmIfsIncompatibleMedia, 0, NULL);
            break;

#if 1
        case MSG_DCOPY_NON_COMPAT_DISKS:
            r = _callback(FmIfsIncompatibleMedia, 0, NULL);
            break;
#else
        // MSG_DCOPY_BAD_DEST may need to call a different FmIfs....
        case MSG_DCOPY_NON_COMPAT_DISKS:
            // pop a dialog and ask for retry or cancel
            // TRUE signals CANCEL selected instead of RETRY
            break;
#endif


        case MSG_TOTAL_DISK_SPACE:
            _kilobytes_total_disk_space = va_arg(VarPointer, ULONG)/1024;
            break;

        case MSG_AVAILABLE_DISK_SPACE:
            fmt_report.KiloBytesTotalDiskSpace = _kilobytes_total_disk_space;
            fmt_report.KiloBytesAvailable = va_arg(VarPointer, ULONG)/1024;
            r = _callback(FmIfsFormatReport,
                          sizeof(FMIFS_FORMAT_REPORT_INFORMATION),
                          &fmt_report);
            break;

        case MSG_TOTAL_MEGABYTES:
        case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_MB:
            unit_bits = TOTAL_DISK_SPACE_IN_MB;

            // fall thru

        case MSG_TOTAL_KILOBYTES:
        case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_KB:
            _values_in_mb = unit_bits;
            _kilobytes_total_disk_space = va_arg(VarPointer, ULONG);
            break;

        case MSG_AVAILABLE_MEGABYTES:
        case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_MB:
            _values_in_mb |= BYTES_AVAILABLE_IN_MB;

            // fall thru

        case MSG_AVAILABLE_KILOBYTES:
        case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_KB:
            fmt_report.KiloBytesTotalDiskSpace = _kilobytes_total_disk_space;
            fmt_report.KiloBytesAvailable = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsFormatReport,
                          sizeof(FMIFS_FORMAT_REPORT_INFORMATION),
                          &fmt_report);
            break;

        case MSG_DCOPY_WRITE_ERROR:
        case MSG_DCOPY_READ_ERROR:
            io_error_info.DiskType = (GetMessageId() == MSG_DCOPY_READ_ERROR) ?
                                     DISK_TYPE_SOURCE : DISK_TYPE_TARGET;
            va_arg(VarPointer, PVOID);
            io_error_info.Head = va_arg(VarPointer, ULONG);
            io_error_info.Track = va_arg(VarPointer, ULONG);
            r = _callback(FmIfsIoError,
                          sizeof(FMIFS_IO_ERROR_INFORMATION),
                          &io_error_info);
            break;

        case MSG_CANT_LOCK_THE_DRIVE:
            r = _callback(FmIfsCantLock, 0, NULL);
            break;

        case MSG_CANT_UNLOCK_THE_DRIVE:
            // similiar to FmIfsCantLock
            break;

        case MSG_DCOPY_NO_MEDIA_IN_DEVICE:
            drive_name = va_arg(VarPointer, PWSTRING);
            {
                WCHAR wchLetter = drive_name->QueryChAt(0);
                r = _callback(FmIfsNoMediaInDevice, sizeof(WCHAR),
                    (void*) &wchLetter);
            }
            break;

        case MSG_DCOPY_UNRECOGNIZED_MEDIA:
            // pop a dialog and ask for retry or cancel
            // TRUE signals CANCEL selected instead of RETRY
            break;

        case MSG_DASD_ACCESS_DENIED:
            r = _callback(FmIfsAccessDenied, 0, NULL);
            break;

        case MSG_CANT_QUICKFMT:
        case MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE:
            r = _callback(FmIfsCantQuickFormat, 0, NULL);
            break;

        case MSG_FMT_TOO_MANY_CLUSTERS:
            r = _callback(FmIfsClustersCountBeyond32bits, 0, NULL);
            break;

        case MSG_DCOPY_MEDIA_WRITE_PROTECTED:
            r = _callback(FmIfsMediaWriteProtected, 0, NULL);
            break;

        case MSG_FMT_WRITE_PROTECTED_MEDIA:
            r = _callback(FmIfsMediaWriteProtected, 0, NULL);
            break;

        case MSG_INVALID_LABEL_CHARACTERS:
            r = _callback(FmIfsBadLabel, 0, NULL);
            break;

        case MSG_HIDDEN_STATUS:
            r = _callback(FmIfsHiddenStatus, 0, NULL);
            break;

#if defined ( DBLSPACE_ENABLED )
        case MSG_DBLSPACE_VOLUME_NOT_CREATED:
            r = _callback(FmIfsDblspaceCreateFailed, 0, NULL);
            break;

        case MSG_DBLSPACE_CANT_MOUNT:
            r = _callback(FmIfsDblspaceMountFailed, 0, NULL);
            break;

        case MSG_DBLSPACE_CANT_ASSIGN_DRIVE_LETTER:
            r = _callback(FmIfsDblspaceDriveLetterFailed, 0, NULL);
            break;

        case MSG_DBLSPACE_VOLUME_CREATED:
            // Both arguments to this message are PWSTRING's;
            // the first is the drive, the second is the
            // Compressed Volume File name.
            //
            drive_name = va_arg( VarPointer, PWSTRING );
            file_name = va_arg( VarPointer, PWSTRING );
            r = _callback(FmIfsDblspaceCreated,
                          file_name->QueryChCount() * sizeof(WCHAR),
                          (PVOID)file_name->GetWSTR() );
            break;

        case MSG_DBLSPACE_MOUNTED:
            r = _callback(FmIfsDblspaceMounted, 0, NULL);
            break;
#endif // DBLSPACE_ENABLED

        case MSG_FMT_CLUSTER_SIZE_TOO_SMALL:
            r = _callback(FmIfsClusterSizeTooSmall, 0, NULL);
            break;

        case MSG_FMT_CLUSTER_SIZE_TOO_BIG:
            r = _callback(FmIfsClusterSizeTooBig, 0, NULL);
            break;

        case MSG_FMT_VOL_TOO_SMALL:
        case MSG_FMT_VOLUME_TOO_SMALL:
            r = _callback(FmIfsVolumeTooSmall, 0, NULL);
            break;

        case MSG_FMT_VOL_TOO_BIG:
            r = _callback(FmIfsVolumeTooBig, 0, NULL);
            break;

        case MSG_DEVICE_OFF_LINE:
            r = _callback(FmIfsDeviceOffLine, 0, NULL);
            break;

        default:
            break;
    }

    return r;
}


PMESSAGE
FMIFS_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PFMIFS_MESSAGE  p;

    if (!(p = NEW FMIFS_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize(_callback)) {
        DELETE(p);
        return NULL;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\format.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
extern "C" {
#include "fmifs.h"
#include "stdio.h"
};
#include "fmifsmsg.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"
#include "ifsentry.hxx"
#include "system.hxx"
#include "hmem.hxx"
#include "drive.hxx"

typedef struct _FILE_SYSTEM_FORMAT_RECORD {
    WCHAR       FileSystemName[MAX_FILE_SYSTEM_FORMAT_NAME_LEN];    // FAT, FAT32, NTFS
    UCHAR       MajorVersion;                                       // major revision number
    UCHAR       MinorVersion;                                       // minor revision number
    BOOLEAN     Latest;                                             // TRUE for most up-to-date version
} FILE_SYSTEM_FORMAT_RECORD;

//
// Defines all the format type Format() and FormatEx() can do
// This needs to be updated on each official release
//
FILE_SYSTEM_FORMAT_RECORD   fsFormatAvailable[] = {
    {{'F','A','T'},         0, 0, TRUE},
    {{'F','A','T','3','2'}, 0, 0, TRUE},
    {{'N','T','F','S'},     4, 0, FALSE},
    {{'N','T','F','S'},     5, 0, TRUE}
};

MEDIA_TYPE
ComputeNtMediaType(
    IN  FMIFS_MEDIA_TYPE    MediaType
    )
/*++

Routine Description:

    This routine translates the FMIFS media type to the NT media type.

Arguments:

    MediaType   - Supplies the FMIFS media type.

Return Value:

    The NT media type corresponding to the input.

--*/
{
    MEDIA_TYPE  media_type;

    switch (MediaType) {
        case FmMediaFixed:
            media_type = FixedMedia;
            break;
        case FmMediaRemovable:
            media_type = RemovableMedia;
            break;
        case FmMediaF5_1Pt2_512:
            media_type = F5_1Pt2_512;
            break;
        case FmMediaF5_360_512:
            media_type = F5_360_512;
            break;
        case FmMediaF5_320_512:
            media_type = F5_320_512;
            break;
        case FmMediaF5_320_1024:
            media_type = F5_320_1024;
            break;
        case FmMediaF5_180_512:
            media_type = F5_180_512;
            break;
        case FmMediaF5_160_512:
            media_type = F5_160_512;
            break;
        case FmMediaF3_2Pt88_512:
            media_type = F3_2Pt88_512;
            break;
        case FmMediaF3_1Pt44_512:
            media_type = F3_1Pt44_512;
            break;
        case FmMediaF3_720_512:
            media_type = F3_720_512;
            break;
        case FmMediaF3_20Pt8_512:
            media_type = F3_20Pt8_512;
            break;
        case FmMediaF3_120M_512:
            media_type = F3_120M_512;
            break;
        case FmMediaF3_200Mb_512:
            media_type = F3_200Mb_512;
            break;
        case FmMediaF3_240Mb_512:
            media_type = F3_240M_512;
            break;
#ifdef FE_SB // JAPAN && i386
        // FMR Sep.8.1994 SFT YAM :ADD
        // FMR Jul.12.1994 SFT KMR
        // Add the media-type for 2HD/2HC
        case FmMediaF5_1Pt23_1024:
            media_type = F5_1Pt23_1024;
            break;
        case FmMediaF3_1Pt23_1024:
            media_type = F3_1Pt23_1024;
            break;
        case FmMediaF3_1Pt2_512:
            media_type = F3_1Pt2_512;
            break;
        // Add the media-type for 2DD(640KB/720KB)
        case FmMediaF5_720_512:
            media_type = F5_720_512;
            break;
        case FmMediaF5_640_512:
            media_type = F5_640_512;
            break;
        // NEC98 '94.09.22 NES
        // add  FmMediaF5_1Pt2_1024
        //      FmMediaF8_256_128
        //      FmMediaF3_640_512
        //      FmMediaF3_128Mb_512

        // deleted F5_1Pt2_1024 by eichim, 11/14/94
        // please see also public\sdk\inc\ntdddisk.h@v5
        //  case FmMediaF5_1Pt2_1024:
        //  media_type = F5_1Pt2_1024;
        //  break;
#if (_WIN32_WINNT < 0x0400)
        //
        // FmMediaF8_256_128 is no longer supported.
        //
        case FmMediaF8_256_128:
            media_type = F8_256_128;
            break;
#endif
        case FmMediaF3_640_512:
            media_type = F3_640_512;
            break;

        //
        // OpticalDisk format...
        //
        case FmMediaF3_128Mb_512:
            media_type = F3_128Mb_512;
            break;
        case FmMediaF3_230Mb_512:
            media_type = F3_230Mb_512;
            break;
#endif // FE_SB

        case FmMediaUnknown:
        default:
            media_type = Unknown;
            break;
    }

    return media_type;
}


FMIFS_MEDIA_TYPE
ComputeFmMediaType(
    IN  MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine translates the NT media type to the FMIFS media type.

Arguments:

    MediaType   - Supplies the NT media type.

Return Value:

    The FMIFS media type corresponding to the input.

--*/
{
    FMIFS_MEDIA_TYPE    media_type;

    switch (MediaType) {
        case FixedMedia:
            media_type = FmMediaFixed;
            break;
        case RemovableMedia:
            media_type = FmMediaRemovable;
            break;
        case F5_1Pt2_512:
            media_type = FmMediaF5_1Pt2_512;
            break;
        case F5_360_512:
            media_type = FmMediaF5_360_512;
            break;
        case F5_320_512:
            media_type = FmMediaF5_320_512;
            break;
        case F5_320_1024:
            media_type = FmMediaF5_320_1024;
            break;
        case F5_180_512:
            media_type = FmMediaF5_180_512;
            break;
        case F5_160_512:
            media_type = FmMediaF5_160_512;
            break;
        case F3_2Pt88_512:
            media_type = FmMediaF3_2Pt88_512;
            break;
        case F3_1Pt44_512:
            media_type = FmMediaF3_1Pt44_512;
            break;
        case F3_720_512:
            media_type = FmMediaF3_720_512;
            break;
        case F3_20Pt8_512:
            media_type = FmMediaF3_20Pt8_512;
            break;
        case F3_120M_512:
            media_type = FmMediaF3_120M_512;
            break;
        case F3_200Mb_512:
            media_type = FmMediaF3_200Mb_512;
            break;
        case F3_240M_512:
            media_type = FmMediaF3_240Mb_512;
            break;
#ifdef FE_SB // JAPAN && i386
        // FMR Sep.8.1994 SFT YAM :ADD
        // FMR Jul.12.1994 SFT KMR
        // Add the media-type for 2HD
        case F5_1Pt23_1024:
            media_type = FmMediaF5_1Pt23_1024;
            break;
        case F3_1Pt23_1024:
            media_type = FmMediaF3_1Pt23_1024;
            break;
        case F3_1Pt2_512:
            media_type = FmMediaF3_1Pt2_512;
            break;
        // Add the media-type for 2DD(640KB/720KB)
        case F5_720_512:
            media_type = FmMediaF5_720_512;
            break;
        case F5_640_512:
            media_type = FmMediaF5_640_512;
            break;
        // NEC98 '94.09.22 NES
        // add       F5_1Pt2_1024:
        //           F8_256_128:
        //           F3_640_512:
        //           F3_128Mb_512:

        // deleted F5_1Pt2_1024 by eichim, 11/14/94
        // please see also public\sdk\inc\ntdddisk.h@v5
        //  case F5_1Pt2_1024:
        //  media_type = FmMediaF5_1Pt2_1024;
        //  break;
#if (_WIN32_WINNT < 0x0400)
        //
        // FmMediaF8_256_128 is no longer supported.
        //
        case F8_256_128:
            media_type = FmMediaF8_256_128;
            break;
#endif
        case F3_640_512:
            media_type = FmMediaF3_640_512;
            break;

        //
        // OpticalDisk format...
        //
        case F3_128Mb_512:
            media_type = FmMediaF3_128Mb_512;
            break;
        case F3_230Mb_512:
            media_type = FmMediaF3_230Mb_512;
            break;
#endif // FE_SB

        case Unknown:
        default:
            media_type = FmMediaUnknown;
            break;
    }

    return media_type;
}

#if defined(FE_SB) && defined (_X86_)
BOOLEAN
ConvertSectorSizeIfNeeded(
    IN      PDSTRING                ntdrivename,
    IN      FMIFS_MEDIA_TYPE        MediaType,
    OUT     PUCHAR                  FirstByte,
    IN OUT  PMESSAGE                Message
)
/*++

Routine Description:

    Given the drive name and media type, this routine writes 0 to the first byte of the boot sector.
    This routine returns original value of the first byte.

Arguments:

    ntdrivename     - Supplies the name of the drive name.
    MediaType       - Supplies the media type.
    FirstByte       - Returns First byte of first sector.
    Message         - Supplies an outlet for messages

Return Value:

    TRUE  - Success
    FALSE - Failure

--*/
{
    // FMR Oct.13.1994 SFT YAM
    // If the sector-size when the last format differ from next format,
    // initialize a hard one-byte of disk.

    ULONG       old_sec_size;
    ULONG       new_sec_size;
    HMEM    hmem;
    PUCHAR      rw_buff = NULL;
    DP_DRIVE    dpdrive;
    BOOLEAN     result = TRUE;

    *FirstByte = 0;

    if (dpdrive.Initialize(ntdrivename, Message)) {
        if (dpdrive.QueryMediaType() != Unknown) {

            old_sec_size = dpdrive.QuerySectorSize();

            if (ComputeNtMediaType(MediaType) == F5_1Pt23_1024 ||
                ComputeNtMediaType(MediaType) == F3_1Pt23_1024) {
                new_sec_size = 1024;
            } else {
                new_sec_size = 512;
            }

            if (new_sec_size != old_sec_size) {
                LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;

                if (LDpDrive->Initialize(ntdrivename,NULL,TRUE)) {
                    if (IsNEC_98 ? hmem.Acquire(dpdrive.QuerySectorSize(), max(dpdrive.QueryAlignmentMask(),
                                                          dpdrive.QuerySectorSize()-1)) :
                                   hmem.Acquire(dpdrive.QuerySectorSize(), dpdrive.QueryAlignmentMask())) {
                        rw_buff = (PUCHAR)hmem.GetBuf();
                        LDpDrive->Read(0,1,rw_buff);
                        *FirstByte = rw_buff[0];
                        rw_buff[0] = 0;
                        LDpDrive->Write(0,1,rw_buff);
                    } else {
                        result = FALSE;
                    }
                } else {
                    result = FALSE;
                }
                DELETE(LDpDrive);
            }
        }
    } else {
        result = FALSE;
    }
    return result;
}

VOID
RevertToOriginalSectorSize(
    IN  PDSTRING                ntdrivename,
    IN  UCHAR                   FirstByte
)
/*++

Routine Description:

    Given the drive name, this routine write back the first byte of first sector.

Arguments:

    ntdrivename     - Supplies the name of the drive name.
    FirstByte       - Returns First byte of first sector.

Return Value:

--*/
{
    HMEM    hmem;
    PUCHAR      rw_buff;
    DP_DRIVE    dpdrive;

    if (FirstByte) {
        if (dpdrive.Initialize(ntdrivename)) {
            LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;

        if (LDpDrive->Initialize(ntdrivename,NULL,TRUE)) {
                if (IsNEC_98 ? hmem.Acquire(dpdrive.QuerySectorSize(), max(dpdrive.QueryAlignmentMask(),
                                                      dpdrive.QuerySectorSize()-1)) :
                               hmem.Acquire(dpdrive.QuerySectorSize(), dpdrive.QueryAlignmentMask())) {
                    rw_buff = (PUCHAR)hmem.GetBuf();
                    LDpDrive->Read(0,1,rw_buff);
                    rw_buff[0] = FirstByte;
                    LDpDrive->Write(0,1,rw_buff);
                }
            }
            DELETE(LDpDrive);
        }
    }
    return;
}
#endif // FE_SB && _X86_

VOID
Format(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    )
/*++

Routine Description:

    This routine loads and calls the correct DLL to format the
    given volume.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    MediaType       - Supplies the media type.
    FileSystemName  - Supplies the file system type to format to.
    Label           - Supplies a new label for the volume.
    Quick           - Supplies whether or not to perform a quick
                        format.
    Callback        - Supplies the necessary call back for
                        communication with the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     format_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    FORMAT_FN                   format_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     label_string;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    DSTRING                     ntfs_str, ntfs_minus_str, ntfs_previous_str, ntfs_current_str;
    DSTRING                     fat_str, fat32_str, fat32_current_str;
    BOOLEAN                     backward_compatible;
    BOOLEAN                     rst;

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !format_string.Initialize("Format") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize(FileSystemName) ||
        !ntfs_str.Initialize("NTFS") ||
        !ntfs_minus_str.Initialize("NTFS-") ||
        !ntfs_previous_str.Initialize("NTFS 4.0") ||
        !ntfs_current_str.Initialize("NTFS 5.0") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !fat32_current_str.Initialize("FAT32 0.0")) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    if (file_system_name == ntfs_str) {
        rst = TRUE;
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_minus_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == fat_str) {
        rst = TRUE;
        backward_compatible = TRUE;
    } else if (file_system_name == fat32_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == fat32_current_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_previous_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == ntfs_current_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = FALSE;
    } else
        rst = FALSE;

    if (!rst ||
        !library_name.Strcat(&file_system_name) ||
        !(format_function = (FORMAT_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &format_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !label_string.Initialize(Label) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if defined(FE_SB) && defined (_X86_)
    UCHAR       FirstByte;

    if (ConvertSectorSizeIfNeeded(&ntdrivename, MediaType, &FirstByte, &message) == FALSE) {

        SYSTEM::FreeLibraryHandle(dll_handle);

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }
#endif // FE_SB

    // Call format.

    result = format_function(&ntdrivename,
                             &message,
                             Quick,
                             backward_compatible,
                             ComputeNtMediaType(MediaType),
                             &label_string, 0);

#if defined(FE_SB) && defined (_X86_)
    if (!result && FirstByte)
    RevertToOriginalSectorSize(&ntdrivename, FirstByte);
#endif // FE_SB && _X86_

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}


VOID
FormatEx(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  DWORD               ClusterSize,
    IN  FMIFS_CALLBACK      Callback
    )
/*++

Routine Description:

    This routine loads and calls the correct DLL to format the
    given volume.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    MediaType       - Supplies the media type.
    FileSystemName  - Supplies the file system type to format to.
    Label           - Supplies a new label for the volume.
    Quick           - Supplies whether or not to perform a quick
                        format.
    ClusterSize     - Size of volume cluster in bytes.
    Callback        - Supplies the necessary call back for
                        communication with the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     format_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    FORMAT_FN                   format_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     label_string;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    DSTRING                     ntfs_str, ntfs_minus_str, ntfs_previous_str, ntfs_current_str;
    DSTRING                     fat_str, fat32_str, fat32_current_str;
    BOOLEAN                     backward_compatible;
    BOOLEAN                     rst = TRUE;

#if 0
    FMIFS_FORMATEX2_PARAM       param;

    VOID
    FormatEx2(
        IN  PWSTR                   DriveName,
        IN  FMIFS_MEDIA_TYPE        MediaType,
        IN  PWSTR                   FileSystemName,
        IN  PFMIFS_FORMATEX2_PARAM  Param,
        IN  FMIFS_CALLBACK          Callback
        );

    memset(&param, 0, sizeof(param));
    param.Major = 1;
    param.Minor = 0;
    if (Quick)
        param.Flags |= FMIFS_FORMAT_QUICK;
    param.Flags |= FMIFS_FORMAT_FORCE;
    param.ClusterSize = ClusterSize;
    param.LabelString = Label;

    FormatEx2(DriveName,
              MediaType,
              FileSystemName,
              &param,
              Callback);
    return;
#endif

#if 0 // test code for API within
    {
        STR             x[100];
        UCHAR           major, minor;
        BOOLEAN         latest;
        unsigned            i;
        WSTR            fsName[10];

        for (i=0; QueryAvailableFileSystemFormat(i++, fsName, &major, &minor, &latest);) {
            OutputDebugStringW(fsName);
            sprintf(x, "; Major %d; Minor %d; Latest %d\n", major, minor, latest);
            OutputDebugStringA(x);
        }
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        WSTR        fsname[MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN];
        UCHAR       major, minor;
        NTSTATUS    errcode;

        if (QueryFileSystemName(DriveName,
                                fsname,
                                &major,
                                &minor,
                                &errcode)) {
            OutputDebugStringW(fsname);
            sprintf(x, "; Major %d; Minor %d; Errcode %d\n", major, minor, errcode);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryFileSystemName failed\n");
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        UCHAR       major, minor;

        if (QueryLatestFileSystemVersion(FileSystemName, &major, &minor)) {
            OutputDebugStringW(FileSystemName);
            sprintf(x, "; Major %d; Minor %d\n", major, minor);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryLatestFileSystemVersion failed\n");
    }
#endif

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (!message.Initialize(Callback) ||
        !format_string.Initialize("Format") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize(FileSystemName) ||
        !ntfs_str.Initialize("NTFS") ||
        !ntfs_minus_str.Initialize("NTFS-") ||
        !ntfs_previous_str.Initialize("NTFS 4.0") ||
        !ntfs_current_str.Initialize("NTFS 5.0") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !fat32_current_str.Initialize("FAT32 0.0")) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    if (file_system_name == ntfs_str) {
        rst = TRUE;
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_minus_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == fat_str) {
        rst = TRUE;
        backward_compatible = TRUE;
    } else if (file_system_name == fat32_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == fat32_current_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_previous_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == ntfs_current_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = FALSE;
    } else
        rst = FALSE;

    if (!rst ||
        !library_name.Strcat(&file_system_name) ||
        !(format_function = (FORMAT_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &format_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !label_string.Initialize(Label) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if defined(FE_SB) && defined (_X86_)
    UCHAR       FirstByte;

    if (ConvertSectorSizeIfNeeded(&ntdrivename, MediaType, &FirstByte, &message) == FALSE) {

        SYSTEM::FreeLibraryHandle(dll_handle);

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }
#endif // FE_SB && _X86_

    // Call format.

    result = format_function(&ntdrivename,
                             &message,
                             Quick,
                             backward_compatible,
                             ComputeNtMediaType(MediaType),
                             &label_string, ClusterSize);

#if defined(FE_SB) && defined (_X86_)
    if (!result && FirstByte)
    RevertToOriginalSectorSize(&ntdrivename, FirstByte);
#endif // FE_SB && _X86_

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}


VOID
FormatEx2(
    IN  PWSTR                   DriveName,
    IN  FMIFS_MEDIA_TYPE        MediaType,
    IN  PWSTR                   FileSystemName,
    IN  PFMIFS_FORMATEX2_PARAM  Param,
    IN  FMIFS_CALLBACK          Callback
    )
/*++

Routine Description:

    This routine loads and calls the correct DLL to format the
    given volume.

Arguments:

    DriveName       - Supplies the DOS style drive name.
    MediaType       - Supplies the media type.
    FileSystemName  - Supplies the file system type to format to.
    Param           - Supplies the format parameter block
    Callback        - Supplies the necessary call back for
                        communication with the file manager.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FMIFS_MESSAGE               message;
    DSTRING                     format_string;
    DSTRING                     library_name;
    DSTRING                     file_system_name;
    FORMATEX_FN                 format_function;
    HANDLE                      dll_handle;
    DSTRING                     ntdrivename;
    BOOLEAN                     result;
    DSTRING                     label_string;
    DSTRING                     dosdrivename;
    FMIFS_FINISHED_INFORMATION  finished_info;
    DWORD                       OldErrorMode;

    DSTRING                     ntfs_str, ntfs_minus_str, ntfs_previous_str, ntfs_current_str;
    DSTRING                     fat_str, fat32_str, fat32_current_str;
    BOOLEAN                     backward_compatible;
    BOOLEAN                     rst = TRUE;
    FORMATEX_FN_PARAM           param;

#if 0 // test code for API within
    {
        STR             x[100];
        UCHAR           major, minor;
        BOOLEAN         latest;
        unsigned            i;
        WSTR            fsName[10];

        for (i=0; QueryAvailableFileSystemFormat(i++, fsName, &major, &minor, &latest);) {
            OutputDebugStringW(fsName);
            sprintf(x, "; Major %d; Minor %d; Latest %d\n", major, minor, latest);
            OutputDebugStringA(x);
        }
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        WSTR        fsname[MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN];
        UCHAR       major, minor;
        NTSTATUS    errcode;

        if (QueryFileSystemName(DriveName,
                                fsname,
                                &major,
                                &minor,
                                &errcode)) {
            OutputDebugStringW(fsname);
            sprintf(x, "; Major %d; Minor %d; Errcode %d\n", major, minor, errcode);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryFileSystemName failed\n");
    }
#endif

#if 0 // test code for API within
    {
        STR         x[100];
        UCHAR       major, minor;

        if (QueryLatestFileSystemVersion(FileSystemName, &major, &minor)) {
            OutputDebugStringW(FileSystemName);
            sprintf(x, "; Major %d; Minor %d\n", major, minor);
            OutputDebugStringA(x);
        } else
            OutputDebugStringA("QueryLatestFileSystemVersion failed\n");
    }
#endif

    // Initialize the message object with the callback function.
    // Load the file system DLL.
    // Compute the NT style drive name.

    if (Param->Major != 1 ||
        Param->Minor != 0 ||
        !message.Initialize(Callback) ||
        !format_string.Initialize("FormatEx") ||
        !library_name.Initialize("U") ||
        !file_system_name.Initialize(FileSystemName) ||
        !ntfs_str.Initialize("NTFS") ||
        !ntfs_minus_str.Initialize("NTFS-") ||
        !ntfs_previous_str.Initialize("NTFS 4.0") ||
        !ntfs_current_str.Initialize("NTFS 5.0") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !fat32_current_str.Initialize("FAT32 0.0")) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    if (file_system_name == ntfs_str) {
        rst = TRUE;
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_minus_str) {
        rst = FALSE; // file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == fat_str) {
        rst = TRUE;
        backward_compatible = TRUE;
    } else if (file_system_name == fat32_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == fat32_current_str) {
        rst = file_system_name.Initialize("FAT");
        backward_compatible = FALSE;
    } else if (file_system_name == ntfs_previous_str) {
        rst = FALSE; // file_system_name.Initialize("NTFS");
        backward_compatible = TRUE;
    } else if (file_system_name == ntfs_current_str) {
        rst = file_system_name.Initialize("NTFS");
        backward_compatible = FALSE;
    } else
        rst = FALSE;

    if (!rst ||
        !library_name.Strcat(&file_system_name) ||
        !(format_function = (FORMATEX_FN)
            SYSTEM::QueryLibraryEntryPoint(&library_name,
                                           &format_string,
                                           &dll_handle)) ||
        !dosdrivename.Initialize(DriveName) ||
        !label_string.Initialize(Param->LabelString) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }

    // Disable hard-error popups.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

#if defined(FE_SB) && defined (_X86_)
    UCHAR       FirstByte;

    if (ConvertSectorSizeIfNeeded(&ntdrivename, MediaType, &FirstByte, &message) == FALSE) {

        SYSTEM::FreeLibraryHandle(dll_handle);

        finished_info.Success = FALSE;
        Callback(FmIfsFinished,
                 sizeof(FMIFS_FINISHED_INFORMATION),
                 &finished_info);
        return;
    }
#endif // FE_SB && _X86_

#if ((FMIFS_FORMAT_QUICK != FORMAT_QUICK) || \
     (FMIFS_FORMAT_BACKWARD_COMPATIBLE != FORMAT_BACKWARD_COMPATIBLE) || \
     (FMIFS_FORMAT_FORCE != FORMAT_FORCE))

#error FMIFS_FORMAT_* definition must be the same as that of CHKDSK_*

#endif

    param.Major = 1;
    param.Minor = 0;
    param.Flags = Param->Flags |
                  (backward_compatible ? FORMAT_BACKWARD_COMPATIBLE : 0);
    param.LabelString = &label_string;
    param.ClusterSize = Param->ClusterSize;

    // Call format.

    result = format_function(&ntdrivename,
                             &message,
                             &param,
                             ComputeNtMediaType(MediaType));

#if defined(FE_SB) && defined (_X86_)
    if (!result && FirstByte)
    RevertToOriginalSectorSize(&ntdrivename, FirstByte);
#endif // FE_SB && _X86_

    // Enable hard-error popups.
    SetErrorMode( OldErrorMode );

    SYSTEM::FreeLibraryHandle(dll_handle);

    finished_info.Success = result;
    Callback(FmIfsFinished,
             sizeof(FMIFS_FINISHED_INFORMATION),
             &finished_info);
}


BOOLEAN
EnableVolumeCompression(
    IN  PWSTR               DriveName,
    IN  USHORT              CompressionFormat
    )
/*++

Routine Description:

    This sets the compression attribute on the root directory of an NTFS volume.
    Note that the compression state of any files already contained on the
    volume is not affected.

Arguments:

    DriveName          - Supplies the drive name.
                         Expects a string like "C:\".

    CompressionFormat  - COMPRESSION_FORMAT_NONE      = Uncompressed.
                         COMPRESSION_FORMAT_DEFAULT   = Default compression.
                         COMPRESSION_FORMAT_LZNT1     = Use LZNT1 compression format.
                         (as defined in NTRTL.H)

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
   HANDLE hFile;
   BOOLEAN bStatus = FALSE;

   //
   // Don't even try if no drive name provided.
   //
   if (DriveName[0])
   {
      //
      //  Try to open the root directory - READ_DATA | WRITE_DATA.
      //
      if ((hFile = CreateFile(DriveName,
                              FILE_READ_DATA | FILE_WRITE_DATA,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_BACKUP_SEMANTICS,
                              NULL )) != INVALID_HANDLE_VALUE)
      {
          ULONG Length = 0;

          if (DeviceIoControl( hFile,
                 FSCTL_SET_COMPRESSION,
                 &CompressionFormat,
                 sizeof(CompressionFormat),
                 NULL,
                 0,
                 &Length,
                 NULL))
          {
              //
              //  Successfully set compression on root directory.
              //
              bStatus = TRUE;
          }
          CloseHandle(hFile);
      }
   }
   return bStatus;
}

BOOLEAN
QuerySupportedMedia(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray,
    IN  ULONG               NumberOfArrayEntries,
    OUT PULONG              NumberOfMediaTypes
    )
/*++

Routine Description:

    This routine computes a list of the supported media types for
    the given drive.

    If NULL is passed for the array then 'NumberOfMediaTypes'
    is filled in with the correct number.

Arguments:

    DriveName               - Supplies the drive name.
    MediaTypeArray          - Returns the supported media types.
    NumberOfArrayEntries    - Supplies the number of entries in
                                'MediaTypeArray'.
    NumberOfMediaTypes      - Returns the number of media types
                                returned in the media type array.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING             dosdrivename, ntdrivename;
    DP_DRIVE            dpdrive;
    PCDRTYPE            nt_media_types;
    INT                 num_types;
    ULONG               i, j;
    FMIFS_MEDIA_TYPE    tmp;

    if (!dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        return FALSE;
    }

    if (!dpdrive.Initialize(&ntdrivename)) {
        SetLastError(RtlNtStatusToDosError(dpdrive.QueryLastNtStatus()));
        return FALSE;
    }

    if (!(nt_media_types = dpdrive.GetSupportedList(&num_types))) {
        return FALSE;
    }

    if (!MediaTypeArray) {
        *NumberOfMediaTypes = num_types;
        return TRUE;
    }

    *NumberOfMediaTypes = min(NumberOfArrayEntries, (ULONG)num_types);

    for (i = 0; i < *NumberOfMediaTypes; i++) {
        MediaTypeArray[i] = ComputeFmMediaType(nt_media_types[i].MediaType);
    }

#ifndef FE_SB // JAPAN && i386
    //
    // NT-US diaplays the dialog box by MediaType order.
    // The MediaType order matches media size order on NT-US.
    // But PC98 has more media_types than US one.
    // And these does NOT match on PC98.
    // We wish to display the dialog box by size order.
    // See also..
    //   \nt\private\utils\ifsutil\src\drive.cxx
    //   DP_DRIVE::Initialize
    //
    for (i = 0; i < *NumberOfMediaTypes; i++) {
        for (j = 0; j < *NumberOfMediaTypes - 1; j++) {
            if (MediaTypeArray[j] < MediaTypeArray[j + 1]) {
                tmp = MediaTypeArray[j];
                MediaTypeArray[j] = MediaTypeArray[j + 1];
                MediaTypeArray[j + 1] = tmp;
            }
        }
    }
#endif

    return TRUE;
}

BOOLEAN
QueryAvailableFileSystemFormat(
    IN     ULONG            Index,
    OUT    PWSTR            FileSystemName,
    OUT    PUCHAR           MajorVersion,
    OUT    PUCHAR           MinorVersion,
    OUT    PBOOLEAN         Latest
)
/*++

Routine Description:

    This routine returns file system that the Format()
    and FormatEx() routines know how to format.

Arguments:

    Index                   - Supplies the index like 0, 1, 2, etc.
    FileSystemName          - Returns the name of the file system (FAT, NTFS, FAT32)
    MajorVersion            - Returns the major version number of the FS.
    MinorVersion            - Returns the minor version number of the FS.
    Latest                  - Returns TRUE if the return FS info is the latest one.

    Note that length of FileSystemName should be long enough to hold the
    return string.  The maximum length is MAX_FILE_SYSTEM_FORMAT_NAME_LEN.


Return Value:

    N/A

--*/
{
    if (Index >= sizeof(fsFormatAvailable)/sizeof(FILE_SYSTEM_FORMAT_RECORD))
        return FALSE;

    if (!FileSystemName || !MajorVersion || !MinorVersion || !Latest)
        return FALSE;

    memcpy(FileSystemName,
           fsFormatAvailable[Index].FileSystemName,
           sizeof(WCHAR)*(wcslen(fsFormatAvailable[Index].FileSystemName)+1));

    *MajorVersion = fsFormatAvailable[Index].MajorVersion;
    *MinorVersion = fsFormatAvailable[Index].MinorVersion;
    *Latest = fsFormatAvailable[Index].Latest;

    return TRUE;
}

BOOLEAN
QueryFileSystemName(
    IN  PWSTR        DriveName,
    OUT PWSTR        FileSystemName,
    OUT PUCHAR       MajorVersion,
    OUT PUCHAR       MinorVersion,
    OUT PNTSTATUS    ErrorCode
)
/*++

Routine Description:

    This routine returns the file system format on the specified drive.

Arguments:

    DriveName               - Supplies the DOS style drive name
    FileSystemName          - Returns the name of the file system (FAT, NTFS, FAT32)
    MajorVersion            - Returns the major version number of the FS.
    MinorVersion            - Returns the minor version number of the FS.
    ErrorCode               - Returns the error code if the routine returns FALSE.

    Note that length of FileSystemName should be long enough to hold the
    return string.  The maximum length is MAX_FILE_SYSTEM_FORMAT_NAME_LEN.

Return Value:

    TRUE  - Success
    FALSE - Failure

--*/
{
    DSTRING         dos_drive_name, nt_drive_name;
    DSTRING         file_system_name;
    DSTRING         file_system_name_and_version;
    DSTRING         fat_str, fat32_str, ntfs_str;
    PWSTR           fs_name_and_version;

    if (!ErrorCode || !MinorVersion || !MajorVersion ||
        !FileSystemName || !DriveName) {
        if (ErrorCode)
            *ErrorCode = 0;
        return FALSE;
    }

    *ErrorCode = 0;

    if (!fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !ntfs_str.Initialize("NTFS") ||
        !dos_drive_name.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dos_drive_name, &nt_drive_name) ||
        !IFS_SYSTEM::QueryFileSystemName(&nt_drive_name,
                                         &file_system_name,
                                         ErrorCode,
                                         &file_system_name_and_version))
        return FALSE;

    *ErrorCode = 0;

    file_system_name.QueryWSTR(0, TO_END, FileSystemName,
                               MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN);
    if (file_system_name == fat_str) {
        *MajorVersion = *MinorVersion = 0;
    } else if (file_system_name == fat32_str) {
        *MajorVersion = *MinorVersion = 0;
    } else if (file_system_name == ntfs_str) {
        if (file_system_name_and_version == file_system_name) {
            *MajorVersion = (UCHAR)0;
            *MinorVersion = (UCHAR)0;
            return TRUE;
        }
        fs_name_and_version = file_system_name_and_version.QueryWSTR();
        if (!fs_name_and_version)
            return FALSE;

        DWORD dwMajor, dwMinor;

        if (swscanf(fs_name_and_version,
                    L"NTFS %d.%d",
                    &dwMajor,
                    &dwMinor ) != 2) {
            FREE(fs_name_and_version);
            return FALSE;
        } else {
            *MajorVersion = (UCHAR)dwMajor;
            *MinorVersion = (UCHAR)dwMinor;
        }
        FREE(fs_name_and_version);
    } else {
        DebugAbort("Unknown file system\n");
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
QueryLatestFileSystemVersion(
    IN  PWSTR   FileSystemName,
    OUT PUCHAR  MajorVersion,
    OUT PUCHAR  MinorVersion
)
/*++

Routine Description:

    Given the file system, this routine returns the latest
    major and minor version of that file system.

Arguments:

    FileSystemName          - Supplies the name of the file system (FAT, NTFS, FAT32)
    MajorVersion            - Returns the major version number of the FS.
    MinorVersion            - Returns the minor version number of the FS.

Return Value:

    TRUE  - Success
    FALSE - Failure

--*/
{
    BOOLEAN latest;
    ULONG   i;
    WCHAR   fsname[MAX_FILE_SYSTEM_FORMAT_NAME_LEN];

    if (!FileSystemName || !MajorVersion || !MinorVersion)
        return FALSE;

    for(i=0;
        QueryAvailableFileSystemFormat(i,
                                       fsname,
                                       MajorVersion,
                                       MinorVersion,
                                       &latest);
        i++) {
        if (wcscmp(fsname, FileSystemName) == 0 && latest) {
            return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
QueryDeviceInformation(
    IN     PWSTR                                DriveName,
       OUT PFMIFS_DEVICE_INFORMATION            DevInfo,
    IN     ULONG                                DevInfoSize
    )
/*++

Routine Description:

    This routine returns the attributes of a device.

Arguments:

    DriveName               - Supplies the drive name.
    DevInfo                 - Returns the device information.
    DevInfoSize             - Supplies the size of the device info structure.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DP_DRIVE            dpdrive;
    DSTRING             dosdrivename, ntdrivename;

    if (!dosdrivename.Initialize(DriveName) ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {

        return FALSE;
    }

    if (!dpdrive.Initialize(&ntdrivename)) {
        return FALSE;
    }

    if (DevInfoSize < sizeof(FMIFS_DEVICE_INFORMATION)) {
        return FALSE;
    }

    DevInfo->Flags = (dpdrive.IsSonyMS() ? (FMIFS_SONY_MS | FMIFS_NTFS_NOT_SUPPORTED) : 0);
    DevInfo->Flags |= (dpdrive.IsSonyMSFmtCmdCapable() ? FMIFS_SONY_MS_FMT_CMD_CAPABLE : 0);
    DevInfo->Flags |= (dpdrive.IsSonyMSProgressIndicatorCapable() ? FMIFS_SONY_MS_PROGRESS_INDICATOR_CAPABLE : 0);
    DevInfo->Flags |= (dpdrive.IsNtfsNotSupported() ? FMIFS_NTFS_NOT_SUPPORTED : 0);

    return TRUE;
}

BOOLEAN
QueryDeviceInformationByHandle(
    IN     HANDLE                               DriveHandle,
       OUT PFMIFS_DEVICE_INFORMATION            DevInfo,
    IN     ULONG                                DevInfoSize
    )
/*++

Routine Description:

    This routine returns the attributes of a device.

Arguments:

    DriveHandle             - Supplies the handle to the volume.
    DevInfo                 - Returns the device information.
    DevInfoSize             - Supplies the size of the device info structure.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    CURRENTLY, THIS ROUTINE ONLY RETURNS THE FMIFS_NTFS_NOT_SUPPORTED FLAG AND
    DOES NOT WORK ON MEMORY STICK.  IF FMIFS_NTFS_NOT_SUPPORTED IS NOT SET ON RETURN,
    USER SHOULD CALL QueryDeviceInformation() AS WELL.

--*/
{
    BOOLEAN     NoNtfsSupport;
    NTSTATUS    status;

    if (DevInfoSize < sizeof(FMIFS_DEVICE_INFORMATION)) {
        return FALSE;
    }

    status = DP_DRIVE::QueryNtfsSupportInfo(DriveHandle, &NoNtfsSupport);

    if (NT_SUCCESS(status)) {
        DevInfo->Flags = (NoNtfsSupport ? FMIFS_NTFS_NOT_SUPPORTED : 0);
    }

    return NT_SUCCESS(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fmifs\src\fmifs.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    fmifs.cxx

Abstract:

        This module contains run-time, global support for the
    FM IFS Utilities library (FMIFS).   This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

    Norbert P. Kusters (norbertk) 30-May-1991

Environment:

        User Mode

Notes:

--*/

#include "ulib.hxx"


//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C" BOOLEAN
InitializeFmIfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        );

BOOLEAN
InitializeFmIfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        )
/*++

Routine Description:

    Initialize FmIfs by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    static ULONG    count = 0;

    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrintTrace(("FMIFS.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

#if defined(TRACE_FMIFS_MEM_LEAK)
            DebugPrint("FMIFS.DLL got attached.\n");
#endif

            if (!DefineClassDescriptors() ) {
                UndefineClassDescriptors();
                DebugAbort( "FmIfs initialization failed!!!\n" );
                return( FALSE );
            }
            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrintTrace(("FMIFS.DLL got detached.  %d time(s) left.", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrint("FMIFS.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_FMIFS_MEM_LEAK)
                DebugPrint("FMIFS.DLL detached more than attached\n");
#endif
            }
            break;
    }
    return TRUE;
}



DECLARE_CLASS(  FMIFS_MESSAGE           );
DECLARE_CLASS(  FMIFS_CHKMSG            );

STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
    if( DEFINE_CLASS_DESCRIPTOR(    FMIFS_MESSAGE           )
     && DEFINE_CLASS_DESCRIPTOR(    FMIFS_CHKMSG            )
        ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR(    FMIFS_MESSAGE           );
    UNDEFINE_CLASS_DESCRIPTOR(    FMIFS_CHKMSG            );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\format\format.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

        format.cxx

Abstract:

        Utility to format a disk

Author:

        Norbert P. Kusters (norbertk) 12-April-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "drive.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "system.hxx"
#include "ifssys.hxx"
#include "ulibcl.hxx"
#include "ifsentry.hxx"
#include "path.hxx"
#include "parse.hxx"
#include "hmem.hxx"
#include "volume.hxx"

extern "C" {
    #include "nturtl.h"
}

VOID
DisplayFormatUsage(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine outputs usage information on format.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    None.

--*/
{
    Message->Set(MSG_FORMAT_INFO);
    Message->Display("");
    Message->Set(MSG_FORMAT_COMMAND_LINE_1);
    Message->Display("");
    Message->Set(MSG_FORMAT_COMMAND_LINE_2);
    Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    if(!IsPC98_N()) {
#endif
        Message->Set(MSG_FORMAT_COMMAND_LINE_3);
        Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    }
#endif
    Message->Set(MSG_FORMAT_COMMAND_LINE_4);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_V);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_Q);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_C);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_X);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_F);
    Message->Display("");
//    Message->Set(MSG_FORMAT_SUPPORTED_SIZES);
//    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_T);
    Message->Display("");
    Message->Set(MSG_FORMAT_SLASH_N);
    Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    if(!IsPC98_N()) {
#endif
//        Message->Set(MSG_FORMAT_SLASH_1);
//        Message->Display("");
//        Message->Set(MSG_FORMAT_SLASH_4);
//        Message->Display("");
//        Message->Set(MSG_FORMAT_SLASH_8);
//        Message->Display("");
#if defined(FE_SB) && defined(_X86_)
    }
#endif
}


BOOLEAN
DetermineMediaType(
    OUT     PMEDIA_TYPE     MediaType,
    IN OUT  PMESSAGE        Message,
    IN      BOOLEAN         Request160,
    IN      BOOLEAN         Request180,
    IN      BOOLEAN         Request320,
    IN      BOOLEAN         Request360,
    IN      BOOLEAN         Request720,
    IN      BOOLEAN         Request1200,
    IN      BOOLEAN         Request1440,
    IN      BOOLEAN         Request2880,
    IN      BOOLEAN         Request20800
#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.12.1994 SFT KMR
    // Add Request640 on to the parmeter of DetermineMediaType()
    // Add Request1232 on to the parmeter of DetermineMediaType()
   ,IN       BOOLEAN         Request256
   ,IN       BOOLEAN         Request640
   ,IN       BOOLEAN         Request1232
#endif
    )
/*++

Routine Description:

    This routine determines the media type to format to.

Arguments:

    MediaType       - Supplies the current media type and returns
                        a new media type.
    Message         - Supplies an outlet for messages.
    Request160      - Supplies whether or not the user wished to format 160.
    Request180      - Supplies whether or not the user wished to format 180.
    Request320      - Supplies whether or not the user wished to format 320.
    Request360      - Supplies whether or not the user wished to format 360.
    Request720      - Supplies whether or not the user wished to format 720.
    Request1200     - Supplies whether or not the user wished to format 1200.
    Request1440     - Supplies whether or not the user wished to format 1440.
    Request2880     - Supplies whether or not the user wished to format 2880.
    Request20800    - Supplies whether or not the use wished to format 20800.
#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.12.1994 SFT KMR
    Request256      - Supplies whether or not the user wished to format 256. --NEC--
    // Add Request640 on to the parmeter of DetermineMediaType()
    Request640      - Supplies whether or not the user wished to format 640.
    // Add Request1232 on to the parmeter of DetermineMediaType()
    Request1232      - Supplies whether or not the user wished to format 1232.
#endif

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    INT sum;

    // First, normalize all of the booleans.

    if (Request160) {
        Request160 = 1;
        *MediaType = F5_160_512;
    }

    if (Request180) {
        Request180 = 1;
        *MediaType = F5_180_512;
    }

#if defined(FE_SB) && (_X86_)
    if (Request256) {
        Request256 = 1;
        *MediaType = F8_256_128;
    }
#endif

    if (Request320) {
        Request320 = 1;
        *MediaType = F5_320_512;
    }

    if (Request360) {
        Request360 = 1;
        *MediaType = F5_360_512;
    }

#if defined(FE_SB) && (_X86_)
    if (Request640) {
        Request640 = 1;
        *MediaType = F5_640_512;
    }
#endif

    if (Request720) {
        Request720 = 1;
        *MediaType = F3_720_512;
    }

    if (Request1200) {
        Request1200 = 1;
        *MediaType = F5_1Pt2_512;
    }

#if defined(FE_SB) && (_X86_)
    if (Request1232) {
        Request1232 = 1;
        *MediaType = F5_1Pt23_1024;
    }
#endif

    if (Request1440) {
        Request1440 = 1;
        *MediaType = F3_1Pt44_512;
    }

    if (Request2880) {
        Request2880 = 1;
        *MediaType = F3_2Pt88_512;
    }

    if (Request20800) {
        Request20800 = 1;
        *MediaType = F3_20Pt8_512;
    }

    sum = Request160 +
          Request180 +
#if defined(FE_SB) && defined(_X86_)
          Request256 +
#endif
          Request320 +
          Request360 +
#if defined(FE_SB) && defined(_X86_)
          Request640 +
#endif
          Request720 +
          Request1200 +
#if defined(FE_SB) && defined(_X86_)
          Request1232 +
#endif
          Request1440 +
          Request2880 +
          Request20800;

    if (sum > 1) {

        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();
        return FALSE;
    }

    if (sum == 0) {
        *MediaType = Unknown;
    }

    return TRUE;
}

int __cdecl
main(
    )
/*++

Routine Description:

    This routine is the main procedure for format.  This routine
    parses the arguments, determines the appropriate file system,
    and invokes the appropriate version of format.

    The arguments accepted by format are:

        /fs:fs      - specifies file system to install on volume
        /v:label    - specifies a volume label.
        /q          - specifies a "quick" format.
        /c          - the file system is compressed.
        /f:size     - specifies the size of the floppy disk to format
        /t          - specifies the number of tracks per disk side
        /n          - specifies the number of sectors per track
        /1          - formats a single side of a floppy
        /4          - formats a 360K floppy in a high density drive
        /8          - formats eight sectors per track
        /backup     - refrain from prompting the user

Arguments:

    None.

Return Value:

    0   - Success.
    1   - Failure.
    4   - Fatal error
    5   - User pressed N to stop formatting

--*/
{
    STREAM_MESSAGE      msg;
    PMESSAGE            message;
    MEDIA_TYPE          media_type, cmd_line_media_type;
    DSTRING             dosdrivename;
    DSTRING             displaydrivename;
    DSTRING             arg_fsname;
    DSTRING             arg_label;
    BOOLEAN             label_spec;
    BOOLEAN             quick_format;
    BOOLEAN             compressed;
    BOOLEAN             force_mode;
    INT                 errorlevel;
    DSTRING             ntdrivename;
    DSTRING             fsname;
    DSTRING             fsNameAndVersion;
    DSTRING             currentdrive;
    DSTRING             raw_str;
    DSTRING             fat_str;
    DSTRING             fat32_str;
    DSTRING             ntfs_str;
    DSTRING             hpfs_str;
    PWSTRING            old_volume_label = NULL;
    PATH                dos_drive_path;
    VOL_SERIAL_NUMBER   old_serial;
    DSTRING             user_old_label;
    DSTRING             null_string;
    BOOLEAN             do_format;
    BOOLEAN             do_floppy_return;
    DSTRING             LibSuffix;
    DSTRING             LibraryName;
    HANDLE              FsUtilityHandle = NULL;
    DSTRING             FormatString;
    FORMATEX_FN         Format = NULL;
    DRIVE_TYPE          drive_type;
    BIG_INT             bigint;
    NTSTATUS            Status;
    DWORD               OldErrorMode;
    ULONG               cluster_size;
    BOOLEAN             no_prompts;
    BOOLEAN             force_dismount;
    BOOLEAN             old_fs = TRUE;
    FORMATEX_FN_PARAM   Param;
    BOOLEAN             writeable;

#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.14.1994 SFT KMR
    // Add the value to use the process to judge for 5inci or 3.5inch

    PCDRTYPE            nt_media_types;
    INT                 num_types;
    INT                 i;
    // FMR Oct.07.1994 SFT YAM
    // Add the flag check whether unformat-disk.
    INT             Unknown_flag = FALSE;

    InitializeMachineData();
#endif

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {
        return 4;
    }

    if( !null_string.Initialize( "" ) ) {
        return 4;
    }

    if (!ParseArguments(&msg, &cmd_line_media_type, &dosdrivename, &displaydrivename,
                        &arg_label, &label_spec, &arg_fsname, &quick_format,
                        &force_mode, &cluster_size, &compressed, &no_prompts,
                        &force_dismount, &errorlevel )) {

        return errorlevel;
    }

    if (force_mode) {
        force_dismount = TRUE;  // don't ask the user; just do it
        if (!label_spec) {      // if no label is specified, assume it's empty
            if (!arg_label.Initialize("")) {
                return 4;
            }
            label_spec = TRUE;
        }
    }

    message = &msg;

    if (!hpfs_str.Initialize("HPFS")) {
        return 4;
    }

    if (arg_fsname == hpfs_str) {
        message->Set(MSG_HPFS_NO_FORMAT);
        message->Display("");
        return 1;
    }

    // Disable popups while we determine the drive type.
    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    drive_type = SYSTEM::QueryDriveType(&dosdrivename);

    // Re-enable harderror popups.
    SetErrorMode( OldErrorMode );

    switch (drive_type) {
        case UnknownDrive:
            message->Set(MSG_NONEXISTENT_DRIVE);
            message->Display("");
            return 1;

        case RemoteDrive:
            message->Set(MSG_FORMAT_NO_NETWORK);
            message->Display("");
            return 1;

        case RamDiskDrive:
            message->Set(MSG_FORMAT_NO_RAMDISK);
            message->Display("");
            return 1;

        default:
            break;

    }

    if (!SYSTEM::QueryCurrentDosDriveName(&currentdrive) ||
        currentdrive == dosdrivename) {

        message->Set(MSG_CANT_LOCK_CURRENT_DRIVE);
        message->Display();
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdrivename, &ntdrivename)) {
        return 4;
    }

    if (!raw_str.Initialize("RAW") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32") ||
        !ntfs_str.Initialize("NTFS")) {

        return 4;
    }

    for (;;) {

        DP_DRIVE    dpdrive;

        // ------------------------------------
        // Figure out if the drive is a floppy.
        // ------------------------------------

        if (drive_type == FixedDrive && cmd_line_media_type != Unknown) {
            message->Set(MSG_INCOMPATIBLE_PARAMETERS_FOR_FIXED);
            message->Display("");
            return 1;
        }

        if (drive_type == RemovableDrive && !no_prompts) {
            message->Set(MSG_INSERT_DISK);
            message->Display("%W", &displaydrivename);
            message->Set(MSG_PRESS_ENTER_WHEN_READY);
            message->Display("");
            message->WaitForUserSignal();
        }




        // -----------------------
        // Now get the media type.
        // -----------------------

        // Disable hard-error popups while we initialize the drive.
        // Otherwise, we'll may get the 'unformatted medium' popup,
        // which doesn't make a lot of sense.

        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        if (!dpdrive.Initialize(&ntdrivename, message)) {
            // Re-enable hard-error popups
            SetErrorMode( OldErrorMode );

            return 4;
        }

#if defined(FE_SB) && defined(_X86_)
        // FMR Oct.07.1994 SFT YAM
        // Add the check whether unformat-disk.
        if(dpdrive.QueryMediaType()==Unknown) {
            Unknown_flag = TRUE;
        }

        // FMR Jul.14.1994 SFT KMR
        // Add the process to judge for 5inch or 3.5inch
        // FMR is surport 3.5/5 inch disk drive. System default 2HD.
        // Return 3.5 or 5inch type media. driver used.
        // Search drive list on media type.

        // FJMERGE.16 95/07/13 J.Yamamoto 3mode PC/AT uses.
        //if (IsFMR_N() || IsPC98_N()) {
            if (!(nt_media_types = dpdrive.GetSupportedList(&num_types))) {
                return 4;
            }
            for (i = 0; i < num_types; i++) {
                if ( nt_media_types[i].MediaType == cmd_line_media_type) break;
            }
           if (i == num_types) {
                MEDIA_TYPE alt_media_type;

                switch(cmd_line_media_type) {
                    case F5_1Pt23_1024:
                        alt_media_type = F3_1Pt23_1024;
                        break;
                    case F3_1Pt23_1024:
                        alt_media_type = F5_1Pt23_1024;
                        break;
                    case F5_1Pt2_512:
                        alt_media_type = F3_1Pt2_512;
                        break;
                    case F3_1Pt2_512:
                        alt_media_type = F5_1Pt2_512;
                        break;
                    case F3_720_512:
                        alt_media_type = F5_720_512;
                        break;
                    case F5_720_512:
                        alt_media_type = F3_720_512;
                        break;
                    case F5_640_512:
                        alt_media_type = F3_640_512;
                        break;
                    case F3_640_512:
                        alt_media_type = F5_640_512;
                        break;
                    default:
                        alt_media_type = Unknown;
                        break;
                }
                for (i = 0; i < num_types; i++) {
                    if ( nt_media_types[i].MediaType == alt_media_type){
                        cmd_line_media_type = alt_media_type;
                        break;
                    }
                }
            }
        // FJMERGE.16 95/07/13 J.Yamamoto
        //}
#endif

        // Re-enable hard-error popups
        SetErrorMode( OldErrorMode );

        if (cmd_line_media_type == Unknown) {
            media_type = dpdrive.QueryMediaType();
        } else {
            media_type = cmd_line_media_type;
        }

        if (media_type == Unknown) {

            media_type = dpdrive.QueryRecommendedMediaType();

            if (media_type == Unknown) {
                // This should never happen.
                DebugPrint("No media types supported by this device.\n");
                return 4;
            }
        }

        do_floppy_return = dpdrive.IsFloppy();

        // Disable hard error popups.  This will prevent the file system
        // from throwing up the popup that says 'unformatted medium'.

        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        if (!IFS_SYSTEM::QueryFileSystemName(&ntdrivename, &fsname,
                                             &Status, &fsNameAndVersion)) {

            if( Status == STATUS_ACCESS_DENIED ) {

                message->Set( MSG_DASD_ACCESS_DENIED );
                message->Display( "" );

            } else {

                message->Set( MSG_FS_NOT_DETERMINED );
                message->Display( "%W", &displaydrivename );
            }

            // Re-enable hard error popups.
            SetErrorMode( OldErrorMode );

            return 1;
        }

        // Re-enable hard error popups.
        SetErrorMode( OldErrorMode );

        if (!fsname.Strupr()) {
            message->Set(MSG_FS_NOT_DETERMINED);
            message->Display("%W", &displaydrivename);
            return 4;
        }

        if (drive_type == CdRomDrive) {
            if (0 == ntfs_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                          &arg_fsname : &fsname )) {
                message->Set(MSG_FMT_NO_NTFS_ALLOWED);
                message->Display();
                return 1;
            }
        }

        if (dpdrive.IsSonyMS() || dpdrive.IsNtfsNotSupported()) {
            if (0 == ntfs_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                       &arg_fsname : &fsname )) {
                message->Set(dpdrive.IsSonyMS() ?
                              MSG_FMT_NO_NTFS_ALLOWED :
                              MSG_FMT_NTFS_NOT_SUPPORTED);
                message->Display();
                return 1;
            }
        }

        if (dpdrive.IsSonyMS()) {

            if (cmd_line_media_type == F3_1Pt44_512) {
                message->Set(MSG_FMT_INVALID_SLASH_F_OPTION);
                message->Display();
                return 1;
            }

            if (0 == fat32_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                       &arg_fsname : &fsname )) {
                message->Set(MSG_FMT_NO_FAT32_ALLOWED);
                message->Display();
                return 1;
            }

            if (dpdrive.IsFloppy()) {  // no hw to test this on
                message->Set(MSG_FMT_SONY_MEM_STICK_ON_FLOPPY_NOT_ALLOWED);
                message->Display();
                return 1;
            }
        }

        message->Set(MSG_FILE_SYSTEM_TYPE);
        message->Display("%W", &fsname);

        //
        // If compression is requested, make sure we can compress the
        // indicated file system type (or the current filesystem type,
        // if the user didn't specify one). Compression is not supported
        // for 64k-cluster NTFS volumes.
        //

        if (compressed) {
            if (0 != ntfs_str.Stricmp( 0 != arg_fsname.QueryChCount() ?
                                      &arg_fsname : &fsname )) {

                message->Set(MSG_COMPRESSION_NOT_AVAILABLE);
                message->Display("%W", 0 != arg_fsname.QueryChCount() ?
                                      &arg_fsname : &fsname );
                return 1;
            }
            if (cluster_size > 4096) {
                message->Set(MSG_CANNOT_COMPRESS_HUGE_CLUSTERS);
                message->Display();
                return 1;
            }
        }

        //
        // Determine which IFS library to load.  The IFS
        // utilities for file system xxxx reside in Uxxxx.DLL.
        // If the use specified the file system with the /FS:
        // parameter, use that file system; otherwise, take
        // whatever's already on the disk (returned from
        // SYSTEM::QueryFileSystemName).
        //

        if( !LibraryName.Initialize( "U" ) ) {

                return 4;
        }

        if (!LibSuffix.Initialize(arg_fsname.QueryChCount() ?
                                  &arg_fsname : &fsname) ||
            !LibSuffix.Strupr()) {
            return 4;
        }

        if (LibSuffix == ntfs_str)
            old_fs = FALSE;

        if (fsname != LibSuffix) {
            message->Set(MSG_NEW_FILE_SYSTEM_TYPE);
            message->Display("%W", &LibSuffix);
        } else if (fsname == raw_str) {
            if (dpdrive.IsFloppy()) {
                if (!LibSuffix.Initialize(&fat_str)) {
                    return 4;
                }
                message->Set(MSG_NEW_FILE_SYSTEM_TYPE);
                message->Display("%W", &LibSuffix);
            } else {
                message->Set(MSG_FORMAT_PLEASE_USE_FS_SWITCH);
                message->Display("");
                return 1;
            }
        }

        if (LibSuffix == fat32_str) {

            if(!LibSuffix.Initialize("FAT")) {
                return 4;
            }
            old_fs = FALSE;
        }

        if ( !LibraryName.Strcat( &LibSuffix ) ) {

                return 4;
        }

        if( !FormatString.Initialize( "FormatEx" ) ) {

                return 4;
        }

        if( (Format =
             (FORMATEX_FN)SYSTEM::QueryLibraryEntryPoint( &LibraryName,
                                                          &FormatString,
                                                          &FsUtilityHandle )) ==
             NULL ) {

            message->Set( MSG_FS_NOT_SUPPORTED );
            message->Display( "%s%W", "FORMAT", &LibSuffix );
            message->Set( MSG_BLANK_LINE );
            message->Display( "" );
            return 1;
        }


        if (drive_type != RemovableDrive) {

            // If the volume has a label, prompt the user for it.
            // Note that if we can't get the label, we'll treat it
            // as without a label (since we have to handle unformatted
            // volumes).

            OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

            if( !force_mode &&
                dos_drive_path.Initialize( &dosdrivename) &&
                (old_volume_label =
                    SYSTEM::QueryVolumeLabel( &dos_drive_path,
                                              &old_serial )) != NULL &&
                old_volume_label->Stricmp( &null_string ) != 0 ) {

                // This fixed drive has a label.  To give the user
                // a bit more protection, prompt for the old label:

                message->Set( MSG_ENTER_CURRENT_LABEL );
                message->Display( "%W", &displaydrivename );
                message->QueryStringInput( &user_old_label );

                if( old_volume_label->Stricmp( &user_old_label ) != 0 ) {

                    // Re-enable hard error popups.
                    SetErrorMode( OldErrorMode );

                    message->Set( MSG_WRONG_CURRENT_LABEL );
                    message->Display( "" );

                    DELETE( old_volume_label );

                    return 1;
                }
            }

            // Re-enable hard error popups.
            SetErrorMode( OldErrorMode );

            DELETE( old_volume_label );
            old_volume_label = NULL;
            if (!force_mode) {
                message->Set(MSG_WARNING_FORMAT);
                message->Display("%W", &displaydrivename);
                if (!message->IsYesResponse(FALSE)) {
                    return 5;
                }
            }
        }

        // ------------------------------------
        // Print the formatting <size> message.
        // ------------------------------------

        do_format = (BOOLEAN) (media_type != dpdrive.QueryMediaType());

        switch (media_type) {
            case F5_160_512:
            case F5_180_512:
            case F5_320_512:
            case F5_360_512:
            case F3_720_512:
#if defined (FE_SB) && defined(_X86_)
            // FMR Jul.12.1994 SFT KMR
            // Modify the process to be display
            // when formating 640KB and 5inch's 720KB disk
            case F8_256_128:
            case F5_640_512:
            case F3_640_512:
            case F5_720_512:
#endif
                if (quick_format) {
                    message->Set(MSG_QUICKFORMATTING_KB);
                } else if (do_format) {
                    message->Set(MSG_FORMATTING_KB);
                } else {
                    message->Set(MSG_VERIFYING_KB);
                }
                break;

            case F5_1Pt2_512:
            case F3_1Pt44_512:
            case F3_2Pt88_512:
            case F3_20Pt8_512:
#if defined(FE_SB) && defined(_X86_)
            // FMR Jul.12.1994 SFT KMR
            // Modify the process to be display
            // when formating 1.20/1.23MB disk
            case F3_1Pt2_512:
            case F5_1Pt23_1024:
            case F3_1Pt23_1024:
#endif
                if (quick_format) {
                    message->Set(MSG_QUICKFORMATTING_DOT_MB);
                } else if (do_format) {
                    message->Set(MSG_FORMATTING_DOT_MB);
                } else {
                    message->Set(MSG_VERIFYING_DOT_MB);
                }
                break;

            case RemovableMedia:
            case FixedMedia:
            case F3_120M_512:
            case F3_200Mb_512:
            case F3_240M_512:
#if defined(FE_SB) // main():OpticalDisk support
            case F3_128Mb_512:
            case F3_230Mb_512:
#endif
                if (quick_format) {
                    message->Set(MSG_QUICKFORMATTING_MB);
                } else if (do_format) {
                    message->Set(MSG_FORMATTING_MB);
                } else {
                    message->Set(MSG_VERIFYING_MB);
                }
                break;

            case F5_320_1024:
            case Unknown:
                // This can't happen.
                return 4;
        }

        switch (media_type) {
            case F5_160_512:
                message->Display("%d", 160);
                break;

            case F5_180_512:
                message->Display("%d", 180);
                break;

#if defined(FE_SB) && defined(_X86_)
            case F8_256_128:
                message->Display("%d", 256);
                break;
#endif

            case F5_320_512:
                message->Display("%d", 320);
                break;

            case F5_360_512:
                message->Display("%d", 360);
                break;

            case F3_720_512:
#if defined(FE_SB) && defined(_X86_)
            case F5_720_512:
#endif
                message->Display("%d", 720);
                break;

            case F5_1Pt2_512:
#if defined(FE_SB) && defined(_X86_)
            case F3_1Pt2_512:
#endif
                message->Display("%d%d", 1, 2);
                break;

            case F3_1Pt44_512:
                message->Display("%d%d", 1, 44);
                break;

            case F3_2Pt88_512:
                message->Display("%d%d", 2, 88);
                break;

            case F3_20Pt8_512:
                message->Display("%d%d", 20, 8);
                break;

            case RemovableMedia:
            case FixedMedia:
            case F3_120M_512:
            case F3_200Mb_512:
            case F3_240M_512:
#if defined(FE_SB) // main():Optical Disk support
            case F3_128Mb_512:
            case F3_230Mb_512:
#endif
                bigint = dpdrive.QuerySectors()*
                         dpdrive.QuerySectorSize()/
                         1048576;

                DebugAssert(bigint.GetHighPart() == 0);

                message->Display("%d", bigint.GetLowPart());
                break;

            case F5_320_1024:
            case Unknown:
                // This can't happen.
                return 4;

#if defined(FE_SB) && defined(_X86_)
            case F5_640_512:
            case F3_640_512:
                message->Display("%d", 640);
                break;

            case F5_1Pt23_1024:
            case F3_1Pt23_1024:
                if (IsPC98_N()){
                    message->Display("%d%d", 1, 25);
                }
                else{
                    message->Display("%d%d", 1, 23);
                }
                break;
#endif
        }

#if defined (FE_SB) && defined (_X86_)
        // FMR Oct.07.1994 SFT YAM
        // If the sector-size when the last format differ from next format,
        // initialize a hard one-byte of disk.
        // at this time,if next formated disk is unformat-disk,
        // this process is undone.

        ULONG       old_sec_size;
        ULONG       new_sec_size;
        HMEM        hmem;
        PUCHAR      rw_buff;
        LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;
        UCHAR       FirstByte = 0;

        if ((IsPC98_N() && drive_type == FixedDrive) ?
            !hmem.Acquire(dpdrive.QuerySectorSize(), max(dpdrive.QueryAlignmentMask(), dpdrive.QuerySectorSize()-1)) :
            !hmem.Acquire(dpdrive.QuerySectorSize(), dpdrive.QueryAlignmentMask())) {
            message->Set(MSG_INSUFFICIENT_MEMORY);
            message->Display();
            return 1;
        }
        rw_buff = (PUCHAR)hmem.GetBuf();

        if(drive_type == RemovableDrive && !no_prompts) {
            if(Unknown_flag == FALSE) {
                old_sec_size = dpdrive.QuerySectorSize();

                if(cmd_line_media_type == F5_1Pt23_1024 || cmd_line_media_type == F3_1Pt23_1024) {
                    new_sec_size = 1024;
                }
                else {
                    new_sec_size = 512;
                }

                if(new_sec_size != old_sec_size) {
                    // PC98 Sep.25.1995 UPDATE
                    // When LDpDrive is fales to initialize,
                    // we don't have to use LDpDrive.
                    if( LDpDrive->Initialize(&ntdrivename,message,TRUE)){
                        LDpDrive->Read(0,1,rw_buff);
                        FirstByte = rw_buff[0];
                        rw_buff[0] = 0;
                        LDpDrive->Write(0,1,rw_buff);
                    }
                }
            }
        }
        else {
            if (IsFMR_N()) {
                if(LibSuffix.Stricmp(&fsname)) {
                    LDpDrive->Initialize(&ntdrivename,message,TRUE);
                    LDpDrive->Read(0,1,rw_buff);
                    FirstByte = rw_buff[0];
                    rw_buff[0] = 0;
                    LDpDrive->Write(0,1,rw_buff);
                }
            }
        }

        // PC98 Sep.25.1995 ADD
        // If the sector-size when the last format differ from next format,
        // initialize a hard one-byte of disk.
        // at this time,if next formated disk is unformat-disk,
        // this process is undone.

        if( IsPC98_N() ){
            if( drive_type == FixedDrive && Unknown_flag == FALSE &&
                dpdrive.QuerySectorSize()!=dpdrive.QueryPhysicalSectorSize()){
                if( LDpDrive->Initialize(&ntdrivename,message,TRUE)){
                    LDpDrive->Read(0,1,rw_buff);
                    FirstByte = rw_buff[0];
                    rw_buff[0] = 0;
                    LDpDrive->Write(0,1,rw_buff);
                }
            }
        }

        DELETE( LDpDrive );
#endif

        // Disable hard-error popups.
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        Param.Major = 1;
        Param.Minor = 0;
        Param.Flags = (quick_format ? FORMAT_QUICK : 0) |
                      (old_fs ? FORMAT_BACKWARD_COMPATIBLE : 0) |
                      (force_dismount ? FORMAT_FORCE : 0) |
                      (force_mode ? FORMAT_YES : 0);
        Param.LabelString = (label_spec ? &arg_label : NULL);
        Param.ClusterSize = cluster_size;


        if( !Format( &ntdrivename,
                     message,
                     &Param,
                     media_type
                   ) ) {

#if defined (FE_SB) && defined (_X86_)
            if (FirstByte) {
                LOG_IO_DP_DRIVE *LDpDrive = NEW LOG_IO_DP_DRIVE;
                if( LDpDrive->Initialize(&ntdrivename,message,TRUE)){
                    rw_buff[0] = FirstByte;
                    LDpDrive->Write(0,1,rw_buff);
                }
                DELETE( LDpDrive );
            }
#endif

            // Enable hard-error popups.
            SetErrorMode( OldErrorMode );

            SYSTEM::FreeLibraryHandle( FsUtilityHandle );
            return 4;
        }

        // Enable hard-error popups.
        SetErrorMode( OldErrorMode );


        SYSTEM::FreeLibraryHandle( FsUtilityHandle );


        if (do_floppy_return && !no_prompts) {
            message->Set(quick_format ? MSG_QUICKFMT_ANOTHER : MSG_FORMAT_ANOTHER);
            message->Display("");
            if (!message->IsYesResponse(FALSE)) {
                break;
            }
        } else {
            break;
        }
    }


    // Make sure that the file system is installed.

    if (!do_floppy_return &&
        !IFS_SYSTEM::IsFileSystemEnabled(&LibSuffix)) {

        message->Set(MSG_FMT_INSTALL_FILE_SYSTEM);
        message->Display("%W", &LibSuffix);
        if (message->IsYesResponse(TRUE)) {
            if (!IFS_SYSTEM::EnableFileSystem(&LibSuffix)) {
                message->Set(MSG_FMT_CANT_INSTALL_FILE_SYSTEM);
                message->Display();
                return 1;
            }

            message->Set(MSG_FMT_FILE_SYSTEM_INSTALLED);
            message->Display();
        }
    }

    if (compressed && !IFS_SYSTEM::EnableVolumeCompression(&ntdrivename)) {
        message->Set(MSG_CANNOT_ENABLE_COMPRESSION);
        message->Display();

        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\format\parse.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "error.hxx"
#include "drive.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "system.hxx"
#include "ifssys.hxx"
#include "ulibcl.hxx"
#include "ifsentry.hxx"
#include "path.hxx"
#include "parse.hxx"

extern "C" {
    #include "nturtl.h"
}

BOOLEAN
ParseArguments(
    IN OUT  PMESSAGE    Message,
    OUT     PMEDIA_TYPE MediaType,
    OUT     PWSTRING    DosDriveName,
    OUT     PWSTRING    DisplayDriveName,
    OUT     PWSTRING    Label,
    OUT     PBOOLEAN    IsLabelSpeced,
    OUT     PWSTRING    FileSystemName,
    OUT     PBOOLEAN    QuickFormat,
    OUT     PBOOLEAN    ForceMode,
    OUT     PULONG      ClusterSize,
    OUT     PBOOLEAN    Compress,
    OUT     PBOOLEAN    NoPrompts,
    OUT     PBOOLEAN    ForceDismount,
    OUT     PINT        ErrorLevel
    )
{
    PWSTRING            pwstring;
    BOOLEAN             req160;
    BOOLEAN             req180;
    BOOLEAN             req320;
    BOOLEAN             req360;
    BOOLEAN             req720;
    BOOLEAN             req1200;
    BOOLEAN             req1440;
    BOOLEAN             req2880;
    BOOLEAN             req20800;
#if defined(FE_SB) && defined(_X86_)
    BOOLEAN             req256 = FALSE;
    BOOLEAN             req640 = FALSE;
    BOOLEAN             req1232 = FALSE;
#endif
    DSTRING             tmp_string;
    ULONG               v;

    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    PSTRING_ARGUMENT    progname = NULL;
    PFLAG_ARGUMENT      dummyv = NULL;
    PFLAG_ARGUMENT      dummyu = NULL;
    PPATH_ARGUMENT      drive = NULL;
    PFLAG_ARGUMENT      quick = NULL;
    PFLAG_ARGUMENT      compress = NULL;
    PFLAG_ARGUMENT      force = NULL;       // dangerous option not to be documented
    PFLAG_ARGUMENT      null_label = NULL;
    PSTRING_ARGUMENT    label = NULL;
    PFLAG_ARGUMENT      f160 = NULL;
    PFLAG_ARGUMENT      f160k = NULL;
    PFLAG_ARGUMENT      f160kb = NULL;
    PFLAG_ARGUMENT      f180 = NULL;
    PFLAG_ARGUMENT      f180k = NULL;
    PFLAG_ARGUMENT      f180kb = NULL;
    PFLAG_ARGUMENT      f320 = NULL;
    PFLAG_ARGUMENT      f320k = NULL;
    PFLAG_ARGUMENT      f320kb = NULL;
    PFLAG_ARGUMENT      f360 = NULL;
    PFLAG_ARGUMENT      f360k = NULL;
    PFLAG_ARGUMENT      f360kb = NULL;
#if defined(FE_SB) && defined(_X86_)
    PFLAG_ARGUMENT      f256 = NULL;
    PFLAG_ARGUMENT      f256k = NULL;
    PFLAG_ARGUMENT      f256kb = NULL;
#endif
    PFLAG_ARGUMENT      f720 = NULL;
    PFLAG_ARGUMENT      f720k = NULL;
    PFLAG_ARGUMENT      f720kb = NULL;
    PFLAG_ARGUMENT      f1200 = NULL;
    PFLAG_ARGUMENT      f1200k = NULL;
    PFLAG_ARGUMENT      f1200kb = NULL;
    PFLAG_ARGUMENT      f12 = NULL;
    PFLAG_ARGUMENT      f12m = NULL;
    PFLAG_ARGUMENT      f12mb = NULL;
#if defined(FE_SB) && defined(_X86_)
    PFLAG_ARGUMENT      f1250 = NULL;
    PFLAG_ARGUMENT      f1250k = NULL;
    PFLAG_ARGUMENT      f1250kb = NULL;
    PFLAG_ARGUMENT      f125 = NULL;
    PFLAG_ARGUMENT      f125m = NULL;
    PFLAG_ARGUMENT      f125mb = NULL;
    PFLAG_ARGUMENT      f1 = NULL;
    PFLAG_ARGUMENT      f1m = NULL;
    PFLAG_ARGUMENT      f1mb = NULL;
#endif
    PFLAG_ARGUMENT      f1440 = NULL;
    PFLAG_ARGUMENT      f1440k = NULL;
    PFLAG_ARGUMENT      f1440kb = NULL;
    PFLAG_ARGUMENT      f144 = NULL;
    PFLAG_ARGUMENT      f144m = NULL;
    PFLAG_ARGUMENT      f144mb = NULL;
    PFLAG_ARGUMENT      f2880 = NULL;
    PFLAG_ARGUMENT      f2880k = NULL;
    PFLAG_ARGUMENT      f2880kb = NULL;
    PFLAG_ARGUMENT      f288 = NULL;
    PFLAG_ARGUMENT      f288m = NULL;
    PFLAG_ARGUMENT      f288mb = NULL;
    PFLAG_ARGUMENT      f208 = NULL;
    PFLAG_ARGUMENT      f208m = NULL;
    PFLAG_ARGUMENT      f208mb = NULL;
#if defined(FE_SB) && defined(_X86_)
    PFLAG_ARGUMENT      f640 = NULL;
    PFLAG_ARGUMENT      f640k = NULL;
    PFLAG_ARGUMENT      f640kb = NULL;

    PFLAG_ARGUMENT      f1232 = NULL;
    PFLAG_ARGUMENT      f1232k = NULL;
    PFLAG_ARGUMENT      f1232kb = NULL;

    PFLAG_ARGUMENT      f123 = NULL;
    PFLAG_ARGUMENT      f123m = NULL;
    PFLAG_ARGUMENT      f123mb = NULL;
#endif
    PFLAG_ARGUMENT      cs512 = NULL;
    PFLAG_ARGUMENT      cs1024 = NULL;
    PFLAG_ARGUMENT      cs2048 = NULL;
    PFLAG_ARGUMENT      cs4096 = NULL;
    PFLAG_ARGUMENT      cs8192 = NULL;
    PFLAG_ARGUMENT      cs16k = NULL;
    PFLAG_ARGUMENT      cs32k = NULL;
    PFLAG_ARGUMENT      cs64k = NULL;
    PFLAG_ARGUMENT      cs128k = NULL;
    PFLAG_ARGUMENT      cs256k = NULL;
    PFLAG_ARGUMENT      one = NULL;
    PFLAG_ARGUMENT      four = NULL;
    PFLAG_ARGUMENT      eight = NULL;
    PLONG_ARGUMENT      secpertrack = NULL;
    PLONG_ARGUMENT      numtracks = NULL;
    PSTRING_ARGUMENT    arg_fs_name = NULL;
    PFLAG_ARGUMENT      helparg = NULL;
    PFLAG_ARGUMENT      no_prompts = NULL;  // dangerous option not to be documented
    PFLAG_ARGUMENT      yes = NULL;         // dangerous option not to be documented
    PFLAG_ARGUMENT      force_dismount = NULL;


    DebugAssert(Message);
    DebugAssert(MediaType);
    DebugAssert(DosDriveName);
    DebugAssert(DisplayDriveName);
    DebugAssert(Label);
    DebugAssert(FileSystemName);
    DebugAssert(QuickFormat);
    DebugAssert(ErrorLevel);
    DebugAssert(NoPrompts);
    DebugAssert(ForceDismount);


#if defined(FE_SB) && defined(_X86_)
    // FMR is surpport 640KB&2HD, non surpport 2D Media.
    // NT format is compatible for DOS format.
    if( IsFMR_N() ) {
        if (!(progname = NEW STRING_ARGUMENT) ||
            !(dummyv = NEW FLAG_ARGUMENT) ||
            !(dummyu = NEW FLAG_ARGUMENT) ||
            !(drive = NEW PATH_ARGUMENT) ||
            !(quick = NEW FLAG_ARGUMENT) ||
            !(compress = NEW FLAG_ARGUMENT) ||
            !(force = NEW FLAG_ARGUMENT) ||
            !(null_label = NEW FLAG_ARGUMENT) ||
            !(no_prompts = NEW FLAG_ARGUMENT) ||
            !(yes = NEW FLAG_ARGUMENT) ||
            !(force_dismount = NEW FLAG_ARGUMENT) ||
            !(label = NEW STRING_ARGUMENT) ||
            !(f640 = NEW FLAG_ARGUMENT) ||
            !(f640k = NEW FLAG_ARGUMENT) ||
            !(f640kb = NEW FLAG_ARGUMENT) ||
            !(f720 = NEW FLAG_ARGUMENT) ||
            !(f720k = NEW FLAG_ARGUMENT) ||
            !(f720kb = NEW FLAG_ARGUMENT) ||
            !(f1200 = NEW FLAG_ARGUMENT) ||
            !(f1200k = NEW FLAG_ARGUMENT) ||
            !(f1200kb = NEW FLAG_ARGUMENT) ||
            // Add the 2HD_check on to the ParseArguments()
            !(f1232 = NEW FLAG_ARGUMENT) ||
            !(f1232k = NEW FLAG_ARGUMENT) ||
            !(f1232kb = NEW FLAG_ARGUMENT) ||
            !(f12 = NEW FLAG_ARGUMENT) ||
            !(f12m = NEW FLAG_ARGUMENT) ||
            !(f12mb = NEW FLAG_ARGUMENT) ||
            // Add the 2HD_check on to the ParseArguments()
            !(f123 = NEW FLAG_ARGUMENT) ||
            !(f123m = NEW FLAG_ARGUMENT) ||
            !(f123mb = NEW FLAG_ARGUMENT) ||
            !(f1440 = NEW FLAG_ARGUMENT) ||
            !(f1440k = NEW FLAG_ARGUMENT) ||
            !(f1440kb = NEW FLAG_ARGUMENT) ||
            !(f144 = NEW FLAG_ARGUMENT) ||
            !(f144m = NEW FLAG_ARGUMENT) ||
            !(f144mb = NEW FLAG_ARGUMENT) ||
            !(f2880 = NEW FLAG_ARGUMENT) ||
            !(f2880k = NEW FLAG_ARGUMENT) ||
            !(f2880kb = NEW FLAG_ARGUMENT) ||
            !(f288 = NEW FLAG_ARGUMENT) ||
            !(f288m = NEW FLAG_ARGUMENT) ||
            !(f288mb = NEW FLAG_ARGUMENT) ||
            !(f208 = NEW FLAG_ARGUMENT)) {

            *ErrorLevel = 4;
            return FALSE;
        }
    } else if(IsPC98_N()) {
        if (!(progname = NEW STRING_ARGUMENT) ||
            !(dummyv = NEW FLAG_ARGUMENT) ||
            !(dummyu = NEW FLAG_ARGUMENT) ||
            !(drive = NEW PATH_ARGUMENT) ||
            !(quick = NEW FLAG_ARGUMENT) ||
            !(compress = NEW FLAG_ARGUMENT) ||
            !(force = NEW FLAG_ARGUMENT) ||
            !(null_label = NEW FLAG_ARGUMENT) ||
            !(no_prompts = NEW FLAG_ARGUMENT) ||
            !(yes = NEW FLAG_ARGUMENT) ||
            !(force_dismount = NEW FLAG_ARGUMENT) ||
            !(label = NEW STRING_ARGUMENT) ||
            !(f160 = NEW FLAG_ARGUMENT) ||
            !(f160k = NEW FLAG_ARGUMENT) ||
            !(f160kb = NEW FLAG_ARGUMENT) ||
            !(f180 = NEW FLAG_ARGUMENT) ||
            !(f180k = NEW FLAG_ARGUMENT) ||
            !(f180kb = NEW FLAG_ARGUMENT) ||
            !(f256 = NEW FLAG_ARGUMENT) ||
            !(f256k = NEW FLAG_ARGUMENT) ||
            !(f256kb = NEW FLAG_ARGUMENT) ||
            !(f320 = NEW FLAG_ARGUMENT) ||
            !(f320k = NEW FLAG_ARGUMENT) ||
            !(f320kb = NEW FLAG_ARGUMENT) ||
            !(f360 = NEW FLAG_ARGUMENT) ||
            !(f360k = NEW FLAG_ARGUMENT) ||
            !(f360kb = NEW FLAG_ARGUMENT) ||
            !(f640 = NEW FLAG_ARGUMENT) ||
            !(f640k = NEW FLAG_ARGUMENT) ||
            !(f640kb = NEW FLAG_ARGUMENT) ||
            !(f1232 = NEW FLAG_ARGUMENT) ||
            !(f1232k = NEW FLAG_ARGUMENT) ||
            !(f1232kb = NEW FLAG_ARGUMENT) ||
            !(f123 = NEW FLAG_ARGUMENT) ||
            !(f123m = NEW FLAG_ARGUMENT) ||
            !(f123mb = NEW FLAG_ARGUMENT) ||
            !(f720 = NEW FLAG_ARGUMENT) ||
            !(f720k = NEW FLAG_ARGUMENT) ||
            !(f720kb = NEW FLAG_ARGUMENT) ||
            !(f1200 = NEW FLAG_ARGUMENT) ||
            !(f1200k = NEW FLAG_ARGUMENT) ||
            !(f1200kb = NEW FLAG_ARGUMENT) ||
            !(f12 = NEW FLAG_ARGUMENT) ||
            !(f12m = NEW FLAG_ARGUMENT) ||
            !(f12mb = NEW FLAG_ARGUMENT) ||
            !(f1250 = NEW FLAG_ARGUMENT) ||
            !(f1250k = NEW FLAG_ARGUMENT) ||
            !(f1250kb = NEW FLAG_ARGUMENT) ||
            !(f125 = NEW FLAG_ARGUMENT) ||
            !(f125m = NEW FLAG_ARGUMENT) ||
            !(f125mb = NEW FLAG_ARGUMENT) ||
            !(f1 = NEW FLAG_ARGUMENT) ||
            !(f1m = NEW FLAG_ARGUMENT) ||
            !(f1mb = NEW FLAG_ARGUMENT) ||
            !(f1440 = NEW FLAG_ARGUMENT) ||
            !(f1440k = NEW FLAG_ARGUMENT) ||
            !(f1440kb = NEW FLAG_ARGUMENT) ||
            !(f144 = NEW FLAG_ARGUMENT) ||
            !(f144m = NEW FLAG_ARGUMENT) ||
            !(f144mb = NEW FLAG_ARGUMENT) ||
            !(f2880 = NEW FLAG_ARGUMENT) ||
            !(f2880k = NEW FLAG_ARGUMENT) ||
            !(f2880kb = NEW FLAG_ARGUMENT) ||
            !(f288 = NEW FLAG_ARGUMENT) ||
            !(f288m = NEW FLAG_ARGUMENT) ||
            !(f288mb = NEW FLAG_ARGUMENT) ||
            !(f208 = NEW FLAG_ARGUMENT)) {

            *ErrorLevel = 4;
            return FALSE;
        }
    }else
#endif
    if (!(progname = NEW STRING_ARGUMENT) ||
        !(dummyv = NEW FLAG_ARGUMENT) ||
        !(dummyu = NEW FLAG_ARGUMENT) ||
        !(drive = NEW PATH_ARGUMENT) ||
        !(quick = NEW FLAG_ARGUMENT) ||
        !(compress = NEW FLAG_ARGUMENT) ||
        !(force = NEW FLAG_ARGUMENT) ||
        !(null_label = NEW FLAG_ARGUMENT) ||
        !(no_prompts = NEW FLAG_ARGUMENT) ||
        !(yes = NEW FLAG_ARGUMENT) ||
        !(force_dismount = NEW FLAG_ARGUMENT) ||
        !(label = NEW STRING_ARGUMENT) ||
        !(f160 = NEW FLAG_ARGUMENT) ||
        !(f160k = NEW FLAG_ARGUMENT) ||
        !(f160kb = NEW FLAG_ARGUMENT) ||
        !(f180 = NEW FLAG_ARGUMENT) ||
        !(f180k = NEW FLAG_ARGUMENT) ||
        !(f180kb = NEW FLAG_ARGUMENT) ||
        !(f320 = NEW FLAG_ARGUMENT) ||
        !(f320k = NEW FLAG_ARGUMENT) ||
        !(f320kb = NEW FLAG_ARGUMENT) ||
        !(f360 = NEW FLAG_ARGUMENT) ||
        !(f360k = NEW FLAG_ARGUMENT) ||
        !(f360kb = NEW FLAG_ARGUMENT) ||
#if defined(FE_SB) && defined(_X86_)
        // FMR Jul.13.1994 SFT KMR
        // 3mode PC/AT surpports 640KB&2HD Media.
        // NT format is compatible for DOS format.
        !(f640 = NEW FLAG_ARGUMENT) ||
        !(f640k = NEW FLAG_ARGUMENT) ||
        !(f640kb = NEW FLAG_ARGUMENT) ||
        !(f1232 = NEW FLAG_ARGUMENT) ||
        !(f1232k = NEW FLAG_ARGUMENT) ||
        !(f1232kb = NEW FLAG_ARGUMENT) ||
        !(f123 = NEW FLAG_ARGUMENT) ||
        !(f123m = NEW FLAG_ARGUMENT) ||
        !(f123mb = NEW FLAG_ARGUMENT) ||
#endif
        !(f720 = NEW FLAG_ARGUMENT) ||
        !(f720k = NEW FLAG_ARGUMENT) ||
        !(f720kb = NEW FLAG_ARGUMENT) ||
        !(f1200 = NEW FLAG_ARGUMENT) ||
        !(f1200k = NEW FLAG_ARGUMENT) ||
        !(f1200kb = NEW FLAG_ARGUMENT) ||
        !(f12 = NEW FLAG_ARGUMENT) ||
        !(f12m = NEW FLAG_ARGUMENT) ||
        !(f12mb = NEW FLAG_ARGUMENT) ||
        !(f1440 = NEW FLAG_ARGUMENT) ||
        !(f1440k = NEW FLAG_ARGUMENT) ||
        !(f1440kb = NEW FLAG_ARGUMENT) ||
        !(f144 = NEW FLAG_ARGUMENT) ||
        !(f144m = NEW FLAG_ARGUMENT) ||
        !(f144mb = NEW FLAG_ARGUMENT) ||
        !(f2880 = NEW FLAG_ARGUMENT) ||
        !(f2880k = NEW FLAG_ARGUMENT) ||
        !(f2880kb = NEW FLAG_ARGUMENT) ||
        !(f288 = NEW FLAG_ARGUMENT) ||
        !(f288m = NEW FLAG_ARGUMENT) ||
        !(f288mb = NEW FLAG_ARGUMENT) ||
        !(f208 = NEW FLAG_ARGUMENT)) {

        *ErrorLevel = 4;
        return FALSE;
    }

    if (!(f208m = NEW FLAG_ARGUMENT) ||
        !(f208mb = NEW FLAG_ARGUMENT) ||
        !(cs512 = NEW FLAG_ARGUMENT) ||
        !(cs1024 = NEW FLAG_ARGUMENT) ||
        !(cs2048 = NEW FLAG_ARGUMENT) ||
        !(cs4096 = NEW FLAG_ARGUMENT) ||
        !(cs8192 = NEW FLAG_ARGUMENT) ||
        !(cs16k = NEW FLAG_ARGUMENT) ||
        !(cs32k = NEW FLAG_ARGUMENT) ||
        !(cs64k = NEW FLAG_ARGUMENT) ||
        !(cs128k = NEW FLAG_ARGUMENT) ||
        !(cs256k = NEW FLAG_ARGUMENT) ||
        !(one = NEW FLAG_ARGUMENT) ||
        !(four = NEW FLAG_ARGUMENT) ||
        !(eight = NEW FLAG_ARGUMENT) ||
        !(secpertrack = NEW LONG_ARGUMENT) ||
        !(numtracks = NEW LONG_ARGUMENT) ||
        !(arg_fs_name = NEW STRING_ARGUMENT) ||
        !(helparg = NEW FLAG_ARGUMENT)) {

        *ErrorLevel = 4;
        return FALSE;
    }


    if (!lex_array.Initialize() ||
        !arg_array.Initialize() ||
        !arglex.Initialize(&lex_array)) {

        *ErrorLevel = 4;
        return FALSE;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {

        *ErrorLevel = 4;
        return FALSE;
    }


#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.13.1994 SFT KMR
    // FMR is surpport 640KB&2HD, non surpport 2D Media.
    // NT format is compatible for DOS format.
    if ( IsFMR_N() ) {
        if (!progname->Initialize("*") ||
            !dummyv->Initialize("/v") ||
            !dummyu->Initialize("/u") ||
            !drive->Initialize("*") ||
            !quick->Initialize("/q") ||
            !compress->Initialize("/c") ||
            !force->Initialize("/force") ||
            !null_label->Initialize("/v:\"\"") ||
            !label->Initialize("/v:*") ||
            !no_prompts->Initialize("/backup") ||
            !yes->Initialize("/y") ||
            !force_dismount->Initialize("/x") ||
            !f640->Initialize("/f:640") ||
            !f640k->Initialize("/f:640K") ||
            !f640kb->Initialize("/f:640KB") ||
            !f720->Initialize("/f:720") ||
            !f720k->Initialize("/f:720K") ||
            !f720kb->Initialize("/f:720KB") ||
            !f1200->Initialize("/f:1200") ||
            !f1200k->Initialize("/f:1200K") ||
            !f1200kb->Initialize("/f:1200KB") ||
            // Add the 2HD_check on to the ParseArguments()
            !f1232->Initialize("/f:1232") ||
            !f1232k->Initialize("/f:1232K") ||
            !f1232kb->Initialize("/f:1232KB") ||
            !f12->Initialize("/f:1.2") ||
            !f12m->Initialize("/f:1.2M") ||
            !f12mb->Initialize("/f:1.2MB") ||
            // Add the 2HD_check on to the ParseArguments()
            !f123->Initialize("/f:1.23") ||
            !f123m->Initialize("/f:1.23M") ||
            !f123mb->Initialize("/f:1.23MB") ||
            !f1440->Initialize("/f:1440") ||
            !f1440k->Initialize("/f:1440K") ||
            !f1440kb->Initialize("/f:1440KB") ||
            !f144->Initialize("/f:1.44") ||
            !f144m->Initialize("/f:1.44M") ||
            !f144mb->Initialize("/f:1.44MB") ||
            !f2880->Initialize("/f:2880") ||
            !f2880k->Initialize("/f:2880K") ||
            !f2880kb->Initialize("/f:2880KB") ||
            !f288->Initialize("/f:2.88") ||
            !f288m->Initialize("/f:2.88M") ||
            !f288mb->Initialize("/f:2.88MB") ||
            !f208->Initialize("/f:20.8") ||
            !f208m->Initialize("/f:20.8M") ||
            !f208mb->Initialize("/f:20.8MB") ||
            !cs512->Initialize("/a:512") ||
            !cs1024->Initialize("/a:1024") ||
            !cs2048->Initialize("/a:2048") ||
            !cs4096->Initialize("/a:4096") ||
            !cs8192->Initialize("/a:8192") ||
            !cs16k->Initialize("/a:16k") ||
            !cs32k->Initialize("/a:32k") ||
            !cs64k->Initialize("/a:64k") ||
            !cs128k->Initialize("/a:128k") ||
            !cs256k->Initialize("/a:256k") ||
            !one->Initialize("/1") ||
            !four->Initialize("/4") ||
            !eight->Initialize("/8") ||
            !secpertrack->Initialize("/n:*") ||
            !numtracks->Initialize("/t:*") ||
            !arg_fs_name->Initialize("/fs:*") ||
            !helparg->Initialize("/?")) {

            *ErrorLevel = 4;
            return FALSE;
        }
    }
    else if(IsPC98_N()) {
        if (!progname->Initialize("*") ||
            !dummyv->Initialize("/v") ||
            !dummyu->Initialize("/u") ||
            !drive->Initialize("*") ||
            !quick->Initialize("/q") ||
            !compress->Initialize("/c") ||
            !force->Initialize("/force") ||
            !null_label->Initialize("/v:\"\"") ||
            !label->Initialize("/v:*") ||
            !no_prompts->Initialize("/backup") ||
            !yes->Initialize("/y") ||
            !force_dismount->Initialize("/x") ||
            !f160->Initialize("/f:160") ||
            !f160k->Initialize("/f:160K") ||
            !f160kb->Initialize("/f:160KB") ||
            !f180->Initialize("/f:180") ||
            !f180k->Initialize("/f:180K") ||
            !f180kb->Initialize("/f:180KB") ||
            !f256->Initialize("/f:256") ||
            !f256k->Initialize("/f:256K") ||
            !f256kb->Initialize("/f:256KB") ||
            !f320->Initialize("/f:320") ||
            !f320k->Initialize("/f:320K") ||
            !f320kb->Initialize("/f:320KB") ||
            !f360->Initialize("/f:360") ||
            !f360k->Initialize("/f:360K") ||
            !f360kb->Initialize("/f:360KB") ||
            !f640->Initialize("/f:640") ||
            !f640k->Initialize("/f:640K") ||
            !f640kb->Initialize("/f:640KB") ||
            !f720->Initialize("/f:720") ||
            !f720k->Initialize("/f:720K") ||
            !f720kb->Initialize("/f:720KB") ||
            !f1200->Initialize("/f:1200") ||
            !f1200k->Initialize("/f:1200K") ||
            !f1200kb->Initialize("/f:1200KB") ||
            !f12->Initialize("/f:1.2") ||
            !f12m->Initialize("/f:1.2M") ||
            !f12mb->Initialize("/f:1.2MB") ||
            !f1250->Initialize("/f:1250") ||
            !f1250k->Initialize("/f:1250K") ||
            !f1250kb->Initialize("/f:1250KB") ||
            !f125->Initialize("/f:1.25") ||
            !f125m->Initialize("/f:1.25M") ||
            !f125mb->Initialize("/f:1.25MB") ||
            !f1->Initialize("/f:1") ||
            !f1m->Initialize("/f:1M") ||
            !f1mb->Initialize("/f:1MB") ||
            !f1440->Initialize("/f:1440") ||
            !f1440k->Initialize("/f:1440K") ||
            !f1440kb->Initialize("/f:1440KB") ||
            !f144->Initialize("/f:1.44") ||
            !f144m->Initialize("/f:1.44M") ||
            !f144mb->Initialize("/f:1.44MB") ||
            !f2880->Initialize("/f:2880") ||
            !f2880k->Initialize("/f:2880K") ||
            !f2880kb->Initialize("/f:2880KB") ||
            !f288->Initialize("/f:2.88") ||
            !f288m->Initialize("/f:2.88M") ||
            !f288mb->Initialize("/f:2.88MB") ||
            !f208->Initialize("/f:20.8") ||
            !f208m->Initialize("/f:20.8M") ||
            !f208mb->Initialize("/f:20.8MB") ||
            !cs512->Initialize("/a:512") ||
            !cs1024->Initialize("/a:1024") ||
            !cs2048->Initialize("/a:2048") ||
            !cs4096->Initialize("/a:4096") ||
            !cs8192->Initialize("/a:8192") ||
            !cs16k->Initialize("/a:16k") ||
            !cs32k->Initialize("/a:32k") ||
            !cs64k->Initialize("/a:64k") ||
            !cs128k->Initialize("/a:128k") ||
            !cs256k->Initialize("/a:256k") ||
            !one->Initialize("/1") ||
            !four->Initialize("/4") ||
            !eight->Initialize("/8") ||
            !secpertrack->Initialize("/n:*") ||
            !numtracks->Initialize("/t:*") ||
            !arg_fs_name->Initialize("/fs:*") ||
            !helparg->Initialize("/?")) {

            *ErrorLevel = 4;
            return FALSE;
        }
    }else
#endif
    if (!progname->Initialize("*") ||
        !dummyv->Initialize("/v") ||
        !dummyu->Initialize("/u") ||
        !drive->Initialize("*") ||
        !quick->Initialize("/q") ||
        !compress->Initialize("/c") ||
        !force->Initialize("/force") ||
        !null_label->Initialize("/v:\"\"") ||
        !label->Initialize("/v:*") ||
        !no_prompts->Initialize("/backup") ||
        !yes->Initialize("/y") ||
        !force_dismount->Initialize("/x") ||
        !f160->Initialize("/f:160") ||
        !f160k->Initialize("/f:160K") ||
        !f160kb->Initialize("/f:160KB") ||
        !f180->Initialize("/f:180") ||
        !f180k->Initialize("/f:180K") ||
        !f180kb->Initialize("/f:180KB") ||
        !f320->Initialize("/f:320") ||
        !f320k->Initialize("/f:320K") ||
        !f320kb->Initialize("/f:320KB") ||
        !f360->Initialize("/f:360") ||
        !f360k->Initialize("/f:360K") ||
        !f360kb->Initialize("/f:360KB") ||
#if defined(FE_SB) && defined(_X86_)
        // FMR Jul.13.1994 SFT KMR
        // 3mode PC/AT surpports 640KB&2HD Media.
        // NT format is compatible for DOS format.
        !f640->Initialize("/f:640") ||
        !f640k->Initialize("/f:640K") ||
        !f640kb->Initialize("/f:640KB") ||
        !f1232->Initialize("/f:1232") ||
        !f1232k->Initialize("/f:1232K") ||
        !f1232kb->Initialize("/f:1232KB") ||
        !f123->Initialize("/f:1.23") ||
        !f123m->Initialize("/f:1.23M") ||
        !f123mb->Initialize("/f:1.23MB") ||
#endif
        !f720->Initialize("/f:720") ||
        !f720k->Initialize("/f:720K") ||
        !f720kb->Initialize("/f:720KB") ||
        !f1200->Initialize("/f:1200") ||
        !f1200k->Initialize("/f:1200K") ||
        !f1200kb->Initialize("/f:1200KB") ||
        !f12->Initialize("/f:1.2") ||
        !f12m->Initialize("/f:1.2M") ||
        !f12mb->Initialize("/f:1.2MB") ||
        !f1440->Initialize("/f:1440") ||
        !f1440k->Initialize("/f:1440K") ||
        !f1440kb->Initialize("/f:1440KB") ||
        !f144->Initialize("/f:1.44") ||
        !f144m->Initialize("/f:1.44M") ||
        !f144mb->Initialize("/f:1.44MB") ||
        !f2880->Initialize("/f:2880") ||
        !f2880k->Initialize("/f:2880K") ||
        !f2880kb->Initialize("/f:2880KB") ||
        !f288->Initialize("/f:2.88") ||
        !f288m->Initialize("/f:2.88M") ||
        !f288mb->Initialize("/f:2.88MB") ||
        !f208->Initialize("/f:20.8") ||
        !f208m->Initialize("/f:20.8M") ||
        !f208mb->Initialize("/f:20.8MB") ||
        !cs512->Initialize("/a:512") ||
        !cs1024->Initialize("/a:1024") ||
        !cs2048->Initialize("/a:2048") ||
        !cs4096->Initialize("/a:4096") ||
        !cs8192->Initialize("/a:8192") ||
        !cs16k->Initialize("/a:16k") ||
        !cs32k->Initialize("/a:32k") ||
        !cs64k->Initialize("/a:64k") ||
        !cs128k->Initialize("/a:128k") ||
        !cs256k->Initialize("/a:256k") ||
        !one->Initialize("/1") ||
        !four->Initialize("/4") ||
        !eight->Initialize("/8") ||
        !secpertrack->Initialize("/n:*") ||
        !numtracks->Initialize("/t:*") ||
        !arg_fs_name->Initialize("/fs:*") ||
        !helparg->Initialize("/?")) {

        *ErrorLevel = 4;
        return FALSE;
    }

    if (!arg_array.Put(progname) ||
        !arg_array.Put(dummyv) ||
        !arg_array.Put(dummyu) ||
        !arg_array.Put(drive) ||
        !arg_array.Put(quick) ||
        !arg_array.Put(compress) ||
        !arg_array.Put(force) ||
        !arg_array.Put(null_label) ||
        !arg_array.Put(label) ||
        !arg_array.Put(no_prompts) ||
        !arg_array.Put(yes) ||
        !arg_array.Put(force_dismount) ||
        !arg_array.Put(f1440) ||
        !arg_array.Put(f1440k) ||
        !arg_array.Put(f1440kb) ||
        !arg_array.Put(f144) ||
        !arg_array.Put(f144m) ||
        !arg_array.Put(f144mb) ||
        !arg_array.Put(cs512) ||
        !arg_array.Put(cs1024) ||
        !arg_array.Put(cs2048) ||
        !arg_array.Put(cs4096) ||
        !arg_array.Put(cs8192) ||
        !arg_array.Put(cs16k) ||
        !arg_array.Put(cs32k) ||
        !arg_array.Put(cs64k) ||
        !arg_array.Put(cs128k) ||
        !arg_array.Put(cs256k) ||
        !arg_array.Put(secpertrack) ||
        !arg_array.Put(numtracks) ||
        !arg_array.Put(arg_fs_name) ||
        !arg_array.Put(helparg)) {

        *ErrorLevel = 4;
        return FALSE;
    }



    if (!arglex.DoParsing(&arg_array)) {

        Message->Set(MSG_INVALID_PARAMETER);
        Message->Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        arg_array.DeleteAllMembers();

        *ErrorLevel = 4;
        return FALSE;
    }

    if (helparg->QueryFlag()) {

        DisplayFormatUsage(Message);
        arg_array.DeleteAllMembers();

        *ErrorLevel = 0;
        return FALSE;
    }

    if (drive->IsValueSet()) {

        PPATH               ppath;
        PATH                fullpath;
        DSTRING             drive_path_string;
        PATH_ANALYZE_CODE   rst;

        ppath = drive->GetPath();

#if defined(RUN_ON_NT4)
        if (!DosDriveName->Initialize(ppath->GetPathString())) {
            DebugPrint("Out of memory.\n");
            *ErrorLevel = 1;
            return FALSE;
        }
#endif

#if !defined(RUN_ON_NT4)
        rst = ppath->AnalyzePath(DosDriveName,
                                 &fullpath,
                                 &drive_path_string);

        switch (rst) {
            case PATH_OK:
            case PATH_COULD_BE_FLOPPY:
                if (drive_path_string.QueryChCount() != 0) {
                    Message->Set(MSG_FMT_INVALID_DRIVE_SPEC);
                    Message->Display();
                    *ErrorLevel = 1;
                    return FALSE;
                }
                if (ppath->IsGuidVolName()) {
                    if (!DisplayDriveName->Initialize(DosDriveName)) {
                        DebugPrint("Out of memory.\n");
                        *ErrorLevel = 1;
                        return FALSE;
                    }
                } else {
                    if (!DisplayDriveName->Initialize(fullpath.GetPathString())) {
                        DebugPrint("Out of memory.\n");
                        *ErrorLevel = 1;
                        return FALSE;
                    }
                }
                break;

            case PATH_OUT_OF_MEMORY:
                DebugPrint("Out of memory.\n");
                *ErrorLevel = 1;
                return FALSE;

            case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
                Message->Set(MSG_FMT_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH);
                Message->Display();
                *ErrorLevel = 1;
                return FALSE;

            default:
                Message->Set(MSG_FMT_INVALID_DRIVE_SPEC);
                Message->Display();
                *ErrorLevel = 1;
                return FALSE;
        }
#endif

        if (!DosDriveName->Strupr()) {
            *ErrorLevel = 1;
            return FALSE;
        }

    } else {
        Message->Set(MSG_REQUIRED_PARAMETER);
        Message->Display("");
        arg_array.DeleteAllMembers();

        *ErrorLevel = 1;
        return FALSE;
    }

    if (label->IsValueSet() && null_label->QueryFlag()) {

        Message->Set(MSG_INVALID_PARAMETER);
        Message->Display("%s", "/v:\"\"");

        *ErrorLevel = 4;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

    *IsLabelSpeced = label->IsValueSet() || null_label->QueryFlag();

    if (label->IsValueSet()) {

        if (!Label->Initialize(label->GetString())) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

    } else {

        if (!Label->Initialize("")) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }
    }


    if (arg_fs_name->IsValueSet()) {

        if (!FileSystemName->Initialize(arg_fs_name->GetString()) ||
            !FileSystemName->Strupr()) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

        if (FileSystemName->QueryChCount() == 0) {
            Message->Set(MSG_INVALID_PARAMETER);
            Message->Display("%W", arg_fs_name->GetLexeme());
            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

    } else {

        if (!FileSystemName->Initialize("")) {

            *ErrorLevel = 4;
            arg_array.DeleteAllMembers();
            return FALSE;
        }

    }


    *NoPrompts = no_prompts->QueryFlag();
    *ForceDismount = force_dismount->QueryFlag();
    *QuickFormat = quick->QueryFlag();
    *ForceMode = force->QueryFlag();

    if (yes->QueryFlag()) {
        *NoPrompts = *ForceMode = TRUE;
    }

    *Compress = compress->QueryFlag();

    if (label->IsValueSet()) {
        if (eight->QueryFlag()) {

            Message->Set(MSG_NO_LABEL_WITH_8);
            Message->Display("");

            *ErrorLevel = 1;
            arg_array.DeleteAllMembers();
            return FALSE;
        }
    }

    v = 0;
    *ClusterSize = 0;

    if (cs512->QueryFlag()) {
        *ClusterSize = 512;
        v++;
    }

    if (cs1024->QueryFlag()) {
        *ClusterSize = 1024;
        v++;
    }

    if (cs2048->QueryFlag()) {
        *ClusterSize = 2048;
        v++;
    }

    if (cs4096->QueryFlag()) {
        *ClusterSize = 4096;
        v++;
    }

    if (cs8192->QueryFlag()) {
        *ClusterSize = 8192;
        v++;
    }

    if (cs16k->QueryFlag()) {
        *ClusterSize = 16*1024;
        v++;
    }

    if (cs32k->QueryFlag()) {
        *ClusterSize = 32*1024;
        v++;
    }

    if (cs64k->QueryFlag()) {
        *ClusterSize = 64*1024;
        v++;
    }

    if (cs128k->QueryFlag()) {
        *ClusterSize = 128*1024;
        v++;
    }

    if (cs256k->QueryFlag()) {
        *ClusterSize = 256*1024;
        v++;
    }

    if (v > 1) {
        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();

        *ErrorLevel = 4;
        arg_array.DeleteAllMembers();
        return FALSE;
    }


    // -----------------------
    // Compute the media type.
    // -----------------------

#if defined(FE_SB) && defined(_X86_)
    // FMR Jul.13.1994 SFT KMR
    // When /T:80 and /N:8, modify the process to be 640KB's
    // Delete the /F:160,180,320 and 360 process from the ParseArguments()
    // Not surported media 2D.
    // NT format is compatible for DOS format.
    if ( IsFMR_N() ) {
        req160 = FALSE;
        req180 = FALSE;
        req320 = FALSE;
        req360 = FALSE;
    } else {
#endif
    req160 = f160->QueryFlag() || f160k->QueryFlag() || f160kb->QueryFlag();
    req180 = f180->QueryFlag() || f180k->QueryFlag() || f180kb->QueryFlag();
    req320 = f320->QueryFlag() || f320k->QueryFlag() || f320kb->QueryFlag();
    req360 = f360->QueryFlag() || f360k->QueryFlag() || f360kb->QueryFlag();
#if defined(FE_SB) && defined(_X86_)
    }

    if(IsPC98_N()) {
        req256 = f256->QueryFlag() || f256k->QueryFlag() || f256kb->QueryFlag();
    } else {
        req256 = FALSE;
    }

    // FMR, 3mode PC/AT(FMV) and PC98 uses f640,
    // FMR and 3mode PC/AT(FMV) uses f1230,
    // PC98 uses f1250.
    req640 = f640->QueryFlag() || f640k->QueryFlag() || f640kb->QueryFlag();

    if ( IsPC98_N() ) {
        req1232 = f1250->QueryFlag() || f1250k->QueryFlag() || f1250kb->QueryFlag() ||
                  f125->QueryFlag() || f125m->QueryFlag() || f125mb->QueryFlag() ||
                  f1->QueryFlag() || f1m->QueryFlag() || f1mb->QueryFlag();
    } else {
        req1232 = f1232->QueryFlag() || f1232k->QueryFlag() || f1232kb->QueryFlag() ||
                  f123->QueryFlag() || f123m->QueryFlag() || f123mb->QueryFlag();
    }

#endif

    req720 = f720->QueryFlag() || f720k->QueryFlag() || f720kb->QueryFlag();
    req1200 = f1200->QueryFlag() || f1200k->QueryFlag() || f1200kb->QueryFlag() ||
              f12->QueryFlag() || f12m->QueryFlag() || f12mb->QueryFlag();
    req1440 = f1440->QueryFlag() || f1440k->QueryFlag() || f1440kb->QueryFlag() ||
              f144->QueryFlag() || f144m->QueryFlag() || f144mb->QueryFlag();
    req2880 = f2880->QueryFlag() || f2880k->QueryFlag() || f2880kb->QueryFlag() ||
              f288->QueryFlag() || f288m->QueryFlag() || f288mb->QueryFlag();
    req20800 = f208->QueryFlag() || f208m->QueryFlag() || f208mb->QueryFlag();

    if (one->QueryFlag() && four->QueryFlag() && !eight->QueryFlag()) {

        req180 = TRUE;

    } else if (one->QueryFlag() && !four->QueryFlag() && eight->QueryFlag()) {

        req160 = TRUE;

    } else if (!one->QueryFlag() && four->QueryFlag() && !eight->QueryFlag()) {

        req360 = TRUE;

    } else if (!one->QueryFlag() && !four->QueryFlag() && eight->QueryFlag()) {

        req320 = TRUE;

    } else if (!one->QueryFlag() && !four->QueryFlag() && !eight->QueryFlag()) {
    } else {
        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display("");
        *ErrorLevel = 1;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

    if (secpertrack->IsValueSet() && numtracks->IsValueSet()) {
        if (secpertrack->QueryLong() == 8) {
            if (numtracks->QueryLong() == 40) {

                req320 = TRUE;

#if defined(FE_SB) && defined(_X86_)
            }
            else if ( numtracks->QueryLong() == 77)  {
                // When /T:77 and /N:8, modify the process to be 1.2MB's
                req1232 = TRUE;
            }
            else if ( numtracks->QueryLong() == 80 ) {
                // When /T:80 and /N:8, modify the process to be 640KB's
                req640 = TRUE;
#endif
            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 9) {
            if (numtracks->QueryLong() == 40) {

                req360 = TRUE;

            } else if (numtracks->QueryLong() == 80) {

                req720 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 15) {
            if (numtracks->QueryLong() == 80) {

                req1200 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 18) {
            if (numtracks->QueryLong() == 80) {

                req1440 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
        } else if (secpertrack->QueryLong() == 36) {
            if (numtracks->QueryLong() == 80) {

                req2880 = TRUE;

            } else {
                Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
                Message->Display("");
                *ErrorLevel = 1;
                arg_array.DeleteAllMembers();
                return FALSE;
            }
#if defined(FE_SB) && defined(_X86_)
        // NEC98 '94.09.22 NES
        } else if(IsPC98_N() && (secpertrack->QueryLong() == 26)) {
            req256 = TRUE;
#endif
        } else {
            Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
            Message->Display("");
            *ErrorLevel = 1;
            arg_array.DeleteAllMembers();
            return FALSE;
        }
    } else if (secpertrack->IsValueSet() || numtracks->IsValueSet()) {
        Message->Set(MSG_NEED_BOTH_T_AND_N);
        Message->Display("");
        *ErrorLevel = 1;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

   if (!DetermineMediaType(MediaType, Message, req160, req180, req320,
                            req360, req720, req1200, req1440, req2880,
                            req20800
#if defined(FE_SB) && defined(_X86_)
                           ,req256,req640,req1232
#endif
                           )
       ) {

        *ErrorLevel = 1;
        arg_array.DeleteAllMembers();
        return FALSE;
    }

    // If the media type was specified then it's gotten by now.

    arg_array.DeleteAllMembers();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\help\makefile.inc ===
msg.h msg.rc msg00001.bin: msg.mc
    mc -v msg.mc

$(NTTARGETFILE0): msg.rc msg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\format\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=format
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\parse.cxx ..\format.cxx ..\format.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

TARGETLIBS=     \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\inc\bootreg.h ===
#include <nt.h>
#include <ntrtl.h>

ULONG
CharsInMultiString(
    IN PWSTR pw
    );

BOOLEAN
QueryAutocheckEntries(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    );

BOOLEAN
SaveAutocheckEntries(
    IN  PVOID   Value
    );

BOOLEAN
QueryTimeOutValue(
    OUT PULONG  TimeOut
    );

BOOLEAN
SetTimeOutValue(
    IN  ULONG   TimeOut
    );

NTSTATUS
QuerySystemPartitionValue(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\help\help.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    Help.c

Abstract:

    Simple minded utility that prints one-line help or spawns other
    utilities for their help.

Author:

    Mark Zbikowski 5/18/2001

Environment:

    User Mode

--*/

#include <windows.h>
#include <winnlsp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#include "msg.h"

#ifndef SHIFT
#define SHIFT(c,v)      {(c)--; (v)++;}
#endif //SHIFT



BOOL
PrintString(
    PWCHAR String
    )
/*++

Routine Description:

    Output a unicode string to the standard output handling
    redirection

Arguments:

    String
        NUL-terminated UNICODE string for display

Return Value:

    TRUE if string was successfully output to STD_OUTPUT_HANDLE
    
    FALSE otherwise
        
--*/
{
    DWORD   BytesWritten;
    DWORD   Mode;
    HANDLE  OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);    

    //
    //  If the output handle is for the console
    //
    
    if ((GetFileType( OutputHandle ) & FILE_TYPE_CHAR) && 
        GetConsoleMode( OutputHandle, &Mode) ) {

        return WriteConsoleW( OutputHandle, String, wcslen( String ), &BytesWritten, 0);

    } else {

        BOOL RetValue;
        int Count = WideCharToMultiByte( GetConsoleOutputCP(), 
                                         0, 
                                         String, 
                                         -1, 
                                         0, 
                                         0, 
                                         0, 
                                         0 );
         
        PCHAR SingleByteString = (PCHAR) malloc( Count );

        if (SingleByteString == NULL) {
            RetValue = FALSE;
        } else {
            WideCharToMultiByte( GetConsoleOutputCP( ), 
                             0, 
                             String, 
                             -1, 
                             SingleByteString, 
                             Count, 
                             0, 
                             0 );

            RetValue = WriteFile( OutputHandle, SingleByteString, Count - 1, &BytesWritten, 0 );

            free( SingleByteString );
        }

        return RetValue;
    }

}



PWCHAR
GetMsg(
    ULONG MsgNum, 
    ...
    )
/*++

Routine Description:

    Retrieve, format, and return a message string with all args substituted

Arguments:

    MsgNum - the message number to retrieve
    
    Optional arguments can be supplied

Return Value:

    NULL if the message retrieval/formatting failed 
    
    Otherwise pointer to the formatted string.
        
--*/
{
    PTCHAR Buffer = NULL;
    ULONG msglen;
    
    va_list arglist;

    va_start( arglist, MsgNum );

    msglen = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE
                            | FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER ,
                            NULL,
                            MsgNum,
                            0,
                            (LPTSTR) &Buffer,
                            0,
                            &arglist
                            );
    
    va_end(arglist);

    return msglen == 0 ? NULL : Buffer;
    
}


void
DisplayMessageError(
    ULONG MsgNum
    )
/*++

Routine Description:

    Displays a message if we cannot retrieve a message

Arguments:

    MsgNum
        Message number to display

Return Value:

    None.
        
--*/
{
    WCHAR Buffer[40];  // This is from #define LONG_SIZE_LENGTH  40 in base\crts\crtw32\convert\xtow.c
    PWCHAR MessageString;

    _ultow( MsgNum, Buffer, 16 );
    MessageString = GetMsg( ERROR_MR_MID_NOT_FOUND, Buffer, L"Application" );
    if (MessageString == NULL) {
        PrintString( L"Unable to get Message-Not-Found message\n" );
    } else {
        PrintString( MessageString );
        LocalFree( MessageString );
    }

}



BOOL
DisplayFullHelp(
    void
    )
/*++

Routine Description:

    Display the full help set. This assumes all messages in the message
    file are in the correct order

Arguments:

    None.

Return Value:

    TRUE if all messages were correctly output
    
    FALSE otherwise
        
--*/
{
    ULONG Message;
    BOOL RetValue = TRUE;

    for (Message = HELP_FIRST_HELP_MESSAGE; RetValue && Message <= HELP_LAST_HELP_MESSAGE; Message++) {
        PWCHAR MessageString = GetMsg( Message );
        if (MessageString == NULL) {
            DisplayMessageError( Message );
            RetValue = FALSE;
        } else {
            RetValue = PrintString( MessageString );
            LocalFree( MessageString );
        }
    }

    return RetValue;
}



BOOL
DisplaySingleHelp(
    PWCHAR Command
    )
/*++

Routine Description:

    Display the help appropriate to the specific command

Arguments:

    Command
        NUL-terminated UNICODE string for command

Return Value:

    TRUE if help was correctly output
    
    FALSE otherwise
        
--*/
{
    ULONG Message;
    ULONG Count = wcslen( Command );
    PWCHAR MessageString;

    //
    //  Walk through the messages one by one and determine which
    //  one has the specified command as the prefix.  
    //
    
    for (Message = HELP_FIRST_COMMAND_HELP_MESSAGE; 
         Message <= HELP_LAST_HELP_MESSAGE; 
         Message++) {

        MessageString = GetMsg( Message );
        if (MessageString == NULL) {
            DisplayMessageError( Message );
            return FALSE;
        } else {

            if (!_wcsnicmp( Command, MessageString, Count ) &&
                MessageString[Count] == L' ') {

                //
                //  We've found a match. Let the command
                //  display it's own help
                //

                WCHAR CommandString[MAX_PATH];

                wcscpy( CommandString, Command );
                wcscat( CommandString, L" /?" );
                
                _wsystem( CommandString );

                LocalFree( MessageString );
                return TRUE;
            }
            
            LocalFree( MessageString );
        }
    }

    MessageString = GetMsg( HELP_NOT_FOUND_MESSAGE, Command );

    if (MessageString == NULL) {
        DisplayMessageError( Message );
        return FALSE;
    }
    
    PrintString( MessageString );
    
    LocalFree( MessageString );

    return FALSE;
}


//
//  HELP with no arguments will display a series of one-line help summaries
//  for a variety of tools.
//
//  HELP with a single argument will walk through the list of tools it knows
//  about and attempt to match the tool against the argument.  If one is found,
//  the tool is executed with the /? switch and then the tool displays more
//  detailed help.
//

INT
__cdecl wmain(
    INT argc,
    PWSTR argv[]
    )
/*++

Routine Description:

    Source entry point for the 

Arguments:

    argc - The argument count.
    argv - string arguments, the first being the name of the executable and the
        remainder being parameters, only a single one is allowed.

Return Value:

    INT - Return Status:
        0 if help was successfully displayed
        1 otherwise
        
--*/

{
    PWSTR ProgramName = argv[0];
    PWSTR HelpString;
    BOOL RetValue;
    
    //
    //  Set up all the various international stuff
    //

    setlocale( LC_ALL, ".OCP" ) ;
    SetThreadUILanguage( 0 );
    
    //
    //  Get past the name of the program
    //

    SHIFT( argc, argv );

    //
    //  No arguments means a quick blurt of all the messages
    //
    
    if (argc == 0) {
        return DisplayFullHelp( );
    }

    //
    //  A single argument is looked up in the message set and
    //  that command is executed
    //  

    if (argc == 1 && wcscmp( argv[0], L"/?" )) {
        return DisplaySingleHelp( argv[0] );
    }

    //
    //  More than one argument was supplied.  This is an error
    //

    HelpString = GetMsg( HELP_USAGE_MESSAGE, ProgramName );
    
    if (HelpString == NULL) {
        PrintString( L"Unable to display usage message\n" );
        return 1;
    }

    RetValue = PrintString( HelpString );

    LocalFree( HelpString );

    return RetValue;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\autoentr.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    autoentr

Abstract:

    This module contains the definition of the AUTOENTR class.

Author:

    Ramon J. San Andres (ramonsa) 11 Mar 1991

Environment:

    Ulib, User Mode


--*/

#include <pch.cxx>

#include "ulib.hxx"
#include "autoentr.hxx"

DEFINE_CONSTRUCTOR( AUTOENTRY, OBJECT );



AUTOENTRY::~AUTOENTRY (
    )
/*++

Routine Description:

    Destructor for AUTOENTRY

Arguments:

	None.

Return Value:

	None.

--*/
{
    Destroy();
}




VOID
AUTOENTRY::Construct (
    )
/*++

Routine Description:

    Constructor for AUTOENTRY

Arguments:

	None.

Return Value:

	None.

--*/
{
}




VOID
AUTOENTRY::Destroy (
    )
/*++

Routine Description:

    Destroys an  AUTOENTRY object

Arguments:

	None.

Return Value:

	None.

--*/
{

}



BOOLEAN
AUTOENTRY::Initialize (
    IN  PCWSTRING    EntryName,
    IN  PCWSTRING    CommandLine
    )
/*++

Routine Description:

    Initializes an AUTOENTRY object

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if success

--*/
{
    return ( _EntryName.Initialize( EntryName )   &&
             _CommandLine.Initialize( CommandLine ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\autoreg.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    autoreg

Abstract:

    This module contains the definition of the AUTOREG class.

    The AUTOREG class contains methods for the registration and
    de-registration of those programs that are to be executed at
    boot time.

Author:

    Ramon J. San Andres (ramonsa) 11 Mar 1991

Environment:

    Ulib, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "autoreg.hxx"
#include "autoentr.hxx"


extern "C" {
    #include <stdio.h>
    #include "bootreg.h"
}

CONST BootExecuteBufferSize = 0x2000;

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::AddEntry (
    IN  PCWSTRING    CommandLine
    )
{
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    ULONG   CharsInValue, NewCharCount;


    // Fetch the existing autocheck entries.
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Determine if the new entry fits in our buffer.  The
    // new size will be the chars in the existing value
    // plus the length of the new string plus a terminating
    // null for the new string plus a terminating null for
    // the multi-string value.
    //
    CharsInValue = CharsInMultiString( BootExecuteValue );

    NewCharCount = CharsInValue + CommandLine->QueryChCount() + 2;

    if( NewCharCount * sizeof( WCHAR ) > BootExecuteBufferSize ) {

        // Not enough room.
        //
        return FALSE;
    }


    // Add the new entry to the buffer and add a terminating null
    // for the multi-string:
    //
    if( !CommandLine->QueryWSTR( 0,
                                 TO_END,
                                 BootExecuteValue + CharsInValue,
                                 BootExecuteBufferSize/sizeof(WCHAR) -
                                    CharsInValue ) ) {

        // Couldn't get the WSTR.
        //
        return FALSE;
    }

    BootExecuteValue[ NewCharCount - 1 ] = 0;


    // Write the value back into the registry:
    //
    return( SaveAutocheckEntries( BootExecuteValue ) );
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::PushEntry (
    IN  PCWSTRING    CommandLine
    )
{
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    ULONG   CharsInValue, NewCharCount;


    // Fetch the existing autocheck entries.
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Determine if the new entry fits in our buffer.  The
    // new size will be the chars in the existing value
    // plus the length of the new string plus a terminating
    // null for the new string plus a terminating null for
    // the multi-string value.
    //
    CharsInValue = CharsInMultiString( BootExecuteValue ) + 1;

    NewCharCount = CharsInValue + CommandLine->QueryChCount() + 1;

    if( NewCharCount * sizeof( WCHAR ) > BootExecuteBufferSize ) {

        // Not enough room.
        //
        return FALSE;
    }


    // Add the new entry to the buffer and add a terminating null
    // for the multi-string:
    //
    memmove(BootExecuteValue + CommandLine->QueryChCount() + 1,
            BootExecuteValue,
            CharsInValue*sizeof(WCHAR));

    if( !CommandLine->QueryWSTR( 0,
                                 TO_END,
                                 BootExecuteValue,
                                 NewCharCount
                                )) {
        // Couldn't get the WSTR.
        //
        return FALSE;
    }

    // Write the value back into the registry:
    //
    return( SaveAutocheckEntries( BootExecuteValue ) );
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::DeleteEntry (
    IN  PCWSTRING    LineToMatch,
    IN  BOOLEAN      PrefixOnly
    )
/*++

Routine Description:

    This method removes an Autocheck entry.

Arguments:

    LineToMatch --  Supplies a pattern for the entry to delete.
                    All lines which match this pattern will be
                    deleted.

    PrefixOnly  --  LineToMatch specifies a prefix, and all lines
                    beginning with that prefix are deleted.

Return Value:

    TRUE upon successful completion.  Note that this function
    will return TRUE if no matching entry is found, or if a
    matching entry is found and removed.

Notes:

    Since the utilities only assume responsibility for removing
    entries which we created in the first place, we can place
    very tight constraints on the matching pattern.  In particular,
    we can require an exact match (except for case).

--*/
{
    DSTRING CurrentString;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( LineToMatch ) == 0 ||
            (PrefixOnly && CurrentString.Stricmp( LineToMatch,
                                                  0, LineToMatch->QueryChCount(),
                                                  0, LineToMatch->QueryChCount()) == 0)) {

            // This line is a match--delete it.  We simply expunge
            // the current string plus its terminating null by
            // shifting the data beyond that point down.
            //
            memmove( pw,
                     pw + CurrentString.QueryChCount() + 1,
                     BootExecuteBufferSize - (unsigned int)(pw - BootExecuteValue) * sizeof(WCHAR) );

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return( SaveAutocheckEntries( BootExecuteValue ) );
}


IFSUTIL_EXPORT
BOOLEAN
AUTOREG::DeleteEntry (
    IN  PCWSTRING    PrefixToMatch,
    IN  PCWSTRING    ContainingString
    )
/*++

Routine Description:

    This method removes an entry that matches the PrefixToMatch and
    also contains the ContainingString.

Arguments:

    PrefixToMatch    --  Supplies a prefix pattern of interest.

    ContainingString --  Supplies a string to look for in each entry.

Return Value:

    TRUE upon successful completion.  Note that this function
    will return TRUE if no matching entry is found, or if a
    matching entry is found and removed.

Notes:

    Since the utilities only assume responsibility for removing
    entries which we created in the first place, we can place
    very tight constraints on the matching pattern.  In particular,
    we can require an exact match (except for case).

--*/
{
    DSTRING CurrentString;
    DSTRING ContainingStringUpcase;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    if (!ContainingStringUpcase.Initialize( ContainingString ) ||
        !ContainingStringUpcase.Strupr())

        return FALSE;


    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ||
            !CurrentString.Strupr() ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( PrefixToMatch,
                                   0,
                                   PrefixToMatch->QueryChCount(),
                                   0,
                                   TO_END ) == 0 &&
            CurrentString.Strstr( &ContainingStringUpcase ) != INVALID_CHNUM ) {

            // This line is a match--delete it.  We simply expunge
            // the current string plus its terminating null by
            // shifting the data beyond that point down.
            //
            memmove( pw,
                     pw + CurrentString.QueryChCount() + 1,
                     BootExecuteBufferSize - (unsigned int)(pw - BootExecuteValue) * sizeof(WCHAR) );

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return( SaveAutocheckEntries( BootExecuteValue ) );
}


IFSUTIL_EXPORT
BOOLEAN
AUTOREG::IsEntryPresent (
    IN PCWSTRING     LineToMatch
    )
/*++

Routine Description:

    This method determines whether a proposed entry for the
    autocheck list is already in the registry.

Arguments:

    LineToMatch --  Supplies a pattern for proposed entry.

Return Value:

    TRUE if a matching entry exists.
--*/
{
    DSTRING CurrentString;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( LineToMatch ) == 0 ) {

            // This line is a match.
            //
            return TRUE;

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::IsEntryPresent (
    IN  PCWSTRING    PrefixToMatch,
    IN  PCWSTRING    ContainingString
    )
/*++

Routine Description:

    This method search for an entry that matches the PrefixToMatch and
    also contains the ContainingString.

Arguments:

    PrefixToMatch    --  Supplies a prefix pattern of interest.

    ContainingString --  Supplies a string to look for in each entry.

Return Value:

    TRUE if a matching entry exists.
--*/
{
    DSTRING CurrentString;
    DSTRING ContainingStringUpcase;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    if (!ContainingStringUpcase.Initialize( ContainingString ) ||
        !ContainingStringUpcase.Strupr())

        return FALSE;


    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ||
            !CurrentString.Strupr() ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( PrefixToMatch,
                                   0,
                                   PrefixToMatch->QueryChCount(),
                                   0,
                                   TO_END ) == 0 &&
            CurrentString.Strstr( &ContainingStringUpcase ) != INVALID_CHNUM ) {

            return TRUE;

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
AUTOREG::IsFrontEndPresent (
    IN  PCWSTRING    PrefixToMatch,
    IN  PCWSTRING    SuffixToMatch
    )
/*++

Routine Description:

    This method search for an entry that matches the PrefixToMatch and
    the SuffixToMatch.

Arguments:

    PrefixToMatch    --  Supplies a prefix pattern of interest.
    SuffixToMatch    --  Supplies a suffix pattern of interest.

Return Value:

    TRUE if a matching entry exists.
--*/
{
    DSTRING CurrentString;
    DSTRING SuffixUpcase;
    BYTE    BootExecuteBuffer[BootExecuteBufferSize];
    PWCHAR  BootExecuteValue = (PWCHAR)BootExecuteBuffer;
    PWCHAR  pw;

    // Fetch the existing entries:
    //
    if( !QueryAutocheckEntries( BootExecuteValue,
                                BootExecuteBufferSize ) ) {

        return FALSE;
    }

    if (!SuffixUpcase.Initialize( SuffixToMatch ) ||
        !SuffixUpcase.Strupr())

        return FALSE;


    // Spin through the entries looking for matches:
    //
    pw = BootExecuteValue;

    while( *pw ) {

        if( !CurrentString.Initialize( pw ) ||
            !CurrentString.Strupr() ) {

            return FALSE;
        }

        if( CurrentString.Stricmp( PrefixToMatch,
                                   0,
                                   PrefixToMatch->QueryChCount(),
                                   0,
                                   TO_END ) == 0 ) {

            if ((CurrentString.QueryChCount() >=
                 (PrefixToMatch->QueryChCount() + SuffixUpcase.QueryChCount())) &&
                CurrentString.Stricmp( SuffixToMatch,
                                       CurrentString.QueryChCount() - SuffixUpcase.QueryChCount(),
                                       TO_END,
                                       0,
                                       TO_END ) == 0 ) {

                return TRUE;
            } else {

                // This line is not a match.  Advance to the next.
                // Note that this will bump over the terminating
                // null for this component string, which is what
                // we want.
                //
                while( *pw++ );
            }

        } else {

            // This line is not a match.  Advance to the next.
            // Note that this will bump over the terminating
            // null for this component string, which is what
            // we want.
            //
            while( *pw++ );
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\bigint.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "bigint.hxx"

IFSUTIL_EXPORT
VOID
BIG_INT::Set(
    IN  UCHAR   ByteCount,
    IN  PCUCHAR CompressedInteger
    )
/*++

Routine Description:

    This routine sets the big_int with the given compressed integer.

Arguments:

    ByteCount           - Supplies the number of bytes in the compressed
                            integer.
    CompressedInteger   - Supplies the compressed integer.

Return Value:

    None.

--*/
{
    // If the number is completely compressed then we'll say that the
    // number is zero.  QueryCompressed should always return at least
    // one byte though.

    if (ByteCount == 0) {
        x = 0;
        return;
    }


    // First fill the integer with -1 if it's negative or 0 if it's
    // positive.

    if (CompressedInteger[ByteCount - 1] >= 0x80) {

        x = -1;

    } else {

        x = 0;
    }


    // Now copy over the integer.

    DebugAssert( ByteCount <= 8 );

    memcpy( &x, CompressedInteger, ByteCount );
}


IFSUTIL_EXPORT
VOID
BIG_INT::QueryCompressedInteger(
    OUT PUCHAR  ByteCount,
    OUT PUCHAR  CompressedInteger
    ) CONST
/*++

Routine Descrtiption:

    This routine returns a compressed form of the integer.

Arguments:

    ByteCount           - Returns the number of bytes in the compressed
                            integer.
    CompressedInteger   - Returns a 'little endian' string of bytes
                            representing a signed 'ByteCount' byte integer
                            into this supplied buffer.

Return Value:

    None.

--*/
{
    INT     i;
    PUCHAR  p;

    DebugAssert(ByteCount);
    DebugAssert(CompressedInteger);

    // First copy over the whole thing then determine the number
    // of bytes that you have to keep.

    memcpy(CompressedInteger, &x, sizeof(LARGE_INTEGER));


    p = CompressedInteger;


    // First check to see whether the number is positive or negative.

    if (p[7] >= 0x80) { // high byte is negative.

        for (i = 7; i >= 0 && p[i] == 0xFF; i--) {
        }

        if (i < 0) {
            *ByteCount = 1;
            return;
        }

        if (p[i] < 0x80) { // high byte is non-negative.
            i++;
        }

    } else { // high byte is non-negative.

        for (i = 7; i >= 0 && p[i] == 0; i--) {
        }

        if (i < 0) {
            *ByteCount = 1;
            return;
        }

        if (p[i] >= 0x80) { // high byte is negative.
            i++;
        }

    }


    // Now 'i' marks the position of the last character that you
    // have to keep.

    *ByteCount = (UCHAR) (i + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\bootreg.c ===
#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include "bootreg.h"

#define SESSION_MANAGER_KEY      L"Session Manager"
#define BOOT_EXECUTE_VALUE       L"BootExecute"
#define NEW_ENTRY                L"autocheck new entry"
#define TIME_OUT_VALUE           L"AutoChkTimeOut"

#define SYSTEM_PARTITION         L"SystemPartition"

ULONG
CharsInMultiString(
    IN PWSTR pw
    )
/*++

Routine Description:

    This computes the number of characters in a multi-string.  Note
    that this includes the terminating nulls of the component strings
    but not the terminating null of the multi-string itself.

Arguments:

    pw  --  Supplies a pointer to the multi-string.

Return Value:

    the number of characters in the multi-string.

--*/
{
    ULONG Length = 0;

    while( *pw ) {

        while( *pw++ ) {

            Length++;
        }

        Length++;
    }


    return Length;
}


BOOLEAN
QueryAutocheckEntries(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    )
/*++

Routine Description:

    This function fetches the BootExecute value of the Session
    Manager key.

Arguments:

    Buffer      --  Supplies a buffer into which the value
                    will be written.
    BufferSize  --  Supplies the size of the client's buffer.

Return Value:

    TRUE upon successful completion.

--*/
{
    UNICODE_STRING OutputString;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS Status;

    // Set up the query table:
    //
    OutputString.Length = 0;
    OutputString.MaximumLength = (USHORT)BufferSize;
    OutputString.Buffer = (PWSTR)Buffer;

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[0].Name = BOOT_EXECUTE_VALUE;
    QueryTable[0].EntryContext = &OutputString;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     SESSION_MANAGER_KEY,
                                     QueryTable,
                                     NULL,
                                     NULL );

    return( NT_SUCCESS( Status ) );
}


BOOLEAN
SaveAutocheckEntries(
    IN  PVOID   Value
    )
/*++

Routine Description:

    This function writes the BootExecute value of the Session
    Manager key.

Arguments:

    Value       --  Supplies the value (as a MULTI_STRING)

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS Status;
    ULONG Length;

    Length = ( CharsInMultiString( Value ) + 1 ) * sizeof( WCHAR );

    Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                    SESSION_MANAGER_KEY,
                                    BOOT_EXECUTE_VALUE,
                                    REG_MULTI_SZ,
                                    Value,
                                    Length );

    return( NT_SUCCESS( Status ) );
}


BOOLEAN
QueryTimeOutValue(
    OUT PULONG  TimeOut
)
/*++

Routine Description:

    This function reads the AutoChkTimeOut value of the Session
    Manager key.

Arguments:

    TimeOut     --  Supplies the location to store the timeout value

Return Value:

    TRUE upon successful completion.

--*/
{
    RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
    NTSTATUS                    Status;

    // Set up the query table:
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = TIME_OUT_VALUE;
    QueryTable[0].EntryContext = TimeOut;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     SESSION_MANAGER_KEY,
                                     QueryTable,
                                     NULL,
                                     NULL );

    return( NT_SUCCESS( Status ) );
}


BOOLEAN
SetTimeOutValue(
    IN  ULONG  TimeOut
)
/*++

Routine Description:

    This function sets the AutoChkTimeOut value of the Session
    Manager key.

Arguments:

    TimeOut     --  Supplies the time out value

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS                    Status;

    Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                    SESSION_MANAGER_KEY,
                                    TIME_OUT_VALUE,
                                    REG_DWORD,
                                    &TimeOut,
                                    sizeof(TimeOut) );

    return( NT_SUCCESS( Status ) );
}


NTSTATUS
QuerySystemPartitionValue(
    OUT PVOID   Buffer,
    IN  ULONG   BufferSize
    )
/*++

Routine Description:

    This function fetches the value of the HKLM\System\Setup\SystemPartition key.

Arguments:

    Buffer      --  Supplies a buffer into which the value
                    will be written.
    BufferSize  --  Supplies the size of the client's buffer.

Return Value:

    TRUE upon successful completion.

--*/
{
    UNICODE_STRING OutputString;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS Status;

    // Set up the query table:
    //
    OutputString.Length = 0;
    OutputString.MaximumLength = (USHORT)BufferSize;
    OutputString.Buffer = (PWSTR)Buffer;

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[0].Name = SYSTEM_PARTITION;
    QueryTable[0].EntryContext = &OutputString;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                                     L"\\Registry\\Machine\\System\\Setup",
                                     QueryTable,
                                     NULL,
                                     NULL );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\dcache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "dcache.hxx"


DEFINE_CONSTRUCTOR( DRIVE_CACHE, OBJECT );


DRIVE_CACHE::~DRIVE_CACHE(
    )
/*++

Routine Description:

    Destructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
DRIVE_CACHE::Construct (
	)
/*++

Routine Description:

    Contructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


VOID
DRIVE_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


BOOLEAN
DRIVE_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive
    )
/*++

Routine Description:

    This routine initializes a DRIVE_CACHE object.

Arguments:

    Drive   - Supplies the drive to cache for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Drive);

    Destroy();
    _drive = Drive;
    return TRUE;
}


BOOLEAN
DRIVE_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors directly from the disk.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_drive);
    return _drive->HardRead(StartingSector, NumberOfSectors, Buffer);
}


BOOLEAN
DRIVE_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_drive);
    return _drive->HardWrite(StartingSector, NumberOfSectors, Buffer);
}


BOOLEAN
DRIVE_CACHE::Flush(
    )
/*++

Routine Description:

    This routine flushes all dirty cache blocks to disk.  This routine
    returns FALSE if there has ever been an write error since the last
    flush.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\cache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "cache.hxx"

#if defined( _AUTOCHECK_ )
extern "C" {
    #include "ntos.h"
}
#endif

DEFINE_CONSTRUCTOR( CACHE, OBJECT );


CACHE::~CACHE(
    )
/*++

Routine Description:

    Destructor for CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
CACHE::Construct(
    )
/*++

Routine Description:

    This routine initializes this class to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buffer = NULL;
    _block_number = NULL;
    _inuse = NULL;
    _num_blocks = 0;
    _block_size = 0;
    _next_add = 0;
    _next_add_inuse = 0;
    _timeout.QuadPart = 0;
}


VOID
CACHE::Destroy(
    )
/*++

Routine Description:

    This routine returns this object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    if (_buffer)
        for (i = 0; i < _num_blocks; i++) {
            FREE(_buffer[i]);
        }
    DELETE(_buffer);
    DELETE(_block_number);
    FREE(_inuse);

    _num_blocks = 0;
    _block_size = 0;
    _next_add = 0;
    _next_add_inuse = 0;
    _timeout.QuadPart = 0;
}


BOOLEAN
CACHE::Initialize(
    IN  ULONG   BlockSize,
    IN  ULONG   MaximumNumberOfBlocks
    )
/*++

Routine Description:

    This routine initializes this object to a valid initial state.

Arguments:

    BlockSize               - Supplies the size of the cache blocks.
    MaximumNumberOfBlocks   - Supplies the maximum number of cache blocks.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;

    Destroy();

    _num_blocks = MaximumNumberOfBlocks;
    _block_size = BlockSize;

    if (!(_buffer = NEW PVOID[_num_blocks]) ||
        !(_block_number = NEW BIG_INT[_num_blocks]) ||
        !(_inuse = (LONG *)MALLOC(_num_blocks*sizeof(LONG)))) {

        Destroy();
        return FALSE;
    }

    for (i = 0; i < _num_blocks; i++) {

        _buffer[i] = NULL;
        _block_number[i] = -1;
        _inuse[i] = 0;
    }

    for (i = 0; i < _num_blocks; i++) {

        if (!(_buffer[i] = MALLOC((UINT) _block_size))) {

            Destroy();
            return FALSE;
        }
    }

    _timeout.QuadPart = -10000;

    return TRUE;
}


BOOLEAN
CACHE::Read(
    IN  BIG_INT BlockNumber,
    OUT PVOID   Buffer
    ) CONST
/*++

Routine Description:

    This routine searches the cache for the requested block and
    copies it to the buffer if it is available.  If the block is
    not available then this routine will return FALSE.

Arguments:

    BlockNumber - Supplies the number of the block requested.
    Buffer      - Returns the buffer for the block requested.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;
    LONG    final_value;

    for (i = 0; i < _num_blocks; i++) {

        while (InterlockedCompareExchange(&_inuse[i], 1, 0) != 0) {
            NtDelayExecution(FALSE, &(LARGE_INTEGER)_timeout);
        }

        if (BlockNumber == _block_number[i]) {

            memcpy(Buffer, _buffer[i], (UINT) _block_size);
            final_value = InterlockedDecrement(&_inuse[i]);
            DebugAssert(final_value == 0);
            return TRUE;
        }

        final_value = InterlockedDecrement(&_inuse[i]);
        DebugAssert(final_value == 0);

    }

    return FALSE;
}


VOID
CACHE::AddBlock(
    IN  BIG_INT BlockNumber,
    IN  PCVOID  Buffer
    )
/*++

Routine Description:

    This routine adds a new block to the cache.  This will remove the
    oldest existing block out of the cache.

Arguments:

    BlockNumber - Supplies the block number of the new block.
    Buffer      - Supplies the buffer for the new block.

Return Value:

    None.

--*/
{
    LONG    final_value;

    while (InterlockedCompareExchange(&_next_add_inuse, 1, 0) != 0) {
        NtDelayExecution(FALSE, &_timeout);
    }

    while (InterlockedCompareExchange(&_inuse[_next_add], 1, 0) != 0) {
        NtDelayExecution(FALSE, &_timeout);
    }

    memcpy(_buffer[_next_add], Buffer, (UINT) _block_size);
    _block_number[_next_add] = BlockNumber;

    final_value = InterlockedDecrement(&_inuse[_next_add]);
    DebugAssert(final_value == 0);

    _next_add = (_next_add + 1) % _num_blocks;

    final_value = InterlockedDecrement(&_next_add_inuse);
    DebugAssert(final_value == 0);
}


VOID
CACHE::Empty(
    )
/*++

Routine Description:

    This routine eliminates all of the blocks from the cache.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;
    LONG    final_value;

    for (i = 0; i < _num_blocks; i++) {

        while (InterlockedCompareExchange(&_inuse[i], 1, 0) != 0) {
            NtDelayExecution(FALSE, &_timeout);
        }

        _block_number[i] = -1;

        final_value = InterlockedDecrement(&_inuse[i]);
        DebugAssert(final_value == 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\cannedsd.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    cannedsd.cxx

Abstract:

    This module contains member function definitions for the
    CANNED_SECURITY class, which is a repository for the canned
    Security Descriptors used by the utilities.

    Initializing an object of this type generates the canned
    security descriptors used by the utilities, which can
    then be gotten from the object.

    These security descriptors are all in the self-relative
    format.

    Note that this class uses the NT Api and RTL routines, rather
    than the Win32 API, since it needs to be available to AutoChk
    and AutoConvert.

Author:

    Bill McJohn (billmc) 04-March-1992

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "ntrtl.h"
#include "nturtl.h"

#include "cannedsd.hxx"

// This generic mapping array is copied from ntos\io\ioinit.c.
//
GENERIC_MAPPING IopFileMapping = {

    STANDARD_RIGHTS_READ |
        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_EXECUTE,
    FILE_ALL_ACCESS
};



DEFINE_EXPORTED_CONSTRUCTOR( CANNED_SECURITY, OBJECT, IFSUTIL_EXPORT );

IFSUTIL_EXPORT
CANNED_SECURITY::~CANNED_SECURITY(
    )
{
    Destroy();
}

VOID
CANNED_SECURITY::Construct(
    )
/*++

Routine Description:

    This method is the helper function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NoAccessLength = 0;
    _NoAclLength = 0;
    _ReadLength = 0;
    _WriteLength = 0;
    _EditLength = 0;
    _EditWorldDirLength = 0;
    _EditWorldFileLength = 0;

    _NoAccessSd = NULL;
    _NoAclSd = NULL;
    _ReadSd = NULL;
    _WriteSd = NULL;
    _EditSd = NULL;
    _EditWorldDirSd = NULL;
    _EditWorldFileSd = NULL;
    _NoAclFileSd = NULL;
}

VOID
CANNED_SECURITY::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if !defined( _SETUP_LOADER_ )
    _NoAccessLength = 0;
    _NoAclLength = 0;
    _ReadLength = 0;
    _WriteLength = 0;
    _EditLength = 0;
    _EditWorldDirLength = 0;
    _EditWorldFileLength = 0;

    // Since the canned security descriptors are ultimately
    // generated by RtlNewSecurityObject, they have to be
    // freed using RtlFreeHeap.
    //
    if( _NoAccessSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _NoAccessSd );
        _NoAccessSd = NULL;
    }

    if( _NoAclSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _NoAclSd );
        _NoAclSd = NULL;
    }

    if( _ReadSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _ReadSd );
        _ReadSd = NULL;
    }

    if( _WriteSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _WriteSd );
        _WriteSd = NULL;
    }

    if( _EditSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _EditSd );
        _EditSd = NULL;
    }

    if( _EditWorldDirSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _EditWorldDirSd );
        _EditWorldDirSd = NULL;
    }

    if( _EditWorldFileSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _EditWorldFileSd );
        _EditWorldFileSd = NULL;

    if( _NoAclFileSd != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, _NoAclFileSd );
        _NoAclFileSd = NULL;
    }

    }
#endif // _SETUP_LOADER_
}


IFSUTIL_EXPORT
BOOLEAN
CANNED_SECURITY::Initialize(
    )
/*++

Routine Description:

    This method initializes the object.  It builds the canned
    security descriptors, puts them into self-relative form,
    and squirrels them away for later use.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
#if defined( _SETUP_LOADER_ )

    // Canned security descriptors are not available in
    // the setup loader environment.
    //
    return FALSE;

#else

    CONST SidBufferLength = 512;
    PSID SystemSid = NULL;
    PSID AdminsSid = NULL;
    ULONG AdminsSidBufferLength, SystemSidBufferLength;
    NTSTATUS Status;
    HANDLE TokenHandle;

    Destroy();

    // Get the SID's for Admins and System.
    //
    SystemSidBufferLength = SidBufferLength;
    AdminsSidBufferLength = SidBufferLength;

    if( (SystemSid = (PSID)MALLOC( SystemSidBufferLength )) == NULL ||
        !QuerySystemSid( SystemSid, &SystemSidBufferLength ) ||
        (AdminsSid = (PSID)MALLOC( AdminsSidBufferLength )) == NULL ||
        !QueryAdminsSid( AdminsSid, &AdminsSidBufferLength ) ) {

        FREE( SystemSid );
        FREE( AdminsSid );
        Destroy();
        return FALSE;
    }

    // Get a handle to the token for the current process:
    //
    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &TokenHandle );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: NtOpenProcessToken failed: status = 0x%x\n", Status ));
        FREE( SystemSid );
        FREE( AdminsSid );
        Destroy();
        return FALSE ;
    }

    // Generate the canned security descriptors.  All but _NoAclSd
    // have a discretionary ACL, so pass in TRUE for the DaclPresent
    // parameter for all but that exception.
    //
    _NoAccessSd = GenerateCannedSd( NoAccessCannedSd,
                                    0,
                                    AdminsSid,
                                    SystemSid,
                                    TokenHandle,
                                    &_NoAccessLength );

    _NoAclSd = GenerateCannedSd( NoAclCannedSd,
                                 0,
                                 AdminsSid,
                                 SystemSid,
                                 TokenHandle,
                                 &_NoAclLength );

    _ReadSd = GenerateCannedSd( ReadCannedSd,
                                GENERIC_READ,
                                AdminsSid,
                                SystemSid,
                                TokenHandle,
                                &_ReadLength );

    _WriteSd = GenerateCannedSd( WriteCannedSd,
                                 GENERIC_READ | GENERIC_WRITE,
                                 AdminsSid,
                                 SystemSid,
                                 TokenHandle,
                                 &_WriteLength );

    _EditSd = GenerateCannedSd( EditCannedSd,
                                GENERIC_ALL,
                                AdminsSid,
                                SystemSid,
                                TokenHandle,
                                &_EditLength );

    _EditWorldDirSd = GenerateCannedSd( EditWorldCannedDirSd,
                                        GENERIC_ALL,
                                        AdminsSid,
                                        SystemSid,
                                        TokenHandle,
                                        &_EditWorldDirLength );

    _EditWorldFileSd = GenerateCannedSd( EditWorldCannedFileSd,
                                         GENERIC_ALL,
                                         AdminsSid,
                                         SystemSid,
                                         TokenHandle,
                                         &_EditWorldFileLength );

    _NoAclFileSd = GenerateCannedSd( EditWorldCannedFileSd,
                                     0,
                                     AdminsSid,
                                     SystemSid,
                                     TokenHandle,
                                     &_NoAclFileLength );
    //
    // New Security descriptor with a different format from those created
    // above.
    //

    _NewRootSd = GenerateCannedSd( NewRootSd,
                                   0,
                                   0,
                                   0,
                                   TokenHandle,
                                   &_NewRootSdLength );

    // We're done with the SID's for Admins and System, and with
    // the token for the current process.
    //
    FREE( SystemSid );
    FREE( AdminsSid );
    NtClose( TokenHandle );

    // Make sure that all the canned security descriptors were
    // successful generated.
    //
    if( _NoAccessSd == NULL ||
        _NoAclSd == NULL    ||
        _ReadSd == NULL     ||
        _WriteSd == NULL    ||
        _EditSd == NULL    ||
        _EditWorldDirSd == NULL ||
        _EditWorldFileSd == NULL ||
        _NewRootSd == NULL ||
        _NoAclFileSd == NULL) {

        Destroy();
        return FALSE;
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


IFSUTIL_EXPORT
PVOID
CANNED_SECURITY::GetCannedSecurityDescriptor(
    IN  CANNED_SECURITY_TYPE   Type,
    OUT PULONG                 Length
    )
/*++

Routine Description:

    This method fetches one of the canned security descriptors.

Arguments:

    Type    --  Supplies a code indicating which security
                descriptor to get.
    Length  --  Receives the length (in bytes) of the security
                descriptor.

Return Value:

    A pointer to the canned security descriptor.  (A return value
    of NULL indicates that an error has occurred.)

--*/
{
    DebugPtrAssert( Length );

    switch( Type ) {

    case NoAccessCannedSd     : *Length = _NoAccessLength;
                                return _NoAccessSd;

    case NoAclCannedSd        : *Length = _NoAclLength;
                                return _NoAclSd;

    case ReadCannedSd         : *Length = _ReadLength;
                                return _ReadSd;

    case WriteCannedSd        : *Length = _WriteLength;
                                return _WriteSd;

    case EditCannedSd         : *Length = _EditLength;
                                return _EditSd;

    case EditWorldCannedDirSd : *Length = _EditWorldDirLength;
                                return _EditWorldDirSd;

    case EditWorldCannedFileSd: *Length = _EditWorldFileLength;
                                return _EditWorldFileSd;

    case NewRootSd            : *Length = _NewRootSdLength;
                                return _NewRootSd;

    case NoAclCannedFileSd    : *Length = _NoAclFileLength;
                                return _NoAclFileSd;

    default                   : *Length = 0;
                                return NULL;
    }
}

#if !defined( _SETUP_LOADER_ )

BOOLEAN
QueryWorldSid(
    OUT     PSID    NewSid,
    IN OUT  PULONG  Length
    )
/*++

Routine Description:

    This functions fetches the SID for WORLD.

Arguments:

    NewSid  --  Supplies buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the
                length of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // WORLD is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_WORLD_RID;

    return TRUE;
}

NTSTATUS
AddInheritableAccessAllowedAce(
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN UCHAR AceFlags,
    IN PSID Sid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.  The inheritance
    flags are set so that this ACE will apply to the current item
    and will be propagated to child containers and objects.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    AceFlags - Inheritance flags for new ACE

    Sid - Pointer to the SID being granted access.


Return Value:

    STATUS_SUCCESS - The ACE was successfully added.
    anything else  - The ACE was not successfully added.

--*/
{
    PACCESS_ALLOWED_ACE NewAce;
    ULONG AceSize;
    NTSTATUS Status;

    AceSize = (USHORT)(sizeof(ACE_HEADER) +
                      sizeof(ACCESS_MASK) +
                      RtlLengthSid(Sid));

    NewAce = (PACCESS_ALLOWED_ACE)MALLOC( AceSize );

    if( NewAce == NULL ) {

        return STATUS_NO_MEMORY;
    }

    NewAce->Header.AceFlags = AceFlags;
    NewAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    NewAce->Header.AceSize = (USHORT)AceSize;
    NewAce->Mask = AccessMask;
    RtlCopySid( RtlLengthSid(Sid), (PSID)(&NewAce->SidStart), Sid );

    Status = RtlAddAce( Acl, AceRevision, MAXULONG, NewAce, AceSize );

    FREE( NewAce );

    return Status;
}


BOOLEAN
GenerateWorldAcl(
    OUT PACL        AclBuffer,
    IN  ULONG       BufferLength
    )
/*++

Routine Description:

    This function creates an ACL that grants full access to all
    the world.

Arguments:

    AclBuffer       --  Supplies the buffer in which the ACL
                        will be created.
    BufferLength    --  Supplies the length of the buffer

Return Value:

    TRUE upon successful completion.

--*/
{
    CONST WorldSidBufferLength = 64;
    BYTE WorldSidBuffer[WorldSidBufferLength];

    ULONG WorldSidLength = WorldSidBufferLength;
    PSID  WorldSid = (PSID)WorldSidBuffer;

    if( !QueryWorldSid( WorldSid, &WorldSidLength ) ) {

        return FALSE;
    }

    ACL_SIZE_INFORMATION AclSizeInfo;
    PACL NewAcl;
    NTSTATUS Status;

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }


    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }


    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryUsersSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the USERS alias.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // Users is a well-known SID with two subauthorities.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 2 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               2 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( NewSid, 1 )) = DOMAIN_ALIAS_RID_USERS;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryPowerUsersSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the POWER USERS SID pseudo-account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // Power Users is a well-known SID with two subauthorities.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 2 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               2 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( NewSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryCreatorOwnerSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the CREATOR OWNER pseudo-account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // System is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryPrincipalSelfSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the PRINCIPAL SELF SID pseudo-account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // System is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_PRINCIPAL_SELF_RID;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QuerySystemSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the SYSTEM account.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // System is a well-known SID with one subauthority.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 1 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the subauthority:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               1 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::QueryAdminsSid(
    OUT    PSID     NewSid,
    IN OUT PULONG   Length
    )
/*++

Routine Description:

    This method fetches the SID for the WORKSTATION ADMINISTRATORS
    alias.

Arguments:

    NewSid  --  Supplies the buffer in which the SID will be created.
    Length  --  Supplies the length of the buffer; receives the length
                of the actual SID.

Return Value:

    TRUE upon successful completion.

--*/
{
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    ULONG LengthNeeded;
    NTSTATUS Status;

    // Admins is a well-known SID with two subauthorities.  Make sure
    // that the buffer is big enough:
    //
    LengthNeeded = RtlLengthRequiredSid( 2 );

    if( *Length < LengthNeeded ) {

        return FALSE;
    }

    *Length = LengthNeeded;

    // Initialize the SID and fill in the two subauthorities:
    //
    Status = RtlInitializeSid( NewSid,
                               &IdentifierAuthority,
                               2 );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlInitializeSid failed--status 0x%x\n", Status ));
        return FALSE;
    }

    *(RtlSubAuthoritySid( NewSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( NewSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

    return TRUE;
}



PVOID
CANNED_SECURITY::GenerateCannedSd(
    IN  CANNED_SECURITY_TYPE    SecurityType,
    IN  ACCESS_MASK             GrantedAccess,
    IN  PSID                    AdminsSid,
    IN  PSID                    SystemSid,
    IN  HANDLE                  TokenHandle,
    OUT PULONG                  Length
    )
/*++

Routine Description:

    This method generates a self-relative Security Descriptor
    which grants the specified access to System and Administrators.

Arguments:

    SecurityType    --  Identifies the sort of security descriptor to generate
    GrantedAccess   --  Supplies the access that System and Administrators
                        will have to the file protected by this Security
                        Descriptor.  A value of zero indicates that no
                        aces are to be created.
    AdminsSid       --  Supplies the SID for Administrators.
    SystemSid       --  Supplies the SID for System.
    Length          --  Receives the length of the Security Descriptor.

Return Value:

    A pointer to the generated Security Descriptor.  NULL indicates
    failure.

--*/
{
    CONST CannedAclBufferLength = 4096;
    BYTE  CannedAclBuffer[CannedAclBufferLength];

    SECURITY_DESCRIPTOR AbsoluteSd;
    PSECURITY_DESCRIPTOR SelfRelativeSd;
    NTSTATUS Status;

    // Create an absolute Security Descriptor.
    //
    Status = RtlCreateSecurityDescriptor( &AbsoluteSd,
                                          SECURITY_DESCRIPTOR_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "RtlCreateSecurityDescriptor failed--status 0x%x.\n", Status ));
        return NULL;
    }

    //
    // got rid of setting of owner as Admin (see WinSE #:6709, Whistler #:53503)
    //

    //
    // The group is ADMINS.
    //

    Status = RtlSetGroupSecurityDescriptor( &AbsoluteSd,
                                            AdminsSid,
                                            TRUE );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlSetGroupSecurityDescriptor failed--status 0x%x\n", Status ));
        return NULL;
    }

    switch (SecurityType) {
        case NoAccessCannedSd:
        case ReadCannedSd:
        case WriteCannedSd:
        case EditCannedSd:
            // The client wants to put a discretionary ACL on this
            // security descriptor.
            //
            if( !GenerateCannedAcl( (PACL)CannedAclBuffer,
                                    CannedAclBufferLength,
                                    GrantedAccess,
                                    AdminsSid,
                                    SystemSid ) ) {

                return NULL;
            }
            break;

        case NoAclCannedSd:
            // The client has not specified a discretionary ACL, so
            // we'll create an ACL that grants full access to all
            // the world.
            //
            if( !GenerateWorldAcl( (PACL)CannedAclBuffer,
                                   CannedAclBufferLength ) ) {

                return NULL;
            }
            break;

        case EditWorldCannedDirSd:
            // The client has not specified a discretionary ACL, so
            // we'll create an ACL that grants full access to all
            // the world.
            //
            if( !GenerateCannedWorldDirAcl( (PACL)CannedAclBuffer,
                                            CannedAclBufferLength,
                                            GrantedAccess,
                                            AdminsSid,
                                            SystemSid ) ) {

                return NULL;
            }
            break;

        case EditWorldCannedFileSd:
            // The client has not specified a discretionary ACL, so
            // we'll create an ACL that grants full access to all
            // the world.
            //
            if( !GenerateCannedWorldFileAcl( (PACL)CannedAclBuffer,
                                             CannedAclBufferLength,
                                             GrantedAccess,
                                             AdminsSid,
                                             SystemSid ) ) {

                return NULL;
            }
            break;

        case NewRootSd:

            if( !GenerateCannedNewRootAcl( (PACL)CannedAclBuffer,
                                           CannedAclBufferLength ) ) {

                return NULL;
            }

            break;

        default:
            DebugPrintTrace(("IFSUTIL: Unknown security type %d\n", SecurityType));
            return NULL;
    }

    // Attach the new ACL to the Security Descriptor.  Pass in
    // TRUE for DaclPresent (since that's what we're setting)
    // and for DaclDefaulted (since these canned Security
    // Descriptors are defaults).
    //
    Status = RtlSetDaclSecurityDescriptor( &AbsoluteSd,
                                           TRUE,
                                           (PACL)CannedAclBuffer,
                                           TRUE );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "RtlSetDaclSecurityDescriptor failed--status 0x%x.\n", Status ));
        return NULL;
    }

    // Now call RtlNewSecurityObject to massage this security
    // descriptor into a self-relative security descriptor
    // that canned be slammed onto files.
    //
    Status = RtlNewSecurityObject( NULL,
                                   &AbsoluteSd,
                                   &SelfRelativeSd,
                                   FALSE,
                                   TokenHandle,
                                   &IopFileMapping );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL:  RtlNewSecurityObject failed--status = 0x%x\n", Status ));
        return NULL;
    }

    // Make sure the returned security descriptor is valid:
    //
    if( !RtlValidSecurityDescriptor( SelfRelativeSd ) ) {

        DebugPrint( "IFSUTIL: RtlNewSecurityObject did not return a valid security descriptor.\n" );

        RtlFreeHeap( RtlProcessHeap(), 0, SelfRelativeSd );
        return NULL;
    }

    *Length = RtlLengthSecurityDescriptor( SelfRelativeSd );
    return SelfRelativeSd;
}


BOOLEAN
CANNED_SECURITY::GenerateCannedAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength,
    IN  ACCESS_MASK GrantedAccess,
    IN  PSID        AdminsSid,
    IN  PSID        SystemSid
    )
/*++

Routine Description:

    This method builds up an ACL in the supplied buffer.

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).
    GrantedAccess   --  Supplies the access the ACL will grant to
                        SYSTEM and ADMINS.
    AdminsSid       --  Supplies the SID for administrators.
    SystemSid       --  Supplies the SID for SYSTEM.

--*/
{
    ACL_SIZE_INFORMATION AclSizeInfo;
    PACL NewAcl;
    NTSTATUS Status;

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::GenerateCannedWorldDirAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength,
    IN  ACCESS_MASK GrantedAccess,
    IN  PSID        AdminsSid,
    IN  PSID        SystemSid
    )
/*++

Routine Description:

    This method builds up an ACL in the supplied buffer.

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).
    GrantedAccess   --  Supplies the access the ACL will grant to
                        SYSTEM and ADMINS.
    AdminsSid       --  Supplies the SID for administrators.
    SystemSid       --  Supplies the SID for SYSTEM.

--*/
{
    ACL_SIZE_INFORMATION    AclSizeInfo;
    PACL                    NewAcl;
    NTSTATUS                Status;
    CONST                   WorldSidBufferLength = 64;
    BYTE                    WorldSidBuffer[WorldSidBufferLength];
    ULONG                   WorldSidLength = WorldSidBufferLength;
    PSID                    WorldSid = (PSID)WorldSidBuffer;

    if( !QueryWorldSid( WorldSid, &WorldSidLength ) ) {

        return FALSE;
    }

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = AddInheritableAccessAllowedAce ( NewAcl,
                                                  ACL_REVISION,
                                                  GrantedAccess,
                                                  OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                  SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = AddInheritableAccessAllowedAce( NewAcl,
                                                 ACL_REVISION,
                                                 GrantedAccess,
                                                 OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                 AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = AddInheritableAccessAllowedAce( NewAcl,
                                                 ACL_REVISION,
                                                 GrantedAccess,
                                                 OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                 SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = AddInheritableAccessAllowedAce( NewAcl,
                                                 ACL_REVISION,
                                                 GrantedAccess,
                                                 OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                                 AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: AddInheritableAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    return TRUE;
}



BOOLEAN
CANNED_SECURITY::GenerateCannedNewRootAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength
    )
/*++

Routine Description:

    This method builds up an the following ACL in the supplied buffer:

            BUILTIN\Administrators:(OI)(CI)F
            NT AUTHORITY\SYSTEM:(OI)(CI)F
            CREATOR OWNER:(OI)(CI)(IO)F
            BUILTIN\Users:(OI)(CI)R
            BUILTIN\Users:(CI)(special access:) FILE_APPEND_DATA
            BUILTIN\Users:(CI)(IO)(special access:) FILE_WRITE_DATA
            Everyone:R

    Where:

        OI stands for Object Inherit
        CI stands for Container Inherit
        IO stands for Inherit Only

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).

--*/
{
    ACL_SIZE_INFORMATION    AclSizeInfo;
    PACL                    NewAcl;
    NTSTATUS                Status;

    CONST                   SidBufferLength = 256;
    BYTE                    SidBuffer[SidBufferLength];
    ULONG                   SidLength = SidBufferLength;
    PSID                    Sid = (PSID)SidBuffer;

    //
    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //

    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Adminstrator:F CI OI
    //

    if( !QueryAdminsSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryAdminsSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Admin SID to ACL failed--status 0x%x.\n", Status ));
         return FALSE;
    }

    //
    // Add System:F CI OI
    //

    SidLength = SidBufferLength;
    if( !QuerySystemSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QuerySystemSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                                             Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add System SID to ACL failed--status 0x%x.\n", Status ));
         return FALSE;
    }

    //
    // Add Creator Owner:F CI OI IO
    //

    SidLength = SidBufferLength;
    if( !QueryCreatorOwnerSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryCreatorOwnerSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_ALL,
                                             OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
                                             Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Creator Owner SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Users: Read, Execute, Synchronize CI OI
    //

    SidLength = SidBufferLength;
    if( !QueryUsersSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryUsersSid failed\n"));
        return FALSE;
    }

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             GENERIC_READ | FILE_EXECUTE | SYNCHRONIZE,
                                             CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                             Sid );

    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add First Users SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Users: Create Directory CI (must be different ACE from above, because
    //            Create Directory is the same bit as FILE_APPEND_DATA, so we can't let
    //            it inherit to files.
    //

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             FILE_ADD_SUBDIRECTORY,
                                             CONTAINER_INHERIT_ACE,
                                             Sid );

    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Second Users SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add Users: Add File CI IO
    //

    Status = AddInheritableAccessAllowedAce( NewAcl,
                                             ACL_REVISION,
                                             FILE_ADD_FILE,
                                             CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE,
                                             Sid );

    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add Third Users SID to ACL failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    //
    // Add World:R CI OI + traverse + synchronize (for cmd.exe)
    //

    SidLength = SidBufferLength;
    if( !QueryWorldSid( Sid, &SidLength ) ) {
        DebugPrintTrace(( "IFSUTIL: QueryWorldSid failed\n"));
        return FALSE;
    }

    Status = RtlAddAccessAllowedAce( NewAcl,
                                     ACL_REVISION,
                                     GENERIC_READ | FILE_TRAVERSE | SYNCHRONIZE,
                                     Sid );
    if (!NT_SUCCESS( Status )) {
        DebugPrintTrace(( "IFSUTIL: Add World SID to ACL failed--status 0x%x.\n", Status ));
         return FALSE;
    }

    return TRUE;
}


BOOLEAN
CANNED_SECURITY::GenerateCannedWorldFileAcl(
    IN  PACL        AclBuffer,
    IN  ULONG       BufferLength,
    IN  ACCESS_MASK GrantedAccess,
    IN  PSID        AdminsSid,
    IN  PSID        SystemSid
    )
/*++

Routine Description:

    This method builds up an ACL in the supplied buffer.

Arguments:

    AclBuffer       --  Supplies the buffer in which to build the ACL.
    BufferLength    --  Supplies the length of the buffer (in bytes).
    GrantedAccess   --  Supplies the access the ACL will grant to
                        SYSTEM and ADMINS.
    AdminsSid       --  Supplies the SID for administrators.
    SystemSid       --  Supplies the SID for SYSTEM.

--*/
{
    ACL_SIZE_INFORMATION    AclSizeInfo;
    PACL                    NewAcl;
    NTSTATUS                Status;
    CONST                   WorldSidBufferLength = 64;
    BYTE                    WorldSidBuffer[WorldSidBufferLength];
    ULONG                   WorldSidLength = WorldSidBufferLength;
    PSID                    WorldSid = (PSID)WorldSidBuffer;

    if( !QueryWorldSid( WorldSid, &WorldSidLength ) ) {

        return FALSE;
    }

    // This is rather complicated, since we want to use the minimum
    // space for this ACL, but have to give it the buffer size in
    // advance.  To deal with this problem, we build the ACL up
    // twice.  The first time, we initialize it with the entire
    // buffer.  Once it's complete, we can ask it how big it really
    // is, and rebuild it with the correct size.
    //
    NewAcl = (PACL)AclBuffer;
    Status = RtlCreateAcl( NewAcl, BufferLength, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = RtlAddAccessAllowedAce( NewAcl,
                                     ACL_REVISION,
                                     GENERIC_ALL,
                                     WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce ( NewAcl,
                                          ACL_REVISION,
                                          GrantedAccess,
                                          SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    // Now determine the size of this ACL:
    //
    RtlQueryInformationAcl( NewAcl,
                            &AclSizeInfo,
                            sizeof( ACL_SIZE_INFORMATION ),
                            AclSizeInformation );

    // Now reinitialize and rebuild the ACL with the correct size:
    //
    Status = RtlCreateAcl( NewAcl, AclSizeInfo.AclBytesInUse, ACL_REVISION );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlCreateAcl failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    // This ACL always has one ACE, which grants the world full
    // access:
    //
    Status = RtlAddAccessAllowedAce( NewAcl,
                                     ACL_REVISION,
                                     GENERIC_ALL,
                                     WorldSid );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
        return FALSE;
    }

    if( GrantedAccess != 0 ) {

        // The client wants an ACL that grants certain access
        // rights to System and Administrators.
        //
        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         SystemSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }

        Status = RtlAddAccessAllowedAce( NewAcl,
                                         ACL_REVISION,
                                         GrantedAccess,
                                         AdminsSid );

        if( !NT_SUCCESS( Status ) ) {

            DebugPrintTrace(( "IFSUTIL: RtlAddAccessAllowedAce failed--status 0x%x.\n", Status ));
            return FALSE;
        }
    }

    return TRUE;
}


#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\drive.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    drive.cxx

Abstract:

    Provide drive methods.
    See drive.hxx for details.

Author:

        Mark Shavlik (marks) Jun-90
        Norbert P. Kusters (norbertk) 22-Feb-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "drive.hxx"
#include "rtmsg.h"
#include "message.hxx"
#include "numset.hxx"
#include "dcache.hxx"
#include "hmem.hxx"
#include "ifssys.hxx"

extern "C" {
#include <stdio.h>
#include <ntdddisk.h>
#include <initguid.h>
#include <diskguid.h>
#include <mountmgr.h>
#include <ntddmmc.h>
#include <ntddcdrm.h>

#include "bootreg.h"
};

#if defined(IO_PERF_COUNTERS)
LARGE_INTEGER IO_DP_DRIVE::_wtotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rtotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_ctotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rrtotal = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_wcount = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rcount = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_wsize = {0, 0};
LARGE_INTEGER IO_DP_DRIVE::_rsize = {0, 0};
#endif

//#define TRAP_A_WRITE    1
//#define TRAP_A_READ     1

// Don't lock down more that 64K for IO.
CONST   MaxIoSize   = 65536;

DEFINE_CONSTRUCTOR( DRIVE, OBJECT );

VOID
DRIVE::Construct (
        )
/*++

Routine Description:

    Contructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DRIVE::~DRIVE(
    )
/*++

Routine Description:

    Destructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
DRIVE::Initialize(
    IN      PCWSTRING    NtDriveName,
    IN OUT  PMESSAGE     Message
    )
/*++

Routine Description:

    This routine initializes a drive object.

Arguments:

    NtDriveName - Supplies an NT style drive name.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!NtDriveName) {
        Destroy();
        return FALSE;
    }

    if (!_name.Initialize(NtDriveName)) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    return TRUE;
}


VOID
DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns a DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DEFINE_EXPORTED_CONSTRUCTOR( DP_DRIVE, DRIVE, IFSUTIL_EXPORT );

VOID
DP_DRIVE::Construct (
        )
/*++

Routine Description:

    Constructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_actual, 0, sizeof(DRTYPE));
    _supported_list = NULL;
    _num_supported = 0;
    _alignment_mask = 0;
    _last_status = 0;
    _handle = 0;
    _alternate_handle = 0;
    _hosted_drive = FALSE;
    _super_floppy = FALSE;
    _is_writeable = FALSE;
    _is_primary_partition = FALSE;
    _is_system_partition = FALSE;
#if defined(FE_SB) && defined(_X86_)
    _format_type = NONE;
#endif
    memset(&_partition_info, 0, sizeof(_partition_info));
    _sony_ms = FALSE;
    _sony_ms_fmt_cmd = FALSE;
    _sony_ms_progress_indicator = FALSE;
    _ntfs_not_supported = FALSE;
}


IFSUTIL_EXPORT
DP_DRIVE::~DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

NTSTATUS
DP_DRIVE::OpenDrive(
    IN      PCWSTRING   NtDriveName,
    IN      ACCESS_MASK DesiredAccess,
    IN      BOOLEAN     ExclusiveWrite,
    OUT     PHANDLE     Handle,
    OUT     PULONG      Alignment,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method is a worker function for the Initialize methods,
    to open a volume and determine its alignment requirement.

Arguments:

    NtDriveName     - Supplies the name of the drive.
    DesiredAccess   - Supplies the access the client desires to the volume.
    ExclusiveWrite  - Supplies a flag indicating whether the client
                      wishes to exclude other write handles.
    Handle          - Receives the handle to the opened volume.
    Alignment       - Receives the alignment requirement for the volume.
    Message         - Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.


--*/
{
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    IO_STATUS_BLOCK             status_block;
    FILE_ALIGNMENT_INFORMATION  alignment_info;
    MSGID                       MessageId;
    NTSTATUS                    Status;


    string.Length = (USHORT) NtDriveName->QueryChCount() * sizeof(WCHAR);
    string.MaximumLength = string.Length;
    string.Buffer = (PWSTR)NtDriveName->GetWSTR();

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile(Handle,
                        DesiredAccess,
                        &oa, &status_block,
                        FILE_SHARE_READ |
                        (ExclusiveWrite ? 0 : FILE_SHARE_WRITE),
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status)) {

        MessageId = ( Status == STATUS_ACCESS_DENIED ) ?
                                MSG_DASD_ACCESS_DENIED :
                                MSG_CANT_DASD;
        Message ? Message->DisplayMsg( MessageId ) : 1;
        return Status;
    }


    // Query the disk alignment information.

    Status = NtQueryInformationFile(*Handle,
                                    &status_block,
                                    &alignment_info,
                                    sizeof(FILE_ALIGNMENT_INFORMATION),
                                    FileAlignmentInformation);

    if (!NT_SUCCESS(Status)) {

        switch( Status ) {

            case STATUS_DEVICE_BUSY:
            case STATUS_DEVICE_NOT_READY:
                MessageId = MSG_DEVICE_BUSY;
                break;

            case STATUS_DEVICE_OFF_LINE:
                MessageId = MSG_DEVICE_OFF_LINE;
                break;

            default:
                MessageId = MSG_BAD_IOCTL;
                break;
        }

        DebugPrintTrace(("IFSUTIL: Failed NtQueryInformationFile (%x)\n", Status));

        Message ? Message->DisplayMsg(MessageId) : 1;


        return Status;
    }

    *Alignment = alignment_info.AlignmentRequirement;

    //
    //  Set the ALLOW_EXTENDED_DASD_IO flag for the file handle,
    //  which ntfs format and chkdsk depend on to write the backup
    //  boot sector.  We ignore the return code from this, but we
    //  could go either way.
    //

    (VOID)NtFsControlFile( *Handle,
                           0, NULL, NULL,
                           &status_block,
                           FSCTL_ALLOW_EXTENDED_DASD_IO,
                           NULL, 0, NULL, 0);

    return Status;
}


IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a DP_DRIVE object based on the supplied drive
    path.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined(RUN_ON_W2K)
    CONST NumMediaTypes         = 20;

    IO_STATUS_BLOCK             status_block;
    DISK_GEOMETRY               disk_geometry;
    DISK_GEOMETRY               media_types[NumMediaTypes];
    INT                         i;
    PARTITION_INFORMATION       partition_info;
    BOOLEAN                     partition;
    MSGID                       MessageId;
#if !defined(_AUTOCHECK_)
    PWCHAR                      wstr;
#endif
    
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;

    Destroy();

    if (!DRIVE::Initialize(NtDriveName, Message)) {
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( NtDriveName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if(!NT_SUCCESS(_last_status)) {

        Destroy();
        DebugPrintTrace(("IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        return FALSE;
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

#if defined(FE_SB) && defined(_X86_)
    SetFormatType(FormatType);
#endif

// #if defined(_AUTOCHECK_)  // removed to always support DP_DRIVE::QueryDriveType 
    _last_status = NtQueryVolumeInformationFile(_handle,
                                                &status_block,
                                                &DeviceInfo,
                                                sizeof(DeviceInfo),
                                                FileFsDeviceInformation);

    // this is from ::GetDriveType()

    if (!NT_SUCCESS(_last_status)) {
        _drive_type = UnknownDrive;
    } else if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        _drive_type = RemoteDrive;
    } else {
        switch (DeviceInfo.DeviceType) {
          case FILE_DEVICE_NETWORK:
          case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            _drive_type = RemoteDrive;
             break;

          case FILE_DEVICE_CD_ROM:
          case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
             _drive_type = CdRomDrive;
             break;

          case FILE_DEVICE_VIRTUAL_DISK:
             _drive_type = RamDiskDrive;
             break;

          case FILE_DEVICE_DISK:
          case FILE_DEVICE_DISK_FILE_SYSTEM:

             if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                 _drive_type = RemovableDrive;
                 }
             else {
                 _drive_type = FixedDrive;
                 }
             break;

          default:
             _drive_type = UnknownDrive;
             break;
        }
    }
// #endif

    // Record that this is not a hosted volume:
    //
    _hosted_drive = FALSE;

    // Query the disk geometry.

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                         NULL, 0, &disk_geometry,
                                         sizeof(DISK_GEOMETRY));

    if (!NT_SUCCESS(_last_status)) {
       DebugPrintTrace(("IFSUTIL: Can't query disk geometry. Status returned = %x.\n", _last_status));
       if ((_last_status == STATUS_UNSUCCESSFUL) ||
            (_last_status == STATUS_UNRECOGNIZED_MEDIA)) {
            disk_geometry.MediaType = Unknown;
        } else {
            Destroy();
            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_CANT_DASD;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                case STATUS_DEVICE_OFF_LINE:
                    MessageId = MSG_DEVICE_OFF_LINE;
                    break;
                    
                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;

            return FALSE;
        }
    }

    if (disk_geometry.MediaType == Unknown) {
        memset(&disk_geometry, 0, sizeof(DISK_GEOMETRY));
        disk_geometry.MediaType = Unknown;
    }

    partition = FALSE;

    // Try to read the partition entry.

    if (disk_geometry.MediaType == FixedMedia ||
        disk_geometry.MediaType == RemovableMedia) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_PARTITION_INFO,
                                             NULL, 0, &partition_info,
                                             sizeof(PARTITION_INFORMATION));

        partition = (BOOLEAN) NT_SUCCESS(_last_status);

        if (!NT_SUCCESS(_last_status) &&
            _last_status != STATUS_INVALID_DEVICE_REQUEST) {
            DebugPrintTrace(("IFSUTIL: Can't read partition entry. Status returned = %x.\n", _last_status));
            Destroy();
            Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
            return FALSE;
        }

    }


    // Store the information in the class.

    if (partition) {

        //
        // Preserve the partition information in the drive object.
        //
        _partition_info = partition_info;

#if defined(FE_SB) && defined(_X86_)
        // PC98 Oct.21.1995
        // PC98 must support ATA cards which is formatted with similar
        // AT compatible machine.
        // So we need to know whether it is ATA card or not to judge the way of
        // format(PC98 or AT compatible).
        //
        // NEC Oct.15.1994
        // PC98 Oct.31.1994
        // PC98 supports special FAT file system. Its sector size is imaginay.
        // This idea was based on specification of early DOS (not PC-DOS)
        // when we had to support large device at DOS 3.x.
        // The logical sector (SectorSize in BPB) is not always same size
        // as the Physical sector (SectorSize of target disk's specification).
        // For example, Logical sector was made from collecting 4 Physical sector,
        // we could support 128MB partition in DOS 3.x.
        //   2048(bytes per LOGICAL sector) * 0xFFFF(sectors) = 128MB(-2048bytes)
        //
        // PC98 supports special HPFS, too.
        // It is made on disks whose physical sector size is 2048 bytes.
        // We realized it to congeal 4 logical sectors on 1 physical sector,
        // when MS OS/2 v1.21.

        if (IsPC98_N()) {
            if (disk_geometry.MediaType == RemovableMedia)
                _next_format_type = FORMAT_MEDIA_AT;
            else
                _next_format_type = FORMAT_MEDIA_98;
        }

        if (IsPC98_N() && _next_format_type!=FORMAT_MEDIA_AT) {
            PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  Bpb_Data;
            BIG_INT     numSectors = 0;

            _actual.PhysicalHiddenSectors =
                            (BIG_INT)(partition_info.StartingOffset /
                                      disk_geometry.BytesPerSector);
            // June.23.1995
            // store phisicalsectorsize for QueryPhysicalSectorSize

            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));

            if (QueryFormatType() == NONE ){
                ULONG       buffer_size = 10*1024;
                HMEM        hmem;
                PUCHAR      Buffer;
                ULONG       tmp = 0L;
                BIG_INT     biSectors;

                if (!hmem.Acquire(buffer_size, QueryAlignmentMask())) {
                    return FALSE;
                }
                Buffer = (PUCHAR)hmem.GetBuf();

                Bpb_Data = (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer;

                _last_status = NtReadFile(_handle, 0, NULL, NULL,
                                          &status_block,
                                          Buffer, buffer_size,
                                          NULL, NULL);

                if (NT_ERROR(_last_status) ||
                    status_block.Information != buffer_size) {
                    return FALSE;

                }

                memcpy(&tmp, Bpb_Data->Bpb.Sectors, sizeof(USHORT));

                if (!tmp) {
                    memcpy(&tmp, Bpb_Data->Bpb.LargeSectors, sizeof(ULONG));
                }

                biSectors = (BIG_INT)tmp;

                if (IFS_SYSTEM::IsThisFat( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer)) {
                    //
                    // set Logical sector size
                    //
                    memcpy(&disk_geometry.BytesPerSector,
                           Bpb_Data->Bpb.BytesPerSector, sizeof(USHORT));
                } else if (IFS_SYSTEM::IsThisHpfs( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer,
                                (PULONG)(&Buffer[16*512]),    // super block
                                (PULONG)(&Buffer[17*512]))) { // spare block
                    //
                    // emulate HPFS made on not 512 bytes/sector with
                    // exclusive driver that we are prepared.
                    // June.23.1995 bug fix

                    if (disk_geometry.BytesPerSector != 512) {
                        disk_geometry.BytesPerSector = 512;
                    }
                } else {
                    // none
                }

#if 0 // We do not support the format of logical sector != 512 on NT4.0
      // merged by V-HIDEKK 1996.10.14
            } else
            if (QueryFormatType() == FAT) {
                if (disk_geometry.MediaType != FixedMedia &&
                    disk_geometry.MediaType != RemovableMedia ||
                    partition_info.PartitionLength >= (129<<20)) {
                    // FD & 3.5"MO & Large Partition

                } else if (disk_geometry.BytesPerSector == 2048 ||
                    partition_info.PartitionLength >= (65<<20)) {
                    //  Small partition (Logical sector size = 2048)

                    disk_geometry.BytesPerSector = 2048;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }

                } else {
                    //  Small partition (Logical sector size = 1024)

                    disk_geometry.BytesPerSector = 1024;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }
                }

            } else
            if (QueryFormatType() == HPFS){
                if (disk_geometry.BytesPerSector == 2048)
                    disk_geometry.BytesPerSector = 512;
            }
#endif // #if 0:
            }
            if(numSectors == 0){
                 numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector;
            }
            DiskGeometryToDriveType(&disk_geometry,
                                    numSectors,
                                    partition_info.HiddenSectors,
                                    &_actual);

        } else if (IsFMR_N()) {

            // FMR Jul.14.1994 SFT KMR
            // Check the sector_length by the partition size
            // FMR's sector size is different, when partition size changed.
            // Set under 126MB is 1024 or 2048Byte, or 2048Byte.
            // Nothing sector size 512.

            if (partition_info.PartitionType == PARTITION_FAT_12) {
                if(partition_info.PartitionLength <= 3*1024*1024)
                    disk_geometry.BytesPerSector = 1024;
                else
                    disk_geometry.BytesPerSector = 2048;
            } else if (partition_info.PartitionType == PARTITION_FAT_16 ||
                       partition_info.PartitionType == PARTITION_HUGE)
                disk_geometry.BytesPerSector = 2048;
        } else if (IsPC98_N() && _next_format_type == FORMAT_MEDIA_AT){
            _actual.PhysicalHiddenSectors =
                         (BIG_INT)(partition_info.StartingOffset /
                          disk_geometry.BytesPerSector);
            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));
        }

        if (!IsPC98_N() || (IsPC98_N() && _next_format_type==FORMAT_MEDIA_AT))
#endif // FE_SB && _X86_

        DiskGeometryToDriveType(&disk_geometry,
                                partition_info.PartitionLength/
                                disk_geometry.BytesPerSector,
                                partition_info.HiddenSectors,
                                &_actual);

#if !defined(_AUTOCHECK_)
        if (Message && (wstr = _wgetenv(L"5XUFWX_FORMAT_SECTORS"))) {

            ULONG   sectors;
            INT     r;

            r = swscanf(wstr, L"%d", &sectors);
            if (r != 0 && r != EOF && sectors != 0 &&
                sectors <= _actual.Sectors.GetLowPart()) {
                Message->DisplayMsg(MSG_FMT_SECTORS, "%d", sectors);
                _actual.Sectors.Set(sectors, 0);
            } else {
                Message->DisplayMsg(MSG_FMT_BAD_SECTORS);
                return FALSE;
            }
        }
#endif

    } else {

        DiskGeometryToDriveType(&disk_geometry, &_actual);

        if (IsFloppy()) {

            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_GET_MEDIA_TYPES,
                                                 NULL, 0, media_types,
                                                 NumMediaTypes*
                                                 sizeof(DISK_GEOMETRY));

            if (!NT_SUCCESS(_last_status)) {
                DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_MEDIA_TYPES (%x)\n", _last_status));
                Destroy();
                if (Message) {

                    MSGID   MessageId;

                    switch (_last_status) {
                        case STATUS_NO_MEDIA_IN_DEVICE:
                            MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                            break;

                        case STATUS_DEVICE_BUSY:
                        case STATUS_DEVICE_NOT_READY:
                            MessageId = MSG_DEVICE_BUSY;
                            break;

                        case STATUS_DEVICE_OFF_LINE:
                            MessageId = MSG_DEVICE_OFF_LINE;
                            break;

                        default:
                            MessageId = MSG_BAD_IOCTL;
                            break;
                    }
                    Message->DisplayMsg(MessageId);
                }
                return FALSE;
            }



            _num_supported = (INT) (status_block.Information/
                                    sizeof(DISK_GEOMETRY));

            if (!_num_supported) {
                Destroy();
                if (Message) {
                    Message->DisplayMsg(MSG_BAD_IOCTL);
                }
                return FALSE;
            }

#if defined(FE_SB)
            INT j;
            DISK_GEOMETRY temp;

#if defined(_X86_)
    // PC98 Aug.26,1996

            if (IsPC98_N()) {
                for(i = 0; i < _num_supported; i++) {
                    // Remove F5_360_512 Media Type
                    if(media_types[i].MediaType==F5_360_512) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                    // Remove F8_256_128 Media Type
                    if(media_types[i].MediaType==F8_256_128) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                }
            }
#endif // _X86_

            // NT-US diaplays the dialog box by MediaType order.
            // The MediaType order matches media size order on NT-US.
            // But PC98 has more media_types than US one.
            // And these does NOT match on PC98.
            // We wish to display the dialog box by size order.
            // See also..
            //   \nt\private\utils\fmifs\src\format.cxx
            //   QuerySupportedMedia()

            for(i = 0; i < _num_supported ; i++) {
                for(j = 0; j < _num_supported - 1; j++) {
                    if(media_types[j].Cylinders.LowPart *
                       media_types[j].TracksPerCylinder *
                       media_types[j].SectorsPerTrack *
                       media_types[j].BytesPerSector <
                       media_types[j+1].Cylinders.LowPart *
                       media_types[j+1].TracksPerCylinder *
                       media_types[j+1].SectorsPerTrack *
                       media_types[j+1].BytesPerSector) {
                         temp=media_types[j];
                         media_types[j]=media_types[j+1];
                         media_types[j+1]=temp;
                     }
                 }
            }
#endif // FE_SB
                        if (!(_supported_list = NEW DRTYPE[_num_supported])) {
                Destroy();
                Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
                return FALSE;
            }

            for (i = 0; i < _num_supported; i++) {
                DiskGeometryToDriveType(&media_types[i], &_supported_list[i]);
            }
        }
    }

    if (!_num_supported) {
        _num_supported = 1;

        if (!(_supported_list = NEW DRTYPE[1])) {
            Destroy();
            Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
            return FALSE;
        }

        _supported_list[0] = _actual;
    }

    if (!CheckForPrimaryPartition()) {
        DebugPrintTrace(("IFSUTIL: Failed CheckForPrimaryPartition (%x)\n", _last_status));
        Destroy();
        if (Message) {

            MSGID   MessageId;

            switch (_last_status) {
                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                case STATUS_DEVICE_OFF_LINE:
                    MessageId = MSG_DEVICE_OFF_LINE;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }
            Message->DisplayMsg(MessageId);
        }
        return FALSE;
    }

    if (!CheckForSystemPartition()) {

        switch (_last_status) {
          case STATUS_BUFFER_TOO_SMALL:
            return FALSE;   // should not continue as the buffer should be long enough

          case STATUS_OBJECT_NAME_NOT_FOUND:
            break;          // ignore this one since it can happen in textmode setup

          default:
            //
            // Let's not fail just because we cannot determine if this is a system partition
            // This can happen in textmode setup.
            //
            DebugPrintTrace(("IFSUTIL: Failed CheckForSystemPartition (%x).\n", _last_status));
        }
    }

    //
    // Determine whether the media is a super-floppy; non-floppy
    // removable media which is not partitioned.  Such media will
    // have but a single partition, normal media will have at least 4.
    //

    if (disk_geometry.MediaType == RemovableMedia) {

        CONST INT EntriesPerBootRecord = 4;
        CONST INT MaxLogicalVolumes = 23;
        CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION) +
                            EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                sizeof(PARTITION_INFORMATION);

        UCHAR buf[Length];

        DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status)) {
            DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_DRIVE_LAYOUT (%x)\n", _last_status));
            Destroy();
            if (Message) {

                MSGID   MessageId;

                switch (_last_status) {
                    case STATUS_NO_MEDIA_IN_DEVICE:
                        MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                        break;

                    case STATUS_DEVICE_BUSY:
                    case STATUS_DEVICE_NOT_READY:
                        MessageId = MSG_DEVICE_BUSY;
                        break;

                    case STATUS_DEVICE_OFF_LINE:
                        MessageId = MSG_DEVICE_OFF_LINE;
                        break;
                    
                    default:
                        MessageId = MSG_BAD_IOCTL;
                        break;
                }
                Message->DisplayMsg(MessageId);
            }
            return FALSE;
        }

        if (layout_info->PartitionCount < 4) {

            _super_floppy = TRUE;
        }
    }

    if (!IsTransient) {
        NtClose(_handle);
        _handle = 0;
    }

    return TRUE;
#else // defined(RUN_ON_W2K)
    CONST NumMediaTypes             = 20;

    IO_STATUS_BLOCK                 status_block;
    DISK_GEOMETRY                   disk_geometry;
    DISK_GEOMETRY                   media_types[NumMediaTypes];
    INT                             i;
    PARTITION_INFORMATION_EX        partition_info;
    GET_LENGTH_INFORMATION          length_info;
    BOOLEAN                         partition;
    MSGID                           MessageId;
#if !defined(_AUTOCHECK_)
    PWCHAR                          wstr;
#endif
    
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;

    Destroy();

    if (!DRIVE::Initialize(NtDriveName, Message)) {
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( NtDriveName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if(!NT_SUCCESS(_last_status)) {

        Destroy();
        DebugPrintTrace(("IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        return FALSE;
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

#if defined(FE_SB) && defined(_X86_)
    SetFormatType(FormatType);
#endif

// #if defined(_AUTOCHECK_)  // removed to always support DP_DRIVE::QueryDriveType 
    _last_status = NtQueryVolumeInformationFile(_handle,
                                                &status_block,
                                                &DeviceInfo,
                                                sizeof(DeviceInfo),
                                                FileFsDeviceInformation);

    // this is from ::GetDriveType()

    if (!NT_SUCCESS(_last_status)) {
        _drive_type = UnknownDrive;
    } else if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        _drive_type = RemoteDrive;
    } else {
        switch (DeviceInfo.DeviceType) {
          case FILE_DEVICE_NETWORK:
          case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            _drive_type = RemoteDrive;
             break;

          case FILE_DEVICE_CD_ROM:
          case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
             _drive_type = CdRomDrive;
             break;

          case FILE_DEVICE_VIRTUAL_DISK:
             _drive_type = RamDiskDrive;
             break;

          case FILE_DEVICE_DISK:
          case FILE_DEVICE_DISK_FILE_SYSTEM:

             if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                 _drive_type = RemovableDrive;
                 }
             else {
                 _drive_type = FixedDrive;
                 }
             break;

          default:
             _drive_type = UnknownDrive;
             break;
        }
    }
// #endif

    // Record that this is not a hosted volume:
    //
    _hosted_drive = FALSE;


    // Query the disk geometry.

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                         NULL, 0, &disk_geometry,
                                         sizeof(DISK_GEOMETRY));

    if (!NT_SUCCESS(_last_status)) {
       DebugPrintTrace(("IFSUTIL: Can't query disk geometry. Status returned = %x.\n", _last_status));
       if ((_last_status == STATUS_UNSUCCESSFUL) ||
            (_last_status == STATUS_UNRECOGNIZED_MEDIA)) {
            disk_geometry.MediaType = Unknown;
        } else {
            Destroy();
            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_CANT_DASD;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                case STATUS_DEVICE_OFF_LINE:
                    MessageId = MSG_DEVICE_OFF_LINE;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;

            return FALSE;
        }
    }

    if (disk_geometry.MediaType == Unknown) {
        memset(&disk_geometry, 0, sizeof(DISK_GEOMETRY));
        disk_geometry.MediaType = Unknown;
    }

    partition = FALSE;

    // Try to read the partition entry.

    if (disk_geometry.MediaType == FixedMedia ||
        disk_geometry.MediaType == RemovableMedia) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_LENGTH_INFO,
                                             NULL, 0, &length_info,
                                             sizeof(GET_LENGTH_INFORMATION));

        partition = (BOOLEAN) NT_SUCCESS(_last_status);

        if (!NT_SUCCESS(_last_status) &&
            _last_status != STATUS_INVALID_DEVICE_REQUEST) {
            DebugPrintTrace(("IFSUTIL: Can't get volume size. Status returned = %x.\n", _last_status));
            Destroy();
            Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
            return FALSE;
        }

        if (partition) {

            _last_status = NtDeviceIoControlFile(
                               _handle, 0, NULL, NULL, &status_block,
                               IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
                               &partition_info,
                               sizeof(PARTITION_INFORMATION_EX));

            if (!NT_SUCCESS(_last_status)) {
                if (_last_status != STATUS_INVALID_DEVICE_REQUEST) {
                    DebugPrintTrace(("IFSUTIL: Can't read partition entry. Status returned = %x.\n", _last_status));
                    Destroy();
                    Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
                    return FALSE;
                }

                //
                // GET_PARTITION_INFO_EX will fail outright on an EFI Dynamic
                // Volume.  In this case, just make up the starting offset
                // so that FORMAT/CHKDSK can proceed normally.
                //

                partition_info.PartitionStyle = PARTITION_STYLE_GPT;
                partition_info.StartingOffset.QuadPart = 0x7E00;
                partition_info.PartitionLength.QuadPart = length_info.Length.QuadPart;
                partition_info.Gpt.PartitionType = PARTITION_BASIC_DATA_GUID;
            }

            if (partition_info.PartitionStyle != PARTITION_STYLE_MBR) {

                // If this is EFI, then just make up reasonable MBR values
                // so that CHKDSK/FORMAT can proceed with business as usual.

                partition_info.PartitionStyle = PARTITION_STYLE_MBR;
                if (IsEqualGUID(partition_info.Gpt.PartitionType,
                                PARTITION_BASIC_DATA_GUID)) {

                    partition_info.Mbr.PartitionType = 0x7;
                } else {
                    partition_info.Mbr.PartitionType = 0xEE;
                }

                partition_info.Mbr.BootIndicator = FALSE;
                partition_info.Mbr.RecognizedPartition = TRUE;
                partition_info.Mbr.HiddenSectors =
                        (ULONG) (partition_info.StartingOffset.QuadPart/
                                 disk_geometry.BytesPerSector);
            }
        }
    }


    // Store the information in the class.

    if (partition) {

        _partition_info = partition_info;

#if defined(FE_SB) && defined(_X86_)
        // PC98 Oct.21.1995
        // PC98 must support ATA cards which is formatted with similar
        // AT compatible machine.
        // So we need to know whether it is ATA card or not to judge the way of
        // format(PC98 or AT compatible).
        //
        // NEC Oct.15.1994
        // PC98 Oct.31.1994
        // PC98 supports special FAT file system. Its sector size is imaginay.
        // This idea was based on specification of early DOS (not PC-DOS)
        // when we had to support large device at DOS 3.x.
        // The logical sector (SectorSize in BPB) is not always same size
        // as the Physical sector (SectorSize of target disk's specification).
        // For example, Logical sector was made from collecting 4 Physical sector,
        // we could support 128MB partition in DOS 3.x.
        //   2048(bytes per LOGICAL sector) * 0xFFFF(sectors) = 128MB(-2048bytes)
        //
        // PC98 supports special HPFS, too.
        // It is made on disks whose physical sector size is 2048 bytes.
        // We realized it to congeal 4 logical sectors on 1 physical sector,
        // when MS OS/2 v1.21.

        if (IsPC98_N()) {
            if (disk_geometry.MediaType == RemovableMedia)
                _next_format_type = FORMAT_MEDIA_AT;
            else
                _next_format_type = FORMAT_MEDIA_98;
        }

        if (IsPC98_N() && _next_format_type!=FORMAT_MEDIA_AT) {
            PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  Bpb_Data;
            BIG_INT     numSectors = 0;

            _actual.PhysicalHiddenSectors =
                            (BIG_INT)(partition_info.StartingOffset /
                                      disk_geometry.BytesPerSector);
            // June.23.1995
            // store phisicalsectorsize for QueryPhysicalSectorSize

            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));

            if (QueryFormatType() == NONE ){
                ULONG       buffer_size = 10*1024;
                HMEM        hmem;
                PUCHAR      Buffer;
                ULONG       tmp = 0L;
                BIG_INT     biSectors;

                if (!hmem.Acquire(buffer_size, QueryAlignmentMask())) {
                    return FALSE;
                }
                Buffer = (PUCHAR)hmem.GetBuf();

                Bpb_Data = (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer;

                _last_status = NtReadFile(_handle, 0, NULL, NULL,
                                          &status_block,
                                          Buffer, buffer_size,
                                          NULL, NULL);

                if (NT_ERROR(_last_status) ||
                    status_block.Information != buffer_size) {
                    return FALSE;

                }

                memcpy(&tmp, Bpb_Data->Bpb.Sectors, sizeof(USHORT));

                if (!tmp) {
                    memcpy(&tmp, Bpb_Data->Bpb.LargeSectors, sizeof(ULONG));
                }

                biSectors = (BIG_INT)tmp;

                if (IFS_SYSTEM::IsThisFat( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer)) {
                    //
                    // set Logical sector size
                    //
                    memcpy(&disk_geometry.BytesPerSector,
                           Bpb_Data->Bpb.BytesPerSector, sizeof(USHORT));
                } else if (IFS_SYSTEM::IsThisHpfs( biSectors,
                                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)Buffer,
                                (PULONG)(&Buffer[16*512]),    // super block
                                (PULONG)(&Buffer[17*512]))) { // spare block
                    //
                    // emulate HPFS made on not 512 bytes/sector with
                    // exclusive driver that we are prepared.
                    // June.23.1995 bug fix

                    if (disk_geometry.BytesPerSector != 512) {
                        disk_geometry.BytesPerSector = 512;
                    }
                } else {
                    // none
                }

#if 0 // We do not support the format of logical sector != 512 on NT4.0
      // merged by V-HIDEKK 1996.10.14
            } else
            if (QueryFormatType() == FAT) {
                if (disk_geometry.MediaType != FixedMedia &&
                    disk_geometry.MediaType != RemovableMedia ||
                    partition_info.PartitionLength >= (129<<20)) {
                    // FD & 3.5"MO & Large Partition

                } else if (disk_geometry.BytesPerSector == 2048 ||
                    partition_info.PartitionLength >= (65<<20)) {
                    //  Small partition (Logical sector size = 2048)

                    disk_geometry.BytesPerSector = 2048;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }

                } else {
                    //  Small partition (Logical sector size = 1024)

                    disk_geometry.BytesPerSector = 1024;
                    if((numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector)
                       > 0xFFFF){
                      numSectors = 0xFFFF;
                    }
                }

            } else
            if (QueryFormatType() == HPFS){
                if (disk_geometry.BytesPerSector == 2048)
                    disk_geometry.BytesPerSector = 512;
            }
#endif // #if 0:
            }
            if(numSectors == 0){
                 numSectors = partition_info.PartitionLength/disk_geometry.BytesPerSector;
            }
            DiskGeometryToDriveType(&disk_geometry,
                                    numSectors,
                                    partition_info.Mbr.HiddenSectors,
                                    &_actual);

        } else if (IsFMR_N()) {

            // FMR Jul.14.1994 SFT KMR
            // Check the sector_length by the partition size
            // FMR's sector size is different, when partition size changed.
            // Set under 126MB is 1024 or 2048Byte, or 2048Byte.
            // Nothing sector size 512.

            if (partition_info.Mbr.PartitionType == PARTITION_FAT_12) {
                if(partition_info.PartitionLength <= 3*1024*1024)
                    disk_geometry.BytesPerSector = 1024;
                else
                    disk_geometry.BytesPerSector = 2048;
            } else if (partition_info.Mbr.PartitionType == PARTITION_FAT_16 ||
                       partition_info.Mbr.PartitionType == PARTITION_HUGE)
                disk_geometry.BytesPerSector = 2048;
        } else if (IsPC98_N() && _next_format_type == FORMAT_MEDIA_AT){
            _actual.PhysicalHiddenSectors =
                         (BIG_INT)(partition_info.StartingOffset /
                          disk_geometry.BytesPerSector);
            _actual.PhysicalSectorSize = 0L;
            memcpy(&_actual.PhysicalSectorSize,&disk_geometry.BytesPerSector,sizeof(USHORT));
        }

        if (!IsPC98_N() || (IsPC98_N() && _next_format_type==FORMAT_MEDIA_AT))
#endif // FE_SB && _X86_

        DiskGeometryToDriveType(&disk_geometry,
                                partition_info.PartitionLength/
                                disk_geometry.BytesPerSector,
                                partition_info.Mbr.HiddenSectors,
                                &_actual);

#if !defined(_AUTOCHECK_)
        if (Message && (wstr = _wgetenv(L"5XUFWX_FORMAT_SECTORS"))) {

            ULONG   sectors;
            INT     r;

            r = swscanf(wstr, L"%d", &sectors);
            if (r != 0 && r != EOF && sectors != 0 &&
                sectors <= _actual.Sectors.GetLowPart()) {
                Message->DisplayMsg(MSG_FMT_SECTORS, "%d", sectors);
                _actual.Sectors.Set(sectors, 0);
            } else {
                Message->DisplayMsg(MSG_FMT_BAD_SECTORS);
                return FALSE;
            }
        }
#endif

    } else {

        DiskGeometryToDriveType(&disk_geometry, &_actual);

        if (IsFloppy()) {

            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_GET_MEDIA_TYPES,
                                                 NULL, 0, media_types,
                                                 NumMediaTypes*
                                                 sizeof(DISK_GEOMETRY));

            if (!NT_SUCCESS(_last_status)) {
                DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_MEDIA_TYPES (%x)\n", _last_status));
                Destroy();
                if (Message) {

                    MSGID   MessageId;

                    switch (_last_status) {
                        case STATUS_NO_MEDIA_IN_DEVICE:
                            MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                            break;

                        case STATUS_DEVICE_BUSY:
                        case STATUS_DEVICE_NOT_READY:
                            MessageId = MSG_DEVICE_BUSY;
                            break;

                        case STATUS_DEVICE_OFF_LINE:
                            MessageId = MSG_DEVICE_OFF_LINE;
                            break;

                        default:
                            MessageId = MSG_BAD_IOCTL;
                            break;
                    }
                    Message->DisplayMsg(MessageId);
                }
                return FALSE;
            }



            _num_supported = (INT) (status_block.Information/
                                    sizeof(DISK_GEOMETRY));

            if (!_num_supported) {
                Destroy();
                if (Message) {
                    Message->DisplayMsg(MSG_BAD_IOCTL);
                }
                return FALSE;
            }

#if defined(FE_SB)
            INT j;
            DISK_GEOMETRY temp;

#if defined(_X86_)
    // PC98 Aug.26,1996

            if (IsPC98_N()) {
                for(i = 0; i < _num_supported; i++) {
                    // Remove F5_360_512 Media Type
                    if(media_types[i].MediaType==F5_360_512) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                    // Remove F8_256_128 Media Type
                    if(media_types[i].MediaType==F8_256_128) {
                        for(j = i; j < _num_supported - 1; j++) {
                            media_types[j]=media_types[j+1];
                        }
                        _num_supported--;
                    }
                }
            }
#endif // _X86_

            // NT-US diaplays the dialog box by MediaType order.
            // The MediaType order matches media size order on NT-US.
            // But PC98 has more media_types than US one.
            // And these does NOT match on PC98.
            // We wish to display the dialog box by size order.
            // See also..
            //   \nt\private\utils\fmifs\src\format.cxx
            //   QuerySupportedMedia()

            for(i = 0; i < _num_supported ; i++) {
                for(j = 0; j < _num_supported - 1; j++) {
                    if(media_types[j].Cylinders.LowPart *
                       media_types[j].TracksPerCylinder *
                       media_types[j].SectorsPerTrack *
                       media_types[j].BytesPerSector <
                       media_types[j+1].Cylinders.LowPart *
                       media_types[j+1].TracksPerCylinder *
                       media_types[j+1].SectorsPerTrack *
                       media_types[j+1].BytesPerSector) {
                         temp=media_types[j];
                         media_types[j]=media_types[j+1];
                         media_types[j+1]=temp;
                     }
                 }
            }
#endif // FE_SB
            if (!(_supported_list = NEW DRTYPE[_num_supported])) {
                Destroy();
                Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
                return FALSE;
            }

            for (i = 0; i < _num_supported; i++) {
                DiskGeometryToDriveType(&media_types[i], &_supported_list[i]);
            }
        }
    }

    if (!_num_supported) {
        _num_supported = 1;

        if (!(_supported_list = NEW DRTYPE[1])) {
            Destroy();
            Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
            return FALSE;
        }

        _supported_list[0] = _actual;
    }

    if (!CheckForPrimaryPartition()) {
        DebugPrintTrace(("IFSUTIL: Failed CheckForPrimaryPartition (%x)\n", _last_status));
        Destroy();
        if (Message) {

            MSGID   MessageId;

            switch (_last_status) {
                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                case STATUS_DEVICE_OFF_LINE:
                    MessageId = MSG_DEVICE_OFF_LINE;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }
            Message->DisplayMsg(MessageId);
        }
        return FALSE;
    }

    if (!CheckForSystemPartition()) {

        switch (_last_status) {
          case STATUS_BUFFER_TOO_SMALL:
            return FALSE;   // should not continue as the buffer should be long enough

          case STATUS_OBJECT_NAME_NOT_FOUND:
            break;          // ignore this one since it can happen in textmode setup

          default:
            //
            // Let's not fail just because we cannot determine if this is a system partition
            // This can happen in textmode setup.
            //
            DebugPrintTrace(("IFSUTIL: Failed CheckForSystemPartition (%x)\n", _last_status));
        }
    }

    //
    // Check ifthe device is hotpluggable
    //
    CheckHotPlugInfo();
    
    //
    // Determine whether the media is a super-floppy; non-floppy
    // removable media which is not partitioned.  Such media will
    // have but a single partition, normal media will have at least 4.
    //

    if (disk_geometry.MediaType == RemovableMedia) {

        BOOLEAN   bFallBack = FALSE;

        CONST INT EntriesPerBootRecord = 4;
        CONST INT MaxLogicalVolumes = 23;
        CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                            EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                sizeof(PARTITION_INFORMATION_EX);

        UCHAR buf[Length];

        DRIVE_LAYOUT_INFORMATION_EX *layout_info = (DRIVE_LAYOUT_INFORMATION_EX *)buf;

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                             NULL, 0, layout_info,
                                             Length);

#if 1
        if (!NT_SUCCESS(_last_status)) {

            if (_last_status == STATUS_INVALID_DEVICE_REQUEST) {

                CONST INT EntriesPerBootRecord = 4;
                CONST INT MaxLogicalVolumes = 23;
                CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION) +
                                    EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                        sizeof(PARTITION_INFORMATION);

                UCHAR buf[Length];

                DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

                bFallBack = TRUE;

                _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                     &status_block,
                                                     IOCTL_DISK_GET_DRIVE_LAYOUT,
                                                     NULL, 0, layout_info,
                                                     Length);

                if (!NT_SUCCESS(_last_status)) {
                    DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_DRIVE_LAYOUT (%x)\n", _last_status));
                } else if (layout_info->PartitionCount < 4) {
                    _super_floppy = TRUE;
                }

            } else {
                DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_GET_DRIVE_LAYOUT_EX (%x)\n", _last_status));
            }
        }
#endif

        if (!NT_SUCCESS(_last_status)) {

            Destroy();

            if (Message) {

                MSGID   MessageId;

                switch (_last_status) {
                    case STATUS_NO_MEDIA_IN_DEVICE:
                        MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                        break;

                    case STATUS_DEVICE_BUSY:
                    case STATUS_DEVICE_NOT_READY:
                        MessageId = MSG_DEVICE_BUSY;
                        break;

                    case STATUS_DEVICE_OFF_LINE:
                        MessageId = MSG_DEVICE_OFF_LINE;
                        break;
                    
                    default:
                        MessageId = MSG_BAD_IOCTL;
                        break;
                }
                Message->DisplayMsg(MessageId);
            }
            return FALSE;
        }

        if (!bFallBack) {
            if (layout_info->PartitionStyle == PARTITION_STYLE_MBR) {
                if (layout_info->PartitionCount < 4) {
                    _super_floppy = TRUE;
                }
            } else if (layout_info->PartitionStyle == PARTITION_STYLE_GPT) {
                if (layout_info->PartitionCount == 1 &&
                    layout_info->PartitionEntry[0].StartingOffset.QuadPart == 0) {

                    _super_floppy = TRUE;
                }
            }
        }

        CheckSonyMS();

        if (IsSonyMS()) {

#if !defined(_AUTOCHECK_)

            STORAGE_BUS_TYPE    bus_type;

            if (QueryBusType(&bus_type) && BusTypeUsb == bus_type) {

                SONY_MS_INQUIRY_DATA    inquiry_data;

                if (SendSonyMSInquiryCmd(&inquiry_data)) {

                    if (0 == memcmp(inquiry_data.device_capability, "MEMORYSTICK         ", 20) ||
                        0 == memcmp(inquiry_data.device_capability, "MEMORYSTICK-MG      ", 20)) {

                        DebugPrintTrace(("IFSUTIL: Fmt cmd capable reader\n"));
                        _sony_ms_fmt_cmd = TRUE;

                        SONY_MS_MODE_SENSE_DATA mode_sense_data;

                        if (SendSonyMSModeSenseCmd(&mode_sense_data)) {
                            if (mode_sense_data.srfp) {
                                DebugPrintTrace(("IFSUTIL: Reader also supports progress bar\n"));
                                _sony_ms_progress_indicator = TRUE;
                            }
                        }
                    }
                }
            }
#endif
        }
    }

    if (!IsTransient) {
        NtClose(_handle);
        _handle = 0;
    }

    return TRUE;
#endif // defined(RUN_ON_W2K)
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This method initializes a hosted drive, i.e. a volume which
    is implemented as a file on another volume.  Instead of opening
    this file by its actual name, we open it by the host file name,
    to prevent interactions with the file system.

Arguments:

    NtDriveName     - Supplies the NT name of the drive itself.
    HostFileName    - Supplies the fully qualified name of the file
                      which contains this drive.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK StatusBlock;
    BIG_INT Sectors, FileSize;
    ULONG AlignmentMask, ExtraUlong;


    Destroy();

    if( !DRIVE::Initialize(HostFileName, Message)) {

        Destroy();
        return FALSE;
    }

    _hosted_drive = TRUE;

    // First, make the host file not-readonly.
    //
    if( !IFS_SYSTEM::FileSetAttributes( HostFileName,
                                        FILE_ATTRIBUTE_NORMAL,
                                        &_old_attributes ) ) {

        Message ? Message->DisplayMsg( MSG_CANT_DASD ) : 1;
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( HostFileName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA |
                                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if( !NT_SUCCESS( _last_status ) ) {

        IFS_SYSTEM::FileSetAttributes( HostFileName,
                                       _old_attributes,
                                       &ExtraUlong );

        DebugPrintTrace(("IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        Destroy();
        return FALSE;
    }

    if( NtDriveName ) {

        _last_status = OpenDrive( NtDriveName,
                                  SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                  ExclusiveWrite,
                                  &_alternate_handle,
                                  &AlignmentMask,
                                  Message );
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &StatusBlock,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

    // Fill in the drive type information.  Everything except the
    // Sectors field is fixed by default.  The number of Sectors
    // on the drive is determined from the host file's size.
    //
    _actual.MediaType = HostedDriveMediaType;
    _actual.SectorSize = HostedDriveSectorSize;
    _actual.HiddenSectors = HostedDriveHiddenSectors;
    _actual.SectorsPerTrack = HostedDriveSectorsPerTrack;
    _actual.Heads = HostedDriveHeads;

    _last_status = NtQueryInformationFile( _handle,
                                           &StatusBlock,
                                           &FileStandardInfo,
                                           sizeof( FileStandardInfo ),
                                           FileStandardInformation );

    if( !NT_SUCCESS( _last_status ) ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_DISK_TOO_LARGE_TO_FORMAT ) : 1;
        return FALSE;
    }

    FileSize = FileStandardInfo.EndOfFile;
    Sectors = FileSize / _actual.SectorSize;

    if( Sectors.GetHighPart() != 0 ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_BAD_IOCTL ) : 1;
        return FALSE;
    }

    _actual.Sectors = Sectors.GetLargeInteger();


    // This drive has only one supported drive type
    //
    _num_supported = 1;

    if (!(_supported_list = NEW DRTYPE[1])) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    _supported_list[0] = _actual;

    // If this was a transient open, clean it up.
    //
    if (!IsTransient) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
        NtClose(_handle);
        _alternate_handle ? NtClose(_alternate_handle) : 1;
        _handle = 0;
        _alternate_handle = 0;
    }


    return TRUE;
}

IFSUTIL_EXPORT
ULONG
DP_DRIVE::QuerySectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per sector.

--*/
{
    return _actual.SectorSize;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
ULONG
DP_DRIVE::QueryPhysicalSectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per physical sector.

--*/
{
    return _actual.PhysicalSectorSize;
}
#endif


IFSUTIL_EXPORT
BIG_INT
DP_DRIVE::QuerySectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number sectors on the disk.  This does not
    include the hidden sectors.

Arguments:

    None.

Return Value:

    The number of sectors on the disk.

--*/
{
    return _actual.Sectors;
}


IFSUTIL_EXPORT
UCHAR
DP_DRIVE::QueryMediaByte(
        ) CONST
/*++

Routine Description:

        This routine computes the media byte used by the FAT and HPFS file
        systems to represent the current media type.

Arguments:

        None.

Return Value:

        The media byte for the drive.

--*/
{
    switch (_actual.MediaType) {
        case F5_1Pt2_512:   // 5.25", 1.2MB,  512 bytes/sector
            return 0xF9;

        case F3_1Pt44_512:  // 3.5",  1.44MB, 512 bytes/sector
        case F3_2Pt88_512:  // 3.5",  2.88MB, 512 bytes/sector
        case F3_120M_512:   // 3.5",  120MB,  512 bytes/sector
        case F3_200Mb_512:  // 3.5",  200MB,  512 bytes/sector
        case F3_240M_512:   // 3.5",  240MB,  512 bytes/sector
            return 0xF0;

        case F3_20Pt8_512:  // 3.5",  20.8MB, 512 bytes/sector
            return 0xF9;

        case F3_720_512:    // 3.5",  720KB,  512 bytes/sector
            return 0xF9;

        case F5_360_512:    // 5.25", 360KB,  512 bytes/sector
            return 0xFD;

        case F5_320_512:    // 5.25", 320KB,  512 bytes/sector
            return 0xFF;

        case F5_180_512:    // 5.25", 180KB,  512 bytes/sector
            return 0xFC;

        case F5_160_512:    // 5.25", 160KB,  512 bytes/sector
            return 0xFE;

        case RemovableMedia:// Removable media other than floppy
            return 0xF8;    // There is no better choice than this.

        case FixedMedia:    // Fixed hard disk media
#if defined(FE_SB) && defined(_X86_)
            // FMR Jul.13.1994 SFT KMR
            // Add the set up process for the fixed_hard_disk_mediaID for FMR
            // FMR's media id is different. Case under 64MB or not.

            if(IsFMR_N()) {
                if(_actual.SectorSize * _actual.Sectors <= 63*1024*1024) {
                    return 0xF9;
                } else {
                    return 0xFA;
                }
            } else
#endif
            return 0xF8;

#if defined(FE_SB)
        case F3_128Mb_512:  // 3.5"MO, 128MB, 512 bytes/sector
        case F3_230Mb_512:  // 3.3"MO, 230MB, 512 bytes/sector
            return 0xF0;

#if defined(_X86_)
        // NEC Oct.15.1994
        // FMR Jul.14.1994 SFT KMR

        // For 8"1S , 256KB , 128 bytes/sector
        // If the media_type is 2HD, return the mediaID:FE

        case F8_256_128:    // 8"1S , 256KB , 128 bytes/sector
        case F5_1Pt23_1024: // 5.25", 1.23MB,  1024 bytes/sector
        case F3_1Pt23_1024: // 3.5",  1.23MB,  1024 bytes/sector
            return 0xFE;

        // If the media_type is 2HC, return the mediaID:F9
        // If the media_type is 2DD(720KB), return the mediaID:F9

        case F5_720_512:    // 5.25",  720KB,  512 bytes/sector
        case F3_1Pt2_512:   // 3.5",  1.2MB,    512 bytes/sector
            return 0xF9;

        // If the media_type is 2DD(640KB), return the mediaID:FB

        case F5_640_512:    // 5",    640KB,  512 bytes/sector
        case F3_640_512:    // 3.5",  640KB,  512 bytes/sector
            return 0xFB;
#endif // _X86_
#endif // FE_SB

        case F5_320_1024:
        case Unknown:
            break;

    }

    return 0;
}


VOID
DP_DRIVE::Destroy(
        )
/*++

Routine Description:

    This routine returns a DP_DRIVE to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG ExtraUlong;

    memset(&_actual, 0, sizeof(DRTYPE));
    DELETE_ARRAY(_supported_list);
    _num_supported = 0;
    _alignment_mask = 0;
    _super_floppy = FALSE;
    _is_writeable = FALSE;
    _is_primary_partition = FALSE;
    _is_system_partition = FALSE;
#if defined(FE_SB) && defined(_X86_)
    _format_type = NONE;
#endif
    _sony_ms = FALSE;
    _sony_ms_fmt_cmd = FALSE;
    _sony_ms_progress_indicator = FALSE;
    _ntfs_not_supported = FALSE;

    if (_hosted_drive) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
    }

    if (_alternate_handle) {

        NtClose(_alternate_handle);
        _alternate_handle = 0;
    }

    if (_handle) {

        NtClose(_handle);
        _handle = 0;
    }

    _hosted_drive = FALSE;
    memset(&_partition_info, 0, sizeof(_partition_info));
}


VOID
DP_DRIVE::CloseDriveHandle(
    )
{
    if (_handle) {
        NtClose(_handle);
        _handle = 0;
    }
}


BOOLEAN
DP_DRIVE::IsSupported(
    IN  MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the supplied media type is supported
    by the drive.

Arguments:

    MediaType   - Supplies the media type.

Return Value:

    FALSE   - The media type is not supported by the drive.
    TRUE    - The media type is supported by the drive.

--*/
{
    INT i;

    for (i = 0; i < _num_supported; i++) {
        if (MediaType == _supported_list[i].MediaType) {
            return TRUE;
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
MEDIA_TYPE
DP_DRIVE::QueryRecommendedMediaType(
    ) CONST
/*++

Routine Description:

    This routine computes the recommended media type for
    drive.  This media type is independant of any existing
    media type for the drive.  It is solely based on the
    list of recommended media types for the drive.

Arguments:

    None.

Return Value:

    The recommended media type for the drive.

--*/
{
    INT         i;
    MEDIA_TYPE  media_type;
    SECTORCOUNT sectors;

    media_type = Unknown;
    sectors = 0;
    for (i = 0; i < _num_supported; i++) {

        // Special case 1.44.  If a drive supports it then
        // that should be the recommended media type.

        if (_supported_list[i].MediaType == F3_1Pt44_512) {
            media_type = _supported_list[i].MediaType;
            break;
        }

        if (_supported_list[i].Sectors > sectors) {
            media_type = _supported_list[i].MediaType;
        }
    }

    return media_type;
}

#if defined ( DBLSPACE_ENABLED )
BOOLEAN
DP_DRIVE::QueryMountedFileSystemName(
    OUT PWSTRING FileSystemName,
    OUT PBOOLEAN IsCompressed
    )
/*++

Routine Description:

    This method returns the name of the file system
    which has mounted this volume.

Arguments:

    FileSystemName  - Receives the name of the file system
                      which has mounted this volume.
    IsCompressed    - Receives TRUE if the volume is compressed,
                      FALSE if it's not compressed or if the
                      method fails.

Return Value:

    TRUE upon successful completion.

--*/
{
    CONST                           buffer_length = 64;
    BYTE                            buffer[buffer_length];
    PFILE_FS_ATTRIBUTE_INFORMATION  fs_info;
    IO_STATUS_BLOCK                 status_block;
    NTSTATUS                        status;

    DebugPtrAssert( FileSystemName );
    DebugPtrAssert( IsCompressed );

    *IsCompressed = FALSE;

    fs_info = (PFILE_FS_ATTRIBUTE_INFORMATION) buffer;

    status = NtQueryVolumeInformationFile( (_alternate_handle != 0) ?
                                                _alternate_handle : _handle,
                                           &status_block,
                                           fs_info,
                                           buffer_length,
                                           FileFsAttributeInformation );

    if( !NT_SUCCESS( status ) || fs_info->FileSystemNameLength == 0 ) {

        return FALSE;
    }

    *IsCompressed =
        (fs_info->FileSystemAttributes & FILE_VOLUME_IS_COMPRESSED) ?
        TRUE : FALSE;

    return( FileSystemName->Initialize( fs_info->FileSystemName,
                                        fs_info->FileSystemNameLength ) );
}

BOOLEAN
DP_DRIVE::MountCvf(
    IN  PCWSTRING   CvfName,
    IN  PMESSAGE    Message
    )
/*++

Routine Description:

    This method mounts a file on the drive as a Double Space volume.

Arguments:

    CvfName --  Supplies the name of the Compressed Volume File.
    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion

--*/
{
    CONST                   MountBufferSize = 64;
    IO_STATUS_BLOCK         status_block;
    BYTE                    MountBuffer[MountBufferSize];
    PFILE_MOUNT_DBLS_BUFFER MountInfo;

    MountInfo = (PFILE_MOUNT_DBLS_BUFFER)MountBuffer;

    if( _hosted_drive ||
        !CvfName->QueryWSTR( 0,
                             TO_END,
                             MountInfo->CvfName,
                             (MountBufferSize - sizeof(ULONG))/sizeof(WCHAR),
                             TRUE ) ) {

        Message->DisplayMsg( MSG_DBLSPACE_CANT_MOUNT, "%W", CvfName );
        return FALSE;
    }

    MountInfo->CvfNameLength = CvfName->QueryChCount() * sizeof(WCHAR);

    _last_status = NtFsControlFile( _handle,
                                    0, NULL, NULL,
                                    &status_block,
                                    FSCTL_MOUNT_DBLS_VOLUME,
                                    MountBuffer,
                                    sizeof( MountBuffer ),
                                    NULL, 0 );

    if( !NT_SUCCESS( _last_status ) ) {

        Message->DisplayMsg( MSG_DBLSPACE_CANT_MOUNT, "%W", CvfName );
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
DP_DRIVE::SetCvfSize(
    IN  ULONG   Size
    )
/*++

Routine Description:

    This routine sets the size of the cvf.  Used to grow or
    shrink the cvf while converted filesystems from or to
    dblspace.  The caller is responsible for placing the
    proper signature at the end of the last sector in the cvf.

Arguments:

    Size - desired size, in bytes, of the entire cvf.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure.

--*/
{
    IO_STATUS_BLOCK status_block;
    FILE_ALLOCATION_INFORMATION allocation;

    allocation.AllocationSize.HighPart = 0;
    allocation.AllocationSize.LowPart = Size;

    _last_status = NtSetInformationFile(_handle,
                                        &status_block,
                                        &allocation,
                                        sizeof(allocation),
                                        FileAllocationInformation
                                        );
    if (!NT_SUCCESS(_last_status)) {
        return FALSE;
    }

    DebugAssert(Size % _actual.SectorSize == 0);

    _actual.Sectors = Size / _actual.SectorSize;

    return TRUE;
}
#endif  // DBLSPACE_ENABLED

BOOLEAN
DP_DRIVE::SetMediaType(
    IN  MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine alters the media type of the drive.  If 'MediaType' is
    'Unknown' and the current media type for the drive is also 'Unknown'
    then this routine selects the highest density supported by the
    driver.  If the current media type is known then this function
    will have no effect if 'MediaType' is 'Unknown'.

Arguments:

    MediaType   - Supplies the new media type for the drive.

Return Value:

    FALSE   - The proposed media type is not supported by the drive.
    TRUE    - Success.

--*/
{
    INT i;

    if (MediaType == Unknown) {
        if (_actual.MediaType != Unknown) {
            return TRUE;
        } else if (!_num_supported) {
            return FALSE;
        }

        for (i = 0; i < _num_supported; i++) {
            if (_supported_list[i].Sectors > QuerySectors()) {
                _actual = _supported_list[i];
            }
        }

        return TRUE;
    }

    for (i = 0; i < _num_supported; i++) {
        if (_supported_list[i].MediaType == MediaType) {
            _actual = _supported_list[i];
            return TRUE;
        }
    }

    return FALSE;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry    - Supplies the disk geometry for the drive.
    DriveType       - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = DiskGeometry->Cylinders*
                         DiskGeometry->TracksPerCylinder*
                         DiskGeometry->SectorsPerTrack;
    DriveType->HiddenSectors = 0;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    IN  BIG_INT         NumSectors,
    IN  BIG_INT         NumHiddenSectors,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry        - Supplies the disk geometry for the drive.
    NumSectors          - Supplies the total number of non-hidden sectors on
                        the disk.
    NumHiddenSectors    - Supplies the number of hidden sectors on the disk.
    DriveType           - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = NumSectors;
    DriveType->HiddenSectors = NumHiddenSectors;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::IsATformat(
    ) CONST
/*++

Routine Description:

    This routine judged whether it is AT format.

Arguments:

    None.

Return Value:

    FALSE   - The disk is not AT format.
    TRUE    - The disk is AT format.

History:

    PC98 Oct.21.1995

--*/
{
    return _next_format_type == FORMAT_MEDIA_AT;
}
#endif


DEFINE_CONSTRUCTOR( IO_DP_DRIVE, DP_DRIVE );

VOID
IO_DP_DRIVE::Construct (
        )

/*++

Routine Description:

    Constructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _is_locked = FALSE;
    _is_exclusive_write = FALSE;
    _cache = NULL;
    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


VOID
IO_DP_DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns an IO_DP_DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_cache);

    if (_is_exclusive_write) {
        Dismount();
        _is_exclusive_write = FALSE;
    }

    if (_is_locked) {
        Unlock();
        _is_locked = FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


IO_DP_DRIVE::~IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DP_DRIVE::Initialize(NtDriveName, Message, TRUE, ExclusiveWrite, FormatType)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another
    volume.

Arguments:

    NtDriveName     - Supplies the drive path.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if( !DP_DRIVE::Initialize(NtDriveName,
                              HostFileName,
                              Message,
                              TRUE,
                              ExclusiveWrite)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Write(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
VOID
IO_DP_DRIVE::SetCache(
    IN OUT  PDRIVE_CACHE    Cache
    )
/*++

Routine Description:

    This routine relaces the current cache with the one supplied.
    The object then takes ownership of this cache and it will be
    deleted by the object.

Arguments:

    Cache   - Supplies the new cache to install.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(Cache);
    DELETE(_cache);
    _cache = Cache;
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::FlushCache(
    )
/*++

Routine Description:

    This routine flushes the cache and report returns whether any
    IO error occurred during the life of the cache.

Arguments:

    None.

Return Value:

    FALSE   - Some IO errors have occured during the life of the cache.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Flush();
}


BOOLEAN
IO_DP_DRIVE::HardRead(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           sector_size;
    ULONG           buffer_size;
    IO_STATUS_BLOCK status_block;
    BIG_INT         secptr;
    BIG_INT         endofrange;
    SECTORCOUNT     increment;
    PCHAR           bufptr;
    BIG_INT         byte_offset;
    BIG_INT         tmp;
    LARGE_INTEGER   l;
#if defined(IO_PERF_COUNTERS)
    LARGE_INTEGER   rt1, rt2;
#endif

#if TRAP_A_READ
    BIG_INT         end_offset;
    char            bufptr2[0x10000];
#endif


#if 0
    //
    // For testing bad sectors.
    //
    BIG_INT bad_sector = 0x8fc0;
    if ((StartingSector <= bad_sector) && 
        (bad_sector < StartingSector + NumberOfSectors)) {

        DebugPrintTrace(("HardRead: NtReadFile failure simulation for sector: 0x%I64x\n",
                                 bad_sector));
        return FALSE;
        
    }
    

#endif


    DebugAssert(!(((ULONG_PTR) Buffer) & QueryAlignmentMask()));

    sector_size = QuerySectorSize();
    endofrange = StartingSector + NumberOfSectors;
    increment = MaxIoSize/sector_size;

#if defined(IO_PERF_COUNTERS)
    _rcount.QuadPart++;
#endif
    bufptr = (PCHAR) Buffer;
    for (secptr = StartingSector; secptr < endofrange; secptr += increment) {

        byte_offset = secptr*sector_size;

        if (secptr + increment > endofrange) {
            tmp = endofrange - secptr;
            DebugAssert(tmp.GetHighPart() == 0);
            buffer_size = sector_size*tmp.GetLowPart();
#if defined(IO_PERF_COUNTERS)
            _rsize.QuadPart = _rsize.QuadPart + tmp.GetQuadPart();
#endif
        } else {
            buffer_size = sector_size*increment;
#if defined(IO_PERF_COUNTERS)
            _rsize.QuadPart = _rsize.QuadPart + increment;
#endif
        }

        l = byte_offset.GetLargeInteger();

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt1);
#endif
        _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                  bufptr, buffer_size, &l, NULL);
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt2);
        _rrtotal.QuadPart = _rrtotal.QuadPart + (rt2.QuadPart - rt1.QuadPart);
#endif

#if TRAP_A_READ
        end_offset = byte_offset + buffer_size - 1;
        if (((0x5eUL*0x200UL) <= end_offset && end_offset <= (0x5fUL*0x200UL)) ||
                ((0x5eUL*0x200UL) <= byte_offset && byte_offset <= (0x5fUL*0x200UL)) ||
                (byte_offset <= (0x5eUL*0x200UL) && (0x5fUL*0x200UL) <= end_offset)) {
            _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                      bufptr2, buffer_size, &l, NULL);
            __asm int 3;
        }
        if (((0x18fffUL*0x200UL) <= end_offset && end_offset <= (0x19000UL*0x200UL)) ||
                ((0x18fffUL*0x200UL) <= byte_offset && byte_offset <= (0x19000UL*0x200UL)) ||
                (byte_offset <= (0x18fffUL*0x200UL) && (0x19000UL*0x200UL) <= end_offset)) {
            _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                      bufptr2, buffer_size, &l, NULL);
            __asm int 3;
        }
#endif

        if (_last_status == STATUS_NO_MEMORY) {
            increment /= 2;
            secptr -= increment;
            continue;
        }

        if (NT_ERROR(_last_status) || status_block.Information != buffer_size) {

            if (NT_ERROR(_last_status)) {
                DebugPrintTrace(("HardRead: NtReadFile failure: %x, %I64x, %x\n",
                                 _last_status, l, buffer_size));
            } else {
                DebugPrintTrace(("HardRead: NtReadFile failure: %I64x, %x, %x\n",
                                 l, status_block.Information, buffer_size));
            }

            if (_message) {
                if (NT_ERROR(_last_status)) {
                    _message->LogMsg(MSG_CHKLOG_READ_FAILURE,
                                     "%x%I64x%x", _last_status, l, buffer_size);
                } else {
                    _message->LogMsg(MSG_CHKLOG_READ_INCORRECT,
                                     "%I64d%x%x", l, status_block.Information, buffer_size);
                }
            }

            return FALSE;
        }

        bufptr += buffer_size;
    }

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::HardWrite(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

    MJB: After writing each chunk, we read it back to make sure the write
    really succeeded.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           sector_size;
    ULONG           buffer_size;
    IO_STATUS_BLOCK status_block;
    BIG_INT         secptr;
    BIG_INT         endofrange;
    SECTORCOUNT     increment;
    PCHAR           bufptr;
    PCHAR           scratch_ptr;
    BIG_INT         byte_offset;
    BIG_INT         tmp;
    LARGE_INTEGER   l;
    CHAR            ScratchIoBuf[MaxIoSize + 511];

#if defined(IO_PERF_COUNTERS)
    LARGE_INTEGER   wt1, wt2, rt1, rt2, ct1, ct2;
#endif

#if TRAP_A_WRITE
    BIG_INT     end_offset;
#endif


#if 0
    //
    // For testing bad sectors.
    //
    BIG_INT bad_sector = 8 * 0xa21dce;
    if ((StartingSector <= bad_sector) && 
        (bad_sector < StartingSector + NumberOfSectors)) {

        DebugPrintTrace(("HardWrite: NtReadFile failure simulation for sector: 0x%I64x\n",
                                 bad_sector));
        return FALSE;
        
    }
    
#endif


    DebugAssert(!(((ULONG_PTR) Buffer) & QueryAlignmentMask()));
    DebugAssert(QueryAlignmentMask() < 0x200);

    if (! ((ULONG_PTR)ScratchIoBuf & QueryAlignmentMask())) {
        scratch_ptr = ScratchIoBuf;
    } else {
        scratch_ptr = (PCHAR)((ULONG_PTR) ((PCHAR)ScratchIoBuf +
            QueryAlignmentMask()) & (~(ULONG_PTR)QueryAlignmentMask()));
    }
    DebugAssert(!(((ULONG_PTR) scratch_ptr) & QueryAlignmentMask()));

    sector_size = QuerySectorSize();
    endofrange = StartingSector + NumberOfSectors;
    increment = MaxIoSize/sector_size;

#if defined(IO_PERF_COUNTERS)
    _wcount.QuadPart++;
#endif
    bufptr = (PCHAR) Buffer;
    for (secptr = StartingSector; secptr < endofrange; secptr += increment) {

        byte_offset = secptr*sector_size;

        if (secptr + increment > endofrange) {
            tmp = endofrange - secptr;
            DebugAssert(tmp.GetHighPart() == 0);
            buffer_size = sector_size*tmp.GetLowPart();
#if defined(IO_PERF_COUNTERS)
            _wsize.QuadPart = _wsize.QuadPart + tmp.GetQuadPart();
#endif
        } else {
            buffer_size = sector_size*increment;
#if defined(IO_PERF_COUNTERS)
            _wsize.QuadPart = _wsize.QuadPart + increment;
#endif
        }

        l = byte_offset.GetLargeInteger();

#if TRAP_A_WRITE
        end_offset = byte_offset + buffer_size - 1;
        if (((0x5eUL*0x200UL) <= end_offset && end_offset <= (0x5fUL*0x200UL)) ||
                ((0x5eUL*0x200UL) <= byte_offset && byte_offset <= (0x5fUL*0x200UL)) ||
                (byte_offset <= (0x5eUL*0x200UL) && (0x5fUL*0x200UL) <= end_offset)) {
            __asm int 3;
        }
        if (((0x18fffUL*0x200UL) <= end_offset && end_offset <= (0x19000UL*0x200UL)) ||
                ((0x18fffUL*0x200UL) <= byte_offset && byte_offset <= (0x19000UL*0x200UL)) ||
                (byte_offset <= (0x18fffUL*0x200UL) && (0x19000UL*0x200UL) <= end_offset)) {
            __asm int 3;
        }
#endif

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&wt1);
#endif
        _last_status = NtWriteFile(_handle, 0, NULL, NULL, &status_block,
                                   bufptr, buffer_size, &l, NULL);
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&wt2);
        _wtotal.QuadPart = _wtotal.QuadPart + (wt2.QuadPart - wt1.QuadPart);
#endif

        if (_last_status == STATUS_NO_MEMORY) {
            increment /= 2;
            secptr -= increment;
            continue;
        }

        if (NT_ERROR(_last_status) || status_block.Information != buffer_size) {

            if (NT_ERROR(_last_status)) {
                DebugPrintTrace(("HardWrite: NtWriteFile failure: %x, %I64x, %x\n",
                                 _last_status, l, buffer_size));
            } else {
                DebugPrintTrace(("HardWrite: NtWriteFile failure: %I64x, %x, %x\n",
                                 l, status_block.Information, buffer_size));
            }

            if (_message) {
                if (NT_ERROR(_last_status)) {
                    _message->LogMsg(MSG_CHKLOG_WRITE_FAILURE,
                                     "%x%I64x%x", _last_status, l, buffer_size);
                } else {
                    _message->LogMsg(MSG_CHKLOG_WRITE_INCORRECT,
                                     "%I64d%x%x", l, status_block.Information, buffer_size);
                }
            }

            return FALSE;
        }

        DebugAssert(buffer_size <= MaxIoSize);

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt1);
#endif
        _last_status = NtReadFile(_handle, 0, NULL, NULL, &status_block,
                                  scratch_ptr, buffer_size, &l, NULL);
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&rt2);
        _rtotal.QuadPart = _rtotal.QuadPart + (rt2.QuadPart - rt1.QuadPart);
#endif

        if (NT_ERROR(_last_status) || status_block.Information != buffer_size) {

            if (NT_ERROR(_last_status)) {
                DebugPrintTrace(("HardWrite: NtReadFile failure: %x, %I64x, %x\n",
                                 _last_status, l, buffer_size));
            } else {
                DebugPrintTrace(("HardWrite: NtReadFile failure: %I64x, %x, %x\n",
                                 l, status_block.Information, buffer_size));
            }

            if (_message) {
                if (NT_ERROR(_last_status)) {
                    _message->LogMsg(MSG_CHKLOG_WRITE_FAILURE,
                                  "%x%I64x%x", _last_status, l, buffer_size);
                } else {
                    _message->LogMsg(MSG_CHKLOG_WRITE_INCORRECT,
                                 "%I64x%x%x", l, status_block.Information, buffer_size);
                }
            }

            return FALSE;
        }

#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&ct1);
#endif
        if (0 != memcmp(scratch_ptr, bufptr, buffer_size)) {

            DebugPrint("What's read back does not match what's written out\n");
            if (_message) {
                _message->LogMsg(MSG_CHKLOG_READ_BACK_FAILURE,
                                 "%I64x%x", l, buffer_size);
            }

            return FALSE;
        }
#if defined(IO_PERF_COUNTERS)
        QueryPerformanceCounter(&ct2);
        _ctotal.QuadPart = _ctotal.QuadPart + (ct2.QuadPart - ct1.QuadPart);
#endif

        bufptr += buffer_size;
    }

    return TRUE;
}


BOOLEAN
DP_DRIVE::CheckForPrimaryPartition(
    )
/*++

Routine Description:

    This routine checks to see if the volume is on a primary partition.
    It sets the result returned by IsPrimaryPartition routine.

Arguments:

    N/A

Return Value:

    TRUE if successfully determined if the volume is on a primary
    partition.
--*/
{
#if defined(RUN_ON_W2K)
    CONST INT EntriesPerBootRecord = 4;
    CONST INT MaxLogicalVolumes = 23;
    CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                        EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                            sizeof(PARTITION_INFORMATION_EX);

    IO_STATUS_BLOCK             status_block;
    STORAGE_DEVICE_NUMBER       device_info;
    UCHAR                       buf[Length];
    DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

    ULONG                       i, partition_count;

    _is_primary_partition = FALSE;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                         NULL, 0, &device_info,
                                         sizeof(STORAGE_DEVICE_NUMBER));

    if (NT_SUCCESS(_last_status) && device_info.DeviceType == FILE_DEVICE_DISK &&
        (device_info.PartitionNumber != -1 && device_info.PartitionNumber != 0)) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status))
            return FALSE;

        partition_count = min(4, layout_info->PartitionCount);

        for (i=0; i<partition_count; i++) {
            if (layout_info->PartitionEntry[i].PartitionNumber ==
                device_info.PartitionNumber) {
                _is_primary_partition = TRUE;
                break;
            }
        }
    }

    return TRUE;
#else // defined(RUN_ON_W2K)
    CONST INT EntriesPerBootRecord = 4;
    CONST INT MaxLogicalVolumes = 23;
    CONST INT Info_Length =  EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                            sizeof(PARTITION_INFORMATION_EX);
    INT       Length = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + Info_Length;

    IO_STATUS_BLOCK             status_block;
    STORAGE_DEVICE_NUMBER       device_info;
    DRIVE_LAYOUT_INFORMATION_EX *layout_info, *temp;

    ULONG                       i, partition_count;

    _is_primary_partition = FALSE;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                         NULL, 0, &device_info,
                                         sizeof(STORAGE_DEVICE_NUMBER));

    if (NT_SUCCESS(_last_status) && device_info.DeviceType == FILE_DEVICE_DISK &&
        (device_info.PartitionNumber != -1 && device_info.PartitionNumber != 0)) {

        layout_info = (DRIVE_LAYOUT_INFORMATION_EX *) MALLOC(Length);

        do {

            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                             NULL, 0, layout_info,
                                             Length);

            if (!NT_SUCCESS(_last_status)) {
                if ((_last_status == STATUS_BUFFER_TOO_SMALL) 
                        && (Length += Info_Length)
                        && ((temp = (DRIVE_LAYOUT_INFORMATION_EX *)REALLOC(layout_info, Length)) != NULL)) {
                    layout_info = temp;    
                } else {
                    FREE(layout_info);
                    return FALSE;
                }
            }
        }while (_last_status == STATUS_BUFFER_TOO_SMALL);

        if (layout_info->PartitionStyle == PARTITION_STYLE_MBR) {
            partition_count = min(4, layout_info->PartitionCount);

            for (i=0; i<partition_count; i++) {
                if (layout_info->PartitionEntry[i].PartitionNumber ==
                    device_info.PartitionNumber) {
                    _is_primary_partition = TRUE;
                    break;
                }
            }
        }

        FREE(layout_info);
    }

    return TRUE;
#endif // defined(RUN_ON_W2K)
}

BOOLEAN
DP_DRIVE::CheckForSystemPartition(
    )
/*++

Routine Description:

    This routine checks to see if the volume is a system partition.
    It sets the result returned by IsSystemPartition routine.

Arguments:

    N/A

Return Value:

    TRUE if successfully determined if the volume is a system partition.
--*/
{
    BYTE                buffer[MAX_PATH*sizeof(WCHAR)+sizeof(MOUNTDEV_NAME)];
    PMOUNTDEV_NAME      mountdev_name = (PMOUNTDEV_NAME)buffer;
    WCHAR               system_partition[MAX_PATH];
    IO_STATUS_BLOCK     status_block;

    _is_system_partition = FALSE;

    _last_status = QuerySystemPartitionValue(system_partition, sizeof(system_partition));

    if (!NT_SUCCESS(_last_status)) {
        DebugPrintTrace(("IFSUTIL: Unable to query system partition in registry (%x)\n", _last_status));
        return FALSE;
    }
    // DebugPrintTrace(("CheckForSystemPartition: SP: %ls\n", system_partition));

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                         NULL, 0, mountdev_name,
                                         sizeof(buffer));

    if (!NT_SUCCESS(_last_status)) {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_MOUNTDEV_QUERY_DEVICE_NAME (%x)\n", _last_status));
        return FALSE;
    }

    if (mountdev_name->NameLength < MAX_PATH) {
        mountdev_name->Name[mountdev_name->NameLength/sizeof(WCHAR)] = 0;
    } else {
        DebugPrintTrace(("IFSUTIL: CheckForSystemPartition: Device Name too long (%d, %d)\n",
                         mountdev_name->NameLength, status_block.Information));
        _last_status = STATUS_BUFFER_TOO_SMALL;
        return FALSE;
    }

    // DebugPrintTrace(("CheckForSystemPartition: DN: %ls\n", mountdev_name->Name));

    if (WSTRING::Stricmp(system_partition, mountdev_name->Name) == 0) {
        // DebugPrintTrace(("CheckForSystemPartition: This is a system partition\n"));
        _is_system_partition = TRUE;
    }

    return TRUE;
}

BOOLEAN
DP_DRIVE::QueryBusType(
    OUT PSTORAGE_BUS_TYPE   BusType
    )
/*++

Routine Description:

    This routine returns the bus type of the device.

Arguments:

    N/A

Return Value:

    TRUE if successful retrieval of the bus type.

--*/
{
    STORAGE_PROPERTY_QUERY      spq;
    IO_STATUS_BLOCK             status_block;
    BYTE                        buffer[sizeof(STORAGE_DEVICE_DESCRIPTOR)+0x100];
    PSTORAGE_DEVICE_DESCRIPTOR  sdd = (PSTORAGE_DEVICE_DESCRIPTOR)buffer;

    spq.PropertyId = StorageDeviceProperty;
    spq.QueryType = PropertyStandardQuery;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block, IOCTL_STORAGE_QUERY_PROPERTY,
                                         &spq,
                                         sizeof(spq),
                                         sdd,
                                         sizeof(buffer));

    if (NT_SUCCESS(_last_status)) {
        *BusType = sdd->BusType;
        return TRUE;
    } else {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_STORAGE_QUERY_PROPERTY (%x)\n", _last_status));
        return FALSE;
    }
}

BOOLEAN
DP_DRIVE::CheckHotPlugInfo(
    )
/*++

Routine Description:

    This routine determines if ntfs file system should be used on this device.

Arguments:

    N/A

Return Value:

    TRUE if successful.

--*/
{
    BOOLEAN     NoNtfsSupport;

    _last_status = DP_DRIVE::QueryNtfsSupportInfo(_handle, &NoNtfsSupport);

    if (NT_SUCCESS(_last_status)) {
        _ntfs_not_supported = NoNtfsSupport;
        return TRUE;
    } else {
        _ntfs_not_supported = FALSE;
        return FALSE;
    }
}

NTSTATUS
DP_DRIVE::QueryNtfsSupportInfo(
    IN     HANDLE                   DriveHandle,
       OUT PBOOLEAN                 NoNtfsSupport
    )
/*++

Routine Description:

    This routine determines if ntfs file system should be used on this device.

Arguments:

    DriveHandle     - Supplies a handle to the volume.
    NoNtfsSupport   - Retrieves a boolean which tells if ntfs should be used on the device.

Return Value:

    NTSTATUS of the query

--*/
{
    IO_STATUS_BLOCK         status_block;
    NTSTATUS                status;
    STORAGE_HOTPLUG_INFO    hpinfo;

    status = NtDeviceIoControlFile(DriveHandle, 0, NULL, NULL,
                                   &status_block, IOCTL_STORAGE_GET_HOTPLUG_INFO,
                                   NULL,
                                   0,
                                   &hpinfo,
                                   sizeof(STORAGE_HOTPLUG_INFO));

    if (NT_SUCCESS(status)) {
        if (NoNtfsSupport != NULL) {
            *NoNtfsSupport = (hpinfo.MediaHotplug || hpinfo.DeviceHotplug);
        }
    } else {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_STORAGE_GET_HOTPLUG_INFO (%x)\n", status));
    }

    return status;
}


BOOLEAN
DP_DRIVE::QueryMrwSupport(
    IN     HANDLE                   DriveHandle
    )
/*++

Routine Description:

    This routine determines if the media in the drive supports Mt Rainier Format.

Arguments:

    DriveHandle     - Supplies a handle to the volume.

Return Value:

    TRUE    - supports Mt Rainier Format
    FALSE   - no suport for Mt Rainier Format

--*/
{
    UCHAR   buffer[sizeof(GET_CONFIGURATION_HEADER)+sizeof(FEATURE_DATA_MRW)];
    UCHAR   expected_size = sizeof(GET_CONFIGURATION_HEADER)+sizeof(FEATURE_DATA_MRW);
    
    GET_CONFIGURATION_IOCTL_INPUT   mrw_request;
    IO_STATUS_BLOCK                 status_block;
    NTSTATUS                        status;
        
    RtlZeroMemory(buffer, sizeof(buffer));
    RtlZeroMemory(&mrw_request, sizeof(GET_CONFIGURATION_IOCTL_INPUT));

    mrw_request.Feature = FeatureMrw;
    mrw_request.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;


    status = NtDeviceIoControlFile(DriveHandle, 0, NULL, NULL,
                                   &status_block, IOCTL_CDROM_GET_CONFIGURATION,
                                   &mrw_request,
                                   sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                   buffer,
                                   expected_size);


    if (NT_SUCCESS(status)) {

        PGET_CONFIGURATION_HEADER get_config_header = (PGET_CONFIGURATION_HEADER)buffer;
        PFEATURE_DATA_MRW mrw_feature = (PFEATURE_DATA_MRW)get_config_header->Data;
        ULONG valid_data;
        ULONG feature_code;

        valid_data =
            (get_config_header->DataLength[0] << (8*3)) |
            (get_config_header->DataLength[1] << (8*2)) |
            (get_config_header->DataLength[2] << (8*1)) |
            (get_config_header->DataLength[3] << (8*0)) ;
        valid_data += RTL_SIZEOF_THROUGH_FIELD(GET_CONFIGURATION_HEADER, DataLength);

        if (valid_data < expected_size) {
            return FALSE;
        }

        feature_code =
            (mrw_feature->Header.FeatureCode[0] << (8*1)) |
            (mrw_feature->Header.FeatureCode[1] << (8*0)) ;
        if (feature_code != FeatureMrw) {
            return FALSE;
        }

        if (mrw_feature->Header.Current) {
            return TRUE;
        } else {
            return FALSE;
        }
    
    } else {
        DebugPrintTrace(("IFSUTIL: Failed IOCTL_CDROM_GET_CONFIGURATION (%x)\n", status));
        return FALSE;
    }

}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors
    )
/*++

Routine Description:

    This routine verifies a run of sectors on the disk.

Arguments:

    StartingSector  - Supplies the first sector of the run to verify.
    NumberOfSectors - Supplies the number of sectors in the run to verify.

Return Value:

    FALSE   - Some of the sectors in the run are bad.
    TRUE    - All of the sectors in the run are good.

--*/
{
    VERIFY_INFORMATION  verify_info;
    IO_STATUS_BLOCK     status_block;
    BIG_INT             starting_offset;
    BIG_INT             verify_size;

    DebugAssert(QuerySectorSize());

    _last_status = STATUS_SUCCESS;

    if (IsFloppy() || !_is_exclusive_write) {
        return VerifyWithRead(StartingSector, NumberOfSectors);
    }

    starting_offset = StartingSector*QuerySectorSize();
    verify_size = NumberOfSectors*QuerySectorSize();

    verify_info.StartingOffset = starting_offset.GetLargeInteger();

    // Note: norbertk Verify IOCTL is destined to go to a BIG_INT length.
    DebugAssert(verify_size.GetHighPart() == 0);
    verify_info.Length = verify_size.GetLowPart();

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block, IOCTL_DISK_VERIFY,
                                         &verify_info,
                                         sizeof(VERIFY_INFORMATION),
                                         NULL, 0);

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN      BIG_INT         StartingSector,
    IN      BIG_INT         NumberOfSectors,
    IN OUT  PNUMBER_SET     BadSectors
    )
/*++

Routine Description:

    This routine computes which sectors in the given range are bad
    and adds these bad sectors to the bad sectors list.

Arguments:

    StartingSector  - Supplies the starting sector.
    NumberOfSectors - Supplies the number of sectors.
    BadSectors      - Supplies the bad sectors list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       MaxSectorsInVerify = 512;

    ULONG       MaxDiskHits;
    BIG_INT     half;
    PBIG_INT    starts;
    PBIG_INT    run_lengths;
    ULONG       i, n;
    BIG_INT     num_sectors;

    if (NumberOfSectors == 0) {
        return TRUE;
    }

    if (NumberOfSectors.GetHighPart() != 0) {
        DebugPrint("IFSUTIL: Number of sectors to verify exceeded 32 bits\n");
        return FALSE;
    }


    //
    // Check to see if block length has been set
    //
    if (!_ValidBlockLengthForVerify) {

        num_sectors = min(NumberOfSectors, MaxSectorsInVerify);

        while (!Verify(StartingSector, num_sectors)) {
            if (QueryLastNtStatus() == STATUS_INVALID_BLOCK_LENGTH ||
                QueryLastNtStatus() == STATUS_INVALID_DEVICE_REQUEST) {
                if (num_sectors == 1) {
                    DebugPrint("IFSUTIL: Number of sectors to verify mysteriously down to 1\n");
                    return FALSE;
                }
                num_sectors = num_sectors / 2;
            } else
                break;
        }

        DebugAssert(num_sectors.GetHighPart() == 0);

        if (QueryLastNtStatus() == STATUS_SUCCESS) {

            if (!(NumberOfSectors < MaxSectorsInVerify &&
                  NumberOfSectors == num_sectors))
                MaxSectorsInVerify = _ValidBlockLengthForVerify = num_sectors.GetLowPart();


            if (num_sectors == NumberOfSectors)
                return TRUE;    // done, return
            else {
                //
                // skip over sectors that has been verified
                //
                StartingSector += num_sectors;
                NumberOfSectors -= num_sectors;
            }
        }
    } else
        MaxSectorsInVerify = _ValidBlockLengthForVerify;


    // Allow 20 retries so that a single bad sector in this region
    // will be found accurately.

    MaxDiskHits = (20 + NumberOfSectors/MaxSectorsInVerify + 1).GetLowPart();

    if (!(starts = NEW BIG_INT[MaxDiskHits]) ||
        !(run_lengths = NEW BIG_INT[MaxDiskHits])) {

        DELETE_ARRAY(starts);
        DELETE_ARRAY(run_lengths);
        return FALSE;
    }

    num_sectors = NumberOfSectors;
    for (i = 0; num_sectors > 0; i++) {
        starts[i] = StartingSector + i*MaxSectorsInVerify;
        if (MaxSectorsInVerify > num_sectors) {
            run_lengths[i] = num_sectors;
        } else {
            run_lengths[i] = MaxSectorsInVerify;
        }
        num_sectors -= run_lengths[i];
    }

    n = i;

    for (i = 0; i < n; i++) {

        if (!Verify(starts[i], run_lengths[i])) {

            if (QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE) {
                DELETE_ARRAY(starts);
                DELETE_ARRAY(run_lengths);
                return FALSE;
            }

            DebugAssert(QueryLastNtStatus() != STATUS_INVALID_BLOCK_LENGTH &&
                        QueryLastNtStatus() != STATUS_INVALID_DEVICE_REQUEST);

            if (BadSectors == NULL) {
                DELETE_ARRAY(starts);
                DELETE_ARRAY(run_lengths);
                return FALSE;
            }

            if (n + 2 > MaxDiskHits) {

                if (!BadSectors->Add(starts[i], run_lengths[i])) {
                    DELETE_ARRAY(starts);
                    DELETE_ARRAY(run_lengths);
                    return FALSE;
                }

            } else {

                if (run_lengths[i] == 1) {

                    if (!BadSectors->Add(starts[i])) {
                        DELETE_ARRAY(starts);
                        DELETE_ARRAY(run_lengths);
                        return FALSE;
                    }

                } else {

                    half = run_lengths[i]/2;

                    starts[n] = starts[i];
                    run_lengths[n] = half;
                    starts[n + 1] = starts[i] + half;
                    run_lengths[n + 1] = run_lengths[i] - half;

                    n += 2;
                }
            }
        }
    }


    DELETE_ARRAY(starts);
    DELETE_ARRAY(run_lengths);

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::VerifyWithRead(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors
    )
/*++

Routine Description:

    This routine verifies the usability of the given range of sectors
    using read.

Arguments:

    StartingSector      - Supplies the starting sector of the verify.
    Number OfSectors    - Supplies the number of sectors to verify.

Return Value:

    FALSE   - At least one of the sectors in the given range was unreadable.
    TRUE    - All of the sectors in the given range are readable.

--*/
{
    HMEM    hmem;
    ULONG   grab;
    BIG_INT i;

    if (!hmem.Initialize() ||
        !hmem.Acquire(MaxIoSize, QueryAlignmentMask())) {

        return FALSE;
    }

    grab = MaxIoSize/QuerySectorSize();
    for (i = 0; i < NumberOfSectors; i += grab) {

        if (NumberOfSectors - i < grab) {
            grab = (NumberOfSectors - i).GetLowPart();
        }

        if (!HardRead(StartingSector + i, grab, hmem.GetBuf())) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Lock(
    )
/*++

Routine Description:

    This routine locks the drive.  If the drive is already locked then
    this routine will do nothing.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    if (_is_locked) {
        return TRUE;
    }

    if (_hosted_drive && _alternate_handle == 0) {

        // This is a hosted volume which is not mounted as
        // a drive--locking succeeds.
        //
        _is_locked = TRUE;
        _is_exclusive_write = TRUE;
        return TRUE;
    }

    _last_status = NtFsControlFile( (_alternate_handle != 0) ?
                                        _alternate_handle : _handle,
                                    0, NULL, NULL,
                                    &status_block,
                                    FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

    _is_locked = (BOOLEAN) NT_SUCCESS(_last_status);

    if (_is_locked) {
        _is_exclusive_write = TRUE;
    } else {
        DebugPrintTrace(("IFSUTIL: Unable to lock the volume (%x)\n", _last_status));
    }

    return _is_locked;
}


BOOLEAN
IO_DP_DRIVE::InvalidateVolume(
    )
/*++

Routine Description:

    This routine invalidates the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HANDLE              handle;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   attributes;
    IO_STATUS_BLOCK     ioStatusBlock;
#if 0
    BOOLEAN             WasEnabled;
    NTSTATUS            status;
    PNTSTATUS           pstatus;

    _last_status = RtlAdjustPrivilege( SE_TCB_PRIVILEGE,
                                       TRUE,              // Enable
                                       FALSE,             // Client
                                       &WasEnabled
                                     );

    if (!NT_SUCCESS(_last_status)) {
        DebugPrintTrace(("IFSUTIL: Unable to adjust privilege (%x)\n", _last_status));
        return FALSE;
    }
#endif

    RtlInitUnicodeString(&unicodeString, L"\\Fat");

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    _last_status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                        &attributes,
                        &ioStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(_last_status)) {
        _last_status = NtFsControlFile( handle,
                                        0, NULL, NULL,
                                        &ioStatusBlock,
                                        FSCTL_INVALIDATE_VOLUMES,
                                        (_alternate_handle != 0) ? &_alternate_handle : &_handle,
                                        sizeof(HANDLE), NULL, 0);

        if (!NT_SUCCESS(_last_status)) {
            DebugPrintTrace(("IFSUTIL: Unable to invalidate volume (%x)\n", _last_status));
        }

    } else {
        DebugPrintTrace(("IFSUTIL: Unable to obtain a handle from fastfat driver (%x)\n", _last_status));
    }

#if 0
    if (WasEnabled) {

        if (NT_SUCCESS(_last_status))
            pstatus = &_last_status;
        else
            pstatus = &status;

        *pstatus = RtlAdjustPrivilege( SE_TCB_PRIVILEGE,
                                       FALSE,             // Enable
                                       FALSE,             // Client
                                       &WasEnabled
                                     );

        if (!NT_SUCCESS(*pstatus)) {
            DebugPrintTrace(("IFSUTIL: Unable to restore privilege (%x) but return successful status anyway.\n",
                             *pstatus));
        }
    }
#endif

    return (BOOLEAN)NT_SUCCESS(_last_status);
}


BOOLEAN
IO_DP_DRIVE::ForceDirty(
    )
/*++

Routine Description:

    This routine forces the volume to be dirty, so that autochk will
    run next time the system reboots.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    _last_status = NtFsControlFile((_alternate_handle != 0) ?
                                        _alternate_handle : _handle,
                                   0, NULL, NULL,
                                   &status_block,
                                   FSCTL_MARK_VOLUME_DIRTY,
                                   NULL, 0, NULL, 0);

    return ((BOOLEAN) NT_SUCCESS(_last_status));
}


BOOLEAN
IO_DP_DRIVE::Unlock(
    )
/*++

Routine Description:

    This routine unlocks the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;
    NTSTATUS        status;

    if (_hosted_drive && _alternate_handle == 0 ) {

        return TRUE;
    }

    _last_status = NtFsControlFile((_alternate_handle != 0) ?
                                      _alternate_handle : _handle,
                                      0, NULL, NULL,
                                      &status_block,
                                      FSCTL_UNLOCK_VOLUME,
                                      NULL, 0, NULL, 0);

    return NT_SUCCESS(_last_status);

}


BOOLEAN
IO_DP_DRIVE::Dismount(
    )
/*++

Routine Description:

    This routine dismounts the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    if( _hosted_drive && _alternate_handle == 0 ) {

        return TRUE;
    }

    if( !NT_SUCCESS(_last_status = NtFsControlFile((_alternate_handle != 0) ?
                                          _alternate_handle : _handle,
                                    0, NULL, NULL,
                                    &status_block,
                                    FSCTL_DISMOUNT_VOLUME,
                                    NULL, 0, NULL, 0)) ) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::DismountAndUnlock(
    )
/*++

Routine Description:

    This routine dismounts the drive and unlocks it.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN r = TRUE;

    // 
    // If the volume is already dismounted using DismountAndLock
    // an atttempt to dismount it will result in STATUS_VOLUME_DISMOUNTED
    // and a subsequent attemp to unlock it will result in
    // STATUS_NOT_LOCKED. So we account for both of those cases and 
    // return success.
    //
    if (_is_exclusive_write) {
        r = Dismount() || (_last_status == STATUS_VOLUME_DISMOUNTED);
        _is_exclusive_write = FALSE;
    }

    if (_is_locked) {
        r = (Unlock() || (_last_status == STATUS_NOT_LOCKED)) && r;
        _is_locked = FALSE;
    }

    return r;
}


BOOLEAN
IO_DP_DRIVE::DismountAndLock(
    )
/*++

Routine Description:

    This routine locks the drive.  If the drive is already locked then
    this routine will do nothing.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK status_block;

    if( _hosted_drive && _alternate_handle == 0 ) {
        //
        // This is a hosted volume which is not mounted as
        // a drive--locking succeeds.
        //
        _is_locked = TRUE;
        _is_exclusive_write = TRUE;
        return TRUE;
    }
    
    
    _is_locked = Dismount();

    if (_is_locked) {
        _is_exclusive_write = TRUE;
    } else {
        DebugPrintTrace(("IFSUTIL: Unable to dismount and lock the volume (%x)\n", _last_status));
    }

    return _is_locked;
}




BOOLEAN
IO_DP_DRIVE::FormatVerifyFloppy(
    IN      MEDIA_TYPE  MediaType,
    IN OUT  PNUMBER_SET BadSectors,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsDmfFormat
    )
/*++

Routine Description:

    This routine low level formats an entire floppy disk to the media
    type specified.  If no MediaType is specified then a logical one will
    be selected.

Arguments:

    MediaType   - Supplies an optional media type to format to.
    BadSectors  - Returns a list of bad sectors on the disk.
    Message     - Supplies a message object to route messages to.
    IsDmfFormat - Supplies whether or not to perform a DMF type format.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK         status_block;
    CONST                   format_parameters_size = sizeof(FORMAT_EX_PARAMETERS) + 20*sizeof(USHORT);
    CHAR                    format_parameters_buffer[format_parameters_size];
    PFORMAT_EX_PARAMETERS   format_parameters;
    PBAD_TRACK_NUMBER       bad;
    ULONG                   num_bad, j;
    ULONG                   i;
    ULONG                   cyl;
    ULONG                   percent;
    ULONG                   sec_per_track;
    ULONG                   sec_per_cyl;
    HMEM                    hmem;
    MSGID                   MessageId;
    USHORT                  swap_buffer[3];

    // We don't make sure that the volume is locked here because
    // it's not strictly necessary and 'diskcopy' will format
    // floppies without locking them.

    if (!SetMediaType(MediaType) ||
        (IsDmfFormat && QueryMediaType() != F3_1Pt44_512)) {

        Message ? Message->DisplayMsg(MSG_NOT_SUPPORTED_BY_DRIVE) : 1;
        return FALSE;
    }

    format_parameters = (PFORMAT_EX_PARAMETERS) format_parameters_buffer;
    format_parameters->MediaType = QueryMediaType();
    format_parameters->StartHeadNumber = 0;
    format_parameters->EndHeadNumber = QueryHeads() - 1;

    if (IsDmfFormat) {
        sec_per_track = 21;
        format_parameters->FormatGapLength = 8;
        format_parameters->SectorsPerTrack = (USHORT) sec_per_track;
        format_parameters->SectorNumber[0] = 12;
        format_parameters->SectorNumber[1] = 2;
        format_parameters->SectorNumber[2] = 13;
        format_parameters->SectorNumber[3] = 3;
        format_parameters->SectorNumber[4] = 14;
        format_parameters->SectorNumber[5] = 4;
        format_parameters->SectorNumber[6] = 15;
        format_parameters->SectorNumber[7] = 5;
        format_parameters->SectorNumber[8] = 16;
        format_parameters->SectorNumber[9] = 6;
        format_parameters->SectorNumber[10] = 17;
        format_parameters->SectorNumber[11] = 7;
        format_parameters->SectorNumber[12] = 18;
        format_parameters->SectorNumber[13] = 8;
        format_parameters->SectorNumber[14] = 19;
        format_parameters->SectorNumber[15] = 9;
        format_parameters->SectorNumber[16] = 20;
        format_parameters->SectorNumber[17] = 10;
        format_parameters->SectorNumber[18] = 21;
        format_parameters->SectorNumber[19] = 11;
        format_parameters->SectorNumber[20] = 1;
    } else {
        sec_per_track = QuerySectorsPerTrack();
    }
    sec_per_cyl = sec_per_track*QueryHeads();

    DebugAssert(QueryCylinders().GetHighPart() == 0);
    cyl = QueryCylinders().GetLowPart();
    num_bad = QueryHeads();
    if (num_bad == 0 || cyl == 0) {
        return FALSE;
    }

        if (!(bad = NEW BAD_TRACK_NUMBER[num_bad])) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    if (!hmem.Acquire(sec_per_cyl*QuerySectorSize(), QueryAlignmentMask())) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }


    Message ? Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0) : 1;

    percent = 0;
    for (i = 0; i < cyl; i++) {

        format_parameters->StartCylinderNumber = i;
        format_parameters->EndCylinderNumber = i;

        if (IsDmfFormat) {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS_EX,
                                                 format_parameters,
                                                 format_parameters_size,
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));

            // Skew the next cylinder by 3 sectors from this one.

            RtlMoveMemory(swap_buffer,
                          &format_parameters->SectorNumber[18],
                          3*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[3],
                          &format_parameters->SectorNumber[0],
                          18*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[0],
                          swap_buffer,
                          3*sizeof(USHORT));

        } else {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS,
                                                 format_parameters,
                                                 sizeof(FORMAT_PARAMETERS),
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));
        }

        if (!NT_SUCCESS(_last_status)) {
            DebugPrintTrace(("IFSUTIL: Failed IOCTL_DISK_FORMAT_TRACKS (%x)\n", _last_status));
            DELETE_ARRAY(bad);

            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_MEDIA_WRITE_PROTECTED:
                    MessageId = MSG_FMT_WRITE_PROTECTED_MEDIA ;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                case STATUS_DEVICE_OFF_LINE:
                    MessageId = MSG_DEVICE_OFF_LINE;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;
            return FALSE;
        }


        // Verify the sectors.

        if (BadSectors) {

            if (!Read(i*sec_per_cyl, sec_per_cyl, hmem.GetBuf())) {

                // If this is the first track then give out.
                // A disk with a bad cylinder 0 is not
                // worth continuing on.
                //
                // As of 7/29/94, formatting 2.88 floppies to 1.44
                // doesn't work on Alphas; if we can't format to
                // 1.44 and 2.88 is supported, try 2.88.
                //
                if (i == 0) {

                    if( !IsDmfFormat &&
                        QueryMediaType() == F3_1Pt44_512 &&
                        SetMediaType(F3_2Pt88_512) ) {

                        return( FormatVerifyFloppy( F3_2Pt88_512,
                                                    BadSectors,
                                                    Message,
                                                    IsDmfFormat ) );

                    } else {

                        Message ? Message->DisplayMsg(MSG_UNUSABLE_DISK) : 1;
                        return FALSE;
                    }
                }

                for (j = 0; j < sec_per_cyl; j++) {
                    if (!Read(i*sec_per_cyl + j, 1, hmem.GetBuf())) {
                        if (!BadSectors->Add(i*sec_per_cyl + j)) {
                            return FALSE;
                        }
                    }
                }
            }
        }

        if ((i + 1)*100/cyl > percent) {
            percent = (i + 1)*100/cyl;
            if (percent > 100) {
                percent = 100;
            }

            // This check for success on the message object
            // has to be there for FMIFS to implement CANCEL.

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                DELETE_ARRAY(bad);
                return FALSE;
            }
        }
    }

    DELETE_ARRAY(bad);

    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( LOG_IO_DP_DRIVE, IO_DP_DRIVE, IFSUTIL_EXPORT );


IFSUTIL_EXPORT
LOG_IO_DP_DRIVE::~LOG_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for LOG_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite, FormatType);
}

IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another volume.


Arguments:

    NtDriveName     - Supplies the path of the drive object.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName,
                                   HostFileName,
                                   Message,
                                   ExclusiveWrite);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::SetSystemId(
    IN  PARTITION_SYSTEM_ID   SystemId
    )
/*++

Routine Description:

    This routine sets the system identifier (or partition type) in the
    hidden sectors of a logical volume on a fixed disk.

Arguments:

    SystemId    - Supplies the system id to write in the partition entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    IO_STATUS_BLOCK             status_block;
    SET_PARTITION_INFORMATION   partition_info;

    //
    // This operation is unnecessary on floppies, super-floppies, and
    // hosted volumes.
    //

    if (IsFloppy() || IsSuperFloppy() || _hosted_drive) {
        return TRUE;
    }

    if( SystemId == SYSID_NONE ) {

        // Note: billmc -- we should never set it to zero!

        DebugPrint( "Skip setting the partition type to zero.\n" );
        return TRUE;
    }

    partition_info.PartitionType = (UCHAR)SystemId;

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_DISK_SET_PARTITION_INFO,
                                         &partition_info,
                                         sizeof(SET_PARTITION_INFORMATION),
                                         NULL, 0);

    return NT_SUCCESS(_last_status) ||
           _last_status == STATUS_INVALID_DEVICE_REQUEST;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Write(StartingSector, NumberOfSectors, Buffer);
}
#endif // FE_SB && _X86_


DEFINE_CONSTRUCTOR( PHYS_IO_DP_DRIVE, IO_DP_DRIVE );

PHYS_IO_DP_DRIVE::~PHYS_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for PHYS_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
PHYS_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a PHYS_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite, FormatType);
}

#if defined(IO_PERF_COUNTERS)
VOID
IO_DP_DRIVE::QueryPerformanceCounters(
        PLARGE_INTEGER          Wtime,
        PLARGE_INTEGER          Rtime,
        PLARGE_INTEGER          Ctime,
        PLARGE_INTEGER          WSecCount,
        PLARGE_INTEGER          WCount,
        PLARGE_INTEGER          RRtime,
        PLARGE_INTEGER          RSecCount,
        PLARGE_INTEGER          RCount
)
{
        *Wtime = _wtotal;
        *Rtime = _rtotal;
        *Ctime = _ctotal;
        *WSecCount = _wsize;
        *WCount = _wcount;

        *RRtime = _rrtotal;
        *RSecCount = _rsize;
        *RCount = _rcount;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\digraph.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

        digraph.cxx

Abstract:

        This module implements the Directed Graph class.

Author:

        Matthew Bradburn (mattbr)  11-Nov-1994

Remarks:

    The class is implemented as a mapping from parent to child.
    There is a hash table of parents, with a linked-list of parent nodes
    from each hash table bucket... each parent node then holds a pointer
    to a tree of child nodes which share an edge with that parent.  In an
    attempt to save memory, each child node actually has a starting value
    and a bitmap which describes the possible children immediately following
    that starting value.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_
#define MAXIMUM_CYCLE_SEARCH_LENGTH 1024

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "digraph.hxx"
#include "numset.hxx"
#include "bitvect.hxx"
#include "list.hxx"
#include "intstack.hxx"


CONST NumHeads = 1024;

DEFINE_EXPORTED_CONSTRUCTOR( DIGRAPH, OBJECT, IFSUTIL_EXPORT );

DEFINE_EXPORTED_CONSTRUCTOR( DIGRAPH_EDGE, OBJECT, IFSUTIL_EXPORT );

VOID
DIGRAPH::Construct (
        )
/*++

Routine Description:

    Constructor for DIGRAPH.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _parent_head = NULL;
    _num_nodes = 0;
}


VOID
DIGRAPH::Destroy(
    )
/*++

Routine Description:

    This routine returns the DIGRAPH to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE_ARRAY(_parent_head);
    _num_nodes = 0;
}


IFSUTIL_EXPORT
DIGRAPH::~DIGRAPH(
    )
/*++

Routine Description:

    Destructor for DIGRAPH.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::Initialize(
    IN  ULONG   NumberOfNodes
    )
/*++

Routine Description:

    This routine initializes this class to an empty directed graph.

Arguments:

    NumberOfNodes   - Supplies the number of nodes in the graph.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _num_nodes = NumberOfNodes;

    if (!(_parent_head = NEW PPARENT_ENTRY[NumHeads]) ||
        !_parent_mgr.Initialize(sizeof(PARENT_ENTRY)) ||
        !_element_mgr.Initialize()) {

        return FALSE;
    }

    memset(_parent_head, 0, sizeof(PPARENT_ENTRY)*NumHeads);

    return TRUE;
}

RTL_GENERIC_COMPARE_RESULTS
GenericChildCompare(
    RTL_GENERIC_TABLE *Table,
    PVOID First,
    PVOID Second
    )
/*++

Routine Description:

    This routine is required for use by the Generic Table package.
    In this case it will be used only to find the node containing
    a particular child, and the caller will search the bits in that
    node after that.


--*/
{
    PCHILD_ENTRY FirstChild = PCHILD_ENTRY(First);
    PCHILD_ENTRY SecondChild = PCHILD_ENTRY(Second);

    if (FirstChild->Child < SecondChild->Child) {
        return GenericLessThan;
    }
    if (FirstChild->Child > SecondChild->Child) {
        return GenericGreaterThan;
    }
    return GenericEqual;
}

PVOID
NTAPI
GenericChildAllocate(
    RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )
{
    return ((PDIGRAPH)Table->TableContext)->AllocChild(ByteSize);
}

VOID
NTAPI
GenericChildDeallocate(
    RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )
{
    ((PDIGRAPH)Table->TableContext)->FreeChild(Buffer);
}

PPARENT_ENTRY
DIGRAPH::GetParentEntry(
    IN  ULONG   Parent
    ) CONST
/*++

Routine Description:

    This routine searches for the requested parent entry and returns it if
    it is found.

Arguments:

    Parent  - Supplies the number of the parent.

Return Value:

    A pointer to the requested parent entry or NULL.

--*/
{
    PPARENT_ENTRY   r;

    for (r = _parent_head[Parent%NumHeads]; NULL != r; r = r->Next) {
        if (r->Parent == Parent) {
            break;
        }
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::AddEdge(
    IN  ULONG   Parent,
    IN  ULONG   Child
    )
/*++

Routine Description:

    This routine adds an edge to the digraph.

Arguments:

    Parent  - Supplies the source node of the edge.
    Child   - Supplies the destination node of the edge.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Parent < _num_nodes);
    DebugAssert(Child < _num_nodes);

    PPARENT_ENTRY   parent_entry;
    CHILD_ENTRY     new_child;
    PCHILD_ENTRY    pChild;
    RTL_BITMAP      bitmap_hdr;

    memset(&new_child, 0, sizeof(new_child));

    //
    // Figure out which node we're looking for by rounding Child down
    // to the appropriate alignment.
    //

    new_child.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    DebugAssert(new_child.Child <= Child);
    DebugAssert(new_child.Child + BITS_PER_CHILD_ENTRY >= Child);

    if (!(parent_entry = GetParentEntry(Parent))) {
        if (!(parent_entry = (PPARENT_ENTRY) _parent_mgr.Alloc())) {
            return FALSE;
        }

        parent_entry->Next = _parent_head[Parent%NumHeads];
        parent_entry->Parent = Parent;

        RtlInitializeGenericTable(
            &parent_entry->Children,
            GenericChildCompare,
            GenericChildAllocate,
            GenericChildDeallocate,
            this
            );

        _parent_head[Parent%NumHeads] = parent_entry;
    }

    pChild = (PCHILD_ENTRY)RtlInsertElementGenericTable(
                &parent_entry->Children,
                &new_child,
                sizeof(new_child),
                NULL
                );
    if (NULL == pChild) {
        return FALSE;
    }

    RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits, BITS_PER_CHILD_ENTRY);

    RtlSetBits(&bitmap_hdr, Child - new_child.Child, 1);

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::RemoveEdge(
    IN  ULONG   Parent,
    IN  ULONG   Child
    )
/*++

Routine Description:

    This routine removes an edge from the digraph.

Arguments:

    Parent  - Supplies the source node of the edge.
    Child   - Supplies the destination node of the edge.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Parent < _num_nodes);
    DebugAssert(Child < _num_nodes);

    PPARENT_ENTRY   parent_entry;
    CHILD_ENTRY     curr;
    PCHILD_ENTRY    pChild;
    RTL_BITMAP      bitmap_hdr;

    curr.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    if (!(parent_entry = GetParentEntry(Parent))) {
        return TRUE;
    }

    pChild = (PCHILD_ENTRY)RtlLookupElementGenericTable(
        &parent_entry->Children,
        &curr);
    if (NULL == pChild) {
        return TRUE;
    }

    RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits, BITS_PER_CHILD_ENTRY);

    RtlClearBits(&bitmap_hdr, Child - curr.Child, 1);

    //
    // Now if the entire bitmap for this node is clear, we'll delete
    // the node itself.
    //

    if ((ULONG)-1 == RtlFindSetBits(&bitmap_hdr, 1, 0)) {
        RtlDeleteElementGenericTable(&parent_entry->Children, &curr);
    }

    return TRUE;
}


ULONG
DIGRAPH::QueryNumChildren(
    IN  ULONG   Parent
    ) CONST
/*++

Routine Description:

    This routine computes the number of children that belong to the
    given parent.

Arguments:

    Parent  - Supplies the parent node.

Return Value:

    The number of children pointed to by the parent.

--*/
{
    PPARENT_ENTRY   parent_entry;
    RTL_BITMAP      bitmap_hdr;
    PVOID           restart_key;
    PVOID           ptr;
    ULONG           r;

    if (!(parent_entry = GetParentEntry(Parent))) {
        return 0;
    }

    //
    // Need to enuerate through all the children and count the bits in
    // each bitmap.
    //

    r = 0;
    restart_key = NULL;

    for (ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key);
         ptr != NULL;
         ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key)) {

        RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
             BITS_PER_CHILD_ENTRY);

        r += RtlNumberOfSetBits(&bitmap_hdr);
    }

    return r;
}


ULONG
DIGRAPH::QueryNumParents(
    IN  ULONG   Child
    ) CONST
/*++

Routine Description:

    This routine computes the number of parents that belong to the
    given child.

Arguments:

    Child   - Supplies the child node.

Return Value:

    The number of parents that point to the child.

--*/
{
    ULONG           i, r;
    PPARENT_ENTRY   currp;
    CHILD_ENTRY     curr;
    RTL_BITMAP      bitmap_hdr;
    PCHILD_ENTRY    pChild;

    curr.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    r = 0;
    for (i = 0; i < NumHeads; i++) {
        for (currp = _parent_head[i]; currp; currp = currp->Next) {

            //
            // Increment <r> if the child tree contains <Child>.
            //

            pChild = (PCHILD_ENTRY)RtlLookupElementGenericTable(
                &currp->Children, &curr);
            if (NULL == pChild) {
                continue;
            }

            RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits,
                BITS_PER_CHILD_ENTRY);

            if (RtlCheckBit(&bitmap_hdr, Child - curr.Child)) {
                r++;
            }
        }
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::QueryChildren(
    IN  ULONG       Parent,
    OUT PNUMBER_SET Children
    ) CONST
/*++

Routine Description:

    This routine computes the children of the given parent.

Arguments:

    Parent      - Supplies the parent.
    Children    - Return the children.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPARENT_ENTRY   parent_entry;
    RTL_BITMAP      bitmap_hdr;
    PVOID           restart_key;
    PVOID           ptr;
    ULONG           i;

    if (!Children->Initialize()) {
        return FALSE;
    }

    if (!(parent_entry = GetParentEntry(Parent))) {
        return TRUE;
    }

    restart_key = NULL;
    for (ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key);
         ptr != NULL;
         ptr = RtlEnumerateGenericTableWithoutSplaying(
            &parent_entry->Children, &restart_key)) {

        //
        // Add a child for each set bit in this node.
        //

        RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
            BITS_PER_CHILD_ENTRY);

        for (i = 0; i < BITS_PER_CHILD_ENTRY; ++i) {

            if (RtlCheckBit(&bitmap_hdr, i)) {

                if (!Children->Add(PCHILD_ENTRY(ptr)->Child + i)) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::QueryParents(
    IN  ULONG       Child,
    OUT PNUMBER_SET Parents
    ) CONST
/*++

Routine Description:

    This routine computes the parents of the given child.

Arguments:

    Child      - Supplies the child.
    Parents    - Return the parents.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    PPARENT_ENTRY   currp;
    CHILD_ENTRY     curr;
    PCHILD_ENTRY    pChild;
    RTL_BITMAP      bitmap_hdr;

    curr.Child = Child & ~(BITS_PER_CHILD_ENTRY - 1);

    if (!Parents->Initialize()) {
        return FALSE;
    }

    for (i = 0; i < NumHeads; i++) {
        for (currp = _parent_head[i]; currp; currp = currp->Next) {

            pChild = (PCHILD_ENTRY)RtlLookupElementGenericTable(
                &currp->Children, &curr);
            if (NULL == pChild) {
                continue;
            }

            RtlInitializeBitMap(&bitmap_hdr, pChild->ChildBits,
                BITS_PER_CHILD_ENTRY);

            if (RtlCheckBit(&bitmap_hdr, Child - curr.Child)) {

                if (!Parents->Add(currp->Parent)) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::QueryParentsWithChildren(
    OUT PNUMBER_SET Parents,
    IN  ULONG       MinimumNumberOfChildren
    ) CONST
/*++

Routine Description:

    This routine returns a list of all digraph nodes with out degree
    greater than or equal to the given minimum.

Arguments:

    Parents                 - Returns a list of parents.
    MinimumNumberOfChildren - Supplies the minimum number of children
                                that a parent must have to qualify for
                                the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    PPARENT_ENTRY   currp;
    ULONG           count;
    RTL_BITMAP      bitmap_hdr;
    PVOID           ptr;
    PVOID           restart_key;

    if (!Parents->Initialize()) {
        return FALSE;
    }

    if (!MinimumNumberOfChildren) {
        return Parents->Add(0, _num_nodes);
    }

    for (i = 0; i < NumHeads; i++) {
        for (currp = _parent_head[i]; currp; currp = currp->Next) {

            //
            // Need to enumerate nodes of the tree and count bits in
            // each node.
            //

            restart_key = NULL;
            count = 0;

            for (ptr = RtlEnumerateGenericTableWithoutSplaying(
                    &currp->Children, &restart_key);
                 ptr != NULL;
                 ptr = RtlEnumerateGenericTableWithoutSplaying(
                    &currp->Children, &restart_key)) {

                RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
                    BITS_PER_CHILD_ENTRY);

                count += RtlNumberOfSetBits(&bitmap_hdr);

                if (count >= MinimumNumberOfChildren) {
                    break;
                }
            }

            if (count >= MinimumNumberOfChildren) {
                if (!Parents->Add(currp->Parent)) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
DIGRAPH::EliminateCycles(
    IN OUT  PCONTAINER  RemovedEdges,
    OUT PBOOLEAN CompletionStatus
    )
/*++

Routine Description:

    This routine eliminates cycles from the digraph and then returns
    the edges that had to be removed.

Arguments:

    RemovedEdges     - Returns the edges removed from the digraph.
    CompletionStatus - Returns whether all the cycles have been successfully
                       detected. THis will be set only if the function suceeds,
                       that is, returns TRUE.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BITVECTOR   visited;
    ULONG       i;
    INTSTACK    ancestors;

    if (!visited.Initialize(_num_nodes) || !ancestors.Initialize()) {
        return FALSE;
    }

    _all_cycles_detected = TRUE;

    for (i = 0; i < _num_nodes; i++) {

        if (!visited.IsBitSet(i) &&
            !DescendDigraph(i, &visited, &ancestors, RemovedEdges)) {

            return FALSE;
        }
    }

    *CompletionStatus = _all_cycles_detected;
    return TRUE;
}


BOOLEAN
DIGRAPH::DescendDigraph(
    IN      ULONG       CurrentNode,
    IN OUT  PBITVECTOR  Visited,
    IN OUT  PINTSTACK   Ancestors,
    IN OUT  PCONTAINER  RemovedEdges
    )
/*++

Routine Description:

    This routine does a depth first search on the digraph.

Arguments:

    CurrentNode - Supplies the current node being evaluated.
    Visited     - Supplies a list of nodes which have been visited.
    Ancestors   - Supplies a stack of direct ancestors.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPARENT_ENTRY   parent_entry;
    PNUMBER_SET     nodes_to_delete;
    ULONG           i, set_card, child_node;
    PDIGRAPH_EDGE   p;
    RTL_BITMAP      bitmap_hdr;
    PVOID           restart_key;
    PVOID           ptr;

    // if the DFS search stack is greater that the maximum allowed
    // do not go any deeper to avoid stack overflow
    if (Ancestors->QuerySize() > MAXIMUM_CYCLE_SEARCH_LENGTH) {
        _all_cycles_detected = FALSE;
        return TRUE;
    }


    Visited->SetBit(CurrentNode);
    if (!Ancestors->Push(CurrentNode)) {
        return FALSE;
    }

    nodes_to_delete = NULL;

    if (NULL != (parent_entry = GetParentEntry(CurrentNode))) {

        // traverse list

        restart_key = NULL;
        for (ptr = RtlEnumerateGenericTableWithoutSplaying(
                &parent_entry->Children, &restart_key);
             ptr != NULL;
             ptr = RtlEnumerateGenericTableWithoutSplaying(
                &parent_entry->Children, &restart_key)) {

            for (i = 0; i < BITS_PER_CHILD_ENTRY; ++i) {

                RtlInitializeBitMap(&bitmap_hdr, PCHILD_ENTRY(ptr)->ChildBits,
                    BITS_PER_CHILD_ENTRY);

                if (0 == RtlCheckBit(&bitmap_hdr, i)) {
                    continue;
                }

                //
                // Child + i is a child of this parent.
                //


                if (Visited->IsBitSet(PCHILD_ENTRY(ptr)->Child + i)) {

                    // Check for cycle.

                    if (Ancestors->IsMember(PCHILD_ENTRY(ptr)->Child + i)) {

                        // Cycle detected.

                        if (!nodes_to_delete) {
                            if (!(nodes_to_delete = NEW NUMBER_SET) ||
                                !nodes_to_delete->Initialize()) {

                                DELETE(nodes_to_delete);
                                return FALSE;
                            }
                        }

                        if (!nodes_to_delete->Add(PCHILD_ENTRY(ptr)->Child + i)) {
                            DELETE(nodes_to_delete);
                            return FALSE;
                        }
                    }

                } else if (!DescendDigraph(PCHILD_ENTRY(ptr)->Child + i, Visited,
                    Ancestors, RemovedEdges)) {

                    DELETE(nodes_to_delete);
                    return FALSE;
                }
            }
        }
    }

    if (nodes_to_delete) {

        set_card = nodes_to_delete->QueryCardinality().GetLowPart();

        for (i = 0; i < set_card; i++) {

            child_node = nodes_to_delete->QueryNumber(i).GetLowPart();

            if (!RemoveEdge(CurrentNode, child_node)) {
                DELETE(nodes_to_delete);
                return FALSE;
            }

            if (!(p = NEW DIGRAPH_EDGE)) {
                DELETE(nodes_to_delete);
                return FALSE;
            }

            p->Parent = CurrentNode;
            p->Child = child_node;

            if (!RemovedEdges->Put(p)) {
                DELETE(nodes_to_delete);
                return FALSE;
            }
        }
    }

    Ancestors->Pop();
    DELETE(nodes_to_delete);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\pch.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

        pch.cxx

Abstract:

        This module implements

Author:

        Matthew Bradburn (mattbr)  27-Apr-1994

--*/

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ifsutil.hxx"
#include "autoentr.hxx"
#include "autoreg.hxx"
#include "bigint.hxx"
#include "bpb.hxx"
#include "cache.hxx"
#include "cannedsd.hxx"
#include "dcache.hxx"
#include "digraph.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "intstack.hxx"
#include "mldcopy.hxx"
#include "mpmap.hxx"
#include "numset.hxx"
#include "rcache.hxx"
#include "rwcache.hxx"
#include "secrun.hxx"
#include "spaset.hxx"
#include "supera.hxx"
#include "tlink.hxx"
#include "volume.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\ifsutil.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    ifsutil.cxx

Abstract:

        This module contains run-time, global support for the
    IFS Utilities library (IFSUTIL).   This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Bill McJohn (billmc) 30-May-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C"
IFSUTIL_EXPORT
BOOLEAN
InitializeIfsUtil (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

IFSUTIL_EXPORT
BOOLEAN
InitializeIfsUtil (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined(FE_SB) && defined(_X86_)
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize machine id.
        //
        InitializeMachineData();
    }
#endif

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "IfsUtil initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_IFSUTIL_MEM_LEAK)
    DebugPrint("IFSUTIL.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrintTrace(("IFSUTIL.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "IfsUtil initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_IFSUTIL_MEM_LEAK)
            DebugPrint("IFSUTIL.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrintTrace(("IFSUTIL.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrint("IFSUTIL.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_IFSUTIL_MEM_LEAK)
                DebugPrint("IFSUTIL.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif _AUTOCHECK_ || _SETUP_LOADER_

    return TRUE;
}


DECLARE_CLASS(  AUTOENTRY           );
DECLARE_CLASS(  CACHE               );
DECLARE_CLASS(  CANNED_SECURITY     );
DECLARE_CLASS(  DIGRAPH             );
DECLARE_CLASS(  DIGRAPH_EDGE        );
DECLARE_CLASS(  DP_DRIVE            );
DECLARE_CLASS(  DRIVE               );
DECLARE_CLASS(  DRIVE_CACHE         );
DECLARE_CLASS(  INTSTACK            );
DECLARE_CLASS(  IO_DP_DRIVE         );
DECLARE_CLASS(  LOG_IO_DP_DRIVE     );
DECLARE_CLASS(  MOUNT_POINT_MAP     );
DECLARE_CLASS(  MOUNT_POINT_TUPLE   );
DECLARE_CLASS(  NUMBER_EXTENT       );
DECLARE_CLASS(  NUMBER_SET          );
DECLARE_CLASS(  PHYS_IO_DP_DRIVE    );
DECLARE_CLASS(  READ_CACHE          );
DECLARE_CLASS(  READ_WRITE_CACHE    );
DECLARE_CLASS(  SECRUN              );
DECLARE_CLASS(  SPARSE_SET          );
DECLARE_CLASS(  SUPERAREA           );
DECLARE_CLASS(  TLINK               );
DECLARE_CLASS(  VOL_LIODPDRV        );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
    if( DEFINE_CLASS_DESCRIPTOR(    AUTOENTRY           ) &&
        DEFINE_CLASS_DESCRIPTOR(    CACHE               ) &&
        DEFINE_CLASS_DESCRIPTOR(    CANNED_SECURITY     ) &&
        DEFINE_CLASS_DESCRIPTOR(    DIGRAPH             ) &&
        DEFINE_CLASS_DESCRIPTOR(    DIGRAPH_EDGE        ) &&
        DEFINE_CLASS_DESCRIPTOR(    DP_DRIVE            ) &&
        DEFINE_CLASS_DESCRIPTOR(    DRIVE               ) &&
        DEFINE_CLASS_DESCRIPTOR(    DRIVE_CACHE         ) &&
        DEFINE_CLASS_DESCRIPTOR(    INTSTACK            ) &&
        DEFINE_CLASS_DESCRIPTOR(    IO_DP_DRIVE         ) &&
        DEFINE_CLASS_DESCRIPTOR(    LOG_IO_DP_DRIVE     ) &&
        DEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_MAP     ) &&
        DEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_TUPLE   ) &&
        DEFINE_CLASS_DESCRIPTOR(    NUMBER_EXTENT       ) &&
        DEFINE_CLASS_DESCRIPTOR(    NUMBER_SET          ) &&
        DEFINE_CLASS_DESCRIPTOR(    PHYS_IO_DP_DRIVE    ) &&
        DEFINE_CLASS_DESCRIPTOR(    READ_CACHE          ) &&
        DEFINE_CLASS_DESCRIPTOR(    READ_WRITE_CACHE    ) &&
        DEFINE_CLASS_DESCRIPTOR(    SECRUN              ) &&
        DEFINE_CLASS_DESCRIPTOR(    SPARSE_SET          ) &&
        DEFINE_CLASS_DESCRIPTOR(    SUPERAREA           ) &&
        DEFINE_CLASS_DESCRIPTOR(    TLINK               ) &&
        DEFINE_CLASS_DESCRIPTOR(    VOL_LIODPDRV        ) ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR(    AUTOENTRY           );
    UNDEFINE_CLASS_DESCRIPTOR(    CACHE               );
    UNDEFINE_CLASS_DESCRIPTOR(    CANNED_SECURITY     );
    UNDEFINE_CLASS_DESCRIPTOR(    DIGRAPH             );
    UNDEFINE_CLASS_DESCRIPTOR(    DIGRAPH_EDGE        );
    UNDEFINE_CLASS_DESCRIPTOR(    DP_DRIVE            );
    UNDEFINE_CLASS_DESCRIPTOR(    DRIVE               );
    UNDEFINE_CLASS_DESCRIPTOR(    DRIVE_CACHE         );
    UNDEFINE_CLASS_DESCRIPTOR(    INTSTACK            );
    UNDEFINE_CLASS_DESCRIPTOR(    IO_DP_DRIVE         );
    UNDEFINE_CLASS_DESCRIPTOR(    LOG_IO_DP_DRIVE     );
    UNDEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_MAP     );
    UNDEFINE_CLASS_DESCRIPTOR(    MOUNT_POINT_TUPLE   );
    UNDEFINE_CLASS_DESCRIPTOR(    NUMBER_EXTENT       );
    UNDEFINE_CLASS_DESCRIPTOR(    NUMBER_SET          );
    UNDEFINE_CLASS_DESCRIPTOR(    PHYS_IO_DP_DRIVE    );
    UNDEFINE_CLASS_DESCRIPTOR(    READ_CACHE          );
    UNDEFINE_CLASS_DESCRIPTOR(    READ_WRITE_CACHE    );
    UNDEFINE_CLASS_DESCRIPTOR(    SECRUN              );
    UNDEFINE_CLASS_DESCRIPTOR(    SPARSE_SET          );
    UNDEFINE_CLASS_DESCRIPTOR(    SUPERAREA           );
    UNDEFINE_CLASS_DESCRIPTOR(    TLINK               );
    UNDEFINE_CLASS_DESCRIPTOR(    VOL_LIODPDRV        );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\ifssys.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

        ifssys.cxx

Abstract:

    This module contains the implementation for the IFS_SYSTEM class.
    The IFS_SYSTEM class is an abstract class which offers an
    interface for communicating with the underlying operating system
    on specific IFS issues.

Author:

        Norbert P. Kusters (norbertk) 03-Sep-1991

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "ifssys.hxx"
#include "bigint.hxx"
#include "wstring.hxx"
#include "cannedsd.hxx"
#include "drive.hxx"
#include "secrun.hxx"
#include "hmem.hxx"
#include "bpb.hxx"
#include "volume.hxx"

#include "untfs2.hxx"

#if defined(_AUTOCHECK_)
extern "C" {
    #include "ntos.h"
}
#endif

PCANNED_SECURITY    IFS_SYSTEM::_CannedSecurity = NULL;

BOOLEAN
IFS_SYSTEM::IsThisFat(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines if the given boot sector is a FAT
    boot sector.

Arguments:

    Sectors     - Supplies the number of sectors on this drive.
    BootSector  - Supplies the boot sector data.

Return Value:

    FALSE   - This is not a FAT boot sector.
    TRUE    - This is a FAT boot sector.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  BootSector =
                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, reserved_sectors, root_entries, sectors;
    USHORT  sectors_per_fat;
    ULONG   large_sectors;

    r = TRUE;

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&reserved_sectors, BootSector->Bpb.ReservedSectors, sizeof(USHORT));
    memcpy(&root_entries, BootSector->Bpb.RootEntries, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));
    memcpy(&sectors_per_fat, BootSector->Bpb.SectorsPerFat, sizeof(USHORT));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9 &&
        BootSector->IntelNearJumpCommand[0] != 0x49) {  // FMR 'I' of 'IPL1'
#else
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9) {
#endif
        r = FALSE;

    } else if ((bytes_per_sector != 128) &&
               (bytes_per_sector != 256) &&
               (bytes_per_sector != 512) &&
               (bytes_per_sector != 1024) &&
               (bytes_per_sector != 2048) &&
               (bytes_per_sector != 4096)) {

        r = FALSE;

    } else if ((BootSector->Bpb.SectorsPerCluster[0] != 1) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 2) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 4) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 8) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 16) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 32) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 64) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 128)) {

        r = FALSE;

    } else if (reserved_sectors == 0) {

        r = FALSE;

    } else if (BootSector->Bpb.Fats[0] == 0) {

        r = FALSE;

    } else if (root_entries == 0) {

        r = FALSE;

    } else if (Sectors.GetHighPart() != 0) {

        r = FALSE;

    } else if (sectors != 0 && sectors > Sectors.GetLowPart()) {

        r = FALSE;

    } else if (sectors == 0 && large_sectors > Sectors.GetLowPart()) {

        r = FALSE;

    } else if (sectors == 0 && large_sectors == 0) {

        r = FALSE;

    } else if (sectors_per_fat == 0) {

        r = FALSE;

    }

    return r;
}

BOOLEAN
IFS_SYSTEM::IsThisFat32(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines if the given boot sector is a FAT32
    boot sector.

Arguments:

    Sectors     - Supplies the number of sectors on this drive.
    BootSector  - Supplies the boot sector data.

Return Value:

    FALSE   - This is not a FAT32 boot sector.
    TRUE    - This is a FAT32 boot sector.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector =
            (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, reserved_sectors, sectors;
    ULONG   root_entries, sectors_per_fat;
    ULONG   large_sectors;

    r = TRUE;

    root_entries=0;
    memcpy(&root_entries, BootSector->Bpb.RootEntries, sizeof(USHORT));

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&reserved_sectors, BootSector->Bpb.ReservedSectors, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));
    memcpy(&sectors_per_fat, BootSector->Bpb.BigSectorsPerFat, sizeof(ULONG));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9 &&
        BootSector->IntelNearJumpCommand[0] != 0x49) {  // FMR 'I' of 'IPL1'
#else
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9) {
#endif
        r = FALSE;

    } else if ((bytes_per_sector != 128) &&
               (bytes_per_sector != 256) &&
               (bytes_per_sector != 512) &&
               (bytes_per_sector != 1024) &&
               (bytes_per_sector != 2048) &&
               (bytes_per_sector != 4096)) {

        r = FALSE;

    } else if ((BootSector->Bpb.SectorsPerCluster[0] != 1) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 2) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 4) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 8) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 16) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 32) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 64) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 128)) {

        r = FALSE;

    } else if ( sectors_per_fat == 0 || (0 != BootSector->Bpb.SectorsPerFat[0] &&
                                         0 != BootSector->Bpb.SectorsPerFat[1]) ) {

        DebugPrint("IsThisFat32() not fat 32 sectors/fat value\n");
        r = FALSE;

    } else {

        if (reserved_sectors == 0) {

            r = FALSE;

        } else if (BootSector->Bpb.Fats[0] == 0) {

            r = FALSE;

        } else if (root_entries != 0) {

            r = FALSE;

        } else if (Sectors.GetHighPart() != 0) {

            r = FALSE;

        } else if (sectors != 0 && sectors > Sectors.GetLowPart()) {

            r = FALSE;

        } else if (sectors == 0 && large_sectors > Sectors.GetLowPart()) {

            r = FALSE;

        } else if (sectors == 0 && large_sectors == 0) {

            r = FALSE;

        }
    }

    return r;
}

BOOLEAN
IFS_SYSTEM::IsThisHpfs(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData,
    IN  PULONG  SuperBlock,
    IN  PULONG  SpareBlock
    )
/*++

Routine Description:

    This routine determines whether or not the given structures
    are part of an HPFS file system.

Arguments:

    Sectors     - Supplies the number of sectors on the volume.
    BootSector  - Supplies the unaligned boot sector.
    SuperBlock  - Supplies the super block.
    SpareBlock  - Supplies the spare block.

Return Value:

    FALSE   - The given structures are not part on an HPFS volume.
    TRUE    - The given structures are part of an HPFS volume.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector =
                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, sectors;
    ULONG   large_sectors;

    r = TRUE;

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if ((BootSector->IntelNearJumpCommand[0] != 0xeb &&
         BootSector->IntelNearJumpCommand[0] != 0xe9 &&
         BootSector->IntelNearJumpCommand[0] != 0x49) ||
#else
    if ((BootSector->IntelNearJumpCommand[0] != 0xeb &&
         BootSector->IntelNearJumpCommand[0] != 0xe9) ||
#endif
        bytes_per_sector != 512 ||
        ((PUCHAR) BootSector)[510] != 0x55 ||
        ((PUCHAR) BootSector)[511] != 0xaa ||
        BootSector->Bpb.Fats[0] != 0 ||
        (sectors == 0 && large_sectors == 0) ||
        (sectors != 0 && large_sectors != 0) ||
        (sectors > Sectors.GetLowPart()) ||
        (large_sectors > Sectors.GetLowPart()) ||
        Sectors.GetHighPart() != 0) {

        r = FALSE;

    } else if (SuperBlock[0] != 0xF995E849 ||
               SuperBlock[1] != 0xFA53E9C5 ||
               SpareBlock[0] != 0xf9911849 ||
               SpareBlock[1] != 0xfa5229c5) {

        r = FALSE;

    }

    return r;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsThisNtfs(
    IN  BIG_INT Sectors,
    IN  ULONG   SectorSize,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines whether or not the given structure
    is part of an NTFS partition.

Arguments:

    Sectors     - Supplies the number of sectors on the drive.
    SectorSize  - Supplies the number of bytes per sector.
    BootSectorData
                - Supplies an unaligned boot sector.

Return Value:

    FALSE   - The supplied boot sector is not part of an NTFS
    TRUE    - The supplied boot sector is part of an NTFS volume.

--*/
{
    PPACKED_BOOT_SECTOR BootSector = (PPACKED_BOOT_SECTOR)BootSectorData;
    BOOLEAN r;
    ULONG   checksum;
    PULONG  l;
    USHORT  reserved_sectors, root_entries, sectors, sectors_per_fat;
    USHORT  bytes_per_sector;
    ULONG   large_sectors;

    memcpy(&reserved_sectors, BootSector->PackedBpb.ReservedSectors, sizeof(USHORT));
    memcpy(&root_entries, BootSector->PackedBpb.RootEntries, sizeof(USHORT));
    memcpy(&sectors, BootSector->PackedBpb.Sectors, sizeof(USHORT));
    memcpy(&sectors_per_fat, BootSector->PackedBpb.SectorsPerFat, sizeof(USHORT));
    memcpy(&bytes_per_sector, BootSector->PackedBpb.BytesPerSector, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->PackedBpb.LargeSectors, sizeof(ULONG));


    r = TRUE;

    checksum = 0;
    for (l = (PULONG) BootSector; l < (PULONG) &BootSector->Checksum; l++) {
        checksum += *l;
    }

    if (BootSector->Oem[0] != 'N' ||
        BootSector->Oem[1] != 'T' ||
        BootSector->Oem[2] != 'F' ||
        BootSector->Oem[3] != 'S' ||
        BootSector->Oem[4] != ' ' ||
        BootSector->Oem[5] != ' ' ||
        BootSector->Oem[6] != ' ' ||
        BootSector->Oem[7] != ' ' ||
        // BootSector->Checksum != checksum ||
        bytes_per_sector != SectorSize) {

        r = FALSE;

    } else if ((BootSector->PackedBpb.SectorsPerCluster[0] != 0x1) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x2) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x4) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x8) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x10) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x20) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x40) &&
               (BootSector->PackedBpb.SectorsPerCluster[0] != 0x80)) {

        r = FALSE;

    } else if (reserved_sectors != 0 ||
               BootSector->PackedBpb.Fats[0] != 0 ||
               root_entries != 0 ||
               sectors != 0 ||
               sectors_per_fat != 0 ||
               large_sectors != 0 ||
               BootSector->NumberSectors > Sectors ||
               BootSector->MftStartLcn >= Sectors ||
               BootSector->Mft2StartLcn >= Sectors) {

        r = FALSE;
    }

    if (!r) {
        return r;
    }

    if (BootSector->ClustersPerFileRecordSegment < 0) {

        LONG temp = LONG(BootSector->ClustersPerFileRecordSegment);

        temp = 2 << -temp;

        if (temp < 512) {
            return FALSE;
        }
    } else if ((BootSector->ClustersPerFileRecordSegment != 0x1) &&
               (BootSector->ClustersPerFileRecordSegment != 0x2) &&
               (BootSector->ClustersPerFileRecordSegment != 0x4) &&
               (BootSector->ClustersPerFileRecordSegment != 0x8) &&
               (BootSector->ClustersPerFileRecordSegment != 0x10) &&
               (BootSector->ClustersPerFileRecordSegment != 0x20) &&
               (BootSector->ClustersPerFileRecordSegment != 0x40) &&
               (BootSector->ClustersPerFileRecordSegment != 0x80)) {

        return FALSE;
    }

    if (BootSector->DefaultClustersPerIndexAllocationBuffer < 0) {

        LONG temp = LONG(BootSector->DefaultClustersPerIndexAllocationBuffer);

        temp = 2 << -temp;

        if (temp < 512) {
            return FALSE;
        }
    } else if ((BootSector->DefaultClustersPerIndexAllocationBuffer != 0x1) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x2) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x4) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x8) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x10) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x20) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x40) &&
               (BootSector->DefaultClustersPerIndexAllocationBuffer != 0x80)) {

        r = FALSE;
    }

    return r;
}


#define BOOTBLKSECTORS 4
typedef int DSKPACKEDBOOTSECT;

BOOLEAN
IsThisOfs(
    IN      LOG_IO_DP_DRIVE *           Drive,
    IN      DSKPACKEDBOOTSECT *         PackedBootSect
    )
{
    return(FALSE);
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryNtfsVersion(
    OUT PUCHAR           Major,
    OUT PUCHAR           Minor,
    IN  PLOG_IO_DP_DRIVE Drive,
    IN  PVOID            BootSectorData
    )
/*++

Routine Description:

    This routine extracts the version number of the NTFS partition.
    Note:  Caller should call IsThisNtfs() first.

Arguments:

    Major      - Receives the major version number of NTFS partition.
    Minor      - Receives the minor version number of NTFS partition.
    Drive      - Supplies the drive that partition is on.
    BootSectorData
               - Supplies an unaligned boot sector.

Return Value:

    FALSE   - The supplied boot sector is not part of an NTFS
    TRUE    - The supplied boot sector is part of an NTFS volume.

--*/
{
    PPACKED_BOOT_SECTOR BootSector = (PPACKED_BOOT_SECTOR)BootSectorData;
    SECRUN              mftsec;
    HMEM                mftsec_hmem;
    ULONG               sectors_per_frs;
    BIG_INT             start_sector, alternate_sector;

    PFILE_RECORD_SEGMENT_HEADER vol_frs;
    PATTRIBUTE_RECORD_HEADER    attr_rec;
    PCHAR                       attr_rec_end;
    PVOLUME_INFORMATION         vol_info;

    if (BootSector->ClustersPerFileRecordSegment > 0) {
        sectors_per_frs = BootSector->ClustersPerFileRecordSegment *
                          *BootSector->PackedBpb.SectorsPerCluster;
    } else {
        sectors_per_frs = (1<<-BootSector->ClustersPerFileRecordSegment) /
                          *(USHORT UNALIGNED *)BootSector->PackedBpb.BytesPerSector;
    }

    start_sector = *BootSector->PackedBpb.SectorsPerCluster *
                   BootSector->MftStartLcn +
                   sectors_per_frs * VOLUME_DASD_NUMBER;

    alternate_sector = *BootSector->PackedBpb.SectorsPerCluster *
                       BootSector->Mft2StartLcn +
                       sectors_per_frs * VOLUME_DASD_NUMBER;

    //
    // Read in the VOLUME_DASD_NUMBER FRS
    //
    for (;;) {

        if (!mftsec_hmem.Initialize() ||
            !mftsec.Initialize(&mftsec_hmem, Drive, start_sector, sectors_per_frs))
            return FALSE;

        if (!mftsec.Read()) {
            //
            // try the mirror copy
            //
            if (start_sector != alternate_sector) {
                start_sector = alternate_sector;
                continue;
            } else
                break;
        }

        vol_frs = (PFILE_RECORD_SEGMENT_HEADER)mftsec.GetBuf();
        if (vol_frs->MultiSectorHeader.Signature[0] != 'F' ||
            vol_frs->MultiSectorHeader.Signature[1] != 'I' ||
            vol_frs->MultiSectorHeader.Signature[2] != 'L' ||
            vol_frs->MultiSectorHeader.Signature[3] != 'E') {
            if (start_sector != alternate_sector) {
                start_sector = alternate_sector;
                continue;
            } else
                break;
        }

        attr_rec = (PATTRIBUTE_RECORD_HEADER)
                   ((PCHAR)vol_frs + vol_frs->FirstAttributeOffset);
        if ((ULONG_PTR)attr_rec != DwordAlign((ULONG_PTR)attr_rec))
            return FALSE;

        attr_rec_end = ((PCHAR)vol_frs +
                       sectors_per_frs* *(USHORT UNALIGNED *)BootSector->PackedBpb.BytesPerSector);

        //
        // Scan thru the attributes for $VOLUME_INFORMATION
        //
        while ((PCHAR)attr_rec < attr_rec_end &&
            attr_rec->TypeCode != $END &&
            attr_rec->RecordLength != 0 &&
            attr_rec->TypeCode != $VOLUME_INFORMATION) {

            attr_rec = (PATTRIBUTE_RECORD_HEADER)
                       ((PCHAR)attr_rec + attr_rec->RecordLength);

            if ((ULONG_PTR)attr_rec != DwordAlign((ULONG_PTR)attr_rec))
                return FALSE;
        }

        if ((PCHAR)attr_rec < attr_rec_end) {
            if (attr_rec->TypeCode == $VOLUME_INFORMATION &&
                attr_rec->FormCode == RESIDENT_FORM &&
                attr_rec->RecordLength > SIZE_OF_RESIDENT_HEADER &&
                attr_rec->Form.Resident.ValueLength < attr_rec->RecordLength &&
                (attr_rec->RecordLength - attr_rec->Form.Resident.ValueLength) >=
                attr_rec->Form.Resident.ValueOffset &&
                attr_rec->Form.Resident.ValueLength >= sizeof(VOLUME_INFORMATION) &&
                ((PCHAR)attr_rec + attr_rec->RecordLength) <= attr_rec_end) {

                vol_info = (PVOLUME_INFORMATION)
                           ((PCHAR)attr_rec + attr_rec->Form.Resident.ValueOffset);
                if ((ULONG_PTR)vol_info != DwordAlign((ULONG_PTR)vol_info))
                    return FALSE;
                *Major = vol_info->MajorVersion;
                *Minor = vol_info->MinorVersion;
                if (!(
                      (*Major != 1 || (*Minor != 0 && *Minor != 1 && *Minor != 2)) &&
                      (*Major != 2 || (*Minor != 0)) &&
                      (*Major != 3 || (*Minor != 0))
                     ))
                    return TRUE;
            }
        }

        if (start_sector != alternate_sector) {
            start_sector = alternate_sector;
            continue;
        } else
            break;
    }

    return FALSE;
}

#if !defined( _SETUP_LOADER_ )

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryFileSystemName(
    IN  PCWSTRING    NtDriveName,
    OUT PWSTRING     FileSystemName,
    OUT PNTSTATUS    ErrorCode,
    OUT PWSTRING     FileSystemNameAndVersion
    )
/*++

Routine Description:

    This routine computes the file system name for the drive specified.

Arguments:

    NtDriveName     - Supplies an NT style drive name.
    FileSystemName  - Returns the file system name for the drive.
    ErrorCode       - Receives an error code (if the method fails).
                        Note that this may be NULL, in which case the
                        exact error is not reported.
    FileSystemNameAndVersion
                    - Returns the file system name and version for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LOG_IO_DP_DRIVE drive;
    HMEM            bootsec_hmem;
    SECRUN          bootsec;
    HMEM            super_hmem;
    SECRUN          super_secrun;
    HMEM            spare_hmem;
    SECRUN          spare;
    BOOLEAN         could_be_fat;
    BOOLEAN         could_be_hpfs;
    BOOLEAN         could_be_ntfs;
    BOOLEAN         could_be_ofs;
    ULONG           num_boot_sectors;
    BOOLEAN         first_read_failed = FALSE;
    UCHAR           major, minor;
    DSTRING         fs_name_version;

    if (ErrorCode) {
        *ErrorCode = 0;
    }
    if (FileSystemNameAndVersion == NULL)
        FileSystemNameAndVersion = &fs_name_version;

    if (!drive.Initialize(NtDriveName)) {
        if (ErrorCode) {
            *ErrorCode = drive.QueryLastNtStatus();
        }
        return FALSE;
    }

    could_be_fat = could_be_hpfs = could_be_ntfs = could_be_ofs = TRUE;


    if (drive.QueryMediaType() == Unknown) {
        return FileSystemName->Initialize("RAW") &&
               FileSystemNameAndVersion->Initialize("RAW");
    }

    num_boot_sectors = max(1, BYTES_PER_BOOT_SECTOR/drive.QuerySectorSize());

    if (!bootsec_hmem.Initialize() ||
        !bootsec.Initialize(&bootsec_hmem, &drive, 0, num_boot_sectors)) {

        return FileSystemName->Initialize("RAW") &&
               FileSystemNameAndVersion->Initialize("RAW");
    }

    if (!bootsec.Read()) {

        could_be_fat = could_be_hpfs = FALSE;
        first_read_failed = TRUE;

        bootsec.Relocate(drive.QuerySectors());

        if (!bootsec.Read()) {

            bootsec.Relocate(drive.QuerySectors()/2);

            if (!bootsec.Read()) {

                could_be_ntfs = FALSE;
            }
        }
    }

    if (could_be_ntfs &&
        IsThisNtfs(drive.QuerySectors(),
                   drive.QuerySectorSize(),
                   (PPACKED_BOOT_SECTOR) bootsec.GetBuf())) {
        if (QueryNtfsVersion(&major,
                             &minor,
                             &drive,
                             (PPACKED_BOOT_SECTOR) bootsec.GetBuf())) {
            if (major >= 2) {
                return FileSystemName->Initialize("NTFS") &&
                       FileSystemNameAndVersion->Initialize("NTFS 5.0");
            } else {
                return FileSystemName->Initialize("NTFS") &&
                       FileSystemNameAndVersion->Initialize("NTFS 4.0");
            }
        } else {
            return FileSystemName->Initialize("NTFS") &&
                   FileSystemNameAndVersion->Initialize("NTFS");
        }
    }

    if (first_read_failed) {

        bootsec.Relocate(BOOTBLKSECTORS);

        if (!bootsec.Read()) {
            could_be_ofs = FALSE;
        }
    }

    // Check if it is ofs

    if (could_be_ofs &&
        IsThisOfs(&drive, (DSKPACKEDBOOTSECT *) bootsec.GetBuf())) {

        return FileSystemName->Initialize("OFS") &&
               FileSystemNameAndVersion->Initialize("OFS");
    }

    if (could_be_hpfs) {
        if (!super_hmem.Initialize() ||
            !super_secrun.Initialize(&super_hmem, &drive,
                              16*num_boot_sectors, num_boot_sectors) ||
            !super_secrun.Read() ||
            !spare_hmem.Initialize() ||
            !spare.Initialize(&spare_hmem, &drive,
                              17*num_boot_sectors, num_boot_sectors) ||
            !spare.Read()) {

            could_be_hpfs = FALSE;
        }
    }

    if (could_be_hpfs &&
        IsThisHpfs(drive.QuerySectors(),
                   (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf(),
                   (PULONG) super_secrun.GetBuf(),
                   (PULONG) spare.GetBuf())) {

        return FileSystemName->Initialize("HPFS") &&
               FileSystemNameAndVersion->Initialize("HPFS");
    }

    if (could_be_fat) {
        //
        //  Check if we have an OS/2 Boot Manager partition and treat is as an
        //  Unknown file system.  We check the partition type in from the
        //  partition table and we ensure that it has less than 0x80 sectors.
        //
        //  The OS/2 Boot Manager partition boot sector mimics a FAT12 partition
        //  but does not adhere to the FAT12 file system.  For example, the
        //  boot sector indicates it has 2 FATs but only really has one.  The
        //  boot manager code overlays the second FAT.  Because of this we want
        //  to ingore partitions of this type.
        //
        if (drive.QueryPartitionType() == SYSID_OS2BOOTMGR) {

             PPACKED_BIOS_PARAMETER_BLOCK  Pbpb;
             USHORT                        Sectors;

             Pbpb = &(((PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())->Bpb);
             CopyUchar2( &Sectors, Pbpb->Sectors);
             if (( Sectors != 0 ) &&
                 ( Sectors < 0x80 )) {
                DebugPrintTrace(( "IFSUTIL: OS/2 Boot Manager partition detected, Unknown file system. \n" ));
                return FileSystemName->Initialize("OS/2 Boot Manager") &&
                       FileSystemNameAndVersion->Initialize("OS/2 Boot Manager");
             }
        }
    }

    if (could_be_fat &&
        IsThisFat(drive.QuerySectors(),
                  (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())) {

        return FileSystemName->Initialize("FAT") &&
               FileSystemNameAndVersion->Initialize("FAT");
    }

    if (could_be_fat &&
        IsThisFat32(drive.QuerySectors(),
                  (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())) {

        return FileSystemName->Initialize("FAT32") &&
               FileSystemNameAndVersion->Initialize("FAT32");
    }

    return FileSystemName->Initialize("RAW") &&
           FileSystemNameAndVersion->Initialize("RAW");
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::DosDriveNameToNtDriveName(
    IN  PCWSTRING    DosDriveName,
    OUT PWSTRING            NtDriveName
    )
/*++

Routine Description:

    This routine converts a dos style drive name to an NT style drive
    name.

Arguments:

    DosDriveName    - Supplies the dos style drive name.
    NtDriveName     - Supplies the nt style drive name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING  string;
    WSTR            buffer[80];
    CHNUM           l;
    PWSTR           Wstr;
    BOOLEAN         result;

    Wstr = DosDriveName->QueryWSTR(0, TO_END, buffer, 80);

    if (!Wstr) {
        return FALSE;
    }

    l = DosDriveName->QueryChCount() + 1;

    buffer[l - 1] = '\\';
    buffer[l] = 0;

    if (!RtlDosPathNameToNtPathName_U(buffer, &string, NULL, NULL)) {
        return FALSE;
    }

    string.Buffer[string.Length/sizeof(WSTR) - 1] = 0;

    result = NtDriveName->Initialize(string.Buffer);

    RtlFreeUnicodeString(&string);

    return result;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::NtDriveNameToDosDriveName(
    IN  PCWSTRING    NtDriveName,
    OUT PWSTRING     DosDriveName
    )
/*++

Routine Description:

    This routine converts an NT style drive name to a DOS style drive
    name.

Arguments:

    NtDriveName     - Supplies the nt style drive name.
    DosDriveName    - Receives the dos style drive name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING     nt_name_prefix;
    DSTRING     guid_volname_prefix;

    if (!nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !guid_volname_prefix.Initialize(GUID_VOLNAME_PREFIX)) {
        DebugPrint("Out of memory.\n");
        return FALSE;
    }

    if (NtDriveName->Stricmp(&nt_name_prefix,
                             0,
                             nt_name_prefix.QueryChCount()) != 0)
        return FALSE;   // does not recognize name at all

    if (NtDriveName->Stricmp(&guid_volname_prefix,
                             nt_name_prefix.QueryChCount(),
                             guid_volname_prefix.QueryChCount()) == 0) {
        if (!DosDriveName->Initialize(DOS_GUIDNAME_PREFIX) ||
            !DosDriveName->InsertString(DosDriveName->QueryChCount(),
                                        NtDriveName,
                                        nt_name_prefix.QueryChCount())) {
            DebugPrint("Out of memory.\n");
            return FALSE;
        }
        return TRUE;
    } else if (NtDriveName->QueryChCount() == (nt_name_prefix.QueryChCount() + 2) &&
               NtDriveName->QueryChAt(nt_name_prefix.QueryChCount()+1) == (WCHAR)':') {
        if (!DosDriveName->Initialize() ||
            !DosDriveName->InsertString(0,
                                        NtDriveName,
                                        nt_name_prefix.QueryChCount())) {
            DebugPrint("Out of memory.\n");
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

VOID
IFS_SYSTEM::Reboot (
    IN BOOLEAN PowerOff
    )
/*++

Routine Description:

    Reboots the machine

Arguments:

    PowerOff -- if TRUE, we will ask the system to shut down and
                power off.

Return Value:

    Only returns in case of error.

--*/
{

#if defined ( _AUTOCHECK_ )

    CONST PrivilegeBufferSize = 32;
    CHAR PrivilegeBuffer[PrivilegeBufferSize];
    NTSTATUS Status;
    HANDLE TokenHandle;

    PTOKEN_PRIVILEGES TokenPrivileges = (PTOKEN_PRIVILEGES)PrivilegeBuffer;

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_ADJUST_PRIVILEGES,
                                 &TokenHandle );

    if( !NT_SUCCESS( Status ) ) {

        return;
    }

    memset( TokenPrivileges, 0, PrivilegeBufferSize );

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = RtlConvertUlongToLuid( SE_SHUTDOWN_PRIVILEGE );
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    Status = NtAdjustPrivilegesToken( TokenHandle,
                                      FALSE,
                                      TokenPrivileges,
                                      0,
                                      NULL,
                                      NULL );

    if( !NT_SUCCESS( Status ) ) {

        NtClose( TokenHandle );
        return;
    }

    Status = NtShutdownSystem( PowerOff ? ShutdownPowerOff: ShutdownReboot );

    if( !NT_SUCCESS( Status ) ) {

        NtClose( TokenHandle );
        return;
    }

#endif

}

IFSUTIL_EXPORT
PCANNED_SECURITY
IFS_SYSTEM::GetCannedSecurity(
    )
/*++

Routine Description:

    This method fetches the canned security object.

Arguments:

    None.

Return Value:

    A pointer to the canned security object; NULL to indicate
    failure.

--*/
{
    STATIC LONG     InitializingCannedSecurity = 0;
    STATIC          Initialized = FALSE;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingCannedSecurity, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if( !Initialized ) {

        // The canned security information has not yet been
        // generated; allocate and initialize a canned security
        // object.  Note that if initialization fails, DELETE
        // will set _CannedSecurity back to NULL.
        //
        _CannedSecurity = NEW CANNED_SECURITY;

        if( _CannedSecurity == NULL ||
            !_CannedSecurity->Initialize() ) {

            DebugPrint( "IFSUTIL: cannot initialize canned security.\n" );
            DELETE( _CannedSecurity );
        }

        Initialized = TRUE;
    }

    status = InterlockedDecrement(&InitializingCannedSecurity);
    DebugAssert(status == 0);

    return _CannedSecurity;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryFreeDiskSpace(
    IN  PCWSTRING   DosDriveName,
    OUT PBIG_INT    BytesFree
    )
/*++

Routine Description:

    Returns the amount of free space in a volume (in bytes).

Arguments:

    DosDrivename    -   Supplies the DOS name  of the drive
    BytesFree       -   Supplies the BIG_INT in which the result
                        is returned.

Return Value:

    BOOLEAN -   TRUE if the amount of free space was obtained.

--*/
{
    BOOLEAN Ok = FALSE;

#if !defined( _AUTOCHECK_ )

    WCHAR   Buffer[MAX_PATH];
    LPWSTR  Drive;
    BIG_INT TmpBigInt;

    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD NumberOfFreeClusters;
    DWORD TotalNumberOfClusters;

    DebugPtrAssert( DosDriveName );

    Drive = DosDriveName->QueryWSTR( 0, TO_END, Buffer, MAX_PATH );

    if ( Drive ) {

        if ( GetDiskFreeSpace( Drive,
                               &SectorsPerCluster,
                               &BytesPerSector,
                               &NumberOfFreeClusters,
                               &TotalNumberOfClusters
                               ) ) {

            // Use a temporary big_int so that the following happens in
            // large integer arithmetic.

            TmpBigInt = BytesPerSector;
            *BytesFree = TmpBigInt * SectorsPerCluster * NumberOfFreeClusters;

            Ok = TRUE;
        }
    }

#endif

    return Ok;
}


BOOLEAN
QueryDriverName(
    IN  PCWSTRING    FileSystemName,
    OUT PWSTRING            DriverName
    )
/*++

Routine Description:

    This routine computes the driver name corresponding to the
    given file system name.

Arguments:

    FileSystemName  - Supplies the name of the file system.
    DriverName      - Returns the name of the corresponding driver.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING fat_name, hpfs_name;

    if (!fat_name.Initialize("FAT") || !hpfs_name.Initialize("HPFS")) {
        return FALSE;
    }

    if (!FileSystemName->Stricmp(&fat_name)) {
        return DriverName->Initialize("FASTFAT");
    } else if (!FileSystemName->Stricmp(&hpfs_name)) {
        return DriverName->Initialize("PINBALL");
    }

    return DriverName->Initialize(FileSystemName);
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableFileSystem(
    IN  PCWSTRING    FileSystemName
    )
/*++

Routine Description:

    This routine will simply return TRUE because file systems are
    enabled automatically due to a recent IO system change.
    Formerly, this routine used to enable the file system in
    the registry.

Arguments:

    FileSystemName  - Supplies the name of the file system to enable.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNREFERENCED_PARAMETER(FileSystemName);

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsFileSystemEnabled(
    IN  PCWSTRING   FileSystemName,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This routine will always return TRUE now that the IO
    system will automatically load file systems when needed.
    Formerly, this method used to examine the registry
    for this information.

Argument:

    FileSystemName  - Supplies the name of the file system.
    Error           - Returns whether or not an error occurred.

Return Value:

    FALSE   - The file system is not enabled.
    TRUE    - The file system is enabled.

--*/
{
    UNREFERENCED_PARAMETER(FileSystemName);

    if (Error) {
        *Error = FALSE;
    }

    return TRUE;
}


#endif // _SETUP_LOADER_


IFSUTIL_EXPORT
VOID
IFS_SYSTEM::QueryNtfsTime(
    OUT PLARGE_INTEGER NtfsTime
    )
/*++

Routine Description:

    This method returns the current time in NTFS (ie. NT) format.

Arguments

    NtfsTime    --  receives the current time in NTFS format.

Return Value:

    None.

--*/
{
#if !defined( _SETUP_LOADER_ )

    NtQuerySystemTime( NtfsTime );

#else

    TIME_FIELDS TimeFields;

    SpGetTimeFields( &TimeFields );
    RtlTimeFieldsToTime( &TimeFields, NtfsTime );

#endif // _SETUP_LOADER_
}


IFSUTIL_EXPORT
ULONG
IFS_SYSTEM::QueryPageSize(
    )
/*++

Routine Description:

    This method determines the page size of the system.

Arguments:

    None.

Return Value:

    The system page size.  A return value of 0 indicates error.

--*/
{
#if !defined( _SETUP_LOADER_ )

    SYSTEM_BASIC_INFORMATION BasicInfoBuffer;
    NTSTATUS Status;

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &BasicInfoBuffer,
                                       sizeof( BasicInfoBuffer ),
                                       NULL );

    if( !NT_SUCCESS( Status ) ) {

        return 0;

    } else {

        return BasicInfoBuffer.PageSize;
    }

#else

    // The setup loader environment assumes a page size of 4K.
    //
    return 0x1000;

#endif // _SETUP_LOADER_
}


#if !defined( _SETUP_LOADER_ )

CONST   MaxNtNameLength = MAX_PATH;

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryCanonicalNtDriveName(
    IN  PCWSTRING   NtDriveName,
    OUT PWSTRING    CanonicalNtDriveName
    )
/*++

Routine Description:

    This routine follows the given NT drive name through all
    of the links until it hits the end of the link chain.
    The element at the end of the chain is the "canonical"
    form.

Arguments:

    NtDriveName             - Supplies the NT drive name to canonicalize.
    CanonicalNtDriveName    - Returns the canoncal form of the given drive
                                name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING      source, target;
    PUNICODE_STRING     psource, ptarget, tmp;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              handle;
    WSTR                buffer[MaxNtNameLength];

    RtlInitUnicodeString(&source, NtDriveName->GetWSTR());
    psource = &source;
    ptarget = &target;

    for (;;) {

        InitializeObjectAttributes(&oa, psource, OBJ_CASE_INSENSITIVE,
                                   NULL, NULL);

        status = NtOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);

        if (!NT_SUCCESS(status)) {
            ptarget = psource;
            break;
        }

        ptarget->Buffer = buffer;
        ptarget->MaximumLength = MaxNtNameLength*sizeof(WCHAR);
        status = NtQuerySymbolicLinkObject(handle, ptarget, NULL);
        NtClose(handle);

        if (!NT_SUCCESS(status)) {
            ptarget = psource;
            break;
        }

        tmp = psource;
        psource = ptarget;
        ptarget = tmp;
    }

    if (!CanonicalNtDriveName->Initialize(ptarget->Buffer,
                                          ptarget->Length/sizeof(WCHAR))) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
IFS_SYSTEM::QueryNtSystemDriveName(
    OUT PWSTRING    NtSystemDriveName
    )
/*++

Routine Description:

    This routine returns the NT device name for the partition
    which contains the NT system files (ie. ntoskrnl.exe).

Arguments:

    NtSystemDriveName   - Returns the NT drive name for the partition
                          on which ntoskrnl.exe resides.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WSTR            buffer[MaxNtNameLength];
    UNICODE_STRING  source, target;
    FSTRING         dos_name;
    NTSTATUS        status;

    RtlInitUnicodeString(&source, (PWSTR) L"%SystemRoot%");

    target.Buffer = buffer;
    target.MaximumLength = MaxNtNameLength*sizeof(WCHAR);

    status = RtlExpandEnvironmentStrings_U(NULL, &source, &target, NULL);

    if (!NT_SUCCESS(status) ||
        target.Length/sizeof(WCHAR) < 2 ||
        target.Buffer[1] != ':') {

        return FALSE;
    }

    target.Buffer[2] = 0;
    dos_name.Initialize(target.Buffer);

    return DosDriveNameToNtDriveName(&dos_name, NtSystemDriveName);
}

BOOLEAN
IFS_SYSTEM::QuerySystemEnvironmentVariableValue(
    IN  PWSTRING    VariableName,
    IN  ULONG       ValueBufferLength,
    OUT PVOID       ValueBuffer,
    OUT PUSHORT     ValueLength
    )
/*++

Routine Description:

    This method fetches the value of an NT System Variable.  (Note
    that this is a set of variables distinct from the Windows
    environment variables.)

Arguments:

    VariableName
    ValueBufferLength   --  Supplies the length (in bytes) of the
                            buffer supplied to hold the output value.
    ValueBuffer         --  Receives the UNICODE value of the
                            environment variable.
    ValueLength         --  Receives the length (in bytes) of the
                            value.

Return Value:

    TRUE if the method was able to query the value of the specified
    environment variable.

--*/
{
    UNICODE_STRING Name;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Name.Buffer = (PWSTR)VariableName->GetWSTR();
    Name.Length = (USHORT)VariableName->QueryChCount() * sizeof(WCHAR);
    Name.MaximumLength = Name.Length;

    // Adjust the privileges so we can access system variables:
    //
    Status = RtlAdjustPrivilege( SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                                 TRUE,
                                 FALSE,
                                 &WasEnabled );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: Could not adjust privileges (Status 0x%x).\n", Status ));
        return FALSE;
    }

    Status = NtQuerySystemEnvironmentValue( &Name,
                                            (PWSTR)ValueBuffer,
                                            (USHORT)ValueBufferLength,
                                            ValueLength );

    // Set the privilege back:
    //
    RtlAdjustPrivilege( SE_SYSTEM_PROFILE_PRIVILEGE,
                        WasEnabled,
                        FALSE,
                        &WasEnabled );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: Couldn't query system variable--status 0x%x\n", Status ));
        return FALSE;

    } else {

        return TRUE;
    }
}



IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsArcSystemPartition(
    IN  PCWSTRING   NtDriveName,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This routine determines whether the specified drive
    appears in the list of System Partitions in the ARC
    boot selections.

Arguments:

    NtDriveName --  Supplies the name
    Error       --  Receives TRUE if the method encountered an
                    error.

Return Value:

    TRUE if the specified volume is a System Partition for a
    system boot selection.

Notes:

    The System Partitions is the volume from which the system
    loads OSLOADER.EXE and HAL.DLL.  The system partitions
    for the various boot selections are listed in the system
    environment variable SYSTEMPARTITION.  The value of this
    variable is a list of ARC names delimited by semicolons.

--*/
{
#if defined( i386 )

    *Error = FALSE;
    return FALSE;

#else

    CONST ULONG ValueBufferSize = 512;
    BYTE SystemPartitionValue[ValueBufferSize];
    DSTRING SearchName, CurrentNameString, CurrentCanonicalName, VariableName,
            ZeroString, ArcPrefixString;
    PWSTR CurrentName, CurrentChar;
    ULONG RemainingLength, CurrentNameLength, i;
    USHORT ValueLength = 0;

    DebugPtrAssert( NtDriveName );
    DebugPtrAssert( Error );

    // Assume innocent until...
    //
    *Error = FALSE;

    // Initialize the helper strings:
    //
    if( !ZeroString.Initialize( "0" ) ||
        !ArcPrefixString.Initialize( "\\ArcName\\" ) ) {

        *Error = TRUE;
        return FALSE;
    }

    // Canonicalize the search name:
    //
    if( !QueryCanonicalNtDriveName( NtDriveName, &SearchName ) ) {

        *Error = TRUE;
        return FALSE;
    }

    // Fetch the value of the system environment variable
    // SystemPartition.
    //
    if( !VariableName.Initialize( "SystemPartition" ) ||
        !QuerySystemEnvironmentVariableValue( &VariableName,
                                              ValueBufferSize,
                                              SystemPartitionValue,
                                              &ValueLength ) ) {

        *Error = TRUE;
        return FALSE;
    }

    // Step through the list of partition names in the
    // value of the SystemPartition variable.  For each
    // partition name, canonicalize it and compare it to
    // the search name.
    //
    RemainingLength = ValueLength/sizeof(WCHAR);
    CurrentChar = (PWSTR)SystemPartitionValue;

    while( RemainingLength ) {

        // Determine the length of the current name:
        //
        CurrentName = CurrentChar;
        CurrentNameLength = 0;

        while( RemainingLength && *CurrentChar != ';' ) {

            CurrentNameLength++;
            RemainingLength--;
            CurrentChar++;
        }

        if( CurrentNameLength != 0 ) {

            // Initialize a DSTRING for the current name
            // and canonicalize it for comparison with the
            // (canonicalized) search name.
            //
            if( !CurrentNameString.Initialize( CurrentName,
                                               CurrentNameLength ) ) {

                *Error = TRUE;
                return FALSE;
            }

            // Now normalize the current ARC name--prepend it
            // with \ArcName\ and replace any occurrence of
            // "()" with "(0)".
            //
            if( !CurrentNameString.InsertString( 0, &ArcPrefixString ) ) {

                *Error = TRUE;
                return FALSE;
            }

            // Find the first occurrence of '(':
            //
            i = CurrentNameString.Strchr( '(', 0 );

            while( i != INVALID_CHNUM ) {

                i++;

                if( CurrentNameString.QueryChAt( i ) == ')' &&
                    !CurrentNameString.InsertString( i, &ZeroString ) ) {

                    *Error = TRUE;
                    return FALSE;
                }

                // Find the next occurrence of '(':
                //
                i = CurrentNameString.Strchr( '(', i );
            }

            // CurrentNameString is now a symbolic link to an ARC
            // System Partition.  Canonicalize this name in the
            // NT name space and compare it to the (previously
            // canonicalized) search name.
            //
            if( !QueryCanonicalNtDriveName( &CurrentNameString,
                                            &CurrentCanonicalName ) ) {

                *Error = TRUE;
                return FALSE;
            }

            if( SearchName.Stricmp( &CurrentCanonicalName ) == 0 ) {

                // Found a match--the search name is an ARC System
                // Partition.
                //
                return TRUE;
            }

        }

        // If RemainingLength is non-zero, then CurrentChar is
        // pointing at a semicolon delimiter.  Step over it
        // to the next name.
        //
        if( RemainingLength ) {

            RemainingLength--;
            CurrentChar++;
        }
    }

    // No match was found--this name is not an ARC System Partition.
    //
    return FALSE;
#endif  // i386
}


BOOLEAN
IFS_SYSTEM::FileSetAttributes(
    IN  HANDLE  FileHandle,
    IN  ULONG   NewAttributes,
    OUT PULONG  OldAttributes
    )
/*++

Routine Description:

    This method changes the attributes (read-only, system, hidden,
    archive) on a file.

Arguments:

    FileHandle      --  Supplies the handle of the target file.
    NewAttributes   --  Supplies the new attributes for the file.
    OldAttributes   --  Receives the existing file attributes.

Return Value:

    TRUE upon successful completion.

--*/
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    Status = NtQueryInformationFile( FileHandle,
                                     &IoStatusBlock,
                                     &BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation
                                     );

    if( !NT_SUCCESS( Status ) ) {

        return FALSE;
    }

    *OldAttributes = BasicInfo.FileAttributes;

    BasicInfo.FileAttributes = NewAttributes;

    Status = NtSetInformationFile( FileHandle,
                                   &IoStatusBlock,
                                   &BasicInfo,
                                   sizeof(BasicInfo),
                                   FileBasicInformation
                                   );

    return( NT_SUCCESS( Status ) );
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::FileSetAttributes(
    IN  PCWSTRING FileName,
    IN  ULONG     NewAttributes,
    OUT PULONG    OldAttributes
    )
/*++

Routine Description:

    This method changes the attributes (read-only, system, hidden,
    archive) on a file.

Arguments:

    FileName        --  Supplies the name of the target file.
    NewAttributes   --  Supplies the new attributes for the file.
    OldAttributes   --  Receives the existing file attributes.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING string;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN Result;

    string.Buffer = (PWSTR)FileName->GetWSTR();
    string.Length = (USHORT)FileName->QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length;

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if( !NT_SUCCESS( Status ) )  {

        return FALSE;
    }

    Result = FileSetAttributes( Handle, NewAttributes, OldAttributes );

    NtClose( Handle );

    return Result;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::WriteToFile(
    IN  PCWSTRING   QualifiedFileName,
    IN  PVOID       Data,
    IN  ULONG       DataLength,
    IN  BOOLEAN     Append
    )
/*++

Routine Description:

    This method appends the given data to the specified file
    using the NT-native file-system API.  If the file does not
    exist, it is created.

Arguments:

    QualifiedFileName   --  Supplies the fully-qualified file name.
    Data                --  Supplies the data to be written to the file.
    DataLength          --  Supplies the length of data in bytes.
    Append              --  Supplies a flag indicating that new data
                            should be appended to the file, rather than
                            overwriting it.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING string;
    IO_STATUS_BLOCK StatusBlock;
    LARGE_INTEGER FileOffset;

    if( Append && DataLength == 0 ) {

        return TRUE;
    }

    string.Buffer = (PWSTR)QualifiedFileName->GetWSTR();
    string.Length = (USHORT)QualifiedFileName->QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length;

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    // If we're appending to the file, open; if that fails, create
    // it.  If we're not appending, just create it.
    //
    if( Append ) {

        Status = NtOpenFile(
                    &Handle,
                    FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                    &Obja,
                    &StatusBlock,
                    FILE_SHARE_READ,
                    0
                    );
    }

    if( !Append ||
        Status == STATUS_NO_SUCH_FILE ||
        Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        Status = NtCreateFile( &Handle,
                               FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                               &Obja,
                               &StatusBlock,
                               NULL,        // No pre-allocation
                               FILE_ATTRIBUTE_NORMAL,
                               0,           // No sharing.
                               FILE_OVERWRITE_IF,
                               FILE_NON_DIRECTORY_FILE,
                               NULL,        // No EA's
                               0 );
    }

    if( !NT_SUCCESS( Status ) )  {

        // Can't open or create the file.
        //
        DebugPrintTrace(( "IFSUTIL: Error opening/creating file--status 0x%x\n", Status ));
        return FALSE;
    }

    FileOffset = RtlConvertLongToLargeInteger( FILE_WRITE_TO_END_OF_FILE );

    Status = NtWriteFile( Handle,
                          0, NULL, NULL,
                          &StatusBlock,
                          Data,
                          DataLength,
                          &FileOffset,
                          NULL );

    NtClose( Handle );

    if( !NT_SUCCESS( Status ) ) {

        DebugPrintTrace(( "IFSUTIL: NtWriteFile failed with status 0x%s\n", Status ));
        return FALSE;

    } else {

        return TRUE;
    }
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableVolumeCompression(
    IN  PCWSTRING   NtDriveName
    )
/*++

Routine Description:

    This routine sets the bit on the root directory of the given
    volume so that files added to the volume will be compressed.

Arguments:

    NtDriveName     -- the name of the volume


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              Handle;
    UNICODE_STRING      string;
    IO_STATUS_BLOCK     IoStatusBlock;
    USHORT              State = 1;
    DSTRING             FileName;
    DSTRING             backslash;

    if (!backslash.Initialize("\\") ||
        !FileName.Initialize(NtDriveName) ||
        !FileName.Strcat(&backslash)) {
        return FALSE;
    }

    string.Buffer = (PWSTR)FileName.GetWSTR();
    string.Length = (USHORT)FileName.QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length;

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtFsControlFile(
                Handle,
                NULL,                       /* Event */
                NULL,                       /* ApcRoutine */
                NULL,                       /* ApcContext */
                &IoStatusBlock,
                FSCTL_SET_COMPRESSION,
                (PVOID)&State,              /* InputBuffer */
                sizeof(State),              /* InputBufferLength */
                NULL,                       /* OutputBuffer */
                0                           /* OutputBufferLength */
                );

    NtClose(Handle);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableVolumeUpgrade(
    IN  PCWSTRING   NtDriveName
    )
/*++

Routine Description:

    This routine sets the bit on the root directory of the given
    volume so that files added to the volume will be compressed.

Arguments:

    NtDriveName     -- the name of the volume


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::DismountVolume(
    IN  PCWSTRING   NtDriveName
    )
/*++

Routine Description:

    This routine dismounts the given volume.

Arguments:

    NtDriveName     -- the name of the volume


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              Handle;
    UNICODE_STRING      string;
    IO_STATUS_BLOCK     IoStatusBlock;
    DSTRING             FileName;

    if (!FileName.Initialize(NtDriveName))
        return FALSE;

    string.Buffer = (PWSTR)FileName.GetWSTR();
    string.Length = (USHORT)FileName.QueryChCount() * sizeof( WCHAR );
    string.MaximumLength = string.Length + sizeof(WCHAR);   // null char too

    InitializeObjectAttributes(
        &Obja,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT
                );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtFsControlFile(
                Handle,
                NULL,                       /* Event */
                NULL,                       /* ApcRoutine */
                NULL,                       /* ApcContext */
                &IoStatusBlock,
                FSCTL_DISMOUNT_VOLUME,
                NULL,                       /* InputBuffer */
                0,                          /* InputBufferLength */
                NULL,                       /* OutputBuffer */
                0                           /* OutputBufferLength */
                );

    NtClose(Handle);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::CheckValidSecurityDescriptor(
    IN ULONG Length,
    IN PISECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    Validates a security descriptor for structural correctness.

Arguments:

    Length - Length in bytes of passed Security Descriptor.

    SecurityDescriptor - Points to the Security Descriptor (in kernel memory) to be
        validatated.

Return Value:

    TRUE - The passed security descriptor is correctly structured
    FALSE - The passed security descriptor is badly formed

--*/
{
    return RtlValidRelativeSecurityDescriptor(SecurityDescriptor, Length, 0);
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsVolumeDirty(
    IN  PWSTRING    NtDriveName,
    OUT PBOOLEAN    Result
    )
/*++

Routine Description:

    This routine opens the given nt drive and sends down
    FSCTL_IS_VOLUME_DIRTY to determine the state of that volume's
    dirty bit.

Arguments:

    NtDriveName     -- supplies the volume in question
    Result          -- returns the state of the dirty bit

Return Value:

    FALSE           -- the dirty bit could not be queried
    TRUE            -- success

--*/
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h;
    ULONG               r;


    u.Length = (USHORT)NtDriveName->QueryChCount() * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = (PWSTR)NtDriveName->GetWSTR();

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    status = NtOpenFile(&h,
                        FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &obj,
                        &iosb,
                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(status)) {

        return FALSE;
    }

    status = NtFsControlFile(h, NULL, NULL, NULL,
                             &iosb,
                             FSCTL_IS_VOLUME_DIRTY,
                             NULL, 0,
                             &r, sizeof(r));

    if (!NT_SUCCESS(status)) {
        NtClose(h);
        return FALSE;
    }

#if(_WIN32_WINNT >= 0x0500)
    *Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
    *Result = (BOOLEAN)r;
#endif
    NtClose(h);

    return TRUE;
}

#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\numset.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "numset.hxx"
#include "iterator.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NUMBER_SET, OBJECT, IFSUTIL_EXPORT );

DEFINE_CONSTRUCTOR( NUMBER_EXTENT, OBJECT );

VOID
NUMBER_SET::Construct (
        )
/*++

Routine Description:

    Constructor for NUMBER_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _card = 0;
    _iterator = NULL;
}


VOID
NUMBER_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the NUMBER_SET to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _list.DeleteAllMembers();
    _card = 0;
    DELETE(_iterator);
}


IFSUTIL_EXPORT
NUMBER_SET::~NUMBER_SET(
    )
/*++

Routine Description:

    Destructor for NUMBER_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!_list.Initialize() ||
        !(_iterator = _list.QueryIterator())) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number  - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (p) {

        next = p->Start + p->Length;

        if (Number < next) {
            return TRUE;
        }

        if (Number == next) {

            p->Length += 1;
            _card += 1;

            if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {

                if (pn->Start == Number + 1) {

                    p->Length += pn->Length;
                    pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                    DELETE(pn);
                }
            }

            return TRUE;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        if (Number + 1 == p->Start) {

            p->Start = Number;
            p->Length += 1;
            _card += 1;
            return TRUE;
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::AddStart(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.  Call this routine once before calling 
    AddNext.

    NOTE: Do not insert other calls of this class in between AddStart and AddNext.

Arguments:

    Number    - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    _iterator->Reset();
    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    while (p != NULL) {
        if (p->Start <= Number) {
            next = p->Start + p->Length;

            // if within range, then done
            if (Number < next)
                return TRUE;

            // if passed the range by 1, try to expand the range to include it
            if (Number == next) {
                p->Length += 1;
                _card += 1;
                // see if the next range can be merged with the expanded range
                if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {
                   if (pn->Start == Number + 1) {
                       p->Length += pn->Length;
                       pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                       DELETE(pn);
                   }
                }
                p = (PNUMBER_EXTENT)_iterator->GetPrevious();
                return TRUE;
            }

            // if less than the next range by 1, try to expand the range to
            // include it.  There won't be a merge as there must be more than
            // one hole in between the two ranges
            if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
                if (p->Start <= Number)
                    continue;
                if ((Number+1) == p->Start) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
            }
            break;
        } else {
            // search backwards
            p = (PNUMBER_EXTENT) _iterator->GetPrevious();
            if (p == NULL) {
                p = (PNUMBER_EXTENT) _iterator->GetNext();
                DebugAssert(p);
                if (p && ((Number+1) == p->Start)) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
                break;
            }
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::AddNext(
    IN  BIG_INT Number
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.  Call this routine after calling
    AddStart once.  This routine differs from Add ni the sense that it searches
    through each of the subset from where it last added instead of starting
    backwards like Add does.

    NOTE: Do not insert any other call of this class in between two AddNext calls.

Arguments:

    Number    - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);

    if (!(p = (PNUMBER_EXTENT) _iterator->GetCurrent())) {
        _iterator->Reset();
        p = (PNUMBER_EXTENT) _iterator->GetPrevious();
    }

    while (p != NULL) {
        if (p->Start <= Number) {
            next = p->Start + p->Length;

            // if within range, then done
            if (Number < next)
                return TRUE;

            // if passed the range by 1, try to expand the range to include it
            if (Number == next) {
                p->Length += 1;
                _card += 1;
                // see if the next range can be merged with the expanded range
                if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {
                   if (pn->Start == Number + 1) {
                       p->Length += pn->Length;
                       pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                       DELETE(pn);
                   }
                }
                p = (PNUMBER_EXTENT)_iterator->GetPrevious();
                return TRUE;
            }

            // if less than the next range by 1, try to expand the range to
            // include it.  There won't be a merge as there must be more than
            // one hole in between the two ranges
            if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
                if (p->Start <= Number)
                    continue;
                if ((Number+1) == p->Start) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
            }
            break;
        } else {
            // search backwards
            p = (PNUMBER_EXTENT) _iterator->GetPrevious();
            if (p == NULL) {
                p = (PNUMBER_EXTENT) _iterator->GetNext();
                DebugAssert(p);
                if (p && ((Number+1) == p->Start)) {
                    p->Start = Number;
                    p->Length += 1;
                    _card += 1;
                    return TRUE;
                }
                break;
            }
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    p = (PNUMBER_EXTENT) _iterator->GetPrevious();

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    )
/*++

Routine Description:

    This routine adds the range of numbers to the set.

Arguments:

    Start   - Supplies the first number to add to the set.
    Length  - Supplies the length of the run to add.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT i, sup;
    BOOLEAN r;

    sup = Start + Length;

    r = TRUE;
    for (i = Start; i < sup; i += 1) {
        r = Add(i) && r;
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Add(
    IN  PCNUMBER_SET    NumberSet
    )
/*++

Routine Description:

    This routine adds all of the elements in the given number set to
    this one.

Arguments:

    NumberSet   - Supplies the numbers to add.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, n;
    BIG_INT s, l;

    n = NumberSet->QueryNumDisjointRanges();

    for (i = 0; i < n; i++) {

        NumberSet->QueryDisjointRange(i, &s, &l);

        if (!Add(s, l)) {
            return FALSE;
        }
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::CheckAndAdd(
    IN  BIG_INT   Number,
    OUT PBOOLEAN  Duplicate
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number  - Supplies the number to add to the set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p, pn;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next;

    DebugAssert(_iterator);
    DebugAssert(Duplicate);

    *Duplicate = FALSE;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (p) {

        next = p->Start + p->Length;

        if (Number < next) {
            *Duplicate = TRUE;
            return TRUE;
        }

        if (Number == next) {

            p->Length += 1;
            _card += 1;

            if (pn = (PNUMBER_EXTENT) _iterator->GetNext()) {

                if (pn->Start == Number + 1) {

                    p->Length += pn->Length;
                    pn = (PNUMBER_EXTENT) _list.Remove(_iterator);
                    DELETE(pn);
                }
            }

            return TRUE;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        if (Number + 1 == p->Start) {

            p->Start = Number;
            p->Length += 1;
            _card += 1;
            return TRUE;
        }
    }

    if (!(new_extent = NEW NUMBER_EXTENT)) {
        return FALSE;
    }

    new_extent->Start = Number;
    new_extent->Length = 1;

    if (!_list.Insert(new_extent, _iterator)) {
        DELETE(new_extent);
        return FALSE;
    }

    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  BIG_INT     Number
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number  - Supplies the number to remove.

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next, new_length;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
        if (p->Start > Number) {
            break;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {

        next = p->Start + p->Length;

        if (p->Start == Number) {
            p->Start += 1;
            p->Length -= 1;
            _card -= 1;

            if (p->Length == 0) {
                p = (PNUMBER_EXTENT) _list.Remove(_iterator);
                DELETE(p);
            }

            return TRUE;
        }

        if (Number + 1 == next) {
            p->Length -= 1;
            _card -= 1;
            return TRUE;
        }

        if (Number < next) {

            if (!(new_extent = NEW NUMBER_EXTENT)) {
                return FALSE;
            }

            _iterator->GetNext();

            if (!_list.Insert(new_extent, _iterator)) {
                DELETE(new_extent);
                return FALSE;
            }

            new_length = Number - p->Start;

            new_extent->Start = Number + 1;
            new_extent->Length = p->Length - 1 - new_length;

            p->Length = new_length;

            _card -= 1;
        }
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::RemoveAll(
     )
{
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    if ((p = (PNUMBER_EXTENT) _iterator->GetNext())) 
        do {
            p = (PNUMBER_EXTENT) _list.Remove(_iterator);
            DELETE(p);
        } while ((p=(PNUMBER_EXTENT)_iterator->GetCurrent()));
    _card = 0;
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::CheckAndRemove(
    IN  BIG_INT     Number,
     OUT PBOOLEAN   DoesExists
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number      - Supplies the number to remove.
     DoesExists - TRUE if Number was found in the set

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;
    PNUMBER_EXTENT  new_extent;
    BIG_INT         next, new_length;

    DebugAssert(_iterator);
    DebugAssert(DoesExists);

    *DoesExists = FALSE;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {
        if (p->Start > Number) {
            break;
        }
    }

    if (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {

        next = p->Start + p->Length;

        if (p->Start == Number) {
            p->Start += 1;
            p->Length -= 1;
            _card -= 1;
            *DoesExists = TRUE;

            if (p->Length == 0) {
                p = (PNUMBER_EXTENT) _list.Remove(_iterator);
                DELETE(p);
            }

            return TRUE;
        }

        if (Number + 1 == next) {
            p->Length -= 1;
            _card -= 1;
            *DoesExists = TRUE;
            return TRUE;
        }

        if (Number < next) {

            if (!(new_extent = NEW NUMBER_EXTENT)) {
                return FALSE;
            }

            _iterator->GetNext();

            if (!_list.Insert(new_extent, _iterator)) {
                DELETE(new_extent);
                return FALSE;
            }

            new_length = Number - p->Start;

            new_extent->Start = Number + 1;
            new_extent->Length = p->Length - 1 - new_length;

            p->Length = new_length;

            _card -= 1;
            *DoesExists = TRUE;
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    )
/*++

Routine Description:

    This routine removes the given range from the number set.

Arguments:

    Start   - Supplies the beginning of the range.
    Length  - Supplies the length of the range.

Routine Description:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT i, sup;
    BOOLEAN r;

    sup = Start + Length;

    r = TRUE;
    for (i = Start; i < sup; i += 1) {
        r = Remove(i) && r;
    }

    return r;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::Remove(
    IN  PCNUMBER_SET    NumberSet
    )
/*++

Routine Description:

    This routine removes all of the elements in the given number set from
    this one.

Arguments:

    NumberSet   - Supplies the numbers to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, n;
    BIG_INT s, l;

    n = NumberSet->QueryNumDisjointRanges();
    for (i = 0; i < n; i++) {

        NumberSet->QueryDisjointRange(i, &s, &l);

        if (!Remove(s, l)) {
            return FALSE;
        }
    }

    return TRUE;
}


IFSUTIL_EXPORT
BIG_INT
NUMBER_SET::QueryNumber(
    IN  BIG_INT Index
    ) CONST
/*++

Routine Description:

    This routine returns the Nth number contained in this set.

Arguments:

    Index   - Supplies a zero-based index into the ordered set.

Return Value:

    The Nth number in this set.

--*/
{
    PNUMBER_EXTENT  p;
    BIG_INT         r;
    BIG_INT         count;

    DebugAssert(Index < _card);

    _iterator->Reset();
    count = 0;
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        count += p->Length;

        if (count > Index) {
            break;
        }
    }

    DebugAssert(p);

    return p->Start + Index - (count - p->Length);
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::DoesIntersectSet(
    IN  BIG_INT Start,
    IN  BIG_INT Length
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the range specified intersects
    the current number set.  This routine will return FALSE if the
    intersection is empty, TRUE otherwise.

Arguments:

    Start   - Supplies the start of the range.
    Length  - Supplies the length of the range.

Return Value:

    FALSE   - The specified range does not intersect the number set.
    TRUE    - The specified range makes a non-empty intersection with
                the number set.

--*/
{
    PNUMBER_EXTENT  p;
    BIG_INT         pnext, next;

    DebugAssert(_iterator);

    if (Length == 0) {
        return FALSE;
    }

    next = Start + Length;

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetNext()) {

        pnext = p->Start + p->Length;

        if (Start >= p->Start) {

            if (Start < pnext) {
                return TRUE;
            }
        } else {

            if (next > p->Start) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
VOID
NUMBER_SET::QueryDisjointRange(
    IN  ULONG       Index,
    OUT PBIG_INT    Start,
    OUT PBIG_INT    Length
    ) CONST
/*++

Routine Description:

    This routine returns the 'Index'th disjoint range.  (This is zero
    based).

Arguments:

    Index   - Supplies the index of the disjoint range.
    Start   - Returns the start of the disjoint range.
    Length  - Returns the length of the disjoint range.

Return Value:

    None.

--*/
{
    ULONG           i;
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    for (i = 0; i <= Index; i++) {
        p = (PNUMBER_EXTENT) _iterator->GetNext();
    }

    DebugAssert(p);
    DebugAssert(Start);
    DebugAssert(Length);

    *Start = p->Start;
    *Length = p->Length;
}


IFSUTIL_EXPORT
BOOLEAN
NUMBER_SET::QueryContainingRange(
    IN  BIG_INT     Number,
    OUT PBIG_INT    Start,
    OUT PBIG_INT    Length
    ) CONST
/*++

Routine Description:

    This routine returns the range that contains the given number.

Arguments:

    Number  - Supplies the number.
    Start   - Returns the start of the range.
    Length  - Returns the length of the range.

Return Value:

    FALSE   - The given number was not in the set.
    TRUE    - Success.

--*/
{
    PNUMBER_EXTENT  p;

    DebugAssert(_iterator);

    _iterator->Reset();
    while (p = (PNUMBER_EXTENT) _iterator->GetPrevious()) {
        if (p->Start <= Number) {
            break;
        }
    }

    if (!p || Number >= p->Start + p->Length) {
        return FALSE;
    }

    *Start = p->Start;
    *Length = p->Length;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\rcache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "rcache.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( READ_CACHE, DRIVE_CACHE, IFSUTIL_EXPORT );


READ_CACHE::~READ_CACHE(
    )
/*++

Routine Description:

    Destructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
READ_CACHE::Construct (
        )
/*++

Routine Description:

    Contructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
READ_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for READ_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
READ_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      ULONG           NumberOfCacheBlocks
    )
/*++

Routine Description:

    This routine initializes a READ_CACHE object.

Arguments:

    Drive   - Supplies the drive to cache for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DRIVE_CACHE::Initialize(Drive)) {
        Destroy();
        return FALSE;
    }

    if (!_cache.Initialize(Drive->QuerySectorSize(),
                           NumberOfCacheBlocks)) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
READ_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i, j;
    ULONG   sector_size;
    PCHAR   buf;

    // Bypass the cache for large reads.

    if (NumberOfSectors > _cache.QueryMaxNumBlocks()) {
        return HardRead(StartingSector, NumberOfSectors, Buffer);
    }

    sector_size = _cache.QueryBlockSize();
    buf = (PCHAR) Buffer;

    for (i = 0; i < NumberOfSectors; i++) {

        for (j = i; j < NumberOfSectors; j++) {

            if (_cache.Read(StartingSector + j, &buf[j*sector_size])) {

                break;
            }
        }


        // Now do a hard read on everything from i to j and add these
        // blocks to the cache.

        if (j - i) {

            if (!HardRead(StartingSector + i, j - i, &buf[i*sector_size])) {

                return FALSE;
            }

            for (; i < j; i++) {

                _cache.AddBlock(StartingSector + i, &buf[i*sector_size]);
            }
        }
    }

    return TRUE;
}


BOOLEAN
READ_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _cache.Empty();
    return HardWrite(StartingSector, NumberOfSectors, Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\mldcopy.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

extern "C" {
#include "ntlsa.h"
#include "md4.h"
}

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "ifssys.hxx"
#include "wstring.hxx"
#include "drive.hxx"
#include "mldcopy.hxx"
#include "rtmsg.h"
#include "supera.hxx"
#include "hmem.hxx"
#include "cmem.hxx"
#include "message.hxx"


#define JIMS_BIG_NUMBER 718315
#define RegPath TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName")
#define RegVal  TEXT("ComputerName")
#define DmfPath TEXT("System\\CurrentControlSet\\Control\\Windows")
#define DmfVal  TEXT("DmfEnabled")

#define MAX_DISK_SIZE_ALLOWED    (3)   // in Megabytes

BOOLEAN
GetWidget(
    OUT PSID *Sid,
    OUT PULONG SidLength
    )

/*++

Routine Description:

    This routine retrieves the sid of this machine's account
    domain and returns it in memory allocated with MALLOC.
    If this machine is a server in a domain, then this SID will
    be domain's SID.


Arguments:

    Sid - receives a pointer to the returned SID.

    SidLength - Receives the length (in bytes) of the returned SID.


Return Value:

    TRUE - The SID was allocated and returned.

    FALSE - Some error prevented the SID from being returned.

--*/

{
    NTSTATUS
        Status;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    LSA_HANDLE
        PolicyHandle;

    POLICY_ACCOUNT_DOMAIN_INFO
        *DomainInfo = NULL;

    PSID
        ReturnSid;

    BOOLEAN
        ReturnStatus = FALSE;



    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,       // No name
                                0,          // No attributes
                                0,          // No root handle
                                NULL        // No SecurityDescriptor
                                );

    Status = LsaOpenPolicy( NULL,           // Local System
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle
                            );

    if (NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     (PVOID*) &DomainInfo
                     );

        if (NT_SUCCESS(Status)) {

            ASSERT(DomainInfo != NULL);

            //
            // Allocate the return buffer
            //

            (*SidLength) = RtlLengthSid( DomainInfo->DomainSid );
            ReturnSid = MALLOC(*SidLength);

            if (ReturnSid != NULL) {

                //
                // Copy the sid
                //

                RtlMoveMemory( ReturnSid, DomainInfo->DomainSid, (*SidLength) );
                (*Sid) = ReturnSid;
                ReturnStatus = TRUE;
            }


            LsaFreeMemory( DomainInfo );
        }

        Status = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(Status));
    }

    return(ReturnStatus);
}


IFSUTIL_EXPORT
ULONG
QueryMachineUniqueToken(
    )
/*++

Routine Description:

    This routine will compute a unique 32-bit value for this machine.

Arguments:

    None.

Return Value:

    0   - Failure.
    A 32-bit value unique for this machine.

--*/
{
    HKEY    hKey;
    int     err;
    WCHAR   szMN[64];
    DWORD   dwType;
    DWORD   cbMN = 64 * sizeof(WCHAR);
    MD4_CTX MD4Context;
    DWORD   Final;
    DWORD * pDigest;
    PSID    sid;
    ULONG   sidLength;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, RegPath, &hKey);
    if (err) {
        return 0;
    }

    err = RegQueryValueEx(hKey, RegVal, NULL, &dwType, (PBYTE) szMN, &cbMN);
    if (err) {
        RegCloseKey(hKey);
        return 0;
    }

    RegCloseKey(hKey);

    if (!GetWidget(&sid, &sidLength)) {
        return 0;
    }

    MD4Init(&MD4Context);

    MD4Update(&MD4Context, (PBYTE) szMN, cbMN);
    MD4Update(&MD4Context, (PBYTE) sid, sidLength);

    MD4Final(&MD4Context);
    pDigest = (DWORD *) MD4Context.digest;

    Final = pDigest[0] ^ pDigest[1] ^ pDigest[2] ^ pDigest[3];

    FREE(sid);

    return Final;
}


BOOLEAN
TestTokenForAdmin(
    )
/*++

Routine Description:

    This routine checks if the current process token represents an admin
    user.

    Code taken from Winlogon.

Arguments:

    None.

Return Value:

    FALSE   - The current process does not represent an administrator.
    TRUE    - The current process represents an administrator.

--*/
{
    NTSTATUS                    Status;
    BOOL                        IsMember;
    PSID                        gAdminSid;
    SID_IDENTIFIER_AUTHORITY    gSystemSidAuthority = SECURITY_NT_AUTHORITY;

    Status = RtlAllocateAndInitializeSid(
                    &gSystemSidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &gAdminSid
                    );

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    if (!CheckTokenMembership(NULL, gAdminSid, &IsMember)) {
        DebugPrintTrace(("IFSUTIL: CheckTokenMembership failed %d\n", GetLastError()));
        return FALSE;
    } else
        return (IsMember == TRUE);
}


IFSUTIL_EXPORT
INT
DiskCopyMainLoop(
    IN      PCWSTRING    SrcNtDriveName,
    IN      PCWSTRING    DstNtDriveName,
    IN      PCWSTRING    SrcDosDriveName,
    IN      PCWSTRING    DstDosDriveName,
    IN      BOOLEAN      Verify,
    IN OUT  PMESSAGE     Message,
    IN OUT  PMESSAGE     PercentMessage
    )
/*++

Routine Description:

    This routine copies on floppy diskette to another floppy diskette.

Arguments:

    SrcNtDriveName  - Supplies the NT style drive name for the source.
    DstNtDriveName  - Supplies the NT style drive name for the destination.
    SrcDosDriveName - Supplies the DOS style drive name for the source.
    DstDosDriveName - Supplies the DOS style drive name for the destination.
    Message         - Supplies an outlet for messages.
    PercentMessage  - Supplies an outlet for percent complete messages.

Return Value:

    0   - Success.
    1   - Io error occured.
    3   - Fatal hard error.
    4   - Initialization error.

--*/
{
    PLOG_IO_DP_DRIVE    src_drive = NULL;
    LOG_IO_DP_DRIVE     dst_drive;
    HMEM                src_hmem;
    HMEM                dst_hmem;
    CONT_MEM            src_cmem;
    PVOID               mem_ptr;
    SECRUN              src_secrun;
    SECRUN              dst_secrun;
    SECTORCOUNT         sec_per_track;
    ULONG               total_tracks;
    ULONG               grab;       // number of tracks to grab at once.
    ULONG               sector_size;
    BOOLEAN             one_drive;
    ULONG               src_top;    // src track pointer -- next read
    ULONG               dst_top;    // dst track pointer -- next write
    ULONG               src_volume_id, volume_id;
    PCHAR               pchar;
    ULONG               i;
    PUSHORT             pus;
    ULONG               heads;
    DSTRING             fsname;
    BOOLEAN             io_error;
    ULONG               percent_complete, newp;
    DWORD               OldErrorMode;
    BOOLEAN             dmf;
    UCHAR               saved_char;
    BOOLEAN             cancel;
    BOOLEAN             done = FALSE;
    MSGID               msg;
    BIG_INT             src_drive_Sectors;
    BIG_INT             src_drive_Tracks;
    MEDIA_TYPE          src_drive_MediaType;
#if defined(FE_SB) && defined(_X86_)
    // FMR Nov.21.94 NaokiM
    MEDIA_TYPE          AltMediaType;
#endif

    one_drive = (*SrcDosDriveName == *DstDosDriveName);

    if (!one_drive) {
        Message->Set(MSG_DCOPY_INSERT_SOURCE_AND_TARGET);
        Message->Display("%W%W", SrcDosDriveName, DstDosDriveName);
    } else {
        Message->Set(MSG_DCOPY_INSERT_SOURCE);
        Message->Display("%W", SrcDosDriveName);
    }

    Message->Set(MSG_PRESS_ENTER_WHEN_READY);
    Message->Display();
    Message->WaitForUserSignal();


    if (!(src_drive = NEW LOG_IO_DP_DRIVE)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return 4;
    }

    if (!src_drive->Initialize(SrcNtDriveName)) {

        // Verify that we can access the source drive:

        if (src_drive->QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display();
            DELETE(src_drive);
            return 4;
        }

        Message->Set(MSG_DCOPY_BAD_SOURCE);
        Message->Display();
        DELETE(src_drive);
        return 3;
    }

    if (!src_drive->IsFloppy()) {
        Message->Set(MSG_DCOPY_INVALID_DRIVE);
        Message->Display();
        DELETE(src_drive);
        return 4;
    }

    if (!src_drive->Lock()) {
        Message->Set(MSG_CANT_LOCK_THE_DRIVE);
        Message->Display("");
        DELETE(src_drive);
        return 3;
    }

    if (src_drive->QueryMediaType() == Unknown ||
        src_drive->QuerySectorsPerTrack() == 0) {
        Message->Set(MSG_DCOPY_BAD_SOURCE);
        Message->Display();
        DELETE(src_drive);
        return 3;
    }

    src_drive_Sectors = src_drive->QuerySectors();
    src_drive_MediaType = src_drive->QueryMediaType();
    src_drive_Tracks = src_drive->QueryTracks();

    if (src_drive->QueryMediaType() == F3_1Pt44_512 &&
        src_drive->QuerySectorsPerTrack() != 18) {

        if (!src_hmem.Initialize() ||
            !src_secrun.Initialize(&src_hmem, src_drive, 0, 1) ||
            !src_secrun.Read()) {

            Message->Set(MSG_DCOPY_BAD_SOURCE);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

        if (src_drive->QuerySectorsPerTrack() != 21 ||
            memcmp(((PUCHAR) src_secrun.GetBuf()) + 3, "MSDMF3.2", 8)) {

            Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }


        {
            HKEY    hKey;
            int     err;
            DWORD   dwType;
            DWORD   JimsBigNumber, machineToken;
            MD4_CTX MD4Context;
            DWORD   Final;
            DWORD * pDigest;
            DWORD   regFinal;
            DWORD   regFinalSize = sizeof(DWORD);

            JimsBigNumber = JIMS_BIG_NUMBER;

            machineToken = QueryMachineUniqueToken();

            MD4Init(&MD4Context);

            MD4Update(&MD4Context, (PBYTE) &machineToken, sizeof(DWORD));
            MD4Update(&MD4Context, (PBYTE) &JimsBigNumber, sizeof(DWORD));

            MD4Final(&MD4Context);
            pDigest = (DWORD *) MD4Context.digest;

            Final = pDigest[0] ^ pDigest[1] ^ pDigest[2] ^ pDigest[3];


            //
            // Reserve the upper two bits for VERSIONing.
            // This is version 0.0
            //

            Final &= 0x3FFFFFFF;


            err = RegOpenKey(HKEY_LOCAL_MACHINE, DmfPath, &hKey);
            if (err) {
                Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
                Message->Display();
                DELETE(src_drive);
                return 3;
            }

            err = RegQueryValueEx(hKey, DmfVal, NULL, &dwType, (PBYTE) &regFinal,
                                  &regFinalSize);
            if (err || regFinalSize != sizeof(DWORD)) {
                Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
                Message->Display();
                DELETE(src_drive);
                return 3;
            }

            RegCloseKey(hKey);

            if (regFinal != Final) {
                Message->Set(MSG_DCOPY_UNRECOGNIZED_FORMAT);
                Message->Display();
                DELETE(src_drive);
                return 3;
            }
        }


        dmf = TRUE;
        Verify = TRUE;

        if (!TestTokenForAdmin()) {
            Message->Set(MSG_DCOPY_NOT_ADMINISTRATOR);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

        if (src_drive->IsSupported(F3_2Pt88_512)) {
            Message->Set(MSG_FMT_DMF_NOT_SUPPORTED_ON_288_DRIVES);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

    } else {
        dmf = FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    // FMR Nov.21.94 NaokiM
    AltMediaType = src_drive->QueryMediaType();
#endif

    // If there is more than one drive then open the second
    // one right away to determine if it's compatible or not.

    if (!one_drive) {

        // Disable popups while we determine the drive type.
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        if (!dst_drive.Initialize(DstNtDriveName)) {

            // Restore the error mode.
            SetErrorMode( OldErrorMode );

            // Verify that we can access the destination drive:

            if (dst_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
                Message->Set(MSG_DASD_ACCESS_DENIED);
                Message->Display();
                DELETE(src_drive);
                return 4;
            }

            Message->Set(MSG_DCOPY_BAD_DEST);
            Message->Display();
            DELETE(src_drive);
            return 3;
        }

        // Restore the error mode.
        SetErrorMode( OldErrorMode );

        if (!dst_drive.Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            DELETE(src_drive);
            return 4;
        }

        // Make sure that the destination floppy will support the same media
        // as the source floppy.

#if defined(FE_SB) && defined(_X86_)
        //
        // FMR Nov.21.94 NaokiM
        // If source media type is not supported on target drive, try another
        // Media type that has same format.(F5_ ... -> F3_ ...)
        //

        if (!dst_drive.IsSupported(src_drive->QueryMediaType())) {

            switch(src_drive->QueryMediaType()) {
                case F5_1Pt23_1024:
                    AltMediaType = F3_1Pt23_1024;
                    break;
                case F3_1Pt23_1024:
                    AltMediaType = F5_1Pt23_1024;
                    break;
                case F5_1Pt2_512:
                    AltMediaType = F3_1Pt2_512;
                    break;
                case F3_1Pt2_512:
                    AltMediaType = F5_1Pt2_512;
                    break;
                case F3_720_512:
                    AltMediaType = F5_720_512;
                    break;
                case F5_720_512:
                    AltMediaType = F3_720_512;
                    break;
                case F5_640_512:
                    AltMediaType = F3_640_512;
                    break;
                case F3_640_512:
                    AltMediaType = F5_640_512;
                    break;
                default:
                    break;
            }
        }

        if (!dst_drive.IsSupported(AltMediaType)) {
#else
        if (!dst_drive.IsSupported(src_drive->QueryMediaType())) {
#endif
            Message->Set(MSG_DCOPY_BAD_DEST);
            Message->Display();
            DELETE(src_drive);
            return 4;
        }
    }

    sec_per_track = src_drive->QuerySectorsPerTrack();
    sector_size = src_drive->QuerySectorSize();
    total_tracks = src_drive->QueryTracks().GetLowPart();
    heads = src_drive->QueryHeads();

    if (total_tracks*sec_per_track*sector_size >
        MAX_DISK_SIZE_ALLOWED*1024*1024) {
        Message->Set(MSG_DCOPY_DISK_TOO_LARGE);
        Message->Display("%d", MAX_DISK_SIZE_ALLOWED);
        DELETE(src_drive);
        return 3;
    }

    Message->Set(MSG_DCOPY_COPYING);
    Message->Display("%d%d%d", src_drive->QueryCylinders().GetLowPart(),
                               sec_per_track,
                               heads);

    DebugAssert(src_drive->QuerySectors().GetHighPart() == 0);

    if (!dst_hmem.Initialize()) {
        DELETE(src_drive);
        return 4;
    }

    io_error = FALSE;

    percent_complete = 0;
    if (PercentMessage) {
        PercentMessage->Set(MSG_PERCENT_COMPLETE);
        if (!PercentMessage->Display("%d", 0)) {
            DELETE(src_drive);
            return 4;
        }
    }

    for (src_top = dst_top = 0; dst_top < total_tracks; dst_top++) {

        if (src_top == dst_top) {

            if (src_top && one_drive) {

                // Gets here because diskcopy is doing multiple passes

                ASSERT(FALSE); // shouldn't get here anymore

                if (!dst_drive.Unlock()) {
                    Message->Set(MSG_CANT_UNLOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }

                Message->Set(MSG_DCOPY_INSERT_SOURCE);
                Message->Display("%W", SrcDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();

                if (!src_drive->Lock()) {
                    Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }
            }


            // Allocate memory for read.
            for (grab = total_tracks - src_top;
                 !src_hmem.Initialize() ||
                 !(mem_ptr = src_hmem.Acquire(grab*sector_size*sec_per_track,
                                              src_drive->QueryAlignmentMask()));
                 grab /= 2) {

//                if (grab < 2) {
                    Message->Set(MSG_CHK_NO_MEMORY);
                    Message->Display();
                    DELETE(src_drive);
                    return 4;
//                }
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }


            // Read the source, track by track.

            for (i = 0; i < grab; i++) {
                if (!src_secrun.Initialize(&src_cmem, src_drive,
                                           src_top*sec_per_track,
                                           sec_per_track)) {
                    DELETE(src_drive);
                    return 4;
                }

              ReadAgain:

                if (!src_secrun.Read()) {

                    if (src_drive->QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                        src_drive->QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                        if (src_drive->QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                            msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                        else
                            msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                        Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                        cancel = Message->Display("%W", SrcDosDriveName);
                        if (!cancel) // if not cancel that means the user want to retry
                            goto ReadAgain;
                        DELETE(src_drive);
                        return 3;
                    }

                    Message->Set(MSG_DCOPY_READ_ERROR);
                    Message->Display("%W%d%d", SrcDosDriveName,
                                               src_top%heads, src_top/heads);
                    io_error = TRUE;
                }

                src_top++;

                newp = (100*(src_top + dst_top)/
                       (2*src_drive->QueryTracks())).GetLowPart();
                if (newp != percent_complete && PercentMessage) {
                    PercentMessage->Set(MSG_PERCENT_COMPLETE);
                    if (!PercentMessage->Display("%d", newp)) {
                        DELETE(src_drive);
                        return 4;
                    }
                }
                percent_complete = newp;
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }

            if (one_drive) {

                if (!src_drive->Unlock()) {
                    Message->Set(MSG_CANT_UNLOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 4;
                } else {
                   DELETE(src_drive);
                   src_drive = NULL;
                }

                Message->Set(MSG_DCOPY_INSERT_TARGET);
                Message->Display("%W", DstDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();

                if (dst_top && !dst_drive.Lock()) {
                    Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }

            }

            if (!dst_top) { // first time

              DstInitializeAgain:

                // Disable popups while we determine the drive type.
                OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

                if (!dst_drive.Initialize(DstNtDriveName)) {

                    // Restore the error mode.
                    SetErrorMode( OldErrorMode );

                    // Verify that we can access the destination drive:

                    if (dst_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
                        Message->Set(MSG_DASD_ACCESS_DENIED);
                        Message->Display();
                        DELETE(src_drive);
                        return 4;
                    }

                    if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                        dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                        if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                            msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                        else
                            msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                        Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                        cancel = Message->Display("%W", DstDosDriveName);
                        if (!cancel) // if not cancel that means the user want to retry
                            goto DstInitializeAgain;
                    }

                    Message->Set(MSG_DCOPY_BAD_DEST);
                    Message->Display();
                    DELETE(src_drive);
                    return 3;
                }

                // Restore the error mode.
                SetErrorMode( OldErrorMode );

                // Only try to lock the drive if the source disk has
                // a serial number.  Don't lock if the source and
                // destination drive name are the same (since they
                // may have the same serial number).
                // If the target is DMF, don't write protect it until
                // we're done with it.

                if (dmf) {
                    saved_char = ((PUCHAR) mem_ptr)[3];
                    ((PUCHAR) mem_ptr)[3] = 'X';
                }

                if (((PUCHAR) mem_ptr)[0x26] == 0x28 ||
                    ((PUCHAR) mem_ptr)[0x26] == 0x29) {

                    memcpy(&src_volume_id, (PCHAR) mem_ptr + 0x27,
                           sizeof(ULONG));
                } else {
                    src_volume_id = 0;
                }

                if (!dst_drive.Lock()) {
                    Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                    Message->Display("");
                    DELETE(src_drive);
                    return 3;
                }

                // Only format the target if it isn't formatted.
                // If it is formatted then it must be of the same
                // media type.

#if defined(FE_SB) && defined(_X86_)
                //
                // FMR Nov.21.94 NaokiM
                // Add conditions that we shuold format target on.
                //

                if (((AltMediaType == F3_1Pt44_512) &&
                      ((dst_drive.QueryMediaType() == F3_1Pt2_512) ||
                       (dst_drive.QueryMediaType() == F3_1Pt23_1024))) ||
                    ((AltMediaType == F3_1Pt2_512) &&
                      ((dst_drive.QueryMediaType() == F3_1Pt44_512) ||
                       (dst_drive.QueryMediaType() == F3_1Pt23_1024))) ||
                    ((AltMediaType == F3_1Pt23_1024) &&
                      ((dst_drive.QueryMediaType() == F3_1Pt44_512) ||
                       (dst_drive.QueryMediaType() == F3_1Pt2_512))) ||
                    ((AltMediaType == F3_720_512) &&
                       (dst_drive.QueryMediaType() == F3_640_512)) ||
                    ((AltMediaType == F3_640_512) &&
                       (dst_drive.QueryMediaType() == F3_720_512)) ||
                    ((AltMediaType == F5_1Pt2_512) &&
                       (dst_drive.QueryMediaType() == F5_1Pt23_1024)) ||
                    ((AltMediaType == F5_1Pt23_1024) &&
                       (dst_drive.QueryMediaType() == F5_1Pt2_512)) ||
                    // FMR Feb.02.95 JunY
                    // Add 5.25" 720KB/640KB types that we shuold format target on.
                    ((AltMediaType == F5_720_512) &&
                       (dst_drive.QueryMediaType() == F5_640_512)) ||
                    ((AltMediaType == F5_640_512) &&
                       (dst_drive.QueryMediaType() == F5_720_512)) ||

                    (dst_drive.QueryMediaType() == Unknown) ||
                    (dst_drive.QueryMediaType() == src_drive_MediaType &&
                     (dmf || dst_drive.QuerySectors() != src_drive_Sectors))) {
                    if (!dst_drive.IsSupported(AltMediaType)) {
#else
                if (dst_drive.QueryMediaType() == Unknown ||
                    (dst_drive.QueryMediaType() == src_drive_MediaType &&
                     (dmf || dst_drive.QuerySectors() != src_drive_Sectors))) {
                    if (!dst_drive.IsSupported(src_drive_MediaType)) {
#endif
                        Message->Set(MSG_DCOPY_BAD_DEST);
                        Message->Display();
                        DELETE(src_drive);
                        return 4;
                    }

                    Message->Set(MSG_DCOPY_FORMATTING_WHILE_COPYING);
                    Message->Display();


#if defined(FE_SB) && defined(_X86_)
                    // FMR Nov.21.94 NaokiM
                    //
                    // Make destination media "Unknwon" before formatting.
                    // This is to ensure write operation in case that sector size is changed
                    // after formatting.
                    //

                    if (dst_drive.QueryMediaType() != Unknown ) {

                        // Disable popups while we determine the drive type.
                        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

                        if (!dst_hmem.Initialize() ||
                            !dst_secrun.Initialize(&dst_hmem, &dst_drive,
                                                    0, 1)) {
                            DELETE(src_drive);
                            return 4;
                        }

                        if (dst_secrun.Read()) {
                            //
                            // if boot sector can be read, destroy boot sector.
                            //
                            pchar = (PCHAR) dst_secrun.GetBuf();
                            *pchar = 0x00;

                            dst_secrun.Write();
                        }

                        //
                        // Dismount desination volume
                        //
                        dst_drive.Initialize(DstNtDriveName);

                        //
                        // Re-initialize dst_hmem for the verify code
                        //
                        if (!dst_hmem.Initialize()) {
                            DELETE(src_drive);
                            return 4;
                        }

                        // Restore the error mode.
                        SetErrorMode( OldErrorMode );

                    }

                    if (!dst_drive.FormatVerifyFloppy(
                                AltMediaType, NULL, NULL, dmf)) {
#else
                    if (!dst_drive.FormatVerifyFloppy(
                                src_drive_MediaType, NULL, NULL, dmf)) {
#endif
                        Message->Set(MSG_DCOPY_BAD_DEST);
                        Message->Display("");
                        DELETE(src_drive);
                        return 3;
                    }

#if defined(FE_SB) && defined(_X86_)
                } else if (dst_drive.QueryMediaType() !=
                                   AltMediaType) {
#else
                } else if (dst_drive.QueryMediaType() !=
                                   src_drive_MediaType) {
#endif

#if defined(FE_SB) && defined(_X86_)
                    // NEC Oct.16.1994
                    // Try to format the destination floppy.
                    // Need user's agreement before the destination floppy will be format.
                    //
                    if ( IsPC98_N() ) {
#ifdef LATER
                        Message->Set(MSG_FORMAT_AND_COPY_OK);
                        Message->Display("");
                        if (!Message->IsYesResponse(TRUE)) {
                                Message->Set(MSG_DCOPY_NON_COMPAT_DISKS);
                                Message->Display();
                                DELETE(src_drive);
                                return 4;
                        }
#endif

                        Message->Set(MSG_DCOPY_FORMATTING_WHILE_COPYING);
                        Message->Display();

                        if (!dst_drive.FormatVerifyFloppy(
                                    src_drive_MediaType, NULL, NULL, dmf)) {

                            Message->Set(MSG_DCOPY_BAD_DEST);
                            Message->Display("");
                            DELETE(src_drive);
                            return 3;
                        }
                    } else {
#endif

                    dst_drive.Unlock();
                    Message->Set(MSG_DCOPY_NON_COMPAT_DISKS);
                    cancel = Message->Display();
                    if (!cancel)
                        goto DstInitializeAgain;
                    DELETE(src_drive);
                    return 4;
#if defined(FE_SB) && defined(_X86_)
                    }
#endif
                }
            }
        }

      FinalWrite:

        if (!dst_secrun.Initialize(&src_cmem, &dst_drive,
                                   dst_top*sec_per_track, sec_per_track)) {
            DELETE(src_drive);
            return 4;
        }

        if (!dst_top && !done) {
            if (src_volume_id) {

                while (!(volume_id = SUPERAREA::ComputeVolId())) {
                }

                pchar = (PCHAR) dst_secrun.GetBuf();
                memcpy(pchar + 0x27, &volume_id, sizeof(ULONG));
            }
            continue;
        }

      WriteAgain:

        if (!dst_secrun.Write()) {

            if (dst_drive.QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED  ||
                dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                    msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                else if (dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA)
                    msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                else {
                    msg = MSG_DCOPY_MEDIA_WRITE_PROTECTED;
                    // Assuming this is the first write.  That means the user has
                    // to either unprotect the disk or put in a different disk.
                    // If the user puts in a different disk, we will have to start
                    // over again.  That's why we should unlock first.
                    dst_drive.Unlock();
                }
                Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                cancel = Message->Display("%W", DstDosDriveName);
                if (!cancel) // if not cancel that means the user want to retry
                    if (msg == MSG_DCOPY_MEDIA_WRITE_PROTECTED) {
                        if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                            DELETE(src_drive);
                            return 4;
                        }
                        done = FALSE;
                        dst_top = 0;
                        goto DstInitializeAgain;
                    } else
                        goto WriteAgain;
                DELETE(src_drive);
                return 3;
            }

            Message->Set(MSG_DCOPY_WRITE_ERROR);
            Message->Display("%W%d%d", DstDosDriveName,
                                       dst_top%heads, dst_top/heads);

            io_error = TRUE;

        } else if (Verify) {
            pchar = (PCHAR) dst_secrun.GetBuf();

            if (!dst_secrun.Initialize(&dst_hmem, &dst_drive,
                                       dst_top*sec_per_track, sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }

          VerifyReadAgain:

            if (!dst_secrun.Read() ||
                memcmp(dst_secrun.GetBuf(), pchar,
                       (UINT) (sec_per_track*sector_size))) {

                if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                    dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                    if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE)
                        msg = MSG_DCOPY_NO_MEDIA_IN_DEVICE;
                    else
                        msg = MSG_DCOPY_UNRECOGNIZED_MEDIA;
                    Message->Set(msg, NORMAL_MESSAGE, GUI_MESSAGE);
                    cancel = Message->Display("%W", DstDosDriveName);
                    if (!cancel) // if not cancel that means the user want to retry
                        goto VerifyReadAgain;
                    DELETE(src_drive);
                    return 3;
                }

                Message->Set(MSG_DCOPY_WRITE_ERROR);
                Message->Display("%W%d%d", DstDosDriveName,
                                           dst_top%heads, dst_top/heads);

                io_error = TRUE;
            }
        }

        if (dst_top == total_tracks-1) {
            dst_top = 0;
            done = TRUE;
            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                DELETE(src_drive);
                return 4;
            }
            goto FinalWrite;
        }

        if (done)
           dst_top = total_tracks;

        newp = (100*(src_top + dst_top-1)/
               (2*src_drive_Tracks)).GetLowPart();
        if (newp != percent_complete && PercentMessage) {
            PercentMessage->Set(MSG_PERCENT_COMPLETE);
            if (!PercentMessage->Display("%d", newp)) {
                DELETE(src_drive);
                return 4;
            }
        }
        percent_complete = newp;
    }

    DELETE(src_drive);

    // If this is DMF then write-protect the target floppy.

    if (dmf) {
        if (!dst_hmem.Initialize() ||
            !dst_secrun.Initialize(&dst_hmem, &dst_drive, 0, 1) ||
            !dst_secrun.Read() ||
            (((PUCHAR) dst_secrun.GetBuf())[3] = saved_char) != saved_char ||
            !dst_secrun.Write()) {

            Message->Set(MSG_DCOPY_WRITE_ERROR);
            Message->Display("%W%d%d", DstDosDriveName, 0, 0);
            io_error = TRUE;
        }
    }

    if (src_volume_id) {
        pus = (PUSHORT) &volume_id;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", pus[1], pus[0]);
    }

    // In that we didn't lock the
    // volume previously.  We need to do this so
    // that the file system will do a verify and
    // thus be able to see the new label if any.
    // We shouldn't fail if we can't do this though.

    dst_drive.Lock();

    return io_error ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\intstack.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "intstack.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( INTSTACK, OBJECT, IFSUTIL_EXPORT );

VOID
INTSTACK::Construct (
        )
/*++

Routine Description:

    Constructor for INTSTACK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _stack = NULL;
    _size = 0;
}


IFSUTIL_EXPORT
INTSTACK::~INTSTACK(
    )
/*++

Routine Description:

    Destructor for INTSTACK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
INTSTACK::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
INTSTACK::Push(
    IN  BIG_INT Data
    )
/*++

Routine Description:

    This routine pushes 'Data' on the stack.

Arguments:

    Data    - Supplies the integer to push on the stack.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PINTNODE    p;

    p = _stack;
        if (!(_stack = NEW INTNODE)) {
        _stack = p;
        return FALSE;
    }

    _stack->Next = p;
    _stack->Data = Data;
    _size++;

    return TRUE;
}


IFSUTIL_EXPORT
VOID
INTSTACK::Pop(
    IN  ULONG   HowMany
    )
/*++

Routine Description:

    This routine attempts to remove 'HowMany' elements from the top of
    the stack.  If there are not that many to remove then all that
    can be removed, will be removed and FALSE will be returned.

Arguments:

    HowMany - Supplies the number of elements to remove from the top of the
                stack.

Return Value:

    None.

--*/
{
    PINTNODE    p;

    for (; HowMany; HowMany--) {

        DebugAssert(_stack);

        p = _stack->Next;
                DELETE( _stack );
        _stack = p;
        _size--;
    }
}


IFSUTIL_EXPORT
BIG_INT
INTSTACK::Look(
    IN  ULONG   Index
    ) CONST
/*++

Routine Description:

    This routine returns the 'Index'th element of the stack.  Index 0 denotes
    the top of the stack.  Index 1 denotes one element from the top of the
    stack and so on.  If the stack is smaller than the element requested then
    this routine will return 0.  This is not a limitation since 'QuerySize'
    will return the depth of the stack.

Arguments:

    Index   - Supplies the index of the data requested.

Return Value:

    The value of the stack element at position 'Index' or 0.

--*/
{
    PINTNODE    p;

    p = _stack;
    for (; Index; Index--) {
        p = p ? p->Next : NULL;
    }

    if (!p) {
        return 0;
    }

    return p->Data;
}


BOOLEAN
INTSTACK::IsMember(
    IN  BIG_INT Data
    ) CONST
/*++

Routine Description:

    This routine searches the stack to see if there is an element equal
    to 'Data'.  It returns TRUE if there is.

Arguments:

    Data    - Supplies the element to search for.

Return Value:

    FALSE   - 'Data' is not an element of the stack.
    TRUE    - 'Data' is an element of the stack.

--*/
{
    PINTNODE    p;

    for (p = _stack; p; p = p->Next) {
        if (Data == p->Data) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
INTSTACK::Destroy(
    )
/*++

Routine Description:

    This routine returns the INTSTACK to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PINTNODE    p;

    while (_stack) {
        p = _stack->Next;
                DELETE( _stack );
        _stack = p;
    }
    _size = 0;
}


BOOLEAN
INTSTACK::ReverseCopy(
    PINTSTACK   x
    )
/*++

Routine Description:

    This routine copies the INTSTACK backwards.

Arguments:

    x       - Supplies the INTSTACK to copy from.

Return Value:

    TRUE    - if successful
    FALSE   - if failure

--*/
{
    BOOLEAN     result = TRUE;
    PINTNODE    p;

    for (p = x->_stack; p && result; p = p->Next) {
        result = Push(p->Data);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\mpmap.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "mpmap.hxx"
#include "arrayit.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( MOUNT_POINT_MAP, OBJECT, IFSUTIL_EXPORT );

DEFINE_EXPORTED_CONSTRUCTOR( MOUNT_POINT_TUPLE, OBJECT, IFSUTIL_EXPORT );

VOID
MOUNT_POINT_MAP::Construct (
        )
/*++

Routine Description:

    Constructor for MOUNT_POINT_MAP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _parr = NULL;
}


VOID
MOUNT_POINT_MAP::Destroy(
    )
/*++

Routine Description:

    This routine returns the MOUNT_POINT_MAP to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (_parr)
        DELETE(_parr);
}


IFSUTIL_EXPORT
MOUNT_POINT_MAP::~MOUNT_POINT_MAP(
    )
/*++

Routine Description:

    Destructor for MOUNT_POINT_MAP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::Initialize(
    )
/*++

Routine Description:

    This routine initializes the stack for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _parr = NEW ARRAY;

    if (!_parr || !_parr->Initialize()) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::AddVolumeName(
    IN     PWSTRING     DeviceName,
    IN     PWSTRING     VolumeName
    )
/*++

Routine Description:

    This routine adds a mount point tuple consisting of
    DeviceName and VolumeName pair into the array.
    If the tuple already exists, it just updates it.

Arguments:

    DeviceName  - Supplies the name of the device.
    VolumeName  - Supplies the volume name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_DeviceName.Stricmp(DeviceName) == 0) {
            DELETE(iter);
            return mptuple->_VolumeName.Initialize(VolumeName);
        }
    }

    DELETE(iter);

    DebugAssert(mptuple == NULL);

    if (mptuple == NULL) {
        mptuple = NEW MOUNT_POINT_TUPLE;
        if (mptuple == NULL) {
            DebugPrint("Out of memory\n");
            return FALSE;
        }
    }

    if (!mptuple->_DeviceName.Initialize(DeviceName) ||
        !mptuple->_VolumeName.Initialize(VolumeName) ||
        !mptuple->_DriveName.Initialize() ||
        !_parr->Put(mptuple)) {
        DELETE(mptuple);
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::AddDriveName(
    IN     PWSTRING     DeviceName,
    IN     PWSTRING     DriveName
    )
/*++

Routine Description:

    This routine adds a mount point tuple consisting of
    DeviceName and DriveName pair into the array.
    If the tuple already exists, it just updates it.

Arguments:

    DeviceName  - Supplies the name of the device.
    DriveName   - Supplies the drive name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_DeviceName.Stricmp(DeviceName) == 0) {
            DELETE(iter);
            return mptuple->_DriveName.Initialize(DriveName);
        }
    }

    DELETE(iter);

    DebugAssert(mptuple == NULL);

    if (mptuple == NULL) {
        mptuple = NEW MOUNT_POINT_TUPLE;
        if (mptuple == NULL) {
            DebugPrint("Out of memory\n");
            return FALSE;
        }
    }

    if (!mptuple->_DeviceName.Initialize(DeviceName) ||
        !mptuple->_DriveName.Initialize(DriveName) ||
        !mptuple->_VolumeName.Initialize() ||
        !_parr->Put(mptuple)) {
        DELETE(mptuple);
        return FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::QueryVolumeName(
    IN     PWSTRING DriveName,
       OUT PWSTRING VolumeName
    )
/*++

Routine Description:

    This routine retrieves the associated VolumeName given
    the DeviceName.

Arguments:

    DriveName   - Supplies the drive name.
    VolumeName  - Receives the volume name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_DriveName.Stricmp(DriveName) == 0) {
            DELETE(iter);
            return VolumeName->Initialize(&(mptuple->_VolumeName));
        }
    }

    DELETE(iter);

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::QueryDriveName(
    IN     PWSTRING VolumeName,
       OUT PWSTRING DriveName
    )
/*++

Routine Description:

    This routine retrieves the associated DriveName given
    the DeviceName.

Arguments:

    VolumeName  - Supplies the volume name.
    DriveName   - Receives the drive name of the device.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PMOUNT_POINT_TUPLE  mptuple;
    PARRAY_ITERATOR     iter;

    iter = (PARRAY_ITERATOR)_parr->QueryIterator();

    if (iter == NULL)
        return FALSE;

    while (mptuple = (PMOUNT_POINT_TUPLE)iter->GetNext()) {
        if (mptuple->_VolumeName.Stricmp(VolumeName) == 0) {
            DELETE(iter);
            return DriveName->Initialize(&(mptuple->_DriveName));
        }
    }

    DELETE(iter);

    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
MOUNT_POINT_MAP::GetAt(
    IN     ULONG    Index,
       OUT PWSTRING DriveName,
       OUT PWSTRING VolumeName
    )
{
    PMOUNT_POINT_TUPLE  mptuple;

    DebugPtrAssert(DriveName);
    DebugPtrAssert(VolumeName);

    mptuple = (PMOUNT_POINT_TUPLE)_parr->GetAt(Index);

    if (mptuple == NULL)
        return FALSE;

    if (!DriveName->Initialize(&mptuple->_DriveName) ||
        !VolumeName->Initialize(&mptuple->_VolumeName)) {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ifsutil
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib    \
    ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\cfgmgr32.lib \
    $(SDK_LIB_PATH)\setupapi.lib \
    $(SDK_LIB_PATH)\ntdll.lib

USE_MSVCRT=1

DLLENTRY=InitializeIfsUtil

PRECOMPILED_INCLUDE= ..\pch.cxx

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\autoentr.cxx    \
        ..\autoreg.cxx     \
        ..\bigint.cxx      \
        ..\bootreg.c       \
        ..\cache.cxx       \
        ..\cannedsd.cxx    \
        ..\dcache.cxx      \
        ..\digraph.cxx     \
        ..\drive.cxx       \
        ..\ifssys.cxx      \
        ..\ifsutil.cxx     \
        ..\intstack.cxx    \
        ..\mldcopy.cxx     \
        ..\mpmap.cxx       \
        ..\numset.cxx      \
        ..\rcache.cxx      \
        ..\rwcache.cxx     \
        ..\secrun.cxx      \
        ..\smsdtect.cxx    \
        ..\spaset.cxx      \
        ..\supera.cxx      \
        ..\tlink.cxx       \
        ..\volume.cxx      \
        ..\ifsutil.rc

INCLUDES= \
    ..;\
    ..\..\inc;\
    ..\..\..\ulib\inc; \
    $(DS_INC_PATH)\crypto; \
    $(DDK_INC_PATH)

C_DEFINES=-DUNICODE=1 -DSTRICT=1

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console

DLLDEF=

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\rwcache.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "rwcache.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( READ_WRITE_CACHE, DRIVE_CACHE, IFSUTIL_EXPORT );


READ_WRITE_CACHE::~READ_WRITE_CACHE(
    )
/*++

Routine Description:

    Destructor for READ_WRITE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
READ_WRITE_CACHE::Construct(
        )
/*++

Routine Description:

    Contructor for READ_WRITE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _cache_blocks = NULL;
    _num_blocks = 0;
    _sector_size = 0;
    _error_occurred = FALSE;
    _sectors_per_buffer = 0;
#if defined(RWCACHE_PERF_COUNTERS)
    _WMiss = _WHit = 0;
    _RMiss = _RHit = _ROverHead = 0;
    _Usage = 0;
#endif
}


VOID
READ_WRITE_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for READ_WRITE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    Flush();

    for (i = 0; i < _num_blocks; i++) {
        DELETE(_cache_blocks[i]);
    }
    DELETE(_cache_blocks);

    _num_blocks = 0;
    _sector_size = 0;
    _error_occurred = FALSE;
    _sectors_per_buffer = 0;
#if defined(RWCACHE_PERF_COUNTERS)
    _WMiss = _WHit = 0;
    _RMiss = _RHit = _ROverHead = 0;
    _Usage = 0;
#endif
}


IFSUTIL_EXPORT
BOOLEAN
READ_WRITE_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      ULONG           NumberOfCacheBlocks
    )
/*++

Routine Description:

    This routine initializes a READ_WRITE_CACHE object.

Arguments:

    Drive               - Supplies the drive to cache for.
    NumberOfCacheBlocks - Supplies the number of cache blocks.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;

    Destroy();

    _num_blocks = NumberOfCacheBlocks;
    _sector_size = Drive->QuerySectorSize();
    _error_occurred = FALSE;

    if (!DRIVE_CACHE::Initialize(Drive) ||
        !_sectors_cached.Initialize() ||
        !(_cache_blocks = NEW PRW_CACHE_BLOCK[_num_blocks]) ||
        !_write_buffer.Initialize() ||
        !_write_buffer.Acquire(1024*1024,
                               Drive->QueryAlignmentMask())) {

        Destroy();
        return FALSE;
    }

    DebugAssert((_write_buffer.QuerySize() % _sector_size) == 0);
    _sectors_per_buffer = _write_buffer.QuerySize()/_sector_size;

    for (i = 0; i < _num_blocks; i++) {

        if (!(_cache_blocks[i] = NEW RW_CACHE_BLOCK) ||
            !_cache_blocks[i]->SectorBuffer.Initialize() ||
            !_cache_blocks[i]->SectorBuffer.Acquire(_sector_size)) {

            Destroy();
            return FALSE;
        }

        _cache_blocks[i]->InUse = FALSE;
        _cache_blocks[i]->IsDirty = FALSE;
        _cache_blocks[i]->Age = 0;
        _cache_blocks[i]->SectorNumber = 0;
    }

    return TRUE;
}


BOOLEAN
READ_WRITE_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i, j;
    PRW_CACHE_BLOCK p;
    PCHAR           pchar;

    pchar = (PCHAR) Buffer;

    // First check to see if the whole thing can come from the cache.

    for (i = 0; i < NumberOfSectors; i++) {

        if (!(p = GetSectorCacheBlock(StartingSector + i))) {
            break;
        }

#if defined(RWCACHE_PERF_COUNTERS)
        _RHit++;
#endif
        memcpy(&pchar[i*_sector_size], p->SectorBuffer.GetBuf(), _sector_size);
    }

    if (i == NumberOfSectors) {
        return TRUE;
    }


    // Not all of it was available so we first read the whole thing in from
    // disk and then modify that with any dirty cache blocks.

    if (!HardRead(StartingSector + i, NumberOfSectors - i,
                  &pchar[i*_sector_size])) {

        return FALSE;
    }

    // First, spin through the sectors just read to determine
    // if any are dirty in the cache; if a sector is present
    // and dirty, copy it from the cache block to the client
    // buffer.
    //
    for (j = i; j < NumberOfSectors; j++) {

        if (p = GetSectorCacheBlock(StartingSector + j)) {

            // The sector is in the cache.  Update its timestamp;
            // if it's dirty, copy the data from the cache block
            // into the client buffer.
            //
#if defined(RWCACHE_PERF_COUNTERS)
            _ROverHead++;
#endif
            if (p->IsDirty) {
                memcpy(&pchar[j*_sector_size], p->SectorBuffer.GetBuf(), _sector_size);
            }
        }
    }

    // Now spin through them again, copying the read data that
    // isn't already in the cache into the cache.  Note that this
    // loop must be kept separate from the loop above to prevent
    // dirty cache blocks associated with this read from getting
    // preempted.
    //
    for (j = i; j < NumberOfSectors; j++) {

        if (!GetSectorCacheBlock(StartingSector + j)) {

            // The sector is not already in the cache--grab a
            // cache block and stuff this sector's data into it
            //
            if (p = GetNextAvailbleCacheBlock(StartingSector + j)) {

                if (p->InUse) {
                    if (p->IsDirty) {
                        FlushThisCacheBlock(p);
                    }

                    _sectors_cached.Remove(p->SectorNumber);
                }

#if defined(RWCACHE_PERF_COUNTERS)
                _RMiss++;
#endif
                p->InUse = TRUE;
                p->IsDirty = FALSE;
                p->SectorNumber = StartingSector + j;
                memcpy(p->SectorBuffer.GetBuf(), &pchar[j*_sector_size], _sector_size);

                _sectors_cached.Add(p->SectorNumber);

            } else {
                DebugAbort("This can't happen!");
            }
        }
    }

    return TRUE;
}


BOOLEAN
READ_WRITE_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    PRW_CACHE_BLOCK p;
    PCHAR           pchar;

    pchar = (PCHAR) Buffer;

    for (i = 0; i < NumberOfSectors; i++) {

        if (!(p = GetSectorCacheBlock(StartingSector + i))) {

            p = GetNextAvailbleCacheBlock(StartingSector + i);
            DebugAssert(p);

            if (p->InUse) {
                if (p->IsDirty) {
                    FlushThisCacheBlock(p);
                }

                _sectors_cached.Remove(p->SectorNumber);
            }

#if defined(RWCACHE_PERF_COUNTERS)
            _WMiss++;
#endif
            p->InUse = TRUE;
            p->SectorNumber = StartingSector + i;
            _sectors_cached.Add(p->SectorNumber);
        } else {
#if defined(RWCACHE_PERF_COUNTERS)
            _WHit++;
#endif
        }

        p->IsDirty = TRUE;
        memcpy(p->SectorBuffer.GetBuf(), &pchar[i*_sector_size], _sector_size);
    }

    return !_error_occurred;
}


BOOLEAN
READ_WRITE_CACHE::Flush(
    )
/*++

Routine Description:

    This routine flushes all dirty cache blocks to disk.  This routine
    returns FALSE if there has ever been an write error since the last
    flush.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;
    PRW_CACHE_BLOCK p;

    for (i=0; i < _num_blocks; i++) {
        p = _cache_blocks[i];
        if (p->InUse && p->IsDirty) {
            FlushThisCacheBlock(p);
        }
#if defined(RWCACHE_PERF_COUNTERS)
        if (p->InUse) {
            _Usage++;
        }
#endif
    }

    return !_error_occurred;
}


PRW_CACHE_BLOCK
READ_WRITE_CACHE::GetSectorCacheBlock(
    IN  BIG_INT SectorNumber
    )
/*++

Routine Description:

    This routine searches the cache block list and return the block corresponding
    to the given sector.  If no such block exists then this routine returns NULL.

Arguments:

    SectorNumber    - Supplies the sector searched for.

Return Value:

    The cache block for the given sector or NULL.

--*/
{
    ULONG           i;
    PRW_CACHE_BLOCK p;

    i = (SectorNumber % _num_blocks).GetLowPart();
    p = _cache_blocks[i];
    if (p->InUse && (p->SectorNumber == SectorNumber)) {
        return p;
    } else
        return NULL;
}


PRW_CACHE_BLOCK
READ_WRITE_CACHE::GetNextAvailbleCacheBlock(
    IN  BIG_INT SectorNumber
    )
/*++

Routine Description:

    This routine searches the cache block list and return the next available
    one.  This routine will return either the oldest cache block or one that
    is not in use.

Arguments:

    None.

Return Value:

    The next available cache block.

--*/
{
    ULONG   i;

    i = (SectorNumber % _num_blocks).GetLowPart();

    return _cache_blocks[i];
}


VOID
READ_WRITE_CACHE::FlushThisCacheBlock(
    IN OUT  PRW_CACHE_BLOCK Block
    )
/*++

Routine Description:

    This routine flushes the given block along with all of its adjacent
    neighbours.  All of these cache blocks are then marked clean.

Arguments:

    Block   - Supplies a pointer to the cache block to flush.

Return Value:

    None.

Notes:

    Because we don't check return values from the NUMBER_SET calls, we can't
    depend on this structure being valid.  If it is not then only the given
    block will be flushed.

--*/
{
    ULONG           i, n;
    BIG_INT         start, length;
    PCHAR           flush_buffer;
    PRW_CACHE_BLOCK p;
    ULONG           sectors_per_buffer;
    ULONG           offset;

    // First figure out which group to flush.

    n = _sectors_cached.QueryNumDisjointRanges();
    for (i = 0; i < n; i++) {

        _sectors_cached.QueryDisjointRange(i, &start, &length);

        if (Block->SectorNumber >= start && Block->SectorNumber < (start + length)) {
            break;
        }
    }

    if (i == n) {
        DebugPrintTrace(("IFSUTIL: FlushThisCacheBlock failure 1\n"));
        _error_occurred = TRUE;
        DebugAssert(FALSE);
        return;
    }

    flush_buffer = (PCHAR) _write_buffer.GetBuf();

    offset = 0;
    do {
        sectors_per_buffer = min(_sectors_per_buffer, length.GetLowPart()-offset);

        for (i = 0; i < sectors_per_buffer; i++) {

            if (!(p = GetSectorCacheBlock(start + i))) {

                DebugPrintTrace(("IFSUTIL: FlushThisCacheBlock failure 2\n"));
                _error_occurred = TRUE;
                DebugAssert(FALSE);
                return;
            }

            p->IsDirty = FALSE;
            memcpy(&flush_buffer[i*_sector_size], p->SectorBuffer.GetBuf(), _sector_size);
        }
        _error_occurred = !HardWrite(start, sectors_per_buffer, flush_buffer) || _error_occurred;
        if (_error_occurred) {
            DebugPrintTrace(("IFSUTIL: FlushThisCacheBlock failure 3\n"));
            return;
        }
        start += sectors_per_buffer;
        offset += sectors_per_buffer;
    } while (offset < length.GetLowPart());
}

#if defined(RWCACHE_PERF_COUNTERS)
VOID
READ_WRITE_CACHE::QueryPerformanceCounters(
    PULONG      RMiss,
    PULONG      RHit,
    PULONG      ROverHead,
    PULONG      WMiss,
    PULONG      WHit,
    PULONG      Usage
    )
{
    *RMiss = _RMiss;
    *RHit  = _RHit;
    *ROverHead = _ROverHead;
    *WMiss = _WMiss;
    *WHit  = _WHit;
    *Usage = _Usage;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\spaset.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "spaset.hxx"

extern "C" {
#include "stdio.h"
}

DEFINE_EXPORTED_CONSTRUCTOR( SPARSE_SET, OBJECT, IFSUTIL_EXPORT );

typedef union {
    ULONG   x;
    struct {
        USHORT  y1;
        USHORT  y2;
    } y;
    struct {
        UCHAR   z1;
        UCHAR   z2;
        UCHAR   z3;
        UCHAR   z4;
    } z;
} HASH_KEY;

VOID
SPARSE_SET::Construct (
        )
/*++

Routine Description:

    Constructor for SPARSE_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _card = 0;
    _hashTable = NULL;
}


VOID
SPARSE_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the SPARSE_SET to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PHASH_ELEMENT   hashElementPtr;
    USHORT          i;

    _card = 0;
    if (_hashTable == NULL)
        return;

    hashElementPtr = _hashTable;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    FREE(_hashTable);
}


IFSUTIL_EXPORT
SPARSE_SET::~SPARSE_SET(
    )
/*++

Routine Description:

    Destructor for SPARSE_SET.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::Initialize(
    )
/*++

Routine Description:

    This routine initializes the set for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PHASH_ELEMENT   hashElementPtr;
    USHORT          i;

    Destroy();

    _hashTable = (PHASH_ELEMENT)MALLOC(sizeof(HASH_ELEMENT)*SPA_SET_HASH_TABLE_SIZE);
    if (_hashTable == NULL)
        return FALSE;

    hashElementPtr = _hashTable;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        hashElementPtr->elements = NULL;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::CheckAndAdd(
    IN  BIG_INT   Number,
    OUT PBOOLEAN  Duplicate
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number    - Supplies the number to add to the set.
    Duplicate - Returns TRUE if Number already exists in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HASH_KEY        key;
    UCHAR           hashKey;
    PHASH_ELEMENT   hashElementPtr;
    PBIG_INT        tmpPtr;
    PBIG_INT        elementPtr;
    BOOLEAN         duplicate;
    ULONG           i;


    if (Duplicate == NULL)
        Duplicate = &duplicate;

    *Duplicate = FALSE;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    key.x = Number.GetLowPart() ^ Number.GetHighPart();
    hashKey = key.z.z1 ^ key.z.z2 ^ key.z.z3 ^ key.z.z4;

    hashElementPtr = &(_hashTable[hashKey]);
    if (hashElementPtr->elements == NULL) {
        hashElementPtr->elements = (PBIG_INT)MALLOC(sizeof(BIG_INT)*
                                                    SPA_SET_HASH_ELEMENT_INC);
        if (hashElementPtr->elements == NULL)
            return FALSE;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = SPA_SET_HASH_ELEMENT_INC;
    }

    //
    // Check for duplicates
    //

    elementPtr = hashElementPtr->elements;
    DebugAssert(hashElementPtr->elementCount.GetHighPart() == 0);
    for (i=0; i<hashElementPtr->elementCount; i++) {
        if (*(elementPtr++) == Number)
            return (*Duplicate = TRUE);
    }

    if (hashElementPtr->elementCount == hashElementPtr->maxElementCount) {
        DebugAssert(hashElementPtr->maxElementCount.GetHighPart() == 0);
        tmpPtr = (PBIG_INT)REALLOC(hashElementPtr->elements,
                                   sizeof(BIG_INT)*
                                   (SPA_SET_HASH_ELEMENT_INC +
                                    hashElementPtr->maxElementCount.GetLowPart()));
        if (tmpPtr == NULL)
            return FALSE;
        hashElementPtr->elements = tmpPtr;
        hashElementPtr->maxElementCount += SPA_SET_HASH_ELEMENT_INC;
    }

        DebugAssert(hashElementPtr->elementCount.GetHighPart() == 0);
    hashElementPtr->elements[hashElementPtr->elementCount.GetLowPart()] = Number;
    hashElementPtr->elementCount += 1;
    DebugAssert(hashElementPtr->elementCount <= hashElementPtr->maxElementCount);
    _card += 1;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::RemoveAll(
     )
{
    PHASH_ELEMENT   hashElementPtr;
    USHORT          i;

    DebugPtrAssert(_hashTable);
    hashElementPtr = _hashTable;
    _card = 0;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
SPARSE_SET::CheckAndRemove(
    IN  BIG_INT     Number,
     OUT PBOOLEAN   DoesExists
    )
/*++

Routine Description:

    This routine removes a number from the number set.

Arguments:

    Number      - Supplies the number to remove.
    DoesExists  - TRUE if Number was found in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HASH_KEY        key;
    UCHAR           hashKey;
    PBIG_INT        elementPtr;
    PHASH_ELEMENT   hashElementPtr;
    BOOLEAN         doesExist;
    ULONG           i;

    if (DoesExists == NULL)
        DoesExists = &doesExist;

    *DoesExists = TRUE;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    key.x = Number.GetLowPart() ^ Number.GetHighPart();
    hashKey = key.z.z1 ^ key.z.z2 ^ key.z.z3 ^ key.z.z4;

    hashElementPtr = &(_hashTable[hashKey]);
    if (hashElementPtr->elements == NULL) {
        *DoesExists = FALSE;
        return TRUE;
    }

    //
    // Check for existence
    //

    elementPtr = hashElementPtr->elements;
    DebugAssert(hashElementPtr->elementCount.GetHighPart() == 0);
    for (i=0; i<hashElementPtr->elementCount; i++) {
        if (*(elementPtr++) == Number) {
            if (hashElementPtr->elementCount == 1) {
                FREE(hashElementPtr->elements);
            } else {
                DebugAssert(hashElementPtr->elementCount > 1);
                hashElementPtr->elementCount -= 1;
                *(--elementPtr) = hashElementPtr->elements[
                                    hashElementPtr->elementCount.GetLowPart()];
            }
            _card -= 1;
            return TRUE;
        }
    }
    *DoesExists = FALSE;
    return TRUE;
}

IFSUTIL_EXPORT
VOID
SPARSE_SET::DumpHashTable(
    )
/*++

Routine Description:

    This routine dumps out the hash table

--*/
{
#if 0
    USHORT          i;
    PHASH_ELEMENT   hashElementPtr;

    hashElementPtr = _hashTable;
    for (i=0; i<SPA_SET_HASH_TABLE_SIZE; i++) {
        if (hashElementPtr->elements != NULL) {
            printf("%d, %d\n", i, hashElementPtr->elementCount);
        }
        hashElementPtr++;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\supera.cxx ===
#include <pch.cxx>

#if i386
//
// Temporarily disable optimizations until cl386 Drop 077 is fixed.
//
#pragma optimize("",off)
#endif

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "supera.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ifssys.hxx"

#define MaxLabelLength      1024

DEFINE_EXPORTED_CONSTRUCTOR( SUPERAREA, SECRUN, IFSUTIL_EXPORT );

IFSUTIL_EXPORT
SUPERAREA::~SUPERAREA(
    )
/*++

Routine Description:

    Destructor for SUPERAREA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
SUPERAREA::Construct(
        )
/*++

Routine Description:

        Constructor for SUPERAREA.

Arguments:

        None.

Return Value:

        None.

--*/
{
    _drive = NULL;
}


VOID
SUPERAREA::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state freeing up
    any memory in the process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


IFSUTIL_EXPORT
BOOLEAN
SUPERAREA::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      SECTORCOUNT         NumberOfSectors,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine initializes the SUPERAREA for the given drive.

Arguments:

    Mem             - Supplies necessary memory for the underlying sector run.
    Drive           - Supplies the drive where the superarea resides.
    NumberOfSectors - Supplies the number of sectors in the superarea.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(Drive);
    DebugAssert(NumberOfSectors);

    if (!SECRUN::Initialize(Mem, Drive, 0, NumberOfSectors)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    _drive = Drive;

    return TRUE;
}


IFSUTIL_EXPORT
VOLID
SUPERAREA::ComputeVolId(
    IN  VOLID   Seed
    )
/*++

Routine Description:

    This routine computes a new and unique volume identifier.

Arguments:

    None.

Return Value:

    A unique volume id.

--*/
{
    VOLID           volid;
    PUCHAR          p;
    INT             i;
    LARGE_INTEGER   NtfsTime;

    if (Seed) {
        volid = Seed;
    } else {
        volid = 0;
    }

    do {

        if (!volid) {
            IFS_SYSTEM::QueryNtfsTime( &NtfsTime );
            if (NtfsTime.LowPart) {
                volid = (VOLID) NtfsTime.LowPart;
            } else {
                volid = (VOLID) NtfsTime.HighPart;
            }

            if (volid == 0) { // This should never happen.
                volid = 0x11111111;
            }
        }

        p = (PUCHAR) &volid;
        for (i = 0; i < sizeof(VOLID); i++) {
            volid += *p++;
            volid = (volid >> 2) + (volid << 30);
        }

    } while (!volid);

    return volid;
}

NTSTATUS
SUPERAREA::FormatNotification(
    IN     PWSTRING                        Label,
       OUT PFILE_FS_SIZE_INFORMATION       FsSizeInfo,
       OUT PFILE_FS_VOLUME_INFORMATION     FsVolInfo
    )
/*++

Routine Description:

    This routine sets the volume label which serves as a notification
    to the rest of the system that format has completed and the volume
    is avaiable for use again.

Arguments:

    Label        - Supplies the volume label.  If NULL, the current volume
                   label will be used.
    FsSizeInfo   - Retrieves the File System Size Information
    FsVolInfo    - Retrieves the File System Volume Information

Return Value:

    NT status

--*/
{
    //
    // Close the current drive handle first
    //
    _drive->CloseDriveHandle();

    return SUPERAREA::GenerateLabelNotification(_drive->GetNtDriveName(),
                                                Label,
                                                FsSizeInfo,
                                                FsVolInfo);
}

NTSTATUS
SUPERAREA::GenerateLabelNotification(
    IN     PCWSTRING                       NtDriveName,
    IN     PWSTRING                        Label,
       OUT PFILE_FS_SIZE_INFORMATION       FsSizeInfo,
       OUT PFILE_FS_VOLUME_INFORMATION     FsVolInfo
    )
/*++

Routine Description:

    This routine sets the volume label which serves as a notification
    to the rest of the system that the volume has changed.

Arguments:

    NtDriveName  - Supplies the name of the volume.
    Label        - Supplies the volume label.  If NULL, the current volume
                   label will be used.
    FsSizeInfo   - Retrieves the File System Size Information
    FsVolInfo    - Retrieves the File System Volume Information

Return Value:

    NT status

--*/
{
    CONST                       vollen = sizeof(FILE_FS_VOLUME_INFORMATION) +
                                         MaxLabelLength;
    CONST                       lablen = sizeof(FILE_FS_LABEL_INFORMATION) +
                                         MaxLabelLength;
    PFILE_FS_VOLUME_INFORMATION volinfo;
    PFILE_FS_LABEL_INFORMATION  labinfo;
    STR                         vol_info_buf[vollen];
    STR                         lab_info_buf[lablen];

    IO_STATUS_BLOCK             status_block;
    NTSTATUS                    status;

    PCWSTRING                   ntDriveName;
    UNICODE_STRING              string;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      handle;

    ntDriveName = NtDriveName;

    string.Length = (USHORT) ntDriveName->QueryChCount() * sizeof(WCHAR);
    string.MaximumLength = string.Length;
    string.Buffer = (PWSTR)ntDriveName->GetWSTR();

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("IFSUTIL: Unable to open handle with status %x\n", status));
        return status;
    }

    // status is good at this point

    if (FsVolInfo) {

        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              FsVolInfo,
                                              sizeof(*FsVolInfo),
                                              FileFsVolumeInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to query file system volume information with status %x\n", status));
        }
    }

    if (NT_SUCCESS(status) &&
        FsSizeInfo) {
        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              FsSizeInfo,
                                              sizeof(*FsSizeInfo),
                                              FileFsSizeInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to query file system size information with status %x\n", status));
        }
    }

    if (NT_SUCCESS(status) &&
        Label == NULL) {
        volinfo = (PFILE_FS_VOLUME_INFORMATION) vol_info_buf;

        status = NtQueryVolumeInformationFile(handle,
                                              &status_block,
                                              volinfo,
                                              vollen,
                                              FileFsVolumeInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to query volume label with status %x\n", status));
        }
    }

    if (NT_SUCCESS(status)) {

        labinfo = (PFILE_FS_LABEL_INFORMATION)lab_info_buf;

        if (Label == NULL) {
            labinfo->VolumeLabelLength = volinfo->VolumeLabelLength;
            memcpy(labinfo->VolumeLabel, volinfo->VolumeLabel, labinfo->VolumeLabelLength);
        } else {
            labinfo->VolumeLabelLength = Label->QueryChCount()*sizeof(WCHAR);
            memcpy(labinfo->VolumeLabel, Label->GetWSTR(), labinfo->VolumeLabelLength);
        }

        status = NtSetVolumeInformationFile(handle,
                                            &status_block,
                                            labinfo,
                                            lablen,
                                            FileFsLabelInformation);
        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("IFSUTIL: Unable to set volume label with status %x\n", status));
        }
    }

    NtClose(handle);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\volume.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    volume.cxx

Abstract:

    Provides volume methods.

Author:

    Mark Shavlik (marks) 13-Feb-90
    Norbert P. Kusters (norbertk) 22-Feb-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "volume.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "autoreg.hxx"
#include "ifsentry.hxx"

#if !defined(_AUTOCHECK_)
#include "path.hxx"
#endif

extern "C" {
#ifndef _AUTOCHECK_
    #include <stdio.h>
#else
    #include "ntos.h"
#endif // _AUTOCHECK_
    #include "bootreg.h"
}

DEFINE_EXPORTED_CONSTRUCTOR( VOL_LIODPDRV, LOG_IO_DP_DRIVE, IFSUTIL_EXPORT );

VOID
VOL_LIODPDRV::Construct (
    )
/*++

Routine Description:

    Constructor for VOL_LIODPDRV.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _sa = NULL;
}

IFSUTIL_EXPORT
VOL_LIODPDRV::~VOL_LIODPDRV(
    )
/*++

Routine Description:

    Destructor for VOL_LIODPDRV.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
VOL_LIODPDRV::Destroy(
    )
/*++

Routine Description:

    This routine returns a VOL_LIODPDRV to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _sa = NULL;
}


IFSUTIL_EXPORT
FORMAT_ERROR_CODE
VOL_LIODPDRV::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PSUPERAREA  SuperArea,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType,
    IN      USHORT      FormatType,
    IN      BOOLEAN     ForceDismount
    )
/*++

Routine Description:

    This routine initializes a VOL_LIODPDRV to a valid state.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    SuperArea       - Supplies the superarea for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.
    FormatType      - Supplies the file system type in the event of a format
    ForceDismount   - Supplies whether the drive should be dismounted
                        and locked 

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST               MaxSectorsInVerify = 512;

    BIG_INT             chunk;
    BIG_INT             amount_to_verify;
    BIG_INT             i;
    BIG_INT             sectors;
    ULONG               percent;

    FORMAT_ERROR_CODE   errcode;
#if !defined(RUN_ON_NT4)
    NTSTATUS            es_status;
    EXECUTION_STATE     prev_state, dummy_state;
#endif
    USHORT              format_type;

    Destroy();

    DebugAssert(NtDriveName);
    DebugAssert(SuperArea);

#if defined(FE_SB) && defined(_X86_)
    if (IsPC98_N() && MediaType) {
        format_type = DP_DRIVE::ANY;
    } else {
        format_type = QueryFormatType();
    }
#else
    {
        format_type = DP_DRIVE::NONE;   // does not matter so set it to anything will do
    }
#endif

    if (!LOG_IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite, format_type)) {
        return GeneralError;
    }

    if (!_bad_sectors.Initialize()) {
        return GeneralError;
    }

    _sa = SuperArea;

    if (FormatMedia && !IsWriteable()) {
        Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);
        Message->Display();
        return GeneralError;
    }

    if (QueryMediaType() == Unknown && MediaType == Unknown) {
        Message ? Message->DisplayMsg(MSG_DISK_NOT_FORMATTED) : 1;
        return GeneralError;
    }

    if (!FormatMedia &&
        (QueryMediaType() == Unknown ||
        (MediaType != Unknown && MediaType != QueryMediaType()))) {
        Message ? Message->DisplayMsg(MSG_CANT_QUICKFMT) : 1;
        if (Message ? Message->IsYesResponse(FALSE) : FALSE) {
            FormatMedia = TRUE;
        } else {
            return GeneralError;
        }
    }

    if (QueryMediaType() != Unknown && QuerySectors() == 0) {
        if (Message) {
            Message->DisplayMsg(MSG_FMT_INVALID_SECTOR_COUNT);
        } else {
            DebugPrint("Sectors is 0");
        }
        return GeneralError;
    }

    if (ForceDismount && !(Lock() || DismountAndLock())) {
        return LockError;
    }

    if (FormatMedia) {
        if (!Lock()) {
            return LockError;
        }

        //
        //  We make a weird exception here for the Compaq 120MB floppy,
        //  because it wants to be formatted as if it were a hard disk.
        //

        if (IsFloppy() &&
            (MediaType != F3_120M_512 &&
             MediaType != F3_200Mb_512 &&
             MediaType != F3_240M_512)) {

            BOOLEAN     rst;

#if !defined(RUN_ON_NT4)
            es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                  ES_DISPLAY_REQUIRED|
                                                  ES_SYSTEM_REQUIRED,
                                                  &prev_state);

            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
            }
#endif

            rst = FormatVerifyFloppy(MediaType, &_bad_sectors, Message);

#if !defined(RUN_ON_NT4)
            if (NT_SUCCESS(es_status)) {
                es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", es_status));
                }
            }
#endif

            if (!rst)
                return GeneralError;

        } else {

            sectors = QuerySectors();
            chunk = min( sectors/20 + 1, MaxSectorsInVerify );

            percent = 0;
            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return GeneralError;
            }

#if !defined(RUN_ON_NT4)
            es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                  ES_DISPLAY_REQUIRED|
                                                  ES_SYSTEM_REQUIRED,
                                                  &prev_state);

            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
            }
#endif


            if (IsSonyMS() && IsSonyMSFmtCmdCapable()) {

                errcode = FormatSonyG2MS(Message, sectors);

            } else {

                errcode = NoError;

                for (i = 0; i < sectors; i += chunk) {

                    if ((i.GetLowPart() & 0x3ff) == 0) {
                        if (!Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                            errcode = GeneralError;
                            break;
                        }
                    }

                    if (i*100/sectors > percent) {
                        percent = ((i*100)/sectors).GetLowPart();
                        if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                            errcode = GeneralError;
                            break;
                        }
                    }

                    amount_to_verify = min(chunk, sectors - i);

                    if (!Verify(i, amount_to_verify, &_bad_sectors)) {
                        if (Message) {
                            Message->DisplayMsg( (QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE) ?
                                                    MSG_FORMAT_NO_MEDIA_IN_DRIVE :
                                                    MSG_CHK_NO_MEMORY );
                        }
                        errcode = GeneralError;
                        break;
                    }
                }
            }


#if !defined(RUN_ON_NT4)
            if (NT_SUCCESS(es_status)) {
                es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", es_status));
                }
            }
#endif

            if (errcode != NoError)
                return errcode;

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
                return GeneralError;
            }
        }
    }

    return NoError;
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN      PSUPERAREA  SuperArea,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a VOL_LIODPDRV for a hosted
    volume, i.e. one that is implemented as a file on
    another volume.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    HostFileName    - Supplies the drive name for the host file.
    SuperArea       - Supplies the superarea for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    DebugAssert(HostFileName);
    DebugAssert(SuperArea);

    if (!LOG_IO_DP_DRIVE::Initialize(NtDriveName,
                                     HostFileName,
                                     Message,
                                     ExclusiveWrite)) {

        return FALSE;
    }

    if (!_bad_sectors.Initialize()) {
        return FALSE;
    }

    _sa = SuperArea;

    return TRUE;
}


IFSUTIL_EXPORT
FORMAT_ERROR_CODE
VOL_LIODPDRV::Format(
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       ClusterSize,
    IN      ULONG       VirtualSectors
    )
/*++

Routine Description:

    This routine formats a volume.

Arguments:

    Label   - Supplies an optional label for the volume.
    Message - Supplies an outlet for messages.
    flags   - Supplies flags to control behavior of format
    ClusterSize
            - supplies the cluster size for the volume.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return GeneralError;
    }

    if (!IsWriteable()) {
        Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);
        Message->Display();
        return GeneralError;
    }

    if (IsSystemPartition()) {
        Message->Set(MSG_FMT_SYSTEM_PARTITION_NOT_ALLOWED);
        Message->Display();
        return GeneralError;
    }

    if (!Lock()) {
        return LockError;
    }

    if (_sa->Create(&_bad_sectors,
                    Message, Label,
                    Flags,
                    ClusterSize,
                    VirtualSectors)) {

        if (!DismountAndUnlock()) {
            DebugPrintTrace(("IFSUTIL: Failed in DismountAndUnlock\n"));
            return GeneralError;
        } else {

            PWSTRING    pLabel;
            DSTRING     label;
            NTSTATUS    status;

            pLabel = NULL;
            while (!NT_SUCCESS(status = _sa->FormatNotification(pLabel))) {
                if (status == STATUS_INVALID_VOLUME_LABEL) {

                    Message->Set(MSG_INVALID_LABEL_CHARACTERS);
                    Message->Display();

                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display();
                    Message->QueryStringInput(&label);

                    pLabel = &label;
                } else {
                    return GeneralError;
                }
            }
            return NoError;
        }
    } else
        return GeneralError;
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::SetVolumeLabelAndPrintFormatReport(
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine finishes up formatting by setting the volume label and
    prints format report.

Arguments:

    Label   - Supplies an optional label for the volume.
    Message - Supplies an outlet for messages.

Note:

    If volume label is incorrect, there will be a chance for the volume
    to become unavailable and further setting of label will fail.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE     msg;
    PWSTRING    pLabel;
    DSTRING     label;
    NTSTATUS    status;

    FILE_FS_VOLUME_INFORMATION      fs_vol_info;
    PFILE_FS_VOLUME_INFORMATION     pfs_vol_info;

    FILE_FS_SIZE_INFORMATION        fs_size_info;
    PFILE_FS_SIZE_INFORMATION       pfs_size_info;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return FALSE;
    }

    if (Label && Label->QueryChCount()) {
        pLabel = (PWSTRING)Label;
    } else {
        Message->Set(MSG_VOLUME_LABEL_PROMPT);
        Message->Display();
        Message->QueryStringInput(&label);
        pLabel = &label;
    }

    if (!DismountAndUnlock()) {
        DebugPrintTrace(("IFSUTIL: Failed in DismountAndUnlock\n"));
        return FALSE;
    } else {

        pfs_vol_info = &fs_vol_info;
        pfs_size_info = &fs_size_info;

        while (!NT_SUCCESS(status = _sa->FormatNotification(pLabel,
                                                            pfs_size_info,
                                                            pfs_vol_info))) {
            pfs_size_info = NULL;
            pfs_vol_info = NULL;

            if (status == STATUS_INVALID_VOLUME_LABEL) {

                Message->Set(MSG_INVALID_LABEL_CHARACTERS);
                Message->Display();

                Message->Set(MSG_VOLUME_LABEL_PROMPT);
                Message->Display();
                Message->QueryStringInput(&label);

                pLabel = &label;
            } else {
                Message->Set(MSG_FORMAT_FAILED);
                Message->Display();
                return FALSE;
            }
        }
    }

    if (NT_SUCCESS(status)) {

        Message->Set(MSG_FORMAT_COMPLETE);
        Message->Display();

        _sa->PrintFormatReport(Message,
                               &fs_size_info,
                               &fs_vol_info);
    }

    return TRUE;
}

#if !defined(RUN_ON_NT4)
IFSUTIL_EXPORT
VOID
RestoreThreadExecutionState(
    IN      NTSTATUS        PrevStatus,
    IN      EXECUTION_STATE PrevState
    )
/*++

Routine Description:

    This routine restores the previous execution state of the thread.
    It's intended to be used as the __except expression.

Arguments:

    PrevStatus          - Supplies the status of the previous call to
                          NtSetThreadExecutionState
    PrevState           - Supplies the execution state to restore to

Return Value:

    None

--*/
{
    EXECUTION_STATE     dummy_state;

    if (NT_SUCCESS(PrevStatus)) {
        PrevStatus = NtSetThreadExecutionState(PrevState, &dummy_state);
        if (!NT_SUCCESS(PrevStatus)) {
            DebugPrintTrace(("IFSUTIL: Unable to reset thread execution state (%x)\n", PrevStatus));
        }
    }
}
#endif

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::ChkDsk(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine checks the integrity of the file system on the volume.
    If there are any problems, this routine will attempt to fix them
    to the degree specified in 'FixLevel'.

Arguments:

    FixLevel            - Supplies the level to which the volume should be fixed.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies the flags that controls the behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Tells what logfile size the user wants.
    ExitStatus          - Returns and indication of how the chkdsk went.
    DriveLetter         - For autochk, tells which drive letter we're checking.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    ULONG               exit_status;
#if !defined(RUN_ON_NT4)
    NTSTATUS            es_status;
    EXECUTION_STATE     prev_state;
#endif
    BOOLEAN             rst;

    if (!Message) {
        Message = &msg;
    }

    if (NULL == ExitStatus) {
        ExitStatus = &exit_status;
    }

    if (!_sa) {
        return FALSE;
    }

    if (FixLevel != CheckOnly && !IsWriteable()) {
        Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

#if !defined(RUN_ON_NT4)
    es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                          ES_DISPLAY_REQUIRED|
                                          ES_SYSTEM_REQUIRED,
                                          &prev_state);

    if (!NT_SUCCESS(es_status)) {
        DebugPrintTrace(("IFSUTIL: Unable to set thread execution state (%x)\n", es_status));
    }

    __try {
#endif
        rst = _sa->VerifyAndFix(FixLevel,
                                Message,
                                Flags,
                                DesiredLogFileSize,
                                Algorithm,
                                ExitStatus,
                                DriveLetter);

        RestoreThreadExecutionState(es_status, prev_state);
#if !defined(RUN_ON_NT4)
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        RestoreThreadExecutionState(es_status, prev_state);
        if (FixLevel == CheckOnly) {
            Message->DisplayMsg(MSG_CHK_NTFS_ERRORS_FOUND);
        } else {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY); // unknown error
        }
        *ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        rst = FALSE;
    }

#endif

    return rst;

}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::Recover(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine searches the named file for bad allocation units.
    It removes these allocation units from the file and marks them
    as bad in the file system.

Arguments:

    FullPathFileName    - Supplies the name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    if (!Message) {
        Message = &msg;
    }

    if (!_sa) {
        return FALSE;
    }

    return _sa->RecoverFile(FullPathFileName, Message);
}


IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::ForceAutochk(
    IN  BOOLEAN     Fix,
    IN  ULONG       Options,
    IN  ULONG       LogFileSize,
    IN  USHORT      Algorithm,
    IN  PCWSTRING   Name
    )
/*++

Routine Description:

    This method schedules Autochk to be run at next boot.  If the client
    has not requested bad sector detection or logfile resizing, this
    scheduling is done simply by marking the volume dirty.  If bad sector
    detection or logfile resizing has been requested, the appropriate entry
    is put into the registry to force autochk to run.

Arguments:

    Fix             -- Supplies if chkdsk /f is being implied.
    Options         -- Supplies flags
                          CHKDSK_RECOVER
                          CHKDSK_RESIZE_LOGFILE
                          CHKDSK_SKIP_INDEX_SCAN
                          CHKDSK_SKIP_CYCLE_SCAN
                          CHKDSK_ALGORITHM_SPECIFIED
    LogFileSize     -- If CHKDSK_RESIZE_LOGFILE, tells the desired size in bytes.
    Algorithm       -- If CHKDSK_ALGORITHM_SPECIFIED, tells the desired chunk size.
    Name            -- Supplies the volume's NT name.

Return Value:

    TRUE upon successful completion.

--*/
{
#ifndef _AUTOCHECK_

    DSTRING             CommandLine;
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             nt_drive_name;
    DSTRING             drive_path_string;
    PATH                fullpath;
    PATH                dos_path;
    PCWSTRING           name;
    PATH_ANALYZE_CODE   rst;

    if (!CommandLine.Initialize( "autocheck autochk " )) {
        return FALSE;
    }

    //
    // Let's schedule an explicit autochk.
    //

    //
    // Remove any previous entry of Name from the registry
    //

    if (!AUTOREG::DeleteEntry(&CommandLine, Name))
        return FALSE;

    //
    // Get the alternate name of the drive and remove any previous entry
    // for it from the registry
    //
    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(Name, &dos_drive_name) ||
        !dos_path.Initialize(&dos_drive_name))
        return FALSE;

    rst = dos_path.AnalyzePath(&volume_name,
                               &fullpath,
                               &drive_path_string);

    switch (rst) {
        case PATH_OK:
            DebugAssert(drive_path_string.QueryChCount() == 0);

            if (dos_path.GetPathString()->Stricmp(&volume_name) != 0) {
                // use volume_name as the alternate name
                name = &volume_name;
            } else {
                // try to use fullpath as the alternate name
                name = fullpath.GetPathString();

                if (name->QueryChCount() != 2)
                    break;  // alternate name not drive letter so done
            }

            if (!IFS_SYSTEM::DosDriveNameToNtDriveName(name, &nt_drive_name))
                return FALSE;

            if (!AUTOREG::DeleteEntry(&CommandLine, &nt_drive_name))
                return FALSE;

            break;

        default:
            return FALSE;
    }

    if (Options & CHKDSK_RECOVER) {

        DSTRING R_Option;

        if (!R_Option.Initialize( "/r " ) ||
            !CommandLine.Strcat( &R_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_SKIP_INDEX_SCAN) {

        DSTRING I_Option;

        if (!I_Option.Initialize( "/i " ) ||
            !CommandLine.Strcat( &I_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_SKIP_CYCLE_SCAN) {

        DSTRING C_Option;

        if (!C_Option.Initialize( "/c " ) ||
            !CommandLine.Strcat( &C_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_RESIZE_LOGFILE) {

        DSTRING L_Option;
        CHAR buf[20];

        sprintf(buf, "/l:%d ", LogFileSize / 1024);

        if (!L_Option.Initialize( buf ) ||
            !CommandLine.Strcat( &L_Option )) {

            return FALSE;
        }
    }

    if (Options & CHKDSK_ALGORITHM_SPECIFIED) {

        DSTRING I_Option;
        CHAR buf[20];

        sprintf(buf, "/i:%d ", Algorithm);

        if (!I_Option.Initialize( buf ) ||
            !CommandLine.Strcat( &I_Option )) {

            return FALSE;
        }
    }

    //
    // if /f specified but it's not because of /r, /i, /i:chunks, or /c, then
    // specify /p as well.  The options /r, /i, /i:chunks, or /c implies /p
    // for autochk.
    //
    if (Fix &&
        !(Options & (CHKDSK_RECOVER |
                     CHKDSK_ALGORITHM_SPECIFIED |
                     CHKDSK_SKIP_INDEX_SCAN |
                     CHKDSK_SKIP_CYCLE_SCAN))) {
        DSTRING P_Option;

        if (!P_Option.Initialize( "/p " ) ||
            !CommandLine.Strcat( &P_Option )) {

            return FALSE;
        }
    }

    return CommandLine.Strcat( Name ) &&
           AUTOREG::PushEntry( &CommandLine );
#else

    return FALSE;

#endif // _AUTOCHECK_
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::QueryAutochkTimeOut(
    OUT PULONG      TimeOut
    )
/*++

Routine Description:

    This routine returns the count down time before autochk
    resumes.

Arguments:

    TimeOut     -- Supplies the location to store the timeout value.

Return Value:

    TRUE if successful.

--*/
{
    return QueryTimeOutValue(TimeOut);
}

IFSUTIL_EXPORT
BOOLEAN
VOL_LIODPDRV::SetAutochkTimeOut(
    IN  ULONG      TimeOut
    )
/*++

Routine Description:

    This routine sets the count down time before autochk
    resumes.

Arguments:

    TimeOut     -- Supplies the count down time in seconds

Return Value:

    TRUE if successful.

--*/
{
    return SetTimeOutValue(TimeOut);
}



FORMAT_ERROR_CODE
VOL_LIODPDRV::FormatSonyG2MS(
    IN OUT PMESSAGE     Message,
    IN     BIG_INT      Sectors
    )
/*++

Routine Description:

    This routine formats a Sony Generation 2 or later Memory Stick.

Arguments:

    Message         - Supplies an outlet for messages.
    Sectors         - Supplies the number of sectors to formamt.

Return Value:

    NoError         - Success
    GeneralError    - Failure

--*/
{
    FORMAT_ERROR_CODE   errcode = NoError;

#if !defined(_AUTOCHECK_)
    if (SendSonyMSFormatCmd()) {

        SENSE_DATA      sd;
        LARGE_INTEGER   timeout = { -20000000, -1 };        // 2 seconds
        ULONG           elapsed_time = 0;
        CONST ULONG     max_elapsed_time = 100/((timeout/-10000000).GetLowPart());  // 100 seconds
        ULONG           percent = 0;
        ULONG           new_percent = 0;
        ULONG           new_percent2;
        ULONG           estimated_time;


#if DBG==1
        UCHAR           SENSE_KEY[100];
        UCHAR           ADSENSE[100];
        UCHAR           ADSENSEQ[100];
#endif

        if (IsSonyMSProgressIndicatorCapable()) {

            do {

                NtDelayExecution(FALSE, &timeout);
                elapsed_time++;

                if (!SendSonyMSRequestSenseCmd(&sd)) {
                    // error in sending Request Sense command
                    if (Message) {
                        Message->DisplayMsg(MSG_FMT_CANNOT_TALK_TO_DEVICE);
                    }
                    errcode = GeneralError;
                    break;
                }

#if DBG==1
                SENSE_KEY[elapsed_time] = sd.SenseKey;
                ADSENSE[elapsed_time] = sd.AdditionalSenseCode;
                ADSENSEQ[elapsed_time] = sd.AdditionalSenseCodeQualifier;
#endif

                // Check to see if media is present

                if (sd.SenseKey == SCSI_SENSE_NOT_READY &&
                    sd.AdditionalSenseCode == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE &&
                    sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE) {
                    // media not present error
                    if (Message) {
                        Message->DisplayMsg(MSG_FORMAT_NO_MEDIA_IN_DRIVE);
                    }
                    errcode = GeneralError;
                    break;
                }

                if (sd.SenseKey == SCSI_SENSE_NOT_READY ||
                    sd.SenseKey == SCSI_SENSE_NO_SENSE ||
                    (sd.SenseKey == SCSI_SENSE_UNIT_ATTENTION &&
                     sd.AdditionalSenseCode == SCSI_ADSENSE_MEDIUM_CHANGED &&
                     sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)) {
                    if (sd.SenseKeySpecific[0] & SENSE_DATA_SKSV_BIT) {
                        new_percent = ((sd.SenseKeySpecific[1] << 8) +
                                       sd.SenseKeySpecific[2])*100 / 65536;
                    }
                } else {
                    // unexpected SenseKey
                    DebugPrintTrace(("IFSUTIL: Unexpected sense key %x/%x/%x\n",
                                     sd.SenseKey,
                                     sd.AdditionalSenseCode,
                                     sd.AdditionalSenseCodeQualifier));
                    if (Message) {
                        Message->DisplayMsg(MSG_FORMAT_FAILED);
                    }
                    errcode = GeneralError;
                    break;
                }

                new_percent2 = (elapsed_time * 100) / (max_elapsed_time + 1);
                if (new_percent < new_percent2) {
                    // make sure the progress bar is moving
                    new_percent = new_percent2;
                }
                if (new_percent > percent) {
                    percent = new_percent;
                    if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                        errcode = GeneralError;
                        break;
                    }
                } else {
                    if (Message && !Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                        errcode = GeneralError;
                        break;
                    }
                }

            } while (sd.SenseKey != SCSI_SENSE_NO_SENSE &&
                     elapsed_time <= max_elapsed_time);

        } else {

            // estimated time for memory stick to format
            estimated_time = ((Sectors*QuerySectorSize()/1024/1024).GetLowPart()*27+530)/100/
                             (timeout/-10000000).GetLowPart();

            do {
                NtDelayExecution(FALSE, &timeout);
                elapsed_time++;

                if (!SendSonyMSTestUnitReadyCmd(&sd)) {
                    // error in sending Test Unit Ready command
                    if (Message) {
                        Message->DisplayMsg(MSG_FMT_CANNOT_TALK_TO_DEVICE);
                    }
                    errcode = GeneralError;
                    break;
                }

#if DBG==1
                SENSE_KEY[elapsed_time] = sd.SenseKey;
                ADSENSE[elapsed_time] = sd.AdditionalSenseCode;
                ADSENSEQ[elapsed_time] = sd.AdditionalSenseCodeQualifier;
#endif

                // During formatting, SenseKey should be NOT READY
                // When done with format, SenseKey should be UNIT ATTENTION or NO SENSE
                // For Gen 2 reader, it emits a MEDIUM ERROR before UNIT ATTENTION/NO SENSE

                if (!(sd.SenseKey == SCSI_SENSE_NOT_READY ||
                      sd.SenseKey == SCSI_SENSE_NO_SENSE ||
                      (sd.SenseKey == SCSI_SENSE_UNIT_ATTENTION &&
                       sd.AdditionalSenseCode == SCSI_ADSENSE_MEDIUM_CHANGED &&
                       sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE) ||
                      (sd.SenseKey == SCSI_SENSE_MEDIUM_ERROR &&
                       sd.AdditionalSenseCode == SCSI_ADSENSE_INVALID_MEDIA &&
                       sd.AdditionalSenseCodeQualifier == SCSI_SENSEQ_UNKNOWN_FORMAT))) {
                    // unexpected SenseKey
                    DebugPrintTrace(("IFSUTIL: Unexpected sense key %x/%x/%x\n",
                                     sd.SenseKey,
                                     sd.AdditionalSenseCode,
                                     sd.AdditionalSenseCodeQualifier));
                    if (Message) {
                        Message->DisplayMsg(MSG_FORMAT_FAILED);
                    }
                    errcode = GeneralError;
                    break;
                }

                if (elapsed_time <= estimated_time) {
                    new_percent = (elapsed_time * 70 / estimated_time); // 0-70%
                } else {
                    // if it exceeded the estimate time, then spread the remaining time
                    // over the last 30 percent.
                    new_percent = 70 + (elapsed_time-estimated_time)*30 /
                                       (max_elapsed_time - estimated_time + 1); // 70-100%
                }

                if (new_percent > percent) {
                    percent = new_percent;
                    if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                        errcode = GeneralError;
                        break;
                    }
                } else {
                    if (Message && !Message->DisplayMsg(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0)) {
                        errcode = GeneralError;
                        break;
                    }
                }
            } while (sd.SenseKey != SCSI_SENSE_NO_SENSE &&
                     elapsed_time <= max_elapsed_time);
        }

        if (elapsed_time > max_elapsed_time) {
            if (Message) {
                Message->DisplayMsg(MSG_FMT_TIMEOUT);
            }
            errcode = GeneralError;
        }

    } else {
        if (Message) {
            Message->DisplayMsg(MSG_FMT_CANNOT_TALK_TO_DEVICE);
        }
        errcode = GeneralError;
    }
#endif
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\smsdtect.cxx ===
/*++

Copyright (c) 1992-2001 Microsoft Corporation

Module Name:

    smsdtect.cxx

Abstract:

    This module contains routines that used to detect
    if the device is a Sony Memory Stick and what kind of
    capability it has.

Author:

    Daniel Chan (danielch) 21 Feb, 2001

Environment:

    Ulib, User Mode

Note:

    These routines should be grouped into a class and
    instantiated through one of the DRIVE class.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "drive.hxx"

#if !defined(_AUTOCHECK_)

extern "C" {
#include <stdio.h>
#include <ntdddisk.h>
#include <initguid.h>
#include <diskguid.h>
#include <setupapi.h>
#include <cfgmgr32.h>
};

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    SENSE_DATA          SenseData;
    UCHAR               DataBuffer[1];
    // Allocate buffer space after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;

NTSTATUS
SendCdbToDevice(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN      PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
    IN      BOOLEAN     GetDataFromDevice,
       OUT  PSENSE_DATA SenseInfo,
       OUT  PUCHAR      ScsiStatus
    );

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSFormatCmd(
    )
/*++

Routine Description:

    This routine sends a Sony Generation 2 Memory Stick format command.

Arguments:

    N/A

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    UCHAR   FmtCmd[12] = { 0xFA,    // OP Code
                           0x0B,    // LUN/Reserved
                           0xA0,    // Sub OP Code
                           'M',
                           'G',
                           'f',
                           'm',
                           't',
                           0x00,    // Reserved
                           0x00,    // Reserved
                           0x00,    // Reserved
                           0x00     // Reserved
                         };

    DWORD   buffer_size = 0;
    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)FmtCmd,
                                   sizeof(FmtCmd),
                                   NULL,
                                   &buffer_size,
                                   FALSE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) && scsi_status != SCSISTAT_GOOD) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSModeSenseCmd(
       OUT PSONY_MS_MODE_SENSE_DATA ModeSenseData
    )
/*++

Routine Description:

    This routine sends a Sony Memory Stick Mode Sense command.

Arguments:

    ModeSenseData - Returns the mode sense data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD                       buffer_size = sizeof(SONY_MS_MODE_SENSE_DATA);
    UCHAR   ModeSenseCmd[12] = { SCSIOP_MODE_SENSE10,    // OP Code
                                 0x00,    // LUN/Reserved
                                 0x20,    // PC/PageCode
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Parameter List Length (MSB)
                                 (UCHAR)buffer_size, // Parameter List Length (LSB)
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                 0x00,    // Reserved
                                };
    UCHAR                       scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)ModeSenseCmd,
                                   sizeof(ModeSenseCmd),
                                   (PUCHAR)ModeSenseData,
                                   &buffer_size,
                                   TRUE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) && scsi_status != SCSISTAT_GOOD) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSRequestSenseCmd(
       OUT PSENSE_DATA  SenseInfo
    )
/*++

Routine Description:

    This routine sends a Sony Memory Stick Request Sense command.

Arguments:

    SenseInfo - Returns the sense info data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD   buffer_size = sizeof(SENSE_DATA);
    UCHAR   RequestSenseCmd[12] = { SCSIOP_REQUEST_SENSE,
                                    0x00,    // LUN/Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    (UCHAR)buffer_size,    // Allocation Length
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00,    // Reserved
                                    0x00     // Reserved
                                  };

    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)&RequestSenseCmd,
                                   sizeof(RequestSenseCmd),
                                   (PUCHAR)SenseInfo,
                                   &buffer_size,
                                   TRUE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) &&
        (scsi_status != SCSISTAT_GOOD &&
         scsi_status != SCSISTAT_CHECK_CONDITION)) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSInquiryCmd(
    PSONY_MS_INQUIRY_DATA       InquiryData
    )
/*++

Routine Description:

    This routine sends Sony Memory Stick Inquiry command.

Arguments:

    InquiryData - Returns the inquiry data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD   buffer_size = sizeof(SONY_MS_INQUIRY_DATA);
    UCHAR   InquiryCmd[12] = { SCSIOP_INQUIRY,
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               (UCHAR)buffer_size,  // Allocation Length
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00,    // Reserved
                               0x00     // Reserved
                             };
    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)InquiryCmd,
                                   sizeof(InquiryCmd),
                                   (PUCHAR)InquiryData,
                                   &buffer_size,
                                   TRUE,
                                   NULL,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) && scsi_status != SCSISTAT_GOOD) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::SendSonyMSTestUnitReadyCmd(
       OUT PSENSE_DATA  SenseInfo
    )
/*++

Routine Description:

    This routine sends Sony Memory Stick Test Unit Ready command.

Arguments:

    SenseInfo - Returns the sense info data

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    UCHAR   TestUnitReadyCmd[12] = { SCSIOP_TEST_UNIT_READY,
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00,  // Reserved
                                     0x00   // Reserved
                                   };
    DWORD   buffer_size = 0;
    UCHAR   scsi_status;

    _last_status = SendCdbToDevice(_handle,
                                   (PCDB)TestUnitReadyCmd,
                                   sizeof(TestUnitReadyCmd),
                                   NULL,
                                   &buffer_size,
                                   FALSE,
                                   SenseInfo,
                                   &scsi_status);

    if (NT_SUCCESS(_last_status) &&
        (scsi_status != SCSISTAT_GOOD &&
         scsi_status != SCSISTAT_CHECK_CONDITION)) {
        _last_status = STATUS_UNSUCCESSFUL;
    }

    return (BOOLEAN) NT_SUCCESS(_last_status);
}

NTSTATUS
SendCdbToDevice(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN      PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
    IN      BOOLEAN     GetDataFromDevice,
       OUT  PSENSE_DATA SenseInfo,
       OUT  PUCHAR      ScsiStatus
    )
/*++

Routine Description:

    This routine sends/receives SCSI pass through commands.

Arguments:

    DeviceHandle    -
    Cdb             - Supplies the command data block
    CdbSize         - Supplies the size of the command data block
    Buffer          - Supplies and receives the data in and out
    BufferSize      - Supplies the size of the buffer
    GetDataFromDevice - Supplies TRUE if data is needed from device; otherwise, FALSE
    SenseInfo       - Retrieves the sense info data
    ScsiStatus      - Retrieves the scsi status

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSPT_WITH_BUFFERS   p;
    DWORD               packetSize;
    NTSTATUS            status;
    IO_STATUS_BLOCK     status_block;

    if (Cdb == NULL) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Cdb is NULL\n");
        return STATUS_INVALID_PARAMETER;
    }

    if (CdbSize < 1 || CdbSize > 16) {
        DebugPrintTrace(("IFSUTIL: SendDdbToDevice: Cdb size (0x%x) too large/small\n", CdbSize));
        return STATUS_INVALID_PARAMETER;
    }

    if (BufferSize == NULL) {
        DebugPrint("IFSUTIL: SendDdbToDevice: BufferSize pointer cannot be NULL\n");
        return STATUS_INVALID_PARAMETER;
    }

    if ((*BufferSize != 0) && (Buffer == NULL)) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Buffer cannot be NULL if *BufferSize is non-zero\n");
        return STATUS_INVALID_PARAMETER;
    }

    if ((*BufferSize == 0) && (Buffer != NULL)) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Buffer must be NULL if *BufferSize is zero\n");
        return STATUS_INVALID_PARAMETER;
    }

    if ((*BufferSize) && GetDataFromDevice) {

        //
        // pre-zero output buffer (not input buffer)
        //

        memset(Buffer, 0, (*BufferSize));
    }

    packetSize = sizeof(SPT_WITH_BUFFERS) + (*BufferSize);
    p = (PSPT_WITH_BUFFERS)MALLOC(packetSize);
    if (p == NULL) {
        DebugPrint("IFSUTIL: SendDdbToDevice: Could not allocate memory for pass-through\n");
        return STATUS_NO_MEMORY;
    }

    //
    // this has the side effect of pre-zeroing the output buffer
    // if DataIn is TRUE
    //
    memset(p, 0, packetSize);
    memcpy(p->Spt.Cdb, Cdb, CdbSize);

    p->Spt.Length             = sizeof(SCSI_PASS_THROUGH);
    p->Spt.CdbLength          = CdbSize;
    p->Spt.SenseInfoLength    = sizeof(p->SenseData);
    p->Spt.DataIn             = (GetDataFromDevice ? 1 : 0);
    p->Spt.DataTransferLength = (*BufferSize);
    p->Spt.TimeOutValue       = 10;     // ten seconds
    p->Spt.SenseInfoOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, SenseData);
    p->Spt.DataBufferOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, DataBuffer[0]);

    if ((*BufferSize != 0) && (!GetDataFromDevice)) {

        //
        // if we're sending the device data, copy the user's buffer
        //
        RtlCopyMemory(&(p->DataBuffer[0]), Buffer, *BufferSize);

    }

    status = NtDeviceIoControlFile(DeviceHandle,
                                   0,
                                   NULL,
                                   NULL,
                                   &status_block,
                                   IOCTL_SCSI_PASS_THROUGH,
                                   p,
                                   packetSize,
                                   p,
                                   packetSize);

    if (!NT_SUCCESS(status)) {

        DebugPrintTrace(("IFSUTIL: SendDdbToDevice: "
                         "Error sending command %x with status %x and scsi status %x\n",
                         p->Spt.Cdb[0], status, p->Spt.ScsiStatus));

    } else if (GetDataFromDevice) {

        //
        // upon successful completion of a command getting data from the
        // device, copy the returned data back to the user.
        //

        if (*BufferSize >= p->Spt.DataTransferLength) {
            *BufferSize = p->Spt.DataTransferLength;
        } else {
            DebugPrintTrace(("IFSUTIL: SendDdbToDevice: "
                             "DataTransferLength (%x) exceeded buffer size (%x)\n",
                             p->Spt.DataTransferLength,
                             *BufferSize));
            status = STATUS_BUFFER_OVERFLOW;
        }
        memcpy(Buffer, p->DataBuffer, *BufferSize);

    }

    if (ScsiStatus) {
        *ScsiStatus = p->Spt.ScsiStatus;
    }

    if (SenseInfo) {
        *SenseInfo = p->SenseData;
    }

    //
    // free our memory and return
    //

    FREE(p);

    return status;
}

#define MAX_DEVICEID        200
#define MAX_PNPID           MAX_PATH
#define MAX_PNPINSTID       MAX_PATH
#define MAX_KEY             200

BOOLEAN
GetDeviceIDDiskFromDeviceIDVolume(
    IN     LPWSTR   pszNtVolumeName,
       OUT LPWSTR   pszDeviceIDDisk,
    IN     DWORD    cchDeviceIDDisk
    )
/*++

Routine Description:

    This routine retrieves the device id string from the volume name.

Arguments:

    pszNtVolumeName - Supplies the volume name of the device
    pszDeviceIDDisk - Retrieves the device id string
    cchDeviceIDDisk - Supplies the maximum length of the device id string

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    const GUID guidVolumeClass = {0x53f5630d, 0xb6bf, 0x11d0,
                                  {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

    HMACHINE    hMachine = NULL;
    ULONG       ulSize;
    ULONG       ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;
    CONFIGRET   cr;
    PWCHAR      pszDeviceInterface;
    ULONG       devnum;
    DEVICE_TYPE devtype;
    BOOLEAN     bRemovable;

    cr = CM_Get_Device_Interface_List_Size_Ex(
             &ulSize,
             (GUID*)&guidVolumeClass,
             NULL,
             ulFlags,
             hMachine);

    if (CR_SUCCESS != cr || ulSize <= 1) {
        DebugPrintTrace(("IFSUTIL: CM_Get_Device_Interface_List_Size_Ex1 failed %x\n", cr));
        return FALSE;
    }

    pszDeviceInterface = (PWCHAR)MALLOC(ulSize*sizeof(WCHAR));

    if (NULL == pszDeviceInterface) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    cr = CM_Get_Device_Interface_List_Ex(
             (GUID*)&guidVolumeClass,
              NULL,
             pszDeviceInterface,
             ulSize,
             ulFlags,
             hMachine);

    if (CR_SUCCESS != cr) {
        DebugPrintTrace(("IFSUTIL: CM_Get_Device_Interface_List_Size_Ex2 failed %x\n", cr));
        FREE(pszDeviceInterface);
        return FALSE;
    }

    PWCHAR  psz = pszDeviceInterface;
    WCHAR   saveChar;
    ULONG   len;
    DSTRING dos_name, nt_name, backslash;
    BOOLEAN result = FALSE;

    if (!nt_name.Initialize(pszNtVolumeName)) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(&nt_name, &dos_name)) {
        DebugPrintTrace(("IFSUTIL: NtDriveNameToDosDriveName failed\n"));
        return FALSE;
    }

    if (!backslash.Initialize(TEXT("\\")) ||
        !dos_name.Strcat(&backslash)) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    if (!GetVolumeNameForVolumeMountPoint(dos_name.GetWSTR(), pszDeviceIDDisk, cchDeviceIDDisk)) {
        DebugPrintTrace(("IFSUTIL: GetVolumeNameForVolumeMountPoint %ls failed %d\n",
                         dos_name.GetWSTR(), GetLastError()));
        return FALSE;
    }

    if (!dos_name.Initialize(pszDeviceIDDisk)) {
        DebugPrintTrace(("IFSUTIL: Out of memory.\n"));
        return FALSE;
    }

    do {

        // append a blackslash

        len = lstrlen(psz);
        psz[len] = '\\';
        saveChar = psz[len+1];
        psz[len+1] = 0;

        if (!GetVolumeNameForVolumeMountPoint(psz, pszDeviceIDDisk, cchDeviceIDDisk)) {
            DebugPrintTrace(("IFSUTIL: GetVolumeNameForVolumeMountPoint %ls failed %d\n",
                             psz, GetLastError()));
            break;
        }

        if (_wcsicmp(pszDeviceIDDisk, dos_name.GetWSTR()) == 0) {
            psz[len] = 0;
            if (len < cchDeviceIDDisk) {
                wcscpy(pszDeviceIDDisk, psz);
                result = TRUE;
            } else {
                DebugPrintTrace(("IFSUTIL: GetDeviceIDDiskFromDeviceIDVolume failed\n"
                                 "IFSUTIL: Output string too short.  Needed %d.  Actual %d\n",
                                 len+1, cchDeviceIDDisk));
            }
            break;
        }

        psz[len+1] = saveChar;
        psz = psz + len + 1;

    } while (*psz);

    FREE(pszDeviceInterface);
    return result;
}

BOOLEAN
GetDeviceInstance(
    IN     LPCWSTR     pszDeviceIntfID,
       OUT DEVINST*    pdevinst
    )
/*++

Routine Description:

    This routine returns the device instance based on the device interface ID.

Arguments:

    pszDeviceIntfID - Supplies device interface id
    pdevinst        - Retrieves the device instance

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    BOOLEAN     result = FALSE;
    HDEVINFO    hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pdevinst = NULL;

    if (INVALID_HANDLE_VALUE != hdevinfo) {

        SP_DEVICE_INTERFACE_DATA sdid = {0};

        sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceIntfID, 0, &sdid)) {

            DWORD           cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                                      (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

            SP_DEVINFO_DATA sdd = {0};

            SP_DEVICE_INTERFACE_DETAIL_DATA*    psdidd;

            psdidd = (SP_DEVICE_INTERFACE_DETAIL_DATA*)MALLOC(cbsdidd);

            if (psdidd) {

                memset(psdidd, 0, cbsdidd);

                psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                // SetupDiGetDeviceInterfaceDetail (below) requires that the
                // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                // to the size of the fixed part of the structure, and to pass
                // the size of the full thing as the 4th param.

                if (SetupDiGetDeviceInterfaceDetail(hdevinfo,
                                                    &sdid,
                                                    psdidd,
                                                    cbsdidd,
                                                    NULL,
                                                    &sdd)) {
                    *pdevinst = sdd.DevInst;
                    result = TRUE;

                } else {
                    DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to get device interface (%d)\n",
                                     GetLastError()));
                }

                FREE(psdidd);

            } else {
                DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Out of memory\n"));
            }
        } else {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to open device interface (%d)\n",
                             GetLastError()));
        }

        if (!SetupDiDestroyDeviceInfoList(hdevinfo)) {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to destroy device info list (%d)\n",
                             GetLastError()));
        }
    } else {
        DebugPrintTrace(("IFSUTIL: GetDeviceInstance: Unable to create device info list (%d)\n",
                         GetLastError()));
    }

    return result;
}

BOOLEAN
DeviceInstIsRemovable(
    IN     DEVINST     devinst,
       OUT PBOOLEAN    pfRemovable
    )
/*++

Routine Description:

    This routine checks to see if the given device instance is removable.

Arguments:

    devinst      - Supplies the device instance
    pfRemovable  - Receives TRUE if the device is removable

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD dwCap;
    DWORD cbCap = sizeof(dwCap);

    CONFIGRET cr;

    cr = CM_Get_DevNode_Registry_Property_Ex(
            devinst,
            CM_DRP_CAPABILITIES,
            NULL,
            &dwCap,
            &cbCap,
            0,
            NULL);

    if (CR_SUCCESS == cr) {
        *pfRemovable = (CM_DEVCAP_REMOVABLE & dwCap) ? TRUE : FALSE;
    } else {
        *pfRemovable = FALSE;
    }

    return TRUE;
}

BOOLEAN
GetRemovableDeviceInstRecurs(
    IN     DEVINST     devinst,
       OUT DEVINST*    pdevinst
    )
/*++

Routine Description:

    This routine recursively goes up the device chain to locate the
    correct device instance.

Arguments:

    devinst      - Supplies the initial device instance
    pdevinst     - Retrieves the correct device instance

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    BOOLEAN fRemovable;
    BOOLEAN result = DeviceInstIsRemovable(devinst, &fRemovable);

    if (result)
    {
        if (fRemovable)
        {
            // Found it!
            *pdevinst = devinst;
        }
        else
        {
            // Recurse
            DEVINST devinstParent;

            CONFIGRET cr;

            cr = CM_Get_Parent_Ex(&devinstParent,
                                  devinst,
                                  0,
                                  NULL);

            if (CR_SUCCESS == cr)
            {
                result = GetRemovableDeviceInstRecurs(devinstParent, pdevinst);
            }
            else
            {
                result = FALSE;
            }
        }
    }

    return result;
}

BOOLEAN
FindPnpInstID(
    IN OUT LPWSTR pszPnpID,
       OUT LPWSTR pszPnpInstId,
    IN     ULONG  cchPnpInstId
    )
/*++

Routine Description:

    This routine scans thru the given PNP Id string and splits it up into just
    PNP Id and PNP Instance Id.

Arguments:

    pszPnpID     - Supplies the PNP Id string
    pszPnpInstID - Supplies the PNP Instance Id string
    cchPnpInstId - Supplies the maximum length of the PNP Instance Id string

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    DWORD cToFind = 2;
    LPWSTR psz = pszPnpID;

    if (cchPnpInstId) {
        pszPnpInstId[0] = 0;
    }

    while (*psz && cToFind) {

        if ((TEXT('\\') == *psz)) {
            --cToFind;
        }

        if (cToFind) {
            ++psz;
        }
    }

    if (*psz) {
        *psz = 0;
        psz++;
        wcsncpy(pszPnpInstId, psz, cchPnpInstId);
    }

    return TRUE;
}

BOOLEAN
GetPropertyHelper(
    IN     LPCWSTR pszKey,
    IN     LPCWSTR pszPropName,
       OUT PBYTE pbData,
    IN     DWORD cbData
    )
/*++

Routine Description:

    This routine opens the given registry key and retrieves the value of the property name.

Arguments:

    pszKey       - Supplies the registry key
    pszPropName  - Supplies the property name
    pbData       - Supplies the data buffer to store the value associated with the
                   property name
    cbData       - Supplies the maximum length of the data buffer

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    HKEY    hkey;
    LONG    errcode;

    errcode = RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

    if (ERROR_SUCCESS != errcode) {
        return FALSE;
    }

    errcode =RegQueryValueEx(hkey, pszPropName, 0, NULL, pbData, &cbData);

    if (ERROR_SUCCESS != errcode) {
        RegCloseKey(hkey);
        return FALSE;
    }

    errcode = RegCloseKey(hkey);

    if (ERROR_SUCCESS != errcode) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SetupDiGetDeviceExtendedProperty(
    IN     LPCWSTR pszPnpID,
    IN     LPCWSTR pszPnpInstID,
    IN     LPCWSTR pszPropName,
    DWORD /*dwFlags*/,
    DWORD /*dwType*/,
       OUT PBYTE pbData,
    IN     DWORD cbData
    )
/*++

Routine Description:

    This routine goes thru the registry entries and return the value of the property name
    for the given PNP Id & PNP Instance Id.

Arguments:

    pszPnpID     - Supplies the PNP Id string
    pszPnpInstID - Supplies the PNP Instance Id string
    pszPropName  - Supplies the property name
    pbData       - Supplies the data buffer to store the value associated with the
                   property name
    cbData       - Supplies the maximum length of the data buffer

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
    ULONG   ulLength;
    ULONG   temp;
    WCHAR   szKey[MAX_KEY];
    PWCHAR  psz = TEXT("System\\CurrentControlSet\\Enum\\");
    PWCHAR  pszDevParm = TEXT("\\Device Parameters");

    // Temporary fct to use while PnP team writes the real one
    //
    // First we look under the DeviceNode for the value and if not there
    // we go to the "database".
    //
    //

    ulLength = wcslen(psz) +
               wcslen(pszPnpID) +
               1 +
               wcslen(pszPnpInstID) +
               wcslen(pszDevParm) +
               1;

    if (ulLength <= MAX_KEY) {
        wcscpy(szKey, psz);
        wcscat(szKey, pszPnpID);
        wcscat(szKey, TEXT("\\"));
        wcscat(szKey, pszPnpInstID);
        wcscat(szKey, pszDevParm);

        if (GetPropertyHelper(szKey, pszPropName, pbData, cbData)) {
            return TRUE;
        }
    }

    psz = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\DeviceStorage\\");
    temp = wcslen(psz);
    ulLength = temp + wcslen(pszPnpID) + 1;

    if (ulLength <= MAX_KEY) {
        wcscpy(szKey, psz);
        psz = szKey + temp;
        wcscat(szKey, pszPnpID);

        while (*psz) {
            if (TEXT('\\') == *psz) {
                *psz = TEXT('#');
            }
            ++psz;
        }

        if (GetPropertyHelper(szKey, pszPropName, pbData, cbData)) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif

BOOLEAN
DP_DRIVE::CheckSonyMS()
/*++

Routine Description:

    This routine determines if the given device is a Sony Memory Stick.

Arguments:

    N/A

Return Value:

    FALSE   - Failure
    TRUE    - Success

--*/
{
#if !defined(_AUTOCHECK_)
    IO_STATUS_BLOCK             status_block;
    STORAGE_DEVICE_NUMBER       device_info;
    BYTE                        bData[30];
    DWORD                       cbData = sizeof(bData);
    PBYTE                       pbData = bData;
    HMACHINE                    hMachine = NULL;
    CONFIGRET                   cr;
    WCHAR                       szDeviceIDDisk[MAX_DEVICEID];
    WCHAR                       szVolumeName[MAX_PATH];
    DEVINST                     devinstDisk;
    DEVINST                     devinstHWDevice;
    WCHAR                       szPnpID[MAX_PNPID];
    WCHAR                       szPnpInstID[MAX_PNPINSTID];
    ULONG                       cchPnpID = sizeof(szPnpID)/sizeof(szPnpID[0]);
    ULONG                       cchPnpInstID = sizeof(szPnpInstID)/sizeof(szPnpInstID[0]);
    

    // first get device interface

    if (!GetDeviceIDDiskFromDeviceIDVolume((LPWSTR)GetNtDriveName()->GetWSTR(),
                                           szDeviceIDDisk,
                                           sizeof(szDeviceIDDisk)/sizeof(szDeviceIDDisk[0]))) {
        DebugPrintTrace(("IFSUTIL: GetDeviceIDDiskFromDeviceIDVolume failed\n"));
        return FALSE;
    }

    // now get device number

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &status_block,
                                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                         NULL, 0, &device_info,
                                         sizeof(STORAGE_DEVICE_NUMBER));

    if (NT_SUCCESS(_last_status)) {

        if (device_info.DeviceType != FILE_DEVICE_DISK) {
            return TRUE;    // cannot be a memory stick
        }

        if (!GetDeviceInstance(szDeviceIDDisk, &devinstDisk)) {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance failed\n"));
            return FALSE;
        }

        /* ------------------------------------------------------------------------
        This has been commented out since if there is a removable device in the 
        chain which is not a memory stick then this will not be able to identify 
        a possible memory stick further up the chain 
        
        
        if (!GetRemovableDeviceInstRecurs(devinstDisk, &devinstHWDevice)) {
        
            DebugPrintTrace(("IFSUTIL: GetRemovableDeviceInstRecurs finds no parent\n"));

            // may be it's a non-removable reader
            // try to go up one level at a time and
            // see if we can find a match
        
          
            for (;;) {

                cr = CM_Get_Parent_Ex(&devinstHWDevice,
                                      devinstDisk,
                                      0,
                                      NULL);

                if (CR_SUCCESS != cr) {
                    DebugPrintTrace(("IFSUTIL: Unable to retrieve device parent\n"));
                    return FALSE;
                }

                cbData = sizeof(bData);

                cr = CM_Get_DevNode_Custom_Property(devinstHWDevice,
                                                    TEXT("DeviceGroup"),
                                                    NULL,
                                                    pbData,
                                                    &cbData,
                                                    NULL);

                if (CR_NO_SUCH_VALUE == cr) {
                    devinstDisk = devinstHWDevice;  // up one level
                    continue;                       // and try again
                }

                if (CR_SUCCESS != cr) {
                    DebugPrintTrace(("IFSUTIL: CM_Get_DevNode_Custom_Property (%x)\n", cr));
                    return FALSE;
                }

                if (_wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK")) == 0 ||
                    _wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK-MG")) == 0) {
                    _sony_ms = TRUE;
                    return TRUE;
                }

                devinstDisk = devinstHWDevice;  // up one level
            }
        }
        ------------------------------------------------------------------------*/

        // may be it's a non-removable reader
        // try to go up one level at a time and
        // see if we can find a match
        // once we reach the root and still do not find a memory stick 
        // we exit
        
        for (;;) {
            cbData = sizeof(bData);

            cr = CM_Get_DevNode_Custom_Property(devinstDisk,
                                                TEXT("DeviceGroup"),
                                                NULL,
                                                pbData,
                                                &cbData,
                                                NULL);

            if (CR_NO_SUCH_VALUE != cr) {
                // Check for failure or success     
                if (CR_SUCCESS != cr) {
                    DebugPrintTrace(("IFSUTIL: CM_Get_DevNode_Custom_Property (%x)\n", cr));
                    return FALSE;
                } else {
                    if (_wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK")) == 0 ||
                        _wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK-MG")) == 0) {
                        _sony_ms = TRUE;
                        return TRUE;
                    }
                }
            }

            // up one level and try again
            cr = CM_Get_Parent_Ex(&devinstHWDevice,
                                      devinstDisk,
                                      0,
                                      NULL);

            if (CR_SUCCESS != cr) {
                // if can't find parent, end search for mem stick
                DebugPrintTrace(("IFSUTIL: Unable to retrieve device parent\n"));
                return FALSE;
            } else {
                devinstDisk = devinstHWDevice;
            }
            
        }
        
        DebugAssert(FALSE); // should never get here
    
    } else {

        if (!GetDeviceInstance(szDeviceIDDisk, &devinstHWDevice)) {
            DebugPrintTrace(("IFSUTIL: GetDeviceInstance failed\n"));
            return FALSE;
        }
    }

    cr = CM_Get_DevNode_Custom_Property(devinstHWDevice,
                                        TEXT("DeviceGroup"),
                                        NULL,
                                        pbData,
                                        &cbData,
                                        NULL);

    if (CR_SUCCESS != cr) {
        DebugPrintTrace(("IFSUTIL: CM_Get_DevNode_Custom_Property (%x)\n", cr));
        return FALSE;
    }

    if (_wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK")) == 0 ||
        _wcsicmp((PWCHAR)pbData, TEXT("MEMORYSTICK-MG")) == 0) {
        _sony_ms = TRUE;
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\tlink.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

extern "C" {
    #include <stdio.h>
}

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "tlink.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( TLINK, OBJECT, IFSUTIL_EXPORT );

VOID
TLINK::Construct (
        )
/*++

Routine Description:

    Constructor for TLINK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _array = NULL;
    _size = _maxSize = 0;
}

VOID
TLINK::Destroy(
    )
/*++

Routine Description:

    This routine returns the TLINK to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_array);
    _array = NULL;
    _size = _maxSize = 0;
}

IFSUTIL_EXPORT
TLINK::~TLINK(
    )
/*++

Routine Description:

    Destructor for TLINK.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
TLINK::Initialize(
    IN  USHORT  Size
    )
/*++

Routine Description:

    This routine initializes the triple link list for insertion.

Arguments:

    Size    - Supplies the maximum number of elements that will be in the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();
    if ((_array = (PBIG_INT_NODE)MALLOC((Size+2)*sizeof(BIG_INT_NODE))) == NULL)
        return FALSE;
    _maxSize = Size;
    _array[0].prev = NULL;
    _array[0].next = &(_array[1]);
    _array[0].buffer = NULL;
    return TRUE;
}

RBIG_INT
TLINK::GetNextDataSlot(
)
/*++

Routine Description:

    This routine returns a reference to the next available data slot.

NOTE:

    USER IS RESPONSIBLE FOR NOT ACCESSING BEYOND THE BOUNDARY OF THE LINK LIST.

Arguments:

    None.

Return Value:

    A reference to the BIG_INT of the next available slot in the link list.

--*/
{
    PBIG_INT_NODE   pArray;

    DebugAssert(_size < _maxSize);

    pArray = _array + ++_size;

    pArray->buffer = NULL;
    pArray->next = pArray+1;
    pArray->prev = pArray-1;
    return pArray->data;
}


NONVIRTUAL
IFSUTIL_EXPORT
PVOID
TLINK::QueryDisjointRangeAndAssignBuffer(
    OUT PBIG_INT        Start,
    OUT PUSHORT         Length,
    OUT PUSHORT         EffectiveLength,
    IN  PVOID           Buffer,
    IN  ULONG           DataSize,
    IN  PVOID           Pnode
)
/*++

Routine Description:

    This routine returns the start and length of a disjoint set starting at the
    given node.  It also assigns the appropriate buffer address to the
    corresponding data node.

Arguments:

    Start       - receives the first data value in given Pnode.
    Length      - receives the number of elements in the disjoint range.
    EffectiveLength
                - receives the number of distinct elements in the disjoint range.
    Buffer      - supplies the start address of the buffer for the given Pnode.
    DataSize    - supplies the length of the buffer for each node.
    Pnode       - supplies the first node in the disjoint range

Return Value:

    Points to the first node after the disjoint range

--*/
{
    BIG_INT next_data_value;
    PCHAR   dataPtr;

    DebugPtrAssert(Pnode);
    DebugPtrAssert(Start);
    DebugPtrAssert(Length);
    DebugPtrAssert(EffectiveLength);
    DebugPtrAssert(Buffer);

    dataPtr = (PCHAR)Buffer;

    *Length = 0;
    *EffectiveLength = 1;
    *Start = ((PBIG_INT_NODE)Pnode)->data;
    next_data_value = *Start + 1;
    ((PBIG_INT_NODE)Pnode)->buffer = Buffer;
    Pnode = ((PBIG_INT_NODE)Pnode)+1;

    for (;;) {
        if ((((PBIG_INT_NODE)Pnode)-1)->data == ((PBIG_INT_NODE)Pnode)->data) {
            ((PBIG_INT_NODE)Pnode)->buffer = dataPtr;
            (*Length)++;
            Pnode = ((PBIG_INT_NODE)Pnode)+1;
        } else if (next_data_value == ((PBIG_INT_NODE)Pnode)->data) {
            next_data_value += 1;
            (*EffectiveLength)++;
            dataPtr += DataSize;
            ((PBIG_INT_NODE)Pnode)->buffer = dataPtr;
            Pnode = ((PBIG_INT_NODE)Pnode)+1;
        } else
            break;
    }
    *Length += *EffectiveLength;
    return Pnode;
}

#if DBG == 1
IFSUTIL_EXPORT
void
TLINK::TraverseLinkList(
    )
/*++

Routine Description:

    This routine prints the link list in sorted, initial forward, and initial
    reverse orders.

Arguments:

Return Value:

    N/A

--*/
{
#if 0
    USHORT          i;
    PBIG_INT_NODE   pNode;

    printf("Sorted order:\n");
    for (i=1; i<=_size; i++) {
        printf("[%d]=%x ", i, _array[i].data.GetLowPart());
    }
    printf("\n");

    printf("Initial forward order:\n");
    pNode = _array->next;
    i=1;
    while (i <= _size) {
        printf("[%d]=%x ", i++, pNode->data.GetLowPart());
        pNode = pNode->next;
    }
    printf("\n");

    printf("Initial reverse order:\n");
    pNode = _array[_size+1].prev;
    i=_size;
    while (i > 0) {
        printf("[%d]=%x ", i--, pNode->data.GetLowPart());
        pNode = pNode->prev;
    }
    printf("\n");
#endif
}

IFSUTIL_EXPORT
void
TLINK::CheckLinkList(
    )
/*++

Routine Description:

    This routine checks the link list to make sure it is sorted
    correctly.

Arguments:

Return Value:

    N/A

--*/
{
    USHORT  i;

    for (i=1; i<_size; i++) {
        DebugAssert(_array[i].data <= _array[i+1].data);
    }
}
#endif

IFSUTIL_EXPORT
void
TLINK::ShellSort(
    )
/*++

Routine Description:

    This routine sorts the given list using quick sort algorithm.

Arguments:

    pHeadRec        - supplies the first node in the link list.
    pTailRec        - supplies the last node in the link list.

Return Value:

    N/A

--*/
{
    USHORT          i, incr;
    INT             j;
    BIG_INT         tmp;
    PBIG_INT_NODE   pLeft, pRight, lPrev, lNext, rPrev, rNext;

    incr = _size / 2;
    while (incr > 0) {
        for (i=incr+1; i<=_size; i++) {
            j = i - incr;
            while (j > 0) {
                if (_array[j].data > _array[j+incr].data) {

                    pLeft = _array+j;
                    pRight = _array+j+incr;

                    tmp = pLeft->data;
                    pLeft->data = pRight->data;
                    pRight->data = tmp;

                    lPrev = pLeft->prev;
                    lNext = pLeft->next;
                    rPrev = pRight->prev;
                    rNext = pRight->next;

                    if (pLeft == rPrev) {
                        DebugAssert(lNext == pRight);
                        lPrev->next = pLeft->prev = pRight;
                        pRight->next = rNext->prev = pLeft;

                        pRight->prev = lPrev;
                        pLeft->next = rNext;
                    } else if (pRight == lPrev) {
                        DebugAssert(pLeft == rNext);
                        rPrev->next = pRight->prev = pLeft;
                        pLeft->next = lNext->prev = pRight;

                        pLeft->prev = rPrev;
                        pRight->next = lNext;
                    } else {
                        lPrev->next = lNext->prev = pRight;
                        pRight->prev = lPrev;
                        pRight->next = lNext;

                        rPrev->next = rNext->prev = pLeft;
                        pLeft->prev = rPrev;
                        pLeft->next = rNext;
                    }
                    j -= incr;
                } else
                    break;
            }
        }
        incr /= 2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ifsutil\src\secrun.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "error.hxx"
#include "secrun.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( SECRUN, OBJECT, IFSUTIL_EXPORT );


VOID
SECRUN::Construct (
        )

/*++

Routine Description:

    Constructor for class SECRUN.  This function initializes the
    member variables to "dummy" states.  The member function 'Init'
    must be called to make this class "work".

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _drive = NULL;
    _start_sector = 0;
    _num_sectors = 0;
}


VOID
SECRUN::Destroy(
    )
/*++

Routine Description:

    This routine puts the object back into its initial and empty state.
    It is not necessary to call this function between calls to 'Init'
    as Init will call this function automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _drive = NULL;
    _start_sector = 0;
    _num_sectors = 0;
}


IFSUTIL_EXPORT
SECRUN::~SECRUN(
    )
/*++

Routine Description:

    Destructor of sector run object.  Returns references.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Initialize(
    IN OUT  PMEM            Mem,
    IN OUT  PIO_DP_DRIVE    Drive,
    IN      BIG_INT         StartSector,
    IN      SECTORCOUNT     NumSectors
    )
/*++

Routine Description:

    This member function initializes the class so that reads and writes
    may take place.

Arguments:

    Mem                 - Supplies means by which to acquire sufficient memory.
    Drive               - Supplies drive interface.
    StartSector         - Supplies starting LBN.
    NumSector           - Supplies the number of LBNs.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    ULONG   size;

    Destroy();

    DebugAssert(Drive);
    DebugAssert(Mem);

    _drive = Drive;
    _start_sector = StartSector;
    _num_sectors = NumSectors;
    size = _num_sectors*_drive->QuerySectorSize();
    _buf = Mem->Acquire(size, _drive->QueryAlignmentMask());

    if (!size || !_buf) {
        return FALSE;
    }

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Read(
    )
/*++

Routine Description:

    This member function reads the sectors on disk into memory.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(_buf);
    return _drive->Read(_start_sector, _num_sectors, _buf);
}


IFSUTIL_EXPORT
BOOLEAN
SECRUN::Write(
    )
/*++

Routine Description:

    This member function writes onto the disk.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(_buf);
    return _drive->Write(_start_sector, _num_sectors, _buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\label\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1
TARGETNAME=label
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\label.cxx ..\label.rc

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
       ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
       $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\com.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    Com

Abstract:

    Takes care of request involving a COM device

Author:

    Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/



#include "mode.hxx"
#include "com.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "file.hxx"
#include "path.hxx"
#include "registry.hxx"
#include "regvalue.hxx"


#define     DEFAULT_PARITY      COMM_PARITY_EVEN
#define     DEFAULT_DATA_BITS   7




//
//  Local prototypes
//
BOOLEAN
ComStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
ComSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
IsAValidCommDevice (
    IN  DEVICE_TTYPE     DeviceType,
    IN  ULONG           DeviceNumber,
    OUT PPATH           *DevicePathPointer
    );






BOOLEAN
ComAllocateStuff(
    )

/*++

Routine Description:

    Initializes Data Structures used for COMM processing.

Arguments:

    nonde

Return Value:

    BOOLEAN -   TRUE if global data initialized, FALSE otherwise

Notes:

--*/

{

    return TRUE;

}

BOOLEAN
ComDeAllocateStuff(
    )

/*++

Routine Description:

    Deallocates the stuff allocated by ComAllocateStuff.

Arguments:

    nonde

Return Value:

    BOOLEAN -   TRUE if global data de-initialized, FALSE otherwise

Notes:

--*/

{

    return TRUE;

}

BOOLEAN
ComHandler(
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Handles serial port requests.

Arguments:

    Request -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if request serviced,
                FALSE otherwise.

Notes:

--*/

{


    PPATH   DevicePath;     //  Name of Device
    BOOLEAN Served = TRUE;  //  TRUE if request served OK.

    DebugPtrAssert( Request );
    DebugAssert( Request->DeviceType == DEVICE_TYPE_COM );

    //
    //  Make sure that the device exists, and at the same time get its
    //  name ( For calling APIs ).
    //
    if ( Request->DeviceName ) {

        if (!(DevicePath = NEW PATH)) {
            DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                   NULL,
                                   (ULONG)EXIT_ERROR );
            return FALSE;   // help lint
        }
        DevicePath->Initialize( Request->DeviceName );

    } else {

        if ( !IsAValidCommDevice( Request->DeviceType, Request->DeviceNumber, &DevicePath )) {

            DisplayMessageAndExit( MODE_ERROR_INVALID_DEVICE_NAME,
                                   DevicePath->GetPathString(),
                                   (ULONG)EXIT_ERROR );

        } else if ( !IsAValidDevice( Request->DeviceType, Request->DeviceNumber, NULL  ) ) {

            DisplayMessageAndExit( MODE_ERROR_DEVICE_UNAVAILABLE,
                                   DevicePath->GetPathString(),
                                   (ULONG)EXIT_ERROR );

        }
    }

    //
    //  So the device is valid. Now serve the request
    //
    switch( Request->RequestType ) {

    case REQUEST_TYPE_STATUS:

        //
        //  Display state of COM device
        //
        Served = ComStatus( DevicePath, Request );
        break;

    case REQUEST_TYPE_COM_SET:

        //
        //  Set state of COM device
        //
        Served = ComSetup( DevicePath, Request );
        break;

    default:

        DebugAssert( FALSE );

    }

    DELETE( DevicePath );

    return Served;

}

BOOLEAN
ComStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Displays status if a COM device

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if status displayed successfully,
                FALSE otherwise

Notes:

--*/

{
    DSTRING                 Data;
    COMM_DEVICE             CommDevice;     //  Comm object of the device.
    BOOLEAN                 OpenError;
    BOOLEAN                 Status;

    DebugPtrAssert( DevicePath );
    DebugPtrAssert( Request );

    //
    //  Initialize the Comm object
    //
    Status = CommDevice.Initialize( DevicePath, &OpenError);


    if ( Status ) {

        //
        //  Write the Header
        //
        WriteStatusHeader( DevicePath );


        //
        //  Baud rate
        //
        Data.Initialize( (ULONG)CommDevice.QueryBaudRate() );
        DisplayMessage( MODE_MESSAGE_STATUS_BAUD, &Data );


        //
        //  Parity
        //
        switch ( CommDevice.QueryParity() ) {

        case COMM_PARITY_NONE:
            Data.Initialize( "None" );
            break;

        case COMM_PARITY_ODD:
            Data.Initialize( "Odd" );
            break;

        case COMM_PARITY_EVEN:
            Data.Initialize( "Even" );
            break;

        case COMM_PARITY_MARK:
            Data.Initialize( "Mark" );
            break;

        case COMM_PARITY_SPACE:
            Data.Initialize( "Space" );
            break;

        default:
            DebugAssert( FALSE );
        }

        DisplayMessage( MODE_MESSAGE_STATUS_PARITY, &Data );


        //
        //  Data bits
        //
        Data.Initialize( (ULONG)CommDevice.QueryDataBits() );
        DisplayMessage( MODE_MESSAGE_STATUS_DATA, &Data );


        //
        //  Stop bits
        //
        switch ( CommDevice.QueryStopBits() ) {

        case COMM_STOPBITS_15:
            Data.Initialize( "1.5" );
            break;

        case COMM_STOPBITS_1:
            Data.Initialize( 1 );
            break;

        case COMM_STOPBITS_2:
            Data.Initialize( 2 );
            break;

        default:
            DebugAssert( FALSE );
        }

        DisplayMessage( MODE_MESSAGE_STATUS_STOP, &Data );


        //
        //  TimeOut
        //
        if ( CommDevice.QueryTimeOut() ) {
            //
            //  TRUE means infinite timeout == no timeout
            //
            Data.Initialize( "OFF" );
        } else {
            Data.Initialize( "ON" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_TIMEOUT, &Data );


        //
        //  XON/XOFF
        //
        if ( CommDevice.QueryXon() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_XON, &Data );


        //
        //  CTS
        //
        if ( CommDevice.QueryOcts() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_OCTS, &Data );

        //
        //  DSR handshaking
        //
        if ( CommDevice.QueryOdsr() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_ODSR, &Data );

        //
        //  DSR sensitivity
        //
        if ( CommDevice.QueryIdsr() ) {
            Data.Initialize( "ON" );
        } else {
            Data.Initialize( "OFF" );
        }
        DisplayMessage( MODE_MESSAGE_STATUS_IDSR, &Data );

        //
        //  DTR
        //
        switch( CommDevice.QueryDtrControl() ) {

        case DTR_ENABLE:
            Data.Initialize( "ON" );
            break;

        case DTR_DISABLE:
            Data.Initialize( "OFF" );
            break;

        case DTR_HANDSHAKE:
            Data.Initialize( "HANDSHAKE" );
            break;

        default:
            Data.Initialize( "UNKNOWN" );
            break;

        }
        DisplayMessage( MODE_MESSAGE_STATUS_DTR, &Data );


        //
        //  RTS
        //
        switch( CommDevice.QueryRtsControl() ) {

        case RTS_ENABLE:
            Data.Initialize( "ON" );
            break;

        case RTS_DISABLE:
            Data.Initialize( "OFF" );
            break;

        case RTS_HANDSHAKE:
            Data.Initialize( "HANDSHAKE" );
            break;

        case RTS_TOGGLE:
            Data.Initialize( "TOGGLE" );
            break;

        default:
            Data.Initialize( "UNKNOWN" );
            break;

        }
        DisplayMessage( MODE_MESSAGE_STATUS_RTS, &Data );

        Get_Standard_Output_Stream()->WriteChar( '\r' );
        Get_Standard_Output_Stream()->WriteChar( '\n' );

    } else if ( !OpenError ) {

        DisplayMessage( MODE_ERROR_CANNOT_ACCESS_DEVICE,
                        DevicePath->GetPathString() );

        Status = TRUE;
    }

    return Status;
}



BOOLEAN
ComSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Sets the state of a COM port

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if state set successfully,
                FALSE otherwise

Notes:

--*/

{

    PCOMM_DEVICE            CommDevice;     //  Comm object of the device.
    BOOLEAN                 Status = FALSE; //  Indicates success or failure
    PREQUEST_DATA_COM_SET   Data;           //  Request data
    BOOLEAN                 OpenError;
    DSTRING                 Number;

    DebugPtrAssert( DevicePath );
    DebugPtrAssert( Request );

    //
    //  Initialize the Comm object
    //
    CommDevice = NEW COMM_DEVICE;
    if ( !CommDevice ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
        return FALSE;   // help lint
    }
    Status = CommDevice->Initialize( DevicePath, &OpenError );
    if ( Status ) {

        //
        //  We have the Comm object. Set the state according to
        //  the request.
        //
        Data = &(((PCOM_REQUEST)Request)->Data.Set);

        //
        //  Baud rate
        //
        if ( Data->SetBaud ) {

            CommDevice->SetBaudRate( Data->Baud );

        }

        //
        //  Data Bits
        //
        if ( Data->SetDataBits ) {

            CommDevice->SetDataBits( Data->DataBits );

        } else {

            //
            //  Set default
            //
            if ( CommDevice->QueryDataBits() != DEFAULT_DATA_BITS ) {
                CommDevice->SetDataBits( DEFAULT_DATA_BITS );
                Number.Initialize( DEFAULT_DATA_BITS );
                DisplayMessage( MODE_MESSAGE_USED_DEFAULT_DATA, &Number );
            }
        }

        //
        //  Stop Bits
        //
        if ( Data->SetStopBits ) {

            CommDevice->SetStopBits( Data->StopBits );

        } else {

            //
            //  Set default
            //
            if ( CommDevice->QueryBaudRate() == 110 ) {
                if ( CommDevice->QueryStopBits() != COMM_STOPBITS_2 ) {
                    CommDevice->SetStopBits( COMM_STOPBITS_2 );
                    Number.Initialize( 2 );
                    DisplayMessage( MODE_MESSAGE_USED_DEFAULT_STOP, &Number );
                }
            } else {
                if ( CommDevice->QueryStopBits() != COMM_STOPBITS_1 ) {
                    CommDevice->SetStopBits( COMM_STOPBITS_1 );
                    Number.Initialize( 1 );
                    DisplayMessage( MODE_MESSAGE_USED_DEFAULT_STOP, &Number );
                }
            }
        }

        //
        //  Parity
        //
        if ( Data->SetParity ) {

            CommDevice->SetParity( Data->Parity );

        } else {

            //
            //  Set default
            //
            if ( CommDevice->QueryParity() != DEFAULT_PARITY ) {
                CommDevice->SetParity( DEFAULT_PARITY );
                DisplayMessage( MODE_MESSAGE_USED_DEFAULT_PARITY, NULL );
            }
        }

        //
        //  Timeout
        //
        if ( Data->SetTimeOut ) {

            CommDevice->SetTimeOut( Data->TimeOut );

        }


        //
        //  XON/XOFF
        //
        if ( Data->SetXon) {

            CommDevice->SetXon( Data->Xon );

        }


        //
        //  CTS
        //
        if ( Data->SetOcts ) {

            CommDevice->SetOcts( Data->Octs );
        }

        //
        //  DSR handshaking
        //
        if ( Data->SetOdsr ) {

            CommDevice->SetOdsr( Data->Odsr );
        }

        //
        //  DSR sensitivity
        //
        if ( Data->SetIdsr ) {

            CommDevice->SetIdsr( Data->Idsr );
        }

        //
        //  DTR
        //
        if ( Data->SetDtrControl ) {

            CommDevice->SetDtrControl( Data->DtrControl );
        }

        //
        //  RTS
        //
        if ( Data->SetRtsControl ) {

            CommDevice->SetRtsControl( Data->RtsControl );
        }

        //
        //  Now Commit the changes
        //
        if ( !CommDevice->CommitState() ) {

            DisplayMessage( MODE_ERROR_SERIAL_OPTIONS_NOT_SUPPORTED, NULL );
            DisplayMessageAndExit( MODE_MESSAGE_COM_NO_CHANGE,
                                   NULL,
                                   (ULONG)EXIT_ERROR );
        }

    } else if ( !OpenError ) {

        DisplayMessageAndExit( MODE_ERROR_CANNOT_ACCESS_DEVICE,
                               DevicePath->GetPathString(),
                               (ULONG)EXIT_ERROR );
    }

    DELETE( CommDevice );

    if ( Status ) {
        //
        //  Display the status of the port (as confirmation ).
        //
        ComStatus( DevicePath, Request );

    }

    return Status;
}


LONG
ConvertBaudRate (
    IN  LONG                BaudIn
    )

/*++

Routine Description:

    Validates a baud rate given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    BaudIn      -   Supplies the baud rate given by the user

Return Value:

    LONG    -   The baud rate


--*/

{
    LONG    BaudRate;

    switch ( BaudIn ) {

    case 11:
    case 110:
        BaudRate = 110;
        break;

    case 15:
    case 150:
        BaudRate = 150;
        break;

    case 30:
    case 300:
        BaudRate = 300;
        break;

    case 60:
    case 600:
        BaudRate = 600;
        break;

    case 12:
    case 1200:
        BaudRate = 1200;
        break;

    case 24:
    case 2400:
        BaudRate = 2400;
        break;

    case 48:
    case 4800:
        BaudRate = 4800;
        break;

    case 96:
    case 9600:
        BaudRate = 9600;
        break;

    case 19:
    case 19200:
        BaudRate = 19200;
        break;

    default:
        BaudRate = BaudIn;

    }

    return BaudRate;
}


LONG
ConvertDataBits (
    IN  LONG                DataBitsIn
    )

/*++

Routine Description:

    Validates the number of data bits given as an argument to the program,
    and converts  it to something that the COMM_DEVICE understands.

Arguments:

    DataBitsIn  -   Supplies the number given by the user

Return Value:

    LONG    -   The number of data bits


--*/

{

    if ( ( DataBitsIn != 5 ) &&
         ( DataBitsIn != 6 ) &&
         ( DataBitsIn != 7 ) &&
         ( DataBitsIn != 8 ) ) {

        ParseError();

    }

    return DataBitsIn;

}


STOPBITS
ConvertStopBits (
    IN  LONG                StopBitsIn
    )

/*++

Routine Description:

    Validates a number  of stop bits given as an argument to the program,
    and converts it to something that the COMM_DEVICE understands.

Arguments:

    StopBitsIn  -   Supplies the number given by the user

Return Value:

    STOPBITS    -   The number of stop bits


--*/

{
    STOPBITS    StopBits;

    switch ( StopBitsIn ) {

    case 1:
        StopBits = COMM_STOPBITS_1;
        break;

    case 2:
        StopBits = COMM_STOPBITS_2;
        break;

    default:
        ParseError();

    }

    return StopBits;

}


PARITY
ConvertParity (
    IN  WCHAR   ParityIn
    )

/*++

Routine Description:

    Validates a parity given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    ParityIn    -   Supplies the baud rate given by the user

Return Value:

    PARITY  -   The parity


--*/

{

    DSTRING     ParityString;;
    WCHAR       Par;
    PARITY      Parity;

    //
    //  Get the character that specifies parity. We lowercase it
    //
    ParityString.Initialize( " " );
    ParityString.SetChAt( ParityIn, 0 );

    ParityString.Strlwr();
    Par = ParityString.QueryChAt( 0 );

    //
    //  Set the correct parity value depending on the character.
    //
    switch ( Par ) {

    case 'n':
        Parity = COMM_PARITY_NONE;
        break;

    case 'o':
        Parity = COMM_PARITY_ODD;
        break;

    case 'e':
        Parity = COMM_PARITY_EVEN;
        break;

    case 'm':
        Parity = COMM_PARITY_MARK;
        break;

    case 's':
        Parity = COMM_PARITY_SPACE;
        break;

    default:
        ParseError();

    }

    return Parity;
}


WCHAR
ConvertRetry (
    IN  WCHAR   RetryIn
    )

/*++

Routine Description:

    Validates a retry value given as an argument to the program, and
    converts it to something that the COMM_DEVICE understands.

Arguments:

    RetryIn     -   Supplies the retry  value given by the user

Return Value:

    WCHAR   -   The retry value


--*/

{
    return RetryIn;

}



DTR_CONTROL
ConvertDtrControl (
    IN  PCWSTRING           CmdLine,
    IN  CHNUM               IdxBegin,
    IN  CHNUM               IdxEnd
    )

/*++

Routine Description:

    Validates a DTR control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    CmdLine     -   Supplies the command line
    IdxBegin    -   Supplies Index of first character
    IdxEnd      -   Supplies Index of last character

Return Value:

    DTR_CONTROL -   The DTR control value


--*/

{
    DSTRING On;
    DSTRING Off;
    DSTRING Hs;


    if ( On.Initialize( "ON" )      &&
         Off.Initialize( "OFF" )    &&
         Hs.Initialize( "HS" ) ) {


        if ( !CmdLine->Stricmp( &On,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                On.QueryChCount() ) ) {

            return DTR_ENABLE;
        }

        if ( !CmdLine->Stricmp( &Off,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Off.QueryChCount() ) ) {

            return DTR_DISABLE;
        }

        if ( !CmdLine->Stricmp( &Hs,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Hs.QueryChCount() ) ) {

            return DTR_HANDSHAKE;
        }
    }

    ParseError();

    return (DTR_CONTROL)-1;
}



RTS_CONTROL
ConvertRtsControl (
    IN  PCWSTRING           CmdLine,
    IN  CHNUM               IdxBegin,
    IN  CHNUM               IdxEnd
    )

/*++

Routine Description:

    Validates a RTS control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    CmdLine     -   Supplies the command line
    IdxBegin    -   Supplies Index of first character
    IdxEnd      -   Supplies Index of last character

Return Value:

    RTS_CONTROL -   The RTS control value


--*/

{
    DSTRING On;
    DSTRING Off;
    DSTRING Hs;
    DSTRING Tg;


    if ( On.Initialize( "ON" )      &&
         Off.Initialize( "OFF" )    &&
         Hs.Initialize( "HS" )      &&
         Tg.Initialize( "TG" )
       ) {


        if ( !CmdLine->Stricmp( &On,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                On.QueryChCount() ) ) {

            return RTS_ENABLE;
        }

        if ( !CmdLine->Stricmp( &Off,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Off.QueryChCount() ) ) {

            return RTS_DISABLE;
        }

        if ( !CmdLine->Stricmp( &Hs,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Hs.QueryChCount() ) ) {

            return RTS_HANDSHAKE;
        }

        if ( !CmdLine->Stricmp( &Tg,
                                IdxBegin,
                                IdxEnd-IdxBegin+1,
                                0,
                                Tg.QueryChCount() ) ) {

            return RTS_TOGGLE;
        }
    }

    ParseError();

    return (RTS_CONTROL)-1;
}




BOOLEAN
IsAValidCommDevice (
    IN  DEVICE_TTYPE    DeviceType,
    IN  ULONG           DeviceNumber,
    OUT PPATH           *DevicePathPointer
    )

/*++

Routine Description:

    Determines if a certain comm device exists and optionally
    creates a path for it.

Arguments:

    DeviceType      -   Supplies the type of device
    DeviceNumber    -   Supplies the device number
    DeviceName      -   Supplies a pointer to a pointer to the path for
                        the device.

Return Value:

    BOOLEAN -   TRUE if the device exists,
                FALSE otherwise.

Notes:

--*/

{
    DSTRING                 DeviceName;
    DSTRING                 Number;
    BOOLEAN                 Valid = FALSE;
    REGISTRY                Registry;
    DSTRING                 ParentName;
    DSTRING                 KeyName;
    ARRAY                   ValueArray;
    PARRAY_ITERATOR         Iterator;
    ULONG                   ErrorCode;
    PCBYTE                  Data;
    DSTRING                 PortName;
    PREGISTRY_VALUE_ENTRY   Value;


    UNREFERENCED_PARAMETER( DeviceType );


    if ( DeviceName.Initialize( (LPWSTR)L"COM" )&&
         Number.Initialize( DeviceNumber )      &&
         DeviceName.Strcat( &Number )           &&
         ParentName.Initialize( "" )            &&
         KeyName.Initialize( COMM_KEY_NAME )    &&
         ValueArray.Initialize()                &&
         Registry.Initialize()
       ) {


        //
        //  Get the names of all the serial ports
        //
        if ( Registry.QueryValues(
                        PREDEFINED_KEY_LOCAL_MACHINE,
                        &ParentName,
                        &KeyName,
                        &ValueArray,
                        &ErrorCode
                        ) ) {

            //
            //  See if the given name matches any of the serial ports
            //
            if ( Iterator = (PARRAY_ITERATOR)ValueArray.QueryIterator() ) {

                while ( Value = (PREGISTRY_VALUE_ENTRY)(Iterator->GetNext() ) ) {

                    if ( Value->GetData( &Data ) ) {

                        if ( PortName.Initialize( (PWSTR)Data ) ) {

                            if ( !DeviceName.Stricmp( &PortName ) ) {

                                Valid = TRUE;

                                break;
                            }
                        }
                    }
                }

                DELETE( Iterator );
            }
        }

        if ( DevicePathPointer ) {

            if (!(*DevicePathPointer = NEW PATH)) {
                DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                       NULL,
                                       (ULONG)EXIT_ERROR );
                return FALSE;   // help lint
            }
            (*DevicePathPointer)->Initialize( &DeviceName );
        }

    }

    return Valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\cons.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Con

Abstract:

	Takes care of request involving the console ( CON: )

Author:

	Ramon Juan San Andres (ramonsa) 26-Jun-1991

Notes:

	This module issues direct calls to USER, because having ULIB doing
	so causes programs to crash.

Revision History:

--*/


#include "mode.hxx"
#include "cons.hxx"
#include "keyboard.hxx"
#include "path.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "system.hxx"

//
//	Local prototypes
//
BOOLEAN
ConStatus(
	IN	PREQUEST_HEADER	Request,
	IN	BOOLEAN 		JustCodePage
	);

BOOLEAN
ConCodePage(
	IN	PREQUEST_HEADER	Request
	);

BOOLEAN
ConSetRowCol(
	IN	PREQUEST_HEADER	Request
	);

BOOLEAN
ConSetTypematic(
	IN	PREQUEST_HEADER	Request
	);




BOOLEAN
ConHandler(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Handles console requests

Arguments:

	Request -	Supplies pointer to request

Return Value:

    None.

Notes:

--*/

{

	BOOLEAN Served = TRUE;	//	TRUE if request served OK.

	DebugPtrAssert( Request );
	DebugAssert( Request->DeviceType == DEVICE_TYPE_CON );

	//
	//	So the device is valid. Now serve the request
	//
	switch( Request->RequestType ) {

	case REQUEST_TYPE_STATUS:

		//
		//	Display state of CON device
		//
		Served = ConStatus( Request, FALSE );
		break;

	case REQUEST_TYPE_CODEPAGE_PREPARE:
	case REQUEST_TYPE_CODEPAGE_SELECT:
	case REQUEST_TYPE_CODEPAGE_REFRESH:

		//
		//	Handle Codepage requests
		//
		Served = ConCodePage( Request );
		break;

	case REQUEST_TYPE_CODEPAGE_STATUS:

		//
		//	Display codepage status
		//
		Served = ConStatus( Request, TRUE );
		break;

	case REQUEST_TYPE_CON_SET_ROWCOL:

		//
		//	Set rows & columns
		//
		Served = ConSetRowCol( Request );
		break;

	case REQUEST_TYPE_CON_SET_TYPEMATIC:

		//
		//	Set typematic rate
		//
		Served = ConSetTypematic( Request );
		break;

	default:

        DisplayMessageAndExit( MODE_ERROR_INVALID_PARAMETER,
							   NULL,
							   (ULONG)EXIT_ERROR );

	}

	return Served;


}

BOOLEAN
ConStatus(
	IN	PREQUEST_HEADER	Request,
	IN	BOOLEAN 		JustCodePage
	)

/*++

Routine Description:

	Displays status of a console

Arguments:

	Request 	-	Supplies pointer to request
	JustCodePage-	Supplies a flag which if TRUE means that only
					the codepage status should be displayed.

Return Value:

	BOOLEAN -	TRUE if status displayed successfully,
				FALSE otherwise

Notes:

--*/

{

	SCREEN		Screen;

	PATH		ConPath;

	USHORT		Rows;
	USHORT		Cols;

	ULONG		Delay = 0;
	ULONG		Speed = 0;

    DSTRING     CodepageName;

	ULONG		Language;
	ULONG		Country;
	ULONG		Codepage;

    DSTRING     CodepageString;
	PSTR		S1, S2;


    if ( !ConPath.Initialize( (LPWSTR)L"CON" ) ) {
		DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
	}

	//
	//	Write the Header
	//
	WriteStatusHeader( &ConPath );

   if ( !Screen.Initialize() ) {
      DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
   }

	if ( !JustCodePage ) {

		//
		//	Display non-codepage information
		//

		Screen.QueryScreenSize( &Rows, &Cols );

		Message->Set( MODE_MESSAGE_STATUS_LINES );
		Message->Display( "%d", Rows );

		Message->Set( MODE_MESSAGE_STATUS_COLS );
		Message->Display( "%d", Cols	);

		if (!SystemParametersInfo( SPI_GETKEYBOARDSPEED, 0, (PVOID)&Speed, 0 )) {
			ExitWithError( GetLastError() );
		}
		Message->Set( MODE_MESSAGE_STATUS_RATE );
		Message->Display( "%d", Speed );

		if (!SystemParametersInfo( SPI_GETKEYBOARDDELAY, 0, (PVOID)&Delay, 0 )) {
			ExitWithError( GetLastError() );
		}

		Message->Set( MODE_MESSAGE_STATUS_DELAY );
		Message->Display( "%d", Delay );


    }

    Message->Set( MODE_MESSAGE_STATUS_CODEPAGE );
    Message->Display( "%d", Screen.QueryCodePage( ) );

	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );

	return TRUE;
}

BOOLEAN
ConCodePage(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Handles Codepage requests for the console

Arguments:

	Request 	-	Supplies pointer to request

Return Value:

	BOOLEAN -	TRUE if request handled successfully,
				FALSE otherwise

Notes:

--*/

{
    SCREEN                              Screen;
    PREQUEST_DATA_CON_CODEPAGE_SELECT   Data;


    //
    //  We only process Codepage Select requests, all other requests
    //  are No-Ops. Note that the Codepage Status request is not
    //  processed here.
    //
    if ( Request->RequestType == REQUEST_TYPE_CODEPAGE_SELECT ) {

        Data = (PREQUEST_DATA_CON_CODEPAGE_SELECT)&(((PCON_REQUEST)Request)->
                        Data.CpSelect);

        if ( !Screen.Initialize() ) {
            DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
        }

        if ( !Screen.SetCodePage( Data->Codepage ) ||
             !Screen.SetOutputCodePage( Data->Codepage) ) {
            DisplayMessageAndExit( MODE_ERROR_INVALID_CODEPAGE, NULL, (ULONG)EXIT_ERROR );
        }

#ifdef FE_SB
        LANGID LangId;

        switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
        }

        SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
#endif

        ConStatus( Request, FALSE );

    } else {

        DisplayMessageAndExit( MODE_MESSAGE_NOT_NEEDED, NULL, EXIT_SUCCESS );
    }

	return TRUE;
}

BOOLEAN
ConSetRowCol(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Sets number of rows and columns in the console window.


Arguments:

	Request 	-	Supplies pointer to request

Return Value:

	BOOLEAN -	TRUE if Number of Rows & Columns set successfully,
				FALSE otherwise

Notes:

--*/

{

	PREQUEST_DATA_CON_ROWCOL	Data;

	SCREEN			Screen;

	USHORT			Rows;
    USHORT          Cols;
    BOOLEAN         IsFullScreen;


	DebugPtrAssert( Request);

	Data = (PREQUEST_DATA_CON_ROWCOL)&(((PCON_REQUEST)Request)->Data.RowCol);

    if ( !Screen.Initialize() ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
    }

	if ( !Data->SetCol || !Data->SetLines ) {

		//
		//	Since we don't have both values, take the current ones.
		//
		Screen.QueryScreenSize( &Rows, &Cols );
	}

	//
	//	Set the number of rows and columns
	//
	if ( Data->SetCol ) {

		Cols = (USHORT)Data->Col;

	}

	if ( Data->SetLines ) {

		Rows = (USHORT)Data->Lines;

	}

    if ( !Screen.ChangeScreenSize( Rows, Cols, &IsFullScreen ) ) {

		//
		//	Cannot change the screen size
        //
        if ( IsFullScreen ) {
            DisplayMessageAndExit( MODE_ERROR_FULL_SCREEN, NULL, (ULONG)EXIT_ERROR );
        } else {
            DisplayMessageAndExit( MODE_ERROR_INVALID_SCREEN_SIZE, NULL, (ULONG)EXIT_ERROR );
        }
	}

	return TRUE;
}

BOOLEAN
ConSetTypematic(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Sets thje typematic rate

Arguments:

	DevicePath	-	Supplies pointer to path of device
	Request 	-	Supplies pointer to request

Return Value:

	BOOLEAN -	TRUE if typematic rate set successfully,
				FALSE otherwise

Notes:

--*/

{
	PREQUEST_DATA_CON_TYPEMATIC		Data;

	DebugPtrAssert( Request);


	Data = (PREQUEST_DATA_CON_TYPEMATIC)&(((PCON_REQUEST)Request)->Data.Typematic);

	if ( Data->SetRate ) {
		if (!SystemParametersInfo( SPI_SETKEYBOARDSPEED, (UINT)Data->Rate, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE )) {
			DisplayMessageAndExit( MODE_ERROR_INVALID_RATE, NULL, (ULONG)EXIT_ERROR);
		}
	}
	if ( Data->SetDelay ) {
		if (!SystemParametersInfo( SPI_SETKEYBOARDDELAY, (UINT)Data->Delay, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE )) {
			DisplayMessageAndExit( MODE_ERROR_INVALID_DELAY, NULL, (ULONG)EXIT_ERROR);
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\lpt.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    Lpt

Abstract:

    Takes care of request involving an LPT device

Author:

    Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/


#define _NTAPI_ULIB_

#include "mode.hxx"
#include "lpt.hxx"
#include "file.hxx"
#include "path.hxx"
#include "stream.hxx"
#include "redir.hxx"
#include "registry.hxx"
#include "regvalue.hxx"
#include "array.hxx"
#include "arrayit.hxx"

//
//  When an LPT port is set, mode only sends it an EPSON/IBM sequence.
//  The following macros define the EPSON sequences used.
//
#define     CODE_ESCAPE     0x27
#define     CODE_COLS_80    0x18
#define     CODE_COLS_132   0x15
#define     CODE_LINES_6    '2'
#define     CODE_LINES_8    '0'

#undef      LAST_COM
#define     LAST_COM        4


//
//  Local prototypes
//
BOOLEAN
LptStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptCodePage(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptRedirect(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

BOOLEAN
LptEndRedir(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    );

PPATH
GetRedirection(
    IN  PCPATH          DevicePath,
    OUT PREDIR_STATUS   RedirStatus
    );



BOOLEAN
IsAValidLptDevice (
    IN  DEVICE_TTYPE    DeviceType,
    IN  ULONG           DeviceNumber,
    OUT PPATH           *DevicePathPointer
    )

/*++

Routine Description:

    Determines if a certain comm device exists and optionally
    creates a path for it.

Arguments:

    DeviceType      -   Supplies the type of device
    DeviceNumber    -   Supplies the device number
    DeviceName      -   Supplies a pointer to a pointer to the path for
                        the device.

Return Value:

    BOOLEAN -   TRUE if the device exists,
                FALSE otherwise.

Notes:

--*/

{
    DSTRING                 DeviceName;
    DSTRING                 AlternateName;
    DSTRING                 Number;
    BOOLEAN                 Valid = FALSE;
    REGISTRY                Registry;
    DSTRING                 ParentName;
    DSTRING                 KeyName;
    ARRAY                   ValueArray;
    PARRAY_ITERATOR         Iterator;
    ULONG                   ErrorCode;
    PCBYTE                  Data;
    DSTRING                 PortName;
    PREGISTRY_VALUE_ENTRY   Value;


    UNREFERENCED_PARAMETER( DeviceType );


    if ( DeviceName.Initialize( (LPWSTR)L"LPT" )&&
         Number.Initialize( DeviceNumber )      &&
         DeviceName.Strcat( &Number )           &&
         AlternateName.Initialize( (LPWSTR)L"\\DosDevices\\" ) &&
         AlternateName.Strcat( &DeviceName )    &&
         ParentName.Initialize( "" )            &&
         KeyName.Initialize( LPT_KEY_NAME )     &&
         ValueArray.Initialize()                &&
         Registry.Initialize()
       ) {


        //
        //  Get the names of all the serial ports
        //
        if ( Registry.QueryValues(
                        PREDEFINED_KEY_LOCAL_MACHINE,
                        &ParentName,
                        &KeyName,
                        &ValueArray,
                        &ErrorCode
                        ) ) {

            //
            //  See if the given name matches any of the serial ports
            //
            if ( Iterator = (PARRAY_ITERATOR)ValueArray.QueryIterator() ) {

                while ( Value = (PREGISTRY_VALUE_ENTRY)(Iterator->GetNext() ) ) {

                    if ( Value->GetData( &Data ) ) {

                        if ( PortName.Initialize( (PWSTR)Data ) ) {

                            if ( !DeviceName.Stricmp( &PortName ) ||
                                 !AlternateName.Stricmp( &PortName ) ) {

                                Valid = TRUE;

                                break;
                            }
                        }
                    }
                }

                DELETE( Iterator );
            }
        }

        if ( DevicePathPointer ) {

            if (!(*DevicePathPointer = NEW PATH)) {
                DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                       NULL,
                                       (ULONG)EXIT_ERROR );
                return FALSE;   // help lint
            }
            (*DevicePathPointer)->Initialize( &DeviceName );
        }

    }

    return Valid;
}






BOOLEAN
LptHandler(
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Handles LPT requests

Arguments:

    Request -   Supplies pointer to request

Return Value:

    None.

Notes:

--*/

{
    PPATH           DevicePath;     //  Name of Device
    BOOLEAN         Served = TRUE;  //  TRUE if request served OK.
    REDIR_STATUS    Status;

    DebugPtrAssert( Request );
    DebugAssert( Request->DeviceType == DEVICE_TYPE_LPT );

    //
    //  Make sure that the device exists, and at the same time get its
    //  name ( For calling APIs ).
    //
    if ( Request->DeviceName ) {

        if (!(DevicePath = NEW PATH)) {
            DisplayMessageAndExit( MODE_ERROR_NO_MEMORY,
                                   NULL,
                                   (ULONG)EXIT_ERROR );
            return FALSE;   // help lint
        }

        DevicePath->Initialize( Request->DeviceName );

    } else if ( (!IsAValidLptDevice( Request->DeviceType, Request->DeviceNumber, &DevicePath ) &&
                 Request->RequestType != REQUEST_TYPE_LPT_REDIRECT &&
                 !REDIR::IsRedirected( &Status, DevicePath )) ||
                Request->DeviceNumber > LAST_LPT ) {
        DisplayMessageAndExit( MODE_ERROR_INVALID_DEVICE_NAME,
                               DevicePath->GetPathString(),
                               (ULONG)EXIT_ERROR );
    }

    //
    //  So the device is valid. Now serve the request
    //
    switch( Request->RequestType ) {


    case REQUEST_TYPE_STATUS:

        //
        //  Display State of device
        //
        Served = LptStatus( DevicePath, Request );
        break;

    case REQUEST_TYPE_CODEPAGE_PREPARE:
    case REQUEST_TYPE_CODEPAGE_SELECT:
    case REQUEST_TYPE_CODEPAGE_REFRESH:
    case REQUEST_TYPE_CODEPAGE_STATUS:

        //
        //  Codepage request
        //
        Served = LptCodePage( DevicePath, Request );
        break;

    case REQUEST_TYPE_LPT_SETUP:

        //
        //  Printer setup
        //
        Served = LptSetup( DevicePath, Request );
        break;

    case REQUEST_TYPE_LPT_REDIRECT:

        //
        //  Redirect LPT to COM
        //
        Served = LptRedirect( DevicePath, Request );
        break;

    case REQUEST_TYPE_LPT_ENDREDIR:

        //
        //  End redirection of LPT
        //
        Served = LptEndRedir( DevicePath, Request );
        break;

    default:

        DisplayMessageAndExit( MODE_ERROR_INVALID_PARAMETER,
                               NULL,
                               (ULONG)EXIT_ERROR );

    }

    DELETE( DevicePath );

    return Served;

}

BOOLEAN
LptStatus(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Displays status if an LPT device

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if status displayed successfully,
                FALSE otherwise

Notes:

--*/

{

    UNREFERENCED_PARAMETER( DevicePath );
    UNREFERENCED_PARAMETER( Request );

    PPATH           RedirPath = NULL;
    REDIR_STATUS    RedirStatus;

    RedirPath = GetRedirection( DevicePath, &RedirStatus );

    if ( !RedirPath && (RedirStatus != REDIR_STATUS_NONEXISTENT) ) {
        //
        //  We cannot find out the status of the redirection.
        //  This is almost certainly due to lack of privileges.
        //  We won't display the LPT status
        //
        return TRUE;
    }

    //
    //  Write the Header
    //
    WriteStatusHeader( DevicePath );


    if ( !RedirPath ) {

        DisplayMessage( MODE_MESSAGE_STATUS_NOT_REROUTED, NULL );

    } else {

        DisplayMessage( MODE_MESSAGE_STATUS_REROUTED, RedirPath->GetPathString() );

        DELETE( RedirPath );
    }

    Get_Standard_Output_Stream()->WriteChar( '\r' );
    Get_Standard_Output_Stream()->WriteChar( '\n' );

    return TRUE;
}

BOOLEAN
LptCodePage(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Handles Codepage requests for LPT device

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if request handled successfully,
                FALSE otherwise

Notes:

--*/

{

    UNREFERENCED_PARAMETER( DevicePath );
    UNREFERENCED_PARAMETER( Request );

    DisplayMessage( MODE_ERROR_CODEPAGE_OPERATION_NOT_SUPPORTED, NULL );

    return TRUE;
}

BOOLEAN
LptSetup(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Sets LPT state

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if state set successfully,
                FALSE otherwise

Notes:

--*/

{

    PREQUEST_DATA_LPT_SETUP Data;
    PFSN_FILE               Lpt;
    PFILE_STREAM            LptStream;



    Data = (PREQUEST_DATA_LPT_SETUP)&(((PLPT_REQUEST)Request)->Data.Setup);

    if  (  ( Data->SetCol && (Data->Col != 132) && ( Data->Col != 80 ) ) ||
           ( Data->SetLines && (Data->Lines != 6) && (Data->Lines != 8) ) ) {

        //
        //  Invalid number of lines or columns
        //
        DisplayMessageAndExit( MODE_ERROR_LPT_CANNOT_SET, NULL, (ULONG)EXIT_ERROR );

    }


    Lpt = SYSTEM::QueryFile( DevicePath );
    DebugPtrAssert( Lpt );

    if ( Lpt ) {
        LptStream = Lpt->QueryStream( WRITE_ACCESS );
        DebugPtrAssert( LptStream );
    }

    if ( !Lpt || !LptStream ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
    }

    if ( Data->SetCol ) {

        //
        //  Set number of columns. The sequence consists of one byte.
        //
        LptStream->WriteByte( (Data->Col == 80) ? CODE_COLS_80 : CODE_COLS_132 );
    }

    if ( Data->SetLines ) {

        //
        //  Set line spacing. The sequence consists of one escape byte
        //  followed by one CODE_LINES_6 or CODE_LINES 8 byte.
        //
        LptStream->WriteByte( CODE_ESCAPE );
        LptStream->WriteByte( (Data->Lines == 6) ? CODE_LINES_6 : CODE_LINES_8 );

    }

    DELETE( LptStream );
    DELETE( Lpt );

    return TRUE;
}

BOOLEAN
LptRedirect(
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Redirects LPT to a COMM port.

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE if LPT redirected,
                FALSE otherwise

Notes:

--*/

{

    PREQUEST_DATA_LPT_REDIRECT  Data;
    PPATH                       RedirPath;

    Data = (PREQUEST_DATA_LPT_REDIRECT)&(((PLPT_REQUEST)Request)->Data.Redirect);

    //
    //  Verify that the serial device specified is valid
    //
    if ( !IsAValidDevice( Data->DeviceType, Data->DeviceNumber, &RedirPath )) {

        DisplayMessageAndExit( MODE_ERROR_INVALID_DEVICE_NAME,
                               RedirPath->GetPathString(),
                               (ULONG)EXIT_ERROR );

    }

    if ( !REDIR::Redirect( DevicePath, RedirPath ) ) {

        DisplayMessageAndExit( MODE_ERROR_LPT_CANNOT_REROUTE, RedirPath->GetPathString(), (ULONG)EXIT_ERROR );

    }

    //
    //  Display the status as confirmation
    //
    LptStatus( DevicePath, Request );

    DELETE( RedirPath );

    return TRUE;
}


BOOLEAN
LptEndRedir (
    IN  PCPATH          DevicePath,
    IN  PREQUEST_HEADER Request
    )

/*++

Routine Description:

    Ends the redirection of an LPT port

Arguments:

    DevicePath  -   Supplies pointer to path of device
    Request     -   Supplies pointer to request

Return Value:

    BOOLEAN -   TRUE

Notes:

--*/

{

    REDIR_STATUS    Status;

    //
    //  If the LPT is being redirected, end the redirection
    //
    if ( REDIR::IsRedirected( &Status, DevicePath ) ) {

        if ( !REDIR::EndRedirection( DevicePath )) {

            DisplayMessageAndExit( MODE_ERROR_LPT_CANNOT_ENDREROUTE, NULL, (ULONG)EXIT_ERROR );
        }
    }

    //
    //  Display status
    //
    LptStatus( DevicePath, Request );

    return TRUE;

}

PPATH
GetRedirection(
    IN  PCPATH          DevicePath,
    OUT PREDIR_STATUS   RedirStatus
    )

/*++

Routine Description:

    Determines to what device is the LPT redirected to

Arguments:

    DevicePath  -   Supplies pointer to path of device

    RedirStatus -   Supplies pointer to redirection status

Return Value:

    PPATH   -   Pointer to the redirected device

--*/

{

    ULONG   DeviceNumber    =   1;
    PPATH   DestPath        =   NULL;
    BOOLEAN ValidDevice     =   TRUE;

    if ( REDIR::IsRedirected( RedirStatus, DevicePath ) ) {

        for ( DeviceNumber = 1; DeviceNumber <= LAST_COM; DeviceNumber++ ) {

            IsAValidDevice( DEVICE_TYPE_COM, DeviceNumber, &DestPath );

            if ( REDIR::IsRedirected( RedirStatus, DevicePath, DestPath )) {

                break;

            }

            DELETE( DestPath );
            DestPath = NULL;

        }
    }

    return DestPath;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\mode.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        Mode

Abstract:

        Mode utility

Author:

        Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/


#include "mode.hxx"
#include "system.hxx"



//
//      Message stream
//
PSTREAM_MESSAGE Message;


//
//      DeviceHandler is an array of pointers to the different device
//      handlers.
//
DEVICE_HANDLER  DeviceHandler[ NUMBER_OF_DEVICE_TYPES ] = {

                LptHandler,
                ComHandler,
                ConHandler,
                CommonHandler

        };




VOID
InitializeMode (
        );

VOID
DeallocateResources (
        );


PSTREAM
Get_Standard_Input_Stream();

PSTREAM
Get_Standard_Output_Stream();

PSTREAM
Get_Standard_Error_Stream();







VOID __cdecl
main (
        )

/*++

Routine Description:

        Main function of the Mode utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        PREQUEST_HEADER Request;

        //
        //      Initialize whatever is necessary
        //
        InitializeMode();

        //
        //      Verify the OS version
        //
        if ( !SYSTEM::IsCorrectVersion() ) {

                DisplayMessageAndExit( MODE_ERROR_INCORRECT_OS_VERSION,
                                                           NULL,
                                                           (ULONG)EXIT_ERROR );
        }

        //
        //      Obtain a request from the command line. Note that the
        //      first field of the request is the device type.
        //
        Request = GetRequest();
        DebugPtrAssert( Request );
        DebugAssert( Request->DeviceType <= DEVICE_TYPE_ALL );

        //
        //      Let the device handler for the specified type take care of the
        //      request.
        //
        DebugPtrAssert( DeviceHandler[ Request->DeviceType ] );
        DeviceHandler[ Request->DeviceType ]( Request );

        //
        //      Deallocate resources
        //
        FREE( Request );
        DeallocateResources();

        //
        //      We're done
        //
        ExitMode( EXIT_SUCCESS );

}

VOID
InitializeMode (
        )

/*++

Routine Description:

        Allocates resources and initializes Mode structures

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        if ( //
         // Construct and initialize a STREAM_MESSAGE.
                 //
         !(Message = NEW STREAM_MESSAGE ) ||
         !Get_Standard_Output_Stream() ||
                 !Message->Initialize( Get_Standard_Output_Stream(),
                                                          Get_Standard_Input_Stream() )
           ) {

                //
                //      We don't have Message, so we cannot display the error
                //      text.
                //
                exit( EXIT_ERROR );
        }

        //
        //      Allocate resources which are private to each type of device
        //
        ComAllocateStuff();

}

VOID
DeallocateResources (
        )

/*++

Routine Description:

        Deallocates resources allocated in InitializeMode

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        DELETE( Message );
        ComDeAllocateStuff();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\label\label.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    LABEL

Abstract:

    Label is a DOS-5 compatible volume label changing utility

Author:

        Norbert Kluster (norbertk) 18-Apr-1991

Notes:


Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"
#include "substrng.hxx"
#include "system.hxx"
#include "ifssys.hxx"
#include "ulibcl.hxx"

extern "C" {
    #include "ntioapi.h"
}

CONST   MaxLabelLength = 1024;

VOID
DisplayLabelUsage(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays the usage for the dos 5 label program.

Arguments:

    Message - Supplies an outlet for the messages.

Return Value:

    None.

--*/
{
    Message->Set(MSG_LBL_INFO);
    Message->Display("");
    Message->Set(MSG_LBL_USAGE);
    Message->Display("");
}


BOOLEAN
OpenDrive(
    IN  PCWSTRING   Drive,
    OUT PHANDLE     Handle,
    OUT PNTSTATUS   Status
    )
/*++

Routine Description:

    This routine opens an NT handle to for the given dos drive name.

Arguments:

    Drive   - Supplies a dos drive name.
    Handle  - Returns an NT handle to the drive.
    Status  - Receives the status code if the function returns FALSE

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING             ntdrive;
    UNICODE_STRING      string;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     status_block;

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(Drive, &ntdrive)) {

        *Status = STATUS_NO_MEMORY;
        return FALSE;
    }

    if (!(string.Buffer = ntdrive.QueryWSTR())) {

        *Status = STATUS_NO_MEMORY;
        return FALSE;
    }

    string.Length = (USHORT) (ntdrive.QueryChCount()*sizeof(WCHAR));
    string.MaximumLength = string.Length;

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    *Status = NtOpenFile(Handle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &oa, &status_block,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT | FILE_WRITE_THROUGH);

    return (BOOLEAN) NT_SUCCESS(*Status);
}


BOOLEAN
OpenReadOnlyDrive(
    IN  PCWSTRING   Drive,
    OUT PHANDLE     Handle
    )
/*++

Routine Description:

    This routine opens an NT handle to for the given dos drive name.

Arguments:

    Drive   - Supplies a dos drive name.
        Handle  - Returns an NT handle to the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING             ntdrive;
    UNICODE_STRING      string;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     status_block;
    DSTRING             backslash;
    NTSTATUS            Status;


    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(Drive, &ntdrive) ||
        !backslash.Initialize("\\") ||
        !ntdrive.Strcat(&backslash)) {

        return FALSE;
    }

    if (!(string.Buffer = ntdrive.QueryWSTR())) {

        return FALSE;
    }

    string.Length = (USHORT) (ntdrive.QueryChCount()*sizeof(WCHAR));
    string.MaximumLength = string.Length;

    InitializeObjectAttributes( &oa,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile(Handle,
                        SYNCHRONIZE | FILE_READ_DATA,
                        &oa, &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    return (BOOLEAN) NT_SUCCESS(Status);
}


BOOLEAN
GetLabelInput(
    IN      PCWSTRING   DisplayDriveName,
    IN      PCWSTRING   Drive,
    OUT     PBOOLEAN    LabelExists,
    OUT     PWSTRING    Label,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine prints the current label, if any, and the current serial
    number.  Then a new label is queried from the user.

Arguments:

    DisplayDriveName
                - The dos stype name to be displayed to the user
    Drive       - The dos style drive name.
    LabelExists - Returns whether or not a label currently exists on
                    the volume.
    Label       - Returns the inputted label.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   length = sizeof(FILE_FS_VOLUME_INFORMATION) + MaxLabelLength;
    CONST   max_fsname = 40;

    // The buffer for FileFsVolumeInformation must be quadword-aligned.

    LONGLONG                        info_buf[length/sizeof(LONGLONG) + 1];
    PFILE_FS_VOLUME_INFORMATION     info;

    IO_STATUS_BLOCK                 status_block;
    PUSHORT                         p;
    DSTRING                         current_label;
    HANDLE                          Handle;
    WCHAR                           file_system[max_fsname];
    MSGID                           label_prompt_msg;
    DSTRING                         root_dir;
    DSTRING                         slash;
    PWSTR                           proot_dir;
    DSTRING                         fsname;
    DSTRING                         ntfs;

    if (!OpenReadOnlyDrive(Drive, &Handle)) {

        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();
        return FALSE;
    }


    info = (PFILE_FS_VOLUME_INFORMATION) info_buf;

    if (!NT_SUCCESS(NtQueryVolumeInformationFile(Handle, &status_block,
                    info, length, FileFsVolumeInformation))) {

        NtClose(Handle);
        return FALSE;
    }

    NtClose(Handle);

    info->VolumeLabel[info->VolumeLabelLength/sizeof(WCHAR)] = 0;

    if (!current_label.Initialize(info->VolumeLabel)) {
        return FALSE;
    }

    if (info->VolumeLabelLength) {
        Message->Set(MSG_LBL_THE_LABEL);
        Message->Display("%W%W", DisplayDriveName, &current_label);
        *LabelExists = TRUE;
    } else {
        Message->Set(MSG_LBL_NO_LABEL);
        Message->Display("%W", DisplayDriveName);
        *LabelExists = FALSE;
    }

    p = (PUSHORT) &info->VolumeSerialNumber;

    if (p[1] || p[0]) {
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", p[1], p[0]);
    }

    // Figure out which label prompt message to use.

    label_prompt_msg = MSG_VOLUME_LABEL_PROMPT;

    if (slash.Initialize("\\") &&
        root_dir.Initialize(Drive) &&
        root_dir.Strcat(&slash) &&
        ntfs.Initialize("NTFS") &&
        (proot_dir = root_dir.QueryWSTR())) {

        if (GetVolumeInformation(proot_dir, NULL, 0, NULL, NULL,
                                 NULL, file_system, max_fsname) &&
            fsname.Initialize(file_system) &&
            !fsname.Stricmp(&ntfs)) {

            label_prompt_msg = MSG_VOLUME_LABEL_NO_MAX;
        }

        DELETE(proot_dir);
    }

    Message->Set(label_prompt_msg, ERROR_MESSAGE);
    Message->Display();

    return Message->QueryStringInput(Label);
}


BOOLEAN
SetLabel(
    IN      PCWSTRING   Drive,
    IN      PCWSTRING   Label,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine sets the supplied label on the supplied drive.

Arguments:

    Drive   - Supplies the dos drive name.
    Label   - Supplies a label.
    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   length  = sizeof(FILE_FS_LABEL_INFORMATION) + MaxLabelLength;

    PFILE_FS_LABEL_INFORMATION  info;
    STR                         info_buf[length];
    IO_STATUS_BLOCK             status_block;
    NTSTATUS                    nts;
    DSTRING                     uppercase_label;
    HANDLE                      Handle;
    NTSTATUS                    status;


    if (!OpenDrive(Drive, &Handle, &status)) {

        if( status == STATUS_ACCESS_DENIED ) {

            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display("");

        } else {

            Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
            Message->Display("");
        }

        return FALSE;
    }


    if (!uppercase_label.Initialize(Label)) {
        return FALSE;
    }

    info = (PFILE_FS_LABEL_INFORMATION) info_buf;

    if (!uppercase_label.QueryWSTR(0, TO_END, info->VolumeLabel,
                                   (length - sizeof(ULONG))/sizeof(WCHAR))) {

        Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
        Message->Display();
        return FALSE;
    }

    info->VolumeLabelLength = uppercase_label.QueryChCount()*sizeof(WCHAR);

    nts = NtSetVolumeInformationFile(Handle, &status_block, info,
                                     length, FileFsLabelInformation);

    if (!NT_SUCCESS(nts)) {

        switch (nts) {
        case STATUS_ACCESS_DENIED:

            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display();
            break;

        case STATUS_INVALID_VOLUME_LABEL:

            Message->Set(MSG_INVALID_LABEL);
            Message->Display();
            break;

          case STATUS_NOT_SUPPORTED:
          case STATUS_INVALID_DEVICE_REQUEST:

            Message->Set(MSG_LBL_NOT_SUPPORTED);
            Message->Display();
            break;

          case STATUS_DISK_FULL:

            Message->Set(MSG_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            break;

          case STATUS_MEDIA_WRITE_PROTECTED:

            Message->Set(MSG_LBL_WRITE_PROTECTED_MEDIA);
            Message->Display();
            break;

          case STATUS_CANNOT_MAKE:

            Message->Set(MSG_LBL_ROOT_DIRECTORY_FULL);
            Message->Display();
            break;

          case STATUS_REQUEST_ABORTED:

            Message->Set(MSG_LBL_CHANGE_CANCEL);
            Message->Display();
            break;

          default:

            Message->Set(MSG_INCOMPATIBLE_PARAMETERS);
            Message->Display();
            break;

        }

        return FALSE;
    }

    return TRUE;
}


INT __cdecl
main(
    )
/*++

Routine Description:

    This routine emulates the dos 5 label command for NT.

Arguments:

    None.

Return Value:

    1   - An error occured.
    0   - Success.

--*/
{
    STREAM_MESSAGE          msg;
    ARGUMENT_LEXEMIZER      arglex;
    ARRAY                   lex_array;
    ARRAY                   arg_array;
    STRING_ARGUMENT         progname;
    REST_OF_LINE_ARGUMENT   other_arg;
    FLAG_ARGUMENT           help_arg;
    FLAG_ARGUMENT           mp_arg;
    DSTRING                 label_string;
    DSTRING                 drive_string;
    BOOLEAN                 label_exists;
    PWSTRING                p;
    PATH                    path;
    PATH                    fullpath;
    DSTRING                 drive_path_string;
    CHNUM                   position;
    PATH_ANALYZE_CODE       rst;
    DSTRING                 DisplayDriveName;

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream(),
                        Get_Standard_Error_Stream())) {
        return 1;
    }

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 1;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 1;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 1;
    }

    if (!progname.Initialize("*") ||
        !help_arg.Initialize("/?") ||
        !mp_arg.Initialize("/MP") ||
        !other_arg.Initialize()) {
        return 1;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&help_arg) ||
        !arg_array.Put(&mp_arg) ||
        !arg_array.Put(&other_arg)) {
        return 1;
    }

    if (!arglex.DoParsing(&arg_array)) {
        msg.Set(MSG_INVALID_PARAMETER);
        msg.Display("%W", p = arglex.QueryInvalidArgument());
        return 1;
    }

    if (help_arg.QueryFlag()) {
        DisplayLabelUsage(&msg);
        return 0;
    }

    //
    // Figure out what kind of combination of drive and label
    //

    if (!label_string.Initialize())
        return 1;

    if (other_arg.IsValueSet()) {
        if (!drive_string.Initialize(other_arg.GetRestOfLine()) ||
            !path.Initialize(other_arg.GetRestOfLine())) {
            return 1;
        }
        if (mp_arg.IsValueSet()) {
            // treat like 'label /mp [<mount point or guid volume name>] [label]'
            // note that the mount point or guid volume name is not optional
            if (drive_string.QueryChAt(1) == (WCHAR)':' || path.IsGuidVolName()) {
                position = drive_string.Strchr(L' ');
                if (position != INVALID_CHNUM) {
                    // split up the string into drive string and label string
                    if (!label_string.Initialize(&drive_string, position))
                        return 1;
                    drive_string.DeleteChAt(position, TO_END);
                    // get rid of spaces at the beginning
                    while (label_string.QueryChAt(0) == (WCHAR)' ')
                        label_string.DeleteChAt(0);
                }
            } else {
                if (!label_string.Initialize(&drive_string) ||
                    !drive_string.Initialize(L"."))
                    return 1;
            }
        } else {
            // treat like 'label [<driveletter>:][...label...]
            // note that the drive letter is optional
            if (drive_string.QueryChAt(1) == (WCHAR)':') {
                if (!label_string.Initialize(&drive_string, 2))
                    return 1;
                drive_string.DeleteChAt(2, TO_END);
                // get rid of spaces at the beginning
                while (label_string.QueryChAt(0) == (WCHAR)' ')
                    label_string.DeleteChAt(0);
            } else if (path.IsGuidVolName()) {
                position = drive_string.Strchr(L' ');
                if (position != INVALID_CHNUM) {
                    // split up the string into drive string and label string
                    if (!label_string.Initialize(&drive_string, position))
                        return 1;
                    drive_string.DeleteChAt(position, TO_END);
                    // get rid of spaces at the beginning
                    while (label_string.QueryChAt(0) == (WCHAR)' ')
                        label_string.DeleteChAt(0);
                }
            } else {
                if (!label_string.Initialize(&drive_string) ||
                    !SYSTEM::QueryCurrentDosDriveName(&drive_string)) {
                    return 1;
                }
            }
        }
    } else {
        if (mp_arg.IsValueSet()) {
            if (!drive_string.Initialize(L"."))
                return 1;
        } else {
            if (!SYSTEM::QueryCurrentDosDriveName(&drive_string)) {
                return 1;
            }
        }
    }

    if (!path.Initialize(&drive_string))
        return 1;

    rst = path.AnalyzePath(&drive_string,
                           &fullpath,
                           &drive_path_string);

    switch (rst) {
        case PATH_OK:
        case PATH_COULD_BE_FLOPPY:
            if (drive_path_string.QueryChCount() != 0) {
                msg.Set(MSG_FMT_INVALID_DRIVE_SPEC);
                msg.Display();
                return 1;
            }
            if (path.IsGuidVolName()) {
                if (!DisplayDriveName.Initialize(&drive_string))
                    return 1;
            } else {
                if (!DisplayDriveName.Initialize(fullpath.GetPathString()))
                    return 1;
            }
            if (fullpath.GetPathString()->QueryChCount() == 2 &&
                fullpath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                if (!drive_string.Initialize(fullpath.GetPathString()))
                    return 1;
            }
            break;

        case PATH_OUT_OF_MEMORY:
            DebugPrint("Out of memory.\n");
            return 1;

        case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
            msg.Set(MSG_LBL_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH);
            msg.Display();
            return 1;

        default:
            msg.Set(MSG_LBL_INVALID_DRIVE_SPEC);
            msg.Display();
            return 1;
    }

    if (label_string.QueryChCount() == 0) {

        if (!GetLabelInput(&DisplayDriveName,
                           &drive_string, &label_exists,
                           &label_string, &msg)) {
            return 1;
        }
    }

    if (!label_string.QueryChCount()) {
        if (label_exists) {
            msg.Set(MSG_LBL_DELETE_LABEL);
            msg.Display("");
            if (!msg.IsYesResponse(FALSE)) {
                return 0;
            }
        } else {
            return 0;
        }
    }

    return SetLabel(&drive_string, &label_string, &msg) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\argument.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Argument

Abstract:

    Argument processing for the MODE utility.

    The functions in this file:

    1.- Parse the MODE command line.
    2.- Perform some basic argument validation.
    3.- Make a request packet that will be eventually routed to a
        device handler.


Author:

    Ramon Juan San Andres (ramonsa) 26-Jun-1991

Notes:

    Due to the complexity of the MODE command line, and the fact that
    we have to support both the DOS5 syntax (tagged parameters) and
    the old DOS syntax (positional parameters), MODE does not use
    the standard ULIB argument parsing.  MODE does its own parsing
    instead.

    The mode command-line can take any of the following forms:

    MODE [/?]

    MODE [device] [/STATUS]

    MODE device cp PREPARE=string

    MODE device cp REFRESH

    MODE device cp SELECT=codepage

    MODE device cp [/STATUS]

    MODE LPTn[:] [c][,l][,r]]

    MODE LPTn[:] [COLS=c] [LINES=l] [RETRY=r]

    MODE LPTn[:]=COMm[:]

    MODE COMm[:] [b[,p[,d[,s[,r]]]]]

    MODE COMm[:] [BAUD=b] [PARITY=p] [DATA=d] [STOP=s] [RETRY=r]
                 [to=on|off] [xon=on|off] [odsr=on|off] [octs=on|off]

    MODE [c[,l]]

    MODE CON[:] [COLS=c] [LINES=l]

    MODE CON[:] [RATE=r DELAY=d]


    where:


    device  :=  LPTn[:] | COMm[:] | CON[:]
    cp      :=  CP  |   CODEPAGE



    The argument parsing of MODE does a syntax-directed translation of
    the command line into a request packet. The translation is based on
    the following language.  Note that some terminal symbols (in uppercase)
    might be language dependent.


    mode        :=  MODE  { statusline | lptline | comline | conline | videoline }

    statusline  :=  /STA*

    lptline     :=  lptdev { lptredir | lptsetold | lptsetnew | lptcp | lptstatus }
    lptred      :=  =comdev
    lptset      :=  { n[,n][,c] | [COLS=n] [LINES=n] [RETRY=c] }
    lptcp       :=  cpstuff
    lptstatus   :=  { /STA* | }

    comline     :=  comdev { comset |   comstatus }
    comset      :=  { n[,c[,n[,f[,c]]]] |   [BAUD=n] [PARITY=c] [DATA=n] [STOP=f] [RETRY=c] }
                                            [to=on|off] [xon=on|off] [odsr=on|off] [octs=on|off]
    comstatus   :=  { /STA* | }

    conline     :=  condev { conrc  |   contyp  |   concp   |   constatus }
    conrc       :=  [COLS=n] [LINES=n]
    contyp      :=  RATE=n DELAY=n
    concp       :=  cpstuff
    constatus   :=  { /STA* | }

    videoline   :=  n[,n]

    cpstuff     :=  cp  { prepare | refresh | select | cpstatus}
    cp          :=  CP | CODEPAGE
    prepare     :=  PREPARE=*
    refresh     :=  REFRESH
    select      :=  SELECT=n
    cpstatus    :=  { /STA* | }

    comdev      :=  COMn[:]
    lptdev      :=  LPTn[:]
    condev      :=  CON[:]

    n           :=  Integer number
    f           :=  floating point number
    c           :=  character



    The functions in this file parse the language shown above. Most of
    the functions have names that correspond to non-terminal symbols in
    the language.


    There are 3 main functions used for reading the command line:

    Match()     -   This function matches a pattern against whatever
                    is in the command line at the current position.

                    Note that this does not advance our current position
                    within the command line.

                    If the pattern has a magic character, then the
                    variables MatchBegin and MatchEnd delimit the
                    substring of the command line that matched that
                    magic character.


    Advance()   -   This functions advances our current position within
                    the command line. The amount by which the position
                    is advanced is determined by the the last Match().


    EndOfInput()-   Returns TRUE if the command line has been consumed.



    e.g.    If the command line has the string "MODE COM1: 1200"

            This is what the following sequence would do

            Match( "*" );       //  TRUE (matches "MODE")
            Advance();

            //
            //  Note that Match() does not advance our position
            //
            MATCH( "LPT" );     //  FALSE (no match)
            MATCH( "COM#" );    //  TRUE (matches "COM" )
            //
            //  At this point, MatchBegin and MatchEnd delimit the
            //  substring "1"
            //
            MATCH( "FOO" );     //  FALSE (no match)

            MATCH( "C*" );      //  TRUE (matches "COM1:");
            //
            //  At this point, MatchBegin and MatchEnd delimit the
            //  substring "OM1:"
            //
            Advance();

            Match( "#" );       //  TRUE (matches "1200");
            Advance();

            EndOfInput();       //  TRUE



Revision History:


--*/


#include "mode.hxx"
#include "common.hxx"
#include "lpt.hxx"
#include "com.hxx"
#include "cons.hxx"


extern "C" {

    #include <ctype.h>
    #include <string.h>

}


//
//Static data
//
PWSTRING    CmdLine;        //  The command line
CHNUM       CharIndex;      //  Index of current character
CHNUM       AdvanceIndex;   //  Index of next parameter
CHNUM       ParmIndex;      //  Index of current parameter
CHNUM       MatchBegin;     //  First index of match
CHNUM       MatchEnd;       //  Last index of match

//
//  Patterns.
//
//  Most patterns contain terminal symbols. Certain characters in a
//  pattern have a magic meaning:
//
//  '*' Matches everything up to the end of the parameter (parameters are
//      delimited by blank space).
//
//  '#' Matches a sequence of digits
//
//  '@' Matches a single character
//
//  '[' Starts an optional sequence. If the first character in the
//      the sequence matches, then all the sequence should match. If
//      the first character in the sequence does not match, then the
//      sequence is skipped.
//
//  ']' End of optional sequence
//
//


//
//  Prototypoes
//

PREQUEST_HEADER
LptLine (
    );

PREQUEST_HEADER
LptRedir (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
LptSet (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
LptCp (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
ComLine (
    );

PREQUEST_HEADER
ComSet (
    IN  ULONG   DeviceNumber
    );

PREQUEST_HEADER
ConLine (
    );

PREQUEST_HEADER
ConRc (
    );

PREQUEST_HEADER
ConTyp (
    );

PREQUEST_HEADER
ConCp (
    );

PREQUEST_HEADER
VideoLine (
    );

PREQUEST_HEADER
CpStuff (
    IN  DEVICE_TTYPE DeviceType,
    IN  ULONG        DeviceNumber
    );

BOOLEAN
AllocateResource(
    );

VOID
DeallocateResource(
    );

BOOLEAN
Match(
    IN  PCSTR   Pattern
    );

BOOLEAN
Match(
    IN  PCWSTRING   Pattern
    );

VOID
Advance(
    );

BOOLEAN
EndOfInput(
    );

PREQUEST_HEADER
MakeRequest(
    IN  DEVICE_TTYPE    DeviceType,
    IN  LONG            DeviceNumber,
    IN  REQUEST_TYPE    RequestType,
    IN  ULONG           Size
    );

ULONG
GetNumber(
    );




INLINE
BOOLEAN
EndOfInput(
    )

/*++

Routine Description:

    Finds out if we are at the end of the command line.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if at the end of input, FALSE otherwise


--*/

{

    return (CharIndex >= CmdLine->QueryChCount());

}

PREQUEST_HEADER
GetRequest(
    )

/*++

Routine Description:

    Parses the command line and makes a device request.

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request = NULL;
    DSTRING         Switches;

    //
    //  Allocate strings (i.e. patterns ) from the resource
    //

    //
    //  Get the command line and parse it
    //
    if (Switches.Initialize("/-") &&
        AllocateResource() &&
        CmdLine->Initialize( GetCommandLine() )) {

        //
        //  Before anything else, we look for a help switch somewhere
        //  in the command line. This kind of stinks, but this is how
        //  MODE works under DOS, se let's be compatible...
        //
        CharIndex       = 0;

        while ( TRUE ) {

            //
            //  Look for a switch
            //
            CharIndex = CmdLine->Strcspn( &Switches, CharIndex );

            if ( CharIndex != INVALID_CHNUM ) {

                //
                //  There is a switch, see if it is the help switch
                //
                CharIndex++;

                if ( Match( "?" )) {

                    //
                    //  This is a help switch, Display help
                    //
                    DisplayMessageAndExit( MODE_MESSAGE_HELP, NULL, EXIT_SUCCESS );

                }
            } else {
                break;
            }
        }

        //
        //  No help requested, now we can parse the command line. First we
        //  initialize our indeces.
        //
        ParmIndex       = 0;
        CharIndex       = 0;
        AdvanceIndex    = 0;

        //
        //  Match the program name
        //
        Advance();

        Match( "*" );
        Advance();

        //
        //  If there are no parameters, or the only parameter is the
        //  status switch, then this is a request for the status of
        //  all devices.
        //
        if ( EndOfInput() ) {

            Request = MakeRequest( DEVICE_TYPE_ALL,
                                   ALL_DEVICES,
                                   REQUEST_TYPE_STATUS,
                                   sizeof( REQUEST_HEADER ) );

        } else if ( Match( "/STA*"  ) ) {

            Advance();

            if ( !EndOfInput() ) {

                ParseError();
            }

            Request = MakeRequest( DEVICE_TYPE_ALL,
                                   ALL_DEVICES,
                                   REQUEST_TYPE_STATUS,
                                   sizeof( REQUEST_HEADER ) );


        } else if ( Match( "LPT#[:]" ) ) {

            //
            //  lptline
            //
            Request = LptLine();

        } else if ( Match( "COM#[:]"    ) ) {

            //
            //  comline
            //
            Request = ComLine();

        } else if ( Match( "CON[:]" ) ) {

            //
            //  conline
            //
            Request = ConLine();

        } else if ( Match( "#" ) ) {

            //
            //  videoline
            //
            Request = VideoLine();

        } else {

            //
            //  Parse error
            //
            ParseError();
        }

    } else {

        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );

    }

    //
    //  Deallocate strings from resource
    //
    DeallocateResource();

    //
    //  Return the request
    //
    return Request;

}

PREQUEST_HEADER
LptLine (
    )

/*++

Routine Description:

    Takes care of parsing the lptline non-terminal symbol

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    ULONG           DeviceNumber;

    //
    //  Note that at this point we have matched the lpt device.
    //  Get the device number;
    //
    DeviceNumber =  GetNumber();

    Advance();

    if ( EndOfInput() ) {

        //
        //  End redirection
        //
        Request = MakeRequest( DEVICE_TYPE_LPT,
                               DeviceNumber,
                               REQUEST_TYPE_LPT_ENDREDIR,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match( "/STA*" ) ) {

        //
        //  Status request
        //
        Request = MakeRequest( DEVICE_TYPE_LPT,
                               DeviceNumber,
                               REQUEST_TYPE_STATUS,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match ( "=" ) ) {

        //
        //  lptredir
        //
        Request = LptRedir( DeviceNumber );

    } else if ( Match( "#" )        || Match( "COLS=#" ) ||
                Match( "LINES=#" )  || Match( "RETRY=@" ) ) {

        //
        //  lptset
        //
        Request = LptSet( DeviceNumber );

    } else if ( Match( "CP" ) || Match( "CODEPAGE" ) ) {

        //
        //  lptcp
        //
        Request = LptCp( DeviceNumber );

    } else {

        //
        //  Error
        //
        ParseError();

    }

    return Request;

}

PREQUEST_HEADER
LptRedir (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the lptredir non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER     Request;
    PLPT_REQUEST        LptRequest;
    ULONG               ComDevice;

    Advance();

    //
    //  Can only redirect to COM devices
    //
    if ( Match( "COM#[:]" ) ) {

        ComDevice = GetNumber();

        Request = MakeRequest( DEVICE_TYPE_LPT,
                               DeviceNumber,
                               REQUEST_TYPE_LPT_REDIRECT,
                               sizeof(LPT_REQUEST ) );

        LptRequest = (PLPT_REQUEST)Request;

        LptRequest->Data.Redirect.DeviceType    = DEVICE_TYPE_COM;
        LptRequest->Data.Redirect.DeviceNumber  = ComDevice;

    } else {

        //
        //  Error
        //
        ParseError();

    }

    return Request;
}

PREQUEST_HEADER
LptSet (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the lptset non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER     Request;
    PLPT_REQUEST        LptRequest;
    BOOLEAN             SetCols     =   FALSE;
    BOOLEAN             SetLines    =   FALSE;
    BOOLEAN             SetRetry    =   FALSE;
    ULONG               Cols;
    ULONG               Lines;
    WCHAR               Retry;


    if ( Match( "#" ) ) {

        //
        //  Old syntax, where parameter are positional and comma-delimited.
        //
        //  We will use the following automata for parsing the input
        //  (eoi = end of input)
        //
        //
        //          eoi
        //  [Cols]------------->[End]
        //    |            ^
        //    |,           |eoi
        //    v            |
        //   [X]-----------+
        //    |            ^
        //    | #          |eoi
        //    +-->[Lines]--+
        //    |     |      ^
        //    |     |,     |
        //    |<----+      |
        //    |            |
        //    |,           |eoi
        //    |            |
        //    v            |
        //   [Y]-----------+
        //    |            ^
        //    | @          |eoi
        //    +-->[Retry]--+
        //
        //

        Cols = GetNumber();
        SetCols = TRUE;
        Advance();

        //
        //  X:
        //
        if ( !Match( "," ) ) {
            goto Eoi;
        }
        Advance();

        if ( Match( "#" ) ) {

            //  n
            //  Lines
            //
            Lines = GetNumber();
            SetLines = TRUE;
            Advance();
        }

        //
        //  Y:
        //
        if ( !Match ( "," ) ) {
            goto Eoi;
        }

        if ( Match( "@" ) ) {

            //
            //  Retry
            //
            Retry = CmdLine->QueryChAt( MatchBegin );
            SetRetry = TRUE;
            Advance();
        }

Eoi:
        if ( !EndOfInput() ) {

            //
            //  Error
            //
            ParseError();

        }

    } else {

        //
        //  New syntax, where parameters are tagged. The language assumes
        //  that all parameters are optional (as long as there is at least
        //  one present). If some is required, it is up to the Device
        //  handler to complain latter on.
        //

        while ( !EndOfInput() ) {

            if ( Match( "COLS=#" ) ) {
                //
                //  COLS=
                //
                Cols = GetNumber();
                SetCols = TRUE;
                Advance();

            } else if ( Match( "LINES=#" ) ) {
                //
                //  LINES=
                //
                Lines = GetNumber();
                SetLines = TRUE;
                Advance();

            } else if ( Match( "RETRY=@" ) ) {
                //
                //  RETRY=
                //
                Retry = CmdLine->QueryChAt( MatchBegin );
                SetRetry = TRUE;
                Advance();

            } else {

                ParseError();
            }
        }

    }


    //
    //  Now that we parsed all the parameters, we make the request
    //  packet.
    //
    Request = MakeRequest( DEVICE_TYPE_LPT,
                           DeviceNumber,
                           REQUEST_TYPE_LPT_SETUP,
                           sizeof(LPT_REQUEST ) );

    LptRequest = (PLPT_REQUEST)Request;

    LptRequest->Data.Setup.SetCol   =   SetCols;
    LptRequest->Data.Setup.SetLines =   SetLines;
    LptRequest->Data.Setup.SetRetry =   SetRetry;
    LptRequest->Data.Setup.Col      =   Cols;
    LptRequest->Data.Setup.Lines    =   Lines;
    LptRequest->Data.Setup.Retry    =   Retry;

    return Request;
}

PREQUEST_HEADER
LptCp (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the lptcp non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    //
    //  Since this is the same for LPT and CON, we use the same
    //  function to handle both.
    //
    return  CpStuff( DEVICE_TYPE_LPT, DeviceNumber );

}

PREQUEST_HEADER
ComLine (
    )

/*++

Routine Description:

    Takes care of parsing the comline non-terminal symbol

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    ULONG           DeviceNumber;

    //
    //  Note that we have already matched the COM device.
    //  Get the device number;
    //
    DeviceNumber = GetNumber();

    Advance();

    if ( Match( "/STA*" ) || EndOfInput() ) {

        //
        //  Status request
        //
        Request = MakeRequest( DEVICE_TYPE_COM,
                               DeviceNumber,
                               REQUEST_TYPE_STATUS,
                               sizeof( REQUEST_HEADER ) );


    } else {

        //
        //  comset
        //
        Request = ComSet( DeviceNumber );

    }

    return Request;

}

PREQUEST_HEADER
ComSet (
    IN  ULONG   DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the comset non-terminal symbol

Arguments:

    DeviceNumber    -   Supplies the device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER     Request;
    PCOM_REQUEST        ComRequest;


    BOOLEAN         SetBaud         =   FALSE;
    BOOLEAN         SetDataBits     =   FALSE;
    BOOLEAN         SetStopBits     =   FALSE;
    BOOLEAN         SetParity       =   FALSE;
    BOOLEAN         SetRetry        =   FALSE;
    BOOLEAN         SetTimeOut      =   FALSE;
    BOOLEAN         SetXon          =   FALSE;
    BOOLEAN         SetOdsr         =   FALSE;
    BOOLEAN         SetIdsr         =   FALSE;
    BOOLEAN         SetOcts         =   FALSE;
    BOOLEAN         SetDtrControl   =   FALSE;
    BOOLEAN         SetRtsControl   =   FALSE;

    ULONG           Baud;
    ULONG           DataBits;
    STOPBITS        StopBits;
    PARITY          Parity;
    WCHAR           Retry;
    BOOLEAN         TimeOut;
    BOOLEAN         Xon;
    BOOLEAN         Odsr;
    BOOLEAN         Idsr;
    BOOLEAN         Octs;
    DTR_CONTROL     DtrControl;
    RTS_CONTROL     RtsControl;


    if ( Match( "#" ) ) {

        //
        //  Old syntax, where parameter are positional and comma-delimited.
        //
        //  We will use the following automata for parsing the input
        //  (eoi = end of input):
        //
        //          eoi
        //  [Baud]------------->[End]
        //    |            ^
        //    |,           |eoi
        //    v            |
        //   [a]-----------+
        //    |            ^
        //    | @          |eoi
        //    +-->[Parity]-+
        //    |     |      ^
        //    |     |,     |
        //    |<----+      |
        //    |            |
        //    |,           |eoi
        //    |            |
        //    v            |
        //   [b]-----------+
        //    |            ^
        //    | #          |eoi
        //    +-->[Data]---+
        //    |     |      ^
        //    |     |,     |
        //    |<----+      |
        //    |            |
        //    |,           |eoi
        //    v            |
        //   [c]-----------+
        //    |            ^
        //    | #          |eoi
        //    +-->[Stop]---+
        //

        //
        // Assume xon=off
        //

        SetXon      = TRUE;
        SetOdsr     = TRUE;
        SetOcts     = TRUE;
        SetDtrControl = TRUE;
        SetRtsControl = TRUE;
        Xon         = FALSE;
        Odsr        = FALSE;
        Octs        = FALSE;
        DtrControl  = DTR_ENABLE;
        RtsControl  = RTS_ENABLE;

        Baud = ConvertBaudRate( GetNumber() );
        SetBaud = TRUE;
        Advance();

        //
        //  A:
        //
        if ( !Match( "," ) ) {
            goto Eoi;
        }
        Advance();

        if ( !Match( "," ) && Match( "@" ) ) {

            //
            //  Parity
            //
            Parity = ConvertParity( CmdLine->QueryChAt( MatchBegin ) );
            SetParity = TRUE;
            Advance();
        }

        //
        //  B:
        //
        if ( !Match( "," )) {
            goto Eoi;
        }
        Advance();

        if ( Match( "#" )) {

            //
            //  Data bits
            //
            DataBits = ConvertDataBits( GetNumber() );
            SetDataBits = TRUE;
            Advance();
        }

        //
        //  C:
        //
        if ( !Match( "," )) {
            goto Eoi;
        }
        Advance();

        if ( Match( "1.5" ) ) {
            StopBits =  COMM_STOPBITS_15;
            SetStopBits = TRUE;
            Advance();
        } else if ( Match( "#" ) ) {
            StopBits = ConvertStopBits( GetNumber() );
            SetStopBits = TRUE;
            Advance();
        }

        if (!Match( "," )) {
            goto Eoi;
        }

        Advance();

        if ( Match( "x" )) {

            //
            // XON=ON
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = TRUE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_ENABLE;
            RtsControl = RTS_ENABLE;
            Advance();

        } else if ( Match( "p" )) {
            
            //
            // Permanent retry - Hardware handshaking
            //

            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = TRUE;
            Octs        = TRUE;
            DtrControl = DTR_HANDSHAKE;
            RtsControl = RTS_HANDSHAKE;
            Advance();

        } else {

            //
            // XON=OFF
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_ENABLE;
            RtsControl = RTS_ENABLE;
        }

Eoi:
        if ( !EndOfInput() ) {

            //
            //  Error
            //
            ParseError();

        }

    } else {

        //
        //  New syntax, where parameters are tagged. The language assumes
        //  that all parameters are optional (as long as there is at least
        //  one present). If some is required, it is up to the Device
        //  handler to complain latter on.
        //


        while ( !EndOfInput() ) {

            if ( Match( "BAUD=#" ) ) {
                //
                //  BAUD=
                //
                Baud = ConvertBaudRate( GetNumber() );
                SetBaud = TRUE;
                Advance();

            } else if ( Match( "PARITY=@"   ) ) {
                //
                //  PARITY=
                //
                Parity = ConvertParity( CmdLine->QueryChAt( MatchBegin ) );
                SetParity = TRUE;
                Advance();

            } else if ( Match( "DATA=#" ) ) {
                //
                //  DATA=
                //
                DataBits = ConvertDataBits( GetNumber() );
                SetDataBits = TRUE;
                Advance();

            } else if ( Match( "STOP=1.5" ) ) {
                //
                //  STOP=1.5
                //
                StopBits =  COMM_STOPBITS_15;
                SetStopBits = TRUE;
                Advance();

            } else if ( Match( "STOP=#" ) ) {
                //
                //  STOP=
                //
                StopBits = ConvertStopBits( GetNumber() );
                SetStopBits = TRUE;
                Advance();

            } else if ( Match( "RETRY=@" ) ) {
                //
                //  RETRY=
                //
                Retry = ConvertRetry( CmdLine->QueryChAt( MatchBegin ) );
                SetRetry = TRUE;
                Advance();

            } else if ( Match( "TO=ON" ) ) {
                //
                //  TO=ON
                //
                SetTimeOut = TRUE;
                TimeOut    = FALSE;   // FALSE means finite timeout
                Advance();

            } else if ( Match( "TO=OFF" ) ) {
                //
                //  TO=OFF
                //
                SetTimeOut  = TRUE;
                TimeOut     = TRUE;   // TRUE means infinite timeout
                Advance();

            } else if ( Match( "XON=ON" ) ) {
                //
                //  XON=ON
                //
                SetXon  = TRUE;
                Xon     = TRUE;
                Advance();

            } else if ( Match( "XON=OFF" ) ) {
                //
                //  XON=OFF
                //
                SetXon  = TRUE;
                Xon     = FALSE;
                Advance();

            } else if ( Match( "ODSR=ON" ) ) {
                //
                //  ODSR=ON
                //
                SetOdsr = TRUE;
                Odsr    = TRUE;
                Advance();

            } else if ( Match( "ODSR=OFF" ) ) {
                //
                //  ODSR=OFF
                //
                SetOdsr = TRUE;
                Odsr    = FALSE;
                Advance();

            } else if ( Match( "IDSR=ON" ) ) {
                //
                //  IDSR=ON
                //
                SetIdsr = TRUE;
                Idsr    = TRUE;
                Advance();

            } else if ( Match( "IDSR=OFF" ) ) {
                //
                //  IDSR=OFF
                //
                SetIdsr = TRUE;
                Idsr    = FALSE;
                Advance();

            } else if ( Match( "OCTS=ON" ) ) {
                //
                //  OCS=ON
                //
                SetOcts = TRUE;
                Octs    = TRUE;
                Advance();

            } else if ( Match( "OCTS=OFF" ) ) {
                //
                //  OCS=OFF
                //
                SetOcts = TRUE;
                Octs    = FALSE;
                Advance();

            } else if ( Match( "DTR=*"   ) ) {
                //
                //  DTR=
                //
                DtrControl = ConvertDtrControl( CmdLine, MatchBegin, MatchEnd ) ;
                SetDtrControl = TRUE;
                Advance();

            } else if ( Match( "RTS=*"   ) ) {
                //
                //  RTS=
                //
                RtsControl = ConvertRtsControl( CmdLine, MatchBegin, MatchEnd ) ;
                SetRtsControl = TRUE;
                Advance();

            } else {

                ParseError();
            }
        }
    }

    //
    //  Now that parsing is done, we can make the request packet.
    //
    Request = MakeRequest( DEVICE_TYPE_COM,
                           DeviceNumber,
                           REQUEST_TYPE_COM_SET,
                           sizeof(COM_REQUEST ) );

    ComRequest = (PCOM_REQUEST)Request;

    ComRequest->Data.Set.SetBaud        =   SetBaud;
    ComRequest->Data.Set.SetDataBits    =   SetDataBits;
    ComRequest->Data.Set.SetStopBits    =   SetStopBits;
    ComRequest->Data.Set.SetParity      =   SetParity;
    ComRequest->Data.Set.SetRetry       =   SetRetry;
    ComRequest->Data.Set.SetTimeOut     =   SetTimeOut;
    ComRequest->Data.Set.SetXon         =   SetXon;
    ComRequest->Data.Set.SetOdsr        =   SetOdsr;
    ComRequest->Data.Set.SetIdsr        =   SetIdsr;
    ComRequest->Data.Set.SetOcts        =   SetOcts;
    ComRequest->Data.Set.SetDtrControl  =   SetDtrControl;
    ComRequest->Data.Set.SetRtsControl  =   SetRtsControl;


    ComRequest->Data.Set.Baud           =   Baud;
    ComRequest->Data.Set.DataBits       =   DataBits;
    ComRequest->Data.Set.StopBits       =   StopBits;
    ComRequest->Data.Set.Parity         =   Parity;
    ComRequest->Data.Set.Retry          =   Retry;
    ComRequest->Data.Set.TimeOut        =   TimeOut;
    ComRequest->Data.Set.Xon            =   Xon;
    ComRequest->Data.Set.Odsr           =   Odsr;
    ComRequest->Data.Set.Idsr           =   Idsr;
    ComRequest->Data.Set.Octs           =   Octs;
    ComRequest->Data.Set.DtrControl     =   DtrControl;
    ComRequest->Data.Set.RtsControl     =   RtsControl;

    return Request;

}

PREQUEST_HEADER
ConLine (
    )

/*++

Routine Description:

    Takes care of parsing ConLine

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;

    Advance();

    if ( Match( "/STA*" ) || EndOfInput() ) {

        //
        //  Status request
        //
        Request = MakeRequest( DEVICE_TYPE_CON,
                               0,
                               REQUEST_TYPE_STATUS,
                               sizeof( REQUEST_HEADER ) );


    } else if ( Match( "COLS=#" ) || Match( "LINES=#" ) ) {

        //
        //  conrc
        //
        Request = ConRc();

    } else if ( Match( "RATE=#" ) || Match( "DELAY=#" ) ) {

        //
        //  contyp
        //
        Request = ConTyp();

    } else if ( Match( "CP" ) || Match( "CODEPAGE" ) ) {

        //
        //  concp
        //
        Request = ConCp();

    } else {

        //
        //  Error
        //
        ParseError();

    }

    return Request;

}

PREQUEST_HEADER
ConRc (
    )

/*++

Routine Description:

    Takes care of parsing the conrc non-terminal

Arguments:

    None

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    BOOLEAN         SetCol      =   FALSE;
    BOOLEAN         SetLines    =   FALSE;

    ULONG           Col;
    ULONG           Lines;

    while ( !EndOfInput() ) {

        if ( Match( "LINES=#" )) {
            //
            //  LINES=
            //
            Lines = GetNumber();
            SetLines = TRUE;
            Advance();

        } else if ( Match( "COLS=#" )) {
            //
            //  COLS=
            //
            Col = GetNumber();
            SetCol = TRUE;
            Advance();

        } else {

            ParseError();
        }
    }

    //
    //  We are done parsing, we make the request packet.
    //
    Request = MakeRequest( DEVICE_TYPE_CON,
                           0,
                           REQUEST_TYPE_CON_SET_ROWCOL,
                           sizeof(CON_REQUEST ) );

    ConRequest = (PCON_REQUEST)Request;

    ConRequest->Data.RowCol.SetCol      =   SetCol;
    ConRequest->Data.RowCol.SetLines    =   SetLines;
    ConRequest->Data.RowCol.Col         =   Col;
    ConRequest->Data.RowCol.Lines       =   Lines;

    return Request;

}

PREQUEST_HEADER
ConTyp (
    )

/*++

Routine Description:

    Takes care of parsing the contyp non-terminal

Arguments:

    None

Return Value:

    Pointer to the device request.

Notes:

--*/

{
    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    BOOLEAN         SetRate     =   FALSE;
    BOOLEAN         SetDelay    =   FALSE;

    ULONG           Rate;
    ULONG           Delay;


    //
    //  RATE=
    //
    if ( Match( "RATE=#" )) {
        Rate = GetNumber();
        SetRate = TRUE;
        Advance();
    }

    //
    //  DELAY=
    //
    if ( Match( "DELAY=#" )) {
        Delay = GetNumber();
        SetDelay = TRUE;
        Advance();
    }

    if ( !EndOfInput() ) {
        //
        //  Error
        //
        ParseError();
    }

    //
    //  We are don parsing, we make the request packet.
    //
    Request = MakeRequest( DEVICE_TYPE_CON,
                           0,
                           REQUEST_TYPE_CON_SET_TYPEMATIC,
                           sizeof(CON_REQUEST ) );

    ConRequest = (PCON_REQUEST)Request;

    ConRequest->Data.Typematic.SetRate  =   SetRate;
    ConRequest->Data.Typematic.SetDelay =   SetDelay;
    ConRequest->Data.Typematic.Rate     =   Rate;
    ConRequest->Data.Typematic.Delay    =   Delay;

    return Request;

}

PREQUEST_HEADER
ConCp (
    )

/*++

Routine Description:

    Takes care of parsing the concp non-terminal symbol

Arguments:

    None

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    return  CpStuff( DEVICE_TYPE_CON, 0 );

}

PREQUEST_HEADER
VideoLine (
    )

/*++

Routine Description:

    Takes care of parsing the videoline non-terminal symbol

Arguments:

    None.

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    BOOLEAN         SetCol      =   FALSE;
    BOOLEAN         SetLines    =   FALSE;

    ULONG           Col;
    ULONG           Lines;

    //
    //  This is in the old syntax, where parameter are positional
    //  and comma-delimited.
    //
    //  We will use the following automata for parsing the input
    //  (eoi = end of input):
    //
    //          eoi
    //  [Cols]--------->[End]
    //    |         ^
    //    |,        |
    //    v         |
    //   [ ]        |
    //    |         |
    //    |#        |
    //    |         |
    //    v     eoi |
    //  [Lines]-----+
    //


    if ( Match( "#" )) {
        //
        //  Cols
        //
        Col = GetNumber();
        SetCol = TRUE;
        Advance();
    }

    if ( Match( "," ) ) {

        Advance();

        if ( Match( "#" )) {

            Lines = GetNumber();
            SetLines = TRUE;
            Advance();

        } else {

            ParseError();

        }
    }

    if ( !EndOfInput() ) {
        //
        //  Error
        //
        ParseError();
    }


    //
    //  We are done parsing, make the request packet
    //
    Request = MakeRequest( DEVICE_TYPE_CON,
                           0,
                           REQUEST_TYPE_CON_SET_ROWCOL,
                           sizeof(CON_REQUEST ) );

    ConRequest = (PCON_REQUEST)Request;

    ConRequest->Data.RowCol.SetCol      =   SetCol;
    ConRequest->Data.RowCol.SetLines    =   SetLines;
    ConRequest->Data.RowCol.Col         =   Col;
    ConRequest->Data.RowCol.Lines       =   Lines;

    return Request;

}

PREQUEST_HEADER
CpStuff (
    IN  DEVICE_TTYPE DeviceType,
    IN  ULONG        DeviceNumber
    )

/*++

Routine Description:

    Takes care of parsing the cpstuff non-terminal symbol

Arguments:

    DeviceType      -   Supplies device type
    DeviceNumber    -   Supplies device number

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request;
    PCON_REQUEST    ConRequest;

    Advance();

    if ( Match( "PREPARE=*" ) ) {

        //
        //
        //  PREPARE=
        //
        //  This is a No-Op
        //
        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_PREPARE,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match( "SELECT=#" ) ) {

        //
        //
        //  SELECT=
        //
        //  Note that this relies on the fact that codepage requests
        //  are identical for all devices.
        //

        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_SELECT,
                               sizeof( CON_REQUEST ) );

        ConRequest = (PCON_REQUEST)Request;

        ConRequest->Data.CpSelect.Codepage = GetNumber();

    } else if ( Match( "/STA*" ) || EndOfInput() ) {

        //
        //  /STATUS
        //
        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_STATUS,
                               sizeof( REQUEST_HEADER ) );

    } else if ( Match( "REFRESH" ) ) {

        //
        //
        //  REFRESH
        //
        //  This is a No-Op
        //
        Request = MakeRequest( DeviceType,
                               DeviceNumber,
                               REQUEST_TYPE_CODEPAGE_REFRESH,
                               sizeof( REQUEST_HEADER ) );

    } else {

        ParseError();

    }

    return Request;

}

BOOLEAN
AllocateResource(
    )

/*++

Routine Description:

    Allocate strings from the resource

Arguments:

    None.

Return Value:

    None

Notes:

--*/

{

    CmdLine =   NEW DSTRING;

    return (NULL == CmdLine) ? FALSE : TRUE;

}

VOID
DeallocateResource(
    )

/*++

Routine Description:

    Deallocate strings from the resource

Arguments:

    None.

Return Value:

    None

Notes:

--*/

{

    DELETE( CmdLine );

}

BOOLEAN
Match(
    IN  PCSTR   Pattern
    )

/*++

Routine Description:

    This function matches a pattern against whatever
    is in the command line at the current position.

    Note that this does not advance our current position
    within the command line.

    If the pattern has a magic character, then the
    variables MatchBegin and MatchEnd delimit the
    substring of the command line that matched that
    magic character.

Arguments:

    Pattern -   Supplies pointer to the pattern to match

Return Value:

    BOOLEAN -   TRUE if the pattern matched, FALSE otherwise

Notes:

--*/

{

    DSTRING     PatternString;
    BOOLEAN     StatusOk;

    StatusOk = PatternString.Initialize( Pattern );

    DebugAssert( StatusOk );

    if ( StatusOk ) {

        return Match( &PatternString );

    } else {

        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );

    }
    //NOTREACHED
    return StatusOk;
}

BOOLEAN
Match(
    IN  PCWSTRING   Pattern
    )

/*++

Routine Description:

    This function matches a pattern against whatever
    is in the command line at the current position.

    Note that this does not advance our current position
    within the command line.

    If the pattern has a magic character, then the
    variables MatchBegin and MatchEnd delimit the
    substring of the command line that matched that
    magic character.

Arguments:

    Pattern -   Supplies pointer to the pattern to match

Return Value:

    BOOLEAN -   TRUE if the pattern matched, FALSE otherwise

Notes:

--*/

{

    CHNUM   CmdIndex;       //  Index within command line
    CHNUM   PatternIndex;   //  Index within pattern
    WCHAR   PatternChar;    //  Character in pattern
    WCHAR   CmdChar;        //  Character in command line;

    DebugPtrAssert( Pattern );

    CmdIndex        = CharIndex;
    PatternIndex    = 0;

    while ( (PatternChar = Pattern->QueryChAt( PatternIndex )) != INVALID_CHAR ) {

        switch ( PatternChar ) {

        case '#':

            //
            //  Match a number
            //
            MatchBegin = CmdIndex;
            MatchEnd   = MatchBegin;

            //
            //  Get all consecutive digits
            //
            while ( ((CmdChar = CmdLine->QueryChAt( MatchEnd )) != INVALID_CHAR) &&
                    isdigit( (char)CmdChar ) ) {
                MatchEnd++;
            }
            MatchEnd--;

            if ( MatchBegin > MatchEnd ) {
                //
                //  No number
                //
                return FALSE;
            }

            CmdIndex = MatchEnd + 1;
            PatternIndex++;

            break;


        case '@':

            //
            //  Match one character
            //
            if ( CmdIndex >= CmdLine->QueryChCount() ) {
                return FALSE;
            }

            MatchBegin = MatchEnd = CmdIndex;
            CmdIndex++;
            PatternIndex++;

            break;


        case '*':

            //
            //  Match everything up to next blank (or end of input)
            //
            MatchBegin  = CmdIndex;
            MatchEnd    = MatchBegin;

            while ( ( (CmdChar = CmdLine->QueryChAt( MatchEnd )) != INVALID_CHAR )  &&
                    ( CmdChar !=  (WCHAR)' ' ) ) {

                MatchEnd++;
            }
            MatchEnd--;

            CmdIndex = MatchEnd+1;
            PatternIndex++;

            break;

        case '[':

            //
            //  Optional sequence
            //
            PatternIndex++;

            PatternChar = Pattern->QueryChAt( PatternIndex );
            CmdChar     = CmdLine->QueryChAt( CmdIndex );

            //
            //  If the first charcter in the input does not match the
            //  first character in the optional sequence, we just
            //  skip the optional sequence.
            //
            if ( ( CmdChar == INVALID_CHAR ) ||
                 ( CmdChar == ' ')           ||
                 ( towupper(CmdChar) != towupper(PatternChar) ) ) {

                while ( PatternChar != ']' ) {
                    PatternIndex++;
                    PatternChar = Pattern->QueryChAt( PatternIndex );
                }
                PatternIndex++;

            } else {

                //
                //  Since the first character in the sequence matched, now
                //  everything must match.
                //
                while ( PatternChar != ']' ) {

                    if ( towupper(PatternChar) != towupper(CmdChar) ) {
                        return FALSE;
                    }
                    CmdIndex++;
                    PatternIndex++;
                    CmdChar = CmdLine->QueryChAt( CmdIndex );
                    PatternChar = Pattern->QueryChAt( PatternIndex );
                }

                PatternIndex++;
            }

            break;

        default:

            //
            //  Both characters must match
            //
            CmdChar = CmdLine->QueryChAt( CmdIndex );

            if ( ( CmdChar == INVALID_CHAR ) ||
                 ( towupper(CmdChar) != towupper(PatternChar) ) ) {

                return FALSE;

            }

            CmdIndex++;
            PatternIndex++;

            break;

        }
    }

    AdvanceIndex = CmdIndex;

    return TRUE;

}

VOID
Advance(
    )

/*++

Routine Description:

    Advances our pointers to the beginning of the next lexeme

Arguments:

    None

Return Value:

    None


--*/

{

    CharIndex = AdvanceIndex;

    //
    //  Skip blank space
    //
    if ( CmdLine->QueryChAt( CharIndex ) == ' ' ) {

        while ( CmdLine->QueryChAt( CharIndex ) == ' ' ) {

            CharIndex++;
        }

        ParmIndex = CharIndex;

    }
}

VOID
ParseError(
    )

/*++

Routine Description:

    Display Invalid parameter error message and exits

Arguments:

    None

Return Value:

    None


--*/

{
    DSTRING Parameter;
    CHNUM   ParmEnd;

    //
    //  Look for end of parameter
    //
    ParmEnd = CmdLine->Strchr( ' ', ParmIndex );


    Parameter.Initialize( CmdLine,
                          ParmIndex,
                          (ParmEnd == INVALID_CHNUM) ? TO_END : ParmEnd - ParmIndex );

    DisplayMessageAndExit( MODE_ERROR_INVALID_PARAMETER,
                           &Parameter,
                           (ULONG)EXIT_ERROR );

}

PREQUEST_HEADER
MakeRequest(
    IN  DEVICE_TTYPE    DeviceType,
    IN  LONG            DeviceNumber,
    IN  REQUEST_TYPE    RequestType,
    IN  ULONG           Size
    )

/*++

Routine Description:

    Makes a request and initializes its header.

Arguments:

    DeviceType      -   Supplies the type of device
    DeviceNumber    -   Supplies the device number
    RequestType     -   Supplies the type of request
    Size            -   Supplies size of the request packet

Return Value:

    Pointer to the device request.

Notes:

--*/

{

    PREQUEST_HEADER Request;

    DebugAssert( Size >= sizeof( REQUEST_HEADER )) ;

    Request = (PREQUEST_HEADER)MALLOC( (unsigned int)Size );

    DebugPtrAssert( Request );

    if ( !Request ) {
        DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
    }

    Request->DeviceType     =   DeviceType;
    Request->DeviceNumber   =   DeviceNumber;
    Request->DeviceName     =   NULL;
    Request->RequestType    =   RequestType;

    return Request;

}

ULONG
GetNumber(
    )

/*++

Routine Description:

    Converts the substring delimited by MatchBegin and MatchEnd into
    a number.

Arguments:

    None

Return Value:

    ULONG   -   The matched string converted to a number


--*/

{
    LONG    Number;


    DebugAssert( MatchEnd >= MatchBegin );

    if ( !CmdLine->QueryNumber( &Number, MatchBegin, (MatchEnd-MatchBegin)+1 ) ) {
        ParseError();
    }

    return (ULONG)Number;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\common.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Common

Abstract:

	Takes care of request which are common to all devices.

	Also contains any function which is common to two or more devices.

Author:

	Ramon Juan San Andres (ramonsa) 26-Jun-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "mode.hxx"
#include "common.hxx"
#include "com.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "stream.hxx"
#include "system.hxx"
#include "redir.hxx"
#include "registry.hxx"
#include "regvalue.hxx"



BOOLEAN
CommonHandler(
	IN	PREQUEST_HEADER	Request
	)

/*++

Routine Description:

	Calls all the device handlers with the supplied request.

Arguments:

	Request -	Supplies pointer to request

Return Value:

    None.

Notes:

--*/

{

    ULONG                   Device;         //  Current device
    REDIR_STATUS            Status;
    PPATH                   DevicePath;
    REGISTRY                Registry;
    DSTRING                 ParentName;
    DSTRING                 KeyName;
    ARRAY                   ValueArray;
    PARRAY_ITERATOR         Iterator;
    ULONG                   ErrorCode;
    PCBYTE                  Data;
    DSTRING                 PortName;
    DSTRING                 QualifiedName;
    PREGISTRY_VALUE_ENTRY   Value;


	DebugPtrAssert( Request );
	DebugAssert( Request->DeviceType == DEVICE_TYPE_ALL );

	//
	//	If this is not a null request, then we pass this request to all
	//	device handlers. Note that this means that a device handler must
	//	NOT modify the request, otherwise the next device handler would
	//	get a corrupted request.
	//
	if ( Request->RequestType != REQUEST_TYPE_NULL ) {

        //
        //  LPT devices
        //
		for ( Device = 1; Device <= LAST_LPT; Device++ ) {

            if ( IsAValidLptDevice( DEVICE_TYPE_LPT, Device, &DevicePath ) ||
                 REDIR::IsRedirected( &Status, DevicePath )
               ) {

			    Request->DeviceType   = DEVICE_TYPE_LPT;
			    Request->DeviceNumber = Device;

			    //
			    //	Have it serviced
			    //
			    DeviceHandler[ DEVICE_TYPE_LPT ]( Request );
                DELETE( DevicePath );
            }
        }


        //
        //  COM devices
        //
        if ( ParentName.Initialize( "" )            &&
             KeyName.Initialize( COMM_KEY_NAME )    &&
             ValueArray.Initialize()                &&
             Registry.Initialize()                  &&
             Registry.QueryValues(
                        PREDEFINED_KEY_LOCAL_MACHINE,
                        &ParentName,
                        &KeyName,
                        &ValueArray,
                        &ErrorCode
                        ) ) {

            if ( Iterator = (PARRAY_ITERATOR)ValueArray.QueryIterator() ) {

                while ( Value = (PREGISTRY_VALUE_ENTRY)(Iterator->GetNext() ) ) {

                    if ( Value->GetData( &Data ) ) {

                        if ( PortName.Initialize( (PWSTR)Data )     &&
                             QualifiedName.Initialize( L"\\\\.\\" ) &&
                             QualifiedName.Strcat( &PortName ) ) {

                            if ( SYSTEM::QueryFileType( &QualifiedName ) == CharFile ) {

                                Request->DeviceType = DEVICE_TYPE_COM;
                                Request->DeviceName = &PortName;

                                DeviceHandler[ DEVICE_TYPE_COM ]( Request );

                            }
                        }
                    }
                }

                DELETE( Iterator );
            }
        }

        //
        //  CON device
        //
        Request->DeviceType     = DEVICE_TYPE_CON;
        Request->DeviceNumber   = 1;
        DeviceHandler[ DEVICE_TYPE_CON ]( Request );

	}

	return TRUE;
}

BOOLEAN
IsAValidDevice (
    IN  DEVICE_TTYPE     DeviceType,
	IN	ULONG			DeviceNumber,
	OUT	PPATH			*DevicePathPointer
	)

/*++

Routine Description:

	Determines if a certain device exists and optionally creates a path
	for the device.

Arguments:

	DeviceType		-	Supplies the type of device
	DeviceNumber	-	Supplies the device number
	DeviceName		-	Supplies a pointer to a pointer to the path for
						the device.

Return Value:

	BOOLEAN -	TRUE if the device exists,
				FALSE otherwise.

Notes:

--*/

{
    DSTRING     DeviceName;
    DSTRING     QualifiedDeviceName;
    DSTRING     Number;
	CHNUM		Index;
	FILE_TYPE	DriveType;
	PPATH		DevicePath;


	//
	//	Determine what device we're working with.
	//
	switch ( DeviceType ) {

	case DEVICE_TYPE_COM:
		DeviceName.Initialize("COM#");
		break;

	case DEVICE_TYPE_LPT:
		DeviceName.Initialize("LPT#");
		break;

	case DEVICE_TYPE_CON:
		DeviceName.Initialize("CON");
		break;

	default:
		DebugAssert( FALSE );

	}

	//
	//	All devices (except the console) have a device number
	//
	if ( DeviceType != DEVICE_TYPE_CON ) {

		//
		//	Get the device number in string form
		//
		Number.Initialize( DeviceNumber );

		//
		//	Now substitute the matchnumber character with the number
		//
		Index = DeviceName.Strchr( '#'	);
		DebugAssert( Index != INVALID_CHNUM );

        DeviceName.Replace( Index, 1, &Number );

	}

	//
	//	We have the device name, gets its type.
    //
    QualifiedDeviceName.Initialize( "\\\\.\\" );
    QualifiedDeviceName.Strcat( &DeviceName );

    DriveType = SYSTEM::QueryFileType( &QualifiedDeviceName );

	//
	//	If the caller wants a path, make it.
	//
	if ( DevicePathPointer ) {

		DevicePath = NEW PATH;
		DebugPtrAssert( DevicePath );

		if ( DevicePath ) {

			DevicePath->Initialize( &DeviceName );

		}

		*DevicePathPointer = DevicePath;
	}

	//
	//	Now return whether the device is valid or not
	//
	return DriveType == CharFile;

}

BOOLEAN
WriteStatusHeader (
	IN	PCPATH		DevicePath
	)

/*++

Routine Description:

	Write the header for a status block.

Arguments:

	DevicePath	-	Supplies the device path

Return Value:

	BOOLEAN -	TRUE if header written
				FALSE otherwise.

Notes:

--*/

{

	PWSTRING	Header;
	CHNUM		Index;

	Header	=	QueryMessageString( MODE_MESSAGE_STATUS );

	if ( !Header ) {

		DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );

	}

	//
	//	Replace the match-all character in the header with the device
	//	path.
	//
	Index = Header->Strchr( '*' );
	DebugAssert( Index != INVALID_CHNUM );

    Header->Replace( Index, 1, DevicePath->GetPathString() );

	//
	//	Display the header
	//
	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );
	Get_Standard_Output_Stream()->WriteString( Header );
	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );

	//
	//	Underline it
    //
    for (Index = 0; Index < Header->QueryChCount(); Index++) {
        Header->SetChAt( '-', Index );
    }
	Get_Standard_Output_Stream()->WriteString( Header );
	Get_Standard_Output_Stream()->WriteChar( '\r' );
	Get_Standard_Output_Stream()->WriteChar( '\n' );

	DELETE( Header );

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\more\argument.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Argument

Abstract:

    Argument processing for the "MORE" pager

Author:

    Ramon Juan San Andres (ramonsa) 24-Apr-1990

Notes:

    The arguments accepted  by the more pager are:

    Extended mode switch.-  This allows all other options. Without this
                            switch, no other options are allowed.

    Help switch.-           Displays usage.

    ClearScreen switch.-    Clears the screen before displaying each page.

    SqueezeBlank switch.-   Squeezes consecutive blank lines into a single
                            line.

    ExpandFormFeed switch.- FormFeeds are expanded to fill the rest of
                            the screen.

    Start at line.-         Paging starts at the specified line of the
                            first file.

    Tab expansion.-         Expand tabs to this number of blanks

    File list.-             List of files to page.


    The more pager obtains its arguments from two sources:

    1.- An environment variable ( "MORE" )
    2.- The command line.

    The environment variable may specify any options, except a file
    list.

Revision History:


--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "rtmsg.h"
#include "path.hxx"
#include "smsg.hxx"
#include "system.hxx"
#include "more.hxx"

#define ENABLE_EXTENSIONS_VALUE  L"EnableExtensions"
#define COMMAND_PROCESSOR_KEY    L"Software\\Microsoft\\Command Processor"

//
//  Static variables
//
//
PFLAG_ARGUMENT      ExtendedModeArgument;
PFLAG_ARGUMENT      ClearScreenArgument;
PFLAG_ARGUMENT      ExpandFormFeedArgument;
PFLAG_ARGUMENT      SqueezeBlanksArgument;
PFLAG_ARGUMENT      Help1Argument;
PFLAG_ARGUMENT      Help2Argument;
PLONG_ARGUMENT      StartAtLineArgument;
PLONG_ARGUMENT      TabExpArgument;



VOID
MORE::SetArguments(
    )

/*++

Routine Description:

    Obtains the arguments for the "more" pager.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    FLAG_ARGUMENT       LocalExtendedModeArgument;
    FLAG_ARGUMENT       LocalClearScreenArgument;
    FLAG_ARGUMENT       LocalExpandFormFeedArgument;
    FLAG_ARGUMENT       LocalSqueezeBlanksArgument;
    FLAG_ARGUMENT       LocalHelp1Argument;
    FLAG_ARGUMENT       LocalHelp2Argument;
    LONG_ARGUMENT       LocalStartAtLineArgument;
    LONG_ARGUMENT       LocalTabExpArgument;

    ExtendedModeArgument     = &LocalExtendedModeArgument;
    ClearScreenArgument      = &LocalClearScreenArgument;
    ExpandFormFeedArgument   = &LocalExpandFormFeedArgument;
    SqueezeBlanksArgument    = &LocalSqueezeBlanksArgument;
    Help1Argument            = &LocalHelp1Argument;
    Help2Argument            = &LocalHelp2Argument;
    StartAtLineArgument      = &LocalStartAtLineArgument;
    TabExpArgument           = &LocalTabExpArgument;

    //
    //  Get arguments from the environment variable
    //
    GetArgumentsMore();

    //
    //  Get the arguments from the command line.
    //
    GetArgumentsCmd();

    //
    // Determine if there is a need to enable command extension
    //
    GetRegistryInfo();

    //
    //  Verify the arguments
    //
    CheckArgumentConsistency();

}

VOID
MORE::GetArgumentsMore(
    )

/*++

Routine Description:

    Obtains the arguments from the "More" environment variable.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    ARRAY               ArgArray;
    PWSTRING            MoreVariableName;
    PWSTRING            MoreVariableValue;

    //
    //  Get the name of the MORE environment variable and the argument
    //
    if ( (MoreVariableName  = QueryMessageString( MORE_ENVIRONMENT_VARIABLE_NAME )) == NULL ) {

        Fatal();
    }

    //
    //  Get the value of the MORE environment variable.
    //
    MoreVariableValue = SYSTEM::QueryEnvironmentVariable( MoreVariableName );

    if ( MoreVariableValue != NULL ) {

        //
        //  Now prepare for parsing
        //
        if ( //
             // Initialize tha arguments
             //
             !(ArgArray.Initialize( 7, 7 ))                 ||
             !(ExtendedModeArgument->Initialize( "/E" ))    ||
             !(ClearScreenArgument->Initialize( "/C" ))     ||
             !(ExpandFormFeedArgument->Initialize( "/P" ))  ||
             !(SqueezeBlanksArgument->Initialize( "/S" ))   ||
             !(Help1Argument->Initialize( "/?" ))           ||
             !(Help2Argument->Initialize( "/H" ))           ||
             !(StartAtLineArgument->Initialize( "+*" ))     ||
             !(TabExpArgument->Initialize( "/t*" ))         ||
             //
             // Put the arguments in the argument array
             //
             !(ArgArray.Put( ExtendedModeArgument ))        ||
             !(ArgArray.Put( ClearScreenArgument ))         ||
             !(ArgArray.Put( ExpandFormFeedArgument ))      ||
             !(ArgArray.Put( SqueezeBlanksArgument ))       ||
             !(ArgArray.Put( Help1Argument ))               ||
             !(ArgArray.Put( Help2Argument ))               ||
             !(ArgArray.Put( StartAtLineArgument ))         ||
             !(ArgArray.Put( TabExpArgument ))
             ) {

            Fatal();
        }

        //
        //  Parse the arguments
        //
        ParseArguments( MoreVariableValue, &ArgArray );

        //
        //  Set the global structures
        //
        _ExtendedModeSwitch     =   ExtendedModeArgument->QueryFlag();
        _ClearScreenSwitch      =   ClearScreenArgument->QueryFlag();
        _ExpandFormFeedSwitch   =   ExpandFormFeedArgument->QueryFlag();
        _SqueezeBlanksSwitch    =   SqueezeBlanksArgument->QueryFlag();
        _HelpSwitch             =   (BOOLEAN)(Help1Argument->QueryFlag() || Help2Argument->QueryFlag());
        if ( StartAtLineArgument->IsValueSet() ) {
            _StartAtLine = StartAtLineArgument->QueryLong();
        }
        if ( TabExpArgument->IsValueSet() ) {
            _TabExp = TabExpArgument->QueryLong();
        }

        //
        //  Clean up
        //
        DELETE( MoreVariableValue );
    }

    DELETE( MoreVariableName );

}

VOID
MORE::GetArgumentsCmd(
    )

/*++

Routine Description:

    Obtains the arguments from the Command line

Arguments:

    None.

Return Value:

    None

Notes:

--*/

{

    ARRAY               ArgArray;
    DSTRING             CmdLine;
    PATH_ARGUMENT       ProgramNameArgument;

    //
    //  Prepare for parsing
    //
    if (//
        //  Initialize the arguments
        //
        !(CmdLine.Initialize( GetCommandLine() ))                       ||
        !(ArgArray.Initialize( 9, 9 ))                                  ||
        !(ProgramNameArgument.Initialize( "*" ))                        ||
        !(ExtendedModeArgument->Initialize( "/E" ))                     ||
        !(ClearScreenArgument->Initialize( "/C" ))                      ||
        !(ExpandFormFeedArgument->Initialize( "/P" ))                   ||
        !(SqueezeBlanksArgument->Initialize( "/S" ))                    ||
        !(Help1Argument->Initialize( "/?" ))                            ||
        !(Help2Argument->Initialize( "/H" ))                            ||
        !(StartAtLineArgument->Initialize( "+*" ))                      ||
        !(TabExpArgument->Initialize( "/t*" ))                          ||
         ((_FilesArgument = NEW MULTIPLE_PATH_ARGUMENT) == NULL)        ||
        !(_FilesArgument->Initialize( "*", TRUE, TRUE ))                ||

        //
        //  Put the arguments in the argument array
        //
        !(ArgArray.Put( &ProgramNameArgument ))                         ||
        !(ArgArray.Put( ExtendedModeArgument ))                         ||
        !(ArgArray.Put( ClearScreenArgument ))                          ||
        !(ArgArray.Put( ExpandFormFeedArgument ))                       ||
        !(ArgArray.Put( SqueezeBlanksArgument ))                        ||
        !(ArgArray.Put( Help1Argument ))                                ||
        !(ArgArray.Put( Help2Argument ))                                ||
        !(ArgArray.Put( StartAtLineArgument ))                          ||
        !(ArgArray.Put( TabExpArgument ))                               ||
        !(ArgArray.Put( _FilesArgument )) ) {

        Fatal();
    }

    //
    //  Parse the arguments
    //
    ParseArguments( &CmdLine, &ArgArray );

    //
    //  Set the global structures
    //
    _ExtendedModeSwitch     |=  ExtendedModeArgument->QueryFlag();
    _ClearScreenSwitch      |=  ClearScreenArgument->QueryFlag();
    _ExpandFormFeedSwitch   |=  ExpandFormFeedArgument->QueryFlag();
    _SqueezeBlanksSwitch    |=  SqueezeBlanksArgument->QueryFlag();
    _HelpSwitch             |=  Help1Argument->QueryFlag() || Help2Argument->QueryFlag();

    if ( StartAtLineArgument->IsValueSet() ) {
        _StartAtLine = StartAtLineArgument->QueryLong();
    }
    if ( TabExpArgument->IsValueSet() ) {
        _TabExp = TabExpArgument->QueryLong();
    }

}

VOID
MORE::ParseArguments(
    IN  PWSTRING    CmdLine,
    OUT PARRAY      ArgArray
    )

/*++

Routine Description:

    Parses a group of arguments

Arguments:

    CmdLine     -   Supplies pointer to a command line to parse
    ArgArray    -   Supplies pointer to array of arguments

Return Value:

    none

Notes:

--*/

{
    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    PWSTRING            InvalidParameter;

    //
    //  Initialize lexeme array and the lexemizer.
    //
    if ( !(LexArray.Initialize( 8, 8 ))                                                   ||
         !(ArgLex.Initialize( &LexArray )) ) {

        Fatal();

    }

    //
    //  Set our parsing preferences
    //
    ArgLex.PutMultipleSwitch( "/ECPSH?" );
    ArgLex.PutSwitches( "/" );
    ArgLex.PutSeparators( " /\t" );
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );

    //
    //  Parse the arguments
    //
    if ( !(ArgLex.PrepareToParse( CmdLine ))) {

        Fatal(  EXIT_ERROR, MORE_ERROR_GENERAL, "" );

    }

    if ( !ArgLex.DoParsing( ArgArray ) ) {

        _Message.Set(MSG_INVALID_PARAMETER);
        _Message.Display("%W", InvalidParameter = ArgLex.QueryInvalidArgument() );
        DELETE(InvalidParameter);
        ExitProcess( 0 );
    }

    LexArray.DeleteAllMembers( );


}

VOID
MORE::CheckArgumentConsistency (
    )

/*++

Routine Description:

    Checks the consistency of the arguments

Arguments:

    none

Return Value:

    none

Notes:

--*/

{

    BOOLEAN     ExtendedSwitches;

    if ( _HelpSwitch ) {

        //
        //  Help wanted
        //
        Usage();
    }

    ExtendedSwitches =  (BOOLEAN)( _ClearScreenSwitch                           ||
                                   _ExpandFormFeedSwitch                        ||
                                   _SqueezeBlanksSwitch                         ||
                                   TabExpArgument->IsValueSet()                 ||
                                   ( _StartAtLine > (LONG)0 )                   ||
                                   _FilesArgument->WildCardExpansionFailed()    ||
                                   ( _FilesArgument->QueryPathCount() > (ULONG)0));

    //
    //  If the "extended" flag was not specified, then no other argument
    //  is allowed.
    //
    if ( !_ExtendedModeSwitch   &&
         ExtendedSwitches ) {

        Fatal( EXIT_ERROR, MORE_ERROR_TOO_MANY_ARGUMENTS, "" );

    }

    //
    //  Error out if invalid file specified
    //
    if ( _FilesArgument->WildCardExpansionFailed() ) {
        Fatal(  EXIT_ERROR, MORE_ERROR_CANNOT_ACCESS, "%W", _FilesArgument->GetLexemeThatFailed() );
    }

}

VOID
MORE::GetRegistryInfo(
    )
{
    ULONG   valueType;
    DWORD   value;
    ULONG   valueLength = sizeof(value);
    HKEY    key;
    LONG    status;


    if (_ExtendedModeSwitch)
        return;

    status = RegOpenKeyEx(HKEY_CURRENT_USER,
                          COMMAND_PROCESSOR_KEY,
                          0,
                          KEY_READ,
                          &key);

    if (status != ERROR_SUCCESS) {
        return;
    }

    status = RegQueryValueEx(key,
                             ENABLE_EXTENSIONS_VALUE,
                             NULL,
                             &valueType,
                             (LPBYTE)&value,
                             &valueLength);

    if (status != ERROR_SUCCESS ||
        valueType != REG_DWORD ||
        valueLength != sizeof(DWORD)) {
        RegCloseKey(key);
        return;
    }
    _ExtendedModeSwitch = (BOOLEAN)value;

    RegCloseKey(key);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\support.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Support

Abstract:

	Miscelaneous support functions for the XCopy directory copy
	utility.  All functions that are not involved directly in the
	copy process go here.

Author:

	Ramon Juan San Andres (ramonsa) 02-May-1991

Revision History:

--*/



#include "mode.hxx"
//#include "ulib.hxx"
#include "system.hxx"
//#include "mode.hxx"





VOID
DisplayMessage (
	IN	MSGID				MsgId,
    IN  PCWSTRING           String
	)

/*++

Routine Description:

	Displays a message, with an optional parameter

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.

Return Value:

    None.

Notes:

--*/

{


	if (MsgId != 0) {
		Message->Set( MsgId );

		if ( String == NULL ) {
			//
			//	The message has no parameters
			//
			Message->Display( "" );

		} else {

			//
			//	Display it.
			//
			Message->Display( "%W", String );
		}
	}

}


VOID
DisplayMessageAndExit (
	IN	MSGID				MsgId,
    IN  PCWSTRING           String,
	IN	ULONG				ExitCode
	)

/*++

Routine Description:

	Displays a message and exits the program with the supplied error code.
	We support a maximum of one string parameter for the message.

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.
	ExitCode	-	Supplies the exit code with which to exit.

Return Value:

    None.

Notes:

--*/

{

	DisplayMessage( MsgId, String );

	ExitMode( ExitCode );

}

PWSTRING
QueryMessageString (
	IN MSGID	MsgId
	)
/*++

Routine Description:

	Obtains a string object initialized to the contents of some message

Arguments:

	MsgId	-	Supplies ID of the message

Return Value:

	PWSTRING	-	Pointer to initialized string object

Notes:

--*/

{

	PWSTRING	String;

    if ( ((String = NEW DSTRING) == NULL )  ||
		 !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

		DisplayMessageAndExit( MODE_ERROR_NO_MEMORY, NULL, (ULONG)EXIT_ERROR );
	}

	return String;

}

VOID
ExitWithError(
	IN	DWORD		ErrorCode
	)

/*++

Routine Description:

	Displays a message based on a WIN32 error code, and exits.

Arguments:

	ErrorCode	-	Supplies Windows error code

Return Value:

	none

--*/

{
	Message->Set( MODE_ERROR_EXTENDED );
	Message->Display( "%d", ErrorCode );
	ExitMode( (ULONG)EXIT_ERROR );
}

VOID
ExitMode(
	IN	DWORD	ExitCode
	)

/*++

Routine Description:

	Exits the program

Arguments:

	ExitCode	-	Supplies the exit code

Return Value:

	none

--*/

{
	exit( (int)ExitCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=mode
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\common.cxx      \
        ..\com.cxx         \
        ..\cons.cxx        \
        ..\lpt.cxx         \
        ..\redir.cxx       \
        ..\support.cxx     \
        ..\mode.cxx        \
        ..\mode.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ureg\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

UMLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
       ..\..\ureg\src\$(ALT_PROJECT)\$(O)\ureg.lib \
       $(SDK_LIB_PATH)\user32.lib \
       $(SDK_LIB_PATH)\ntdll.lib

USE_MSVCRT=1

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mode\redir.cxx ===
#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "redir.hxx"


//
//  The string below represents the path used to determine whether or not
//  an LPT device is redirected to a COM device.
//  Due to performance, this path should always be defined in upper case.
//

#define LPT_REDIRECTION_PATH    (LPWSTR)L"\\??\\COM"




BOOLEAN
REDIR::Redirect (
    IN PCPATH   Device,
    IN PCPATH   Destination
    )

/*++

Routine Description:

    Redirects a device.  The device is redirected by creating a symbolic link
    to the destination device. If this is the first redirection of the device,
    the original symbolic link is saved in the registry under a volatile key
    so that it can be recovered latter on.

    Note that redirection requires sufficient privileges to create symbolic
    links and to create entries in the registry under SAVE_ROOT.

Arguments:

    Device      -   Supplies the device to be redirected.

    Destination -   Supplies the device to be redirected to

Return Value:

    BOOLEAN -   TRUE if the device was successfully redirected.
                FALSE otherwise.

--*/

{
    BOOLEAN         Redirected  = FALSE;
    PCWSTRING       DeviceName;
    PCWSTRING       DestinationName;


    DebugPtrAssert( Device );
    DebugPtrAssert( Destination );

    if( ( Device != NULL ) &&
        ( Destination != NULL ) &&
        ( ( DeviceName = Device->GetPathString() ) != NULL ) &&
        ( ( DestinationName = Destination->GetPathString() ) != NULL )
      ) {

        Redirected = DefineDosDevice( 0,
                                      DeviceName->GetWSTR(),
                                      DestinationName->GetWSTR() ) ? TRUE : FALSE;

#if DBG
        if( !Redirected ) {
            DebugPrint( "MODE: DefineDosDevice() failed" );
            DebugPrintTrace(( "MODE: DefineDosDevice() failed, Device = %ls, Destination = %ls, Error = %d \n",
                       DeviceName->GetWSTR(),
                       DestinationName->GetWSTR(),
                       GetLastError() ));
        }
#endif

    }
    return Redirected;
}




BOOLEAN
REDIR::IsRedirected (
    OUT PREDIR_STATUS   Status,
    IN  PCPATH          Device,
    IN  PCPATH          Destination
    )

/*++

Routine Description:

    Determines if a device is being redirected to a specific device.

Arguments:

    Status      -   Supplies pointer to redirection status. Only set in
                    if the return value of this method is FALSE

    Device      -   Supplies the device about which we want to find out if
                    it is redirected or not.

    Destination -   Supplies a pointer to a destination device.

Return Value:

    TRUE if the device is redirected to the destination
    FALSE otherwise

--*/

{
    BOOLEAN         Redirected  = FALSE;
    PCWSTRING       DeviceName;
    PCWSTRING       DestinationName;
    DSTRING         DstRedir;
    FSTRING         LptRedirectionPath;
    DSTRING         TmpString;
    WCHAR           buf[ 2*(MAX_PATH + 1) ];
    PWSTR           pwstrTarget;

    DebugPtrAssert( Device );

    *Status = REDIR_STATUS_ERROR;

    if (NULL == (DeviceName = Device->GetPathString())) {
        return FALSE;
    }

    if (!QueryDosDevice(DeviceName->GetWSTR(),
                       buf,
                       sizeof(buf) / sizeof(WCHAR))) {

        //  The device probably doesn't exist

        return FALSE;
    }

    *Status = REDIR_STATUS_NONEXISTENT;

    pwstrTarget = buf;

    //  Find out if the LPT device is redirected to the destination.

    DstRedir.Initialize(pwstrTarget);

    return INVALID_CHNUM != DstRedir.Strstr(Destination->GetPathString());
}

BOOLEAN
REDIR::IsRedirected (
    OUT PREDIR_STATUS   Status,
    IN  PCPATH          Device
    )

/*++

Routine Description:

    Determines if a device is being redirected to any device.

Arguments:

    Status      -   Supplies pointer to redirection status. Only set in
                    if the return value of this method is FALSE

    Device      -   Supplies the device about which we want to find out if
                    it is redirected or not.

Return Value:

    TRUE if redirected, FALSE otherwise.

--*/

{
    BOOLEAN         Redirected  = FALSE;
    PCWSTRING       DeviceName;
    PCWSTRING       DestinationName;
    DSTRING         DstRedir;
    FSTRING         LptRedirectionPath;
    DSTRING         TmpString;
    WCHAR           Buffer[ 2*(MAX_PATH + 1) ];
    PWSTR           Pointer;
    PPATH           Destination = NULL;

    DebugPtrAssert( Device );

    *Status = REDIR_STATUS_ERROR;

    if( ( Device != NULL ) &&
        ( ( DeviceName = Device->GetPathString() ) != NULL ) ) {

        if( QueryDosDevice( DeviceName->GetWSTR(),
                            Buffer,
                            sizeof( Buffer ) / sizeof( WCHAR ) ) == 0 ) {
            //
            //  The device probably doesn't exist
            //

            return( FALSE );
        }


        //
        // At this point we know that the device exists.
        // Assume that the device is not redirected.
        //

        *Status = REDIR_STATUS_NONEXISTENT;

        Pointer = Buffer;

        LptRedirectionPath.Initialize( LPT_REDIRECTION_PATH );

        //
        //  Find out if the LPT device is redirected to a COM device
        //

        while( ( *Pointer != ( WCHAR )'\0' ) &&
               DstRedir.Initialize( Pointer ) &&
               ( DstRedir.Strupr() != NULL ) &&
               !Redirected ) {

            if( DstRedir.Strstr( &LptRedirectionPath ) != INVALID_CHNUM ) {
                //
                // The LPT device is redirected to a COM device
                //
                if( Destination != NULL ) {
                    if( ( ( DestinationName = Destination->GetPathString() ) != NULL ) &&
                        ( DstRedir.Strstr( DestinationName ) != INVALID_CHNUM ) ) {
                        Redirected = TRUE;
                    }
                } else {
                    Redirected = TRUE;
                }
            }
            Pointer +=  DstRedir.QueryChCount() + 1;
        }
    }

    return Redirected;
}




BOOLEAN
REDIR::EndRedirection (
    IN PCPATH   Device
    )

/*++

Routine Description:

    Ends the redirection of a device

Arguments:

    Device      -   Supplies the device


Return Value:


    TRUE if the device's redirection has ended.
    FALSE otherwise


--*/

{
    BOOLEAN         Done        = FALSE;
    PCWSTRING       DeviceName;
    REDIR_STATUS    Status;



    DebugPtrAssert( Device );

    if( IsRedirected( &Status, Device ) ) {
        if( ( Device != NULL ) &&
            ( ( DeviceName = Device->GetPathString() ) != NULL ) ) {

            Done = DefineDosDevice( DDD_REMOVE_DEFINITION /* | DDD_RAW_TARGET_PATH */,
                                    DeviceName->GetWSTR(),
                                    NULL ) ? TRUE : FALSE;

#if DBG
            if( !Done ) {
                DebugPrint( "MODE: DefineDosDevice() failed" );
                DebugPrintTrace(( "MODE: DefineDosDevice() failed, Device = %ls, Destination = %ls, Error = %d \n",
                           DeviceName->GetWSTR(),
                           LPT_REDIRECTION_PATH,
                           GetLastError() ));
            }
#endif
        }
    }
    return Done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\more\more.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        More.cxx

Abstract:

        "More" pager

Author:

        Ramon Juan San Andres (ramonsa) 11-Apr-1990

Revision History:

--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "keyboard.hxx"
#include "rtmsg.h"
#include "pager.hxx"
#include "path.hxx"
#include "smsg.hxx"
#include "system.hxx"
#include "more.hxx"

#define DEFAULT_TABEXP  8

#define         NULL_CHARACTER                  ((CHAR)'\0')
#define         CTRLC_CHARACTER                 ((CHAR)0x03)



VOID __cdecl
main (
        )

/*++

Routine Description:

        Main function of the more pager.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/


{

    // Initialize stuff
    //
    DEFINE_CLASS_DESCRIPTOR( MORE );

    //
    // Now do the paging
    //
    {
        MORE More;

        //
        // Initialize the MORE object.
        //
        if( More.Initialize() ) {

            //
            // Do the paging
            //
            More.DoPaging();
        }
    }
}

DEFINE_CONSTRUCTOR( MORE,       PROGRAM );



BOOLEAN
MORE::Initialize (
        )

/*++

Routine Description:

        Initializes the MORE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Initialize program object
        //
        if( !PROGRAM::Initialize( MORE_MESSAGE_USAGE, MORE_ERROR_NO_MEMORY,  EXIT_ERROR ) ) {

            return FALSE;
        }

        //
        //      Initialize whatever needs initialization
        //
        InitializeThings();

        //
        //      Do the argument parsing
        //
        SetArguments();

        return TRUE;

}

VOID
MORE::Construct (
    )
/*++

Routine Description:

        Construct a MORE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    _Keyboard = NULL;

    _FilesArgument = NULL;
    _LineDelimiters = NULL;
    _Percent = NULL;
    _Line = NULL;
    _Help = NULL;
    _DisplayLinesOption = NULL;
    _SkipLinesOption = NULL;
    _NextFileOption = NULL;
    _ShowLineNumberOption = NULL;
    _QuitOption = NULL;
    _Help1Option = NULL;
    _Help2Option = NULL;
}

MORE::~MORE (
        )

/*++

Routine Description:

        Destructs a MORE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Deallocate the global structures previously allocated
        //
        DeallocateThings();

        //
        //      Exit without error
        //
        exit( EXIT_NORMAL );

}

VOID
MORE::InitializeThings (
        )

/*++

Routine Description:

        Initializes the global variables that need initialization

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    if ( //
         // Initialize the library
         //
         !(_Keyboard = NEW KEYBOARD)


       ) {

                exit( EXIT_ERROR );

         }

    // MORE translates from MBCS to Unicode according to the
    // current console codepage.
    //
    WSTRING::SetConsoleConversions();

    if ( //
         // Pager stuff
         //
         !DEFINE_CLASS_DESCRIPTOR( PAGER )          ||
         //
         // Misc. Strings
         //
         ((_LineDelimiters = NEW DSTRING) == NULL ) ||
         !_LineDelimiters->Initialize( "\r\n" )     ||
         ((_Percent = NEW DSTRING) == NULL )        ||
         ((_Line    = NEW DSTRING) == NULL )        ||
         ((_OtherPrompt = NEW DSTRING) == NULL )
        ) {

                Fatal();

        }

        //
        //      Get the strings containing valid user options
        //
        if ( (( _Help                            = QueryMessageString( MORE_HELP )) ==  NULL )                                  ||
                 (( _DisplayLinesOption  = QueryMessageString( MORE_OPTION_DISPLAYLINES )) == NULL )    ||
                 (( _SkipLinesOption     = QueryMessageString( MORE_OPTION_SKIPLINES )) == NULL )               ||
                 (( _NextFileOption              = QueryMessageString( MORE_OPTION_NEXTFILE )) == NULL )                ||
                 (( _ShowLineNumberOption = QueryMessageString( MORE_OPTION_SHOWLINENUMBER )) == NULL ) ||
                 (( _QuitOption                  = QueryMessageString( MORE_OPTION_QUIT )) == NULL )                    ||
                 (( _Help1Option                 = QueryMessageString( MORE_OPTION_HELP1 )) == NULL )                   ||
                 (( _Help2Option                 = QueryMessageString( MORE_OPTION_HELP2 )) == NULL ) ) {

                Fatal();
        }

        _Keyboard->Initialize();
        _Quit                                   =       FALSE;
        _ExtendedModeSwitch     =       FALSE;
        _ClearScreenSwitch              =       FALSE;
        _ExpandFormFeedSwitch   =       FALSE;
        _SqueezeBlanksSwitch    =       FALSE;
        _HelpSwitch                     =       FALSE;
        _StartAtLine                    =       0;
        _TabExp                         =       DEFAULT_TABEXP;
        _FilesArgument                  =       NULL;

}

VOID
MORE::DeallocateThings (
        )

/*++

Routine Description:

        Deallocates the global variables that need deallocation

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        DELETE( _Keyboard );

        DELETE( _FilesArgument );
        DELETE( _LineDelimiters );
        DELETE( _Percent );
        DELETE( _Line );
        DELETE( _Help );

        //
        //      Delete the strings containing valid user options
        //
        DELETE( _DisplayLinesOption );
        DELETE( _SkipLinesOption );
        DELETE( _NextFileOption );
        DELETE( _ShowLineNumberOption );
        DELETE( _QuitOption );
        DELETE( _Help1Option );
        DELETE( _Help2Option );

}

VOID
MORE::DoPaging (
        )

/*++

Routine Description:

        Does the paging.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    PPATH        Path;
    PITERATOR    Iterator;
    BOOLEAN      IsFirstFile = TRUE;
    ULONG        FilesLeft;
    PFSN_FILE    FsnFile;
    PFILE_STREAM FileStream;

    FilesLeft = _FilesArgument->QueryPathCount();

    if ( FilesLeft > 0 ) {

        //
        //  We have a list of files, we will page each one in turn
        //
        //  Get an iterator for going thru the file list
        //
        if ((Iterator = _FilesArgument->GetPathArray()->QueryIterator()) == NULL ) {

            Fatal();
        }

        Path = (PPATH)Iterator->GetNext();

        //
        //  Iterate thru all the files in the array
        //
        while ( Path && !_Quit) {

            //
            //  Get a new stream out of the file name
            //
            if ((FsnFile = SYSTEM::QueryFile( Path )) == NULL ||
                (FileStream = FsnFile->QueryStream( READ_ACCESS )) == NULL ) {
                Fatal(  EXIT_ERROR, MORE_ERROR_CANNOT_ACCESS, "%W", Path->GetPathString() );
            }

            PageStream( FileStream,
                        FsnFile,
                        IsFirstFile ? _StartAtLine : 0, --FilesLeft );

            DELETE( FileStream );
            DELETE( FsnFile );

            Path        = (PPATH)Iterator->GetNext();
            IsFirstFile = FALSE;
        }

        DELETE( Iterator );

    } else {

        //
        //  The user did'nt specify a file list, so we will page
        //  standard input.
        //
        PageStream( GetStandardInput(),
                    NULL,
                    _StartAtLine,
                    0 );
    }
}

VOID
MORE::PageStream (
        IN PSTREAM              Stream,
        IN PFSN_FILE    FsnFile,
        IN ULONG                FirstLineToDisplay,
        IN ULONG                FilesLeft
        )

/*++

Routine Description:

        Pages a stream

Arguments:

        Stream                          -       Supplies pointer to stream
        FsnFile                         -       Supplies pointer to file object
        FirstLineToDisplay      -       Supplies first line to display
        FilesLeft                       -       Files remaining to be displayed

Return Value:

    None.

Notes:

--*/

{

        PAGER   Pager;
        ULONG   LinesToDisplay;
        BOOLEAN ClearScreen;
        BOOLEAN StayInFile;

        //
        //      Initialize the pager
        //
        if (!Pager.Initialize( Stream,  this)) {

                Fatal();

        }

        //
        //      Skip to the first line to be displayed
        //
        if ( FirstLineToDisplay > 0 ) {
                Pager.SkipLines( FirstLineToDisplay, _TabExp );
        }

        LinesToDisplay  = Pager.QueryLinesPerPage() - 1;
        ClearScreen     = _ClearScreenSwitch;
        StayInFile              = TRUE;

        while (StayInFile && Pager.ThereIsMoreToPage() && !_Quit) {

            // If QueryLinesPerPage() returns 0 then undo the -1 operation.

            if (LinesToDisplay == (ULONG) -1) {
                LinesToDisplay = 0;
            }

                //
                //      Display a group of lines
                //
                Pager.DisplayPage( LinesToDisplay,
                                   ClearScreen,
                                   _SqueezeBlanksSwitch,
                                   _ExpandFormFeedSwitch,
                                   _TabExp );

                //
                //      If not at end of stream, we wait for an option
                //
                if (Pager.ThereIsMoreToPage() || (FilesLeft > 0)) {

                        StayInFile = DoOption( FsnFile, &Pager, &LinesToDisplay, &ClearScreen );
                }
        }
}

BOOLEAN
MORE::DoOption (
        IN      PFSN_FILE       FsnFile,
        IN      PPAGER          Pager,
        OUT PULONG              LinesInPage,
        OUT PBOOLEAN    ClearScreen
        )

/*++

Routine Description:

        Gets an option from the user

Arguments:

        FsnFile                 -       Supplies pointer to file object
        Pager                   -       Supplies pointer to pager
        LinesInpage             -       Supplies pointer to lines to display in next page
        ClearScreen             -       Supplies pointer to Clearscreen flag.

Return Value:

        TRUE  if paging should continue for this file,
        FALSE otherwise

--*/

{

    WCHAR       Char;
    DSTRING     String;
    BOOLEAN     ShowLineNumber = FALSE;
    BOOLEAN     ShowHelp       = FALSE;
    LONG        Number;


        String.Initialize( " " );

        while ( TRUE ) {

                //
                //      Display prompt
                //
                Prompt( FsnFile, Pager, ShowLineNumber, ShowHelp, 0 );

                ShowHelp                = FALSE;
                ShowLineNumber  = FALSE;

                //
                //      Get option from the user
                //
                _Keyboard->DisableLineMode();
                _Keyboard->ReadChar( &Char );
                _Keyboard->EnableLineMode();
                String.SetChAt(Char, 0);
                String.Strupr();
                Pager->ClearLine();

                //
                //      If Ctl-C, get out
                //
                if ( Char == CTRLC_CHARACTER ) {

                        _Keyboard->EnableLineMode();
                        GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0 );
                        _Quit = TRUE;
                        return FALSE;
                }


                //
                //      If not in extended mode, any key just advances one page
                //
                if ( !_ExtendedModeSwitch ) {
                *LinesInPage  = Pager->QueryLinesPerPage() - 1;
                        return TRUE;
                }


                //
                //      Now take the proper action
                //
                if ( String.QueryChAt(0) == (WCHAR)CARRIAGERETURN ) {

                        //
                        //      Display next line of the file
                        //
                        *LinesInPage  = 1;
                        *ClearScreen  = FALSE;
                        return TRUE;

                } else if ( String.QueryChAt(0) == (WCHAR)' ' ) {

                        //
                        //      Display next page
                        //
            *ClearScreen = _ClearScreenSwitch;
                *LinesInPage  = Pager->QueryLinesPerPage() - 1;
                        return TRUE;

                } else if ( String.Stricmp(_DisplayLinesOption) == 0 ) {

                        //
                        //      Display a certain number of lines. Get the number of lines
                        //      to display
                        //
                        Prompt( FsnFile, Pager, ShowLineNumber, ShowHelp, MORE_LINEPROMPT );


                        *LinesInPage = ReadNumber();

            //if ( ReadLine( _Keyboard, &String ) &&
            //   String.QueryNumber((PLONG)LinesInPage) ) {
            //
            //   (*LinesInPage)--;
            //
            //} else {
            //  *LinesInPage  = 0;
            //}

                        Pager->ClearLine();

                        *ClearScreen  = FALSE;
                        return TRUE;

                } else if ( String.Stricmp(_SkipLinesOption) == 0 ) {

                        //
                        //      Skip a certain number of lines and then display a page.
                        //
                        Prompt( FsnFile, Pager, ShowLineNumber, ShowHelp, MORE_LINEPROMPT );

                        Number = ReadNumber( );
                        if ( Number ) {
                            Pager->SkipLines( Number, _TabExp );
                        }

                        Pager->ClearLine();

                        *LinesInPage  = Pager->QueryLinesPerPage() - 1;
                        return TRUE;

                } else if ( String.Stricmp(_NextFileOption) == 0 ) {

                        //
                        //      Stop paging this file
                        //
                        return FALSE;

                } else if ( String.Stricmp(_QuitOption) == 0 ) {

                        //
                        //      Quit the program
                        //
                        _Quit = TRUE;
                        return FALSE;

                } else if ( String.Stricmp(_ShowLineNumberOption) ==    0) {

                        //
                        //      Prompt again, showing the line number within the file
                        //
                        ShowLineNumber = TRUE;

                } else if ( ( String.Stricmp(_Help1Option) == 0) ||
                                        ( String.Stricmp(_Help2Option) == 0)) {

                        //
                        //      Prompt again, showing a message line
                        //
                        ShowHelp = TRUE;

                }

        }

}

VOID
MORE::Prompt (
        IN      PFSN_FILE       FsnFile,
        IN      PPAGER          Pager,
        IN      BOOLEAN         ShowLineNumber,
        IN      BOOLEAN         ShowHelp,
        IN      MSGID           OtherMsgId
        )

/*++

Routine Description:

        Displays prompt. The prompt consists of a "base" prompt (e.g.
        "-- More --" plus various optional strings:

                - Percentage of the file displayed so far.
                - Line number within the file
                - Help
                - Other (e.g prompt for a number )


Arguments:

        FsnFile                 -       Supplies pointer to file object
        Pager                   -       Supplies pointer to pager
        ShowLineNumber  -       Supplies flag which if TRUE causes the current
                                                line numnber to be displayed
        HelpMsg                 -       Supplies flag which if TRUE causes a brief help
                                                to be displayed

        OtherMsg                -       Supplies MsgId of any other string to be displayed

Return Value:

        none

--*/

{

        CHAR    NullBuffer = NULL_CHARACTER;
        PVOID   PercentMsg;
        PVOID   LineMsg;
        PVOID   HelpMsg;
        PVOID   OtherMsg;

        //
        //      Obtain all the strings that form part of the prompt
        //
        if ( FsnFile != NULL ) {
                SYSTEM::QueryResourceString( _Percent, MORE_PERCENT, "%d", (Pager->QueryCurrentByte() * 100) / FsnFile->QuerySize());
                _Percent->QuerySTR( 0, TO_END, (PSTR)_StringBuffer0, STRING_BUFFER_SIZE);
                PercentMsg = (PVOID)_StringBuffer0;
        } else {
                PercentMsg = (PVOID)&NullBuffer;
        }

        if (ShowLineNumber) {
                SYSTEM::QueryResourceString( _Line, MORE_LINE, "%d", Pager->QueryCurrentLine());
                _Line->QuerySTR( 0, TO_END, (PSTR)_StringBuffer1, STRING_BUFFER_SIZE);
                LineMsg = (PVOID)_StringBuffer1;
        } else {
                LineMsg = (PVOID)&NullBuffer;
        }

        if (ShowHelp) {
                _Help->QuerySTR(0, TO_END, (PSTR)_StringBuffer2, STRING_BUFFER_SIZE);
                HelpMsg = (PVOID)_StringBuffer2;
        } else {
                HelpMsg = (PVOID)&NullBuffer;
        }

        if (OtherMsgId != 0) {
                SYSTEM::QueryResourceString( _OtherPrompt, OtherMsgId, "" );
                _OtherPrompt->QuerySTR(0, TO_END, (PSTR)_StringBuffer3, STRING_BUFFER_SIZE);
                OtherMsg = (PVOID)_StringBuffer3;
        } else {
                OtherMsg = (PVOID)&NullBuffer;
        }

        //
        //      Now display the prompt
        //
        DisplayMessage( MORE_PROMPT, NORMAL_MESSAGE, "%s%s%s%s", PercentMsg, LineMsg, HelpMsg, OtherMsg );
}

PWSTRING
MORE::QueryMessageString (
        IN MSGID        MsgId
        )
/*++

Routine Description:

        Obtains a string object initialized to the contents of some message

Arguments:

        MsgId   -       Supplies ID of the message

Return Value:

        Pointer to initialized string object

Notes:

--*/

{

        PWSTRING        String;

    if ( ((String = NEW DSTRING) == NULL )  ||
         !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

                DELETE( String );
                String = NULL;
        }

        return String;

}

ULONG
MORE::ReadNumber (
        )
/*++

Routine Description:

        Reads a number from the keyboard.

Arguments:

        None

Return Value:

        Number read

Notes:

--*/

{
    DSTRING     NumberString;
    DSTRING     CharString;
    PSTREAM     StandardOut;
    ULONG       Number = 0;
    LONG        LongNumber;
    WCHAR       Char;
    BOOLEAN     Done = FALSE;
    ULONG       DigitCount = 0;

        StandardOut = GetStandardOutput();

        NumberString.Initialize( "" );
        CharString.Initialize( " " );

        while ( !Done ) {

                _Keyboard->DisableLineMode();
                _Keyboard->ReadChar( &Char );
                _Keyboard->EnableLineMode();

                switch ( Char ) {

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                        CharString.SetChAt( Char, 0 );
                        NumberString.Strcat( &CharString );
                        StandardOut->WriteChar( Char );
                        DigitCount++;
                        break;

                case '\b':
                        if ( DigitCount > 0 ) {
                                NumberString.Truncate( NumberString.QueryChCount() - 1 );
                                StandardOut->WriteChar( Char );
                                StandardOut->WriteChar( ' ' );
                                StandardOut->WriteChar( Char );
                                DigitCount--;
                        }
                        break;


                case '\r':
                case '\n':
                        Done = TRUE;
                        break;

        case CTRLC_CHARACTER:
            _Quit = TRUE;
            Done  = TRUE;
            break;

                default:
            break;


                }
        }

        if ( NumberString.QueryChCount() > 0 ) {

        if ( NumberString.QueryNumber( &LongNumber ) ) {

                        Number = (ULONG)LongNumber;
                }
        }

        return Number;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\more\pager.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    PAGER

Abstract:

    This module contains the implementations for the PAGER class

Author:

    Ramon Juan San Andres (RamonSA) 15-Apr-1990

Notes:


--*/

#include "ulib.hxx"
#include "filestrm.hxx"
#include "wstring.hxx"
#include "bstring.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "more.hxx"
#include "pager.hxx"

//
//  What constitutes a "blank" character (spaces and tabs)
//
#define BLANKCHARACTERS         (LPWSTR)L" \t"
#define TAB_ASCII               (CHAR)'\t'



DEFINE_CONSTRUCTOR( PAGER,  OBJECT );

VOID
PAGER::Construct (
    )
{
    UNREFERENCED_PARAMETER( this );
}

PAGER::~PAGER (
    )
{

    DELETE( _String );
    DELETE( _BString );
    DELETE( _Blanks );
    DELETE( _BlankLine );

}

BOOLEAN
PAGER::Initialize (
    IN  PSTREAM     Stream,
    IN  PPROGRAM    Program
    )
/*++

Routine Description:

    Phase 2 of construction for a pager object. It initializes its
    internal data.

Arguments:

    Stream      -   Supplies the stream to be paged
    Program     -   Supplies pointer to the program doing the paging.

Return Value:

    TRUE  - If initialized correctly
    FALSE - If something when wrong. (check error stack)

--*/

{

    USHORT  ScreenRows, RowsInPage;
    CHNUM   i;

    _Stream             =   Stream;
    _CurrentLineNumber  =   0;
    _StandardOutput     =   Program->GetStandardOutput();
    _Screen             =   SCREEN::Cast( _StandardOutput );
    _Position           =   INVALID_CHNUM;

    //
    //  Get the page dimensions
    //
    if (_Screen) {
        _Screen->QueryScreenSize( &ScreenRows, &_ColumnsInScreen, &RowsInPage, &_ColumnsInPage );
        _RowsInPage = RowsInPage;
        _ColumnsInPage = _ColumnsInScreen;
    } else {

        // If we don't have a screen then we should treat the page
        // as infinitely long since we have no need to prompt.

        _RowsInPage    = (ULONG) -1;
        _ColumnsInPage = (USHORT) -1;
    }

    if (!(_String = NEW DSTRING) ||
        !(_BString = NEW BDSTRING) ||
        !(_Blanks = NEW DSTRING) ||
        !(_BlankLine = NEW DSTRING) ||
        !_String->Initialize() ||
        !_BString->Initialize() ||
        !_Blanks->Initialize(BLANKCHARACTERS) ||
        !_BlankLine->Resize(_Screen ? _ColumnsInPage : 0)) {

        return FALSE;
    }

    for (i = 0; i < _BlankLine->QueryChCount(); i++) {
        _BlankLine->SetChAt(' ', i);
    }

    return TRUE;
}

BOOLEAN
PAGER::DisplayPage (
    IN  ULONG   LinesInPage,
    IN  BOOLEAN ClearScreen,
    IN  BOOLEAN SqueezeBlankLines,
    IN  BOOLEAN ExpandFormFeed,
    IN  ULONG   TabExp
    )

/*++

Routine Description:

    Displays a page of the screen

Arguments:

    LinesInPage         -   Supplies the desired number of lines in the page
    ClearScreen         -   Supplies a flag, which if TRUE means that we
                            want to clear the screen before displaying the
                            page
    SqueezeBlankLines   -   Supplies squeeze flag
    ExpandFormFeed      -   Supplies formfeed expansion flag

Return Value:

    TRUE - If page displayed
    FALSE otherwise

--*/

{
    ULONG   LinesLeft       = LinesInPage;
    BOOLEAN IgnoreBlankLine = FALSE;
    CHNUM   Length;
    CHNUM   FormFeedAt;


    if ( TabExp > (ULONG)( _ColumnsInPage - 1 ) ) {
        TabExp = _ColumnsInPage - 1 ;
    }

    //
    //  Clear the screen if instructed to do so
    //
    if ( ClearScreen && _Screen) {
#ifdef FE_SB  // v-junm - 08/18/93
// Also reset attributes.
        _Screen->EraseScreenAndResetAttribute();
#else
        _Screen->EraseScreen();
#endif
        _Screen->MoveCursorTo( 0, 0 );
    } else {
        //
        //  Make sure that we start at the beginning of a line
        //
        ClearLine();
    }

    //
    //  Display up to LinesLeft lines
    //

    while ( LinesLeft > 0 &&
           (ThereIsMoreToPage() || _Position != INVALID_CHNUM) ) {

        //
        //  Get next string from input
        //
        if (!ReadNextString( TabExp )) {
            return FALSE;
        }

#ifdef FE_SB  // v-junm - 08/18/93
// Now QueryChCount returns the correct number of unicode chars.  An additional
// API, QueryByteCount was added.
        Length = _String->QueryByteCount() - _Position;
#else
        Length = _String->QueryChCount() - _Position;
#endif

        if ( SqueezeBlankLines ) {

            if ( _String->Strspn( _Blanks, _Position ) == INVALID_CHNUM ) {

                //
                //  This is a blank line. We must sqeeze
                //
                if ( IgnoreBlankLine ) {
                    //
                    //  We ignore the line
                    //
                    _Position = INVALID_CHNUM;
                    continue;

                } else {
                    //
                    //  We will print a blank line and  ignore the following
                    //  blank lines.
                    //
                    DisplayBlankLine( 1 );
                    _Position = INVALID_CHNUM;
                    IgnoreBlankLine = TRUE;
                    continue;
                }
            } else if (IgnoreBlankLine) {
                LinesLeft--;
                IgnoreBlankLine = FALSE;
                continue;
            }
        }


        if ( ExpandFormFeed ) {
            //
            //  Look for form feed within line
            //
            if ((FormFeedAt = _String->Strchr( FORMFEED,_Position )) != INVALID_CHNUM) {
                if ( FormFeedAt == _Position ) {
                    //
                    //  First character is a form feed.
                    //
                    //  We will skip the formfeed character, and the
                    //  rest of the screen will be blanked.
                    //
                    if ( SqueezeBlankLines ) {
                        if (!IgnoreBlankLine) {
                            DisplayBlankLine( 1 );
                            LinesLeft--;
                            IgnoreBlankLine = TRUE;
                        }
                    } else {
                        DisplayBlankLine( LinesLeft );
                        LinesLeft = 0;
                    }
                    _Position++;
                    continue;
                }

                Length = FormFeedAt - _Position;
            }
        }


        //
        //  If the line is too long, we must split it
        //
        if (Length > (CHNUM)_ColumnsInPage) {
            Length = (CHNUM)_ColumnsInPage;
        }

        //
        //  Display the string
        //
        DisplayString( _String, &_Position, Length );
        IgnoreBlankLine = FALSE;

        LinesLeft--;
    }

    return TRUE;
}

VOID
PAGER::ClearLine (
    )

/*++

Routine Description:

    Clears a line

Arguments:

    none

Return Value:

    none

--*/

{
    USHORT  ScreenRows, ScreenCols;
    USHORT  WindowRows, WindowCols;
    CHNUM   i;

    if (_Screen) {

        _Screen->QueryScreenSize( &ScreenRows,
                                  &ScreenCols,
                                  &WindowRows,
                                  &WindowCols );
        //
        //  If the number of columns has changed, re-initialize the
        //  blank line.
        //
        if ( ScreenCols != _ColumnsInPage ) {
            _BlankLine->Resize(ScreenCols);
            for (i = 0; i < ScreenCols; i++) {
                _BlankLine->SetChAt(' ', i);
            }
        }
        _RowsInPage     = WindowRows;
        _ColumnsInPage  = ScreenCols;

        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
        _StandardOutput->WriteString( _BlankLine, 0, _ColumnsInPage-1 );
        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
    }
}

VOID
PAGER::DisplayBlankLine (
    IN ULONG    Lines,
    IN BOOLEAN  NewLine
    )

/*++

Routine Description:

    Displays a number of blank lines

Arguments:

    Lines   -   Supplies the number of blank lines to display
    NewLine -   Supplies the newline flag

Return Value:

    none

--*/

{
    CHNUM   Position;

    while ( Lines-- ) {

        Position = 0;

        DisplayString( _BlankLine, &Position, _ColumnsInPage-1, (Lines > 0) ? TRUE : NewLine);

    }
}

VOID
PAGER::DisplayString (
    IN  PWSTRING String,
    OUT PCHNUM   Position,
    IN  CHNUM    Length,
    IN  BOOLEAN  NewLine
    )

/*++

Routine Description:

    Displays a chunk of the current string

Arguments:

    Length  -   Supplies the length of the string to display
    NewLine -   Supplies the newline flag

Return Value:

    none

--*/

{
#ifdef FE_SB  // v-junm - 04/19/93

    CHNUM           UnicodeCharNum,     // # of unicode characters to display
                    TempByteCount,      // to minimize calls to QueryByteCount
                    index;              // loop counter
    PSTR            STRBuffer;          // ASCIIZ converted string pointer
    static  CHNUM   OldPos;             // Keeps old position in # of Unicode
    BOOL            DBCSFlag = FALSE;   // Flag for ending leadbyte

    TempByteCount = String->QueryByteCount();
    Length = min( Length, TempByteCount );

    // If the length of the string to display is shorter than
    // the width of the screen, we do not have to do any DBCS
    // checking.  Just print it out.  (Can be skipped for CP437)
    //

    if ( TempByteCount > _ColumnsInPage )  {

        //
        // Initialize # of unicode characters to #
        // of ASCII chars to display.
        //

        UnicodeCharNum = Length;

        //
        // Get the string as a ASCIIZ text.
        //

        STRBuffer = String->QuerySTR();

        if ( STRBuffer != NULL )  {

            //
            // Start changing the UnicodeCharNum from the actual
            // number of bytes to the actual number of characters.
            //

            for( index = 0; index < Length; index++ ) {
                if ( IsLeadByte( *(STRBuffer + index + _Position) ) ) {
                    index++;
                    UnicodeCharNum--;
                    DBCSFlag = TRUE;
                }
                else
                    DBCSFlag = FALSE;
            }
            DELETE( STRBuffer );
        }

        //
        // If the following conditions are true, then there
        // is a Leadbyte at the end of the screen that needs
        // to be displayed on the next line with it's tail byte.
        //

        if ( DBCSFlag == TRUE &&                // String ends with DBCS.
             index == (Length - 1) &&           // Only Leadbyte.
             Length == (CHNUM)_ColumnsInPage    // More rows to display.
            )  {
            Length--;
            UnicodeCharNum--;
        }

    }
    else
//fix kksuzuka: #195
//Overflow pagecolumns when writing 0D0A.
//UnicodeCharNum = String->QueryChCount();
        UnicodeCharNum = min( Length, String->QueryChCount() );

    //
    // When the string does not fit on one line and needs to be truncated,
    // OldPos keeps the position where the string was truncated in Unicode
    // location.
    //


    //
    // If true, set to beginning of string.
    //

    if ( *Position == 0 )
        OldPos = 0;

    _StandardOutput->WriteString( String, OldPos, UnicodeCharNum );

    //
    // Set to last+1 char displayed in unicode character numbers.
    //

    OldPos += UnicodeCharNum;

    //
    //  Update our position within the string
    //

    *Position += Length;

    //
    // Check if all the characters have been written.
    //

    if ( TempByteCount && (TempByteCount == *Position) &&
         !(TempByteCount % _ColumnsInPage) )  {

        //
        // Characters have been written, but there is a LF/CR
        // character at the that needs to be display that has
        // not been displayed.  (At _ColumnsInPage+1 location)
        //

        *Position = INVALID_CHNUM;
//        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
//        _StandardOutput->WriteChar( (WCHAR)LINEFEED );

    }
    else if ( *Position >= TempByteCount )
        *Position = INVALID_CHNUM;

    if ( ((*Position != INVALID_CHNUM) || NewLine) &&
         ( Length < _ColumnsInScreen || !_Screen ) ) {

        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
        _StandardOutput->WriteChar( (WCHAR)LINEFEED );
    }

#else // FE_SB

    Length = min( Length, String->QueryChCount() );

    _StandardOutput->WriteString( String, *Position, Length );

    //
    //  Update our position within the string
    //
    *Position += Length;

    if (*Position >= _String->QueryChCount()) {
        *Position = INVALID_CHNUM;
    }

    if ( ((*Position != INVALID_CHNUM) || NewLine) &&
         ( Length < _ColumnsInScreen || !_Screen ) ) {
        _StandardOutput->WriteChar( (WCHAR)CARRIAGERETURN );
        _StandardOutput->WriteChar( (WCHAR)LINEFEED );
    }

#endif
}


ULONGLONG
PAGER::QueryCurrentByte (
    )

/*++

Routine Description:

    Queries the current Byte number

Arguments:

    none

Return Value:

    The current byte number

--*/

{

    PFILE_STREAM    pFileStream;
    ULONGLONG       PointerPosition ;

    if ((pFileStream = FILE_STREAM::Cast(_Stream)) == NULL )  {

        return 0;

    } else {

        pFileStream->QueryPointerPosition( &PointerPosition );

        return PointerPosition;
    }
}

USHORT
PAGER::QueryLinesPerPage (
    )

/*++

Routine Description:

    Queries the number of lines per page of output

Arguments:

    none

Return Value:

    The number of lines (rows) in a page

--*/

{
    USHORT  ScreenRows, ScreenCols;
    USHORT  WindowRows, WindowCols;
    CHNUM   i;

    //
    //  If Paging to screen, get the current size of the window
    //
    if (_Screen) {

        _Screen->QueryScreenSize( &ScreenRows,
                                  &ScreenCols,
                                  &WindowRows,
                                  &WindowCols );
        //
        //  If the number of columns has changed, re-initialize the
        //  blank line.
        //
        if ( WindowCols != _ColumnsInPage ) {
            _BlankLine->Resize(ScreenCols);
            for (i = 0; i < ScreenCols; i++) {
                _BlankLine->SetChAt(' ', i);
            }
        }
        _RowsInPage     = WindowRows;
        _ColumnsInPage  = ScreenCols;
    }

    return (USHORT)_RowsInPage;
}

BOOLEAN
PAGER::ReadNextString (
    IN  ULONG   TabExp
    )

/*++

Routine Description:

    Reads in the next string from the input stream.

Arguments:

    TabExp  -   Supplies the number of blank characters per tab

Return Value:

    TRUE - If string read in
    FALSE otherwise

--*/

{

    if (_Position == INVALID_CHNUM ) {

        CHNUM   Idx;

        //
        //  We have to read a new string from the input stream.
        //
        if (!_Stream->ReadLine( _String )) {
            return FALSE;
        }

        _CurrentLineNumber++;
        _Position = 0;

        //
        //  Expand tabs
        //
        Idx = 0;

        //
        // Get the string as a ASCIIZ text.
        //
        PSTR   szBuffer;          // ASCIIZ converted string pointer

        szBuffer = _String->QuerySTR();
        if (szBuffer != NULL) {
            _BString->Initialize(szBuffer);
            DELETE( szBuffer );

            while ( (Idx < _BString->QueryChCount()) &&
                   ((Idx = _BString->Strchr( TAB_ASCII, Idx )) != INVALID_CHNUM) ) {

                if (TabExp) {
                    _BString->ReplaceWithChars(
                                      Idx,              // AtPosition
                                      1,                // AtLength
                                      ' ',              // Replacement char
                                      TabExp - Idx%TabExp   // FromLength
                                     );
                } else {
                    _BString->ReplaceWithChars(
                                      Idx,              // AtPosition
                                      1,                // AtLength
                                      ' ',              // Replacement char
                                      0                 // FromLength
                                     );
                }

                //
                // MJB:  If we're eliminating tabs we don't want to advance the
                // index; removing the previous tab has pulled the next character
                // in *to* the index, so it's already where we want it.  Advancing
                // regardless can cause every other adjacent tab not to be
                // elminiated.
                //

                if (TabExp > 0) {
                    Idx = _BString->NextChar(Idx);
                }
            }

            szBuffer = _BString->QuerySTR();
            if (szBuffer != NULL) {
                _String->Initialize(szBuffer);
                DELETE( szBuffer );
            }

        }

    }

    return TRUE;

}

BOOLEAN
PAGER::SkipLines (
    IN  ULONG   LinesToSkip,
    IN  ULONG   TabExp
    )

/*++

Routine Description:

    Skips certain number of lines

Arguments:

    LinesToSkip -   Supplies the number of lines to skip
    TabExp      -   Supplies number of spaces per tab

Return Value:

    TRUE - If lines skipped
    FALSE otherwise

--*/

{

    if ( TabExp > (ULONG)( _ColumnsInPage - 1 ) ) {
        TabExp = _ColumnsInPage - 1;
    }

    while ( LinesToSkip--  && ThereIsMoreToPage() ) {

        if (!ReadNextString( TabExp )) {
            return FALSE;
        }

        _Position = INVALID_CHNUM;

    }

    return TRUE;

}

#ifdef FE_SB // v-junm - 09/24/93

BOOLEAN
PAGER::IsLeadByte(
    IN  BYTE   c
    )

/*++

Routine Description:

    Checks to see if c is a leadbyte of a DBCS character.

Arguments:

    c - character to check to see if leadbyte.

Return Value:

    TRUE - leadbyte of DBCS character.
    FALSE otherwise

--*/

{
    CPINFO          cp;
    static UINT     outputcp = GetConsoleOutputCP();
    int             i;

    if ( GetCPInfo( outputcp, &cp ) )  {

        //
        // Code page info has been aquired.  From code page info,
        // the leadbyte range can be determined.
        //

        for( i = 0; cp.LeadByte[i] && cp.LeadByte[i+1]; i += 2 )  {

            //
            // There are leadbytes.  Check to see if c falls in
            // current leadbyte range.
            //

            if ( c >= cp.LeadByte[i] && c <= cp.LeadByte[i+1] )
                return( TRUE );

        }

        return( FALSE );
    }
    else  {

        //
        // This will not produce correct results if
        // 'ConsoleOutputCP != SystemCP && DBCS System'
        // Just making system conversion the default
        // when GetCPInfo doesn't work.
        //

        return( IsDBCSLeadByte( c ) != FALSE );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\mountvol\mountvol.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <msg.h>
#include <winnlsp.h>
#include <mountmgr.h>
#include <ntddvol.h>

#define SIZEOF_ARRAY(_Array)     (sizeof(_Array)/sizeof(_Array[0]))


HANDLE  OutputFile;
BOOL    IsConsoleOutput;


void
DisplayIt(
    IN  PWSTR   Message
    )

{
    DWORD   bytes, len;
    PSTR    message;

    if (IsConsoleOutput) {
        WriteConsole(OutputFile, Message, wcslen(Message),
                     &bytes, NULL);
    } else {
        len = wcslen(Message);
        message = LocalAlloc(0, (len + 1)*sizeof(WCHAR));
        if (!message) {
            return;
        }
        CharToOem(Message, message);
        WriteFile(OutputFile, message, strlen(message), &bytes, NULL);
        LocalFree(message);
    }
}

void  
PrintMessage(
    DWORD messageID, 
    ...
    )
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                   messagebuffer, SIZEOF_ARRAY (messagebuffer), &ap);

    DisplayIt(messagebuffer);

    va_end(ap);

}  // PrintMessage


static 
void
PrintSystemMessageFromStatus (
    DWORD Status
    )
{
    unsigned short messageBuffer[1024];

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    Status, 
                    0,
                    messageBuffer, 
                    SIZEOF_ARRAY (messageBuffer), 
                    NULL);

    DisplayIt(messageBuffer);
}


static 
BOOL
VolumeNameIsDriveLetter(
    IN  PWSTR  VolumeName
    )
{
    return ((3 == wcslen (VolumeName)) && 
            (':'  == VolumeName [1]) && 
            ('\\' == VolumeName [2]) &&
            (((VolumeName [0] >= 'a') && (VolumeName [0] <= 'z')) || 
             ((VolumeName [0] >= 'A') && (VolumeName [0] <= 'Z'))));
}


BOOL
IsVolumeOffline(
    IN  PWSTR   VolumeName
    )

{
    DWORD   len;
    HANDLE  h;
    BOOL    b;
    DWORD   bytes;


    len = wcslen(VolumeName);

    if ((0 == len) || (L'\\' != VolumeName[len - 1])) {
        return FALSE;
    }

    VolumeName[len - 1] = 0;
    h = CreateFile(VolumeName, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    VolumeName[len - 1] = '\\';
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_VOLUME_IS_OFFLINE, NULL, 0, NULL, 0, &bytes,
                        NULL);
    CloseHandle(h);

    return b;
}

void
PrintTargetForName(
    IN  PWSTR   VolumeName
    )

{
    BOOL    b;
    DWORD   len;
    PWSTR   volumePaths, p;

    PrintMessage(MOUNTVOL_VOLUME_NAME, VolumeName);

    b = GetVolumePathNamesForVolumeName(VolumeName, NULL, 0, &len);
    if (!b && GetLastError() != ERROR_MORE_DATA) {
        PrintSystemMessageFromStatus (GetLastError());
        return;
    }

    volumePaths = LocalAlloc(0, len*sizeof(WCHAR));
    if (!volumePaths) {
        PrintSystemMessageFromStatus (ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    b = GetVolumePathNamesForVolumeName(VolumeName, volumePaths, len, NULL);
    if (!b) {
        LocalFree(volumePaths);
        PrintSystemMessageFromStatus (GetLastError());
        return;
    }

    if (!volumePaths[0]) {
        if (IsVolumeOffline(VolumeName)) {
            PrintMessage(MOUNTVOL_NOT_MOUNTED);
        } else {
            PrintMessage(MOUNTVOL_NO_MOUNT_POINTS);
        }
        LocalFree(volumePaths);
        return;
    }

    p = volumePaths;
    for (;;) {
        PrintMessage(MOUNTVOL_MOUNT_POINT, p);

        while (*p++);

        if (!*p) {
            break;
        }
    }

    LocalFree(volumePaths);

    PrintMessage(MOUNTVOL_NEWLINE);
}

BOOL
GetSystemPartitionFromRegistry(
    IN OUT  PWCHAR  SystemPartition
    )

{
    LONG    r;
    HKEY    key;
    DWORD   bytes;

    r = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", 0, KEY_QUERY_VALUE,
                     &key);
    if (r) {
        SetLastError(r);
        return FALSE;
    }

    bytes = MAX_PATH*sizeof(WCHAR);
    r = RegQueryValueEx(key, L"SystemPartition", NULL, NULL,
                        (LPBYTE) SystemPartition, &bytes);
    RegCloseKey(key);
    if (r) {
        SetLastError(r);
        return FALSE;
    }

    return TRUE;
}

BOOL
QueryAutoMountState(
    PBOOL       ReturnedAutoMountEnabled
    )

{
    HANDLE                      h;
    BOOL                        bSucceeded;
    DWORD                       bytes;
    MOUNTMGR_QUERY_AUTO_MOUNT   QueryAutoMount;

    h = CreateFile (MOUNTMGR_DOS_DEVICE_NAME,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);

    bSucceeded = (INVALID_HANDLE_VALUE != h);


    if (bSucceeded) {
        bSucceeded = DeviceIoControl (h, 
                                      IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT, 
                                      NULL, 
                                      0, 
                                      &QueryAutoMount, 
                                      sizeof (QueryAutoMount),
                                      &bytes,
                                      NULL);
    }


    if (bSucceeded) {
        *ReturnedAutoMountEnabled = (Enabled == QueryAutoMount.CurrentState);
    }


    if (INVALID_HANDLE_VALUE != h) {
        CloseHandle(h);
    }


    return (bSucceeded);
}


BOOL
SetAutoMountState(
    BOOL       AutoMountEnabled
    )

{
    HANDLE                  h;
    BOOL                    bSucceeded;
    DWORD                   bytes;
    MOUNTMGR_SET_AUTO_MOUNT SetAutoMount;

    h = CreateFile (MOUNTMGR_DOS_DEVICE_NAME, 
                    GENERIC_READ | GENERIC_WRITE, 
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);

    bSucceeded = (INVALID_HANDLE_VALUE != h);


    if (bSucceeded) {
        memset (&SetAutoMount, 0x00, sizeof (SetAutoMount));

        SetAutoMount.NewState = (AutoMountEnabled) ? Enabled : Disabled;

        bSucceeded = DeviceIoControl (h, 
                                      IOCTL_MOUNTMGR_SET_AUTO_MOUNT, 
                                      &SetAutoMount, 
                                      sizeof (SetAutoMount),
                                      NULL, 
                                      0, 
                                      &bytes,
                                      NULL);
    }


    if (INVALID_HANDLE_VALUE != h) {
        CloseHandle(h);
    }


    return (bSucceeded);
}


void
PrintMappedESP(
    IN  BOOL*   IsMapped
    )

{
    WCHAR   systemPartition[MAX_PATH];
    UCHAR   c;
    WCHAR   dosDevice[4], dosTarget[MAX_PATH];

    if (IsMapped) {
        *IsMapped = FALSE;
    }

    if (!GetSystemPartitionFromRegistry(systemPartition)) {
        return;
    }

    dosDevice[1] = ':';
    dosDevice[2] = 0;

    for (c = 'A'; c <= 'Z'; c++) {
        dosDevice[0] = c;
        if (!QueryDosDevice(dosDevice, dosTarget, SIZEOF_ARRAY (dosTarget))) {
            continue;
        }
        if (lstrcmp(dosTarget, systemPartition)) {
            continue;
        }
        dosDevice[2] = '\\';
        dosDevice[3] = 0;
        if (IsMapped) {
            *IsMapped = TRUE;
        } else {
            PrintMessage(MOUNTVOL_EFI, dosDevice);
        }
        break;
    }
}


void
PrintVolumeList(
    void
    )

{
    HANDLE  h;
    WCHAR   volumeName[MAX_PATH];
    BOOL    b;
    BOOL    AutoMountEnabled;


    b = QueryAutoMountState (&AutoMountEnabled);

    if (!b) {
        PrintSystemMessageFromStatus (GetLastError ());
        return;
    }


    h = FindFirstVolume(volumeName, SIZEOF_ARRAY (volumeName));
    if (h == INVALID_HANDLE_VALUE) {
        PrintSystemMessageFromStatus (GetLastError());
        return;
    }

    for (;;) {

        PrintTargetForName(volumeName);

        b = FindNextVolume(h, volumeName, SIZEOF_ARRAY (volumeName));

        if (!b) {
            if (ERROR_NO_MORE_FILES != GetLastError()) {
                PrintSystemMessageFromStatus (GetLastError());
                FindVolumeClose(h);
                return;
            }

            break;
        }
    }

    FindVolumeClose(h);

    if (!AutoMountEnabled) {
        PrintMessage(MOUNTVOL_NO_AUTO_MOUNT);
    }

#if defined(_M_IA64)
    PrintMappedESP(NULL);
#endif
}

BOOL
SetSystemPartitionDriveLetter(
    IN  PWCHAR  DirName
    )

/*++

Routine Description:

    This routine will set the given drive letter to the system partition.

Arguments:

    DirName - Supplies the drive letter directory name.

Return Value:

    BOOL

--*/

{
    WCHAR   systemPartition[MAX_PATH];

    if (!GetSystemPartitionFromRegistry(systemPartition)) {
        return FALSE;
    }

    DirName[wcslen(DirName) - 1] = 0;
    if (!DefineDosDevice(DDD_RAW_TARGET_PATH, DirName, systemPartition)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ScrubRegistry(
    )

{
    HANDLE  h, hh;
    DWORD   bytes;
    DWORD   lengthVolumeName;
    DWORD   lengthSubPath;
    BOOL    bSuccess;
    WCHAR   volumeName       [MAX_PATH];
    WCHAR   volumeNameTarget [MAX_PATH];
    WCHAR   volumeNameTarget2[MAX_PATH];
    WCHAR   subPath[2*MAX_PATH];
    WCHAR   fullPath[3*MAX_PATH];

    h = CreateFile(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    bSuccess = DeviceIoControl(h, IOCTL_MOUNTMGR_SCRUB_REGISTRY, NULL, 0, NULL, 0,
                               &bytes, NULL);

    CloseHandle(h);

    if (!bSuccess) {
        return FALSE;
    }


    /*
    ** Scan over each volume we can find on this system
    */
    h = FindFirstVolume(volumeName, SIZEOF_ARRAY (volumeName));
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }


    while (bSuccess) {

        lengthVolumeName = wcslen(volumeName);

        CopyMemory(fullPath, volumeName, lengthVolumeName * sizeof(WCHAR));


        /*
        ** Scan over each mountpoint we can find on this volume
        */
        hh = FindFirstVolumeMountPoint(volumeName, subPath, SIZEOF_ARRAY (subPath));

        if (hh != INVALID_HANDLE_VALUE) {

            while (bSuccess) {

                lengthSubPath = wcslen(subPath);

                CopyMemory(fullPath + lengthVolumeName, 
                           subPath, 
                           lengthSubPath * sizeof(WCHAR));

                fullPath [lengthVolumeName + lengthSubPath] = UNICODE_NULL;

                bSuccess = GetVolumeNameForVolumeMountPoint(fullPath, 
                                                            volumeNameTarget, 
                                                            SIZEOF_ARRAY (volumeNameTarget));

                if (bSuccess) {
                    /*
                    ** Does the volume pointed to by the mount point actually exist?
                    */
                    bSuccess = GetVolumeNameForVolumeMountPoint(volumeNameTarget, 
                                                                volumeNameTarget2,
                                                                SIZEOF_ARRAY (volumeNameTarget2));

                    if ((!bSuccess) && (ERROR_PATH_NOT_FOUND == GetLastError())) {
                        bSuccess = RemoveDirectory(fullPath);
                    }
                }

                if (!bSuccess) {
                    /*
                    ** If we have seen any kind of failure other than that we 
                    ** anticipated it's time to leave.
                    */
                    FindVolumeMountPointClose(hh);
                    FindVolumeClose(h);
                    return FALSE;
                }

                bSuccess = FindNextVolumeMountPoint(hh, subPath, SIZEOF_ARRAY (subPath));
            }

            FindVolumeMountPointClose(hh);
        }

        bSuccess = FindNextVolume(h, volumeName, SIZEOF_ARRAY (volumeName));
    }

    FindVolumeClose(h);

    return TRUE;
}

BOOL
DoPermanentDismount(
    IN  PWCHAR  DirName,
    OUT PBOOL   ErrorHandled
    )

{
    BOOL    b;
    WCHAR   volumeName[MAX_PATH];
    DWORD   len, bytes, dirLen;
    PWSTR   volumePaths, p;
    HANDLE  h;

    *ErrorHandled = FALSE;

    //
    // Make sure that this is the last volume mount point.  Otherwise, fail.
    //

    b = GetVolumeNameForVolumeMountPoint(DirName, volumeName, SIZEOF_ARRAY (volumeName));
    if (!b) {
        return FALSE;
    }

    b = GetVolumePathNamesForVolumeName(volumeName, NULL, 0, &len);
    if (!b && GetLastError() != ERROR_MORE_DATA) {
        return FALSE;
    }

    volumePaths = LocalAlloc(0, len*sizeof(WCHAR));
    if (!volumePaths) {
        return FALSE;
    }

    b = GetVolumePathNamesForVolumeName(volumeName, volumePaths, len, NULL);
    if (!b) {
        LocalFree(volumePaths);
        return FALSE;
    }

    if (!volumePaths[0]) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    p = volumePaths;
    while (*p++);
    if (*p) {
        LocalFree(volumePaths);
        *ErrorHandled = TRUE;
        SetLastError(ERROR_INVALID_PARAMETER);
        PrintMessage(MOUNTVOL_OTHER_VOLUME_MOUNT_POINTS);
        return FALSE;
    }

    LocalFree(volumePaths);

    //
    // Open the volume DASD for read and write access.
    //

    len = wcslen(volumeName);
    volumeName[len - 1] = 0;
    len--;

    h = CreateFile(volumeName, GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Make sure that this volume support VOLUME_OFFLINE.
    //

    b = DeviceIoControl(h, IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE, NULL, 0, NULL,
                        0, &bytes, NULL);
    if (!b) {
        CloseHandle(h);
        *ErrorHandled = TRUE;
        SetLastError(ERROR_INVALID_PARAMETER);
        PrintMessage(MOUNTVOL_NOT_SUPPORTED);
        return FALSE;
    }

    //
    // Dismount the volume.  Issue the LOCK first so that apps may have
    // a chance to dismount gracefully.  If the LOCK fails, warn the user
    // that continuing will result in handles being invalidated.
    //

    b = DeviceIoControl(h, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &bytes, NULL);
    if (!b) {
        PrintMessage(MOUNTVOL_VOLUME_IN_USE);
    }

    b = DeviceIoControl(h, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &bytes,
                        NULL);
    if (!b) {
        CloseHandle(h);
        return FALSE;
    }

    //
    // Issue an IOCTL_VOLUME_OFFLINE.
    //

    b = DeviceIoControl(h, IOCTL_VOLUME_OFFLINE, NULL, 0, NULL, 0, &bytes,
                        NULL);
    if (!b) {
        CloseHandle(h);
        return FALSE;
    }

    CloseHandle(h);

    return TRUE;
}

int __cdecl
main(
    int argc,
    char** argv
    )

{
    DWORD   mode;
    WCHAR   dirName[MAX_PATH];
    WCHAR   volumeName[MAX_PATH];
    DWORD   dirLen, volumeLen;
    BOOL    deletePoint     = FALSE;
    BOOL    listPoint       = FALSE;
    BOOL    systemPartition = FALSE;
    BOOL    dismount        = FALSE;
    BOOL    b, errorHandled;
    WCHAR   targetPathBuffer[MAX_PATH];

    SetThreadUILanguage(0);

    SetErrorMode(SEM_FAILCRITICALERRORS);

    OutputFile = GetStdHandle(STD_OUTPUT_HANDLE);
    IsConsoleOutput = GetConsoleMode(OutputFile, &mode);


    if (argc > 2) {
        volumeLen = _snwprintf (volumeName, 
                                SIZEOF_ARRAY (volumeName), 
                                L"%hs",
                                argv[2]);

        if ((volumeLen <= 0) || (volumeLen >= SIZEOF_ARRAY (volumeName))) {

            PrintSystemMessageFromStatus (ERROR_INVALID_PARAMETER);
            return 1;
        }
    }


    if (argc > 1) {
        dirLen = _snwprintf (dirName,
                             SIZEOF_ARRAY (dirName),
                             L"%hs",
                             argv[1]);

        if ((dirLen <= 0) || (dirLen >= SIZEOF_ARRAY (dirName))) {

            PrintSystemMessageFromStatus (ERROR_INVALID_PARAMETER);
            return 1;
        }
    }



    if (argc != 3) {

        if (argc == 2 && argv[1][0] == '/' && argv[1][1] != 0 &&
            argv[1][2] == 0) {

            if (argv[1][1] == 'r' || argv[1][1] == 'R') {
                b = ScrubRegistry();

            } else if (argv[1][1] == 'n' || argv[1][1] == 'N') {
                //
                // Disable automatic mounting of volumes
                //
                b = SetAutoMountState (FALSE);

            } else if (argv[1][1] == 'e' || argv[1][1] == 'E') {
                //
                // Enable automatic mounting of volumes
                //
                b = SetAutoMountState (TRUE);

            } else {
                goto Usage;
            }

            if (!b) {
                PrintSystemMessageFromStatus (GetLastError());
                return 1;
            }

            return 0;
        }


Usage:

        PrintMessage(MOUNTVOL_USAGE1);
#if defined(_M_IA64)
        PrintMessage(MOUNTVOL_USAGE1_IA64);
#endif
        PrintMessage(MOUNTVOL_USAGE2);
#if defined(_M_IA64)
        PrintMessage(MOUNTVOL_USAGE2_IA64);
#endif
        PrintMessage(MOUNTVOL_START_OF_LIST);
        PrintVolumeList();
        return 0;
    }


    if (argv[2][0] == '/' && argv[2][1] != 0 && argv[2][2] == 0) {
        if (argv[2][1] == 'd' || argv[2][1] == 'D') {
            deletePoint = TRUE;
        } else if (argv[2][1] == 'l' || argv[2][1] == 'L') {
            listPoint = TRUE;
        } else if (argv[2][1] == 'p' || argv[2][1] == 'P') {
            deletePoint = TRUE;
            dismount    = TRUE;
        } else if (argv[2][1] == 's' || argv[2][1] == 'S') {
            systemPartition = TRUE;
        }
    }

    if (dirName[dirLen - 1] != '\\') {
        wcscat(dirName, L"\\");
        dirLen++;
    }

    if (volumeName[volumeLen - 1] != '\\') {
        wcscat(volumeName, L"\\");
        volumeLen++;
    }

    if (deletePoint) {
        if (dismount) {
            b = DoPermanentDismount(dirName, &errorHandled);
            if (!b && errorHandled) {
                return 1;
            }
        } else {
            b = TRUE;
        }
        if (b) {
            b = DeleteVolumeMountPoint(dirName);
            if (!b && GetLastError() == ERROR_INVALID_PARAMETER) {
                dirName[dirLen - 1] = 0;
                b = DefineDosDevice(DDD_REMOVE_DEFINITION, dirName, NULL);
            }
        }
    } else if (listPoint) {
        b = GetVolumeNameForVolumeMountPoint(dirName, volumeName, SIZEOF_ARRAY (volumeName));
        if (b) {
            PrintMessage(MOUNTVOL_VOLUME_NAME, volumeName);
        }
    } else if (systemPartition) {
#if defined(_M_IA64)
        if (!VolumeNameIsDriveLetter (dirName)) {
            PrintSystemMessageFromStatus (ERROR_INVALID_PARAMETER);
            return 1;
        } else {
            dirName[2] = 0;
            b = QueryDosDevice(dirName, targetPathBuffer, SIZEOF_ARRAY (targetPathBuffer));
            if (b) {
                PrintSystemMessageFromStatus (ERROR_DIR_NOT_EMPTY);
                return 1;
            }
            dirName[2] = '\\';

            PrintMappedESP(&b);
            if (b) {
                PrintSystemMessageFromStatus (ERROR_INVALID_PARAMETER);
                return 1;
            }
        }

        b = SetSystemPartitionDriveLetter(dirName);
#else
        PrintSystemMessageFromStatus (ERROR_INVALID_PARAMETER);
        return 1;
#endif
    } else {
        if (VolumeNameIsDriveLetter (dirName)) {

            dirName[2] = 0;
            b = QueryDosDevice(dirName, targetPathBuffer, SIZEOF_ARRAY (targetPathBuffer));
            if (b) {
                PrintSystemMessageFromStatus (ERROR_DIR_NOT_EMPTY);
                return 1;
            }
            dirName[2] = '\\';
        }

        b = SetVolumeMountPoint(dirName, volumeName);
    }

    if (!b) {
        PrintSystemMessageFromStatus (GetLastError());
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\more\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=more
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM
USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\pager.cxx       \
        ..\more.cxx        \
        ..\more.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS= \
    $(SDK_LIB_PATH)\setargv.obj  \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\achkmsg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\achkmsg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\array.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\array.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\attrdef.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrdef.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\arrayit.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\arrayit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\arg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\arg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\attrcol.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrcol.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\attrlist.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrlist.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\attrib.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrib.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\autoentr.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\autoentr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\attrrec.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\attrrec.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\badfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\badfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\basesys.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\basesys.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\autoreg.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\autoreg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\bitfrs.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\bitfrs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\bigint.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\bigint.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\bitvect.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\bitvect.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\bootfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\bootfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\bootreg.c ===
#include "..\..\ifsutil\src\bootreg.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\cannedsd.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\cannedsd.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\cache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\cache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\clasdesc.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\clasdesc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\cluster.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\cluster.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\clusrun.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\clusrun.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\cmem.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\cmem.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\contain.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\contain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\boothack.cxx ===
#include <pch.cxx>
#include "ulib.hxx"

PCCLASS_DESCRIPTOR BSTRING_cd;
PCCLASS_DESCRIPTOR BDSTRING_cd;
PCCLASS_DESCRIPTOR BUFFER_STREAM_cd;
PCCLASS_DESCRIPTOR BYTE_STREAM_cd;
PCCLASS_DESCRIPTOR CHKDSK_MESSAGE_cd;
PCCLASS_DESCRIPTOR COMM_DEVICE_cd;
PCCLASS_DESCRIPTOR FILE_STREAM_cd;
PCCLASS_DESCRIPTOR FSNODE_cd;
PCCLASS_DESCRIPTOR FSN_DIRECTORY_cd;
PCCLASS_DESCRIPTOR FSN_FILE_cd;
PCCLASS_DESCRIPTOR FSN_FILTER_cd;
PCCLASS_DESCRIPTOR KEYBOARD_cd;
PCCLASS_DESCRIPTOR MULTIPLE_PATH_ARGUMENT_cd;
PCCLASS_DESCRIPTOR PATH_ARGUMENT_cd;
PCCLASS_DESCRIPTOR PATH_cd;
PCCLASS_DESCRIPTOR PIPE_cd;
PCCLASS_DESCRIPTOR PIPE_STREAM_cd;
PCCLASS_DESCRIPTOR PRINT_STREAM_cd;
PCCLASS_DESCRIPTOR PROGRAM_cd;
PCCLASS_DESCRIPTOR SCREEN_cd;
PCCLASS_DESCRIPTOR STREAM_MESSAGE_cd;
PCCLASS_DESCRIPTOR STREAM_cd;
PCCLASS_DESCRIPTOR STRING_ARRAY_cd;
PCCLASS_DESCRIPTOR TIMEINFO_ARGUMENT_cd;
PCCLASS_DESCRIPTOR TIMEINFO_cd;
PCCLASS_DESCRIPTOR REST_OF_LINE_ARGUMENT_cd;

//
// Hack because the code to fetch message text in ulib is
// there's 10 layers of stuff to get to the single
// simple thing I want.
//
BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    )
{
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ULONG l,x;
    WCHAR buffer[500];
    WCHAR *text;

    Status = RtlFindMessage(
                NtCurrentPeb()->ImageBaseAddress,
                11, //RT_MESSAGETABLE,
                0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    if(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {
        //
        // Need simple Unicode to OEM conversion.
        //
        text = (WCHAR *)MessageEntry->Text;

    } else {
        //
        // Need ANSI to OEM conversion, which doesn't exist.
        // Thus we convert ANSI to Unicode first.
        //
        Status = RtlMultiByteToUnicodeN(
                    buffer,
                    sizeof(buffer),
                    &l,
                    (char *)MessageEntry->Text,
                    strlen((const char *)MessageEntry->Text) + 1
                    );

        if(!NT_SUCCESS(Status)) {
            return(FALSE);
        }

        text = buffer;
    }

    //
    // Unicode to OEM, leaving the result in the caller's buffer.
    //
    Status = RtlUnicodeToOemN(
                Text,
                BufferLen,
                &l,
                text,
                (wcslen(text)+1) * sizeof(WCHAR)
                );

    //
    // Strip out %0 and anything past it.
    // Note that l includes the terminating nul and there's no need
    // to include it in the scan.
    // Also note that this is not strictly correct for DBCS case but
    // it should be good enough.
    //
    for(x=0; x<(l-2); x++) {
        if((Text[x] == '%') && (Text[x+1] == '0')) {
            Text[x] = 0;
            break;
        }
    }


    return((BOOLEAN)NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\dcache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\dcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\convfat.cxx ===
#include "pch.cxx"  
#include "..\..\cufat\src\convfat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\digraph.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\digraph.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\downgrad.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\downgrad.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\cufat.cxx ===
#include "pch.cxx"  
#include "..\..\cufat\src\cufat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\easet.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\easet.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\drive.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\drive.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\eaheader.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\eaheader.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\extents.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\extents.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fat.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatdir.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatdir.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatntfs.cxx ===
#include "pch.cxx"  
#include "..\..\cufat\src\fatntfs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatsa.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatsa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatdent.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatdent.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatsacnv.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatsacnv.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatsachk.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatsachk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\fatvol.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\fatvol.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\format.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\format.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\frs.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\frs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\filedir.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\filedir.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\hashindx.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\hashindx.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\hmem.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\hmem.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\frsstruc.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\frsstruc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\hackwc.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\hackwc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ifssys.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\ifssys.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ifsutil.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\ifsutil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\indxchk.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxchk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\indxroot.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxroot.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\indxtree.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxtree.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\indxbuff.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\indxbuff.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\intstack.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\intstack.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\iterator.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\iterator.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\logfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\logfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\machine.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\machine.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\largemcb.c ===
#include "..\..\untfs\src\largemcb.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\mem.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\mem.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\listit.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\listit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\makefile.inc ===
rtmsg.mc : ..\..\..\ulib\src\rtmsg.mc
    copy $? $@

#rtmsg.rc: msg00001.bin
#
#rtmsg.h msg00001.bin: rtmsg.mc
#    mc -v -h .\ rtmsg.mc

#
#   From ULIB
#

..\achkmsg.cxx : ..\..\..\ulib\src\achkmsg.cxx

..\array.cxx : ..\..\..\ulib\src\array.cxx

..\arrayit.cxx : ..\..\..\ulib\src\arrayit.cxx

..\basesys.cxx : ..\..\..\ulib\src\basesys.cxx

..\bitvect.cxx : ..\..\..\ulib\src\bitvect.cxx

..\contain.cxx : ..\..\..\ulib\src\contain.cxx

..\clasdesc.cxx : ..\..\..\ulib\src\clasdesc.cxx

..\cmem.cxx : ..\..\..\ulib\src\cmem.cxx

..\hmem.cxx : ..\..\..\ulib\src\hmem.cxx

..\iterator.cxx : ..\..\..\ulib\src\iterator.cxx

..\list.cxx : ..\..\..\ulib\src\list.cxx

..\listit.cxx : ..\..\..\ulib\src\listit.cxx

..\machine.cxx : ..\..\..\ulib\src\machine.cxx

..\mem.cxx : ..\..\..\ulib\src\mem.cxx

..\membmgr.cxx : ..\..\..\ulib\src\membmgr.cxx

..\membmgr2.cxx : ..\..\..\ulib\src\membmgr2.cxx

..\message.cxx : ..\..\..\ulib\src\message.cxx

..\newdel.cxx : ..\..\..\ulib\src\newdel.cxx

..\object.cxx : ..\..\..\ulib\src\object.cxx

..\prnthack.cxx : ..\..\..\ulib\src\prnthack.cxx

..\seqcnt.cxx : ..\..\..\ulib\src\seqcnt.cxx

..\sortcnt.cxx : ..\..\..\ulib\src\sortcnt.cxx

..\sortlist.cxx : ..\..\..\ulib\src\sortlist.cxx

..\sortlit.cxx : ..\..\..\ulib\src\sortlit.cxx

..\spackmsg.cxx : ..\..\..\ulib\src\spackmsg.cxx

..\tmackmsg.cxx : ..\..\..\ulib\src\tmackmsg.cxx

..\ulib.cxx : ..\..\..\ulib\src\ulib.cxx

..\wstring.cxx : ..\..\..\ulib\src\wstring.cxx

..\arg.cxx : ..\..\..\ulib\src\arg.cxx



#
#   From IFSUTIL
#
..\bigint.cxx : ..\..\..\ifsutil\src\bigint.cxx

..\cache.cxx : ..\..\..\ifsutil\src\cache.cxx

..\cannedsd.cxx : ..\..\..\ifsutil\src\cannedsd.cxx

..\digraph.cxx : ..\..\..\ifsutil\src\digraph.cxx

..\drive.cxx : ..\..\..\ifsutil\src\drive.cxx

..\ifssys.cxx : ..\..\..\ifsutil\src\ifssys.cxx

..\ifsutil.cxx : ..\..\..\ifsutil\src\ifsutil.cxx

..\intstack.cxx : ..\..\..\ifsutil\src\intstack.cxx

..\mpmap.cxx : ..\..\..\ifsutil\src\mpmap.cxx

..\numset.cxx : ..\..\..\ifsutil\src\numset.cxx

..\secrun.cxx : ..\..\..\ifsutil\src\secrun.cxx

..\spaset.cxx : ..\..\..\ifsutil\src\spaset.cxx

..\supera.cxx : ..\..\..\ifsutil\src\supera.cxx

..\volume.cxx : ..\..\..\ifsutil\src\volume.cxx

..\autoentr.cxx : ..\..\..\ifsutil\src\autoentr.cxx

..\autoreg.cxx : ..\..\..\ifsutil\src\autoreg.cxx

..\bootreg.c : ..\..\..\ifsutil\src\bootreg.c

..\dcache.cxx : ..\..\..\ifsutil\src\dcache.cxx

..\rcache.cxx : ..\..\..\ifsutil\src\rcache.cxx

..\rwcache.cxx : ..\..\..\ifsutil\src\rwcache.cxx

..\tlink.cxx : ..\..\..\ifsutil\src\tlink.cxx

#
#   From UFAT
#
..\cluster.cxx : ..\..\..\ufat\src\cluster.cxx

..\eaheader.cxx : ..\..\..\ufat\src\eaheader.cxx

..\easet.cxx : ..\..\..\ufat\src\easet.cxx

..\fat.cxx : ..\..\..\ufat\src\fat.cxx

..\fatdent.cxx : ..\..\..\ufat\src\fatdent.cxx

..\fatdir.cxx : ..\..\..\ufat\src\fatdir.cxx

..\fatsa.cxx : ..\..\..\ufat\src\fatsa.cxx

..\rfatsa.cxx : ..\..\..\ufat\src\rfatsa.cxx

..\fatsachk.cxx : ..\..\..\ufat\src\fatsachk.cxx

..\fatsacnv.cxx : ..\..\..\ufat\src\fatsacnv.cxx

..\fatvol.cxx : ..\..\..\ufat\src\fatvol.cxx

..\filedir.cxx : ..\..\..\ufat\src\filedir.cxx

..\hashindx.cxx : ..\..\..\ufat\src\hashindx.cxx

..\reloclus.cxx : ..\..\..\ufat\src\reloclus.cxx

..\rootdir.cxx : ..\..\..\ufat\src\rootdir.cxx

..\ufat.cxx : ..\..\..\ufat\src\ufat.cxx



#
#   From UNTFS
#
..\attrcol.cxx : ..\..\..\untfs\src\attrcol.cxx

..\attrdef.cxx : ..\..\..\untfs\src\attrdef.cxx

..\attrib.cxx : ..\..\..\untfs\src\attrib.cxx

..\attrlist.cxx : ..\..\..\untfs\src\attrlist.cxx

..\attrrec.cxx : ..\..\..\untfs\src\attrrec.cxx

..\badfile.cxx : ..\..\..\untfs\src\badfile.cxx

..\bitfrs.cxx : ..\..\..\untfs\src\bitfrs.cxx

..\bootfile.cxx : ..\..\..\untfs\src\bootfile.cxx

..\clusrun.cxx : ..\..\..\untfs\src\clusrun.cxx

..\downgrad.cxx : ..\..\..\untfs\src\downgrad.cxx

..\extents.cxx : ..\..\..\untfs\src\extents.cxx

..\format.cxx : ..\..\..\untfs\src\format.cxx

..\frs.cxx : ..\..\..\untfs\src\frs.cxx

..\frsstruc.cxx : ..\..\..\untfs\src\frsstruc.cxx

..\hackwc.cxx : ..\..\..\untfs\src\hackwc.cxx

..\indxbuff.cxx : ..\..\..\untfs\src\indxbuff.cxx

..\indxchk.cxx : ..\..\..\untfs\src\indxchk.cxx

..\indxroot.cxx : ..\..\..\untfs\src\indxroot.cxx

..\indxtree.cxx : ..\..\..\untfs\src\indxtree.cxx

..\largemcb.c : ..\..\..\untfs\src\largemcb.c

..\logfile.cxx : ..\..\..\untfs\src\logfile.cxx

..\mft.cxx : ..\..\..\untfs\src\mft.cxx

..\mftfile.cxx : ..\..\..\untfs\src\mftfile.cxx

..\mftinfo.cxx : ..\..\..\untfs\src\mftinfo.cxx

..\mftref.cxx : ..\..\..\untfs\src\mftref.cxx

..\ntfsbit.cxx : ..\..\..\untfs\src\ntfsbit.cxx

..\ntfschk.cxx : ..\..\..\untfs\src\ntfschk.cxx

..\ntfssa.cxx : ..\..\..\untfs\src\ntfssa.cxx

..\ntfsvol.cxx : ..\..\..\untfs\src\ntfsvol.cxx

..\rafile.cxx : ..\..\..\untfs\src\rafile.cxx

..\rasd.cxx : ..\..\..\untfs\src\rasd.cxx

..\sdchk.cxx : ..\..\..\untfs\src\sdchk.cxx

..\untfs.cxx : ..\..\..\untfs\src\untfs.cxx

..\upcase.cxx : ..\..\..\untfs\src\upcase.cxx

..\upfile.cxx : ..\..\..\untfs\src\upfile.cxx

..\usnjrnl.cxx : ..\..\..\untfs\src\usnjrnl.cxx

#
#   From CUFAT
#
..\convfat.cxx : ..\..\..\cufat\src\convfat.cxx

..\cufat.cxx : ..\..\..\cufat\src\cufat.cxx

..\fatntfs.cxx : ..\..\..\cufat\src\fatntfs.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\list.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\list.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\membmgr.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\membmgr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\mft.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\mft.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\mftfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\mftfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\mftinfo.cxx ===
#include "pch.cxx"
#include "..\..\untfs\src\mftinfo.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\membmgr2.cxx ===
#include "pch.cxx"
#include "..\..\ulib\src\membmgr2.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\message.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\message.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\mftref.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\mftref.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\newdel.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\newdel.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\mpmap.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\mpmap.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ntfschk.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfschk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\numset.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\numset.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ntfsbit.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfsbit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ntfssa.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfssa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ntfsvol.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\ntfsvol.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\object.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\object.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\rafile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\rafile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\rasd.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\rasd.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\prnthack.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\prnthack.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    This module implements pre-compiled headers for ntlib.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

//
// ULIB headers.
//

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "smsg.hxx"
#include "cmem.hxx"
#include "basesys.hxx"
#include "buffer.hxx"
#include "contain.hxx"
#include "hmem.hxx"
#include "achkmsg.hxx"
#include "error.hxx"
#include "ifsentry.hxx"
#include "ifsserv.hxx"
#include "iterator.hxx"
#include "list.hxx"
#include "listit.hxx"
#include "mem.hxx"
#include "membmgr.hxx"
#include "membmgr2.hxx"
#include "program.hxx"
#include "rtmsg.h"
#include "seqcnt.hxx"
#include "sortcnt.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "string.hxx"
#include "stringar.hxx"
#include "substrng.hxx"
#include "ulibcl.hxx"
#include "object.hxx"
#include "clasdesc.hxx"


//
// IFSUTIL headers.
//

#include "autoentr.hxx"
#include "autoreg.hxx"
#include "bigint.hxx"
#include "bpb.hxx"
#include "cache.hxx"
#include "cannedsd.hxx"
#include "dcache.hxx"
#include "digraph.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "intstack.hxx"
#include "mldcopy.hxx"
#include "numset.hxx"
#include "rcache.hxx"
#include "rwcache.hxx"
#include "secrun.hxx"
#include "supera.hxx"
#include "volume.hxx"

//
// UFAT headers.
//

#include "cluster.hxx"
#include "eaheader.hxx"
#include "easet.hxx"
#include "fat.hxx"
#include "fatdir.hxx"
#include "fatsa.hxx"
#include "fatdent.hxx"
#include "fatvol.hxx"
#include "filedir.hxx"
#include "reloclus.hxx"
#include "rfatsa.hxx"
#include "rootdir.hxx"
#include "hashindx.hxx"

//
// UNTFS headers.
//

#include "untfs.hxx"
#include "attrcol.hxx"
#include "attrdef.hxx"
#include "attrib.hxx"
#include "attrlist.hxx"
#include "attrrec.hxx"
#include "badfile.hxx"
#include "bitfrs.hxx"
#include "bootfile.hxx"
#include "clusrun.hxx"
#include "extents.hxx"
#include "frs.hxx"
#include "frsstruc.hxx"
#include "hackwc.hxx"
#include "indxbuff.hxx"
#include "indxroot.hxx"
#include "indxtree.hxx"
#include "logfile.hxx"
#include "mft.hxx"
#include "mftfile.hxx"
#include "mftinfo.hxx"
#include "mftref.hxx"
#include "ntfsbit.hxx"
#include "ntfssa.hxx"
#include "ntfsvol.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\rcache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\rcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\rootdir.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\rootdir.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\reloclus.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\reloclus.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\rfatsa.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\rfatsa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\secrun.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\secrun.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\sdchk.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\sdchk.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\seqcnt.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\seqcnt.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\rwcache.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\rwcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\sortlit.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\sortlit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\smsdtect.cxx ===
#include "pch.cxx"
#include "..\..\ifsutil\src\smsdtect.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\sortcnt.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\sortcnt.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\sortlist.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\sortlist.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\spaset.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\spaset.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\spackmsg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\spackmsg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

NT_UP=0

TARGETNAME=ntlib
TARGETPATH=obj
TARGETTYPE=LIBRARY

PRECOMPILED_INCLUDE= ..\pch.cxx

SOURCES= \
    rtmsg.mc \
    ..\achkmsg.cxx     \
    ..\arg.cxx         \
    ..\array.cxx       \
    ..\arrayit.cxx     \
    ..\attrcol.cxx     \
    ..\attrdef.cxx     \
    ..\attrib.cxx      \
    ..\attrlist.cxx    \
    ..\attrrec.cxx     \
    ..\autoentr.cxx    \
    ..\autoreg.cxx     \
    ..\badfile.cxx     \
    ..\basesys.cxx     \
    ..\bigint.cxx      \
    ..\bitfrs.cxx      \
    ..\bitvect.cxx     \
    ..\bootfile.cxx    \
    ..\boothack.cxx \
    ..\bootreg.c       \
    ..\cache.cxx       \
    ..\cannedsd.cxx    \
    ..\clasdesc.cxx    \
    ..\clusrun.cxx     \
    ..\cluster.cxx     \
    ..\cmem.cxx        \
    ..\contain.cxx     \
    ..\convfat.cxx     \
    ..\cufat.cxx       \
    ..\digraph.cxx     \
    ..\dcache.cxx      \
    ..\downgrad.cxx    \
    ..\drive.cxx       \
    ..\eaheader.cxx    \
    ..\easet.cxx       \
    ..\extents.cxx     \
    ..\fat.cxx         \
    ..\fatdent.cxx     \
    ..\fatdir.cxx      \
    ..\fatntfs.cxx     \
    ..\fatsa.cxx       \
    ..\fatsachk.cxx    \
    ..\fatsacnv.cxx    \
    ..\fatvol.cxx      \
    ..\filedir.cxx     \
    ..\format.cxx      \
    ..\frs.cxx         \
    ..\frsstruc.cxx    \
    ..\hackwc.cxx      \
    ..\hashindx.cxx    \
    ..\hmem.cxx        \
    ..\ifssys.cxx      \
    ..\ifsutil.cxx     \
    ..\indxbuff.cxx    \
    ..\indxchk.cxx     \
    ..\indxroot.cxx    \
    ..\indxtree.cxx    \
    ..\intstack.cxx    \
    ..\iterator.cxx    \
    ..\largemcb.c      \
    ..\list.cxx        \
    ..\listit.cxx      \
    ..\logfile.cxx     \
    ..\machine.cxx     \
    ..\mem.cxx         \
    ..\membmgr.cxx     \
    ..\membmgr2.cxx    \
    ..\message.cxx     \
    ..\mpmap.cxx       \
    ..\mft.cxx         \
    ..\mftfile.cxx     \
    ..\mftinfo.cxx     \
    ..\mftref.cxx      \
    ..\newdel.cxx      \
    ..\ntfsbit.cxx     \
    ..\ntfschk.cxx     \
    ..\ntfssa.cxx      \
    ..\ntfsvol.cxx     \
    ..\numset.cxx      \
    ..\object.cxx      \
    ..\rafile.cxx      \
    ..\rasd.cxx        \
    ..\rcache.cxx      \
    ..\reloclus.cxx    \
    ..\rfatsa.cxx      \
    ..\rootdir.cxx     \
    ..\rwcache.cxx     \
    ..\sdchk.cxx       \
    ..\secrun.cxx      \
    ..\seqcnt.cxx      \
    ..\smsdtect.cxx    \
    ..\sortcnt.cxx     \
    ..\sortlist.cxx    \
    ..\sortlit.cxx     \
    ..\spackmsg.cxx    \
    ..\spaset.cxx      \
    ..\supera.cxx      \
    ..\tlink.cxx       \
    ..\tmackmsg.cxx    \
    ..\ufat.cxx        \
    ..\ulib.cxx        \
    ..\untfs.cxx       \
    ..\upfile.cxx      \
    ..\upcase.cxx      \
    ..\usnjrnl.cxx     \
    ..\volume.cxx      \
    ..\wstring.cxx

INCLUDES=..;\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc;\
    $(PROJECT_ROOT)\fs\utils\cufat\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(ADMIN_INC_PATH);

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -D_AUTOCONV_ -DUNICODE=1 -D_NTDRIVER_
NTTARGETFILES=

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

W32_SB=1
SOURCES_USED=..\sources.inc
USE_NTDLL=1

BUFFER_OVERFLOW_CHECKS=NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\supera.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\supera.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\tmackmsg.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\tmackmsg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ufat.cxx ===
#include "pch.cxx"  
#include "..\..\ufat\src\ufat.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\tlink.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\tlink.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\ulib.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\ulib.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\usa\makefile.inc ===
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\upcase.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\upcase.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\usnjrnl.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\usnjrnl.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\untfs.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\untfs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\upfile.cxx ===
#include "pch.cxx"  
#include "..\..\untfs\src\upfile.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\volume.cxx ===
#include "pch.cxx"  
#include "..\..\ifsutil\src\volume.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ntlib\src\wstring.cxx ===
#include "pch.cxx"  
#include "..\..\ulib\src\wstring.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\openfiles.h ===
// ****************************************************************************
//
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//
//        OpenFiles.h
//
//  Abstract:
//
//        macros and function prototypes of OpenFiles.cpp
//
//  Author:
//
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//
//  Revision History:
//
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
//
// ****************************************************************************

#ifndef _OPENFILES_H
#define _OPENFILES_H
#include "pch.h"
#include "resource.h"
#include "chstring.h"
#define FORMAT_OPTIONS GetResString(IDS_FORMAT_OPTIONS)
#define OPENMODE_OPTIONS GetResString(IDS_OPENMODE_OPTION)

#define NULL_CHAR                       L'\0'

// command line options and their indexes in the array
#define MAX_OPTIONS                 5
#define MAX_QUERY_OPTIONS        7
#define MAX_DISCONNECT_OPTIONS   8
#define MAX_LOCAL_OPTIONS        1

#define INVALID_USER_CHARS L"\\/\"[]:|<>+=;,?@" // * is allowed.
#define INVALID_FILE_NAME_CHARS L"/?\"<>|"
// options allowed ( no need to localize )
    // command line options
const WCHAR szDisconnectOption[]    = L"disconnect";
const WCHAR szQueryOption[]         = L"query";
const WCHAR szUsageOption[]         = L"?";
const WCHAR szServerNameOption[]    = L"s";
const WCHAR szUserNameOption[]      = L"u";
const WCHAR szPasswordOption[]      = L"p";
const WCHAR szIDOption[]            = L"id";
const WCHAR szAccessedByOption[]    = L"a";
const WCHAR szOpenModeOption[]      = L"o";;
const WCHAR szOpenFileOption[]      = L"op";
const WCHAR szFormatOption[]        = L"fo";
const WCHAR szNoHeadeOption[]       = L"nh";
const WCHAR szVerboseOption[]       = L"v";
const WCHAR szLocalOption[]         = L"local";

#define DOUBLE_SLASH                _T("\\\\")
#define SINGLE_SLASH                _T("\\")
#define SINGLE_DOT                  _T(".")
#define DOT_DOT                      L".."
#define BLANK_LINE                    L"\n"


// option indexes MAIN
#define OI_DISCONNECT                0
#define OI_QUERY                    1
#define OI_USAGE                    2
#define OI_LOCAL                    3
#define OI_DEFAULT                  4

// Option Indexes QUERY
#define OI_Q_QUERY                  0
#define OI_Q_SERVER_NAME            1
#define OI_Q_USER_NAME              2
#define OI_Q_PASSWORD               3
#define OI_Q_FORMAT                 4
#define OI_Q_NO_HEADER              5
#define OI_Q_VERBOSE                6

// Option Indexes DISCONNECT
#define OI_D_DISCONNECT             0
#define OI_D_SERVER_NAME            1
#define OI_D_USER_NAME              2
#define OI_D_PASSWORD               3
#define OI_D_ID                     4
#define OI_D_ACCESSED_BY            5
#define OI_D_OPEN_MODE              6
#define OI_D_OPEN_FILE              7

// Option Indexes for LOCAL
#define OI_O_LOCAL                  0

// Option Index for showresult for locally open files
// LOF means Localy Open Files
#define LOF_ID                      0
#define LOF_TYPE                    1
#define LOF_ACCESSED_BY             2
#define LOF_PID                     3
#define LOF_PROCESS_NAME            4
#define LOF_OPEN_FILENAME           5


// No of columns in locally open file
#define NO_OF_COL_LOCAL_OPENFILE    6

// Column width for local open file showresult
#define COL_L_ID                       5
#define COL_L_TYPE                     10
#define COL_L_ACCESSED_BY              15
#define COL_L_PROCESS_NAME             20
#define COL_L_PID                       8
#define COL_L_OPEN_FILENAME            50

BOOL 
DoLocalOpenFiles(
    IN DWORD dwFormat,
    IN BOOL bShowNoHeader,
    IN BOOL bVerbose,
    IN LPCTSTR pszLocalValue
    );
BOOL 
GetProcessOwner(
    OUT LPTSTR pszUserName,
    IN  DWORD hFile
    );

#define MAC_DLL_FILE_NAME           L"\\SFMAPI.DLL"
#define NTAUTHORITY_USER            L"NT AUTHORITY"
#define MIN_MEMORY_REQUIRED         256
// Macro definitions
#define SAFEDELETE(pObj) \
    if (pObj) \
    {   \
        delete[] pObj; \
        pObj = NULL; \
    }

#define SAFEIRELEASE(pIObj) \
    if (pIObj)  \
    {\
        pIObj->Release();   \
        pIObj = NULL;\
    }

// SAFEBSTRFREE
#define SAFEBSTRFREE(bstrVal) \
    if (bstrVal) \
    {   \
        SysFreeString(bstrVal); \
        bstrVal = NULL; \
    }
#define SAFERELDYNARRAY(pArray)\
        if(pArray!=NULL)\
        {\
            DestroyDynamicArray(&pArray);\
            pArray = NULL;\
        }

#define FREE_LIBRARY(hModule)\
        if(hModule!=NULL)\
        {\
            ::FreeLibrary (hModule);\
            hModule = NULL;\
        }

// Following are Windows Undocumented defines and structures
//////////////////////////////////////////////////////////////////
// START UNDOCUMETED FEATURES
//////////////////////////////////////////////////////////////////

#define AFP_OPEN_MODE_NONE                0x00000000
#define AFP_OPEN_MODE_READ                0x00000001
#define AFP_OPEN_MODE_WRITE                0x00000002

// Fork type of an open file
#define    AFP_FORK_DATA                    0x00000000
#define    AFP_FORK_RESOURCE                0x00000001

typedef struct _AFP_FILE_INFO
{
    DWORD    afpfile_id;                    // Id of the open file fork
    DWORD    afpfile_open_mode;            // Mode in which file is opened
    DWORD    afpfile_num_locks;            // Number of locks on the file
    DWORD    afpfile_fork_type;            // Fork type
    LPWSTR    afpfile_username;            // File opened by this user. max UNLEN
    LPWSTR    afpfile_path;                // Absolute canonical path to the file

} AFP_FILE_INFO, *PAFP_FILE_INFO;
// Used as RPC binding handle to server
typedef ULONG_PTR    AFP_SERVER_HANDLE;
typedef ULONG_PTR    *PAFP_SERVER_HANDLE;

/////////////////////////////////////////////////////////////////////////////
// END UNDOCUMETED FEATURES
/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\disconnect.h ===
// ****************************************************************************
//
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//
//        Disconnect.h
//
//  Abstract:
//
//        macros and function prototypes of Disconnect.cpp
//
//  Author:
//
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//
//  Revision History:
//
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
//
// ****************************************************************************

#ifndef _DISCONNECT_H
#define _DISCONNECT_H
#include "openfiles.h"
#ifdef __cplusplus
extern "C" {
#endif

#define ID_HELP_START                IDS_HELP_LINE1
#define ID_HELP_END                    IDS_HELP_LINE36

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString(\
                                            IDS_ERROR_USERNAME_BUT_NOMACHINE)

#define ERROR_PASSWORD_BUT_NOUSERNAME    GetResString(\
                                            IDS_ERROR_PASSWORD_BUT_NOUSERNAME )


#define FAILURE                        GetResString(IDS_FAILURE)
#define SUCCESS                        GetResString(IDS_SUCCESS)
#define DISCONNECTED_SUCCESSFULLY   GetResString(IDS_SUCCESS_DISCONNECT)
#define DISCONNECT_UNSUCCESSFUL      GetResString(IDS_ERROR_DISCONNECT)
#define WILD_CARD                    _T("*")

#define READ_MODE                    GetResString(IDS_READ)
#define WRITE_MODE                    GetResString(IDS_WRITE)
#define READ_WRITE_MODE                GetResString(IDS_READ_SLASH_WRITE)
#define WRITE_READ_MODE                GetResString(IDS_WRITE_SLASH_READ)
#define PIPE_STRING                 L"\\PIPE\\srvsvc"
#define DOT_EOL                     GetResString(IDS_DOT_EOL)


BOOL
DisconnectOpenFile( 
    IN PTCHAR pszServer,
    IN PTCHAR pszID,
    IN PTCHAR pszAccessedby,
    IN PTCHAR pszOpenmode,
    IN PTCHAR pszOpenFile 
    );

BOOL 
IsNamedPipePath(
    IN LPWSTR pszwFilePath
    );

BOOL
IsSpecifiedID(
    IN LPTSTR pszId,
    IN DWORD dwId);

BOOL 
IsSpecifiedAccessedBy(
    IN LPTSTR pszAccessedby, 
    IN LPWSTR pszwAccessedby);

BOOL 
IsSpecifiedOpenmode(
    IN LPTSTR pszOpenmode, 
    IN DWORD  dwOpenmode);

BOOL 
IsSpecifiedOpenfile(
    IN LPTSTR pszOpenfile, 
    IN LPWSTR pszwOpenfile);

#ifdef __cplusplus
}
#endif

#endif    // _DISCONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\disconnect.cpp ===
/******************************************************************************
Copyright (c) Microsoft Corporation

Module Name:

    Disconnect.cpp

Abstract:

    Disconnects one or more open files

Author:

     Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000

Revision History:

       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.

******************************************************************************/
//include headers
#include "pch.h"
#include "Disconnect.h"

BOOL
DisconnectOpenFile( 
    IN PTCHAR pszServer,
    IN PTCHAR pszID,
    IN PTCHAR pszAccessedby,
    IN PTCHAR pszOpenmode,
    IN PTCHAR pszOpenFile 
    )
/*++
Routine Description:

Disconnects one or more openfiles


Arguments:

    [in]    pszServer      - remote server name
    [in]    pszID          - Open file ids
    [in]    pszAccessedby  - Name of  user name who access the file
    [in]    pszOpenmode    - accessed mode
    [in]    pszOpenFile    - Open file name

Returned Value:

            - TRUE for success exit
            - FALSE for failure exit
--*/
{
    // local variables to this function
    // Stores fuctions return value status.
    BOOL bResult = FALSE;

    // Receives the count of elements actually enumerated by "NetFileEnum" 
    // function
    DWORD dwEntriesRead = 0;
    
    // Receives the total number of entries that could have been enumerated from 
    // the current resume position by "NetFileEnum" function.
    DWORD dwTotalEntries = 0;

    // Contains a resume handle which is used to continue an existing file 
    // search. The handle should be zero on the first call and left unchanged 
    // for subsequent calls. If resume_handle is NULL,  then no resume handle 
    // is stored. This variable used in calling "NetFileEnum" function.
    DWORD dwResumeHandle = 0;

    // LPFILE_INFO_3  structure contains the identification number and other
    // pertinent information about files, devices, and pipes.
    LPFILE_INFO_3 pFileInfo3_1 = NULL; 
    LPFILE_INFO_3 pFileInfo3_1_Ori = NULL; 

    // Contains return value for "NetFileEnum" function.
    DWORD dwError = 0;

    // Stores return value for NetFileClose function.
    NET_API_STATUS nStatus = 0;

    TCHAR szResult[(MAX_RES_STRING*2)];

    AFP_FILE_INFO* pFileInfo = NULL;
    AFP_FILE_INFO* pFileInfoOri = NULL;
    DWORD hEnumHandle = 0;
    AFP_SERVER_HANDLE ulSFMServerConnection = 0;
    
    // buffer for Windows directory path.
    TCHAR   szDllPath[MAX_PATH+1];


    HMODULE hModule = 0;          // To store retval for LoadLibrary

    typedef DWORD (*AFPCONNECTIONCLOSEPROC) (AFP_SERVER_HANDLE,DWORD); 
    typedef DWORD (*CONNECTPROC) (LPWSTR,PAFP_SERVER_HANDLE);
    typedef DWORD (*FILEENUMPROC)(AFP_SERVER_HANDLE,LPBYTE*,
                                                DWORD,LPDWORD,LPDWORD,LPDWORD);

    AFPCONNECTIONCLOSEPROC AfpAdminFileClose = NULL;
    CONNECTPROC  AfpAdminConnect = NULL;
    FILEENUMPROC AfpAdminFileEnum = NULL;// Function Pointer


    //varibles to store whether the given credentials are matching with the
    //got credentials.

    BOOL    bId = FALSE;
    BOOL    bAccessedBy = FALSE;
    BOOL    bOpenmode   = FALSE;
    BOOL    bOpenfile   = FALSE;
    BOOL    bIfatleast  = FALSE;

    SecureZeroMemory(szResult, sizeof(szResult));
    SecureZeroMemory(szDllPath, sizeof(szDllPath));
    do
    {
        // Get the block of files
        dwError = NetFileEnum( pszServer,
                               NULL,
                               NULL,
                               3,
                               (LPBYTE *)&pFileInfo3_1,
                               MAX_PREFERRED_LENGTH,
                               &dwEntriesRead,
                               &dwTotalEntries,
                               (PDWORD_PTR)&dwResumeHandle );
        if( ERROR_ACCESS_DENIED == dwError)
        {
            SetLastError(E_ACCESSDENIED);
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return FALSE;
        }
        pFileInfo3_1_Ori = pFileInfo3_1;
        if( NERR_Success  == dwError  || ERROR_MORE_DATA  == dwError)
        {
            for ( DWORD dwFile = 0;
                  dwFile < dwEntriesRead;
                  dwFile++, pFileInfo3_1++ )
            {
                //Check whether the got open file is file or names pipe.
                // If named pipe leave it. As this utility do not
                // disconnect Named pipe
                if ( IsNamedPipePath(pFileInfo3_1->fi3_pathname ) )
                {
                    continue;
                }

                //Not a named pipe. is a file
                else
                {
                    bId = IsSpecifiedID(pszID,pFileInfo3_1->fi3_id);
                    bAccessedBy = IsSpecifiedAccessedBy(pszAccessedby,
                                                   pFileInfo3_1->fi3_username);
                    bOpenmode = IsSpecifiedOpenmode(pszOpenmode,
                                                pFileInfo3_1->fi3_permissions);
                    bOpenfile = IsSpecifiedOpenfile(pszOpenFile,
                                                pFileInfo3_1->fi3_pathname);
                    // Proceed for dicconecting the open file only if
                    // all previous fuction returns true. This insures that
                    // user preference is taken care.

                    if( bId &&
                        bAccessedBy &&
                        bOpenmode &&
                        bOpenfile)
                    {
                        bIfatleast = TRUE;
                        SecureZeroMemory(szResult, sizeof(szResult));
                        
                        //The NetFileClose function forces a resource to close.
                        nStatus = NetFileClose(pszServer,
                                               pFileInfo3_1->fi3_id);
                        if( NERR_Success == nStatus)
                        {
                            // Create the output message string as File
                            // is successfully deleted.
                            // Output string will be :
                            // SUCCESS: Connection to openfile "filename"
                            // has been terminated.
                            bResult = TRUE;

                            StringCchPrintfW(szResult,SIZE_OF_ARRAY(szResult), 
                                              DISCONNECTED_SUCCESSFULLY,
                                              pFileInfo3_1->fi3_pathname);
                            ShowMessage(stdout, szResult);
                        }
                        else
                        {
                           // As unable to disconnect the openfile make
                           // output message as
                           // ERROR: could not dissconnect "filename".
                            bResult = FALSE;
                            
                            StringCchPrintfW(szResult, SIZE_OF_ARRAY(szResult), 
                                             DISCONNECT_UNSUCCESSFUL,
                                             pFileInfo3_1->fi3_pathname);
                            ShowMessage(stderr, szResult);
                        }
                        // Display output result as previously constructed.
                    }//If bId...
                }//else part of is named pipe
             }
        }

        // Free the block
        if( NULL != pFileInfo3_1_Ori )
        {
            NetApiBufferFree( pFileInfo3_1_Ori );
            pFileInfo3_1 = NULL;
        }
   } while ( ERROR_MORE_DATA  == dwError);

    // Now disconnect files for MAC OS
    // DLL required is stored always in \windows\system32 directory....
    // so get windows directory first.
    if( 0 != GetSystemDirectory(szDllPath, MAX_PATH))
    {
        StringConcat(szDllPath,MAC_DLL_FILE_NAME,MAX_PATH);
        hModule = ::LoadLibrary (szDllPath);

        if( NULL == hModule)
        {
            ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));

            // Shows the error string set by API function.
            ShowLastError(stderr); 
            return FALSE;

        }
    }
    else
    {
            ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
            
            // Shows the error string set by API function.
            ShowLastError(stderr); 
            return FALSE;
    }

    AfpAdminConnect = 
        (CONNECTPROC)::GetProcAddress (hModule,"AfpAdminConnect");
    AfpAdminFileClose = 
    ( AFPCONNECTIONCLOSEPROC)::GetProcAddress (hModule,"AfpAdminFileClose");
    AfpAdminFileEnum = 
        (FILEENUMPROC)::GetProcAddress (hModule,"AfpAdminFileEnum");

    // Check if  all function pointer successfully taken from DLL
    // if not show error message and exit
    if(( NULL == AfpAdminFileClose)||
        ( NULL == AfpAdminConnect)||
        ( NULL == AfpAdminFileEnum))

    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));

        // Shows the error string set by API function.
        ShowLastError(stderr); 
        FREE_LIBRARY(hModule);
        return FALSE;
    }

    // Connection ID is requered for AfpAdminFileEnum function so
    // connect to server to get connect id...
    DWORD retval_connect =  AfpAdminConnect(const_cast<LPWSTR>(pszServer),
                            &ulSFMServerConnection );
    if( 0 != retval_connect)
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        
        // Shows the error string set by API function.
        ShowLastError(stderr); 
        FREE_LIBRARY(hModule);
            return FALSE;
    }
    do
    {
       dwError = AfpAdminFileEnum( ulSFMServerConnection,
                                 (PBYTE*)&pFileInfo,
                                 (DWORD)-1L,
                                 &dwEntriesRead,
                                 &dwTotalEntries,
                                 &hEnumHandle );
        if( ERROR_ACCESS_DENIED == dwError)
        {
            SetLastError(E_ACCESSDENIED);
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            FREE_LIBRARY(hModule);
            return FALSE;
        }
        
        pFileInfoOri = pFileInfo;
        if( NERR_Success == dwError || ERROR_MORE_DATA  == dwError)
        {
            for ( DWORD dwFile = 0;
                  dwFile < dwEntriesRead;
                  dwFile++, pFileInfo++ )
            {
                //Check whether the got open file is file or names pipe.
                // If named pipe leave it. As this utility do not
                // disconnect Named pipe
                if ( IsNamedPipePath(pFileInfo->afpfile_path ) )
                {
                    continue;
                }

                //Not a named pipe. is a file
                else
                {
                    bId = IsSpecifiedID(pszID,pFileInfo->afpfile_id );
                    bAccessedBy = IsSpecifiedAccessedBy(pszAccessedby,
                                                  pFileInfo->afpfile_username);
                    bOpenmode = IsSpecifiedOpenmode(pszOpenmode,
                                                pFileInfo->afpfile_open_mode);
                    bOpenfile = IsSpecifiedOpenfile(pszOpenFile,
                                                pFileInfo->afpfile_path);
                    // Proceed for dicconecting the open file only if
                    // all previous fuction returns true. This insures that
                    // user preference is taken care.

                    if( bId &&
                        bAccessedBy &&
                        bOpenmode &&
                        bOpenfile)
                    {
                        bIfatleast = TRUE;
                        SecureZeroMemory(szResult, sizeof(szResult));

                        nStatus = AfpAdminFileClose(ulSFMServerConnection,
                                                  pFileInfo->afpfile_id);
                        if( NERR_Success == nStatus)
                        {
                            // Create the output message string as File
                            // is successfully deleted.
                            // Output string will be :
                            // SUCCESS: Connection to openfile "filename"
                            // has been terminated.
                            bResult = TRUE;

                            StringCchPrintfW(szResult,SIZE_OF_ARRAY(szResult), 
                                             DISCONNECTED_SUCCESSFULLY,
                                             pFileInfo->afpfile_path);
                            ShowMessage(stdout, szResult);

                            bResult = TRUE;
                        }
                        else
                        {
                           // As unable to disconnect the openfile make
                           // output message as
                           // ERROR: could not dissconnect "filename".
                            bResult = FALSE;
                            StringCchPrintfW(szResult, SIZE_OF_ARRAY(szResult),
                                             DISCONNECT_UNSUCCESSFUL,
                                             pFileInfo3_1->fi3_pathname);
                            ShowMessage(stderr, szResult);
                        }
                    }//If bId...
                }//else part of is named pipe
             }
        }

        // Free the block
        if( NULL != pFileInfoOri)
        {
            NetApiBufferFree( pFileInfoOri);
            pFileInfo = NULL;
        }

   } while ( ERROR_MORE_DATA  == dwError);

    // As not a single open file disconnected
    // show Info. message as
    // INFO: No. open files found.
    if( FALSE == bIfatleast)
    {
        ShowMessage(stdout,GetResString(IDS_NO_D_OPENFILES));
    }

    FREE_LIBRARY(hModule);
    return TRUE;
}

BOOL
IsNamedPipePath(
    IN LPWSTR pszwFilePath
    )
/*++

Routine Description:

Tests whether the given file path is namedpipe path or a file path

Arguments:

    [in] pszwFilePath    -- Null terminated string specifying the path name

Returned Value:

TRUE    - if it is a named pipe path
FALSE   - if it is a file path
--*/
{
    // If PIPE_STRING found then return TRUE else FALSE.
    if( NULL == FindString(pszwFilePath, PIPE_STRING,0))
    {
        return FALSE;
    }
   return TRUE;
}//IsNamedPipePath

BOOL
IsSpecifiedID(
    IN LPTSTR pszId, 
    IN DWORD dwId
    )
/*++

Routine Description:

Tests whether the user specified open file id is equivalent to the api
returned id.

Arguments:

    [in]    pszId   -Null terminated string specifying the user
                     specified fil ID
    [in]    dwId    -current file ID.

Returned Value:

TRUE    - if pszId is * or equal to dwId
FALSE   - otherwise
--*/
{
   // Check if WILD card is given OR no id is given OR given id and
   // id returned by api is similar. In any of the case return TRUE.

    if((0 == StringCompare(pszId, WILD_CARD,FALSE, 0)) ||
       (0 == StringLength(pszId, 0))||
       ((DWORD)(_ttol(pszId)) == dwId))
    {
        return TRUE;
    }
    return FALSE;
}//IsSpecifiedID

BOOL
IsSpecifiedAccessedBy(
    IN LPTSTR pszAccessedby, 
    IN LPWSTR pszwAccessedby
    )
/*++

Routine Description:

Tests whether the user specified accessed open file username is equivalent to
the api returned username.

Arguments:

    [in]    pszAccessedby   - Null terminated string specifying the
                              accessedby username
    [in]    pszwAccessedby  - Null terminated string specifying the api
                              returned username.

Returned Value:

TRUE  - if pszAccessedby is * or equal to pszwAccessedby
FALSE - Otherwise
--*/
{
   // Check if WILD card is given OR non - existance of username  OR given
   // username and  username returned by api is similar. In any of the case
   // return TRUE.

    if(( 0 == StringCompare(pszAccessedby, WILD_CARD,FALSE,0)) ||
       ( 0 == StringLength(pszAccessedby,0))||
       ( 0 == StringCompare(pszAccessedby,pszwAccessedby,TRUE,0)))
    {
        return TRUE;
    }
    return FALSE;
}//IsSpecifiedAccessedBy

BOOL
IsSpecifiedOpenmode(
    IN LPTSTR pszOpenmode, 
    IN DWORD  dwOpenmode
    )
/*++

Routine Description:

Tests whether the user specified open mode is equivalent to the api returned
openmode

Arguments:

   [in] pszOpenmode - Null terminated string specifying the openmode
   [in] dwOpenmode  - The api returned open mode.

Returned Value:

TRUE  - if pszOpenmode is * or equal to dwOpenmode
FALSE - otherwise
--*/
{

    // Check for WILD card if given OR if no open mode given . In both case
    // return TRUE.
    if( 0 == (StringCompare(pszOpenmode, WILD_CARD,FALSE,0)) ||
       ( 0 == StringLength(pszOpenmode,0)))
    {
        return TRUE;
    }
    
    // Check if READ mode is given as String .
    if( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                     NORM_IGNORECASE,
                     pszOpenmode,
                     -1,
                     READ_MODE,
                     -1))
    {
        // check  that only READ mode only with dwOpenmode variable which is
        // returned by api.
        if((PERM_FILE_READ == (dwOpenmode & PERM_FILE_READ)) &&
                       (PERM_FILE_WRITE != (dwOpenmode & PERM_FILE_WRITE)))
        {
            return TRUE;
        }
    }
    
    // Check if write mode is given.
    else if( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,
                         pszOpenmode,-1,WRITE_MODE,-1))
    {
        // check  that only WRITE mode only with dwOpenmode variable which is
        // returned by api.

        if((PERM_FILE_WRITE == (dwOpenmode & PERM_FILE_WRITE)) &&
            (PERM_FILE_READ != (dwOpenmode & PERM_FILE_READ)))
        {
            return TRUE;
        }
    }
    else if( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pszOpenmode,-1,READ_WRITE_MODE,-1))
    {
        if((PERM_FILE_READ == (dwOpenmode & PERM_FILE_READ)) &&
                       (PERM_FILE_WRITE == (dwOpenmode & PERM_FILE_WRITE)))
        {
            return TRUE;
        }
    }
    else if( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pszOpenmode,-1,WRITE_READ_MODE,-1))
    {
        if((PERM_FILE_WRITE == (dwOpenmode & PERM_FILE_WRITE)) &&
            (PERM_FILE_READ == (dwOpenmode & PERM_FILE_READ)))
        {
            return TRUE;
        }
    }

    // Given string does not matches with predefined Strings..
    // return FALSE.
    return FALSE;
}

BOOL
IsSpecifiedOpenfile(
    IN LPTSTR pszOpenfile, 
    IN LPWSTR pszwOpenfile
    )
/*++

Routine Description:

Tests whether the user specified open file is equalant to the api returned
open file.

Arguments:

    [in] pszOpenfile    - Null terminated string specifying the open
                          file
    [in] pszwOpenfile   - Null terminated string specifying the api
                          returned open file.

Returned Value:

TRUE    - if pszOpenfile is * or equal to pszwOpenfile
FALSE   - otherwise
--*/
{
    // Check for WILD card if given OR no open file specified OR
    // open file given by user matches with open file returned by api.
    // In all cases return TRUE.
    if(( 0 == StringCompare(pszOpenfile, WILD_CARD,FALSE,0))||
       ( 0 == StringLength(pszOpenfile,0))||
       ( 0 == StringCompare(pszwOpenfile,pszOpenfile,TRUE,0)))
    {
        return TRUE;
    }
    return FALSE;
}//IsSpecifiedOpenfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\handle.cpp ===
/******************************************************************************

  Copyright (C) Microsoft Corporation

  Module Name:
      Handle.CPP

  Abstract:
       This module deals with Query functionality of OpenFiles.exe
       NT command line utility. This module will specifically query open files
       for local system. The code written in this file is  mostly taken from
       sources of OH.exe utlity.

  Author:

       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2001

 Revision History:

       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2001 : Created It.


*****************************************************************************/
#include "pch.h"
#include "OpenFiles.h"

// maximum possible drives are A,B....Y,Z
#define MAX_POSSIBLE_DRIVES 26 
#define RTL_NEW( p ) RtlAllocateHeap( RtlProcessHeap(), \
                     HEAP_ZERO_MEMORY, sizeof( *p ) )

#define MAX_TYPE_NAMES 128
struct DriveTypeInfo
{
    TCHAR szDrive[4];
    UINT  uiDriveType;
    BOOL  bDrivePresent;
};

BOOLEAN fAnonymousToo;
HANDLE ProcessId;
WCHAR szTypeName[ MAX_TYPE_NAMES ];
WCHAR SearchName[ MIN_MEMORY_REQUIRED * 2 ];
HKEY hKey;
CONSOLE_SCREEN_BUFFER_INFO screenBufferInfo;
HANDLE hStdHandle;

typedef struct _PROCESS_INFO
{
    LIST_ENTRY Entry;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo[ 1 ];
} PROCESS_INFO, *PPROCESS_INFO;

LIST_ENTRY ProcessListHead;

PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation;
PSYSTEM_HANDLE_INFORMATION_EX HandleInformation;
PSYSTEM_PROCESS_INFORMATION ProcessInformation;

typedef struct _TYPE_COUNT
{
    UNICODE_STRING  TypeName ;
    ULONG           HandleCount ;
} TYPE_COUNT, * PTYPE_COUNT ;


TYPE_COUNT TypeCounts[ MAX_TYPE_NAMES + 1 ] ;

UNICODE_STRING UnknownTypeIndex;

// Local function decleration
BOOL
RtlQuerySystemDebugInformation( 
    VOID
    );

BOOLEAN
LoadSystemObjects(VOID);

BOOLEAN
LoadSystemHandles(VOID);

BOOLEAN
LoadSystemProcesses(VOID);

PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    );

VOID
DumpHandles( 
    IN DWORD dwFormat,
    IN BOOL bShowNoHeader,
    IN BOOL bVerbose
    );

BOOL 
GetCompleteFileName(
    IN  LPCTSTR pszSourceFile,
    OUT LPTSTR pszFinalPath,
    IN  struct DriveTypeInfo *pdrvInfo,
    IN  DWORD dwTotalDrives,
    IN  LPCTSTR pszCurrentDirectory,
    IN  LPCTSTR pszSystemDirectory,
    OUT PBOOL pAppendToCache
    );

VOID FormatFileName(
    IN OUT LPTSTR pFileName,
    IN     DWORD dwFormat,
    IN     LONG dwColWidth
    );
BOOLEAN
AnsiToUnicode(
    IN  LPCSTR Source,
    OUT PWSTR Destination,
    IN  ULONG NumberOfChars
    )

/*++
Routine Description:
   This function will change an ansi string to UNICODE string

Arguments:
    [in]    Source          : Source string
    [out]   Destination     : Destination string
    [in]    NumberOfChars   : No of character in source string
Return Value:
   BOOL       TRUE : Successfully conversion
              FALSE: Unsuccessful
--*/
{
    if ( 0 == NumberOfChars)
    {
        NumberOfChars = strlen( Source );
    }
    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             Source,
                             NumberOfChars,
                             Destination,
                             NumberOfChars
                           ) != (LONG)NumberOfChars)
    {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
        return FALSE;
    }
    else
    {
        Destination[ NumberOfChars ] = UNICODE_NULL;
        return TRUE;
    }
}

DWORD
GetSystemRegistryFlags( 
    VOID 
    )
/*++
Routine Description:
  Functin gets system registry key.

Arguments:
   none

Return Value:
  DWORD  : Registry key value
--*/
{
    DWORD cbKey;
    DWORD GFlags;
    DWORD type;

    if ( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                      0,
                      KEY_READ | KEY_WRITE,
                      &hKey
                    ))
    {
        return 0;
    }

    cbKey = sizeof( GFlags );
    if ( ERROR_SUCCESS != RegQueryValueEx( hKey,
                         _T("GlobalFlag"),
                         0,
                         &type,
                         (LPBYTE)&GFlags,
                         &cbKey
                       ) || REG_DWORD != type)
    {
        RegCloseKey( hKey );
        return 0;
    }
    return GFlags;
}

BOOLEAN
SetSystemRegistryFlags(
    IN DWORD GFlags
    )
/*++
Routine Description:
   Sets system registry Global Flag with given value.

Arguments:
     [in]     GFlags :  Key value

Return Value:
    BOOLEAN   TRUE: success
              FALSE: FAIL
--*/
{
    if ( ERROR_SUCCESS != RegSetValueEx( hKey,
                       _T("GlobalFlag"),
                       0,
                       REG_DWORD,
                       (LPBYTE)&GFlags,
                       sizeof( GFlags )
                     ))
    {
        RegCloseKey( hKey );
        return FALSE;
    }
    return TRUE;
}


BOOL 
DoLocalOpenFiles(
    IN DWORD dwFormat,
    IN BOOL bShowNoHeader,
    IN BOOL bVerbose,
    IN LPCTSTR pszLocalValue
    )
/*++
Routine Description:
   This function will show all locally opened open files.
Arguments:
   [in]  dwFormat      : Format value for output e.g LIST, CSV or TABLE
   [in]  bShowNoHeader : Whether to show header or not.
   [in]  bVerbose      : Verbose ouput or not.
   [in]  pszLocalValue : To disable object type list;
Return Value:
   BOOL
--*/
{
    DWORD dwRegistryFlags = 0;
    dwRegistryFlags = GetSystemRegistryFlags();

    // disabling the object typelist
    if( 0  == StringCompare(pszLocalValue,GetResString(IDS_LOCAL_OFF),TRUE,0)) 
    {
        dwRegistryFlags &= ~FLG_MAINTAIN_OBJECT_TYPELIST;
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
            ShowMessage(stdout,GetResString(IDS_LOCAL_FLG_ALREADY_RESET));
        }
        else
        {
            SetSystemRegistryFlags(dwRegistryFlags);
            ShowMessage(stdout, GetResString(IDS_LOCAL_FLG_RESET));
        }
        RegCloseKey( hKey );
        return TRUE;
    }
    else if( 0 == StringCompare(pszLocalValue,GetResString(IDS_LOCAL_ON),
                                               TRUE,0))
    {
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
            // Enabling the OS to maintain the objects list flag
            // The user help text calls this global flag 'maintain objects list'
            // and enables it with "/local" switch.
            SetSystemRegistryFlags( dwRegistryFlags  |
                                    FLG_MAINTAIN_OBJECT_TYPELIST );
            ShowMessage(stdout,GetResString(IDS_LOCAL_FLG_SET));
        }
        else
        {
            ShowMessage(stdout, GetResString(IDS_LOCAL_FLG_ALREADY_SET));
        }
        RegCloseKey( hKey );
        return TRUE;
    }
    // Language independent string comparision is required.
    else if( CSTR_EQUAL == CompareString( MAKELCID( MAKELANGID(LANG_ENGLISH,
                                                    SUBLANG_ENGLISH_US),
                                                    SORT_DEFAULT),  
                                         NORM_IGNORECASE,
                                         pszLocalValue,
                                         StringLength(pszLocalValue,0),
                                         L"SHOW_STATUS", 
                                         StringLength(L"SHOW_STATUS",0) 
                                        ))
    {
        dwRegistryFlags &= ~FLG_MAINTAIN_OBJECT_TYPELIST;
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
            ShowMessage(stdout,GetResString(IDS_LOCAL_FLG_ALREADY_RESET));
        }
        else
        {
            ShowMessage(stdout,GetResString(IDS_LOCAL_FLG_ALREADY_SET));
        }
        RegCloseKey( hKey );
        return TRUE;

    }
    // just check for FLG_MAINTAIN_OBJECT_TYPELIST
    else 
    {
        if (!(NtCurrentPeb()->NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST))
        {
            RegCloseKey( hKey );
            ShowMessage(stdout,GetResString(IDS_LOCAL_NEEDS_TO_SET1));
            ShowMessage(stdout,GetResString(IDS_LOCAL_NEEDS_TO_SET2));
            ShowMessage(stdout,GetResString(IDS_LOCAL_NEEDS_TO_SET3));
            return TRUE;
        }
    }
    // Not required Reg. key so close it
    RegCloseKey( hKey );
    hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
    if(hStdHandle!=NULL)
    {
        GetConsoleScreenBufferInfo(hStdHandle,&screenBufferInfo);
    }

    ProcessId = NULL;
    fAnonymousToo = FALSE;

    StringCopy(szTypeName ,L"File",SIZE_OF_ARRAY(szTypeName));
    if( FALSE == RtlQuerySystemDebugInformation())
    {
        return FALSE;
    }

    DumpHandles(dwFormat,bShowNoHeader,bVerbose);
    return TRUE;
}

BOOL
RtlQuerySystemDebugInformation( 
    VOID
    )
/*++
Routine Description:
    Query system for System object, System handles and system process

Arguments:
   none

  result.

Return Value:
    BOOL
--*/
{
    if (!LoadSystemObjects( ))
    {
        return FALSE;
    }

    if (!LoadSystemHandles( ))
    {
        return FALSE;
    }

    if (!LoadSystemProcesses())
    {
        return FALSE;
    }
    return TRUE;
}

PVOID
BufferAlloc(
    IN OUT SIZE_T *Length
    )
/*++
Routine Description:
     This routine will reserves or commits a region of pages in the virtual .
   address space of given size.
Arguments:
      [in] [out] Lenght : Size of memory required
Return Value:
   PVOID, Pointer to allocated buffer.
--*/
{
    PVOID Buffer;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    Buffer = VirtualAlloc( NULL,
                           *Length,
                           MEM_COMMIT,
                           PAGE_READWRITE
                         );

    if( NULL == Buffer)
    {
        return NULL;
    }

    if ( NULL != Buffer&& VirtualQuery( Buffer, &MemoryInformation, 
                                        sizeof( MemoryInformation ) ) )
    {
        *Length = MemoryInformation.RegionSize;
    }
    return Buffer;
}

VOID
BufferFree(
    IN PVOID Buffer
    )
/*++
Routine Description:
    This routine will free buffer.
Arguments:
    [in] Buffer   : Buffer which is to be freed.

Return Value:
    none

--*/
{
    VirtualFree (Buffer,0, MEM_RELEASE) ;
    return;
}

BOOLEAN
LoadSystemObjects(
    )
/*++
Routine Description:
   Loads the system objects

Arguments:
   void

Return Value:
    TRUE:  If function returns successful.
--*/
{
    NTSTATUS Status;
    SYSTEM_OBJECTTYPE_INFORMATION ObjectInfoBuffer;
    SIZE_T RequiredLength, NewLength=0;
    ULONG i;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;

    BOOL bAlwaysTrue = TRUE;

    ObjectInformation = &ObjectInfoBuffer;
    RequiredLength = sizeof( *ObjectInformation );
    while (bAlwaysTrue)
    {
        Status = NtQuerySystemInformation( SystemObjectInformation,
                                           ObjectInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );
        if ( STATUS_INFO_LENGTH_MISMATCH == Status && 
              NewLength > RequiredLength)
        {
            if (ObjectInformation != &ObjectInfoBuffer)
            {
                BufferFree (ObjectInformation);
            }
            RequiredLength = NewLength + 4096;
            ObjectInformation = (PSYSTEM_OBJECTTYPE_INFORMATION)
                                                BufferAlloc (&RequiredLength);
            if ( NULL == ObjectInformation)
            {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status ))
        {
            if (ObjectInformation != &ObjectInfoBuffer)
            {

                BufferFree (ObjectInformation);
            }
            return FALSE;
        }
        else
        {
                break;
        }

    }
    TypeInfo = ObjectInformation;
    while (bAlwaysTrue)
    {
        if (TypeInfo->TypeIndex < MAX_TYPE_NAMES)
        {
            TypeCounts[ TypeInfo->TypeIndex ].TypeName = TypeInfo->TypeName;
        }

        if ( 0 == TypeInfo->NextEntryOffset)
        {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    RtlInitUnicodeString( &UnknownTypeIndex, L"UnknownTypeIdx" );
    for (i=0; i<=MAX_TYPE_NAMES; i++)
    {
        if (0 == TypeCounts[ i ].TypeName.Length)
        {
            TypeCounts[ i ].TypeName = UnknownTypeIndex;
        }
    }

    return TRUE;
}

BOOLEAN
LoadSystemHandles(void)
/*++
Routine Description:
   Loads the system handles

Arguments:
   void

Return Value:
 BOOLEAN

--*/
{
    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION_EX HandleInfoBuffer;
    SIZE_T RequiredLength, NewLength=0;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    BOOL bAlwaysTrue = TRUE;
    HandleInformation = &HandleInfoBuffer;
    RequiredLength = sizeof( *HandleInformation );
    while (bAlwaysTrue)
    {
        Status = NtQuerySystemInformation( SystemExtendedHandleInformation,
                                           HandleInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );

        if ( STATUS_INFO_LENGTH_MISMATCH == Status && 
             NewLength > RequiredLength)
        {
            if (HandleInformation != &HandleInfoBuffer)
            {
                BufferFree (HandleInformation);
            }

            // slop, since we may trigger more handle creations.
            RequiredLength = NewLength + 4096; 
            HandleInformation = (PSYSTEM_HANDLE_INFORMATION_EX)
                                                BufferAlloc( &RequiredLength );
            if ( NULL == HandleInformation)
            {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status ))
        {
            if (HandleInformation != &HandleInfoBuffer)
            {
                BufferFree (HandleInformation);
            }
            return FALSE;
        }
        else
        {
            break;
        }
    }

    TypeInfo = ObjectInformation;
    while (bAlwaysTrue)
    {
        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
         ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (bAlwaysTrue)
        {
            if ( 0 != ObjectInfo->HandleCount)
            {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX pHandleEntry;
                ULONG HandleNumber;

                pHandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles)
                {
                    if (!(pHandleEntry->HandleAttributes & 0x80) &&
                        pHandleEntry->Object == ObjectInfo->Object)
                    {
                        pHandleEntry->Object = ObjectInfo;
                        pHandleEntry->HandleAttributes |= 0x80;
                    }
                    pHandleEntry++;
                }
            }

            if ( 0 == ObjectInfo->NextEntryOffset)
            {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if ( 0 == TypeInfo->NextEntryOffset)
        {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);

    }
    return TRUE;
}

BOOLEAN
LoadSystemProcesses( )
/*++
Routine Description:
     Loads the system process .

Arguments:
    void

Return Value:
   BOOLEAN
--*/
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    ULONG i, TotalOffset;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PPROCESS_INFO ProcessEntry;
    BOOL bAlwaysTrue = TRUE;
    //
    //  Always initialize the list head, so that a failed
    //  NtQuerySystemInformation call won't cause an AV later on.
    //
    InitializeListHead( &ProcessListHead );

    RequiredLength = 64 * 1024;
    ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)
                                                BufferAlloc( &RequiredLength );
    if ( NULL == ProcessInformation)
    {
        return FALSE;
    }

    while (bAlwaysTrue)
    {
        Status = NtQuerySystemInformation( SystemProcessInformation,
                                           ProcessInformation,
                                           (ULONG)RequiredLength,
                                           NULL
                                         );
        if ( STATUS_INFO_LENGTH_MISMATCH == Status)
        {
            if (!VirtualFree( ProcessInformation,
                              0, MEM_RELEASE ))
            {
                return FALSE;
            }

            RequiredLength = RequiredLength * 2;
            ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)
                                                BufferAlloc( &RequiredLength );
            if ( NULL == ProcessInformation)
            {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status ))
        {
            return FALSE;
        }
        else
        {
            break;
        }
    }

    ProcessInfo = ProcessInformation;
    TotalOffset = 0;
    while (bAlwaysTrue)
    {
        ProcessEntry =(PPROCESS_INFO) 
                       RtlAllocateHeap( RtlProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        sizeof( *ProcessEntry ) +
                                       (sizeof( ThreadInfo ) * 
                                           ProcessInfo->NumberOfThreads));
        if ( NULL == ProcessEntry)
        {
            return FALSE;
        }

        InitializeListHead( &ProcessEntry->Entry );
        ProcessEntry->ProcessInfo = ProcessInfo;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        for (i = 0; i < ProcessInfo->NumberOfThreads; i++)
        {
            ProcessEntry->ThreadInfo[ i ] = ThreadInfo++;
        }

        InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

        if (0 == ProcessInfo->NextEntryOffset)
        {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PCHAR)ProcessInformation + TotalOffset);
    }
    return TRUE;
}

PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    )
/*++
Routine Description:
      This routine will get Process information.
Arguments:
    [in] UniqueProcessId = Process ID.

Return Value:
   PSYSTEM_PROCESS_INFORMATION, Structure which hold information about process
--*/
{
    PLIST_ENTRY Next, Head;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PPROCESS_INFO ProcessEntry;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head)
    {
        ProcessEntry = CONTAINING_RECORD( Next,
                                          PROCESS_INFO,
                                          Entry
                                        );

        ProcessInfo = ProcessEntry->ProcessInfo;
        if (ProcessInfo->UniqueProcessId == UniqueProcessId)
        {
            return ProcessInfo;
        }

        Next = Next->Flink;
    }

    ProcessEntry =(PPROCESS_INFO) RtlAllocateHeap( RtlProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    sizeof( *ProcessEntry ) +
                                        sizeof( *ProcessInfo )
                                  );
    if ( NULL == ProcessEntry)
    {
        return NULL;
    }
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessEntry+1);

    ProcessEntry->ProcessInfo = ProcessInfo;
    ProcessInfo->UniqueProcessId = UniqueProcessId;

    InitializeListHead( &ProcessEntry->Entry );
    InsertTailList( &ProcessListHead, &ProcessEntry->Entry );
    return ProcessInfo;
}

VOID
DumpHandles( 
    IN DWORD dwFormat,
    IN BOOL bShowNoHeader,
    IN BOOL bVerbose
    )
/*++
Routine Description:
    This function will show local open files.

Arguments:
   [in]  dwFormat      : Format value for output e.g LIST, CSV or TABLE
   [in]  bShowNoHeader : Whether to show header or not.
   [in]  bVerbose      : Verbose ouput or not.

Return Value:
    void

--*/
{
    HANDLE PreviousUniqueProcessId = NULL;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX pHandleEntry = NULL;
    ULONG HandleNumber = 0;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo = NULL;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo = NULL;
    PUNICODE_STRING ObjectTypeName = NULL;
    WCHAR ObjectName[ MAX_RES_STRING ];
    PVOID Object;
    CHString szFileType;
    PWSTR s;
    ULONG n;
    DWORD dwRow = 0; // no of rows
    
    // Stores avalable logical drives info.
    DWORD dwAvailableLogivalDrives = 0; 
    
    // stores working directory.
    TCHAR szWorkingDirectory[MAX_PATH+1]; 
    
    // Stores the System (Active OS) directory
    TCHAR szSystemDirectory[MAX_PATH+1]; 
    struct DriveTypeInfo drvInfo[MAX_POSSIBLE_DRIVES];
    
    // Stores no. of available drives
    DWORD dwNoOfAvailableDrives = 0; 

    // "A" is First available driveDrive
    TCHAR cDriveLater = 65; 
    
    // "A" is First available driveDriveso mask pattern is 0x0001
    DWORD dwDriveMaskPattern = 1; 
    
    // variable used for _splitpath function...
    TCHAR szDrive[_MAX_DRIVE];
    TCHAR szDir[_MAX_DIR];
    TCHAR szFname[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];

    TCHAR szTemp[MAX_RES_STRING*2];
    TCHAR szCompleteFileName[MAX_PATH];
    DWORD dwHandle = 0;
    BOOL  bAtLeastOne = FALSE;
    DWORD dwIndx = 0; // variable used for indexing

    TCHAR szFileSystemNameBuffer[MAX_PATH+1];
    TCHAR szVolName[MAX_PATH+1];
    DWORD dwVolumeSerialNumber = 0;
    DWORD dwFileSystemFlags = 0;
    DWORD dwMaximumCompenentLength = 0;
    BOOL  bReturn = FALSE;
    BOOL   bAppendToCache = FALSE;
    //Some column required to hide in non verbose mode query
    DWORD  dwMask = bVerbose?SR_TYPE_STRING:SR_HIDECOLUMN|SR_TYPE_STRING;

    TCOLUMNS pMainCols[]=
    {
        {L"\0",COL_L_ID,SR_TYPE_STRING,L"\0",NULL,NULL},
        {L"\0",COL_L_TYPE,SR_HIDECOLUMN,L"\0",NULL,NULL},
        {L"\0",COL_L_ACCESSED_BY,dwMask,L"\0",NULL,NULL},
        {L"\0",COL_L_PID,dwMask,L"\0",NULL,NULL},
        {L"\0",COL_L_PROCESS_NAME,SR_TYPE_STRING,L"\0",NULL,NULL},
        {L"\0",COL_L_OPEN_FILENAME,SR_TYPE_STRING|
                       (SR_NO_TRUNCATION&~(SR_WORDWRAP)),L"\0",NULL,NULL}
    };

    LPTSTR  pszAccessedby = new TCHAR[MAX_RES_STRING*2];
    if(pszAccessedby==NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        return;
    }

    TARRAY pColData  = CreateDynamicArray();//array to stores
                                            //result
    if( NULL == pColData)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        SAFEDELETE(pszAccessedby);
        return;
    }

    TARRAY pCacheData  = CreateDynamicArray();//array to stores

    if( NULL == pCacheData)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        SAFERELDYNARRAY(pColData);
        SAFERELDYNARRAY(pCacheData);
        SAFEDELETE(pszAccessedby);
        return;
    }
    // Initialize variables.
    SecureZeroMemory(ObjectName,SIZE_OF_ARRAY(ObjectName));
    SecureZeroMemory(szWorkingDirectory, SIZE_OF_ARRAY(szWorkingDirectory));
    SecureZeroMemory(szSystemDirectory, SIZE_OF_ARRAY(szSystemDirectory));
    SecureZeroMemory(szDrive, SIZE_OF_ARRAY(szDrive));
    SecureZeroMemory(szDir, SIZE_OF_ARRAY(szDir));
    SecureZeroMemory(szFname,SIZE_OF_ARRAY(szFname));
    SecureZeroMemory(szExt, SIZE_OF_ARRAY(szExt));
    SecureZeroMemory(szTemp, SIZE_OF_ARRAY(szTemp));
    SecureZeroMemory(szCompleteFileName, SIZE_OF_ARRAY(szCompleteFileName));
    SecureZeroMemory(szFileSystemNameBuffer, SIZE_OF_ARRAY(szFileSystemNameBuffer));
    SecureZeroMemory(szVolName, SIZE_OF_ARRAY(szVolName));


    StringCopy(pMainCols[LOF_ID].szColumn,GetResString(IDS_STRING_ID),
               SIZE_OF_ARRAY(pMainCols[LOF_ID].szColumn));
    StringCopy(pMainCols[LOF_TYPE].szColumn,GetResString(IDS_FILE_TYPE),
               SIZE_OF_ARRAY(pMainCols[LOF_TYPE].szColumn));
    StringCopy(pMainCols[LOF_ACCESSED_BY].szColumn,
                                        GetResString(IDS_STRING_ACCESSED_BY),
               SIZE_OF_ARRAY(pMainCols[LOF_ACCESSED_BY].szColumn));
    StringCopy(pMainCols[LOF_PID].szColumn,
                                        GetResString(IDS_STRING_PID),
              SIZE_OF_ARRAY(pMainCols[LOF_PID].szColumn));
    StringCopy(pMainCols[LOF_PROCESS_NAME].szColumn,
                                        GetResString(IDS_STRING_PROCESS_NAME),
              SIZE_OF_ARRAY(pMainCols[LOF_PROCESS_NAME].szColumn));
    StringCopy(pMainCols[LOF_OPEN_FILENAME].szColumn,
                                           GetResString(IDS_STRING_OPEN_FILE),
              SIZE_OF_ARRAY(pMainCols[LOF_OPEN_FILENAME].szColumn));

    dwAvailableLogivalDrives = GetLogicalDrives(); // Get logical drives.
    // Store current working direcory.
    if(NULL == _wgetcwd(szWorkingDirectory,MAX_PATH))
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr); // Shows the error string set by API function.
        SAFERELDYNARRAY(pColData);
        SAFERELDYNARRAY(pCacheData);
        SAFEDELETE(pszAccessedby);
        return ;
    }

    // Get System Active (OS) directory
    if( NULL == GetSystemDirectory(szSystemDirectory,MAX_PATH))
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr); // Shows the error string set by API function.
        SAFERELDYNARRAY(pColData);
        SAFERELDYNARRAY(pCacheData);
        SAFEDELETE(pszAccessedby);
        return ;
    }

    // Check each drive and set its info.
    for(dwIndx=0;dwIndx<MAX_POSSIBLE_DRIVES;dwIndx++,cDriveLater++)
    {
        // dwAvailableLogivalDrives contains drive information in bit wise
        // 0000 0000 0000 0000 0000 01101  means A C and D drives are
        // logical drives.
        if(dwAvailableLogivalDrives & dwDriveMaskPattern)
        {
            // means we catch a drive latter.
            // copy drive latter (line c:\ or a: for example).
            StringCchPrintfW(drvInfo[dwNoOfAvailableDrives].szDrive,
                       SIZE_OF_ARRAY(drvInfo[dwNoOfAvailableDrives].szDrive),
                       _T("%c:"),cDriveLater);
            
            // Check type of the drive .
            drvInfo[dwNoOfAvailableDrives].uiDriveType = 
                          GetDriveType(drvInfo[dwNoOfAvailableDrives].szDrive);
            
            // Check if drive is ready or not.
            StringCchPrintfW(szTemp,(2*MAX_RES_STRING)-1,_T("%s\\"),
                                       drvInfo[dwNoOfAvailableDrives].szDrive);
            bReturn = GetVolumeInformation((LPCWSTR)szTemp,
                                           szVolName,
                                           MAX_PATH,
                                           &dwVolumeSerialNumber,
                                           &dwMaximumCompenentLength,
                                           &dwFileSystemFlags,
                                           szFileSystemNameBuffer,
                                           MAX_PATH);
           drvInfo[dwNoOfAvailableDrives].bDrivePresent = bReturn;
           dwNoOfAvailableDrives++;
        }
        dwDriveMaskPattern = dwDriveMaskPattern << 1; // Left shift 1
    }
    pHandleEntry = &HandleInformation->Handles[ 0 ];
    HandleNumber = 0;
    PreviousUniqueProcessId = INVALID_HANDLE_VALUE;
    for (HandleNumber = 0;HandleNumber < HandleInformation->NumberOfHandles;
         HandleNumber++, pHandleEntry++)
    {
            if (PreviousUniqueProcessId != (HANDLE)pHandleEntry->UniqueProcessId)
            {
                PreviousUniqueProcessId = (HANDLE)pHandleEntry->UniqueProcessId;
                ProcessInfo = FindProcessInfoForCid( PreviousUniqueProcessId );

            }

            ObjectName[ 0 ] = UNICODE_NULL;
            if (pHandleEntry->HandleAttributes & 0x80)
            {
                ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)pHandleEntry->Object;
                Object = ObjectInfo->Object;
                if ( 0 != ObjectInfo->NameInfo.Name.Length &&
                    UNICODE_NULL == *(ObjectInfo->NameInfo.Name.Buffer))
                {
                    ObjectInfo->NameInfo.Name.Length = 0;

                }
                n = ObjectInfo->NameInfo.Name.Length / sizeof( WCHAR );
                if( NULL != ObjectInfo->NameInfo.Name.Buffer)
                {
                    StringCopy( ObjectName,ObjectInfo->NameInfo.Name.Buffer,
                                 SIZE_OF_ARRAY(ObjectName));
                    ObjectName[ n ] = UNICODE_NULL;
                }
                else
                {
                      ObjectName[ 0 ] = UNICODE_NULL;
                }
            }
            else
            {
                ObjectInfo = NULL;
                Object = pHandleEntry->Object;
            }

            if ( 0 != ProcessId && ProcessInfo->UniqueProcessId != ProcessId)
            {
                continue;
            }

            ObjectTypeName = 
                &TypeCounts[ pHandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                   pHandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].TypeName;

            TypeCounts[ pHandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
              pHandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].HandleCount++;

            if (szTypeName[0])
            {
                if (StringCompare( szTypeName, ObjectTypeName->Buffer,TRUE,0 ))
                {
                    continue;
                }
            }

            if (!*ObjectName)
            {
                if (!fAnonymousToo)
                {
                    continue;
                }
            }
            else if (SearchName[0])
            {
                if (!FindString( ObjectName, SearchName,0 ))
                {
                    s = ObjectName;
                    n = StringLength( SearchName,0 );
                    while (*s)
                    {
                        if (!StringCompare( s, SearchName, TRUE,n ))
                         {
                            break;
                        }
                        s += 1;
                    }
                    if (!*s)
                    {
                        continue;
                    }
                }
            }
            
            //pHandleEntry->HandleValue;
            dwHandle = PtrToUlong( ProcessInfo->UniqueProcessId ); 

            // Blocking the display of files that were opened by system 
            // accounts ( NT AUTHORITY )
            if ( FALSE == GetProcessOwner( pszAccessedby, dwHandle ))
                continue;// As user is "SYSTEM" related....
            
            // Get File name ..
            StringCchPrintfW(szTemp,(2*MAX_RES_STRING)-1,
                      _T("%ws"),*ObjectName ? ObjectName : L"\0");
            
            // Search this file in cache, if it is there skip this file
            // for further processing. As this is already processed and
            // was found invalid.
            if( TRUE == IsValidArray(pCacheData))
            {
                if ( -1 != DynArrayFindString( pCacheData, szTemp, TRUE, 0 ))
                    continue;
            }
            StringCopy(szCompleteFileName, L"\0",SIZE_OF_ARRAY(szCompleteFileName));
            if(  FALSE == GetCompleteFileName(szTemp,szCompleteFileName,
                   &drvInfo[0],dwNoOfAvailableDrives,szWorkingDirectory,
                   szSystemDirectory,&bAppendToCache))
            {
                // szTemp contains a directory which is not physicaly exist
                // so add this to cache to skip it in future for checking
                // of its existance
                if( TRUE == bAppendToCache) 
                {

                  if( TRUE == IsValidArray(pCacheData))
                  {
                      DynArrayAppendString(pCacheData, (LPCWSTR)szTemp,0);
                  }
                }
                continue;
            }
            // Now fill the result to dynamic array "pColData"
            DynArrayAppendRow( pColData, 0 );
            // File id
            StringCchPrintfW(szTemp,(2*MAX_RES_STRING)-1,
                       _T("%ld"),pHandleEntry->HandleValue);
            DynArrayAppendString2(pColData ,dwRow,szTemp,0);
            // Type
            DynArrayAppendString2(pColData ,dwRow,(LPCWSTR)szFileType,0);
            // Accessed by
            DynArrayAppendString2(pColData,dwRow,pszAccessedby,0);

            // PID
            StringCchPrintfW(szTemp,(2*MAX_RES_STRING)-1,
                       _T("%ld"),dwHandle);
            DynArrayAppendString2(pColData,dwRow,szTemp,0);

            // Process Name
            DynArrayAppendString2(pColData ,dwRow,
                                              ProcessInfo->ImageName.Buffer,0);

            if( FALSE == bVerbose) // Formate file name only in non verbose mode.
            {
                FormatFileName(szCompleteFileName,dwFormat,COL_L_OPEN_FILENAME);
            }
            // Open File name
            DynArrayAppendString2(pColData ,dwRow,szCompleteFileName,0);
            dwRow++;
            bAtLeastOne = TRUE;

        }

    if( TRUE == bVerbose)
    {
        pMainCols[LOF_OPEN_FILENAME].dwWidth = 80;
    }
    if(bAtLeastOne==FALSE)// if not a single open file found, show info
                          // as -  INFO: No open file found.
    {
        ShowMessage(stdout,GetResString(IDS_NO_OPENFILES));
    }
    else
    {
        ShowMessage(stdout,GetResString(IDS_LOCAL_OPEN_FILES));
        ShowMessage(stdout,GetResString(IDS_LOCAL_OPEN_FILES_SP1));
        if( SR_FORMAT_CSV != dwFormat)
        {
            ShowMessage(stdout,BLANK_LINE);
        }
        
        // Display output result.
        if(bShowNoHeader==TRUE)
        {
              dwFormat |=SR_NOHEADER;
        }
        ShowResults(NO_OF_COL_LOCAL_OPENFILE,pMainCols,dwFormat,pColData);
    }
    SAFERELDYNARRAY(pColData);
    SAFERELDYNARRAY(pCacheData);
    SAFEDELETE(pszAccessedby);
    return;
}

BOOL 
GetCompleteFileName(
    IN  LPCTSTR pszSourceFile,
    OUT LPTSTR pszFinalPath,
    IN  struct DriveTypeInfo *pdrvInfo,
    IN  DWORD dwTotalDrives,
    IN  LPCTSTR pszCurrentDirectory,
    IN  LPCTSTR pszSystemDirectory,
    OUT PBOOL pAppendToCache
    )
/*++
Routine Description:
     This function will accept a path (with out drive letter), and returns
     the path with drive letter.

   Following is the procedure for getting full path name ..
   1. First check if the first character in pszSourceFile is '\' .
   2. If first character of pszSourceFile is '\' then check for the second
      character...
   3. If second character is ';' then than take 3 rd character as drive 
      letter and
      find rest of string for 3rd "\" (Or 4th from first). String after 3rd 
      character
      will be final path. for example let the source string is
      \;Z:00000000000774c8\sanny\c$\nt\base\fs\OpenFiles\Changed\obj\i386
      then final path is z:\nt\base\fs\OpenFiles\Changed\obj\i386
   4. If second character is not ';' then try to find pszSourceFile for its 
      existance
      by first prefixing the available drive letter one by one. The first 
      occurence
      of file existance will be the final valid path. Appending of file 
      letter has a rule. First append FIXED DRIVES then try to append 
      MOVABLE DRIVES.
  
      Here there is a known limitation. Let there exists two files with same 
      name like...
      c:\document\abc.doc and d:\documet\abc.doc and actual file opened is 
      d:\documet\abc.doc
      then this will show final path as c:\documet\abc.doc as it starts 
      with A:....Z:(also preference
      will be given to FIXED TYPE DRIVE).
   5. If first character is not '\' then prefix Current working directory 
      path to file name. And check it for its existance. IF this not exits 
      then search this path by prefixing logical drive letter to it.
Arguments:
   [in]  pszSourceFile       = Source path
   [out] pszFinalPath        = Final path
   [in]  DriveTypeInfo       = Logical drive information structure pointer
   [in]  pszCurrentDirectory = Current woking directory path
   [in]  pszSystemDirectory  = Current Active (OS) System directory
   [out] pAppendToCache      = whether to pszSourceFile to cache

Return Value:
   BOOL:  TRUE:    if fuction successfuly returns pszFinalPath
          FALSE:   otherwise
--*/
{
    // Temp string
    CHString szTemp(pszSourceFile); 
    DWORD dwTemp = 0;// Temp variable
    LONG lTemp = 0;
    LONG lCount = 0;
    TCHAR  szTempStr[MAX_PATH+1];
    HANDLE hHandle = NULL;
    DWORD  dwFoundCount = 0;

    // data buffer for FindFirstFile function.
    WIN32_FIND_DATA win32FindData; 

    // Hold the head position.
    DriveTypeInfo *pHeadPosition = pdrvInfo; 

    // Make it false by default.
    *pAppendToCache = FALSE; 


    TCHAR szSystemDrive[5];
    SecureZeroMemory( szSystemDrive, SIZE_OF_ARRAY(szSystemDrive));
    if(NULL == pszSourceFile )
    {
       return FALSE;
    } 
     
    SecureZeroMemory(szTempStr, SIZE_OF_ARRAY(szTempStr));

    // First two character will be system drive (a:).
    StringCopy(szSystemDrive,pszSystemDirectory,3); 
    if(  _T('\\') == pszSourceFile[0])
    {
        // Check if second character if it is ';'
        if( _T(';') == pszSourceFile[1])
        {
           // make 3rd character as drive letter
           pszFinalPath[0] = pszSourceFile[2]; 
           
           // make 2nd character ':'
           pszFinalPath[1]  = ':'; 
           
           // make 3nd character NULL
           pszFinalPath[2]  = '\0'; 
           dwFoundCount = 0;
           
           // search for 3rd '\'
           for (lTemp = 0;lTemp <5;lTemp++) 
           {
               lCount = szTemp.Find(_T("\\"));
               if( -1 != lCount)
               {
                   dwFoundCount++;
                   // this should always (if any)after 4rd character from start
                   if( 4 == dwFoundCount)
                   {
                       StringConcat( pszFinalPath,
                                          (LPCWSTR)szTemp.Mid(lCount),
                                          MAX_PATH-3);
                       return TRUE;
                   }
                   szTemp = szTemp.Mid(lCount+1);
                   continue;
               }
               *pAppendToCache = TRUE;
               return FALSE;
           }
        }
        else
        {

            // check first of all for system drive
            szTemp = szSystemDrive;
            szTemp+=pszSourceFile;
            
            // now check for its existance....
            hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
            if( INVALID_HANDLE_VALUE != hHandle)
            {
                // closed opened find handle
                FindClose(hHandle); 
                StringCopy(pszFinalPath,(LPCWSTR)szTemp,MAX_PATH-3);
                return TRUE;
            }
            
            // check file for each  FIXED drive
            for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
            {
                if(0 == StringCompare(szSystemDrive,pdrvInfo->szDrive,TRUE,0))
                {
                    // as system drive is already checked
                    continue;
                }
                if( DRIVE_FIXED == pdrvInfo->uiDriveType)
                {
                    szTemp = pdrvInfo->szDrive;
                    szTemp+=pszSourceFile;

                    // now check for its existance....
                    hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);

                    if( INVALID_HANDLE_VALUE == hHandle)
                    {
                       continue;
                    }
                    else
                    {
                        // closed opened find handle
                        FindClose(hHandle);
                        StringCopy(pszFinalPath,(LPCWSTR)szTemp,MAX_PATH-3);
                        return TRUE;
                    }
                } // end if
            } // End for loop

            // retore original position.
            pdrvInfo = pHeadPosition ; 
            
            // check file for other drive which is present...
            for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
            {
                // Check for NON_FIXED drive only if it is physicaly present
                if((DRIVE_FIXED != pdrvInfo->uiDriveType) && 
                   (TRUE == pdrvInfo->bDrivePresent))
                {
                   szTemp = pdrvInfo->szDrive;
                   szTemp+=pszSourceFile;
                   
                   // now check for its existance....
                   hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
                   if( INVALID_HANDLE_VALUE == hHandle)
                   {
                       continue;
                   }
                   else
                   {
                       // closed opened find handle
                       FindClose(hHandle); 
                       StringCopy(pszFinalPath,(LPCWSTR)szTemp,MAX_PATH-3);
                       return TRUE;
                   }

                } // end if
            } // End for loop

            // Now try if file is opend on remote system without
            // having drive map. in this we are assuming that file name
            // is containing atleast 3 '\' characters.
            szTemp = pszSourceFile;

            // make 3rd character '\'
            pszFinalPath[0] = '\\'; 

            // make 2nd character '\o'
            pszFinalPath[1]  = '\0'; 
            dwFoundCount = 0;
            for (lTemp = 0;lTemp <4;lTemp++) // search for 3rd '\'
            {
                lCount = szTemp.Find(_T("\\"));
                if( -1 != lCount)
                {
                    szTemp = szTemp.Mid(lCount+1);
                    dwFoundCount++;
                }
                else
                {
                    break;
                }
                if ( 3 == dwFoundCount)
                {
                    StringConcat(pszFinalPath,pszSourceFile,MAX_PATH-3);
                    
                    // Now try to check its physical existance
                    hHandle = FindFirstFile(pszFinalPath,&win32FindData);

                    if( INVALID_HANDLE_VALUE == hHandle)
                    {
                        // Now try to append \* to it...(this will check if
                        // if pszFinalPath is a directory or not)
                        StringCopy(szTempStr,pszFinalPath,MAX_PATH);
                        StringConcat(szTempStr,L"\\*",MAX_PATH);
                        hHandle = FindFirstFile(szTempStr,&win32FindData);

                        if( INVALID_HANDLE_VALUE == hHandle)
                        {
                            // now its sure this is not a valid directory or 
                            // file so append it to chache.
                            *pAppendToCache = TRUE;
                            return FALSE;
                        }
                        FindClose(hHandle);
                        return TRUE;
                    }
                    FindClose(hHandle);
                    return TRUE;
                }
            } // End for
        }// End else
    } // end if
    else // means string not started with '\'
    {

        StringCopy(pszFinalPath,pszCurrentDirectory,MAX_PATH-3);
        StringConcat(pszFinalPath,L"\\",MAX_PATH-3);
        StringConcat(pszFinalPath,pszSourceFile,MAX_PATH-3);
        hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
        if( INVALID_HANDLE_VALUE != hHandle)
        {
            FindClose(hHandle); // closed opened find handle
            return TRUE;

        }
        // check first of all for system drive
        szTemp = szSystemDrive;
        szTemp+=pszSourceFile;
        // now check for its existance....
        hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
        if( INVALID_HANDLE_VALUE != hHandle)
        {
            FindClose(hHandle); // closed opened find handle
            StringCopy(pszFinalPath,(LPCWSTR)szTemp,MAX_PATH-3);
            return TRUE;
        }
        
        // restores the head position for the pointer.
        pdrvInfo = pHeadPosition ;
        
        // check file for each  FIXED drive
        for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
        {
            if( 0 == StringCompare(szSystemDrive,pdrvInfo->szDrive,TRUE,0))
            {
                // as system drive is already checked
                continue; 
            }

            if( DRIVE_FIXED == pdrvInfo->uiDriveType)
            {
                szTemp = pdrvInfo->szDrive;
                szTemp += L"\\"; 
                szTemp+=pszSourceFile;
                
                // now check for its existance....
                hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);

                if( INVALID_HANDLE_VALUE == hHandle)
                {
                    continue;
                }
                else
                {
                    // closed opened find handle
                    FindClose(hHandle); 
                    StringCopy(pszFinalPath,(LPCWSTR)szTemp,MAX_PATH-3);
                    return TRUE;
                }
            } // end if
        } // End for loop
        pdrvInfo = pHeadPosition ; // retore original position.

        // check file for other drive (Like Floppy or CD-ROM etc. )
        // which is present...
        for (dwTemp=0;dwTemp<dwTotalDrives;dwTemp++,pdrvInfo++)
        {
            if(( DRIVE_FIXED != pdrvInfo->uiDriveType) && 
               ( TRUE == pdrvInfo->bDrivePresent))
            {
                szTemp = pdrvInfo->szDrive;
                szTemp += L"\\"; 
                szTemp+=pszSourceFile;
                
                // now check for its existance....
                hHandle = FindFirstFile((LPCWSTR)szTemp,&win32FindData);
                if( INVALID_HANDLE_VALUE == hHandle)
                {
                    continue;
                }
                else
                {
                    // closed opened find handle
                    FindClose(hHandle); 
                    StringCopy(pszFinalPath,(LPCWSTR)szTemp,MAX_PATH-3);
                    return TRUE;
                }
            } // end if
        } // End for loop
    }
    *pAppendToCache = TRUE;
    return FALSE;
}

VOID FormatFileName(
    IN OUT LPTSTR pFileName,
    IN     DWORD dwFormat,
    IN     LONG dwColWidth
    )
/*++
Routine Description:
     This routine will format the pFileName according to column width

Arguments:
  [in/out]  pFileName  :  path to be formatted
  [in]      dwFormat   :  Format given
  [in]      dwColWidth :  Column width
Return Value:
    none
--*/
{
    CHString szCHString(pFileName);
    if((szCHString.GetLength()>(dwColWidth))&&
        ( SR_FORMAT_TABLE == dwFormat))
    {
        // If file path is too big to fit in column width
        // then it is cut like..
        // c:\..\rest_of_the_path.
        CHString szTemp = szCHString.Right(dwColWidth-6);;
        DWORD dwTemp = szTemp.GetLength();
        szTemp = szTemp.Mid(szTemp.Find(SINGLE_SLASH),
                           dwTemp);
        szCHString.Format(L"%s%s%s",szCHString.Mid(0,3),
                                    DOT_DOT,
                                    szTemp);
    }
    StringCopy(pFileName,(LPCWSTR)szCHString,MIN_MEMORY_REQUIRED);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\pch.h ===
// ***************************************************************************
//
//  Copyright (c)  Microsoft Corporation
//
//  Module Name:
//
//        pch.h
//
//  Abstract:
//
//         pre-compiled header declaration
//        files that has to be pre-compiled into .pch file
//
//
//  Author:
//
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//
//  Revision History:
//
//       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
// ****************************************************************************

#ifndef __PCH_H
#define __PCH_H



#pragma once        // include header file only once

extern "C"
{
    #include <assert.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
    #include <memory.h>
    #include <ntos.h>
    #include <ntioapi.h>
    #include <nturtl.h>
    #include <TCHAR.h>
    #include <windows.h>
    #include <dbghelp.h>
    #include <Winbase.h>
    #include <lm.h>
    #include <Lmserver.h>
    #include <winerror.h>
}

//
// public C header files
//
#include <tchar.h>
#include <crtdbg.h>
#include <comdef.h>
#include <winsock2.h>
#include <svcguid.h>
#include <strsafe.h>
//
// private Common header files
//
// Use command line parser ver. 2
#define CMDLINE_VERSION 200
#include "cmdline.h"

#endif    // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\openfiles.cpp ===
/******************************************************************************
Copyright (c)  Microsoft Corporation

Module Name:

    OpenFiles.cpp

Abstract:

    Enables an administrator to disconnect/query open files ina given system.

  Author:

      Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000

 Revision History:

      Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.

******************************************************************************/
#include "pch.h"
#include "OpenFiles.h"
#include "Disconnect.h"
#include "Query.h"
#include <limits.h>
#include "resource.h"

#define EXIT_ENV_SUCCESS 1
#define EXIT_ENV_FAILURE 0


#define SUBKEY _T("HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0")
#define ERROR_RETREIVE_REGISTRY 4
#define TOKEN_BACKSLASH4  _T("\\\\")
#define IDENTIFIER_VALUE  _T("Identifier")

#define X86_MACHINE _T("x86")

#define SYSTEM_64_BIT 2
#define SYSTEM_32_BIT 3

BOOL g_bIs32BitEnv = TRUE ;

// Fuction protorypes. These functions will be used only in current file.
DWORD
GetCPUInfo(
    IN LPTSTR szComputerName    
    );
DWORD 
CheckSystemType(
    IN LPTSTR szServer       
    );
DWORD 
CheckSystemType64(
    IN LPTSTR szServer      
    );
BOOL 
ProcessQuery(
    IN DWORD argc,      
    IN LPCTSTR argv[]   
    )throw (CHeap_Exception);

BOOL 
ProcessDisconnect(
    IN DWORD argc,      
    IN LPCTSTR argv[]   
    ) throw (CHeap_Exception);

BOOL 
ProcessLocal(
    IN DWORD argc,     
    IN LPCTSTR  argv[] 
    );

BOOL
ProcessOptions( 
    IN  DWORD argc,             
    IN  LPCTSTR argv[],         
    OUT PBOOL pbDisconnect,     
    OUT PBOOL pbQuery,          
    OUT PBOOL pbUsage,          
    OUT PBOOL pbResetFlag       
    );

BOOL
ProcessOptions( 
    IN  DWORD argc,             
    IN  LPCTSTR argv[],         
    OUT PBOOL pbQuery,          
    OUT LPTSTR* pszServer,       
    OUT LPTSTR* pszUserName,     
    OUT LPTSTR* pszPassword,     
    OUT LPTSTR* pszFormat,       
    OUT PBOOL   pbShowNoHeader,  
    OUT PBOOL   pbVerbose,       
    OUT PBOOL   pbNeedPassword   
    );

BOOL
ProcessOptions( 
    IN  DWORD argc,
    IN  LPCTSTR argv[],
    OUT PBOOL pbDisconnect,
    OUT LPTSTR* pszServer,
    OUT LPTSTR* pszUserName,
    OUT LPTSTR* pszPassword,
    OUT LPTSTR* pszID,
    OUT LPTSTR* pszAccessedby,
    OUT LPTSTR* pszOpenmode,
    OUT LPTSTR* pszOpenFile,
    OUT PBOOL   pbNeedPassword
    );
BOOL
ProcessOptions( 
    IN  DWORD argc,
    IN  LPCTSTR argv[],
    OUT LPTSTR* pszLocalValue
    );

BOOL 
Usage(
    VOID
    );

BOOL 
DisconnectUsage(
    VOID
    );

BOOL 
QueryUsage(
    VOID
    );

BOOL 
LocalUsage(
    VOID
    );

// Function implimentation
DWORD _cdecl
_tmain( 
    IN DWORD argc, 
    IN LPCTSTR argv[]
    )
/*++

Routine Description:

Main routine that calls the disconnect and query options

Arguments:

    [in]    argc  - Number of command line arguments.
    [in]    argv  - Array containing command line arguments.

Returned Value:

DWORD       - 0 for success exit
            - 1 for failure exit
--*/
{
  BOOL bCleanExit = FALSE;
  try{
        // local variables to this function
        BOOL bResult = TRUE;
        
        // variables to hold the values specified at the command prompt
        // -? ( help )
        BOOL bUsage = FALSE;
        
        // -disconnect
        BOOL bDisconnect = FALSE;
        
        //query command line options
        // -query
        BOOL bQuery = FALSE;
        BOOL bRestFlag = FALSE;
        DWORD dwRetVal = 0;

        #ifndef _WIN64
            dwRetVal = CheckSystemType( L"\0");
            if(dwRetVal!=EXIT_SUCCESS )
            {
                return EXIT_FAILURE;
            }
        #endif

        // if no command line argument is given than -query option
        // is takan by default.
        if(1 == argc)
        {
            if(IsWin2KOrLater()==FALSE)
            {
                ShowMessage(stderr,GetResString(IDS_INVALID_OS));
                bCleanExit = FALSE;
            }
            else
            {
               
                if ( FALSE  == IsUserAdmin())
                {
                    ShowMessage(stderr,GetResString(IDS_USER_NOT_ADMIN));
                    bCleanExit = FALSE;
                }
                else
                {
                    bCleanExit =  DoQuery(L"\0",FALSE,L"\0",FALSE);
                }
            }
        }
        else
        {

           // process and validate the command line options
            bResult = ProcessOptions( argc,
                                      argv,
                                      &bDisconnect,
                                      &bQuery,
                                      &bUsage,
                                      &bRestFlag);
            if( TRUE == bResult)
            {
                // check if -? is given as parameter.
                if( TRUE == bUsage )
                {
                   //check if -create is also given.
                   if( TRUE == bQuery)
                   {
                        // show usage for -create option.
                        bCleanExit = QueryUsage();
                   }
                   //check if -disconnect is also given.
                   else if ( TRUE == bDisconnect)
                   {
                        //Show usage for -disconnect option.
                        bCleanExit = DisconnectUsage();
                   }
                   //check if -disconnect is also given.
                   else if ( TRUE == bRestFlag)
                   {
                        //Show usage for -local option.
                        bCleanExit = LocalUsage();
                   }
                   else
                   {
                        //as no -create Or -disconnect given, show main usage.
                        bCleanExit = Usage();
                   }
                }
                else
                {
                    if( TRUE == bRestFlag)
                    {
                       // Process command line parameter specific to -local and 
                       // perform action for -local option.
                        bCleanExit = ProcessLocal(argc, argv);
                    }
                    else if( TRUE == bQuery)
                    {
                       // Process command line parameter specific to -query and
                       // perform action for -query option.
                        bCleanExit = ProcessQuery(argc, argv);
                    }
                    else if( TRUE == bDisconnect)
                    {
                       // Process command line parameter specific to -disconnect
                       // and perform action for -disconnect option.
                        bCleanExit = ProcessDisconnect(argc, argv);
                    }
                    else
                    {
                        TCHAR szTemp[2*MAX_STRING_LENGTH];
                        TCHAR szErrstr[MAX_RES_STRING];
                        TCHAR szFormatStr[MAX_RES_STRING];
                        SecureZeroMemory(szFormatStr,sizeof(TCHAR)*MAX_RES_STRING );
                        SecureZeroMemory(szErrstr,sizeof(TCHAR)*MAX_RES_STRING );
                        SecureZeroMemory(szTemp,sizeof(TCHAR)*(2*MAX_STRING_LENGTH));

                        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
                        StringCopy(szErrstr,GetResString(IDS_UTILITY_NAME),
                                    SIZE_OF_ARRAY(szFormatStr));
                        StringCopy(szFormatStr,GetResString(IDS_INVALID_SYNTAX),
                                   SIZE_OF_ARRAY(szFormatStr));
                        StringCchPrintfW(szTemp,SIZE_OF_ARRAY(szTemp),szFormatStr,szErrstr);
                        ShowMessage( stderr,(LPCWSTR)szTemp);
                        bCleanExit = FALSE;
                    }
                }
            }
            else
            {
                if( TRUE == g_bIs32BitEnv )
                {
                    // invalid syntax
                    ShowMessage( stderr,GetReason());
                }
                
                // return from the function
                bCleanExit =  FALSE;
            }

        }
  }
  catch(CHeap_Exception cheapException)
    {
       // catching the CHStrig related memory exceptions...
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       SaveLastError();
       ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
       bCleanExit =  FALSE;
    }

   // Release global memory if any allocated through common functionality
    ReleaseGlobals();
   return bCleanExit?EXIT_SUCCESS:EXIT_FAILURE;
}//_tmain

BOOL
ProcessLocal( 
    IN DWORD argc,
    IN LPCTSTR argv[]
    )
/*++

Routine Description:
 This function will perform Local related tasks.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
--*/
{
    // Variable to store function return value
    BOOL bResult = FALSE;
    LPTSTR pszLocalValue = NULL;

    bResult = ProcessOptions( argc,argv,&pszLocalValue);
    if( FALSE ==bResult)
    {
        // invalid syntax
        ShowMessage( stderr,GetReason() );
        //Release allocated memory safely
        SAFEDELETE(pszLocalValue);
        // return from the function
        return FALSE;
    }
    
    if ( FALSE  == IsUserAdmin())
    {
        ShowMessage(stderr,GetResString(IDS_USER_NOT_ADMIN));        
        bResult = FALSE;
    }
    else
    {
        // Only last argument is of interst
        bResult = DoLocalOpenFiles(0,FALSE,FALSE,pszLocalValue); 
    }

    FreeMemory( (LPVOID*)(&pszLocalValue));
    return bResult;
}

BOOL
ProcessQuery(
    IN DWORD argc,
    IN LPCTSTR argv[]
    )
/*++

Routine Description:
 This function will perform query related tasks.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
--*/
{
    // Variable to store function return value
    BOOL bResult = FALSE; 
    
    BOOL bCloseConnection = FALSE; 
    
    // options.
    // -query query
    BOOL   bQuery         = FALSE;
    
    // -nh (noheader)
    BOOL   bShowNoHeader  = FALSE;
    
    // -v (verbose)
    BOOL   bVerbose       = FALSE;
    
    // need password or not
    BOOL   bNeedPassword  = FALSE;
    
    // -s ( server name)
    LPTSTR pszServer      = NULL;
    
    // -u ( user name)
    LPTSTR pszUserName    = NULL;
    
    // -p ( password)
    LPTSTR pszPassword    = NULL;
    
    // -format
    LPTSTR pszFormat      = NULL;

    // server name used for EstablishConnection Function.
    LPTSTR pszServerName  = NULL;
    LPTSTR pszServerNameHeadPosition = NULL;

  try
    {

        //Stores status if connection to beclosed or not
        CHString szChString = L"";          

        // Process command line options.
        bResult = ProcessOptions(  argc,
                                   argv,
                                   &bQuery,
                                   &pszServer,
                                   &pszUserName,
                                   &pszPassword,
                                   &pszFormat,
                                   &bShowNoHeader,
                                   &bVerbose,
                                   &bNeedPassword);
        if ( FALSE == bResult)
        {
            // Invalid syntax.
            ShowMessage( stderr,GetReason() );
            
            //Release allocated memory safely
            FreeMemory((LPVOID*)&pszPassword);
            FreeMemory((LPVOID*)&pszServer);
            FreeMemory((LPVOID*)&pszUserName);
            FreeMemory((LPVOID*)&pszFormat);
            // return from the function
            return FALSE;
        }

        if( 0 != StringLength(pszServer,0))
        {
            pszServerName = (LPTSTR) AllocateMemory(GetBufferSize((LPVOID)pszServer));
            if( NULL == pszServerName)
            {
               SetLastError(ERROR_NOT_ENOUGH_MEMORY);
               SaveLastError();
               ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
               
                //Release allocated memory safely
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszFormat);
               
                // return from the function
                return FALSE;
            }
            
            // Initialize currently allocated arrays.
            SecureZeroMemory(pszServerName,GetBufferSize((LPVOID)pszServerName));

            // Store head position of 'pszServerName'.
            pszServerNameHeadPosition = pszServerName;

            szChString = pszServer;
            if((StringCompare(szChString.Left(2),DOUBLE_SLASH,FALSE,2)==0)
                                                        &&(szChString.GetLength()>2))
            {
                szChString = szChString.Mid( 2,szChString.GetLength()) ;
            }
            if(StringCompare(szChString.Left(1),SINGLE_SLASH,FALSE,1)!=0)
            {
                StringCopy(pszServer,(LPCWSTR)szChString,
                           GetBufferSize((LPVOID)pszServer));
            }
            StringCopy(pszServerName,pszServer,GetBufferSize((LPVOID)pszServerName));

            // Try to connect to remote server. Function checks for local machine
            // so here no checking is done.
            if(IsLocalSystem(pszServerName)==TRUE)
            {
    #ifndef _WIN64
            DWORD dwRetVal = CheckSystemType( L"\0");
            if(dwRetVal!=EXIT_SUCCESS )
            {
                //Release allocated memory safely
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszFormat);
                FreeMemory((LPVOID*)&pszServerNameHeadPosition);

                return EXIT_FAILURE;
            }
    #else
            DWORD  dwRetVal = CheckSystemType64( L"\0");
            if(dwRetVal!=EXIT_SUCCESS )
            {
                //Release allocated memory safely
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszFormat);
                FreeMemory((LPVOID*)&pszServerNameHeadPosition);

                return EXIT_FAILURE;
            }

    #endif 
                if(StringLength(pszUserName,0)>0)
                {
                    ShowMessage(stderr,GetResString(IDS_LOCAL_SYSTEM));
                }
                // Check if current logon user had administrative rights.
                // Preceed only if current logon user had administrative rights.
                if ( FALSE  == IsUserAdmin())
                {
                    ShowMessage(stderr,GetResString(IDS_USER_NOT_ADMIN));
                    
                    //Release allocated memory safely
                    FreeMemory((LPVOID*)&pszUserName);
                    FreeMemory((LPVOID*)&pszServer);
                    FreeMemory((LPVOID*)&pszPassword);
                    FreeMemory((LPVOID*)&pszFormat);
                    FreeMemory((LPVOID*)&pszServerNameHeadPosition);
                    
                    // return from the function
                    return FALSE;
                }
            }
            else
            {
                if( FALSE == EstablishConnection( pszServerName,
                                                  pszUserName,
                                                  GetBufferSize((LPVOID)pszUserName)/sizeof(WCHAR),
                                                  pszPassword,
                                                  GetBufferSize((LPVOID)pszPassword)/sizeof(WCHAR),
                                                  bNeedPassword ))
                {
                    // Connection to remote system failed , Show corresponding error
                    // and exit from function.
                    ShowMessage( stderr,GetResString(IDS_ID_SHOW_ERROR) );
                    if(StringLength(GetReason(),0)==0)
                    {
                        ShowMessage(stderr,GetResString(IDS_INVALID_CREDENTIALS));
                    }
                    else
                    {
                        ShowMessage( stderr,GetReason() );
                    }
                    
                    //Release allocated memory safely
                    FreeMemory((LPVOID*)&pszPassword);
                    FreeMemory((LPVOID*)&pszServer);
                    FreeMemory((LPVOID*)&pszUserName);
                    FreeMemory((LPVOID*)&pszFormat);
                    FreeMemory((LPVOID*)&pszServerNameHeadPosition);
                    return FALSE;
                }
                
                
                // determine whether this connection needs to disconnected later or not
                // though the connection is successfull, some conflict might have 
                // occured
                switch( GetLastError() )
                {
                case I_NO_CLOSE_CONNECTION:
                    bCloseConnection = FALSE;
                    break;
                case E_LOCAL_CREDENTIALS:
                case ERROR_SESSION_CREDENTIAL_CONFLICT:
                    {
                        //
                        // some error occured ... but can be ignored
                        // connection need not be disconnected
                        bCloseConnection= FALSE;
                        // show the warning message
                        ShowMessage(stderr,GetResString(IDS_ID_SHOW_WARNING));
                        ShowMessage(stderr,GetReason());
                        break;
                    }
                default:
                    bCloseConnection = TRUE;
                }
            }
        }
        // Password is no longer needed, better to free it.
        FreeMemory((LPVOID*)&pszPassword);


        // Perform Qyery operation.
        bResult = DoQuery(pszServer,
                          bShowNoHeader,
                          pszFormat,
                          bVerbose);
        
        // Close the network connection which is previously opened by
        // EstablishConnection
        if(bCloseConnection==TRUE)
        {
            CloseConnection(pszServerName);
        }
        FreeMemory((LPVOID*)&pszServer);
        FreeMemory((LPVOID*)&pszUserName);
        FreeMemory((LPVOID*)&pszFormat);
        FreeMemory((LPVOID*)&pszServerNameHeadPosition);
    }
    catch ( CHeap_Exception cheapException)
    {
        FreeMemory((LPVOID*)&pszPassword);
        FreeMemory((LPVOID*)&pszServer);
        FreeMemory((LPVOID*)&pszUserName);
        FreeMemory((LPVOID*)&pszFormat);
        FreeMemory((LPVOID*)&pszServerNameHeadPosition);
        
        throw(cheapException);
    }
    return bResult;
}


BOOL
ProcessDisconnect(
    IN DWORD argc,
    IN LPCTSTR argv[]
    )
/*++
Routine Description:
 This function will perform Disconnect related tasks.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
--*/
{
    // Variable to store function return value
    BOOL bResult = FALSE; 
    DWORD dwRetVal = 0;
    
    //Check whether connection to be closed or not.
    BOOL bCloseConnection = FALSE; 
    
    // Ask for password or not.
    BOOL bNeedPassword    = FALSE; 
    
    // options.
    // -query query
    BOOL   bQuery         = FALSE;

    // -s ( server name)
    LPTSTR pszServer      = NULL;
    
    // -u ( user name)
    LPTSTR pszUserName    = NULL;
    
    // -p ( password)
    LPTSTR pszPassword    = NULL;
    
    // server name used for EstablishConnection Function.
    LPTSTR pszServerName  = NULL;
    LPTSTR pszServerNameHeadPosition = NULL;
    //LPTSTR pszServerHeadPosition = NULL;

    // -I ( id )
    LPTSTR pszID          = NULL;

    //-a(accessedby)
    LPTSTR pszAccessedby  = NULL;
    
    // -o ( openmode)
    LPTSTR pszOpenmode    = NULL;

    // -op( openfile)
    LPTSTR pszOpenFile    = NULL;
    try
    {
        // Temp. variable
        CHString szChString = L"\0";          
        // Process commandline options.
        bResult = ProcessOptions(  argc,
                                   argv,
                                   &bQuery,
                                   &pszServer,
                                   &pszUserName,
                                   &pszPassword,
                                   &pszID,
                                   &pszAccessedby,
                                   &pszOpenmode,
                                   &pszOpenFile,
                                   &bNeedPassword);
        if ( FALSE == bResult)
        {
            // invalid syntax
            ShowMessage( stderr,GetReason() );
            
            //Release allocated memory safely
            FreeMemory((LPVOID*)&pszServer);
            FreeMemory((LPVOID*)&pszUserName);
            FreeMemory((LPVOID*)&pszPassword);
            FreeMemory((LPVOID*)&pszID);
            FreeMemory((LPVOID*)&pszAccessedby);
            FreeMemory((LPVOID*)&pszOpenmode);
            FreeMemory((LPVOID*)&pszOpenFile);
            
            // return from the function
            return FALSE;
        }

        if( 0 != StringLength(pszServer,0))
        {
            pszServerName = (LPTSTR) AllocateMemory(GetBufferSize((LPVOID)pszServer));
            if (NULL == pszServerName)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                SaveLastError();
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                //Release allocated memory safely
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszID);
                FreeMemory((LPVOID*)&pszAccessedby);
                FreeMemory((LPVOID*)&pszOpenmode);
                FreeMemory((LPVOID*)&pszOpenFile);
            }
            
            // Initialize currently allocated arrays.
            SecureZeroMemory(pszServerName,GetBufferSize((LPVOID)pszServerName));

            // store Head position Address  to successfully delete allocated memory 
            // block.
            pszServerNameHeadPosition = pszServerName;
            szChString = pszServer;

            // Append '\\' in front of server name is not specified. 
            if((StringCompare(szChString.Left(2),DOUBLE_SLASH,FALSE,2)==0)
                                                        &&(szChString.GetLength()>2))
            {
                szChString = szChString.Mid( 2,szChString.GetLength()) ;
            }
            if(StringCompare(szChString.Left(2),SINGLE_SLASH,FALSE,2)!=0)
            {
                StringCopy(pszServer,(LPCWSTR)szChString,
                           GetBufferSize((LPVOID)pszServer));
            }
            StringCopy(pszServerName,pszServer,GetBufferSize((LPVOID )pszServerName));
        }

        if(IsLocalSystem(pszServerName)==TRUE)
        {
    #ifndef _WIN64
            dwRetVal = CheckSystemType( L"\0");
            if(dwRetVal!=EXIT_SUCCESS )
            {
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszServerNameHeadPosition);
                FreeMemory((LPVOID*)&pszID);
                FreeMemory((LPVOID*)&pszAccessedby);
                FreeMemory((LPVOID*)&pszOpenmode);
                FreeMemory((LPVOID*)&pszOpenFile);
                return EXIT_FAILURE;
            }
    #else
            dwRetVal = CheckSystemType64( L"\0");
            if(dwRetVal!=EXIT_SUCCESS )
            {
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszServerNameHeadPosition);
                FreeMemory((LPVOID*)&pszID);
                FreeMemory((LPVOID*)&pszAccessedby);
                FreeMemory((LPVOID*)&pszOpenmode);
                FreeMemory((LPVOID*)&pszOpenFile);
                return EXIT_FAILURE;
            }

    #endif 

           if(StringLength(pszUserName,0)>0)
           {
                ShowMessage(stderr,GetResString(IDS_LOCAL_SYSTEM));
           }

        }
        else
        {
            // Connet to remote system.
            if(EstablishConnection( pszServerName,
                                    pszUserName,
                                    GetBufferSize((LPVOID)pszUserName)/sizeof(WCHAR),
                                    pszPassword,
                                    GetBufferSize((LPVOID)pszPassword)/sizeof(WCHAR),
                                    bNeedPassword )==FALSE)
            {
                // Connection to remote system failed , Show corresponding error
                // and exit from function.
                ShowMessage( stderr,
                             GetResString(IDS_ID_SHOW_ERROR) );
                if(StringLength(GetReason(),0)==0)
                {
                    ShowMessage(stderr,GetResString(IDS_INVALID_CREDENTIALS));
                }
                else
                {
                    ShowMessage( stderr,GetReason() );
                }
                
                //Release allocated memory safely
                FreeMemory((LPVOID*)&pszServer);
                FreeMemory((LPVOID*)&pszUserName);
                FreeMemory((LPVOID*)&pszPassword);
                FreeMemory((LPVOID*)&pszServerNameHeadPosition);
                FreeMemory((LPVOID*)&pszID);
                FreeMemory((LPVOID*)&pszAccessedby);
                FreeMemory((LPVOID*)&pszOpenmode);
                FreeMemory((LPVOID*)&pszOpenFile);
                
                return FALSE;
            }


            // determine whether this connection needs to disconnected later or not
            // though the connection is successfull, some conflict might have 
            // occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    //
                    // some error occured ... but can be ignored

                    // connection need not be disconnected
                    bCloseConnection= FALSE;

                    // show the warning message
                    ShowMessage(stderr,GetResString(IDS_ID_SHOW_WARNING));
                    ShowMessage(stderr,GetReason());
                    break;
                }
            default:
                bCloseConnection = TRUE;

            }

        }
       
       // Password is no longer needed, better to free it.
        FreeMemory((LPVOID*)&pszPassword);

       // Do Disconnect open files.....
        bResult = DisconnectOpenFile(pszServer,
                           pszID,
                           pszAccessedby,
                           pszOpenmode,
                           pszOpenFile );
        
        // Close the network connection which is previously opened by
        // EstablishConnection
        if(bCloseConnection==TRUE)
        {
            CloseConnection(pszServerName);
        }
        
        // Free memory which is previously allocated.
        FreeMemory((LPVOID*)&pszServer);
        FreeMemory((LPVOID*)&pszUserName);
        FreeMemory((LPVOID*)&pszServerNameHeadPosition);
        FreeMemory((LPVOID*)&pszID);
        FreeMemory((LPVOID*)&pszAccessedby);
        FreeMemory((LPVOID*)&pszOpenmode);
        FreeMemory((LPVOID*)&pszOpenFile);
    }
    catch (CHeap_Exception cheapException)
    {
        //Release allocated memory safely
        FreeMemory((LPVOID*)&pszServer);
        FreeMemory((LPVOID*)&pszUserName);
        FreeMemory((LPVOID*)&pszPassword);
        FreeMemory((LPVOID*)&pszID);
        FreeMemory((LPVOID*)&pszAccessedby);
        FreeMemory((LPVOID*)&pszOpenmode);
        FreeMemory((LPVOID*)&pszOpenFile);
        FreeMemory((LPVOID*)&pszServerNameHeadPosition);
        throw(cheapException);
    }
    return bResult;
}

BOOL
ProcessOptions( 
    IN  DWORD argc,
    IN  LPCTSTR argv[],
    OUT LPTSTR* pszLocalValue
    )
/*++

Routine Description:

  This function takes command line argument and checks for correct syntax and
  if the syntax is ok, Out variables [out] will contain respective values.

Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pszLocalValue   - contains the values for -local option

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
--*/
{
    TCMDPARSER2 cmdOptions[ MAX_LOCAL_OPTIONS ];//Variable to store command line
    
    CHString szTempString;
    TCHAR szTemp[MAX_RES_STRING*2];
    TCHAR szOptionAllowed[MAX_RES_STRING];
    StringCopy(szOptionAllowed,GetResString(IDS_LOCAL_OPTION),SIZE_OF_ARRAY(szTemp));

    szTempString = GetResString(IDS_UTILITY_NAME);
    StringCchPrintfW(szTemp,SIZE_OF_ARRAY(szTemp),
               GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);
    
     SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2) * MAX_LOCAL_OPTIONS);

    // -local
    StringCopyA( cmdOptions[ OI_O_LOCAL ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_O_LOCAL ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_O_LOCAL ].pwszOptions = szLocalOption;
    cmdOptions[ OI_O_LOCAL ].pwszFriendlyName = NULL;
    cmdOptions[ OI_O_LOCAL ].pwszValues = szOptionAllowed;
    cmdOptions[ OI_O_LOCAL ].dwCount = 1;
    cmdOptions[ OI_O_LOCAL ].dwActuals = 0;
    cmdOptions[ OI_O_LOCAL ].dwFlags = CP2_VALUE_OPTIONAL | CP2_ALLOCMEMORY | 
                                       CP2_MODE_VALUES ;
    cmdOptions[ OI_O_LOCAL ].pValue = NULL;
    cmdOptions[ OI_O_LOCAL ].dwLength    = StringLength(szOptionAllowed,0);
    cmdOptions[ OI_O_LOCAL ].pFunction = NULL;
    cmdOptions[ OI_O_LOCAL ].pFunctionData = NULL;
    cmdOptions[ OI_O_LOCAL ].dwReserved = 0;
    cmdOptions[ OI_O_LOCAL ].pReserved1 = NULL;
    cmdOptions[ OI_O_LOCAL ].pReserved2 = NULL;
    cmdOptions[ OI_O_LOCAL ].pReserved3 = NULL;


    //
    // do the command line parsing
    if ( FALSE == DoParseParam2( argc, argv, -1, MAX_LOCAL_OPTIONS, cmdOptions,0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       // invalid syntax
    }
    
    *pszLocalValue = (LPTSTR)cmdOptions[ OI_O_LOCAL ].pValue;
    if( NULL == *pszLocalValue)
    {
        // this string does not require localization
        // as it is storing value other than ON/OFF
        *pszLocalValue = (LPTSTR) AllocateMemory( (StringLength(L"SHOW_STATUS",0)+1) * sizeof( WCHAR ) );
        if ( *pszLocalValue == NULL )
        {
            SaveLastError();
            return FALSE;
        }
        StringCopy(*pszLocalValue, L"SHOW_STATUS", GetBufferSize((LPVOID)*pszLocalValue)); 
    }
    return TRUE;
}

BOOL
ProcessOptions( 
    IN  DWORD argc,
    IN  LPCTSTR argv[],
    OUT PBOOL pbDisconnect,
    OUT PBOOL pbQuery,
    OUT PBOOL pbUsage,
    OUT PBOOL pbResetFlag
    )
/*++

Routine Description:

  This function takes command line argument and checks for correct syntax and
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values.


Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pbDisconnect    - Discoonect option string
    [out]   pbQuery         - Query option string
    [out]   pbUsage         - The usage option
    [out]   pbResetFlag     - Reset flag.
Returned Value:

BOOL        -- TRUE if it succeeds
            -- FALSE if it fails.
--*/
{

    // local variables
    TCMDPARSER2 cmdOptions[ MAX_OPTIONS ];//Variable to store command line
                                        // options.
    LPTSTR pszTempServer   = NULL;//new TCHAR[MIN_MEMORY_REQUIRED];
    LPTSTR pszTempUser     = NULL;//new TCHAR[MIN_MEMORY_REQUIRED];
    LPTSTR pszTempPassword = NULL;//new TCHAR[MIN_MEMORY_REQUIRED];
    TARRAY arrTemp         = NULL;



    CHString szTempString;
    TCHAR szTemp[MIN_MEMORY_REQUIRED*2];
    szTempString = GetResString(IDS_UTILITY_NAME);
    StringCchPrintfW( szTemp,SIZE_OF_ARRAY(szTemp),
                GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);
    
    arrTemp = CreateDynamicArray();
    if( NULL == arrTemp)
    {
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       SaveLastError();
       ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
       return FALSE;
    }

    SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2) * MAX_OPTIONS);

    // prepare the command options
    // -disconnect option for help
    StringCopyA( cmdOptions[ OI_DISCONNECT ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_DISCONNECT ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_DISCONNECT ].pwszOptions = szDisconnectOption;
    cmdOptions[ OI_DISCONNECT ].pwszFriendlyName = NULL;
    cmdOptions[ OI_DISCONNECT ].pwszValues = NULL;
    cmdOptions[ OI_DISCONNECT ].dwCount = 1;
    cmdOptions[ OI_DISCONNECT ].dwActuals = 0;
    cmdOptions[ OI_DISCONNECT ].dwFlags = 0;
    cmdOptions[ OI_DISCONNECT ].pValue = pbDisconnect;
    cmdOptions[ OI_DISCONNECT ].dwLength    = 0;
    cmdOptions[ OI_DISCONNECT ].pFunction = NULL;
    cmdOptions[ OI_DISCONNECT ].pFunctionData = NULL;
    cmdOptions[ OI_DISCONNECT ].dwReserved = 0;
    cmdOptions[ OI_DISCONNECT ].pReserved1 = NULL;
    cmdOptions[ OI_DISCONNECT ].pReserved2 = NULL;
    cmdOptions[ OI_DISCONNECT ].pReserved3 = NULL;

    // -query option for help
    StringCopyA( cmdOptions[ OI_QUERY ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_QUERY ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_QUERY ].pwszOptions = szQueryOption;
    cmdOptions[ OI_QUERY ].pwszFriendlyName = NULL;
    cmdOptions[ OI_QUERY ].pwszValues = NULL;
    cmdOptions[ OI_QUERY ].dwCount = 1;
    cmdOptions[ OI_QUERY ].dwActuals = 0;
    cmdOptions[ OI_QUERY ].dwFlags = 0;
    cmdOptions[ OI_QUERY ].pValue = pbQuery;
    cmdOptions[ OI_QUERY ].dwLength    = 0;
    cmdOptions[ OI_QUERY ].pFunction = NULL;
    cmdOptions[ OI_QUERY ].pFunctionData = NULL;
    cmdOptions[ OI_QUERY ].dwReserved = 0;
    cmdOptions[ OI_QUERY ].pReserved1 = NULL;
    cmdOptions[ OI_QUERY ].pReserved2 = NULL;
    cmdOptions[ OI_QUERY ].pReserved3 = NULL;

    // /? option for help
    StringCopyA( cmdOptions[ OI_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_USAGE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_USAGE ].pwszOptions = szUsageOption;
    cmdOptions[ OI_USAGE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_USAGE ].pwszValues = NULL;
    cmdOptions[ OI_USAGE ].dwCount = 1;
    cmdOptions[ OI_USAGE ].dwActuals = 0;
    cmdOptions[ OI_USAGE ].dwFlags = CP_USAGE;
    cmdOptions[ OI_USAGE ].pValue = pbUsage;
    cmdOptions[ OI_USAGE ].dwLength    = 0;
    cmdOptions[ OI_USAGE ].pFunction = NULL;
    cmdOptions[ OI_USAGE ].pFunctionData = NULL;
    cmdOptions[ OI_USAGE ].dwReserved = 0;
    cmdOptions[ OI_USAGE ].pReserved1 = NULL;
    cmdOptions[ OI_USAGE ].pReserved2 = NULL;
    cmdOptions[ OI_USAGE ].pReserved3 = NULL;

    // -local
    StringCopyA( cmdOptions[ OI_LOCAL ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_LOCAL ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_LOCAL ].pwszOptions = szLocalOption;
    cmdOptions[ OI_LOCAL ].pwszFriendlyName = NULL;
    cmdOptions[ OI_LOCAL ].pwszValues = NULL;
    cmdOptions[ OI_LOCAL ].dwCount = 1;
    cmdOptions[ OI_LOCAL ].dwActuals = 0;
    cmdOptions[ OI_LOCAL ].dwFlags = 0;
    cmdOptions[ OI_LOCAL ].pValue = pbResetFlag;
    cmdOptions[ OI_LOCAL ].dwLength    = 0;
    cmdOptions[ OI_LOCAL ].pFunction = NULL;
    cmdOptions[ OI_LOCAL ].pFunctionData = NULL;
    cmdOptions[ OI_LOCAL ].dwReserved = 0;
    cmdOptions[ OI_LOCAL ].pReserved1 = NULL;
    cmdOptions[ OI_LOCAL ].pReserved2 = NULL;
    cmdOptions[ OI_LOCAL ].pReserved3 = NULL;

  //  default ..
  // Although there is no default option for this utility...
  // At this moment all the switches other than specified above will be
  // treated as default parameter for Main DoParceParam.
  // Exact parcing depending on optins (-query or -disconnect) will be done
  // at that respective places.
    StringCopyA( cmdOptions[ OI_DEFAULT ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_DEFAULT ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_DEFAULT ].pwszOptions = NULL;
    cmdOptions[ OI_DEFAULT ].pwszFriendlyName = NULL;
    cmdOptions[ OI_DEFAULT ].pwszValues = NULL;
    cmdOptions[ OI_DEFAULT ].dwCount = 0;
    cmdOptions[ OI_DEFAULT ].dwActuals = 0;
    cmdOptions[ OI_DEFAULT ].dwFlags = CP2_MODE_ARRAY|CP2_DEFAULT;
    cmdOptions[ OI_DEFAULT ].pValue = &arrTemp;
    cmdOptions[ OI_DEFAULT ].dwLength    = 0;
    cmdOptions[ OI_DEFAULT ].pFunction = NULL;
    cmdOptions[ OI_DEFAULT ].pFunctionData = NULL;
    cmdOptions[ OI_DEFAULT ].dwReserved = 0;
    cmdOptions[ OI_DEFAULT ].pReserved1 = NULL;
    cmdOptions[ OI_DEFAULT ].pReserved2 = NULL;
    cmdOptions[ OI_DEFAULT ].pReserved3 = NULL;

    //
    // do the command line parsing
    if ( FALSE == DoParseParam2( argc,argv,-1, MAX_OPTIONS,cmdOptions,0))
    {
        // invalid syntax.
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));

        // Release momory.
        SAFERELDYNARRAY(arrTemp);

        return FALSE;       
    }
    
    //Release memory as variable no longer needed
     SAFERELDYNARRAY(arrTemp);

    // Check if all of following is true is an error
    if((*pbUsage==TRUE)&&argc>3)
    {
         ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
         SetReason(szTemp);
         return FALSE;
    }
    
    // -query ,-disconnect and -local options cannot come together
    if(((*pbQuery)+(*pbDisconnect)+(*pbResetFlag))>1)
    {
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        SAFEDELETE(pszTempUser);
        SAFEDELETE(pszTempPassword);
        SAFEDELETE(pszTempServer);
        return FALSE;
    }
    else if((2 == argc )&&( TRUE == *pbUsage))
    {
       // if -? alone given its a valid conmmand line
        SAFEDELETE(pszTempUser);
        SAFEDELETE(pszTempPassword);
        SAFEDELETE(pszTempServer);
        return TRUE;
    }
    if((argc>2)&& ( FALSE == *pbQuery)&&(FALSE == *pbDisconnect)&&
                                                        (FALSE == *pbResetFlag))
    {
        // If command line argument is equals or greater than 2 atleast one
        // of -query OR -local OR -disconnect should be present in it.
        // (for "-?" previous condition already takes care)
        // This to prevent from following type of command line argument:
        // OpnFiles.exe -nh ... Which is a invalid syntax.
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        SAFEDELETE(pszTempUser);
        SAFEDELETE(pszTempPassword);
        SAFEDELETE(pszTempServer);
        
        return FALSE;
    }

    // Release momory.
    SAFEDELETE(pszTempUser);
    SAFEDELETE(pszTempPassword);
    SAFEDELETE(pszTempServer);
    return TRUE;
}//ProcesOptions


BOOL
ProcessOptions( 
    IN  DWORD argc,
    IN  LPCTSTR argv[],
    OUT PBOOL  pbQuery,
    OUT LPTSTR* pszServer,
    OUT LPTSTR* pszUserName,
    OUT LPTSTR* pszPassword,
    OUT LPTSTR* pszFormat,
    OUT PBOOL   pbShowNoHeader,
    OUT PBOOL   pbVerbose,
    OUT PBOOL   pbNeedPassword
    )
/*++

Routine Description:

  This function takes command line argument and checks for correct syntax and
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values. This Functin specifically checks
  command line parameters requered for QUERY option.


Arguments:

    [in]    argc            - Number of command line arguments.
    [in]    argv            - Array containing command line arguments.
    [out]   pbQuery         - query option string.
    [out]   pszServer       - remote server name.
    [out]   pszUserName     - username for the remote system.
    [out]   pszPassword     - password for the remote system for the username.
    [out]   pszFormat       - format checking.
    [out]   pbShowNoHeader  - show header.
    [out]   pbVerbose       - show verbose.
    [out]   pbNeedPassword  - To check whether the password is required or not.

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
--*/
{
   // Check in/out parameters...
    //Variable to store command line structure.
    TCMDPARSER2 cmdOptions[ MAX_QUERY_OPTIONS ];
    CHString szTempString;
    TCHAR szTemp[MIN_MEMORY_REQUIRED*2];
    TCHAR szTypeHelpMsg[MIN_MEMORY_REQUIRED];
    TCHAR szFormatValues[MAX_RES_STRING];

    szTempString = GetResString(IDS_UTILITY_NAME);
    StringCchPrintfW(szTemp,SIZE_OF_ARRAY(szTemp),
                       GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);
    StringCchPrintfW(szTypeHelpMsg, SIZE_OF_ARRAY(szTypeHelpMsg),
                GetResString(IDS_TYPE_Q_HELP),(LPCWSTR)szTempString);
    StringCopy(szFormatValues, FORMAT_OPTIONS, SIZE_OF_ARRAY(szFormatValues));


    //
    // prepare the command options
    SecureZeroMemory(cmdOptions, sizeof(TCMDPARSER2) * MAX_QUERY_OPTIONS);

    // -query option for help
    StringCopyA( cmdOptions[ OI_Q_QUERY ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_QUERY ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_Q_QUERY ].pwszOptions = szQueryOption;
    cmdOptions[ OI_Q_QUERY ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_QUERY ].pwszValues = NULL;
    cmdOptions[ OI_Q_QUERY ].dwCount = 1;
    cmdOptions[ OI_Q_QUERY ].dwActuals = 0;
    cmdOptions[ OI_Q_QUERY ].dwFlags = 0;
    cmdOptions[ OI_Q_QUERY ].pValue = pbQuery;
    cmdOptions[ OI_Q_QUERY ].dwLength    = 0;
    cmdOptions[ OI_Q_QUERY ].pFunction = NULL;
    cmdOptions[ OI_Q_QUERY ].pFunctionData = NULL;
    cmdOptions[ OI_Q_QUERY ].dwReserved = 0;
    cmdOptions[ OI_Q_QUERY ].pReserved1 = NULL;
    cmdOptions[ OI_Q_QUERY ].pReserved2 = NULL;
    cmdOptions[ OI_Q_QUERY ].pReserved3 = NULL;

    // -s  option remote system name
    StringCopyA( cmdOptions[ OI_Q_SERVER_NAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_SERVER_NAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_Q_SERVER_NAME ].pwszOptions = szServerNameOption;
    cmdOptions[ OI_Q_SERVER_NAME ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].pwszValues = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].dwCount = 1;
    cmdOptions[ OI_Q_SERVER_NAME ].dwActuals = 0;
    cmdOptions[ OI_Q_SERVER_NAME ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_Q_SERVER_NAME ].pValue = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].dwLength    = 0;
    cmdOptions[ OI_Q_SERVER_NAME ].pFunction = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].pFunctionData = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].dwReserved = 0;
    cmdOptions[ OI_Q_SERVER_NAME ].pReserved1 = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].pReserved2 = NULL;
    cmdOptions[ OI_Q_SERVER_NAME ].pReserved3 = NULL;

    // -u  option user name for the specified system
    StringCopyA( cmdOptions[ OI_Q_USER_NAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_USER_NAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_Q_USER_NAME ].pwszOptions = szUserNameOption;
    cmdOptions[ OI_Q_USER_NAME ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_USER_NAME ].pwszValues = NULL;
    cmdOptions[ OI_Q_USER_NAME ].dwCount = 1;
    cmdOptions[ OI_Q_USER_NAME ].dwActuals = 0;
    cmdOptions[ OI_Q_USER_NAME ].dwFlags = CP2_ALLOCMEMORY |CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_Q_USER_NAME ].pValue = NULL;
    cmdOptions[ OI_Q_USER_NAME ].dwLength    = 0;
    cmdOptions[ OI_Q_USER_NAME ].pFunction = NULL;
    cmdOptions[ OI_Q_USER_NAME ].pFunctionData = NULL;
    cmdOptions[ OI_Q_USER_NAME ].dwReserved = 0;
    cmdOptions[ OI_Q_USER_NAME ].pReserved1 = NULL;
    cmdOptions[ OI_Q_USER_NAME ].pReserved2 = NULL;
    cmdOptions[ OI_Q_USER_NAME ].pReserved3 = NULL;

    // -p option password for the given username
    StringCopyA( cmdOptions[ OI_Q_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_PASSWORD ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_Q_PASSWORD ].pwszOptions = szPasswordOption;
    cmdOptions[ OI_Q_PASSWORD ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_PASSWORD ].pwszValues = NULL;
    cmdOptions[ OI_Q_PASSWORD ].dwCount = 1;
    cmdOptions[ OI_Q_PASSWORD ].dwActuals = 0;
    cmdOptions[ OI_Q_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    cmdOptions[ OI_Q_PASSWORD ].pValue = NULL;
    cmdOptions[ OI_Q_PASSWORD ].dwLength    = 0;
    cmdOptions[ OI_Q_PASSWORD ].pFunction = NULL;
    cmdOptions[ OI_Q_PASSWORD ].pFunctionData = NULL;
    cmdOptions[ OI_Q_PASSWORD ].dwReserved = 0;
    cmdOptions[ OI_Q_PASSWORD ].pReserved1 = NULL;
    cmdOptions[ OI_Q_PASSWORD ].pReserved2 = NULL;
    cmdOptions[ OI_Q_PASSWORD ].pReserved3 = NULL;


    // -fo  (format)
    StringCopyA( cmdOptions[ OI_Q_FORMAT ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_FORMAT ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_Q_FORMAT ].pwszOptions = szFormatOption;
    cmdOptions[ OI_Q_FORMAT ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_FORMAT ].pwszValues = szFormatValues;
    cmdOptions[ OI_Q_FORMAT ].dwCount = 1;
    cmdOptions[ OI_Q_FORMAT ].dwActuals = 0;
    cmdOptions[ OI_Q_FORMAT ].dwFlags = CP2_MODE_VALUES  | CP2_VALUE_TRIMINPUT|
                                        CP2_VALUE_NONULL | CP2_ALLOCMEMORY;
    cmdOptions[ OI_Q_FORMAT ].pValue = NULL;
    cmdOptions[ OI_Q_FORMAT ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_Q_FORMAT ].pFunction = NULL;
    cmdOptions[ OI_Q_FORMAT ].pFunctionData = NULL;
    cmdOptions[ OI_Q_FORMAT ].dwReserved = 0;
    cmdOptions[ OI_Q_FORMAT ].pReserved1 = NULL;
    cmdOptions[ OI_Q_FORMAT ].pReserved2 = NULL;
    cmdOptions[ OI_Q_FORMAT ].pReserved3 = NULL;

    //-nh  (noheader)
    StringCopyA( cmdOptions[ OI_Q_NO_HEADER ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_NO_HEADER ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_Q_NO_HEADER ].pwszOptions = szNoHeadeOption;
    cmdOptions[ OI_Q_NO_HEADER ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].pwszValues = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].dwCount = 1;
    cmdOptions[ OI_Q_NO_HEADER ].dwActuals = 0;
    cmdOptions[ OI_Q_NO_HEADER ].dwFlags = 0;
    cmdOptions[ OI_Q_NO_HEADER ].pValue = pbShowNoHeader;
    cmdOptions[ OI_Q_NO_HEADER ].dwLength    = 0;
    cmdOptions[ OI_Q_NO_HEADER ].pFunction = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].pFunctionData = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].dwReserved = 0;
    cmdOptions[ OI_Q_NO_HEADER ].pReserved1 = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].pReserved2 = NULL;
    cmdOptions[ OI_Q_NO_HEADER ].pReserved3 = NULL;

    //-v verbose
    StringCopyA( cmdOptions[ OI_Q_VERBOSE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_Q_VERBOSE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_Q_VERBOSE ].pwszOptions = szVerboseOption;
    cmdOptions[ OI_Q_VERBOSE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_Q_VERBOSE ].pwszValues = NULL;
    cmdOptions[ OI_Q_VERBOSE ].dwCount = 1;
    cmdOptions[ OI_Q_VERBOSE ].dwActuals = 0;
    cmdOptions[ OI_Q_VERBOSE ].dwFlags = 0;
    cmdOptions[ OI_Q_VERBOSE ].pValue = pbVerbose;
    cmdOptions[ OI_Q_VERBOSE ].dwLength    = 0;
    cmdOptions[ OI_Q_VERBOSE ].pFunction = NULL;
    cmdOptions[ OI_Q_VERBOSE ].pFunctionData = NULL; 
    cmdOptions[ OI_Q_VERBOSE ].dwReserved = 0;
    cmdOptions[ OI_Q_VERBOSE ].pReserved1 = NULL;
    cmdOptions[ OI_Q_VERBOSE ].pReserved2 = NULL;
    cmdOptions[ OI_Q_VERBOSE ].pReserved3 = NULL;

    //
    // do the command line parsing
    if ( FALSE == DoParseParam2( argc,argv,OI_Q_QUERY, MAX_QUERY_OPTIONS,cmdOptions,0 ))
    {
        // invalid syntax
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       
    }
    *pszServer   = (LPTSTR)cmdOptions[ OI_Q_SERVER_NAME ].pValue;   
    *pszUserName = (LPTSTR)cmdOptions[ OI_Q_USER_NAME ].pValue;
    *pszPassword = (LPTSTR)cmdOptions[ OI_Q_PASSWORD ].pValue;
    *pszFormat   = (LPTSTR)cmdOptions[ OI_Q_FORMAT ].pValue;

     // -n is allowed only with -fo TABLE (which is also default)
     // and CSV.
     if(( TRUE == *pbShowNoHeader) && (1 == cmdOptions[ OI_Q_FORMAT ].dwActuals) &&
        (0 == StringCompare(*pszFormat,GetResString(IDS_LIST),TRUE,0)))
     {
         StringCopy(szTemp,GetResString(IDS_HEADER_NOT_ALLOWED),
                    SIZE_OF_ARRAY(szTemp));
         StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
         SetReason(szTemp);
         return FALSE;
     }

    // "-p" should not be specified without "-u"
    if ( 0 == cmdOptions[ OI_Q_USER_NAME ].dwActuals &&
         0 != cmdOptions[ OI_Q_PASSWORD ].dwActuals)
    {
        // invalid syntax
        StringCopy(szTemp,ERROR_PASSWORD_BUT_NOUSERNAME,SIZE_OF_ARRAY(szTemp));
        StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
        SetReason(szTemp);
        return FALSE;           
    }

     if(*pbQuery==FALSE)
     {
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        return FALSE;
     }
    
    // "-u" should not be specified without "-s"
    if ( 0 == cmdOptions[ OI_Q_SERVER_NAME ].dwActuals &&
         0 != cmdOptions[ OI_Q_USER_NAME ].dwActuals)
    {
        // invalid syntax
        StringCopy(szTemp,ERROR_USERNAME_BUT_NOMACHINE, SIZE_OF_ARRAY(szTemp));
        StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
        SetReason(szTemp);
        return FALSE;           
    }

    // check the remote connectivity information
    if ( *pszServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name 
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails 
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password 
        // before trying to connect
        //
        // case 3: -p * is specified
        
        // user name
        if ( *pszUserName == NULL )
        {
            *pszUserName = (LPTSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *pszUserName == NULL )
            {
                SaveLastError();
                return FALSE;
            }
        }

        // password
        if ( *pszPassword == NULL )
        {
            *pbNeedPassword = TRUE;
            *pszPassword = (LPTSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *pszPassword == NULL )
            {
                SaveLastError();
                return FALSE;
            }
        }

        // case 1
        if ( cmdOptions[ OI_Q_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ OI_Q_PASSWORD ].pValue == NULL )
        {
            StringCopy( *pszPassword, L"*", GetBufferSize((LPVOID)*pszPassword));
        }

        // case 3
        else if ( StringCompareEx( *pszPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)pszPassword, 
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                return FALSE;
            }

            // ...
            *pbNeedPassword = TRUE;
        }
    }

    return TRUE;
}

BOOL
ProcessOptions( 
    IN  DWORD argc,
    IN  LPCTSTR argv[],
    OUT PBOOL pbDisconnect,
    OUT LPTSTR* pszServer,
    OUT LPTSTR* pszUserName,
    OUT LPTSTR* pszPassword,
    OUT LPTSTR* pszID,
    OUT LPTSTR* pszAccessedby,
    OUT LPTSTR* pszOpenmode,
    OUT LPTSTR* pszOpenFile,
    OUT PBOOL pbNeedPassword
    )
/*++

Routine Description:

  This function takes command line argument and checks for correct syntax and
  if the syntax is ok, it returns the values in different variables. variables
  [out] will contain respective values. This Functin specifically checks
  command line parameters requered for DISCONNECT option.


Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pbDisconnect    - discoonect option string
    [out]   pszServer       - remote server name
    [out]   pszUserName     - username for the remote system
    [out]   pszPassword     - password for the remote system for the
                              username
    [out]   pszID           - Open file ids
    [out]   pszAccessedby   - Name of  user name who access the file
    [out]   pszOpenmode     - accessed mode (read/Write)
    [out]   pszOpenFile     - Open file name
    [out]   pbNeedPassword  - To check whether the password is required
                              or not.

Returned Value:

BOOL        --True if it succeeds
            --False if it fails.
--*/
{
    
    //Variable to store command line
    TCMDPARSER2 cmdOptions[ MAX_DISCONNECT_OPTIONS ];
    CHString szTempString;
    TCHAR szTemp[MIN_MEMORY_REQUIRED*2];
    TCHAR szTypeHelpMsg[MIN_MEMORY_REQUIRED];
    TCHAR szOpenModeValues[MAX_STRING_LENGTH];

    SecureZeroMemory(szOpenModeValues,sizeof(TCHAR)*MAX_STRING_LENGTH);
    szTempString = GetResString(IDS_UTILITY_NAME);
    StringCchPrintfW( szTemp,SIZE_OF_ARRAY(szTemp),
                GetResString(IDS_INVALID_SYNTAX),(LPCWSTR)szTempString);
    StringCchPrintfW( szTypeHelpMsg,SIZE_OF_ARRAY(szTypeHelpMsg),
                GetResString(IDS_TYPE_D_HELP),(LPCWSTR)szTempString);
    StringCopy(szOpenModeValues,OPENMODE_OPTIONS,SIZE_OF_ARRAY(szOpenModeValues));
    //
    // prepare the command options
    SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2)*MAX_DISCONNECT_OPTIONS);
    

    // -disconnect option for help
    StringCopyA( cmdOptions[ OI_D_DISCONNECT ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_DISCONNECT ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_D_DISCONNECT ].pwszOptions = szDisconnectOption;
    cmdOptions[ OI_D_DISCONNECT ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_DISCONNECT ].pwszValues = NULL;
    cmdOptions[ OI_D_DISCONNECT ].dwCount = 1;
    cmdOptions[ OI_D_DISCONNECT ].dwActuals = 0;
    cmdOptions[ OI_D_DISCONNECT ].dwFlags = 0;
    cmdOptions[ OI_D_DISCONNECT ].pValue = pbDisconnect;
    cmdOptions[ OI_D_DISCONNECT ].dwLength    = 0;
    cmdOptions[ OI_D_DISCONNECT ].pFunction = NULL;
    cmdOptions[ OI_D_DISCONNECT ].pFunctionData = NULL;
    cmdOptions[ OI_D_DISCONNECT ].dwReserved = 0;
    cmdOptions[ OI_D_DISCONNECT ].pReserved1 = NULL;
    cmdOptions[ OI_D_DISCONNECT ].pReserved2 = NULL;
    cmdOptions[ OI_D_DISCONNECT ].pReserved3 = NULL;

    // -s  option remote system name
    StringCopyA( cmdOptions[ OI_D_SERVER_NAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_SERVER_NAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_SERVER_NAME ].pwszOptions = szServerNameOption;
    cmdOptions[ OI_D_SERVER_NAME ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].pwszValues = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].dwCount = 1;
    cmdOptions[ OI_D_SERVER_NAME ].dwActuals = 0;
    cmdOptions[ OI_D_SERVER_NAME ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_D_SERVER_NAME ].pValue = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].dwLength    = 0;
    cmdOptions[ OI_D_SERVER_NAME ].pFunction = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].pFunctionData = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].dwReserved = 0;
    cmdOptions[ OI_D_SERVER_NAME ].pReserved1 = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].pReserved2 = NULL;
    cmdOptions[ OI_D_SERVER_NAME ].pReserved3 = NULL;

    // -u  option user name for the specified system
    StringCopyA( cmdOptions[ OI_D_USER_NAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_USER_NAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_USER_NAME ].pwszOptions = szUserNameOption;
    cmdOptions[ OI_D_USER_NAME ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_USER_NAME ].pwszValues = NULL;
    cmdOptions[ OI_D_USER_NAME ].dwCount = 1;
    cmdOptions[ OI_D_USER_NAME ].dwActuals = 0;
    cmdOptions[ OI_D_USER_NAME ].dwFlags = CP2_ALLOCMEMORY |CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_D_USER_NAME ].pValue = NULL;
    cmdOptions[ OI_D_USER_NAME ].dwLength    = 0;
    cmdOptions[ OI_D_USER_NAME ].pFunction = NULL;
    cmdOptions[ OI_D_USER_NAME ].pFunctionData = NULL;
    cmdOptions[ OI_D_USER_NAME ].dwReserved = 0;
    cmdOptions[ OI_D_USER_NAME ].pReserved1 = NULL;
    cmdOptions[ OI_D_USER_NAME ].pReserved2 = NULL;
    cmdOptions[ OI_D_USER_NAME ].pReserved3 = NULL;

    // -p option password for the given username
    StringCopyA( cmdOptions[ OI_D_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_PASSWORD ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_PASSWORD ].pwszOptions = szPasswordOption;
    cmdOptions[ OI_D_PASSWORD ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_PASSWORD ].pwszValues = NULL;
    cmdOptions[ OI_D_PASSWORD ].dwCount = 1;
    cmdOptions[ OI_D_PASSWORD ].dwActuals = 0;
    cmdOptions[ OI_D_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    cmdOptions[ OI_D_PASSWORD ].pValue = NULL;
    cmdOptions[ OI_D_PASSWORD ].dwLength    = 0;
    cmdOptions[ OI_D_PASSWORD ].pFunction = NULL;
    cmdOptions[ OI_D_PASSWORD ].pFunctionData = NULL;
    cmdOptions[ OI_D_PASSWORD ].dwReserved = 0;
    cmdOptions[ OI_D_PASSWORD ].pReserved1 = NULL;
    cmdOptions[ OI_D_PASSWORD ].pReserved2 = NULL;
    cmdOptions[ OI_D_PASSWORD ].pReserved3 = NULL;

    // -id  Values
    StringCopyA( cmdOptions[ OI_D_ID ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_ID ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_ID ].pwszOptions = szIDOption;
    cmdOptions[ OI_D_ID ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_ID ].pwszValues = NULL;
    cmdOptions[ OI_D_ID ].dwCount = 1;
    cmdOptions[ OI_D_ID ].dwActuals = 0;
    cmdOptions[ OI_D_ID ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_D_ID ].pValue = NULL;
    cmdOptions[ OI_D_ID ].dwLength    = 0;
    cmdOptions[ OI_D_ID ].pFunction = NULL;
    cmdOptions[ OI_D_ID ].pFunctionData = NULL;
    cmdOptions[ OI_D_ID ].dwReserved = 0;
    cmdOptions[ OI_D_ID ].pReserved1 = NULL;
    cmdOptions[ OI_D_ID ].pReserved2 = NULL;
    cmdOptions[ OI_D_ID ].pReserved3 = NULL;



    // -a (accessed by)
    StringCopyA( cmdOptions[ OI_D_ACCESSED_BY ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_ACCESSED_BY ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_ACCESSED_BY ].pwszOptions = szAccessedByOption;
    cmdOptions[ OI_D_ACCESSED_BY ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].pwszValues = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].dwCount = 1;
    cmdOptions[ OI_D_ACCESSED_BY ].dwActuals = 0;
    cmdOptions[ OI_D_ACCESSED_BY ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_D_ACCESSED_BY ].pValue = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].dwLength    = 0;
    cmdOptions[ OI_D_ACCESSED_BY ].pFunction = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].pFunctionData = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].dwReserved = 0;
    cmdOptions[ OI_D_ACCESSED_BY ].pReserved1 = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].pReserved2 = NULL;
    cmdOptions[ OI_D_ACCESSED_BY ].pReserved3 = NULL;


    // -o (openmode)
    StringCopyA( cmdOptions[ OI_D_OPEN_MODE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_OPEN_MODE ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_OPEN_MODE ].pwszOptions = szOpenModeOption;
    cmdOptions[ OI_D_OPEN_MODE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_OPEN_MODE ].pwszValues = szOpenModeValues;
    cmdOptions[ OI_D_OPEN_MODE ].dwCount = 1;
    cmdOptions[ OI_D_OPEN_MODE ].dwActuals = 0;
    cmdOptions[ OI_D_OPEN_MODE ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|
                                           CP2_VALUE_NONULL|CP2_MODE_VALUES;
    cmdOptions[ OI_D_OPEN_MODE ].pValue = NULL;
    cmdOptions[ OI_D_OPEN_MODE ].dwLength    = 0;
    cmdOptions[ OI_D_OPEN_MODE ].pFunction = NULL;
    cmdOptions[ OI_D_OPEN_MODE ].pFunctionData = NULL;
    cmdOptions[ OI_D_OPEN_MODE ].dwReserved = 0;
    cmdOptions[ OI_D_OPEN_MODE ].pReserved1 = NULL;
    cmdOptions[ OI_D_OPEN_MODE ].pReserved2 = NULL;
    cmdOptions[ OI_D_OPEN_MODE ].pReserved3 = NULL;

    // -op (openfile)
    StringCopyA( cmdOptions[ OI_D_OPEN_FILE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_D_OPEN_FILE ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_D_OPEN_FILE ].pwszOptions = szOpenFileOption;
    cmdOptions[ OI_D_OPEN_FILE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].pwszValues = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].dwCount = 1;
    cmdOptions[ OI_D_OPEN_FILE ].dwActuals = 0;
    cmdOptions[ OI_D_OPEN_FILE ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ OI_D_OPEN_FILE ].pValue = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].dwLength    = 0;
    cmdOptions[ OI_D_OPEN_FILE ].pFunction = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].pFunctionData = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].dwReserved = 0;
    cmdOptions[ OI_D_OPEN_FILE ].pReserved1 = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].pReserved2 = NULL;
    cmdOptions[ OI_D_OPEN_FILE ].pReserved3 = NULL;



    //
    // do the command line parsing.
    if ( FALSE == DoParseParam2( argc,argv,OI_D_DISCONNECT, MAX_DISCONNECT_OPTIONS ,cmdOptions,0))
    {
        // invalid syntax.
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        return FALSE;       
    }

    // Take values from parcer structure.
    *pszServer     = (LPTSTR)cmdOptions[ OI_D_SERVER_NAME ].pValue;   
    *pszUserName   = (LPTSTR)cmdOptions[ OI_D_USER_NAME ].pValue;
    *pszPassword   = (LPTSTR)cmdOptions[ OI_D_PASSWORD ].pValue;
    *pszID         = (LPTSTR)cmdOptions[ OI_D_ID ].pValue;
    *pszAccessedby = (LPTSTR)cmdOptions[ OI_D_ACCESSED_BY ].pValue;
    *pszOpenmode   = (LPTSTR)cmdOptions[ OI_D_OPEN_MODE ].pValue;
    *pszOpenFile   = (LPTSTR)cmdOptions[ OI_D_OPEN_FILE ].pValue;

     if(*pbDisconnect==FALSE)
     {
        ShowMessage( stderr, GetResString(IDS_ID_SHOW_ERROR) );
        SetReason(szTemp);
        return FALSE;
     }
    
    // At least one of -id OR -a OR -o is required.
    if((cmdOptions[ OI_D_ID ].dwActuals==0)&&
        (cmdOptions[ OI_D_ACCESSED_BY ].dwActuals==0)&&
        (cmdOptions[ OI_D_OPEN_MODE ].dwActuals==0)
        )
     {
        StringCopy(szTemp,GetResString(IDS_NO_ID_ACC_OF),SIZE_OF_ARRAY(szTemp));
        StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
        SetReason(szTemp);
        return FALSE;
     }

     // "-u" should not be specified without "-s"
    if ( 0 == cmdOptions[ OI_D_SERVER_NAME ].dwActuals &&
         0 != cmdOptions[ OI_D_USER_NAME ].dwActuals)
    {
        // invalid syntax
        StringCopy(szTemp,ERROR_USERNAME_BUT_NOMACHINE, SIZE_OF_ARRAY(szTemp));
        StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
        SetReason(szTemp);
        return FALSE;           
    }
    
    // "-p" should not be specified without "-u"
    if ( 0 == cmdOptions[ OI_D_USER_NAME ].dwActuals &&
         0 != cmdOptions[ OI_D_PASSWORD ].dwActuals)
    {
        // invalid syntax
        StringCopy(szTemp,ERROR_PASSWORD_BUT_NOUSERNAME, SIZE_OF_ARRAY(szTemp));
        StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
        SetReason(szTemp);
        return FALSE;           
    }
    
    if(1 == cmdOptions[ OI_D_ACCESSED_BY].dwActuals)
    {
        if(FindOneOf(*pszAccessedby,INVALID_USER_CHARS,0))
        {
            StringCopy(szTemp,GetResString(IDS_USER_INVALID_ADMIN),SIZE_OF_ARRAY(szTemp));
            SetReason(szTemp);
            return FALSE;           
        }
    }
    if (1 == cmdOptions[ OI_D_OPEN_FILE].dwActuals)
    {
        if(FindOneOf(*pszOpenFile,INVALID_FILE_NAME_CHARS,0))
        {
            StringCopy(szTemp,GetResString(IDS_FILENAME_INVALID),SIZE_OF_ARRAY(szTemp));
            SetReason(szTemp);
            return FALSE;           
        }
    }

    // check the remote connectivity information
    if ( *pszServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name 
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails 
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password 
        // before trying to connect
        //
        // case 3: -p * is specified
        
        // user name
        if ( *pszUserName == NULL )
        {
            *pszUserName = (LPTSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *pszUserName == NULL )
            {
                SaveLastError();
                return FALSE;
            }
        }

        // password
        if ( *pszPassword == NULL )
        {
            *pbNeedPassword = TRUE;
            *pszPassword = (LPTSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *pszPassword == NULL )
            {
                SaveLastError();
                return FALSE;
            }
        }

        // case 1
        if ( cmdOptions[ OI_D_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ OI_D_PASSWORD ].pValue == NULL )
        {
            StringCopy( *pszPassword, L"*", GetBufferSize((LPVOID)*pszPassword));
        }

        // case 3
        else if ( StringCompareEx( *pszPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)pszPassword, 
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                return FALSE;
            }

            // ...
            *pbNeedPassword = TRUE;
        }
    }

   // Check if -id option is given and if it is numeric ,
   // also if it is numeric then check its range
    if(1 == cmdOptions[ OI_D_ID ].dwActuals)
    {
        if ( TRUE == IsNumeric((LPCTSTR)(*pszID),10,TRUE))
        {
            if((AsLong((LPCTSTR)(*pszID),10)>UINT_MAX) ||
                (AsLong((LPCTSTR)(*pszID),10)<1))
            {
                // Message shown on screen will be...
                // ERROR: Invlid ID.
                StringCopy(szTemp,GetResString(IDS_ERROR_ID),SIZE_OF_ARRAY(szTemp));
                StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
                SetReason(szTemp);
                return FALSE;
            }

        }
        // check user given "*" or any junk string....
        if(!((StringCompare((LPCTSTR)(*pszID), ASTERIX, FALSE, 0)==0)||
            (IsNumeric((LPCTSTR)(*pszID),10,TRUE)==TRUE))
            &&(StringLength((LPCTSTR)(*pszID), 0)!=0))
        {
                // Message shown on screen will be...
                // ERROR: Invlid ID.
                StringCopy(szTemp,GetResString(IDS_ERROR_ID),SIZE_OF_ARRAY(szTemp));
                StringConcat(szTemp,szTypeHelpMsg,SIZE_OF_ARRAY(szTemp));
                SetReason(szTemp);
                
                return FALSE;
        }

    }
    return TRUE;
}

BOOL
DisconnectUsage(
    VOID
    )
/*++

Routine Description:

Displays how to use -disconnect option

Arguments:

    None

Returned Value:
    TRUE    :   Function returns successfully.
    FALSE   :   otherwise.

--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_LINE1; dw <= IDS_HELP_LINE_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
    
    return TRUE;
}//DisconnectUsage

BOOL
QueryUsage(
    VOID
    )
/*++

Routine Description:
    Displays how to use -query option
Arguments:
    None
Returned Value:
    TRUE    :   Function returns successfully.
    FALSE   :   otherwise.
--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_QUERY1; dw <= IDS_HELP_QUERY_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
   
    return TRUE;
}//query Usage

BOOL
Usage(
    VOID
    )
/*++

Routine Description:
    Displays how to use this Utility
Arguments:
    None
Returned Value:
    TRUE    :   Function returns successfully.
    FALSE   :   otherwise.
--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_MAIN1; dw <= IDS_HELP_MAIN_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
    
    return TRUE;
}//Usage

BOOL
LocalUsage()
/*++

Routine Description:
    Displays how to use -local option
Arguments:
    None
Returned Value:
    TRUE    :   Function returns successfully.
    FALSE   :   otherwise.

--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_LOCAL1; dw <= IDS_HELP_LOCAL_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
    
    return TRUE;
}//-local


DWORD 
CheckSystemType(
    IN LPTSTR szServer
    )
/*++
Routine Description:
    This function returns type of present Operating system.
    As this function is called only in case of 32 bit compilation, its value is 
    useful only build for 32 bit compilation.

Arguments:
    [in] szServer   : Server Name.

Returned Value:
    DWORD:
        EXIT_SUCCESS - If system is 32 bit.
        EXIT_FAILURE - Any error or system is not 32 bit.
--*/

{

    DWORD dwSystemType = 0 ;
#ifndef _WIN64
    
    //display the error message if  the target system is a 64 bit system or if
    // error occured in retreiving the information
     dwSystemType = GetCPUInfo(szServer);
    if( ERROR_RETREIVE_REGISTRY == dwSystemType)
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
        return (EXIT_FAILURE);

    }
    if( SYSTEM_64_BIT == dwSystemType)
    {
        if( 0 == StringLength(szServer, 0))
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_VERSION_MISMATCH));
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_REMOTE_NOT_SUPPORTED));
        }
        return (EXIT_FAILURE);
    }
#endif
        return EXIT_SUCCESS ;
}

DWORD
GetCPUInfo(
    IN LPTSTR szComputerName
    )
/*++
Routine Description: 
   This function determines if the computer is 32 bit system or 64 bit.
Arguments                      
     [ in ] szComputerName   : System name
Return Type                    : BOOL
     TRUE  :   if the system is a  32 bit system
     FALSE :   if the system is a  64 bit system
--*/
{
    HKEY     hKey1 = 0;

    HKEY     hRemoteKey = 0;
    TCHAR    szCurrentPath[MAX_STRING_LENGTH + 1];
    TCHAR    szPath[MAX_STRING_LENGTH + 1] = SUBKEY ;


    DWORD    dwValueSize = MAX_STRING_LENGTH+1;
    DWORD    dwRetCode = ERROR_SUCCESS;
    DWORD    dwError = 0;
    TCHAR    szTmpCompName[MAX_STRING_LENGTH+1];

    TCHAR szTemp[MIN_MEMORY_REQUIRED];
    TCHAR szVal[MIN_MEMORY_REQUIRED];
    DWORD dwLength = MAX_STRING_LENGTH + 10;
    LPTSTR szReturnValue = NULL ;
    DWORD dwCode =  0 ;
    szReturnValue = ( LPTSTR ) AllocateMemory( dwLength*sizeof( TCHAR ) );
   
    if( NULL == szReturnValue)
    {
        return ERROR_RETREIVE_REGISTRY ;
    }

    SecureZeroMemory(szCurrentPath, SIZE_OF_ARRAY(szCurrentPath));
    SecureZeroMemory(szTmpCompName, SIZE_OF_ARRAY(szTmpCompName));
    SecureZeroMemory(szTemp, SIZE_OF_ARRAY(szTemp));
    SecureZeroMemory(szVal, SIZE_OF_ARRAY( szVal));

    if( 0 != StringLength(szComputerName,0))
    {
        StringCopy(szTmpCompName,TOKEN_BACKSLASH4,SIZE_OF_ARRAY(szTmpCompName));
        StringConcat(szTmpCompName,szComputerName,SIZE_OF_ARRAY(szTmpCompName));
    }
    else
    {
        StringCopy(szTmpCompName,szComputerName,SIZE_OF_ARRAY(szTmpCompName));
    }

    // Get Remote computer local machine key
    dwError = RegConnectRegistry(szTmpCompName,HKEY_LOCAL_MACHINE,&hRemoteKey);
    if ( ERROR_SUCCESS == dwError)
    {
     dwError = RegOpenKeyEx(hRemoteKey,szPath,0,KEY_READ,&hKey1);
     if ( ERROR_SUCCESS == dwError)
     {
        dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,
                                        (LPBYTE) szReturnValue, &dwValueSize);
        if ( ERROR_MORE_DATA == dwRetCode)
        {
            if (!ReallocateMemory((LPVOID *)&szReturnValue, dwValueSize*sizeof( TCHAR )))
            {
                RegCloseKey(hKey1);
                RegCloseKey(hRemoteKey);
                FreeMemory( (LPVOID *)&szReturnValue );
                return ERROR_RETREIVE_REGISTRY ;
            }

            dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,
                                         (LPBYTE) szReturnValue, &dwValueSize);
        }

        if ( ERROR_SUCCESS != dwRetCode)
        {
            FreeMemory((LPVOID*)&szReturnValue);
            RegCloseKey(hKey1);
            RegCloseKey(hRemoteKey);
            return ERROR_RETREIVE_REGISTRY ;
        }
     }
     else
     {
        FreeMemory( (LPVOID*)&szReturnValue);
        RegCloseKey(hRemoteKey);
        return ERROR_RETREIVE_REGISTRY ;
     }

    RegCloseKey(hKey1);
    }
    else
    {
        FreeMemory((LPVOID*)&szReturnValue);
        RegCloseKey(hRemoteKey);
        return ERROR_RETREIVE_REGISTRY ;
    }

    RegCloseKey(hRemoteKey);

    StringCopy(szVal,X86_MACHINE, SIZE_OF_ARRAY(szVal));

    //check if the specified system contains the words x86 (belongs to the 32 )
    // set the flag to true if the specified system is 64 bit .

    if( !FindString(szReturnValue,szVal,0))
    {
        dwCode = SYSTEM_64_BIT ;
    }
    else
    {
        dwCode =  SYSTEM_32_BIT ;
    }
    FreeMemory((LPVOID*)&szReturnValue);
    return dwCode ;

}//GetCPUInfo

DWORD 
CheckSystemType64(
    IN LPTSTR szServer
    )
/*++
Routine Description:
    This function returns type of present Operating system.
    As this function is called only in case of 64 bit compilation, its value is 
    useful only build for 64 bit compilation.

Arguments:
    [in] szServer   : Server Name.

Returned Value:
    DWORD:
        EXIT_SUCCESS - If system is 64 bit.
        EXIT_FAILURE - Any error or system is not 64 bit.
--*/
{


    if( NULL == szServer)
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
        return (EXIT_FAILURE);
    }
#ifdef _WIN64
    DWORD dwSystemType = 0 ;
    //display the error message if  the target system is a 64 bit system or 
    //if error occured in retreiving the information
    dwSystemType = GetCPUInfo(szServer);
    if( ERROR_RETREIVE_REGISTRY == dwSystemType)
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
        return (EXIT_FAILURE);

    }
    if( SYSTEM_32_BIT == dwSystemType)
    {
        if( 0 == StringLength(szServer,0))
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_VERSION_MISMATCH1));
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_REMOTE_NOT_SUPPORTED1));
        }
        return (EXIT_FAILURE);
    }

#endif

    return EXIT_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\processowner.cpp ===
/******************************************************************************

  Copyright (C) Microsoft Corporation

  Module Name:
      ProcessOwner.CPP

  Abstract:
       This module deals with Query functionality of OpenFiles.exe
       NT command line utility.

  Author:

       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2001

 Revision History:

       Akhil Gokhale (akhil.gokhale@wipro.com) 25-APRIL-2001 : Created It.

*****************************************************************************/
#include "pch.h"
#include "OpenFiles.h"


#define SAFE_CLOSE_HANDLE(hHandle) \
        if( NULL != hHandle) \
        {\
           CloseHandle(hHandle);\
           hHandle = NULL;\
        }\
        1
#define SAFE_FREE_GLOBAL_ALLOC(block) \
           if( NULL != block)\
           {\
                delete block;\
                block = NULL;\
           }\
           1
#define SAFE_FREE_ARRAY(arr) \
         if( NULL != arr)\
         {\
             delete [] arr;\
             arr = NULL;\
         }\
         1

BOOL 
GetProcessOwner(
    OUT LPTSTR pszUserName,
    IN  DWORD hProcessID
    )
/*++
Routine Description:
    This function returns the owener (username) of the file.
    If a user is Owner of a process, then the file opened by this process will
    be owned by this user.
Arguments:
    [out] pszUserName :  User Name.
    [in]  hProcessID  :  Process Handle.   

Return Value:
    TRUE  : If function returns successfully.
    FALSE : Otherwise.
--*/
{

    DWORD dwRtnCode = 0;
    PSID pSidOwner;
    BOOL bRtnBool = TRUE;
    LPTSTR pszDomainName = NULL,pszAcctName = NULL;
    DWORD dwAcctName = 1, dwDomainName = 1;
    SID_NAME_USE snuUse = SidTypeUnknown;
    PSECURITY_DESCRIPTOR pSD=0;
    HANDLE  hHandle = GetCurrentProcess();
    HANDLE  hDynHandle = NULL;
    HANDLE  hDynToken = NULL;
    LUID luidValue;
    BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    // access token associated with the process
    bResult = OpenProcessToken( GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|
                                TOKEN_QUERY,&hToken);
    if( FALSE == bResult)

    {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL,SE_SECURITY_NAME,&luidValue );
    if( FALSE == bResult)
    {
        SAFE_CLOSE_HANDLE(hToken);
        return FALSE;
    }

    // Prepare the token privilege structure
    tkp.PrivilegeCount = 0;
    tkp.Privileges[0].Luid = luidValue;
    tkp.Privileges[0].Attributes =  SE_PRIVILEGE_ENABLED|
                                    SE_PRIVILEGE_USED_FOR_ACCESS;

    // Now enable the debug privileges in token

    bResult = AdjustTokenPrivileges(hToken, FALSE, &tkp,
                                    sizeof(TOKEN_PRIVILEGES),
                                    (PTOKEN_PRIVILEGES) NULL,
                                    (PDWORD)NULL);
    if( FALSE == bResult)
    {
        SAFE_CLOSE_HANDLE(hToken);
        return FALSE;
    }

    // Here you can give any valid process ids..
    hDynHandle = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,hProcessID); 

    if(NULL == hDynHandle)
    {

        return FALSE;

    }
    bResult = OpenProcessToken(hDynHandle,TOKEN_QUERY,&hDynToken);

    if( FALSE == bResult)
    {

        SAFE_CLOSE_HANDLE(hDynHandle);
        return FALSE;
    }
    
    TOKEN_USER * pUser = NULL;
    DWORD cb = 0;
    
    // determine size of the buffer needed to receive all information
    if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &cb))
    {
        if ( ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            SAFE_CLOSE_HANDLE(hToken);
            SAFE_CLOSE_HANDLE(hDynHandle);
            SAFE_CLOSE_HANDLE(hDynToken);

            return FALSE;
        }
    }

    try
    {
        // '_alloca' can throw exception.
        pUser = (TOKEN_USER *)_alloca(cb);
        if( NULL == pUser)
        {
            SAFE_CLOSE_HANDLE(hToken);
            SAFE_CLOSE_HANDLE(hDynHandle);
            SAFE_CLOSE_HANDLE(hDynToken);
            return FALSE;
        }
    }
    catch(...)
    {
        SAFE_CLOSE_HANDLE(hToken);
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        return FALSE;
    }

    if (!GetTokenInformation(hDynToken, TokenUser, pUser, cb, &cb))
    {
        SAFE_CLOSE_HANDLE(hToken);
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        return FALSE;
     }


    PSID pSid =  pUser->User.Sid;
    
    // Allocate memory for the SID structure.
    pSidOwner = new SID;
    
    // Allocate memory for the security descriptor structure.
    pSD = new SECURITY_DESCRIPTOR;
    if( NULL == pSidOwner || NULL == pSD)
    {
        SAFE_CLOSE_HANDLE(hToken);
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        SAFE_FREE_GLOBAL_ALLOC(pSD);
        SAFE_FREE_GLOBAL_ALLOC(pSidOwner);
       return FALSE;
    }

    // First call to LookupAccountSid to get the buffer sizes.
    bRtnBool = LookupAccountSid(
                      NULL,           // local computer
                      pUser->User.Sid,
                      NULL, // AcctName
                      (LPDWORD)&dwAcctName,
                      NULL, // DomainName
                      (LPDWORD)&dwDomainName,
                      &snuUse);

    pszAcctName = new TCHAR[dwAcctName+1];
    pszDomainName = new TCHAR[dwDomainName+1];

    if( NULL == pszAcctName|| NULL == pszDomainName)
    {
        SAFE_CLOSE_HANDLE(hToken);
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        SAFE_FREE_ARRAY(pszAcctName);
        SAFE_FREE_ARRAY(pszDomainName);
        return FALSE;
    }

    // Second call to LookupAccountSid to get the account name.
    bRtnBool = LookupAccountSid(
          NULL,                          // name of local or remote computer
          pUser->User.Sid,               // security identifier
          pszAcctName,                      // account name buffer
          (LPDWORD)&dwAcctName,          // size of account name buffer
          pszDomainName,                    // domain name
          (LPDWORD)&dwDomainName,        // size of domain name buffer
          &snuUse);                        // SID type

    SAFE_CLOSE_HANDLE(hDynHandle);
    SAFE_CLOSE_HANDLE(hDynToken);

    SAFE_FREE_GLOBAL_ALLOC(pSD);
    SAFE_FREE_GLOBAL_ALLOC(pSidOwner);

    // Check GetLastError for LookupAccountSid error condition.
    if ( FALSE == bRtnBool)
    {
        SAFE_CLOSE_HANDLE(hToken);
        SAFE_CLOSE_HANDLE(hDynHandle);
        SAFE_CLOSE_HANDLE(hDynToken);
        SAFE_FREE_ARRAY(pszAcctName);
        SAFE_FREE_ARRAY(pszDomainName);
        return FALSE;

    } else
    {
        // Check if user is "NT AUTHORITY".
        if(CSTR_EQUAL == CompareString(MAKELCID( MAKELANGID(LANG_ENGLISH,
                                              SUBLANG_ENGLISH_US),
                                            SORT_DEFAULT),
                               NORM_IGNORECASE,  
                               pszDomainName,
                               StringLength(pszDomainName,0),
                               NTAUTHORITY_USER , 
                               StringLength(NTAUTHORITY_USER, 0)
                              ))
        {
            SAFE_CLOSE_HANDLE(hToken);
            SAFE_CLOSE_HANDLE(hDynHandle);
            SAFE_CLOSE_HANDLE(hDynToken);

            SAFE_FREE_ARRAY(pszAcctName);
            SAFE_FREE_ARRAY(pszDomainName);
            return FALSE;
        }
        else
        {
            StringCopy(pszUserName,pszAcctName,MIN_MEMORY_REQUIRED);
            SAFE_CLOSE_HANDLE(hToken);
            SAFE_CLOSE_HANDLE(hDynHandle);
            SAFE_CLOSE_HANDLE(hDynToken);
            
            SAFE_FREE_ARRAY(pszAcctName);
            SAFE_FREE_ARRAY(pszDomainName);
            return TRUE;
        }
    }

    // Release memory.
    SAFE_FREE_ARRAY(pszAcctName);
    SAFE_FREE_ARRAY(pszDomainName);
    SAFE_CLOSE_HANDLE(hDynHandle);
    SAFE_CLOSE_HANDLE(hDynToken);
    SAFE_CLOSE_HANDLE(hToken);

    SAFE_FREE_GLOBAL_ALLOC(pSD);
    SAFE_FREE_GLOBAL_ALLOC(pSidOwner);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\pentbug\makefile.inc ===
pbmsg.rc: msg00001.bin

pbmsg.h msg00001.bin: pbmsg.mc
    mc -v -h .\ pbmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\query.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      Query.h
//
//  Abstract:
//
//      macros and function prototypes of Query.cpp
//
//  Author:
//
//    Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000
//
//  Revision History:
//
//    Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.
//
// *********************************************************************************

#ifndef _QUERY_H
#define _QUERY_H
#include "openfiles.h"
#define COL_WIDTH_HOSTNAME          15
#define COL_WIDTH_ID                8
#define COL_WIDTH_ACCESSED_BY       20
#define COL_WIDTH_TYPE              10
#define COL_WIDTH_LOCK              10
#define COL_WIDTH_OPEN_MODE         15
#define COL_WIDTH_OPEN_FILE         36

#define MAX_OUTPUT_COLUMN            7

#define COL_HOSTNAME        GetResString(IDS_STRING_HOSTNAME)
#define COL_ID              GetResString(IDS_STRING_ID)
#define COL_ACCESSED_BY     GetResString(IDS_STRING_ACCESSED_BY)
#define COL_TYPE            GetResString(IDS_STRING_TYPE)
#define COL_LOCK            GetResString(IDS_STRING_LOCK)
#define COL_OPEN_MODE       GetResString(IDS_STRING_OPEN_MODE)
#define COL_OPEN_FILE       GetResString(IDS_STRING_OPEN_FILE)

#define MAC_OS              GetResString(IDS_MAC_OS)

#define RNR_BUFFER_SIZE 1000

LPTSTR
GetHostByName(
    IN LPCTSTR pszName
    );

LPTSTR
GetHostByAddr(
    IN LPCTSTR pszAddress
    );

LPBLOB
GetXYDataEnt(
    IN  DWORD dwLength,
    IN  LPTSTR pszName,
    IN  LPGUID lpType,
    OUT LPTSTR pszHostName
    );

BOOL
DoQuery(
    IN PTCHAR pszServer,
    IN BOOL bShowNoHeader,
    IN PTCHAR pszFormat,
    IN BOOL bVerbose
    );

BOOL
GetHostName(
    IN OUT PTCHAR pszServer
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\query.cpp ===
/******************************************************************************

  Copyright (C) Microsoft Corporation

  Module Name:
      Query.CPP

  Abstract:
       This module deals with Query functionality of OpenFiles.exe
       NT command line utility.

  Author:

       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000

 Revision History:

       Akhil Gokhale (akhil.gokhale@wipro.com) 1-Nov-2000 : Created It.


*****************************************************************************/
#include "pch.h"
#include "query.h"

GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid =  SVCID_INET_HOSTADDRBYINETSTRING;

AFPROTOCOLS afp[2] = {
                      {AF_INET, IPPROTO_UDP},
                      {AF_INET, IPPROTO_TCP}
                     };

BOOL
DoQuery(
    IN PTCHAR pszServer,
    IN BOOL bShowNoHeader,
    IN PTCHAR pszFormat,
    IN BOOL bVerbose
    )
/*++
Routine Description:

  This function Queries for all open files in for the server and display them.

Arguments:

    [in]    pszServer      : Will have the server name.
    [in]    bShowNoHeader  : Will have the value whether to show header or not.
    [in]    pszFormat      : Will have the format required to show the result.
    [in]    bVerbose       : Will have the value whether to show verbose
                             result.

Return Value:
    TRUE if query successful
    else FALSE

--*/
{

    CHString   szCHString = L"\0";
    
    // Receives the count of elements actually enumerated by "NetFileEnum" 
    // function
    DWORD dwEntriesRead = 0;
    
    // Receives the total number of entries that could have been enumerated 
    // from the current resume position by "NetFileEnum" function
    DWORD dwTotalEntries = 0;
    
    // Contains a resume handle which is used to continue an existing file 
    // search. The handle should be zero on the first call and left unchanged 
    // for subsequent calls. If resume_handle is NULL, then no resume handle 
    // is stored. This variable used in calling "NetFileEnum" function.
    DWORD dwResumeHandle = 0;

    // Contains the state whether at least one record found for this query.
    BOOL bAtLeastOne = FALSE;

    // Stores format flag required to show result on console. Default format
    // is TABLE    
    DWORD dwFormat = SR_FORMAT_TABLE;

    // LPFILE_INFO_3  structure contains the identification number and other
    // pertinent information about files, devices, and pipes.
    LPFILE_INFO_3 pFileInfo3_1 = NULL;
    LPFILE_INFO_3 pFileInfo3Org_1 = NULL;


    // Contains return value for "NetFileEnum" function.
    DWORD dwError = 0;
  
    // Stores server type information.
    LPTSTR pszServerType = new TCHAR[MIN_MEMORY_REQUIRED+1];

    AFP_FILE_INFO* pFileInfo = NULL;
    AFP_FILE_INFO* pFileInfoOrg = NULL;
    DWORD hEnumHandle = 0;


    AFP_SERVER_HANDLE ulSFMServerConnection = 0;
    typedef  DWORD (*FILEENUMPROC)(AFP_SERVER_HANDLE,LPBYTE*,DWORD,LPDWORD,
                                   LPDWORD,LPDWORD);
    typedef  DWORD (*CONNECTPROC) (LPWSTR,PAFP_SERVER_HANDLE);
    typedef  DWORD (*MEMFREEPROC) (LPVOID);

    // buffer for Windows directory path.
    TCHAR   szDllPath[MAX_PATH+1];

    // AfpAdminConnect and AfpAdminFileEnum functions are undocumented function
    // and used only for MAC client.
    CONNECTPROC  AfpAdminConnect = NULL; // Function Pointer
    FILEENUMPROC AfpAdminFileEnum = NULL;// Function Pointer
    MEMFREEPROC  AfpAdminBufferFree = NULL; // Function Pointer

    // To store retval for LoadLibrary
    HMODULE hModule = 0;         

    DWORD dwIndx = 0;               //  Indx variable
    DWORD dwRow  = 0;             //   Row No indx.



    //server name to be shown
    LPTSTR pszServerNameToShow = new TCHAR[MIN_MEMORY_REQUIRED+ 1];
    LPTSTR pszTemp = new TCHAR[MIN_MEMORY_REQUIRED+ 1];
    
    //Some column required to hide in non verbose mode query
    DWORD  dwMask = bVerbose?SR_TYPE_STRING:SR_HIDECOLUMN|SR_TYPE_STRING;
    TCOLUMNS pMainCols[]=
    {
        {L"\0",COL_WIDTH_HOSTNAME,dwMask,L"\0",NULL,NULL},
        {L"\0",COL_WIDTH_ID,SR_TYPE_STRING,L"\0",NULL,NULL},
        {L"\0",COL_WIDTH_ACCESSED_BY,SR_TYPE_STRING,L"\0",NULL,NULL},
        {L"\0",COL_WIDTH_TYPE,SR_TYPE_STRING,L"\0",NULL,NULL},
        {L"\0",COL_WIDTH_LOCK,dwMask,L"\0",NULL,NULL},
        {L"\0",COL_WIDTH_OPEN_MODE,dwMask,L"\0",NULL,NULL},
        {L"\0",COL_WIDTH_OPEN_FILE,SR_TYPE_STRING|
                       (SR_NO_TRUNCATION&~(SR_WORDWRAP)),L"\0",NULL,NULL}

    };

    TARRAY pColData  = CreateDynamicArray();//array to stores
                                            //result

    if(( NULL == pszServerNameToShow)||
       ( NULL == pszServerType)||
       ( NULL == pColData)||
       ( NULL == pszTemp))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        SAFEDELETE(pszServerNameToShow);
        SAFEDELETE(pszServerType);
        SAFERELDYNARRAY(pColData);
        SAFEDELETE(pszTemp);
        return FALSE;
    }

    // Initialize allocated arrays
    SecureZeroMemory(pszServerNameToShow,MIN_MEMORY_REQUIRED*sizeof(TCHAR));
    SecureZeroMemory(pszServerType,MIN_MEMORY_REQUIRED*sizeof(TCHAR));
    SecureZeroMemory(szDllPath, SIZE_OF_ARRAY(szDllPath));

    // Fill column headers with TEXT.
    StringCopy(pMainCols[0].szColumn, COL_HOSTNAME, SIZE_OF_ARRAY(pMainCols[0].szColumn));
    StringCopy(pMainCols[1].szColumn, COL_ID, SIZE_OF_ARRAY(pMainCols[1].szColumn));
    StringCopy(pMainCols[2].szColumn, COL_ACCESSED_BY, SIZE_OF_ARRAY(pMainCols[2].szColumn));
    StringCopy(pMainCols[3].szColumn, COL_TYPE, SIZE_OF_ARRAY(pMainCols[3].szColumn));
    StringCopy(pMainCols[4].szColumn, COL_LOCK, SIZE_OF_ARRAY(pMainCols[4].szColumn));
    StringCopy(pMainCols[5].szColumn, COL_OPEN_MODE, SIZE_OF_ARRAY(pMainCols[5].szColumn));
    StringCopy(pMainCols[6].szColumn, COL_OPEN_FILE, SIZE_OF_ARRAY(pMainCols[6].szColumn));

    if( NULL != pszFormat)
    {
        if( 0 == StringCompare(pszFormat,GetResString(IDS_LIST),TRUE, 0))
        {
            dwFormat = SR_FORMAT_LIST;
        }
        else if( 0 == StringCompare(pszFormat,GetResString(IDS_CSV),TRUE,0))
        {
            dwFormat = SR_FORMAT_CSV;
        }
    }

    // Check if local machine
    if(( NULL == pszServer)||
       ( TRUE == IsLocalSystem(pszServer)))
    {
        DWORD dwBuffLength;
        dwBuffLength = RNR_BUFFER_SIZE + 1 ;
        // Gets the name of computer for local machine.
        GetComputerName(pszServerNameToShow,&dwBuffLength);
        // Show Local Open files
        DoLocalOpenFiles (dwFormat,bShowNoHeader,bVerbose,L"\0");
        ShowMessage(stdout,GetResString(IDS_SHARED_OPEN_FILES));
        ShowMessage(stdout,GetResString(IDS_LOCAL_OPEN_FILES_SP2));
    }
    else
    {
        // pszServername can be changed in GetHostName function
        // so a copy of pszServer is passed.
        StringCopy(pszServerNameToShow, pszServer, MIN_MEMORY_REQUIRED);
        if( FALSE == GetHostName(pszServerNameToShow))
        {
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);

            return FALSE;
        }
    }

    // Server type is "Windows" as NetFileEnum enumerates file only for
    // files opened for windows client
    StringCopy(pszServerType,GetResString(IDS_STRING_WINDOWS),
                                                          MIN_MEMORY_REQUIRED);
    do
    {
        //The NetFileEnum function returns information about some
        // or all open files (from Windows client) on a server
        dwError = NetFileEnum( pszServer, NULL, NULL, 3,
                              (LPBYTE*)&pFileInfo3_1,
                               MAX_PREFERRED_LENGTH,
                               &dwEntriesRead,
                               &dwTotalEntries,
                               (PDWORD_PTR)&dwResumeHandle );

        if( ERROR_ACCESS_DENIED == dwError)
        {
            SetLastError(E_ACCESSDENIED);
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);

            return FALSE;
        }

        pFileInfo3Org_1 = pFileInfo3_1;
        if(  NERR_Success == dwError || ERROR_MORE_DATA  == dwError)
        {
            for ( dwIndx = 0; dwIndx < dwEntriesRead;
                  dwIndx++, pFileInfo3_1++ )
            {

                // Now fill the result to dynamic array "pColData"
                DynArrayAppendRow( pColData, 0 );
                // Hostname
                DynArrayAppendString2(pColData,dwRow,pszServerNameToShow,0);
                // id
                StringCchPrintfW(pszTemp, MIN_MEMORY_REQUIRED-1,_T("%lu"),
                           pFileInfo3_1->fi3_id);
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0);
                // Accessed By
                if(StringLength(pFileInfo3_1->fi3_username, 0)<=0)
                {
                    DynArrayAppendString2(pColData,dwRow,
                                      GetResString(IDS_NA),0);

                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       pFileInfo3_1->fi3_username,0);

                }
                
                // Type
                DynArrayAppendString2(pColData,dwRow,pszServerType,0);
                
                // Locks
                StringCchPrintfW(pszTemp,MIN_MEMORY_REQUIRED-1,
                           _T("%ld"),pFileInfo3_1->fi3_num_locks);
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0);

                 // Checks for  open file mode
                if((pFileInfo3_1->fi3_permissions & PERM_FILE_READ)&&
                   (pFileInfo3_1->fi3_permissions & PERM_FILE_WRITE ))
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_READ_WRITE),0);
                }
                else if(pFileInfo3_1->fi3_permissions & PERM_FILE_WRITE )
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_WRITE),0);

                }
                else if(pFileInfo3_1->fi3_permissions & PERM_FILE_READ )
                {
                      DynArrayAppendString2(pColData,dwRow,
                                         GetResString(IDS_READ),0);
                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       GetResString(IDS_NOACCESS),0);

                }


                // If show result is  table mode and if
                // open file length is gerater than
                // column with, Open File string cut from right
                // by COL_WIDTH_OPEN_FILE-5 and "..." will be
                // inserted before the string.
                // Example o/p:  ...notepad.exe
                szCHString = pFileInfo3_1->fi3_pathname;
                if( FALSE == bVerbose)
                {
                    if((szCHString.GetLength()>(COL_WIDTH_OPEN_FILE-5))&&
                        ( SR_FORMAT_TABLE == dwFormat))
                    {
                        // If file path is too big to fit in column width
                        // then it is cut like..
                        // c:\...\rest_of_the_path.
                        CHString szTemp = 
                                      szCHString.Right(COL_WIDTH_OPEN_FILE-5);;
                        DWORD dwTemp = szTemp.GetLength();
                        szTemp = szTemp.Mid(szTemp.Find(SINGLE_SLASH),
                                           dwTemp);
                        szCHString.Format(L"%s%s%s",szCHString.Mid(0,3),
                                                    DOT_DOT,
                                                    szTemp);
                        pMainCols[6].dwWidth = COL_WIDTH_OPEN_FILE+1;
                    }
                }
                else
                {

                    pMainCols[6].dwWidth = 80;
                }

               // Open File name
                DynArrayAppendString2(pColData,dwRow,
                                   (LPCWSTR)szCHString,0);

                bAtLeastOne = TRUE;
                dwRow++;
            }// Enf for loop
        }
        
        // Free the block
        if( NULL != pFileInfo3Org_1 )
        {
            NetApiBufferFree( pFileInfo3Org_1 );
            pFileInfo3_1 = NULL;
        }

    } while ( ERROR_MORE_DATA == dwError );

    // Now Enumerate  Open files for MAC Client..................

    // Server type is "Machintosh" as AfpAdminFileEnum enumerates file only for
    // files opened for Mac client
    StringCopy(pszServerType, MAC_OS, MIN_MEMORY_REQUIRED);
        // DLL required stored always in \windows\system32 directory....
        // so get windows directory first.
    if( 0 != GetSystemDirectory(szDllPath, MAX_PATH))
    {
        // appending dll file name
        StringConcat(szDllPath,MAC_DLL_FILE_NAME,MAX_PATH); 
        hModule = ::LoadLibrary (szDllPath);

        if( NULL == hModule)
        {
            ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
            
            // Shows the error string set by API function.
            ShowLastError(stderr); 
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);
            return FALSE;

        }
    }
    else
    {
            ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
            
            // Shows the error string set by API function.
            ShowLastError(stderr); 
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);
            return FALSE;
    }

    AfpAdminConnect = 
        (CONNECTPROC)::GetProcAddress (hModule,"AfpAdminConnect");
    AfpAdminFileEnum = 
        (FILEENUMPROC)::GetProcAddress (hModule,"AfpAdminFileEnum");
    AfpAdminBufferFree = 
        (MEMFREEPROC)::GetProcAddress (hModule,"AfpAdminBufferFree");

    if(( NULL == AfpAdminConnect) ||
        ( NULL == AfpAdminFileEnum) ||
        ( NULL == AfpAdminBufferFree))
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        
        // Shows the error string set by API function.
        ShowLastError(stderr); 
        SAFEDELETE(pszServerNameToShow);
        SAFEDELETE(pszServerType);
        SAFERELDYNARRAY(pColData);
        SAFEDELETE(pszTemp);
        FREE_LIBRARY(hModule);
        return FALSE;
    }

    // Connection ID is required for AfpAdminFileEnum function.
    // So connect to server to get connect id...
    DWORD retval_connect =  AfpAdminConnect(const_cast<LPWSTR>(pszServer),
                            &ulSFMServerConnection );
    if( 0 != retval_connect)
    {
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        
        // Shows the error string set by API function.
        ShowLastError(stderr); 
        SAFEDELETE(pszServerNameToShow);
        SAFEDELETE(pszServerType);
        SAFERELDYNARRAY(pColData);
        SAFEDELETE(pszTemp);
        FREE_LIBRARY(hModule);
            return FALSE;
    }

    do
    {

        //The AfpAdminFileEnum function returns information about some
        // or all open files (from MAC client) on a server
         dwError =     AfpAdminFileEnum( ulSFMServerConnection,
                                      (PBYTE*)&pFileInfo,
                                      (DWORD)-1L,
                                      &dwEntriesRead,
                                      &dwTotalEntries,
                                      &hEnumHandle );
        if( ERROR_ACCESS_DENIED == dwError)
        {
            SetLastError(E_ACCESSDENIED);
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFEDELETE(pszServerNameToShow);
            SAFEDELETE(pszServerType);
            SAFERELDYNARRAY(pColData);
            SAFEDELETE(pszTemp);
            FREE_LIBRARY(hModule);
            return FALSE;
        }
        pFileInfoOrg = pFileInfo;
        if( NERR_Success == dwError  || ERROR_MORE_DATA  == dwError)
        {

           for ( dwIndx = 0 ; dwIndx < dwEntriesRead;
                  dwIndx++, pFileInfo++ )
            {

                // Now fill the result to dynamic array "pColData"
                DynArrayAppendRow( pColData, 0 );
                
                // Hostname
                DynArrayAppendString2(pColData,dwRow,pszServerNameToShow,0);
                
                // id
                StringCchPrintfW(pszTemp,MIN_MEMORY_REQUIRED-1,
                           _T("%lu"),pFileInfo->afpfile_id );
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0);
                
                // Accessed By
                if(StringLength(pFileInfo->afpfile_username,0 )<=0)
                {
                    DynArrayAppendString2(pColData,dwRow,
                                      GetResString(IDS_NA),0);

                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       pFileInfo->afpfile_username,0);

                }
                
                // Server Type
                DynArrayAppendString2(pColData,dwRow,pszServerType,0);
                
                // Locks
                StringCchPrintfW(pszTemp,MIN_MEMORY_REQUIRED-1,
                           _T("%ld"),pFileInfo->afpfile_num_locks );
                DynArrayAppendString2(pColData ,dwRow,pszTemp,0);

                // Checks for  open file mode
                if((pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_READ)&&
                   (pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_WRITE ))
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_READ_WRITE),0);
                }
                else if(pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_WRITE )
                {
                     DynArrayAppendString2(pColData,dwRow,
                                        GetResString(IDS_WRITE),0);

                }
                else if(pFileInfo->afpfile_open_mode  & AFP_OPEN_MODE_READ )
                {
                      DynArrayAppendString2(pColData,dwRow,
                                         GetResString(IDS_READ),0);
                }
                else
                {
                    DynArrayAppendString2(pColData,dwRow,
                                       GetResString(IDS_NOACCESS),0);
                }

                // If show result is  table mode and if
                // open file length is gerater than
                // column with, Open File string cut from right
                // by COL_WIDTH_OPEN_FILE-5 and "..." will be
                // inserted before the string.
                // Example o/p:  ...notepad.exe
                szCHString = pFileInfo->afpfile_path ;

                 if( FALSE == bVerbose)
                {
                    if((szCHString.GetLength()>(COL_WIDTH_OPEN_FILE-5))&&
                        ( SR_FORMAT_TABLE == dwFormat))
                    {
                        // If file path is too big to fit in column width
                        // then it is cut like..
                        // c:\...\rest_of_the_path.
                        CHString szTemp = 
                                    szCHString.Right(COL_WIDTH_OPEN_FILE-5);
                        DWORD dwTemp = szTemp.GetLength();
                        szTemp = szTemp.Mid(szTemp.Find(SINGLE_SLASH),
                                           dwTemp);
                        szCHString.Format(L"%s%s%s",szCHString.Mid(0,3),
                                                    DOT_DOT,
                                                    szTemp);
                        pMainCols[6].dwWidth = COL_WIDTH_OPEN_FILE+1;
                    }
                }
                else
                {

                    pMainCols[6].dwWidth = 80;
                }

               // Open File name
                DynArrayAppendString2(pColData,dwRow,
                                   (LPCWSTR)szCHString,0);

                bAtLeastOne = TRUE;
                dwRow++;
            }// Enf for loop
        }
        // Free the block
        if( NULL != pFileInfoOrg )
        {
            AfpAdminBufferFree( pFileInfoOrg );
            pFileInfo    = NULL;
        }

    } while ( ERROR_MORE_DATA  == dwError);

    // if not a single open file found, show info
    // as -  INFO: No open file found.
    if( FALSE == bAtLeastOne)
    {
        ShowMessage(stdout,GetResString(IDS_NO_OPENFILES));
    }
    else
    {

        //Output should start after one blank line
        if( SR_FORMAT_CSV != dwFormat)
        {
            ShowMessage(stdout,BLANK_LINE);
        }

        if( TRUE == bShowNoHeader)
        {
              dwFormat |=SR_NOHEADER;
        }
        
        ShowResults(MAX_OUTPUT_COLUMN,pMainCols,dwFormat,pColData);
        // Destroy dynamic array.
        SAFERELDYNARRAY(pColData);

    }
    SAFEDELETE(pszServerNameToShow);
    SAFEDELETE(pszServerType);
    SAFERELDYNARRAY(pColData);
    SAFEDELETE(pszTemp);
    FREE_LIBRARY(hModule);

    return TRUE;
}

BOOL 
GetHostName(
    IN OUT PTCHAR pszServer
    )
/*++
Routine Description:
    This routine gets Hostname of remote computer

Arguments:
     [in/out] pszServer   = ServerName
Return Value:
      TRUE : if server name retured successfully
      FALSE: otherwise
--*/
{
    if(NULL == pszServer )
    {
        return FALSE;
    }
    BOOL bReturnValue = TRUE; // function return state.

    WORD wVersionRequested; //Variable used to store highest version
                            //number that Windows Sockets can support.
                            // The high-order byte specifies the minor
                            // version (revision) number; the low-order
                            // byte specifies the major version number
    WSADATA wsaData;//Variable receive details of the Windows Sockets
                    //implementation
    DWORD dwErr; // strore error code
    wVersionRequested = MAKEWORD( 2, 2 );

    //WSAStartup function initiates use of
    //Ws2_32.dll by a process
    dwErr = WSAStartup( wVersionRequested, &wsaData );
    if( 0 != dwErr)
    {
        SetLastError(WSAGetLastError());
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
        ShowLastError(stderr);
        return FALSE;
    }
    if(IsValidIPAddress(pszServer))
    {
        LPTSTR pszTemp = NULL;
        
        // gethostbyaddr function retrieves the host information
        //corresponding to a network address.
        pszTemp = GetHostByAddr(pszServer);
        if( NULL != pszTemp)
        {
            StringCopy(pszServer,pszTemp,MIN_MEMORY_REQUIRED);
            SAFEDELETE(pszTemp);
        }
        else
        {
            SetLastError(WSAGetLastError());
            ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
        }
    }
    // Check  validity for the server name
    else if (IsValidServer(pszServer))
    {

        LPTSTR pszTemp = NULL;
        pszTemp =  GetHostByName(pszServer);
        if( NULL != pszTemp)
        {
            StringCopy(pszServer, pszTemp,MIN_MEMORY_REQUIRED);
            SAFEDELETE(pszTemp);
        }
        else
        {
            SetLastError(WSAGetLastError());
            ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR));
            ShowLastError(stderr);
        }
    }
    else
    {
       // server name is incorrect, show error message.
        ShowMessage(stderr,GetResString(IDS_ID_SHOW_ERROR ));
        ShowMessage(stderr,GetResString(IDS_INVALID_SERVER_NAME));
    }
    //WSACleanup function terminates use of the Ws2_32.dll.
    WSACleanup( );
    return bReturnValue;
}

LPTSTR
GetHostByName(
    IN LPCTSTR pszName
    )
/*++
Routine Description:

    Get host information corresponding to a hostname.

Arguments:

    [in ]pszName - A pointer to the null terminated name of the host.

Returns:
     returns hostname.
--*/
{
    LPTSTR pszReturn = NULL;

    pszReturn = new TCHAR[RNR_BUFFER_SIZE];
    if(NULL == pszReturn)
    {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    SecureZeroMemory(pszReturn,RNR_BUFFER_SIZE * sizeof(TCHAR));
    if(GetXYDataEnt( RNR_BUFFER_SIZE,
                          (LPTSTR)pszName,
                          &HostnameGuid,
                          pszReturn))
    {
        return pszReturn;

    }
    else
        return NULL;

}  

LPTSTR
GetHostByAddr(
    IN LPCTSTR pszAddress
    )
/*++
Routine Description:

  Get host information corresponding to an address.

Arguments:

    [in]pszAddress - A pointer to an address in network byte order.
Returns:
    returns Hostname
--*/
{
    LPTSTR pszReturn = NULL;
    pszReturn = new TCHAR[RNR_BUFFER_SIZE];

    if(NULL == pszReturn)
    {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    SecureZeroMemory(pszReturn,RNR_BUFFER_SIZE * sizeof(TCHAR));
    if(GetXYDataEnt(RNR_BUFFER_SIZE,
                         (LPTSTR)pszAddress,
                         &AddressGuid,
                         pszReturn))
    {
        return pszReturn;
    }
    else
        return NULL;
}  

LPBLOB
GetXYDataEnt(
    IN  DWORD dwLength,
    IN  LPTSTR pszName,
    IN  LPGUID lpType,
    OUT LPTSTR pszHostName
    )
/*++
Routine Description:
    This function will query system for given GUID.
Arguments:

    [in]    dwLength       : length.
    [in]    pszName        : Hostname (hostname/ipaddress).
    [in]    lpType         : GUID of the class.
    [out]   pszHostName    : Hostname which is returned by query.

Return Value:
    LPBLOB
--*/
{

    WSAQUERYSET *pwsaq = (WSAQUERYSET*)new TCHAR[RNR_BUFFER_SIZE];
    int err;
    HANDLE hRnR;
    LPBLOB pvRet = 0;

    if(NULL == pwsaq)
    {
        return NULL;
    }

    SecureZeroMemory(pwsaq,RNR_BUFFER_SIZE * sizeof(TCHAR));
    pwsaq->dwSize = sizeof(WSAQUERYSET);
    pwsaq->lpszServiceInstanceName = pszName;
    pwsaq->lpServiceClassId = lpType;
    pwsaq->dwNameSpace = NS_ALL;
    pwsaq->dwNumberOfProtocols = 2;
    pwsaq->lpafpProtocols = &afp[0];

    err = WSALookupServiceBegin( pwsaq,
                                 LUP_RETURN_BLOB | LUP_RETURN_NAME,
                                 &hRnR);

    if( NO_ERROR == err)
    {
        //
        // The query was accepted, so execute it via the Next call.
        //
        err = WSALookupServiceNext(
                                hRnR,
                                0,
                                &dwLength,
                                pwsaq);
        //
        // if NO_ERROR was returned and a BLOB is present, this
        // worked, just return the requested information. Otherwise,
        // invent an error or capture the transmitted one.
        //

        if( NO_ERROR == err)
        {
            if(pvRet = pwsaq->lpBlob)
            {
                if(pszHostName)
                {
                    StringCopy(pszHostName, pwsaq->lpszServiceInstanceName,
                               MIN_MEMORY_REQUIRED);
                }
            }
            else
            {
                err = WSANO_DATA;
            }
        }
        else
        {
            //
            // WSALookupServiceEnd clobbers LastError so save
            // it before closing the handle.
            //

            err = GetLastError();
        }
        WSALookupServiceEnd(hRnR);

        //
        // if an error happened, stash the value in LastError
        //

        if(NO_ERROR != err)
        {
            SetLastError(err);
        }
    }
    SAFEDELETE(pwsaq);
    return(pvRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\openfiles\resource.h ===
#define IDS_HELP_LINE1                  1
#define IDS_HELP_LINE2                  2
#define IDS_HELP_LINE3                  3
#define IDS_HELP_LINE4                  4
#define IDS_HELP_LINE5                  5
#define IDS_HELP_LINE6                  6
#define IDS_HELP_LINE7                  7
#define IDS_HELP_LINE8                  8
#define IDS_HELP_LINE9                  9
#define IDS_HELP_LINE10                 10
#define IDS_HELP_LINE11                 11
#define IDS_HELP_LINE12                 12
#define IDS_HELP_LINE13                 13
#define IDS_HELP_LINE14                 14
#define IDS_HELP_LINE15                 15
#define IDS_HELP_LINE16                 16
#define IDS_HELP_LINE17                 17
#define IDS_HELP_LINE18                 18
#define IDS_HELP_LINE19                 19
#define IDS_HELP_LINE20                 20
#define IDS_HELP_LINE21                 21
#define IDS_HELP_LINE22                 22
#define IDS_HELP_LINE23                 23
#define IDS_HELP_LINE24                 24
#define IDS_HELP_LINE25                 25
#define IDS_HELP_LINE26                 26
#define IDS_HELP_LINE27                 27
#define IDS_HELP_LINE28                 28
#define IDS_HELP_LINE29                 29
#define IDS_HELP_LINE30                 30
#define IDS_HELP_LINE31                 31
#define IDS_HELP_LINE32                 32
#define IDS_HELP_LINE33                 33
#define IDS_HELP_LINE34                 34
#define IDS_HELP_LINE35                 35
#define IDS_HELP_LINE36                 36
#define IDS_HELP_LINE_END               37

#define IDS_FAILURE                         60
#define IDS_SUCCESS                         61
#define IDS_SUCCESS_DISCONNECT              62
#define IDS_ERROR_DISCONNECT                64
#define IDS_ERROR_USERNAME_BUT_NOMACHINE    66
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME   67
#define IDS_STRING_HOSTNAME                 68
#define IDS_STRING_ID                       69
#define IDS_STRING_ACCESSED_BY              71
#define IDS_STRING_TYPE                     72
#define IDS_STRING_LOCK                     73
#define IDS_STRING_OPEN_MODE                74
#define IDS_STRING_OPEN_FILE                75
#define IDS_STRING_WINDOWS                  76
#define IDS_READ                            78
#define IDS_WRITE                           79
#define IDS_READ_WRITE                      80
#define IDS_NO_OPENFILES                    81
#define IDS_FORMAT_OPTIONS                  82
#define IDS_STRING_PID                      83

#define IDS_HELP_MAIN1                  100
#define IDS_HELP_MAIN2                  101
#define IDS_HELP_MAIN3                  102
#define IDS_HELP_MAIN4                  103
#define IDS_HELP_MAIN5                  104
#define IDS_HELP_MAIN6                  105
#define IDS_HELP_MAIN7                  106
#define IDS_HELP_MAIN8                  107
#define IDS_HELP_MAIN9                  108
#define IDS_HELP_MAIN10                 109
#define IDS_HELP_MAIN11                 110
#define IDS_HELP_MAIN12                 111
#define IDS_HELP_MAIN13                 112
#define IDS_HELP_MAIN_END               113

#define IDS_HELP_QUERY1                 121
#define IDS_HELP_QUERY2                 122
#define IDS_HELP_QUERY3                 123
#define IDS_HELP_QUERY4                 124
#define IDS_HELP_QUERY5                 125
#define IDS_HELP_QUERY6                 126
#define IDS_HELP_QUERY7                 127
#define IDS_HELP_QUERY8                 128
#define IDS_HELP_QUERY9                 129
#define IDS_HELP_QUERY10                130
#define IDS_HELP_QUERY11                131
#define IDS_HELP_QUERY12                132
#define IDS_HELP_QUERY13                133
#define IDS_HELP_QUERY14                134
#define IDS_HELP_QUERY15                135
#define IDS_HELP_QUERY16                136
#define IDS_HELP_QUERY17                137
#define IDS_HELP_QUERY18                138
#define IDS_HELP_QUERY19                139
#define IDS_HELP_QUERY20                140
#define IDS_HELP_QUERY21                141
#define IDS_HELP_QUERY22                142
#define IDS_HELP_QUERY23                143
#define IDS_HELP_QUERY24                144
#define IDS_HELP_QUERY25                145
#define IDS_HELP_QUERY_END              146

#define IDS_LIST                        150
#define IDS_CSV                         151
#define IDS_NO_ID_ACC_OF                152
#define IDS_NOACCESS                    153
#define IDS_ERROR_ID                    155
#define IDS_ID_SHOW_ERROR               156
#define IDS_INTERNAL_FAILURE            157
#define IDS_INVALID_CREDENTIALS         159
#define IDS_OPENMODE_OPTION             160
#define IDS_INVALID_SYNTAX              161
#define IDS_AUTHENTICATION_FAILURE      162
#define IDS_INVALID_SERVER_NAME         164
#define IDS_HEADER_NOT_ALLOWED          165
#define IDS_LOCAL_SYSTEM                166
#define IDS_NA                          167
#define IDS_SERVER_EMPTY                168
#define IDS_ID_SHOW_WARNING             169
#define IDS_USERNAME_EMPTY              170
#define IDS_INVALID_OS                  171
#define IDS_MAC_OS                      172
#define IDS_READ_SLASH_WRITE            173
#define IDS_WRITE_SLASH_READ            174
#define IDS_DOT_EOL                     175
#define IDS_NO_D_OPENFILES              176
#define IDS_ACCESSBY_EMPTY              177
#define IDS_OPEN_FILE_EMPTY             178
#define IDS_TYPE_Q_HELP                 179
#define IDS_TYPE_D_HELP                 180
#define IDS_LOCAL_OPEN_FILES            183
#define IDS_SHARED_OPEN_FILES           184
#define IDS_STRING_PROCESS_ID           186
#define IDS_STRING_PROCESS_NAME         187
#define IDS_WARN_NO_LOCAL_FILE          188
#define IDS_LOCAL_OPEN_FILES_SP1        189
#define IDS_LOCAL_OPEN_FILES_SP2        190
#define IDS_UTILITY_NAME                191
#define IDS_ERROR_SYSTEM_INFO           192
#define IDS_ERROR_VERSION_MISMATCH      193
#define IDS_REMOTE_NOT_SUPPORTED        194
#define IDS_ERROR_VERSION_MISMATCH1     195
#define IDS_REMOTE_NOT_SUPPORTED1       196
#define IDS_FILE_TYPE                   197
#define IDS_LOCAL_FLG_SET               228
#define IDS_LOCAL_FLG_RESET             229
#define IDS_LOCAL_ON                    230
#define IDS_LOCAL_OFF                   231
#define IDS_LOCAL_OPTION                232
#define IDS_LOCAL_FLG_ALREADY_RESET     233
#define IDS_LOCAL_FLG_ALREADY_SET       234
#define IDS_USER_NOT_ADMIN              235
#define IDS_LOCAL_NEEDS_TO_SET1         236
#define IDS_LOCAL_NEEDS_TO_SET2         237
#define IDS_LOCAL_NEEDS_TO_SET3         238
#define IDS_USER_INVALID_ADMIN          239
#define IDS_FILENAME_INVALID            240

#define IDS_HELP_LOCAL1                 250
#define IDS_HELP_LOCAL2                 251
#define IDS_HELP_LOCAL3                 252
#define IDS_HELP_LOCAL4                 253
#define IDS_HELP_LOCAL5                 254
#define IDS_HELP_LOCAL6                 255
#define IDS_HELP_LOCAL7                 256
#define IDS_HELP_LOCAL8                 257
#define IDS_HELP_LOCAL9                 258
#define IDS_HELP_LOCAL10                259
#define IDS_HELP_LOCAL11                260
#define IDS_HELP_LOCAL12                261
#define IDS_HELP_LOCAL13                262
#define IDS_HELP_LOCAL_END              263
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\print\print.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

        print.cxx

Abstract:


Author:

        Jaime F. Sasson - jaimes - 14-Jun-1991

Environment:

        ULIB, User Mode

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "system.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "smsg.hxx"
#include "stream.hxx"
#include "rtmsg.h"
#include "prtstrm.hxx"
#include "file.hxx"
#include "print.hxx"

extern "C" {
#include <stdio.h>
#include <string.h>
}

PSTREAM Get_Standard_Input_Stream();
PSTREAM Get_Standard_Output_Stream();

DEFINE_CONSTRUCTOR( PRINT, PROGRAM );


BOOLEAN
PRINT::Initialize(
        )

/*++

Routine Description:

        Initializes a PRINT class.

Arguments:

        None.

Return Value:

        BOOLEAN - Indicates if the initialization succeeded.


--*/


{
        ARGUMENT_LEXEMIZER      ArgLex;
        ARRAY                           LexArray;

        ARRAY                           ArgumentArray;
        FLAG_ARGUMENT           FlagDisplayHelp;

        STRING_ARGUMENT         ProgramNameArgument;
        PWSTRING                        InvalidArgument;

        PATH_ARGUMENT           DeviceArgument;
        PPATH                           DevicePath;
        PCWSTRING                       DeviceString;
        PPATH                           FilePath;
        PCWSTRING                       FileString;
        PARRAY                          PathArray;
        PARRAY_ITERATOR         PathArrayIterator;
        PFSN_FILE                       FsnFile;


        _StandardOutput = Get_Standard_Output_Stream();

        if (_StandardOutput == NULL) {
            DebugPrint("PRINT: Out of memory\n");
            return FALSE;
        }

        //
        // Initialize MESSAGE class
        //
        _Message.Initialize( _StandardOutput, Get_Standard_Input_Stream() );

        //
        //      Parse command line
        //
        if ( !LexArray.Initialize() ) {
                DebugAbort( "LexArray.Initialize() failed \n" );
                return( FALSE );
    }
        if ( !ArgLex.Initialize( &LexArray ) ) {
                DebugAbort( "ArgLex.Initialize() failed \n" );
                return( FALSE );
    }
        ArgLex.PutSwitches( "/" );
        ArgLex.SetCaseSensitive( FALSE );
        ArgLex.PutStartQuotes( "\"" );
        ArgLex.PutEndQuotes( "\"" );

        if( !ArgLex.PrepareToParse() ) {
                DebugAbort( "ArgLex.PrepareToParse() failed \n" );
                return( FALSE );
        }
        if ( !ArgumentArray.Initialize() ) {
                DebugAbort( "ArgumentArray.Initialize() failed \n" );
                return( FALSE );
        }
        if( !ProgramNameArgument.Initialize("*") ||
                !DeviceArgument.Initialize( "/D:*" ) ||
                !_BufferSize.Initialize( "/B:*" ) ||
                !_Ticks1.Initialize( "/U:*" ) ||
                !_Ticks2.Initialize( "/M:*" ) ||
                !_Ticks3.Initialize( "/S:*" ) ||
                !_NumberOfFiles.Initialize( "/Q:*" ) ||
                !_FlagRemoveFiles.Initialize( "/T" ) ||
                !_Files.Initialize( "*", FALSE, TRUE ) ||
                !_FlagCancelPrinting.Initialize( "/C" ) ||
                !_FlagAddFiles.Initialize( "/P" ) ||
                !FlagDisplayHelp.Initialize( "/?" ) ) {
                DebugAbort( "Unable to initialize flag or string arguments \n" );
                return( FALSE );
        }
        if( !ArgumentArray.Put( &ProgramNameArgument ) ||
                !ArgumentArray.Put( &DeviceArgument ) ||
                !ArgumentArray.Put( &_BufferSize ) ||
                !ArgumentArray.Put( &_Ticks1 ) ||
                !ArgumentArray.Put( &_Ticks2 ) ||
                !ArgumentArray.Put( &_Ticks3 ) ||
                !ArgumentArray.Put( &_NumberOfFiles ) ||
                !ArgumentArray.Put( &_FlagRemoveFiles ) ||
                !ArgumentArray.Put( &_Files ) ||
                !ArgumentArray.Put( &_FlagCancelPrinting ) ||
                !ArgumentArray.Put( &_FlagAddFiles ) ||
                !ArgumentArray.Put( &FlagDisplayHelp ) ) {
                DebugAbort( "ArgumentArray.Put() failed \n" );
                return( FALSE );
        }
        if( !ArgLex.DoParsing( &ArgumentArray ) ) {
                InvalidArgument = ArgLex.QueryInvalidArgument();
                DebugPtrAssert( InvalidArgument );
                _Message.Set( MSG_PRINT_INVALID_SWITCH );
                _Message.Display( "%W", InvalidArgument );
                return( FALSE );
        }

        //
        //      /B: /U: /M: /S: /Q: /T: /C: and /P: are not implemented
        //      if one of these arguments was found in the command line
        //      then inform user, and don't print anything
        //
        if( _BufferSize.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/B:" );
                return( FALSE );
        }
        if( _Ticks1.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/U:" );
                return( FALSE );
        }
        if( _Ticks2.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/M:" );
                return( FALSE );
        }
        if( _Ticks3.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/S:" );
                return( FALSE );
        }
        if( _NumberOfFiles.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/Q:" );
                return( FALSE );
        }
        if( _FlagRemoveFiles.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/T:" );
                return( FALSE );
        }
        if( _FlagCancelPrinting.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/C:" );
                return( FALSE );
        }
        if( _FlagAddFiles.IsValueSet() ) {
                _Message.Set( MSG_PRINT_NOT_IMPLEMENTED );
                _Message.Display( "%s", "/P:" );
                return( FALSE );
        }

        //
        //      Displays help message if /? was found in the command line
        //
        if( FlagDisplayHelp.QueryFlag() ) {
                _Message.Set( MSG_PRINT_HELP_MESSAGE );
                _Message.Display( " " );
                return( FALSE );
        }

        //
        //      If no filename was specified, display error message
        //
        if( _Files.QueryPathCount() == 0 ) {
                _Message.Set( MSG_PRINT_NO_FILE );
                _Message.Display( " " );
                return( FALSE );
        }

        //
        // Get device name if one exists. Otherwise use PRN as default
        //
        if( !DeviceArgument.IsValueSet() ) {
                DevicePath = NEW( PATH );
                DebugPtrAssert( DevicePath );
        if( !DevicePath->Initialize( (LPWSTR)L"PRN" ) ) {
                        _Message.Set( MSG_PRINT_UNABLE_INIT_DEVICE );
                        _Message.Display( "%s", "PRN" );
                        return( FALSE );
                }
        } else {
                DevicePath = DeviceArgument.GetPath();
                DebugPtrAssert( DevicePath );
        }
        if( !_Printer.Initialize( DevicePath ) ) {
                DeviceString = DevicePath->GetPathString();
                DebugPtrAssert( DeviceString );
                _Message.Set( MSG_PRINT_UNABLE_INIT_DEVICE );
                _Message.Display( "%W", DeviceString );
                if( !DeviceArgument.IsValueSet() ) {
                        DELETE( DevicePath );
                }
                return( FALSE );
        }

        //
        //      Get FSNODE of each file and put them in an array
        //
        PathArray = _Files.GetPathArray();
        DebugPtrAssert( PathArray );
        PathArrayIterator = ( PARRAY_ITERATOR )PathArray->QueryIterator();
        DebugPtrAssert( PathArrayIterator );

        if( !_FsnFileArray.Initialize() ) {
                DebugAbort( "_FsnFileArray.Initialize() failed \n" );
                return( FALSE );
        }
        while( ( FilePath = ( PPATH )PathArrayIterator->GetNext() ) != NULL ) {
                FsnFile = SYSTEM::QueryFile( FilePath );
                if( FsnFile != NULL ) {
                        _FsnFileArray.Put( ( POBJECT )FsnFile );
                } else {
                        FileString = FilePath->GetPathString();
                        _Message.Set( MSG_PRINT_FILE_NOT_FOUND );
                        _Message.Display( "%W", FileString );
                }
        }
        DELETE( PathArrayIterator );
        return( TRUE );
}


BOOLEAN
PRINT::PrintFiles(
        )

/*++

Routine Description:

        Prints the files specified by the user.

Arguments:

        None.

Return Value:

        BOOLEAN - TRUE if all files were printed.


--*/

{
        PFSN_FILE                       FsnFile;
        PSTREAM                         FileStream;
        PARRAY_ITERATOR         ArrayIterator;
        PBYTE                           Buffer;
        ULONG                           Size;
        ULONG                           BytesRead;
        ULONG                           BytesWritten;
        PCPATH                          FilePath;
        PCWSTRING                       FileName;
        INT                             _BufferStreamType;
        INT                             BytesConverted;
        INT                             cbStuff;
        LPSTR                           lpStuffANSI;
        BOOL                            fUsedDefault;


        Size = 512;
        Buffer = ( PBYTE )MALLOC( ( size_t )Size );
        lpStuffANSI = ( LPSTR )MALLOC( ( size_t )Size );
        if (Buffer == NULL || lpStuffANSI == NULL) {
            DebugPrint("PRINT: Out of memory\n");
            return FALSE;
        }
        ArrayIterator = ( PARRAY_ITERATOR )_FsnFileArray.QueryIterator();
        if (ArrayIterator == NULL) {
            DebugPrint("PRINT: ArrayIterator equals NULL\n");
            return FALSE;
        }
        while( ( FsnFile = ( PFSN_FILE )ArrayIterator->GetNext() ) != NULL ) {
                FileStream = ( PSTREAM )FsnFile->QueryStream( READ_ACCESS );
                if (FileStream == NULL) {
                    DebugPrint("PRINT: FileStream equals NULL\n");
                    return FALSE;
                }

                FileName = FsnFile->GetPath()->GetPathString();
                if( FileName != NULL ) {
                    _Message.Set( MSG_PRINT_PRINTING );
                    _Message.Display( "%W", FileName );
                }

                _BufferStreamType = -1;
                while( !FileStream->IsAtEnd() ) {
                        FileStream->Read( Buffer, Size, &BytesRead );
                        // is file unicode?
                        if (_BufferStreamType < 0) {
                           if (IsTextUnicode((LPTSTR)Buffer, (INT)BytesRead,
                            NULL) ) {
                              _BufferStreamType = 1;
                           } else {
                              _BufferStreamType = 0;
                           }
                        }
                        // does the buffer need to be converted?
                        if (_BufferStreamType == 1) {

                           cbStuff = Size;
                           BytesConverted = WideCharToMultiByte(CP_ACP,0,
                                   (LPTSTR)Buffer,BytesRead/sizeof(WCHAR),
                                   lpStuffANSI,cbStuff,NULL,&fUsedDefault) ;
                           DebugAssert(cbStuff>0);
                           DebugAssert(BytesConverted >= 0);
                           _Printer.Write((PBYTE)lpStuffANSI,BytesConverted,&BytesWritten );
                        } else {
                           _Printer.Write( Buffer, BytesRead, &BytesWritten );
                        }
                }
                _Printer.WriteByte( '\f' );
                DELETE( FileStream );
        }
        DELETE( ArrayIterator );
        return( TRUE );
}




BOOL
PRINT::Terminate(
        )

/*++

Routine Description:

        Deletes objects created during initialization.

Arguments:

        None.

Return Value:

        None.


--*/

{
        return( TRUE );
}





ULONG __cdecl
main()

{
        DEFINE_CLASS_DESCRIPTOR( PRINT );


        {

                PRINT   Print;


                if( Print.Initialize() ) {
                        Print.PrintFiles();
                }
        //      Print.Terminate();
                return( 0 );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\pentbug\pentnt.c ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    pentnt.c

Abstract:

    This module contains a simple program to detect the Pentium FPU
    FDIV precision error, and offers to force floating point emulation
    on if the bug is present.

Author:

    Bryan M. Willman (bryanwi) 7-Dec-1994

Revision History:

--*/

#define         UNICODE
#include        <stdio.h>
#include        <time.h>
#include        <stdlib.h>
#include        <string.h>
#include        <fcntl.h>
#include        <io.h>
#include        <windows.h>
#include        <winnlsp.h>
#include        <ctype.h>
#include        <assert.h>
#include        <locale.h>

#include        <stdarg.h>
#include        "pbmsg.h"

VOID
OutputMessage(
    LPWSTR Message
    )
{
    DWORD       dwBytesWritten;
    DWORD       fdwMode;
    HANDLE      outHandle = GetStdHandle( STD_OUTPUT_HANDLE );    
    
    //
    //  If we have a char mode output handle and that handle
    //  looks like a console handle, then use unicode
    //  output
    //
    
    if (( GetFileType( outHandle ) & FILE_TYPE_CHAR ) != 0 
        && GetConsoleMode( outHandle, &fdwMode )) {
    
        WriteConsole( outHandle, 
                      Message, 
                      wcslen( Message ), 
                      &dwBytesWritten, 
                      0 );
    
    } else {
    
        //
        //  Output device can't handle Unicode.  The best we can do is
        //  convert to multibyte byte strings and just write it out.
        //  Yes, some codepoints won't make it out, but the convention
        //  is that file output is MBCS
        //
        
        int charCount = 
            WideCharToMultiByte( GetConsoleOutputCP( ), 
                                 0, 
                                 Message, 
                                 -1, 
                                 0, 
                                 0, 
                                 0, 
                                 0 );

        PCHAR szaStr = (PCHAR) malloc( charCount );
    
        if (szaStr != NULL) {
            WideCharToMultiByte( GetConsoleOutputCP( ), 0, Message, -1, szaStr, charCount, 0, 0);

            WriteFile( outHandle, szaStr, charCount - 1, &dwBytesWritten, 0 );

            free( szaStr );     
        }
    }
}

void    SetForceNpxEmulation(ULONG setting);
void    TestForDivideError();
void    ScanArgs(int argc, char **argv);
void    GetSystemState();
void    printmessage (DWORD messageID, ...);
int     ms_p5_test_fdiv(void);

//
// Core control state vars
//
BOOLEAN     NeedHelp;

BOOLEAN     Force;
ULONG       ForceValue;

BOOLEAN     FDivError;

BOOLEAN     NTOK;

ULONG       CurrentForceValue;

ULONG       FloatHardware;

//
// ForceValue and CurrentForceValue
//
#define     FORCE_OFF         0   // User wants emulation turned off
#define     FORCE_CONDITIONAL 1   // User wants emulation iff we detect bad pentium
#define     FORCE_ALWAYS      2   // User wants emulation regardless

//
// hardware fp status
//
#define     FLOAT_NONE      0   // No fp hardware
#define     FLOAT_ON        1   // Fp hardware is present and active
#define     FLOAT_OFF       2   // Fp hardware is present and disabled

void
__cdecl
main(
    int argc,
    char **argv
    )
/*++

Routine Description:

    Main procedure for pentnt.

    First, we call a series of routines that build a state vector
    in some booleans.

    We'll then act on these control variables:

        NeedHelp -  User has asked for help, or made a command error

        Force    -  True if user has asked to change a force setting
        ForceValue - Has no meaning if Force is FALSE.  Else says
                     what the user wants us to do.

        FloatHardware - Indicates if there is any and whether it's on

        NTOK         - Indicates if first OS version with fix is what
                        we are running

        FdivError - if TRUE, FP gives WRONG answer, else, gives right answer
        CurrentForceValue - what the current force setting is

    All of these will be set before we do any work.

Arguments:

    argc - count of arguments, including the name of our proggram

    argv - argument list - see command line syntax above

Return Value:

    Exit(0) - nothing changed, and current state is OK

    Exit(1) - either a state change was requested, or just help,
                or the current state may have a problem.

    Exit(2) - we hit something really weird....


--*/
{
    //
    // build up state vector in global booleans
    //
    ScanArgs(argc, argv);
    GetSystemState();
    TestForDivideError();

    /*
    printf("NeedHelp = %d  Force = %d  ForceValue = %d\n",
            NeedHelp, Force, ForceValue);
    printf("FDivError = %d  NTOK = %d  CurrentForceValue = %d  FloatHardware = %d\n",
            FDivError, NTOK, CurrentForceValue, FloatHardware);
    */

    //
    //  Set up for language mapping stuff so the correct messages get output.
    //
    
    SetThreadUILanguage(0);
    setlocale( LC_ALL, ".OCP" ) ;

    //
    // ok, we know the state of the command and the machine, do work
    //

    //
    // if they asked for help, or did something that indicates they don't
    // understand how the program works, print help and exit.
    //
    if (NeedHelp) {
        printmessage(MSG_PENTBUG_HELP);
        exit(1);
    }

    //
    // never do anything if there's no floating point hardware in the box
    //
    if (FloatHardware == FLOAT_NONE) {
        printmessage(MSG_PENTBUG_NO_FLOAT_HARDWARE);
        exit(0);
    }

    //
    // never do anything if it's the wrong version of NT.
    //
    if (!NTOK) {
        printmessage(MSG_PENTBUG_NEED_NTOK);
        exit(1);
    }

    assert(NTOK == TRUE);
    assert(NeedHelp == FALSE);
    assert((FloatHardware == FLOAT_ON) || (FloatHardware == FLOAT_OFF));

    if (Force) {

        switch (ForceValue) {

        case FORCE_OFF:

            if (CurrentForceValue == FORCE_OFF) {

                if (FloatHardware == FLOAT_ON) {
                    //
                    // user wants fp on, fp is on, fp set to be on
                    // all is as it should be
                    //
                    printmessage(MSG_PENTBUG_IS_OFF_OK);
                    exit(FDivError);
                }

                if (FloatHardware == FLOAT_OFF) {
                    //
                    // user need to reboot to finish turning emulation off
                    //
                    printmessage(MSG_PENTBUG_IS_OFF_REBOOT);
                    exit(1);
                }

            } else {
                //
                // they want it off, it's not off, so turn it off
                // remind them to reboot
                //
                SetForceNpxEmulation(FORCE_OFF);
                printmessage(MSG_PENTBUG_TURNED_OFF);
                printmessage(MSG_PENTBUG_REBOOT);
                exit(1);
            }
            break;

        case FORCE_CONDITIONAL:

            if (CurrentForceValue == FORCE_CONDITIONAL) {

                if (FDivError) {
                    //
                    // tell them to reboot
                    //
                    printmessage(MSG_PENTBUG_IS_ON_COND_REBOOT);
                    exit(1);
                } else {
                    //
                    // tell them to be happy
                    //
                    printmessage(MSG_PENTBUG_IS_ON_COND_OK);
                    exit(0);
                }

            } else {
                //
                // set it to what they want and tell them to reboot
                //
                SetForceNpxEmulation(ForceValue);
                printmessage(MSG_PENTBUG_TURNED_ON_CONDITIONAL);
                printmessage(MSG_PENTBUG_REBOOT);
                exit(1);
            }
            break;

        case FORCE_ALWAYS:

            if (CurrentForceValue == FORCE_ALWAYS) {

                if (FloatHardware == FLOAT_OFF) {
                    //
                    // tell them to be happy
                    //
                    printmessage(MSG_PENTBUG_IS_ON_ALWAYS_OK);
                    exit(0);
                } else {
                    //
                    // tell them to reboot to finish
                    //
                    printmessage(MSG_PENTBUG_IS_ON_ALWAYS_REBOOT);
                    exit(1);
                }

            } else {
                SetForceNpxEmulation(ForceValue);
                printmessage(MSG_PENTBUG_TURNED_ON_ALWAYS);
                printmessage(MSG_PENTBUG_REBOOT);
                exit(1);
            }
            break;

        default:
            printf("pentnt: INTERNAL ERROR\n");
            exit(2);

        } // switch
    }



    //
    // no action requested, just report state and give advice
    //
    assert(Force == FALSE);

    if (!FDivError) {

        if (FloatHardware == FLOAT_ON) {
            printmessage(MSG_PENTBUG_FLOAT_WORKS);
        } else {
            printmessage(MSG_PENTBUG_EMULATION_ON_AND_WORKS);
        }
        exit(0);
    }

    //
    // since we're here, we have an fdiv error, tell user what to do about it
    //
    assert(FDivError);

    printmessage(MSG_PENTBUG_FDIV_ERROR);

    if ((CurrentForceValue == FORCE_CONDITIONAL) ||
        (CurrentForceValue == FORCE_ALWAYS))
    {
        printmessage(MSG_PENTBUG_IS_ON_REBOOT);
        exit(1);
    }

    printmessage(MSG_PENTBUG_CRITICAL_WORK);
    exit(1);

    assert((TRUE==FALSE));
}

VOID
SetForceNpxEmulation(
    ULONG   Setting
    )
/*++

Routine Description:

    SetForceNpxEmulation will simply set the ForceNpxEmulation value
    entry under the Session Manager key to the value passed in.
    0 = off
    1 = conditional
    2 = always

    If the set attempt fails, exit with a message.

--*/
{
    HKEY    hkey;
    LONG    rc;

    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
            0,
            KEY_WRITE,
            &hkey
            );

    if (rc != ERROR_SUCCESS) {
        printmessage(MSG_PENTBUG_SET_FAILED, rc);
        exit(2);
    }

    rc = RegSetValueEx(
            hkey,
            TEXT("ForceNpxEmulation"),
            0,
            REG_DWORD,
            (unsigned char *)&Setting,
            sizeof(ULONG)
            );

    if (rc != ERROR_SUCCESS) {
        printmessage(MSG_PENTBUG_SET_FAILED, rc);
        exit(2);
    }

    return;
}

VOID
ScanArgs(
    int     argc,
    char    **argv
    )
/*++

Routine Description:

    ScanArgs - parse command line arguments, and set control flags
                to reflect what we find.

    Sets NeedHelp, Force, ForceValue.

Arguments:

    argc - count of command line args

    argv - argument vector

Return Value:

--*/
{
    int i;

    Force = FALSE;
    NeedHelp = FALSE;

    for (i = 1; i < argc; i++) {
        if ( ! ((argv[i][0] == '-') ||
                (argv[i][0] == '/')) )
        {
            NeedHelp = TRUE;
            goto done;
        }

        switch (argv[i][1]) {

        case '?':
        case 'h':
        case 'H':
            NeedHelp = TRUE;
            break;

        case 'c':
        case 'C':
            if (Force) {
                NeedHelp = TRUE;
            } else {
                Force = TRUE;
                ForceValue = FORCE_CONDITIONAL;
            }
            break;

        case 'f':
        case 'F':
            if (Force) {
                NeedHelp = TRUE;
            } else {
                Force = TRUE;
                ForceValue = FORCE_ALWAYS;
            }
            break;

        case 'o':
        case 'O':
            if (Force) {
                NeedHelp = TRUE;
            } else {
                Force = TRUE;
                ForceValue = FORCE_OFF;
            }
            break;

        default:
            NeedHelp = TRUE;
            goto done;
        }
    }

done:
    if (NeedHelp) {
        Force = FALSE;
    }
    return;
}

VOID
GetSystemState(
    )
/*++

Routine Description:

    GetSystemState - get the system version, whether the computer
                     has FP hardware or not, and whether the force
                     emulation switch is already set or not.

    Sets FloatHardware, NTOK, CurrentForceValue

Arguments:

Return Value:

--*/
{
    HKEY    hkey;
    TCHAR   Buffer[32];
    DWORD   BufferSize = 32;
    DWORD   Type;
    int     major;
    int     minor;
    LONG    rc;
    PULONG  p;
    OSVERSIONINFO   OsVersionInfo;

    NTOK = FALSE;

    //
    // decide if the system version is OK.
    //
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx(&OsVersionInfo);

    if (OsVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        printmessage(MSG_PENTBUG_NOT_NT);
        exit(2);
    }

    if ( (OsVersionInfo.dwMajorVersion > 3) ||
         ( (OsVersionInfo.dwMajorVersion == 3) &&
           (OsVersionInfo.dwMinorVersion >= 51)   ))
    {
        //
        // build 3.51 or greater, it has the fix
        //
        NTOK = TRUE;

    } else if ( (OsVersionInfo.dwMajorVersion == 3) &&
                (OsVersionInfo.dwMinorVersion == 50))
    {
        if (OsVersionInfo.szCSDVersion[0] != (TCHAR)'\0') {
            //
            // we have a service pack for 3.5, since pack 1 and
            // later have the fix, it's OK
            //
            NTOK = TRUE;
        }
    }
    /*
    printf("debug NTOK forced true for testing\n\n\n");
    NTOK = TRUE;
    */


    //
    // determine if float hardware is present
    //
    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("Hardware\\Description\\System\\FloatingPointProcessor"),
            0,
            KEY_READ,
            &hkey
            );

    if (rc == ERROR_SUCCESS) {

        FloatHardware = FLOAT_ON;
        RegCloseKey(hkey);

    } else {

        rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("Hardware\\Description\\System\\DisabledFloatingPointProcessor"),
                0,
                KEY_READ,
                &hkey
                );

        if (rc == ERROR_SUCCESS) {

            FloatHardware = FLOAT_OFF;
            RegCloseKey(hkey);

        } else {

            FloatHardware = FLOAT_NONE;

        }
    }

    //
    // determine if emulation has been forced on
    //
    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
            0,
            KEY_READ,
            &hkey
            );

    if (rc != ERROR_SUCCESS) {
        return;
    }

    BufferSize = 32;
    rc = RegQueryValueEx(
            hkey,
            TEXT("ForceNpxEmulation"),
            0,
            &Type,
            (unsigned char *)Buffer,
            &BufferSize
            );

    if (  (rc == ERROR_SUCCESS) &&
          (Type == REG_DWORD)       )
    {
        p = (PULONG)Buffer;
        CurrentForceValue = *p;
    }

    return;
}

//
// these must be globals to make the compiler do the right thing
//

VOID
TestForDivideError(
    )
/*++

Routine Description:

    Do a divide with a known divident/divisor pair, followed by
    a multiply to see if we get the right answer back.

    FDivError = TRUE if we get the WRONG answer, FALSE.
Arguments:

Return Value:


--*/
{
    DWORD   pick;
    HANDLE  ph;
    DWORD   processmask;
    DWORD   systemmask;
    ULONG   i;

    //
    // fetch the affinity mask, which is also effectively a list
    // of processors
    //
    ph = GetCurrentProcess();
    GetProcessAffinityMask(ph, &processmask, &systemmask);

    //
    // step through the mask, testing each cpu.
    // if any is bad, we treat them all as bad
    //
    FDivError = FALSE;
    for (i = 0; i < 32; i++) {
        pick = 1 << i;

        if ((systemmask & pick) != 0) {

            //*//printf("pick = %08lx\n", pick);
            SetThreadAffinityMask(GetCurrentThread(), pick);

            //
            // call the official test function
            //
            if (ms_p5_test_fdiv()) {
                //
                // do NOT just assign func to FDivError, that will reset
                // it if a second cpu is good.  must be one way flag
                //
                FDivError = TRUE;
            }

        } // IF
    } // for
    return;
}

/***
* testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*Purpose:
*   Detects early steppings of Pentium with incorrect FDIV tables using
*   'official' Intel test values. Returns 1 if flawed Pentium is detected,
*   0 otherwise.
*
*/
int ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}


//
// Call FormatMessage and dump the result.  All messages to Stdout
//
void  printmessage (DWORD messageID, ...)
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                  messagebuffer, 4095, &ap);

    OutputMessage( messagebuffer );

    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\recover\recover.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        recover.cxx

Abstract:

        Utility to recover data from a disk

Author:

        Norbert P. Kusters (norbertk) 12-June-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"

#include "arg.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"

#include "system.hxx"
#include "ifssys.hxx"
#include "substrng.hxx"

#include "ulibcl.hxx"
#include "ifsentry.hxx"

int __cdecl
main(
    )
{
    STREAM_MESSAGE  Message;
    DSTRING         FsName;
    DSTRING         LibraryName;
    HANDLE          FsUtilityHandle;
    DSTRING         RecoverString;
    RECOVER_FN      Recover = NULL;

    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    FLAG_ARGUMENT       help_arg;
    PATH_ARGUMENT       path_arg;
    PWSTRING            dosdrive = NULL;
    DSTRING             ntdrive;
    NTSTATUS            Status;
    PPATH               CanonicalPath;
    PWSTRING            DirsAndName;
    PWSTRING            pwstring;

    if (!Message.Initialize(Get_Standard_Output_Stream(),
                            Get_Standard_Input_Stream())) {
        return 1;
    }

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 1;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 1;
    }

    arglex.PutStartQuotes("\"");
    arglex.PutEndQuotes("\"");
    arglex.PutSeparators(" \t");
    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 1;
    }

    if (!progname.Initialize("*") ||
        !help_arg.Initialize("/?") ||
        !path_arg.Initialize("*")) {
        return 1;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&help_arg) ||
        !arg_array.Put(&path_arg)) {
        return 1;
    }

    if (!arglex.DoParsing(&arg_array)) {
        Message.Set(MSG_INVALID_PARAMETER);
        Message.Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        return 1;
    }

    if (help_arg.QueryFlag()) {
        Message.Set(MSG_RECOV_INFO);
        Message.Display("");
        Message.Set(MSG_RECOV_USAGE);
        Message.Display("");
        Message.Set(MSG_RECOV_INFO2);
        Message.Display("");
        return 0;
    }

    if (!path_arg.IsValueSet()) {
        Message.Set(MSG_RECOV_USAGE);
        Message.Display("");
        return 1;
    }

    // Make sure that the user has specified a file name

    DirsAndName = path_arg.GetPath()->QueryDirsAndName();

    if (!DirsAndName || DirsAndName->QueryChCount() == 0) {

        Message.Set(MSG_RECOV_NOT_SUPPORTED);
        Message.Display("");
        DELETE(DirsAndName);
        return 1;
    }

    DELETE(DirsAndName);

    CanonicalPath = path_arg.GetPath()->QueryFullPath();

    dosdrive = CanonicalPath->QueryDevice();


    // Make sure that drive is not remote.

    if (!dosdrive ||
        SYSTEM::QueryDriveType(dosdrive) == RemoteDrive) {
        Message.Set(MSG_RECOV_CANT_NETWORK);
        Message.Display();
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return 1;
    }


    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dosdrive, &ntdrive)) {
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return 1;
    }


    if (!IFS_SYSTEM::QueryFileSystemName(&ntdrive, &FsName, &Status)) {

        if( Status == STATUS_ACCESS_DENIED ) {

            Message.Set( MSG_DASD_ACCESS_DENIED );
            Message.Display( "" );

        } else {

            Message.Set( MSG_FS_NOT_DETERMINED );
            Message.Display( "%W", dosdrive );
        }

        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return 1;
    }

    Message.Set(MSG_FILE_SYSTEM_TYPE);
    Message.Display("%W", &FsName);

    if (!LibraryName.Initialize("U") ||
        !LibraryName.Strcat(&FsName) ||
        !RecoverString.Initialize("Recover")) {

        Message.Set(MSG_FMT_NO_MEMORY);
        Message.Display("");
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return(1);
    }


    if ((Recover = (RECOVER_FN)SYSTEM::QueryLibraryEntryPoint(&LibraryName,
                                                              &RecoverString,
                                                              &FsUtilityHandle))
                != NULL) {

        Recover(CanonicalPath, &Message);

        SYSTEM::FreeLibraryHandle(FsUtilityHandle);

    } else {

        Message.Set(MSG_FS_NOT_SUPPORTED);
        Message.Display("%s%W", "RECOVER", &FsName);
        Message.Set(MSG_BLANK_LINE);
        Message.Display("");
        DELETE(dosdrive);
        DELETE(CanonicalPath);
        return(1);
    }

    DELETE(dosdrive);
    DELETE(CanonicalPath);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\print\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=print
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\print.cxx ..\print.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\recover\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=recover
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\recover.rc ..\recover.cxx

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\copy.c ===
//-----------------------------------------------------------------------//
//
// File:    copy.cpp
// Created: April 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Copy Support for REG.CPP
// Modification History:
//      Copied from Update.cpp and modificd - April 1997 (a-martih)
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

//
// function prototypes
//
LONG CopyValue( HKEY hKey, LPCWSTR pwszValueName,
                HKEY hDestKey, LPCWSTR pwszDestValueName,
                BOOL* pbForce, LPCWSTR pwszSubKey );
LONG CopyEnumerateKey( HKEY hKey, LPCWSTR pwszSubKey,
                       HKEY hDestKey, LPCWSTR pwszDestSubKey,
                       BOOL* pbForce, BOOL bRecurseSubKeys, DWORD dwDepth );
BOOL ParseCopyCmdLine( DWORD argc,
                       LPCWSTR argv[],
                       PTREG_PARAMS pParams,
                       PTREG_PARAMS pDestParams, BOOL* pbUsage );


//
// implementation
//

//-----------------------------------------------------------------------//
//
// CopyRegistry()
//
//-----------------------------------------------------------------------//

LONG
CopyRegistry( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    HKEY hKey = NULL;
    HKEY hDestKey = NULL;
    BOOL bUsage = FALSE;
    BOOL bResult = FALSE;
    DWORD dwDisposition = 0;
    TREG_PARAMS params;
    TREG_PARAMS paramsDest;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_COPY, &params );
    InitGlobalData( REG_COPY, &paramsDest );

    //
    // Parse the cmd-line
    //
    bResult = ParseCopyCmdLine( argc, argv, &params, &paramsDest, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_COPY );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 0;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 1;
    }

    bResult = RegConnectMachine( &paramsDest );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 1;
    }

    // check whether source and destination are different or not
    if ( params.hRootKey == paramsDest.hRootKey &&
         StringCompare( params.pwszFullKey, paramsDest.pwszFullKey, TRUE, 0 ) == 0 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason( ERROR_COPYTOSELF_COPY );
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 1;
    }

    //
    // Now implement the body of the Copy Operation
    //
    lResult = RegOpenKeyEx(
        params.hRootKey, params.pwszSubKey, 0, KEY_READ, &hKey );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 1;
    }

    //
    // Different Key or Different Root or Different Machine
    // So Create/Open it
    //
    lResult = RegCreateKeyEx( paramsDest.hRootKey,paramsDest.pwszSubKey,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hDestKey, &dwDisposition);
    if( lResult != ERROR_SUCCESS )
    {
        SafeCloseKey( &hKey );
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsDest );
        return 1;
    }

    //
    // Recursively copy all subkeys and values
    //
    lResult = CopyEnumerateKey( hKey, params.pwszSubKey,
        hDestKey, params.pwszSubKey, &params.bForce, params.bRecurseSubKeys, 0 );

    //
    // lets clean up
    //
    SafeCloseKey( &hDestKey );
    SafeCloseKey( &hKey );
    FreeGlobalData( &params );
    FreeGlobalData( &paramsDest );

    // return
    return ((lResult == ERROR_SUCCESS) ? 0 : 1);
}


BOOL
ParseCopyCmdLine( DWORD argc, LPCWSTR argv[],
                  PTREG_PARAMS pParams, PTREG_PARAMS pDestParams, BOOL* pbUsage )
{
    // local variables
    DWORD dw = 0;
    BOOL bResult = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL ||
         pParams == NULL || pDestParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if ( argc >= 3 && InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        if ( argc == 3 )
        {
            *pbUsage = TRUE;
            return TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COPY ] );
            return FALSE;
        }
    }
    else if( argc < 4 || argc > 6 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COPY ] );
        return FALSE;
    }
    else if ( StringCompareEx( argv[ 1 ], L"COPY", TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Source Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    //
    // Destination Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 3 ], pDestParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // parsing
    for( dw = 4; dw < argc; dw++ )
    {
        if( StringCompareEx( argv[ dw ], L"/f", TRUE, 0 ) == 0 )
        {
            if ( pParams->bForce == TRUE )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COPY ] );
                return FALSE;
            }

            pParams->bForce = TRUE;
        }
        else if( StringCompare( argv[ dw ], L"/s", TRUE, 0 ) == 0 )
        {
            if ( pParams->bRecurseSubKeys == TRUE )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COPY ] );
                return FALSE;
            }

            pParams->bRecurseSubKeys = TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COPY ] );
            return FALSE;
        }
    }

    return TRUE;
}


//-----------------------------------------------------------------------//
//
// CopyValue()
//
//-----------------------------------------------------------------------//

LONG CopyValue( HKEY hKey, LPCWSTR pwszValueName,
                HKEY hDestKey, LPCWSTR pwszDestValueName,
                BOOL* pbForce, LPCWSTR pwszSubKey )
{
    // local variables
    LONG lResult = 0;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    BYTE* pBuffer = NULL;
    LPCWSTR pwszList = NULL;
    LPCWSTR pwszTemp = NULL;
    LPCWSTR pwszFormat = NULL;

    // check the input
    if ( hKey == NULL || pwszValueName == NULL ||
         hDestKey == NULL || pwszDestValueName == NULL ||
         pbForce == NULL || pwszSubKey == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First find out how much memory to allocate.
    //
    lResult = RegQueryValueEx( hKey, pwszValueName, NULL, &dwType, NULL, &dwSize );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    // allocate memory for getting the value from the registry
    pBuffer = (BYTE*) AllocateMemory( (dwSize + 1) * sizeof(BYTE) );
    if ( pBuffer == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    //
    // Now get the data
    //
    lResult = RegQueryValueEx( hKey, pwszValueName, NULL, &dwType, pBuffer, &dwSize );
    if( lResult != ERROR_SUCCESS )
    {
        FreeMemory( &pBuffer );
        SaveErrorMessage( lResult );
        return lResult;
    }

    //
    // Copy it to the destination
    //
    if ( *pbForce == FALSE )
    {
        //
        // See if it already exists
        //
        lResult = RegQueryValueEx( hDestKey, pwszDestValueName, 0, NULL, NULL, NULL );
        if( lResult == ERROR_SUCCESS )
        {
            //
            // prepare the prompt message
            //
            pwszFormat = GetResString2( IDS_OVERWRITE, 0 );
            pwszList = GetResString2( IDS_CONFIRM_CHOICE_LIST, 1 );
            if ( StringLength( pwszDestValueName, 0 ) == 0 )
            {
                pwszTemp = GetResString2( IDS_NONAME, 2 );
            }
            else
            {
                pwszTemp = pwszDestValueName;
            }

            // we will make use of the reason buffer for formatting
            // the value name along with the sub key
            SetReason2( 2, L"%s\\%s", pwszSubKey, pwszTemp );
            pwszTemp = GetReason();

            do
            {
                lResult = Prompt( pwszFormat, pwszTemp, pwszList, *pbForce );
            } while ( lResult > 3 );

            if ( lResult == 3 )
            {
                *pbForce = TRUE;
            }
            else if ( lResult != 1 )
            {
                FreeMemory( &pBuffer );
                SaveErrorMessage( ERROR_CANCELLED );
                return ERROR_CANCELLED;
            }
        }
    }

    //
    // Write the Value
    //
    lResult = RegSetValueEx( hDestKey, pwszDestValueName, 0, dwType, pBuffer, dwSize );

    // release memory
    FreeMemory( &pBuffer );

    return lResult;
}


//-----------------------------------------------------------------------//
//
// EnumerateKey() - Recursive
//
//-----------------------------------------------------------------------//

LONG CopyEnumerateKey( HKEY hKey, LPCWSTR pwszSubKey,
                       HKEY hDestKey, LPCWSTR pwszDestSubKey,
                       BOOL* pbForce, BOOL bRecurseSubKeys, DWORD dwDepth )
{
    // local variables
    DWORD dw = 0;
    LONG lResult = 0;
    DWORD dwValues = 0;
    DWORD dwSubKeys = 0;
    DWORD dwLengthOfKeyName = 0;
    DWORD dwLengthOfValueName = 0;
    DWORD dwSize = 0;
    DWORD dwDisposition = 0;
    HKEY hSubKey = NULL;
    HKEY hDestSubKey = NULL;
    LPWSTR pwszNameBuf = NULL;
    LPWSTR pwszNewSubKey = NULL;
    LPWSTR pwszNewDestSubKey = NULL;

    // check the input
    if ( hKey == NULL || pwszSubKey == NULL ||
         hDestKey == NULL || pwszDestSubKey == NULL || pbForce == NULL )
    {
        lResult = ERROR_INVALID_PARAMETER;
        goto exitarea;
    }

    // query source key info
    lResult = RegQueryInfoKey(
        hKey, NULL, NULL, NULL,
        &dwSubKeys, &dwLengthOfKeyName, NULL,
        &dwValues, &dwLengthOfValueName, NULL, NULL, NULL );
    if( lResult != ERROR_SUCCESS )
    {
        goto exitarea;
    }

    //
    // SPECIAL CASE:
    // -------------
    // For HKLM\SYSTEM\CONTROLSET002 it is found to be API returning value 0 for dwMaxLength
    // though there are subkeys underneath this -- to handle this, we are doing a workaround
    // by assuming the max registry key length
    //
    if ( dwSubKeys != 0 && dwLengthOfKeyName == 0 )
    {
        dwLengthOfKeyName = 256;
    }
    else if ( dwLengthOfKeyName < 256 )
    {
        // always assume 100% more length that what is returned by the API
        dwLengthOfKeyName *= 2;
    }

    //
    // First enumerate all of the values
    //
    // bump the length to take into account the terminator.
    dwLengthOfValueName++;
    pwszNameBuf = (LPWSTR) AllocateMemory( dwLengthOfValueName * sizeof(WCHAR) );
    if( pwszNameBuf == NULL)
    {
        lResult = ERROR_OUTOFMEMORY;
    }
    else
    {
        lResult = ERROR_SUCCESS;
        for( dw = 0; dw < dwValues && lResult == ERROR_SUCCESS; dw++ )
        {
            dwSize = dwLengthOfValueName;
            lResult = RegEnumValue( hKey, dw, pwszNameBuf, &dwSize, NULL, NULL, NULL, NULL);
            if( lResult == ERROR_SUCCESS )
            {
                lResult = CopyValue( hKey, pwszNameBuf,
                    hDestKey, pwszNameBuf, pbForce, pwszSubKey );
                if ( lResult == ERROR_CANCELLED )
                {
                    // user chosed to just to skip this
                    lResult = ERROR_SUCCESS;
                }
            }
        }

        // release memory
        FreeMemory( &pwszNameBuf );

        if( bRecurseSubKeys == FALSE || lResult != ERROR_SUCCESS )
        {
            goto exitarea;
        }

        //
        // Now Enumerate all of the keys
        //
        dwLengthOfKeyName++;
        pwszNameBuf = (LPWSTR) AllocateMemory( dwLengthOfKeyName * sizeof(WCHAR) );
        if( pwszNameBuf == NULL )
        {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            hSubKey = NULL;
            hDestSubKey = NULL;
            for( dw = 0; dw < dwSubKeys; dw++ )
            {
                dwSize = dwLengthOfKeyName;
                lResult = RegEnumKeyEx( hKey, dw,
                    pwszNameBuf, &dwSize, NULL, NULL, NULL, NULL );
                if( lResult != ERROR_SUCCESS )
                {
                    break;
                }

                //
                // open up the subkey, create the destination key
                // and enumerate it
                //
                lResult = RegOpenKeyEx( hKey, pwszNameBuf, 0, KEY_READ, &hSubKey );
                if( lResult != ERROR_SUCCESS )
                {
                    break;
                }

                lResult = RegCreateKeyEx( hDestKey,
                    pwszNameBuf, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL,  &hDestSubKey, &dwDisposition );
                if( lResult != ERROR_SUCCESS )
                {
                    break;
                }

                //
                // Build up the needed string and go to town enumerating again
                //

                //
                // new source sub key
                dwSize = StringLength( pwszSubKey, 0 ) + StringLength( pwszNameBuf, 0 ) + 3;
                pwszNewSubKey = (LPWSTR) AllocateMemory( dwSize * sizeof( WCHAR ) );
                if( pwszNewSubKey == NULL )
                {
                    lResult = ERROR_OUTOFMEMORY;
                    break;
                }

                if( StringLength( pwszSubKey, 0 ) > 0 )
                {
                    StringCopy( pwszNewSubKey, pwszSubKey, dwSize );
                    StringConcat( pwszNewSubKey, L"\\", dwSize );
                }

                // ...
                StringConcat( pwszNewSubKey, pwszNameBuf, dwSize );

                //
                // new destination sub key
                dwSize = StringLength( pwszDestSubKey, 0 ) + StringLength( pwszNameBuf, 0 ) + 3;
                pwszNewDestSubKey = (LPWSTR) AllocateMemory( dwSize * sizeof( WCHAR ) );
                if( pwszDestSubKey == NULL )
                {
                    lResult = ERROR_OUTOFMEMORY;
                    break;
                }

                if( StringLength( pwszDestSubKey, 0 ) > 0 )
                {
                    StringCopy( pwszNewDestSubKey, pwszDestSubKey, dwSize);
                    StringConcat( pwszNewDestSubKey, L"\\", dwSize );
                }

                // ...
                StringConcat( pwszNewDestSubKey, pwszNameBuf, dwSize );

                // recursive copy
                lResult = CopyEnumerateKey(  hSubKey, pwszNewSubKey,
                    hDestSubKey, pwszNewDestSubKey, pbForce, bRecurseSubKeys, dwDepth + 1 );

                SafeCloseKey( &hSubKey );
                SafeCloseKey( &hDestSubKey );
                FreeMemory( &pwszNewSubKey );
                FreeMemory( &pwszNewDestSubKey );
            }

            // release all the key handles and memory allocated
            if ( hSubKey != NULL )
            {
                SafeCloseKey( &hSubKey );
            }

            if ( hDestSubKey != NULL )
            {
                SafeCloseKey( &hDestSubKey );
            }

            // ...
            FreeMemory( &pwszNameBuf );
            FreeMemory( &pwszNewSubKey );
            FreeMemory( &pwszNewDestSubKey );
        }
    }

exitarea:

    // check the result and display the error message
    // NOTE: error message display should be done only at the exit point
    if ( dwDepth == 0 )
    {
        if ( lResult != ERROR_SUCCESS )
        {
            // display the error
            SaveErrorMessage( lResult );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        }
        else
        {
            SaveErrorMessage( ERROR_SUCCESS );
            ShowLastErrorEx( stdout, SLE_INTERNAL );
        }
    }

    // return
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\compare.c ===
//-----------------------------------------------------------------------//
//
// File:    compare.cpp
// Created: April 1999
// By:      Zeyong Xu
// Purpose: Compare two registry key
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

//
// defines / constants / enumerations
//

enum
{
    OUTPUTTYPE_NONE = 1,
    OUTPUTTYPE_SAME = 2,
    OUTPUTTYPE_DIFF = 3,
    OUTPUTTYPE_ALL = 4
};

enum
{
    PRINTTYPE_LEFT = 1,
    PRINTTYPE_RIGHT = 2,
    PRINTTYPE_SAME = 3,
};

//
// function prototypes
//
BOOL CompareByteData( BYTE* pLeftData, BYTE* pRightData, DWORD dwSize );
BOOL CopyKeyNameFromLeftToRight( PTREG_PARAMS pParams, PTREG_PARAMS pRightParams );
LONG CompareEnumerateValueName( HKEY hLeftKey, LPCWSTR pwszLeftFullKeyName,
                                HKEY hRightKey, LPCWSTR pwszRightFullKeyName,
                                DWORD dwOutputType, BOOL* pbHasDifference );
LONG CompareValues( HKEY hLeftKey, LPCWSTR pwszLeftFullKeyName,
                    HKEY hRightKey, LPCWSTR pwszRightFullKeyName,
                    LPCWSTR pwszValueName, DWORD dwOutputType, BOOL* pbHasDifference );
LONG CompareEnumerateKey( HKEY hLeftKey, LPCWSTR pwszLeftFullKeyName,
                          HKEY hRightKey, LPCWSTR pwszRightFullKeyName,
                          DWORD dwOutputType, BOOL bRecurseSubKeys,
                          BOOL* pbHasDifference, DWORD dwDepth );
BOOL ParseCompareCmdLine( DWORD argc,
                          LPCWSTR argv[],
                          PTREG_PARAMS pParams,
                          PTREG_PARAMS pRightParams, BOOL* pbUsage );
BOOL PrintValue( LPCWSTR pwszFullKeyName, LPCWSTR pwszValueName,
                 DWORD dwType, BYTE* pData, DWORD dwSize, DWORD dwPrintType );
BOOL PrintKey( LPCWSTR pwszFullKeyName, LPCWSTR pwszSubKeyName, DWORD dwPrintType );
LONG OutputValue( HKEY hKey, LPCWSTR szFullKeyName, LPCWSTR szValueName, DWORD dwPrintType );

//
// implementation
//

//-----------------------------------------------------------------------//
//
// CompareRegistry()
//
//-----------------------------------------------------------------------//

LONG
CompareRegistry( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    HKEY hLeftKey = NULL;
    HKEY hRightKey = NULL;
    BOOL bResult = FALSE;
    BOOL bUsage = FALSE;
    TREG_PARAMS params;
    TREG_PARAMS paramsRight;
    BOOL bHasDifference = FALSE;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_COMPARE, &params );
    InitGlobalData( REG_COMPARE, &paramsRight );

    //
    // Parse the cmd-line
    //
    bResult = ParseCompareCmdLine( argc, argv, &params, &paramsRight, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_COMPARE );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 0;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 1;
    }

    bResult = RegConnectMachine( &paramsRight );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 1;
    }

    // if try to compare the same keys
    if ( params.hRootKey == paramsRight.hRootKey &&
         StringCompare( params.pwszFullKey, paramsRight.pwszFullKey, TRUE, 0 ) == 0 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason( ERROR_COMPARESELF_COMPARE );
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 1;
    }

    //
    // Now implement the body of the Compare Operation
    //
    lResult = RegOpenKeyEx( params.hRootKey, params.pwszSubKey, 0, KEY_READ, &hLeftKey );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 1;
    }

    lResult = RegOpenKeyEx( paramsRight.hRootKey,
        paramsRight.pwszSubKey, 0, KEY_READ, &hRightKey );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SafeCloseKey( &hLeftKey );
        FreeGlobalData( &params );
        FreeGlobalData( &paramsRight );
        return 1;
    }

    //
    // compare a single value if pAppVars->szValueName is not NULL
    //
    if( params.pwszValueName != NULL )
    {
        lResult = CompareValues(
            hLeftKey, params.pwszFullKey,
            hRightKey, paramsRight.pwszFullKey,
            params.pwszValueName, params.dwOutputType, &bHasDifference );
    }
    else
    {
        //
        // Recursively compare if pAppVars->bRecurseSubKeys is true
        //
        lResult = CompareEnumerateKey(
            hLeftKey, params.pwszFullKey,
            hRightKey, paramsRight.pwszFullKey,
            params.dwOutputType, params.bRecurseSubKeys, &bHasDifference, 0 );
    }

    if( lResult == ERROR_SUCCESS )
    {
        if( bHasDifference == TRUE )
        {
            lResult = 2;
            ShowMessage( stdout, KEYS_DIFFERENT_COMPARE );
        }
        else
        {
            lResult = 0;
            ShowMessage( stdout, KEYS_IDENTICAL_COMPARE );
        }

        // ...
        SaveErrorMessage( ERROR_SUCCESS );
        ShowLastErrorEx( stdout, SLE_INTERNAL );

    }
    else
    {
        lResult = 1;
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    //
    // lets clean up
    //
    SafeCloseKey( &hLeftKey );
    SafeCloseKey( &hRightKey );
    FreeGlobalData( &params );
    FreeGlobalData( &paramsRight );

    // return
    return lResult;
}


BOOL
ParseCompareCmdLine( DWORD argc, LPCWSTR argv[],
                     PTREG_PARAMS pParams, PTREG_PARAMS pRightParams, BOOL* pbUsage )
{
    // local variables
    DWORD dw = 0;
    DWORD dwLength = 0;
    BOOL bResult = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL ||
         pParams == NULL || pRightParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if ( argc == 3 &&
         InString( argv[ 2 ], L"/?|-?|/h|-h", TRUE ) == TRUE )
    {
        *pbUsage = TRUE;
        return TRUE;
    }
    else if( argc < 4 || argc > 8 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
        return FALSE;
    }
    else if ( StringCompareEx( argv[ 1 ], L"COMPARE", TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Left Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }


    //
    // Right Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 3 ], pRightParams );
    if( bResult == FALSE )
    {
        if ( GetLastError() == (DWORD) REGDB_E_KEYMISSING )
        {
            // if no keyname for right side is specified,
            // they are comparing the same key name
            bResult = CopyKeyNameFromLeftToRight( pParams, pRightParams );
        }
        else if ( pRightParams->pwszMachineName != NULL &&
                  StringCompareEx( pRightParams->pwszMachineName, L"\\\\.", TRUE, 0 ) == 0 )
        {
            // reinitialize the global data (right only)
            FreeGlobalData( pRightParams );
            InitGlobalData( REG_COMPARE, pRightParams );

            // parse the info using the left data (just the full key)
            bResult = BreakDownKeyString( pParams->pwszFullKey, pRightParams );
        }
    }

    // ...
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // parsing
    for( dw = 4; dw < argc; dw++ )
    {
        if( StringCompareEx( argv[ dw ], L"/v", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->bRecurseSubKeys == TRUE )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            dw++;
            if( dw < argc )
            {
                dwLength = StringLength( argv[ dw ], 0 ) + 1;
                pParams->pwszValueName = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
                if ( pParams->pwszValueName == NULL )
                {
                    SaveErrorMessage( ERROR_OUTOFMEMORY );
                    return FALSE;
                }

                StringCopy( pParams->pwszValueName, argv[ dw ], dwLength );
            }
            else
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/ve", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->bRecurseSubKeys == TRUE )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            pParams->pwszValueName = (LPWSTR) AllocateMemory( 2 * sizeof( WCHAR ) );
            if ( pParams->pwszValueName == NULL )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/oa", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->dwOutputType != 0 )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            pParams->dwOutputType = OUTPUTTYPE_ALL;
        }
        else if( StringCompareEx( argv[ dw ], L"/od", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->dwOutputType != 0 )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            pParams->dwOutputType = OUTPUTTYPE_DIFF;
        }
        else if( StringCompareEx( argv[ dw ], L"/os", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->dwOutputType != 0 )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            pParams->dwOutputType = OUTPUTTYPE_SAME;
        }
        else if( StringCompareEx( argv[ dw ], L"/on", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->dwOutputType != 0 )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            pParams->dwOutputType = OUTPUTTYPE_NONE;
        }
        else if( StringCompareEx( argv[ dw ], L"/s", TRUE, 0 ) == 0 )
        {
            if ( pParams->pwszValueName != NULL || pParams->bRecurseSubKeys == TRUE )
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
                return FALSE;
            }

            pParams->bRecurseSubKeys = TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_COMPARE ] );
            return FALSE;
        }
    }

    // default output is "DIFF"
    if ( pParams->dwOutputType == 0 )
    {
        pParams->dwOutputType = OUTPUTTYPE_DIFF;
    }

    return TRUE;
}


BOOL
CopyKeyNameFromLeftToRight( PTREG_PARAMS pParams, PTREG_PARAMS pRightParams )
{
    // local variables
    DWORD dwLength = 0;

    // check the input
    if ( pParams == NULL || pRightParams == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check if rootkey is remotable for right side
    if( pRightParams->bUseRemoteMachine == TRUE &&
        pParams->hRootKey != HKEY_USERS && pParams->hRootKey != HKEY_LOCAL_MACHINE )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_NONREMOTABLEROOT, g_wszOptions[ REG_COMPARE ] );
        return FALSE;
    }

    //
    // hive
    pRightParams->hRootKey = pParams->hRootKey;

    //
    // full key
    dwLength = StringLength( pParams->pwszFullKey, 0 ) + 1;
    pRightParams->pwszFullKey = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if( pRightParams->pwszFullKey == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    // ...
    StringCopy( pRightParams->pwszFullKey, pParams->pwszFullKey, dwLength );

    //
    // sub key
    dwLength = StringLength( pParams->pwszSubKey, 0 ) + 1;
    pRightParams->pwszSubKey = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if( pRightParams->pwszSubKey == NULL)
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    // ...
    StringCopy( pRightParams->pwszSubKey, pParams->pwszSubKey, dwLength );

    // return
    return TRUE;
}

//-----------------------------------------------------------------------//
//
// EnumerateKey() - Recursive
//
//-----------------------------------------------------------------------//
LONG
CompareEnumerateKey( HKEY hLeftKey,
                     LPCWSTR pwszLeftFullKeyName,
                     HKEY hRightKey,
                     LPCWSTR pwszRightFullKeyName,
                     DWORD dwOutputType,
                     BOOL bRecurseSubKeys,
                     BOOL* pbHasDifference, DWORD dwDepth )
{
    // local variables
    DWORD dw = 0;
    DWORD dwSize = 0;
    LONG lIndex = 0;
    LONG lResult = 0;
    DWORD dwLeftKeys = 0;
    DWORD dwRightKeys = 0;
    TARRAY arrLeftKeys = NULL;
    TARRAY arrRightKeys = NULL;
    HKEY hLeftSubKey = NULL;
    HKEY hRightSubKey = NULL;
    DWORD dwLengthOfLeftKey = 0;
    DWORD dwLengthOfRightKey = 0;
    LPWSTR pwszBuffer = NULL;
    LPCWSTR pwszKey = NULL;
    LPWSTR pwszNewLeftFullKeyName = NULL;
    LPWSTR pwszNewRightFullKeyName = NULL;

    // check the input
    if ( hLeftKey == NULL || pwszLeftFullKeyName == NULL ||
         hRightKey == NULL || pwszRightFullKeyName == NULL || pbHasDifference == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    // enumerate all values under current key
    lResult = CompareEnumerateValueName( hLeftKey, pwszLeftFullKeyName,
        hRightKey, pwszRightFullKeyName, dwOutputType, pbHasDifference );
    if( bRecurseSubKeys == FALSE || lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    // optimizing the logic
    // if user is not interested in seeing the differences,
    // we will check whether the comparision done till now is same or not
    // if not, there is no point in proceeding -- this is because, the final output
    // of the tool is not going to be by continuing furthur
    if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
    {
        if ( *pbHasDifference == TRUE )
        {
            return ERROR_SUCCESS;
        }
    }

    // query left key info
    lResult = RegQueryInfoKey( hLeftKey, NULL, NULL, NULL,
        &dwLeftKeys, &dwLengthOfLeftKey, NULL, NULL, NULL, NULL, NULL, NULL );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    //
    // SPECIAL CASE:
    // -------------
    // For HKLM\SYSTEM\CONTROLSET002 it is found to be API returning value 0 for dwMaxLength
    // though there are subkeys underneath this -- to handle this, we are doing a workaround
    // by assuming the max registry key length
    //
    if ( dwLeftKeys != 0 && dwLengthOfLeftKey == 0 )
    {
        dwLengthOfLeftKey = 256;
    }
    else if ( dwLengthOfLeftKey < 256 )
    {
        // always assume 100% more length that what is returned by the API
        dwLengthOfLeftKey *= 2;
    }


    // query right key info
    lResult = RegQueryInfoKey( hRightKey, NULL, NULL, NULL,
        &dwRightKeys, &dwLengthOfRightKey, NULL, NULL, NULL, NULL, NULL, NULL );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    //
    // SPECIAL CASE:
    // -------------
    // For HKLM\SYSTEM\CONTROLSET002 it is found to be API returning value 0 for dwMaxLength
    // though there are subkeys underneath this -- to handle this, we are doing a workaround
    // by assuming the max registry key length
    //
    if ( dwRightKeys != 0 && dwLengthOfRightKey == 0 )
    {
        dwLengthOfRightKey = 256;
    }
    else if ( dwLengthOfRightKey < 256 )
    {
        // always assume 100% more length that what is returned by the API
        dwLengthOfRightKey *= 2;
    }

    // furthur more optimizing the logic
    // if user is not interested in seeing the differences,
    // we will check the count and length information -- if they dont match, simply return
    if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
    {
        if ( dwLeftKeys != dwRightKeys ||
             dwLengthOfLeftKey != dwLengthOfRightKey )
        {
            *pbHasDifference = TRUE;
            return ERROR_SUCCESS;
        }
    }

    // make the length values point to the max. of both
    dwLengthOfRightKey++;
    dwLengthOfLeftKey++;
    if ( dwLengthOfRightKey > dwLengthOfLeftKey )
    {
        dwLengthOfLeftKey = dwLengthOfRightKey;
    }
    else
    {
        dwLengthOfRightKey = dwLengthOfLeftKey;
    }

    //
    // allocate memory
    //

    // left keys array
    arrLeftKeys = CreateDynamicArray();
    if ( arrLeftKeys == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    // right keys array
    arrRightKeys = CreateDynamicArray();
    if ( arrRightKeys == NULL )
    {
        DestroyDynamicArray( &arrLeftKeys );
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    // string buffer
    pwszBuffer = (LPWSTR) AllocateMemory( dwLengthOfLeftKey * sizeof( WCHAR ) );
    if ( pwszBuffer == NULL )
    {
        DestroyDynamicArray( &arrRightKeys );
        DestroyDynamicArray( &arrLeftKeys );
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    //
    // enumerate all of the subkeys in left key
    //
    lResult = ERROR_SUCCESS;
    for( dw = 0; dw < dwLeftKeys && lResult == ERROR_SUCCESS; dw++ )
    {
        dwSize = dwLengthOfLeftKey;
        SecureZeroMemory( pwszBuffer, dwSize * sizeof( WCHAR ) );
        lResult = RegEnumKeyEx( hLeftKey, dw,
            pwszBuffer, &dwSize, NULL, NULL, NULL, NULL );

        // add the current value to the list of values in the array
        if ( lResult == ERROR_SUCCESS )
        {
            if ( DynArrayAppendString( arrLeftKeys, pwszBuffer, 0 ) == -1 )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    //
    // enumerate all of the subkeys in right key
    //
    for( dw = 0; dw < dwRightKeys && lResult == ERROR_SUCCESS; dw++ )
    {
        dwSize = dwLengthOfRightKey;
        SecureZeroMemory( pwszBuffer, dwSize * sizeof( WCHAR ) );
        lResult = RegEnumKeyEx( hRightKey, dw,
            pwszBuffer, &dwSize, NULL, NULL, NULL, NULL );

        // add the current value to the list of values in the array
        if ( lResult == ERROR_SUCCESS )
        {
            if ( DynArrayAppendString( arrRightKeys, pwszBuffer, 0 ) == -1 )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    // we no longer require this memory -- release it
    FreeMemory( &pwszBuffer );

    // allocatte new buffers for storing the new left and right full key names
    if ( lResult == ERROR_SUCCESS )
    {
        // determine the lengths
        dwLengthOfLeftKey += StringLength( pwszLeftFullKeyName, 0 ) + 5;
        dwLengthOfRightKey += StringLength( pwszRightFullKeyName, 0 ) +5;

        // now allocate buffers
        pwszNewLeftFullKeyName =
            (LPWSTR) AllocateMemory( dwLengthOfLeftKey * sizeof( WCHAR ) );
        if ( pwszNewLeftFullKeyName == NULL )
        {
            lResult = ERROR_OUTOFMEMORY;
        }
        else
        {
            pwszNewRightFullKeyName =
                (LPWSTR) AllocateMemory( dwLengthOfRightKey * sizeof( WCHAR ) );
            if ( pwszNewRightFullKeyName == NULL )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    // compare two subkey name array to find the same subkey
    for( dw = 0; dw < dwLeftKeys && lResult == ERROR_SUCCESS; )
    {
        // get the current value from the left array
        pwszKey = DynArrayItemAsString( arrLeftKeys, dw );

        // search for this value in the right values array
        lIndex = DynArrayFindString( arrRightKeys, pwszKey, TRUE, 0 );
        if ( lIndex != -1 )
        {
            // print the key information
            if ( dwOutputType == OUTPUTTYPE_ALL || dwOutputType == OUTPUTTYPE_SAME )
            {
                PrintKey( pwszLeftFullKeyName, pwszKey, PRINTTYPE_SAME );
            }

            // prepare the new left subkey
            StringCopy( pwszNewLeftFullKeyName, pwszLeftFullKeyName, dwLengthOfLeftKey );
            StringConcat( pwszNewLeftFullKeyName, L"\\", dwLengthOfLeftKey );
            StringConcat( pwszNewLeftFullKeyName, pwszKey,dwLengthOfLeftKey );

            // prepare the new right subkey
            StringCopy( pwszNewRightFullKeyName, pwszRightFullKeyName, dwLengthOfRightKey );
            StringConcat( pwszNewRightFullKeyName, L"\\", dwLengthOfRightKey );
            StringConcat( pwszNewRightFullKeyName, pwszKey, dwLengthOfRightKey );

            //
            // open new left key
            lResult = RegOpenKeyEx( hLeftKey, pwszKey, 0, KEY_READ, &hLeftSubKey );
            if( lResult != ERROR_SUCCESS )
            {
                break;
            }

            //
            // open the new right key
            lResult = RegOpenKeyEx( hRightKey, pwszKey, 0, KEY_READ, &hRightSubKey );
            if( lResult != ERROR_SUCCESS )
            {
                break;
            }

            // recursive to compare subkeys
            lResult = CompareEnumerateKey(
                hLeftSubKey, pwszNewLeftFullKeyName,
                hRightSubKey, pwszNewRightFullKeyName,
                dwOutputType, bRecurseSubKeys, pbHasDifference, dwDepth + 1 );

            // release the keys
            SafeCloseKey( &hLeftSubKey );
            SafeCloseKey( &hRightSubKey );

            if ( lResult == ERROR_SUCCESS )
            {
                // comparision is done -- remove the current keys from
                // left and right values array
                DynArrayRemove( arrLeftKeys, dw );
                DynArrayRemove( arrRightKeys, lIndex );

                // update the count variables accordingly
                dwLeftKeys--;
                dwRightKeys--;
            }

            // check if the differences were found or not
            if( *pbHasDifference == TRUE )
            {
                if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
                {
                    dw = 0;
                    dwLeftKeys = 0;
                    dwRightKeys = 0;
                    break;
                }
            }
        }

        // update the iteration variable
        if ( lIndex == -1 )
        {
            dw++;
        }
    }

    // Output subkey name in left key
    for( dw = 0; dw < dwLeftKeys && lResult == ERROR_SUCCESS; dw++ )
    {
        // get the current value from the left array
        pwszKey = DynArrayItemAsString( arrLeftKeys, dw );
        if( dwOutputType == OUTPUTTYPE_DIFF || dwOutputType == OUTPUTTYPE_ALL )
        {
            PrintKey( pwszLeftFullKeyName, pwszKey, PRINTTYPE_LEFT );
        }

        // ...
        *pbHasDifference = TRUE;
    }

    // Output subkey name in right key
    for( dw = 0; dw < dwRightKeys && lResult == ERROR_SUCCESS; dw++ )
    {
        // get the current value from the left array
        pwszKey = DynArrayItemAsString( arrRightKeys, dw );
        if( dwOutputType == OUTPUTTYPE_DIFF || dwOutputType == OUTPUTTYPE_ALL )
        {
            PrintKey( pwszRightFullKeyName, pwszKey, PRINTTYPE_RIGHT );
        }

        // ...
        *pbHasDifference = TRUE;
    }

    // release the memory allocated
    FreeMemory( &pwszBuffer );
    SafeCloseKey( &hLeftSubKey );
    SafeCloseKey( &hRightSubKey );
    FreeMemory( &pwszNewLeftFullKeyName );
    FreeMemory( &pwszNewRightFullKeyName );
    DestroyDynamicArray( &arrLeftKeys );
    DestroyDynamicArray( &arrRightKeys );

    // return
    SaveErrorMessage( lResult );
    return lResult;
}


LONG
CompareEnumerateValueName( HKEY hLeftKey,
                           LPCWSTR pwszLeftFullKeyName,
                           HKEY hRightKey,
                           LPCWSTR pwszRightFullKeyName,
                           DWORD dwOutputType, BOOL* pbHasDifference )
{
    // local variables
    DWORD dw = 0;
    LONG lIndex = 0;
    LONG lResult = 0;
    DWORD dwSize = 0;
    DWORD dwLeftValues = 0;
    DWORD dwRightValues = 0;
    DWORD dwLengthOfLeftValue = 0;
    DWORD dwLengthOfRightValue = 0;
    TARRAY arrLeftValues = NULL;
    TARRAY arrRightValues = NULL;
    LPWSTR pwszBuffer = NULL;
    LPCWSTR pwszValue = NULL;

    // check the input
    if ( hLeftKey == NULL || pwszLeftFullKeyName == NULL ||
         hRightKey == NULL || pwszRightFullKeyName == NULL || pbHasDifference == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    // optimizing the logic
    // if user is not interested in seeing the differences,
    // we will check whether the comparision done till now is same or not
    // if not, there is no point in proceeding -- this is because, the final output
    // of the tool is not going to be by continuing furthur
    if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
    {
        if ( *pbHasDifference == TRUE )
        {
            return ERROR_SUCCESS;
        }
    }

    // query left key info
    lResult = RegQueryInfoKey(
        hLeftKey, NULL, NULL, NULL, NULL, NULL, NULL,
        &dwLeftValues, &dwLengthOfLeftValue, NULL, NULL, NULL);
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    // query right key info
    lResult = RegQueryInfoKey(
        hRightKey, NULL, NULL, NULL, NULL, NULL, NULL,
        &dwRightValues, &dwLengthOfRightValue, NULL, NULL, NULL);
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    // furthur more optimizing the logic
    // if user is not interested in seeing the differences,
    // we will check the count and length information -- if they dont match, simply return
    if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
    {
        if ( dwLeftValues != dwRightValues ||
             dwLengthOfLeftValue != dwLengthOfRightValue )
        {
            *pbHasDifference = TRUE;
            return ERROR_SUCCESS;
        }
    }

    // make the length values point to the max. of both
    dwLengthOfRightValue++;
    dwLengthOfLeftValue++;
    if ( dwLengthOfRightValue > dwLengthOfLeftValue )
    {
        dwLengthOfLeftValue = dwLengthOfRightValue;
    }
    else
    {
        dwLengthOfRightValue = dwLengthOfLeftValue;
    }

    //
    // allocate bufferes
    //

    // left values array
    arrLeftValues = CreateDynamicArray();
    if ( arrLeftValues == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    // right values array
    arrRightValues = CreateDynamicArray();
    if ( arrRightValues == NULL )
    {
        DestroyDynamicArray( &arrLeftValues );
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    // string buffer
    pwszBuffer = (LPWSTR) AllocateMemory( dwLengthOfLeftValue * sizeof( WCHAR ) );
    if ( pwszBuffer == NULL )
    {
        DestroyDynamicArray( &arrRightValues );
        DestroyDynamicArray( &arrLeftValues );
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    //
    // enumerate all of the values in left key
    //
    lResult = ERROR_SUCCESS;
    for( dw = 0; dw < dwLeftValues && lResult == ERROR_SUCCESS; dw++ )
    {
        dwSize = dwLengthOfLeftValue;
        SecureZeroMemory( pwszBuffer, dwSize * sizeof( WCHAR ) );
        lResult = RegEnumValue( hLeftKey, dw,
            pwszBuffer, &dwSize, NULL, NULL, NULL, NULL );

        // add the current value to the list of values in the array
        if ( lResult == ERROR_SUCCESS )
        {
            if ( DynArrayAppendString( arrLeftValues, pwszBuffer, 0 ) == -1 )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    //
    // enumerate all of the values in right key
    //
    for( dw = 0; dw < dwRightValues && lResult == ERROR_SUCCESS; dw++ )
    {
        dwSize = dwLengthOfRightValue;
        SecureZeroMemory( pwszBuffer, dwSize * sizeof( WCHAR ) );
        lResult = RegEnumValue( hRightKey, dw,
            pwszBuffer, &dwSize, NULL, NULL, NULL, NULL );

        // add the current value to the list of values in the array
        if ( lResult == ERROR_SUCCESS )
        {
            if ( DynArrayAppendString( arrRightValues, pwszBuffer, 0 ) == -1 )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    // we no longer require this memory -- release it
    FreeMemory( &pwszBuffer );

    // compare two valuename array to find the same valuename
    for( dw = 0; dw < dwLeftValues && lResult == ERROR_SUCCESS; )
    {
        // get the current value from the left array
        pwszValue = DynArrayItemAsString( arrLeftValues, dw );

        // search for this value in the right values array
        lIndex = DynArrayFindString( arrRightValues, pwszValue, TRUE, 0 );
        if ( lIndex != -1 )
        {
            lResult = CompareValues( hLeftKey, pwszLeftFullKeyName,
                hRightKey, pwszRightFullKeyName, pwszValue, dwOutputType, pbHasDifference );

            if ( lResult == ERROR_SUCCESS )
            {
                // comparision is done -- remove the current keys from
                // left and right values array
                DynArrayRemove( arrLeftValues, dw );
                DynArrayRemove( arrRightValues, lIndex );

                // update the count variables accordingly
                dwLeftValues--;
                dwRightValues--;
            }
        }

        // update the iteration variable
        if ( lIndex == -1 )
        {
            dw++;
        }
    }

    // Output different valuename in left key
    for( dw = 0; dw < dwLeftValues && lResult == ERROR_SUCCESS; dw++ )
    {
        // get the current value from the left array
        pwszValue = DynArrayItemAsString( arrLeftValues, dw );
        if( dwOutputType == OUTPUTTYPE_DIFF || dwOutputType == OUTPUTTYPE_ALL )
        {
            lResult = OutputValue( hLeftKey,
                pwszLeftFullKeyName, pwszValue, PRINTTYPE_LEFT );
        }

        // ...
        *pbHasDifference = TRUE;
    }

    // Output different valuename in left key
    for( dw = 0; dw < dwRightValues && lResult == ERROR_SUCCESS; dw++ )
    {
        // get the current value from the left array
        pwszValue = DynArrayItemAsString( arrRightValues, dw );
        if( dwOutputType == OUTPUTTYPE_DIFF || dwOutputType == OUTPUTTYPE_ALL )
        {
            lResult = OutputValue( hRightKey,
                pwszRightFullKeyName, pwszValue, PRINTTYPE_RIGHT );
        }

        // ...
        *pbHasDifference = TRUE;
    }

    // release the memory allocated
    DestroyDynamicArray( &arrLeftValues );
    DestroyDynamicArray( &arrRightValues );

    // return
    SaveErrorMessage( lResult );
    return lResult;
}


//-----------------------------------------------------------------------//
//
// CompareValues()
//
//-----------------------------------------------------------------------//

LONG
CompareValues( HKEY hLeftKey,
               LPCWSTR pwszLeftFullKeyName,
               HKEY hRightKey,
               LPCWSTR pwszRightFullKeyName,
               LPCWSTR pwszValueName,
               DWORD dwOutputType, BOOL* pbHasDifference )
{
    // local variables
    LONG lResult = 0;
    DWORD dwTypeLeft = 0;
    DWORD dwTypeRight = 0;
    DWORD dwSizeLeft = 0;
    DWORD dwSizeRight = 0;
    BYTE* pLeftData = NULL;
    BYTE* pRightData = NULL;

    // check the input
    if ( hLeftKey == NULL || pwszLeftFullKeyName == NULL ||
         hRightKey == NULL || pwszRightFullKeyName == NULL ||
         pwszValueName == NULL || pbHasDifference == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    // optimizing the logic
    // if user is not interested in seeing the differences,
    // we will check whether the comparision done till now is same or not
    // if not, there is no point in proceeding -- this is because, the final output
    // of the tool is not going to be by continuing furthur
    if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
    {
        if ( *pbHasDifference == TRUE )
        {
            return ERROR_SUCCESS;
        }
    }

    //
    // First find out how much memory to allocate
    //
    lResult = RegQueryValueEx( hLeftKey, pwszValueName, 0, &dwTypeLeft, NULL, &dwSizeLeft );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    lResult = RegQueryValueEx( hRightKey, pwszValueName, 0, &dwTypeRight, NULL, &dwSizeRight );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    // furthur more optimizing the logic
    // if user is not interested in seeing the differences,
    // we will check the type and size information -- if they dont match, simply return
    if ( dwOutputType == 0 || dwOutputType == OUTPUTTYPE_NONE )
    {
        if ( dwTypeLeft != dwTypeRight || dwSizeLeft != dwSizeRight )
        {
            *pbHasDifference = TRUE;
            return ERROR_SUCCESS;
        }
    }

    // allocate memory for left data
    // NOTE: always align the data on WCHAR boundary
    dwSizeLeft = ALIGN_UP( dwSizeLeft, WCHAR );
    pLeftData = (BYTE*) AllocateMemory( (dwSizeLeft + 2) * sizeof( BYTE ) );
    if( pLeftData == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    // allocate memory for right data
    // NOTE: always align the data on WCHAR boundary
    dwSizeRight = ALIGN_UP( dwSizeRight, WCHAR );
    pRightData = (BYTE*) AllocateMemory( (dwSizeRight + 2) * sizeof( BYTE ) );
    if( pRightData == NULL )
    {
        FreeMemory( &pLeftData );
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return ERROR_OUTOFMEMORY;
    }

    //
    // Now get the data
    //
    lResult = RegQueryValueEx( hLeftKey,
        pwszValueName, 0, &dwTypeLeft, pLeftData, &dwSizeLeft );
    if( lResult == ERROR_SUCCESS )
    {
        lResult = RegQueryValueEx( hRightKey,
            pwszValueName, 0, &dwTypeRight, pRightData, &dwSizeRight );
    }

    if( lResult != ERROR_SUCCESS )
    {
        FreeMemory( &pLeftData );
        FreeMemory( &pRightData );
        SaveErrorMessage( lResult );
        return lResult;
    }

    if( dwTypeLeft != dwTypeRight || dwSizeLeft != dwSizeRight ||
        CompareByteData( pLeftData, pRightData, dwSizeLeft ) == TRUE )
    {
        if( dwOutputType == OUTPUTTYPE_DIFF || dwOutputType == OUTPUTTYPE_ALL )
        {
            // print left and right
            PrintValue( pwszLeftFullKeyName, pwszValueName,
                dwTypeLeft, pLeftData, dwSizeLeft, PRINTTYPE_LEFT );
            PrintValue( pwszRightFullKeyName, pwszValueName,
                dwTypeRight, pRightData, dwSizeRight, PRINTTYPE_RIGHT );
         }

         // ...
         *pbHasDifference = TRUE;
    }
    else    // they are the same
    {
        if( dwOutputType == OUTPUTTYPE_SAME || dwOutputType == OUTPUTTYPE_ALL )
        {
            PrintValue( pwszLeftFullKeyName, pwszValueName,
                dwTypeLeft, pLeftData, dwSizeLeft, PRINTTYPE_SAME );
        }
    }

    // release memory allocate and return
    FreeMemory( &pLeftData );
    FreeMemory( &pRightData );
    SaveErrorMessage( lResult );
    return lResult;
}


BOOL
PrintKey( LPCWSTR pwszFullKeyName, LPCWSTR pwszSubKeyName, DWORD dwPrintType )
{
    // check the input
    if ( pwszFullKeyName == NULL || pwszSubKeyName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // print type
    if( dwPrintType == PRINTTYPE_LEFT )
    {
        ShowMessage( stdout, L"< " );
    }
    else if( dwPrintType == PRINTTYPE_RIGHT )
    {
        ShowMessage( stdout, L"> " );
    }
    else if( dwPrintType == PRINTTYPE_SAME )
    {
        ShowMessage( stdout, L"= " );
    }

    // show the key
    ShowMessageEx( stdout, 1, TRUE,
        GetResString2( IDS_KEY_COMPARE, 0 ), pwszFullKeyName, pwszSubKeyName );

    // ...
    ShowMessage( stdout, L"\n" );

    return TRUE;
}


LONG
OutputValue( HKEY hKey,
             LPCWSTR pwszFullKeyName,
             LPCWSTR pwszValueName,
             DWORD dwPrintType )
{
    // local variables
    LONG lResult = ERROR_SUCCESS;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    BYTE* pByteData = NULL;

    //
    // First find out how much memory to allocate
    //
    lResult = RegQueryValueEx( hKey, pwszValueName, 0, &dwType, NULL, &dwSize );
    if( lResult != ERROR_SUCCESS )
    {
        return lResult;
    }

    // allocate memory
    // NOTE: always align the buffer on the WCHAR border
    dwSize = ALIGN_UP( dwSize, WCHAR );
    pByteData = (BYTE*) AllocateMemory( (dwSize + 2) * sizeof( BYTE ) );
    if( pByteData == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now get the data
    //
    lResult = RegQueryValueEx( hKey,
        pwszValueName, 0, &dwType, (LPBYTE) pByteData, &dwSize );
    if( lResult == ERROR_SUCCESS )
    {
        PrintValue( pwszFullKeyName,
            pwszValueName, dwType, pByteData, dwSize, dwPrintType);
    }

    // release memory
    FreeMemory( &pByteData );

    // return
    return lResult;
}


BOOL
PrintValue( LPCWSTR pwszFullKeyName,
            LPCWSTR pwszValueName,
            DWORD dwType, BYTE* pData,
            DWORD dwSize, DWORD dwPrintType )
{
    // local variables
    TREG_SHOW_INFO showinfo;

    // check the input
    if ( pwszFullKeyName == NULL || pwszValueName == NULL || pData == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // print type
    if( dwPrintType == PRINTTYPE_LEFT )
    {
        ShowMessage( stdout, L"< " );
    }
    else if( dwPrintType == PRINTTYPE_RIGHT )
    {
        ShowMessage( stdout, L"> " );
    }
    else if( dwPrintType == PRINTTYPE_SAME )
    {
        ShowMessage( stdout, L"= " );
    }

    // first Print Key
    ShowMessageEx( stdout, 1, TRUE,
        GetResString2( IDS_VALUE_COMPARE, 0 ), pwszFullKeyName );

    // init to ZERO
    SecureZeroMemory( &showinfo, sizeof( TREG_SHOW_INFO ) );

    // set the data
    showinfo.pwszValueName = pwszValueName;
    showinfo.dwType = dwType;
    showinfo.pByteData = pData;
    showinfo.pwszSeparator = NULL;
    showinfo.dwMaxValueNameLength = 0;
    showinfo.dwPadLength = 2;
    showinfo.dwSize = dwSize;
    showinfo.pwszMultiSzSeparator = NULL;

    // show the value and return
    return ShowRegistryValue( &showinfo );
}

BOOL
CompareByteData( BYTE* pLeftData, BYTE* pRightData, DWORD dwSize )
{
    // local variables
    DWORD dw = 0;
    BOOL  bDifferent = FALSE;

    // check the input
    if ( pLeftData == NULL || pRightData == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    bDifferent = FALSE;
    for( dw = 0; dw < dwSize; dw++ )
    {
        if( pLeftData[ dw ] != pRightData[ dw ] )
        {
            bDifferent = TRUE;
            break;
        }
    }

    return bDifferent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\add.c ===
//-----------------------------------------------------------------------//
//
// File:    add.cpp
// Created: March 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Add (Write) Support for REG.CPP
// Modification History:
//      March 1997 (a-martih):
//          Copied from Query.cpp and modificd.
//      October 1997 (martinho)
//          Added additional termination character for MULTI_SZ strings.
//          Added \0 delimiter between MULTI_SZ strings items
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

//
// function prototypes
//
BOOL ParseAddCmdLine( DWORD argc, LPCWSTR argv[],
                      PTREG_PARAMS pParams, BOOL* pbUsage );


//
// implementation
//

//-----------------------------------------------------------------------//
//
// AddRegistry()
//
//-----------------------------------------------------------------------//

LONG AddRegistry( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    DWORD dw = 0;
    DWORD dwBase = 0;
    DWORD dwCount = 0;
    HKEY hKey = NULL;
    LONG lEnd = 0;
    LONG lStart = 0;
    LONG lResult = 0;
    DWORD dwLength = 0;
    TREG_PARAMS params;
    BOOL bResult = FALSE;
    BYTE* pByteData = NULL;
    DWORD dwDisposition = 0;
    WCHAR wszTemp[ 3 ] = L"\0";
    LPWSTR pwszValue = NULL;
    BOOL bTrailing = FALSE;
    BOOL bErrorString = FALSE;
    DWORD dwLengthOfSeparator = 0;
    LPWSTR pwszData = NULL;
    LPWSTR pwszTemp = NULL;
    LPCWSTR pwszFormat = NULL;
    LPCWSTR pwszList = NULL;
    BOOL bUsage = FALSE;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_ADD, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseAddCmdLine( argc, argv, &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_ADD );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    //
    // Create/Open the registry key
    //
    lResult = RegCreateKeyEx( params.hRootKey, params.pwszSubKey, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition );
    if( lResult == ERROR_SUCCESS )
    {
        // safety check
        if ( hKey == NULL )
        {
            SaveErrorMessage( ERROR_PROCESS_ABORTED );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            FreeGlobalData( &params );
            return 1;
        }

        // value name should not be NULL
        if ( params.pwszValueName == NULL )
        {
            SafeCloseKey( &hKey );
            SaveErrorMessage( ERROR_INVALID_PARAMETER );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            FreeGlobalData( &params );
            return 1;
        }

        // check value if existed
        lResult = RegQueryValueEx( hKey,
            params.pwszValueName, NULL, NULL, NULL, NULL );
        if( lResult == ERROR_SUCCESS )
        {
            pwszFormat = GetResString2( IDS_OVERWRITE_CONFIRM, 0 );
            pwszList = GetResString2( IDS_CONFIRM_CHOICE_LIST, 1 );
            do
            {
                lResult = Prompt( pwszFormat,
                    params.pwszValueName, pwszList, params.bForce );
            } while ( lResult > 2 );

            if( lResult != 1 )
            {
                SafeCloseKey( &hKey );
                SaveErrorMessage( ERROR_CANCELLED );
                ShowLastErrorEx( stdout, SLE_INTERNAL );
                FreeGlobalData( &params );
                return 0;
            }
        }

        // check the error code
        else if ( lResult != ERROR_FILE_NOT_FOUND )
        {
            // some thing else happened -- need to quit
            SaveErrorMessage( lResult );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SafeCloseKey( &hKey );
            FreeGlobalData( &params );
            return 1;
        }

        bResult = TRUE;
        lResult = ERROR_SUCCESS;
        switch( params.lRegDataType )
        {
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            //
            // auto convert szValue (hex, octal, decimal format) to dwData
            //
            {
                if( params.pwszValue == NULL )
                {
                    lResult = ERROR_INVALID_PARAMETER;
                }
                else
                {
                    // determine the base
                    dwBase = 10;
                    if ( StringCompare( params.pwszValue, L"0x", TRUE, 2 ) == 0 )
                    {
                        dwBase = 16;
                    }

                    if( IsNumeric( params.pwszValue, dwBase, FALSE ) == FALSE )
                    {
                        // invalid data format
                        bResult = FALSE;
                        lResult = IDS_ERROR_INVALID_NUMERIC_ADD;
                    }
                    else
                    {
                        // ...
                        dw = (DWORD) AsLong( params.pwszValue, dwBase );
                        lResult = RegSetValueEx( hKey, params.pwszValueName,
                           0, params.lRegDataType, (BYTE*) &dw, sizeof(DWORD) );
                    }
                }

                break;
            }

        case REG_BINARY:
            {
                if ( params.pwszValue == NULL )
                {
                    lResult = ERROR_INVALID_PARAMETER;
                }
                else
                {
                    //
                    // Convert szValue (hex data string) to binary
                    //
                    dwLength = StringLength( params.pwszValue, 0 );

                    //
                    // We're converting a string (representing
                    // hex) into a binary stream.  How much to
                    // allocate?  E.g. for "0xABCD", which has
                    // a length of 4, we would need 2 bytes.
                    //
                    dwLength = (dwLength / 2) + (dwLength % 2) + 1;

                    pByteData = (BYTE*) AllocateMemory( dwLength * sizeof( BYTE ) );
                    if( pByteData == NULL )
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        dwCount = 0;
                        pwszValue = params.pwszValue;
                        SecureZeroMemory( wszTemp,
                            SIZE_OF_ARRAY( wszTemp ) * sizeof( WCHAR ) );
                        while( (dw = StringLength( pwszValue, 0 )) > 1 )
                        {
                            if ( (dw % 2) == 0 )
                            {
                                wszTemp[ 0 ] = *pwszValue;
                                pwszValue++;
                            }
                            else
                            {
                                wszTemp[ 0 ] = L'0';
                            }

                            wszTemp[ 1 ] = *pwszValue;
                            pwszValue++;

                            // hex format
                            if( IsNumeric( wszTemp, 16, TRUE ) == FALSE )
                            {
                                bResult = FALSE;
                                lResult = IDS_ERROR_INVALID_HEXVALUE_ADD;
                                break;
                            }
                            else
                            {
                                pByteData[ dwCount] = (BYTE) AsLong( wszTemp, 16 );
                            }

                            dwCount++;

                            //
                            // make sure we aren't stepping off our buffer
                            //
                            if( dwCount >= dwLength )
                            {
                                ASSERT(0);
                                lResult = ERROR_PROCESS_ABORTED;
                                break;
                            }
                        }

                        if( lResult == ERROR_SUCCESS )
                        {
                            lResult = RegSetValueEx(
                                hKey, params.pwszValueName,
                                0, params.lRegDataType, pByteData, dwCount );
                        }

                        FreeMemory( &pByteData);
                    }
                }

                break;
            }

        default:
        case REG_SZ:
        case REG_EXPAND_SZ:
        case REG_NONE:
            {
                if ( params.pwszValue == NULL )
                {
                    lResult = ERROR_INVALID_PARAMETER;
                }
                else
                {
                    dw = (StringLength(params.pwszValue, 0) + 1) * sizeof(WCHAR);
                    lResult = RegSetValueEx( hKey,
                                             params.pwszValueName, 0,
                                             params.lRegDataType,
                                             (BYTE*) params.pwszValue, dw );
                }

                break;
            }

        case REG_MULTI_SZ:
            {
                //
                // Replace separator("\0") with '\0' for MULTI_SZ,
                // "\0" uses to separate string by default,
                // if two separators("\0\0"), error
                //
                dwLength = StringLength( params.pwszValue, 0 );
                dwLengthOfSeparator = StringLength( params.wszSeparator, 0 );

                // calloc() initializes all char to 0
                dwCount = dwLength + 2;
                pwszData = (LPWSTR) AllocateMemory( (dwCount + 1) * sizeof(WCHAR) );
                if ( pwszData == NULL)
                {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    lEnd = -1;
                    lStart = 0;
                    pwszTemp = pwszData;
                    while( lStart < (LONG) dwLength )
                    {
                        lEnd = FindString2( params.pwszValue,
                            params.wszSeparator, TRUE, lStart );
                        if( lEnd != -1 )
                        {
                            // specifying two separators in the data is error
                            bTrailing = FALSE;
                            if ( lEnd == lStart )
                            {
                                bErrorString = TRUE;
                                break;
                            }
                            else if ( (dwLength - lEnd) == dwLengthOfSeparator )
                            {
                                // set the flag
                                bTrailing = TRUE;
                            }
                        }
                        else
                        {
                            lEnd = dwLength;
                        }

                        StringCopy( pwszTemp,
                            (params.pwszValue + lStart), (lEnd - lStart) + 1 );
                        pwszTemp += StringLength( pwszTemp, 0 ) + 1;

                        //
                        // make sure we aren't stepping off our buffer
                        //
                        if( pwszTemp >= (pwszData + dwCount) )
                        {
                            ASSERT(0);
                            lResult = ERROR_PROCESS_ABORTED;
                            break;
                        }

                        lStart = lEnd + dwLengthOfSeparator;
                    }

                    // empty
                    if( StringCompare( params.pwszValue,
                                       params.wszSeparator, TRUE, 0 ) == 0 )
                    {
                        pwszTemp = pwszData + 2;
                        bErrorString = FALSE;
                    }
                    else
                    {
                        pwszTemp += 1; // double null terminated string
                    }

                    if( bErrorString == TRUE )
                    {
                        bResult = FALSE;
                        lResult = IDS_ERROR_INVALID_DATA_ADD;
                    }
                    else
                    {
                        dwCount = (DWORD)((pwszTemp - pwszData) * sizeof(WCHAR));
                        lResult = RegSetValueEx( hKey, params.pwszValueName,
                            0, params.lRegDataType, (BYTE*) pwszData, dwCount );
                    }

                    FreeMemory( &pwszData );
                }

                break;
            }

        // default:
        //     lResult = ERROR_PROCESS_ABORTED;
        //     break;
        }
    }

    // close the registry key
    SafeCloseKey( &hKey );

    // release the memory allocated for global data
    FreeGlobalData( &params );

    // check the result of the operation performed
    if ( bResult == FALSE )
    {
        // custom error message
        ShowResMessage( stderr, lResult );
        lResult = 1;
    }
    else if ( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        lResult = 1;
    }
    else
    {
        lResult = 0;
        SaveErrorMessage( ERROR_SUCCESS );
        ShowLastErrorEx( stdout, SLE_INTERNAL );
    }

    // return the exit code
    return lResult;
}

//------------------------------------------------------------------------//
//
// ParseAddCmdLine()
//
//------------------------------------------------------------------------//

BOOL
ParseAddCmdLine( DWORD argc,
                 LPCWSTR argv[],
                 PTREG_PARAMS pParams,
                 BOOL* pbUsage )
{
    // local variables
    DWORD dw = 0;
    LONG lResult = 0;
    DWORD dwLength = 0;
    BOOL bResult = FALSE;
    BOOL bHasType = FALSE;
    BOOL bHasSeparator = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( argc < 3 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_ADD ] );
        return FALSE;
    }
    else if ( StringCompareEx( argv[ 1 ], L"ADD", TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    else if ( InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        if ( argc == 3 )
        {
            *pbUsage = TRUE;
            return TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_ADD ] );
            return FALSE;
        }
    }

    // Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // parsing
    bResult = TRUE;
    lResult = ERROR_SUCCESS;
    pParams->bForce = FALSE;
    for( dw = 3; dw < argc; dw++ )
    {
        if( StringCompareEx( argv[ dw ], L"/v", TRUE, 0 ) == 0 )
        {
            if( pParams->pwszValueName != NULL )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                dwLength = StringLength( argv[ dw ], 0 ) + 1;
                pParams->pwszValueName = (LPWSTR) AllocateMemory( dwLength * sizeof(WCHAR) );
                if ( pParams->pwszValueName == NULL )
                {
                    lResult = ERROR_OUTOFMEMORY;
                    break;
                }

                StringCopy( pParams->pwszValueName, argv[ dw ], dwLength );
                TrimString( pParams->pwszValueName, TRIM_ALL );
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/ve", TRUE, 0 ) == 0 )
        {
            if( pParams->pwszValueName != NULL )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // allocate some memory so that "/v" will not allowed
            pParams->pwszValueName = (LPWSTR) AllocateMemory( 1 * sizeof(WCHAR) );
            if( pParams->pwszValueName == NULL )
            {
                lResult = ERROR_OUTOFMEMORY;
                break;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/t", TRUE, 0 ) == 0 )
        {
            if ( bHasType == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                pParams->lRegDataType = IsRegDataType( argv[ dw ] );
                if( pParams->lRegDataType == -1 )
                {
                    if ( IsNumeric( argv[ dw ], 10, TRUE ) == FALSE )
                    {
                        bResult = FALSE;
                        lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                        break;
                    }
                    else
                    {
                        pParams->lRegDataType = AsLong( argv[ dw ], 10 );
                    }
                }

                // ...
                if ( bHasSeparator == TRUE &&
                     pParams->lRegDataType != REG_MULTI_SZ )
                {
                    bResult = FALSE;
                    lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                    break;
                }

                bHasType = TRUE;
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/s", TRUE, 0 ) == 0 )
        {
            if( bHasSeparator == TRUE ||
                (bHasType == TRUE && pParams->lRegDataType != REG_MULTI_SZ) )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                if( StringLength( argv[ dw ], 0 ) == 1 )
                {
                    bHasSeparator = TRUE;
                    StringCopy( pParams->wszSeparator,
                        argv[ dw ], SIZE_OF_ARRAY( pParams->wszSeparator ) );
                }
                else
                {
                    bResult = FALSE;
                    lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                    break;
                }
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/d", TRUE, 0 ) == 0 )
        {
            if( pParams->pwszValue != NULL )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                dwLength = StringLength( argv[ dw ], 0 ) + 1;
                pParams->pwszValue = (LPWSTR) AllocateMemory( dwLength * sizeof(WCHAR) );
                if (pParams->pwszValue == NULL)
                {
                    lResult = ERROR_OUTOFMEMORY;
                    break;
                }

                StringCopy( pParams->pwszValue, argv[ dw ], dwLength );
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/f", TRUE, 0 ) == 0 )
        {
            if ( pParams->bForce == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            pParams->bForce = TRUE;
        }
        else
        {
            bResult = FALSE;
            lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
            break;
        }
    }

    if ( lResult == ERROR_SUCCESS )
    {
        if( bHasSeparator == TRUE && bHasType == FALSE )
        {
            bResult = FALSE;
            lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
        }

        // if no value (or) value name, set to empty
        else
        {
            if ( pParams->pwszValueName == NULL )
            {
                pParams->pwszValueName = (LPWSTR) AllocateMemory( 1 * sizeof(WCHAR));
                if( pParams->pwszValueName == NULL )
                {
                    lResult = 