SP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal->Release();
        mspEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal = NULL;

        
        LOG((MSP_ERROR, "CRecordingTrackTerminal::FireEvent - FireEvent on sink failed. hr = %lx", hr));

        return hr;
    }

    //
    // event fired
    //

    LOG((MSP_TRACE, "CRecordingTrackTerminal::FireEvent - finish"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\frecord\recordingtrackterminal.h ===
// PlaybackTrackTerminal.h: interface for the CRecordingTrackTerminal class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PLAYBACKTRACKTERMINAL_H__4FD57959_2DF1_4F78_AB2C_5E365EFD9CC6__INCLUDED_)
#define AFX_PLAYBACKTRACKTERMINAL_H__4FD57959_2DF1_4F78_AB2C_5E365EFD9CC6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern const CLSID CLSID_FileRecordingTrackTerminal;


/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITFileTrackVtblFRT : public ITFileTrack
{
};

class CFileRecordingTerminal;

class CBRenderPin;
class CBRenderFilter;

class CRecordingTrackTerminal :
    public IDispatchImpl<ITFileTrackVtblFRT<CRecordingTrackTerminal>, &IID_ITFileTrack, &LIBID_TAPI3Lib>,
    public ITPluggableTerminalEventSinkRegistration,
    public ITPluggableTerminalInitialization,
    public CMSPObjectSafetyImpl,
    public CSingleFilterTerminal
{

public:

BEGIN_COM_MAP(CRecordingTrackTerminal)
    COM_INTERFACE_ENTRY2(IDispatch, ITFileTrack)
    COM_INTERFACE_ENTRY(ITFileTrack)
    COM_INTERFACE_ENTRY(ITPluggableTerminalEventSinkRegistration)
    COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CSingleFilterTerminal)
END_COM_MAP()

    CRecordingTrackTerminal();
	virtual ~CRecordingTrackTerminal();

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

    //
    // implementaions of CBaseTerminal methods
    //

    virtual HRESULT AddFiltersToGraph();

    virtual DWORD GetSupportedMediaTypes();


    STDMETHODIMP CompleteConnectTerminal();

    //
    // ITFileTrack methods
    //

    virtual HRESULT STDMETHODCALLTYPE get_Format(OUT AM_MEDIA_TYPE **ppmt);

    virtual HRESULT STDMETHODCALLTYPE put_Format(IN const AM_MEDIA_TYPE *pmt);

    virtual HRESULT STDMETHODCALLTYPE get_ControllingTerminal(
            OUT ITTerminal **ppControllingTerminal
            );

    STDMETHOD(get_AudioFormatForScripting)(
		OUT ITScriptableAudioFormat** ppAudioFormat
		);

    STDMETHOD(put_AudioFormatForScripting)(
		IN	ITScriptableAudioFormat* pAudioFormat
		);

/*
    STDMETHOD(get_VideoFormatForScripting)(
		OUT ITScriptableVideoFormat** ppVideoFormat
		);

    STDMETHOD(put_VideoFormatForScripting)(
		IN	ITScriptableVideoFormat* pVideoFormat
		);

    STDMETHOD(get_EmptyVideoFormatForScripting)(
        OUT ITScriptableVideoFormat** ppVideoFormat
        );

*/

    STDMETHOD(get_EmptyAudioFormatForScripting)(
        OUT ITScriptableAudioFormat** ppAudioFormat
        );


    //
    // ITPluggableTerminalInitialization method
    //

    virtual HRESULT STDMETHODCALLTYPE InitializeDynamic(
        IN  IID                   iidTerminalClass,
        IN  DWORD                 dwMediaType,
        IN  TERMINAL_DIRECTION    Direction,
        IN  MSP_HANDLE            htAddress
        );



    //
    // ITPluggableTerminalEventSinkRegistration methods
    //

    STDMETHOD(RegisterSink)(
        IN  ITPluggableTerminalEventSink *pSink
        );

    STDMETHOD(UnregisterSink)();


    //
    // need to override these so we can notify the parent of addrefs and releases
    //

    ULONG InternalAddRef();

    ULONG InternalRelease();



    //
    // a helper method used by file recording terminal to let us know who the parent is
    //
    
    HRESULT SetParent(IN CFileRecordingTerminal *pParentTerminal, LONG *pCurrentRefCount);

   
    //
    // a method used by file recording terminal to fire events
    //
    
    HRESULT FireEvent(
            TERMINAL_MEDIA_STATE tmsState,
            FT_STATE_EVENT_CAUSE ftecEventCause,
            HRESULT hrErrorCode
            );


    
    //
    // a helper method called by recording terminal to pass us a filter to use
    //

    HRESULT SetFilter(CBRenderFilter *pRenderingFilter);


    //
    // a helper method called by recording terminal
    //

    HRESULT GetFilter(CBRenderFilter **ppRenderingFilter);


private:
    

    
    //
    // a private helper method that returns CFileRecordingFilter * pointer to the pin
    //

    CBRenderPin *GetCPin();


private:


    //
    // pointer to the parent. this is needed for refcounting
    //

    CFileRecordingTerminal *m_pParentTerminal;


    //
    // sink for firing terminal events
    //

    ITPluggableTerminalEventSink* m_pEventSink; 

};

#endif // !defined(AFX_PLAYBACKTRACKTERMINAL_H__4FD57959_2DF1_4F78_AB2C_5E365EFD9CC6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\multitrack\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\multitrack\multitrackterminal.cpp ===
// MultiTrackTerminal.cpp: implementation of the CMultiTrackTerminal class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "MultiTrackTerminal.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMultiTrackTerminal::CMultiTrackTerminal()
    :m_nNumberOfTracks(0)
{
    LOG((MSP_TRACE, 
        "CMultiTrackTerminal::CMultiTrackTerminal[%p] - enter", this));

    LOG((MSP_TRACE, 
        "CMultiTrackTerminal::CMultiTrackTerminal - finish"));
}

CMultiTrackTerminal::~CMultiTrackTerminal()
{
    LOG((MSP_TRACE, 
        "CMultiTrackTerminal::~CMultiTrackTerminal - enter"));

    ReleaseAllTracks();

    
    //
    // we should have no tracks at this point, and counter should be in sync
    //

    TM_ASSERT(m_nNumberOfTracks == 0);

    LOG((MSP_TRACE, 
        "CMultiTrackTerminal::~CMultiTrackTerminal - finish"));

}


HRESULT CMultiTrackTerminal::get_TrackTerminals(OUT VARIANT *pVariant)
{

    LOG((MSP_TRACE, "CMultiTrackTerminal::get_TrackTerminals[%p] - enter. pVariant [%p]", this, pVariant));


    //
    // Check parameters
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::get_TrackTerminals - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }


    //
    // the caller needs to provide us with an empty variant
    //

    if (pVariant->vt != VT_EMPTY)
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::get_TrackTerminals - "
            "variant argument is not empty"));

        return E_UNEXPECTED;
    }


    //
    // create the collection object - see mspbase\mspcoll.h
    //

    HRESULT hr = S_OK;
    

    typedef CTapiIfCollection<ITTerminal*> TerminalCollection;
    
    CComObject<TerminalCollection> *pCollection = NULL;

    
    hr = CComObject<TerminalCollection>::CreateInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::get_TrackTerminals - "
            "can't create collection - exit %lx", hr));

        return hr;
    }


    //
    // get the Collection's IDispatch interface
    //

    IDispatch *pDispatch = NULL;

    hr = pCollection->QueryInterface(IID_IDispatch,
                                    (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::get_TrackTerminals - "
            "QI for IDispatch on collection failed - exit %lx", hr));

        delete pCollection;

        return hr;
    }



    {

        //
        // access data member array in a lock
        //

        CLock lock(m_lock);


        //
        // Init the collection using an iterator -- pointers to the beginning and
        // the ending element plus one.
        //

        hr = pCollection->Initialize( m_TrackTerminals.GetSize(),
                                      m_TrackTerminals.GetData(),
                                      m_TrackTerminals.GetData() + m_TrackTerminals.GetSize() );
    }


    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::get_TrackTerminals - "
            "Initialize on collection failed - exit %lx", hr));
        
        pDispatch->Release();
        delete pCollection;

        return hr;
    }


    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "CMultiTrackTerminal::get_TrackTerminals - "
        "placing IDispatch value %p in variant", pDispatch));

    VariantInit(pVariant);

    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;


    LOG((MSP_TRACE, "CMultiTrackTerminal::get_TrackTerminals - exit S_OK"));
    

    return S_OK;
}


HRESULT CMultiTrackTerminal::EnumerateTrackTerminals(
		    IEnumTerminal **ppEnumTerminal
        )
{

    LOG((MSP_TRACE, 
        "CMultiTrackTerminal::EnumerateTrackTerminals entered. ppEnumTerminal[%p]", ppEnumTerminal));

    
    //
    // check arguments
    //

    if (IsBadWritePtr(ppEnumTerminal, sizeof(IEnumTerminal*)))
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::EnumerateTrackTerminals ppEnumTerminal is a bad pointer"));
        return E_POINTER;
    }

    
    //
    // don't return garbage
    //

    *ppEnumTerminal = NULL;



    typedef _CopyInterface<ITTerminal> CCopy;
    typedef CSafeComEnum<IEnumTerminal, &IID_IEnumTerminal,
                ITTerminal *, CCopy> CEnumerator;

    HRESULT hr = S_OK;

    
    //
    // create enumeration object 
    //

    CMSPComObject<CEnumerator> *pEnum = NULL;

    hr = CMSPComObject<CEnumerator>::CreateInstance(&pEnum);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::EnumerateTrackTerminals Could not create enumerator object, %x", hr));
        return hr;
    }


    //
    // get pEnum's IID_IEnumTerminal interface
    //

    hr = pEnum->QueryInterface(IID_IEnumTerminal, (void**)ppEnumTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::EnumerateTrackTerminals query enum interface failed, %x", hr));

        *ppEnumTerminal = NULL;


        //
        // don't yet have outstanding reference count on pEnum, so delete it.
        //
        // note: this can lead to a problem if FinalRelease of pEnum is 
        // supposed to deallocate resources that have been allocated in its
        // constructor
        //

        delete pEnum;
        return hr;
    }


    // 
    // access data member track terminal list from a lock
    //

    {
        CLock lock(m_lock);


        // The CSafeComEnum can handle zero-sized array.

        hr = pEnum->Init(
            m_TrackTerminals.GetData(),                        // the begin itor
            m_TrackTerminals.GetData() + m_TrackTerminals.GetSize(),  // the end itor, 
            NULL,                                       // IUnknown
            AtlFlagCopy                                 // copy the data.
            );
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMultiTrackTerminal::EnumerateTrackTerminals init enumerator object failed, %x", hr));
        (*ppEnumTerminal)->Release();
        *ppEnumTerminal= NULL;
        return hr;
    }


    LOG((MSP_TRACE, "CMultiTrackTerminal::EnumerateTrackTerminals - exit S_OK"));

    return hr;
}


HRESULT CMultiTrackTerminal::get_MediaTypesInUse(
		OUT long *plMediaTypesInUse
		)
{
    
    LOG((MSP_TRACE, "CMultiTrackTerminal::get_MediaTypesInUse - enter. "
                    "plMediaTypesInUse [%p]", plMediaTypesInUse));
    
    if (IsBadWritePtr(plMediaTypesInUse, sizeof(long)))
    {
        LOG((MSP_ERROR, 
            "CMultiTrackTerminal::get_MediaTypesInUse plMediaTypesInUse "
            "does not point to a valid long"));

        return E_POINTER;
    }


    //
    // enumerate all the terminal and OR their media types and media types in use
    //

    long lMediaTypesInUse = 0;


    //
    // access data member array in a lock
    //

    CLock lock(m_lock);



    for ( int i = 0; i < m_TrackTerminals.GetSize(); i++ )
    {

        long lMT = 0;


        // 
        // is the track terminal a multitrack terminal itself?
        //

        ITMultiTrackTerminal *pMTT = NULL;

        HRESULT hr = m_TrackTerminals[i]->QueryInterface(IID_ITMultiTrackTerminal,
                                            (void**)&pMTT);

        if (SUCCEEDED(hr))
        {

            //
            // this is a multitrack terminal. get its mediatypes in use
            //
            
            hr = pMTT->get_MediaTypesInUse(&lMT);

            
            pMTT->Release();
            pMTT = NULL;


            if (FAILED(hr))
            {

                //
                // failed to get track's media types in use. 
                // continue to the next track 
                //


                LOG((MSP_ERROR, 
                    "CMultiTrackTerminal::get_MediaTypesInUse "
                    "get_MediaTypesInUse on terminal (%d) failed.", i));

                continue;

            }

        }
        else
        {
            //
            // the track is not a multitrack terminal, so use its ITTerminal
            // interface to get its media type
            //

            hr = m_TrackTerminals[i]->get_MediaType(&lMT);

            if (FAILED(hr))
            {

                //
                // failed to get track's media types in use.
                // continue to the next track
                //

                LOG((MSP_ERROR, 
                    "CMultiTrackTerminal::get_MediaTypesInUse "
                    "get_MediaType on terminal (%d) failed.", i));

                continue;

            }

        }

        
        LOG((MSP_TRACE, 
            "CMultiTrackTerminal::get_MediaTypesInUse "
            "track terminal (%d) has media type of %lx.", i, lMT));

        lMediaTypesInUse |= lMT;
    }


    *plMediaTypesInUse = lMediaTypesInUse;

    LOG((MSP_TRACE, "CMultiTrackTerminal::get_EnumerateTrackTerminals - "
        "exit S_OK. MediaTypeInUse %lx", lMediaTypesInUse));

    return S_OK;

}


HRESULT CMultiTrackTerminal::get_DirectionsInUse(
		OUT TERMINAL_DIRECTION *ptdDirectionsInUse
		)
{
    LOG((MSP_TRACE, "CMultiTrackTerminal::get_DirectionsInUse - enter. plDirectionsInUsed[%p]", ptdDirectionsInUse));

    
    if (IsBadWritePtr(ptdDirectionsInUse, sizeof(TERMINAL_DIRECTION)))
    {
        LOG((MSP_ERROR, 
            "CMultiTrackTerminal::get_DirectionsInUse plDirectionsInUsed"
            "does not point to a valid long"));

        return E_POINTER;
    }


    //
    // don't return gardbage
    //

    *ptdDirectionsInUse = TD_NONE;

    //
    // enumerate all the terminal and OR their media types and media types in use
    //

    TERMINAL_DIRECTION tdDirInUse = TD_NONE;


    //
    // access data member array in a lock
    //

    CLock lock(m_lock);


    for ( int i = 0; i < m_TrackTerminals.GetSize(); i++ )
    {

        TERMINAL_DIRECTION td = TD_NONE;


        // 
        // is the track terminal a multitrack terminal itself?
        //

        ITMultiTrackTerminal *pMTT = NULL;

        HRESULT hr = m_TrackTerminals[i]->QueryInterface(IID_ITMultiTrackTerminal, 
                                            (void**)&pMTT);

        if (SUCCEEDED(hr))
        {

            //
            // this is a multitrack terminal. get its mediatypes in use
            //
            
            hr = pMTT->get_DirectionsInUse(&td);

            
            pMTT->Release();
            pMTT = NULL;


            if (FAILED(hr))
            {

                //
                // failed to get track's media types in use. 
                // continue to the next track 
                //


                LOG((MSP_ERROR, 
                    "CMultiTrackTerminal::get_DirectionsInUse "
                    "get_MediaTypesInUse on terminal (%d) failed.", i));

                continue;

            }

        }
        else
        {
            //
            // the track is not a multitrack terminal, so use its ITTerminal
            // interface to get its direction
            //

            hr = m_TrackTerminals[i]->get_Direction(&td);

            if (FAILED(hr))
            {

                //
                // failed to get track's media types in use.
                // continue to the next track
                //

                LOG((MSP_ERROR, 
                    "CMultiTrackTerminal::get_DirectionsInUse "
                    "get_MediaType on terminal (%d) failed.", i));

                continue;

            }

        }

        
        LOG((MSP_TRACE, 
            "CMultiTrackTerminal::get_DirectionsInUse "
            "track terminal (%d) has media type of %lx.", i, td));

        //
        // based on directions we have collected so far, and on the direction that we just got, calculate total direction
        //

        switch (tdDirInUse)
        {
            
        case TD_NONE:

            tdDirInUse = td;

            break;


        case TD_RENDER:
                
            if ( (td != TD_RENDER) && (td != TD_NONE) )
            {
                tdDirInUse = TD_MULTITRACK_MIXED;
            }

            break;

        case TD_CAPTURE:
                
            if ( (td != TD_CAPTURE) && (td != TD_NONE) )
            {
                tdDirInUse = TD_MULTITRACK_MIXED;
            }

            break;
        
        } // switch


        if ( TD_MULTITRACK_MIXED == tdDirInUse )
        {

            //
            // if the current direction is mixed, then break -- there is no point in looking further
            //
            
            break;
        }
        

    } // for (track terminals)


    *ptdDirectionsInUse = tdDirInUse;


    LOG((MSP_TRACE, "CMultiTrackTerminal::get_DirectionsInUse - exit S_OK. "
        "plDirectionsInUsed = %lx", *ptdDirectionsInUse));

    return S_OK;
}


///////////////////////////////////////////////////////
//
//  CMultiTrackTerminal::AddTrackTerminal
//
//  adds the terminal that is passed in as the argument to the 
//  list of track terminals managed by this multitrack terminal
//
//  Note: this function increments refcount of the terminal that is being added to the list
//

HRESULT CMultiTrackTerminal::AddTrackTerminal(ITTerminal *pTrackTerminalToAdd)
{
 
    LOG((MSP_TRACE, "CMultiTrackTerminal::AddTrackTerminal[%p] - enter. "
        "pTrackTerminalToAdd = %p", this, pTrackTerminalToAdd));


    if (IsBadReadPtr(pTrackTerminalToAdd, sizeof(ITTerminal*)))
    {
        LOG((MSP_TRACE, "CMultiTrackTerminal::AddTrackTerminal - invalid ptr"));

        return E_POINTER;
    }


    {
        //
        // access data member array in a lock
        //

        CLock lock(m_lock);


        //
        // we use a special lock to increment track counter, to avoid deadlocks
        // on reference counting
        //

        Lock();


        //
        // add track terminal to the array
        //

        if (!m_TrackTerminals.Add(pTrackTerminalToAdd))
        {
            LOG((MSP_ERROR, "CMultiTrackTerminal::AddTrackTerminal - "
                "failed to add track to the array of terminals"));

            return E_OUTOFMEMORY;
        }



        m_nNumberOfTracks++;


        //
        // the counter should never ever go out of sync
        //
        
        TM_ASSERT(m_nNumberOfTracks == m_TrackTerminals.GetSize());

        Unlock();
    }

    
    //
    // we are keeping a reference to the terminal, so increment refcount
    //

    pTrackTerminalToAdd->AddRef();


    LOG((MSP_TRACE, "CMultiTrackTerminal::AddTrackTerminal - finished"));

    return S_OK;
}


///////////////////////////////////////////////////////
//
//  CMultiTrackTerminal::RemoveTrackTerminal
//
//  removes the terminal from the list of track terminals 
//  managed by this multitrack terminal
//
//  if success, decrementing refcount on the track terminal
//

HRESULT CMultiTrackTerminal::RemoveTrackTerminal(ITTerminal *pTrackTerminalToRemove)
{
 
    LOG((MSP_TRACE, "CMultiTrackTerminal::RemoveTrackTerminal[%p] - enter"
        "pTrackTerminalToRemove = %p", this, pTrackTerminalToRemove));



    {

        //
        // access data member array in a lock
        //

        CLock lock(m_lock);


        //
        // decrement track counter in a special lock to prevent deadlocks 
        // with reference counting
        //

        Lock();


        //
        // remove track from the array
        //

        if (!m_TrackTerminals.Remove(pTrackTerminalToRemove))
        {
            LOG((MSP_ERROR, "CMultiTrackTerminal::RemoveTrackTerminal - "
                "failed to remove from the array of terminals"));

            return E_INVALIDARG;
        }

        m_nNumberOfTracks--;


        //
        // the counter should never ever go out of sync
        //
        
        TM_ASSERT(m_nNumberOfTracks == m_TrackTerminals.GetSize());

        Unlock();


    }


    //
    // we are releasing a reference to the terminal, so decrement refcount
    //

    pTrackTerminalToRemove->Release();


    LOG((MSP_TRACE, "CMultiTrackTerminal::RemoveTrackTerminal- finished"));

    return S_OK;
}


///////////////////////////////////////////////////////
//
//  CMultiTrackTerminal::ReleaseAllTracks
//
//  removes all tracks from the list of managed track terminals 
//  and Release's them
//  
//

HRESULT CMultiTrackTerminal::ReleaseAllTracks()
{

    LOG((MSP_TRACE, "CMultiTrackTerminal::ReleaseAllTracks[%p] - enter", this));


    {
        //
        // access data member array in a lock
        //

        CLock lock(m_lock);

        int nNumberOfTerminalsInArray = m_TrackTerminals.GetSize();

        for (int i = 0; i <  nNumberOfTerminalsInArray; i++)
        {

            //
            // release and remove the first terminal in the array
            //

            LOG((MSP_TRACE, "CMultiTrackTerminal::ReleaseAllTracks - releasing track [%p]", m_TrackTerminals[0]));
            
            m_TrackTerminals[0]->Release();


            //
            // remove element from the array and decrement track counter in a 
            // special lock to prevent deadlocks with reference counting
            //

            Lock();


            m_TrackTerminals.RemoveAt(0);


            m_nNumberOfTracks--;


            //
            // the counter should never ever go out of sync
            //
    
            TM_ASSERT(m_nNumberOfTracks == m_TrackTerminals.GetSize());

            Unlock();
        }

        
        //
        // we should have cleared the array
        //

        TM_ASSERT(0 == m_TrackTerminals.GetSize());
    }


    LOG((MSP_TRACE, "CMultiTrackTerminal::ReleaseAllTracks - finished"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CMultiTrackTerminal::InternalAddRef
//
// keep track of refcount. 
// 
// we need to adjust refcount with the information on the number of tracks 
// that we are managing.
//

ULONG CMultiTrackTerminal::InternalAddRef()
{
    // LOG((MSP_TRACE, "CMultiTrackTerminal::InternalAddRef[%p] - enter.", this));


    LONG lReturnValue = InterlockedIncrement(&m_dwRef);

    lReturnValue -= CountTracks();

    
    // LOG((MSP_TRACE, "CMultiTrackTerminal::InternalAddRef - finish. returning %ld", lReturnValue));

    return lReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//
// CMultiTrackTerminal::InternalRelease
//
// keep track of refcount. 
// return 0 when there are no outstanding references to me or my children
//

ULONG CMultiTrackTerminal::InternalRelease()
{
    // LOG((MSP_TRACE, "CMultiTrackTerminal::InternalRelease[%p] - enter", this));


    LONG lReturnValue = InterlockedDecrement(&m_dwRef);
       
    lReturnValue -= CountTracks();


    // LOG((MSP_TRACE, "CMultiTrackTerminal::InternalRelease - finish. returning %ld", lReturnValue));

    return lReturnValue;

}

//////////////////////////////////////////////////////////////////////
//
// CMultiTrackTerminal::ChildAddRef
//
// this method is called by a track terminal when it is AddRef'd,
// so the File Rec terminal can keep track of its children's refcounts
//

void CMultiTrackTerminal::ChildAddRef()
{
    // LOG((MSP_TRACE, "CMultiTrackTerminal::ChildAddRef[%p] - enter.", this));

    AddRef();

    // LOG((MSP_TRACE, "CMultiTrackTerminal::ChildAddRef - finish."));
}



//////////////////////////////////////////////////////////////////////
//
// CMultiTrackTerminal::ChildRelease
//
// this method is called by a track terminal when it is released,
// so the File Rec terminal can keep track of its children's refcounts
//

void CMultiTrackTerminal::ChildRelease()
{
    // LOG((MSP_TRACE, "CMultiTrackTerminal::ChildRelease[%p] - enter.", this));

    Release();
    
    // LOG((MSP_TRACE, "CMultiTrackTerminal::ChildRelease - finish."));
}


//////////////////////////////////////////////////////////////////////
//
// CMultiTrackTerminal::CountTracks
//
// this method returns the number of tracks managed by this parent
//

int CMultiTrackTerminal::CountTracks()
{
    // LOG((MSP_TRACE, "CMultiTrackTerminal::CountTracks[%p] - enter", this));


    //
    // this lock is only used to protect accesses to this var. this is
    // needed to prevent deadlocks when
    // 
    // one thread locks the parent 
    // terminal and enumerates the tracks (thus getting their locks) 
    //
    // and 
    //
    // another thread addrefs or releases a track. this locks the 
    // track and attempts to notify the parent of the child's refcount 
    // change. if this thread tries to lock the parent, we would have a 
    // deadlock
    //
    // so instead of locking the parent on addref and release, we only use
    // this "addref/release" lock
    // 
    
    
    Lock();

    int nNumberOfTracks = m_nNumberOfTracks;

    Unlock();


    // LOG((MSP_TRACE, "CMultiTrackTerminal::CountTracks - finished. NumberOfTracks = %d", nNumberOfTracks));

    return nNumberOfTracks;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\formats.cpp ===
#include "stdafx.h"
#include "formats.h"

CTAudioFormat::CTAudioFormat() :
    m_pFTM(NULL)
{
}

CTAudioFormat::~CTAudioFormat()
{
    if( m_pFTM )
    {
        m_pFTM->Release();
        m_pFTM = NULL;
    }
}

HRESULT CTAudioFormat::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CTAudioFormat::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTAudioFormat::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CTAudioFormat::FinalConstruct - exit S_OK"));

    return S_OK;
}


HRESULT CTAudioFormat::get_Channels(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::get_Channels enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTAudioFormat::get_Channels exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Return value
	//

	*pVal = m_wfx.nChannels;

    LOG((MSP_TRACE, "CTAudioFormat::get_Channels exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::put_Channels(
	IN	const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::put_Channels enter"));
    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_wfx.nChannels = (WORD)nNewVal;

    LOG((MSP_TRACE, "CTAudioFormat::put_Channels exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::get_SamplesPerSec(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::get_SamplesPerSec enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTAudioFormat::get_SamplesPerSec exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Return value
	//

	*pVal = m_wfx.nSamplesPerSec;

    LOG((MSP_TRACE, "CTAudioFormat::get_SamplesPerSec exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::put_SamplesPerSec(
	IN	const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::put_SamplesPerSec enter"));
    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_wfx.nSamplesPerSec = (DWORD)nNewVal;

    LOG((MSP_TRACE, "CTAudioFormat::put_SamplesPerSec exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::get_AvgBytesPerSec(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::get_AvgBytesPerSec enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTAudioFormat::get_AvgBytesPerSec exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Return value
	//

	*pVal = m_wfx.nAvgBytesPerSec;

    LOG((MSP_TRACE, "CTAudioFormat::get_AvgBytesPerSec exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::put_AvgBytesPerSec(
	IN	const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::put_AvgBytesPerSec enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_wfx.nAvgBytesPerSec = (DWORD)nNewVal;

    LOG((MSP_TRACE, "CTAudioFormat::put_AvgBytesPerSec exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::get_BlockAlign(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::get_BlockAlign enter"));

	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTAudioFormat::get_BlockAlign exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Return value
	//

	*pVal = m_wfx.nBlockAlign;

    LOG((MSP_TRACE, "CTAudioFormat::get_BlockAlign exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::put_BlockAlign(
	IN	const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::put_BlockAlign enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_wfx.nBlockAlign = (WORD)nNewVal;

    LOG((MSP_TRACE, "CTAudioFormat::put_BlockAlign exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::get_BitsPerSample(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::get_BitsPerSample enter"));

	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTAudioFormat::get_BitsPerSample exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Return value
	//

	*pVal = m_wfx.wBitsPerSample;

    LOG((MSP_TRACE, "CTAudioFormat::get_BitsPerSample exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::put_BitsPerSample(
	IN	const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::put_BitsPerSample enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_wfx.wBitsPerSample = (WORD)nNewVal;

    LOG((MSP_TRACE, "CTAudioFormat::put_BitsPerSample exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::get_FormatTag(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::get_FormatTag enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTAudioFormat::get_FormatTag exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Return value
	//

	*pVal = m_wfx.wFormatTag;

    LOG((MSP_TRACE, "CTAudioFormat::get_FormatTag exit S_OK"));
	return S_OK;
}

HRESULT CTAudioFormat::put_FormatTag(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTAudioFormat::put_FormatTag enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_wfx.wFormatTag = (WORD)nNewVal;

    LOG((MSP_TRACE, "CTAudioFormat::put_FormatTag exit S_OK"));
	return S_OK;
}

/*

//
// CTVideoFormat
//

CTVideoFormat::CTVideoFormat() :
    m_pFTM( NULL )
{
}

CTVideoFormat::~CTVideoFormat()
{
    if( m_pFTM )
    {
        m_pFTM->Release();
        m_pFTM = NULL;
    }
}

HRESULT CTVideoFormat::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CTVideoFormat::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTVideoFormat::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CTVideoFormat::FinalConstruct - exit S_OK"));

    return S_OK;
}

HRESULT CTVideoFormat::get_BitRate(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_BitRate enter"));

	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_BitRate exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.dwBitRate;

    LOG((MSP_TRACE, "CTVideoFormat::get_BitRate exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_BitRate(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_BitRate enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.dwBitRate = nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_BitRate exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_BitErrorRate(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_BitErrorRate enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_BitErrorRate exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.dwBitErrorRate;

    LOG((MSP_TRACE, "CTVideoFormat::get_BitErrorRate exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_BitErrorRate(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_BitErrorRate enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.dwBitErrorRate = nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_BitErrorRate exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_AvgTimePerFrame(
	OUT double* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_AvgTimePerFrame enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(double)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_AvgTimePerFrame exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = (double)m_vih.AvgTimePerFrame;

    LOG((MSP_TRACE, "CTVideoFormat::get_AvgTimePerFrame exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_AvgTimePerFrame(
	IN const double nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_AvgTimePerFrame enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.AvgTimePerFrame = (REFERENCE_TIME)nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_AvgTimePerFrame exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_Width(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_Width enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_Width exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.bmiHeader.biWidth;

    LOG((MSP_TRACE, "CTVideoFormat::get_Width exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_Width(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_Width enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.bmiHeader.biWidth = nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_Width exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_Height(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_Height enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_Height exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.bmiHeader.biHeight;

    LOG((MSP_TRACE, "CTVideoFormat::get_Height exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_Height(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_Height enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.bmiHeader.biHeight = nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_Height exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_BitCount(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_BitCount enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_BitCount exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.bmiHeader.biBitCount;

    LOG((MSP_TRACE, "CTVideoFormat::get_BitCount exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_BitCount(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_BitCount enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.bmiHeader.biBitCount = (WORD)nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_BitCount exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_Compression(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_Compression enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::get_Compresion exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.bmiHeader.biCompression;

    LOG((MSP_TRACE, "CTVideoFormat::get_Compression exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_Compression(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_Compression enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.bmiHeader.biCompression = nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_Compression exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::get_SizeImage(
	OUT long* pVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::get_SizeImage enter"));
	//
	// Validates argument
	//

	if( IsBadWritePtr( pVal, sizeof(long)) )
	{
        LOG((MSP_ERROR, "CTVideoFormat::put_SizeImage exit"
			"pVal is a bad pointer. returns E_POINTER"));
        return E_POINTER;
	}

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Returns value
	//

	*pVal = m_vih.bmiHeader.biSizeImage;

    LOG((MSP_TRACE, "CTVideoFormat::get_SizeImage exit S_OK"));
	return S_OK;
}

HRESULT CTVideoFormat::put_SizeImage(
	IN const long nNewVal
	)
{
    LOG((MSP_TRACE, "CTVideoFormat::put_SizeImage enter"));

    //
    // Critical section
    //

    CLock lock(m_Lock);

	//
	// Set value
	//

	m_vih.bmiHeader.biSizeImage = nNewVal;

    LOG((MSP_TRACE, "CTVideoFormat::put_SizeImage exit S_OK"));
	return S_OK;
}

*/

//eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\multitrack\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_MULTITRACK_STDAFX_DOT_H_)
#define _MULTITRACK_STDAFX_DOT_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <mspbase.h>
#include "tm.h"


#endif // !defined(_MULTITRACK_STDAFX_DOT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\recordunit.h ===
#ifndef _RECORDUNIT_DOT_H_INCLUDED_

#define _RECORDUNIT_DOT_H_INCLUDED_


///////////////////////////////////////////////////////////////////
//
// RecordUnit.h
//
//

class CBSourceFilter;
class CBRenderFilter;
class CFileRecordingTerminal;

class CRecordingUnit
{

public:


    //
    // create graph and stuff
    //

    HRESULT Initialize(CFileRecordingTerminal *pOwnerTerminal);


    //
    // communicate file name.
    //

    HRESULT put_FileName(IN BSTR bstrFileName, IN BOOL bTruncateIfPresent);


    //
    // get a filter to be used by the recording terminal. 
    //
    // this also causes a new source pin to be created on the source filter.
    // if the source filter did not exist prior to the call, it will be created
    // and added to the graph.
    //

    HRESULT CreateRenderingFilter(OUT CBRenderFilter **ppRenderingFilter);


    //
    // connect a source filter that belongs to this rendering filter
    //

    HRESULT ConfigureSourceFilter(IN CBRenderFilter *pRenderingFilter);


    //
    // this function disconnects and removes the source pin corresponding to this
    // rendering filter from the source filter.
    //

    HRESULT RemoveRenderingFilter(IN CBRenderFilter *pRenderingFilter);


    //
    // start the filter graph
    //

    HRESULT Start();


    //
    // Stop the filter graph
    //

    HRESULT Stop();


    //
    // Pause the filter graph
    //

    HRESULT Pause();


    //
    // get filter graph's state
    //

    HRESULT GetState(OAFilterState *pGraphState);

    
    //
    // transition recording unit into new state
    //

    HRESULT ChangeState(OAFilterState DesiredState);


    //
    // cleanup
    //

    HRESULT Shutdown();


    //
    // contstructor/destructor
    //

    CRecordingUnit();

    ~CRecordingUnit();


private:

    HRESULT ConnectFilterToMUX(CBSourceFilter *pSourceFilter);

    
    //
    // the callback called on a filter graph event
    //

    static VOID CALLBACK HandleGraphEvent( IN VOID *pContext,
                                           IN BOOLEAN bReason);
    
private:

    //
    // direct show filter graph
    //

    IGraphBuilder *m_pIGraphBuilder;

    
    //
    // critical section used for thread syncronization
    //

    CRITICAL_SECTION m_CriticalSection;


    //
    // a collection of source filters for the recording graph itself
    //

    // CMSPArray<CBSourceFilter*> m_SourceFilters;


    //
    // the mux filter
    //

    IBaseFilter *m_pMuxFilter;


    //
    // owner terminal
    //

    CFileRecordingTerminal *m_pRecordingTerminal;


    HANDLE                  m_hGraphEventHandle;

};


#endif // _RECORDUNIT_DOT_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\recordunit.cpp ===
#include "stdafx.h"

#include "RecordUnit.h"

#include "SourcePinFilter.h"
#include "RendPinFilter.h"

#include "FileRecordingTerminal.h"

///////////////////////////////////////////////////////////////////////////////
//
// event handling logic
//

//static 
VOID CALLBACK CRecordingUnit::HandleGraphEvent(IN VOID *pContext,
                                               IN BOOLEAN bReason)
{
    LOG((MSP_TRACE, "CRecordingUnit[%p]::HandleGraphEvent - enter.", pContext));


    //
    // get recording unit pointer out of context
    //

    CRecordingUnit *pRecordingUnit = 
        static_cast<CRecordingUnit*>(pContext);

    if ( IsBadReadPtr(pRecordingUnit, sizeof(CRecordingUnit)) )
    {
        LOG((MSP_ERROR, "CRecordingUnit::HandleGraphEvent - bad context"));


        //
        // the callbacks must be disabled before recording unit goes away. if
        // this is not the case, something went wrong. debug.
        //

        TM_ASSERT(FALSE);

        return;
    }


    //
    // the graph was not initialized. something went wrong.
    //

    if (NULL == pRecordingUnit->m_pIGraphBuilder)
    {
        LOG((MSP_ERROR, "CRecordingUnit::HandleGraphEvent - not initialized. filter graph null"));


        //
        // this should not happen. the graph is not to be released until callback is completed
        //

        TM_ASSERT(FALSE);

        return;
    }


    //
    // get the media event interface so we can retrieve the event
    //

    IMediaEvent *pMediaEvent = NULL;

    HRESULT hr = 
        pRecordingUnit->m_pIGraphBuilder->QueryInterface(IID_IMediaEvent,
                                                         (void**)&pMediaEvent);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CRecordingUnit::HandleGraphEvent - failed to qi graph for IMediaEvent"));

        return;
    }


    //
    // get the terminal on which to fire the event
    //

    //
    // the terminal is guaranteed to be around while the callback is active
    //

    CFileRecordingTerminal *pRecordingterminal = pRecordingUnit->m_pRecordingTerminal;


    //
    // get the actual event
    //
    
    long     lEventCode = 0;
    LONG_PTR lParam1 = 0;
    LONG_PTR lParam2 = 0;

    hr = pMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);

    if (FAILED(hr))
    {
        LOG((MSP_WARN, "CRecordingUnit::HandleGraphEvent - failed to get the event. hr = %lx", hr));

        pMediaEvent->Release();
        pMediaEvent = NULL;

        return;
    }


    LOG((MSP_EVENT, "CRecordingUnit::HandleGraphEvent - received event code:[0x%lx] param1:[%p] param2:[%p]",
        lEventCode, lParam1, lParam2));


    //
    // ask file terminal to handle the event
    //

    hr = pRecordingterminal->HandleFilterGraphEvent(lEventCode, lParam1, lParam2);


    //
    // free event parameters
    //

    HRESULT hrFree = pMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);

    pMediaEvent->Release();
    pMediaEvent = NULL;


    //
    // did handlefiltergraphevent succeed?
    //

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CRecordingUnit::HandleGraphEvent - failed to fire event on the terminal. hr = %lx",
            hr));

        return;
    }


    //
    // did event free succeed?
    //

    if (FAILED(hrFree))
    {
        LOG((MSP_ERROR,
            "CRecordingUnit::HandleGraphEvent - failed to free event. hr = %lx",
            hr));

        return;
    }

    LOG((MSP_TRACE, "CRecordingUnit::HandleGraphEvent - exit"));
}


///////////////////////////////////////////////////////////////////////////////


CRecordingUnit::CRecordingUnit()
    :m_pIGraphBuilder(NULL),
    m_hGraphEventHandle(NULL),
    m_pMuxFilter(NULL),
    m_pRecordingTerminal(NULL)
{
    LOG((MSP_TRACE, "CRecordingUnit::CRecordingUnit[%p] - enter. ", this));
    LOG((MSP_TRACE, "CRecordingUnit::CRecordingUnit - exit"));
}


///////////////////////////////////////////////////////////////////////////////

CRecordingUnit::~CRecordingUnit()
{
    LOG((MSP_TRACE, "CRecordingUnit::~CRecordingUnit[%p] - enter. ", this));


    //
    // the unit should have been shut down. if it was not, fire assert, and shutdown
    //

    if (NULL != m_pIGraphBuilder)
    {
        
        TM_ASSERT(FALSE);

        Shutdown();
    }

    LOG((MSP_TRACE, "CRecordingUnit::~CRecordingUnit - exit"));
}


HRESULT CRecordingUnit::Initialize(CFileRecordingTerminal *pRecordingTerminal)
{

    LOG((MSP_TRACE, "CRecordingUnit::Initialize[%p] - enter. ", this));

    
    //
    // initialize should only be called once. it it is not, there is a bug in
    // our code
    //

    if (NULL != m_pIGraphBuilder)
    {
        LOG((MSP_ERROR, "CRecordingUnit::Initialize - already initialized"));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // attempt to initialize critical section
    //
    
    BOOL bCSInitSuccess = InitializeCriticalSectionAndSpinCount(&m_CriticalSection, 0);

    if (!bCSInitSuccess)
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::Initialize - failed to initialize critical section. LastError=%ld", 
            GetLastError()));


        return E_OUTOFMEMORY;
    }


    //
    // create filter graph
    //

    HRESULT hr = CoCreateInstance(
            CLSID_FilterGraph,     
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IGraphBuilder,
            (void **) &m_pIGraphBuilder
            );


    if (FAILED(hr))
    {

        LOG((MSP_ERROR, "CRecordingUnit::Initialize - failed to create filter graph. hr = %lx", hr));

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }


    //
    // register for filter graph events
    //

    IMediaEvent *pMediaEvent = NULL;

    hr = m_pIGraphBuilder->QueryInterface(IID_IMediaEvent, (void**)&pMediaEvent);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CRecordingUnit::HandleGraphEvent - failed to qi graph for IMediaEvent, hr = %lx", hr));

        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }


    //
    // get filter graph's event
    //

    HANDLE hEvent = NULL;

    hr = pMediaEvent->GetEventHandle((OAEVENT*)&hEvent);

    pMediaEvent->Release();
    pMediaEvent = NULL;

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CRecordingUnit::HandleGraphEvent - failed to get graph's event. hr = %lx", hr));

        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }


   
    BOOL fSuccess = RegisterWaitForSingleObject(
                    &m_hGraphEventHandle,          // pointer to the returned handle
                    hEvent,                // the event handle to wait for.
                    CRecordingUnit::HandleGraphEvent,    // the callback function.
                    this,                  // the context for the callback.
                    INFINITE,              // wait forever.
                    WT_EXECUTEINWAITTHREAD // use the wait thread to call the callback.
                    );

    if ( ! fSuccess )
    {

        LOG((MSP_ERROR, "CRecordingUnit::HandleGraphEvent - failed to register wait event", hr));

        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;

        DeleteCriticalSection(&m_CriticalSection);

        return hr;

    }

    //
    // keep a pointer to the owner terminal. don't addreff -- the terminal will
    // delete us when it goes away
    //

    m_pRecordingTerminal = pRecordingTerminal;



    LOG((MSP_TRACE, "CRecordingUnit::Initialize - exit"));

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////


HRESULT CRecordingUnit::Shutdown()
{

    LOG((MSP_TRACE, "CRecordingUnit::Shutdown[%p] - enter. ", this));


    //
    // if we don't have filter graph, we have not passed initialization
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::Shutdown - not yet initialized. nothing to shut down"));


        //
        // this is not going to cause any problems, but it should not have happened in the first place!
        //

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // first of all, make sure the graph is stopped
    //

    HRESULT hr = Stop();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CRecordingUnit::Shutdown - failed to stop filter graph, hr = %lx", hr));
    }


    //
    // unregister wait event
    //

    BOOL bUnregisterResult = ::UnregisterWaitEx(m_hGraphEventHandle, INVALID_HANDLE_VALUE);

    m_hGraphEventHandle = NULL;

    if (!bUnregisterResult)
    {
        LOG((MSP_ERROR, "CRecordingUnit::Shutdown - failed to unregisted even. continuing anyway"));
    }


    //
    // no need to keep critical section around any longer -- no one should be 
    // using this object anymore
    //

    DeleteCriticalSection(&m_CriticalSection);


    if (NULL != m_pMuxFilter)
    {
        m_pMuxFilter->Release();
        m_pMuxFilter = NULL;
    }


    //
    // release filter graph
    //

    if (NULL != m_pIGraphBuilder)
    {
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;
    }


    //
    // we don't keep a reference to the terminal, simply ground the pointer
    //

    m_pRecordingTerminal = NULL;


    LOG((MSP_TRACE, "CRecordingUnit::Shutdown - finished"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// 
//

HRESULT CRecordingUnit::put_FileName(IN BSTR bstrFileName, IN BOOL bTruncateIfPresent)
{

    LOG((MSP_TRACE, "CRecordingUnit::put_FileName[%p] - enter", this));


    //
    // check arguments
    //

    if (IsBadStringPtr(bstrFileName, -1))
    {
        LOG((MSP_ERROR, "CRecordingUnit::put_FileName - bad file name passed in"));

        return E_POINTER;
    }


    //
    // make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::put_FileName  - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // lock before accessing data members
    //

    CCSLock Lock(&m_CriticalSection);


    //
    // make sure the graph is not running
    //

    OAFilterState DSState;

    HRESULT hr = GetState(&DSState);

    //
    // is the state transition still in progress?
    //

    if (VFW_S_STATE_INTERMEDIATE == hr)
    {
        LOG((MSP_WARN, "CRecordingUnit::put_FileName  - not yet initialized. TAPI_E_WRONG_STATE"));

        return TAPI_E_WRONG_STATE;
    }


    //
    // is the return anything other than S_OK
    //

    if (hr != S_OK)
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::put_FileName  - failed to get state of the filter graph. hr = %lx", 
            hr));

        return hr;
    }

    
    TM_ASSERT(hr == S_OK);

    if (State_Stopped != DSState)
    {
        LOG((MSP_WARN, 
            "CRecordingUnit::put_FileName - graph is running. "
            "need to stop before attempting to set file name TAPI_E_WRONG_STATE"));

        return TAPI_E_WRONG_STATE;
    }


    //
    // ICaptureGraphBuilder2::SetOutputFile
    //


    //
    // create capture graph builder
    //

    ICaptureGraphBuilder2 *pCaptureGraphBuilder = NULL;
    
    hr = CoCreateInstance(CLSID_CaptureGraphBuilder2, 
                         NULL, 
                         CLSCTX_INPROC, 
                         IID_ICaptureGraphBuilder2,
                         (void**)&pCaptureGraphBuilder);


    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::put_FileName - failed to create CLSID_CaptureGraphBuilder2. hr = %lx", hr));

        return hr;
    }


    //
    // configure capture graph builder with our filter graph
    //
    
    hr = pCaptureGraphBuilder->SetFiltergraph(m_pIGraphBuilder);

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::put_FileName - pCaptureGraphBuilder->SetFiltergraph failed. hr = %lx", hr));

        pCaptureGraphBuilder->Release();
        pCaptureGraphBuilder = NULL;

        return hr;
    }


    //
    // log the name of the file we want to use
    //

    LOG((MSP_TRACE,
        "CRecordingUnit::put_FileName - attempting to open file: [%S]. Truncate: [%d]",
        bstrFileName, bTruncateIfPresent));


    //
    // ask capture graph builder to build filters around for our file
    //

    IBaseFilter *pMUXFilter = NULL;
    IFileSinkFilter *pFileSink = NULL;

    hr = pCaptureGraphBuilder->SetOutputFileName(&MEDIASUBTYPE_Avi,
                                                 bstrFileName,
                                                 &m_pMuxFilter,
                                                 &pFileSink);

    pCaptureGraphBuilder->Release();
    pCaptureGraphBuilder = NULL;

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::put_FileName - failed to set output file name. hr = %lx", hr));

        return hr;
    }


    //
    // use IFileSinkFilter2::SetMode to set append mode
    //

    IFileSinkFilter2 *pFileSink2 = NULL;

    hr = pFileSink->QueryInterface(IID_IFileSinkFilter2, (void**)&pFileSink2);


    //
    // succeed or failed, we no longer need the old IFileSinkFilter interface 
    //

    pFileSink->Release();
    pFileSink = NULL;


    //
    // cleanup if we could not get IFileSinkFilter2
    //

    if (FAILED(hr))
    {
        
        LOG((MSP_ERROR,
            "CRecordingUnit::put_FileName - qi for IFileSinkFilter2 failed. hr = %lx", hr));

        m_pMuxFilter->Release();
        m_pMuxFilter= NULL;

        return hr;
    }


    //
    // set truncate mode
    //
    
    DWORD dwFlags = 0;
    
    if (bTruncateIfPresent)
    {
        dwFlags = AM_FILE_OVERWRITE;
    }


    hr = pFileSink2->SetMode(dwFlags);


    if (FAILED(hr))
    {
        
        LOG((MSP_ERROR,
            "CRecordingUnit::put_FileName - failed to set mode. hr = %lx", hr));

        pFileSink2->Release();
        pFileSink2 = NULL;

        m_pMuxFilter->Release();
        m_pMuxFilter = NULL;

        return hr;
    }


    //
    // see if the file is writeable
    //
    // note: do this at the very end of this function so that we don't delete the file if anything else fails
    //

    HANDLE htmpFile = CreateFile(bstrFileName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (INVALID_HANDLE_VALUE == htmpFile)
    {

        //
        // get the cause of createfile failure 
        //

        DWORD dwLastError = GetLastError();

        hr = HRESULT_FROM_WIN32(dwLastError);

        LOG((MSP_ERROR, 
            "CRecordingUnit::put_FileName  - failed to create file[%S]. LastError[%ld] hr[%lx]", 
            bstrFileName, dwLastError, hr));


        //
        // cleanup. this is rather elaborate -- we need to remove filters 
        // created by graph builder
        //

        //
        // get sink's ibase filter interface so we can remove it from the filter graph
        //

        IBaseFilter *pFileWriterFilter = NULL;

        HRESULT hr2 = pFileSink2->QueryInterface(IID_IBaseFilter, (void**)&pFileWriterFilter);

        //
        // success or not, we no longer need the sink pointer
        //

        pFileSink2->Release();
        pFileSink2 = NULL;

        if (FAILED(hr2))
        {
            LOG((MSP_ERROR, 
                "CRecordingUnit::put_FileName  - failed to get IBaseFilter interface. hr = %lx",
                hr2));
        }


        //
        // remove file writer filter
        //

        if (SUCCEEDED(hr2))
        {
            hr2 = m_pIGraphBuilder->RemoveFilter(pFileWriterFilter);

            if (FAILED(hr2))
            {
                LOG((MSP_ERROR, 
                    "CRecordingUnit::put_FileName  - failed to remove file writer form graph. hr = %lx",
                    hr2));
            }


            pFileWriterFilter->Release();
            pFileWriterFilter = NULL;
        
        }


        //
        // remove mux from the graph
        //

        hr2 = m_pIGraphBuilder->RemoveFilter(m_pMuxFilter);

        if (FAILED(hr2))
        {
            LOG((MSP_ERROR, 
                "CRecordingUnit::put_FileName  - failed to remove mux filter from graph. hr = %lx",
                hr2));
        }

        //
        // succeeded or failed, remove mux from the graph
        //

        m_pMuxFilter->Release();
        m_pMuxFilter = NULL;

        return hr;
    }


    //
    // successfully created the file. now close handle and delete the file
    //

    CloseHandle(htmpFile);
    htmpFile = NULL;

    DeleteFile(bstrFileName);


    //
    // we no longer need file sink
    //

    pFileSink2->Release();
    pFileSink2 = NULL;



    //
    // attempt to configure interleaving mode
    //

    IConfigInterleaving *pConfigInterleaving = NULL;

    hr = m_pMuxFilter->QueryInterface(IID_IConfigInterleaving, (void**)&pConfigInterleaving);

    if (FAILED(hr))
    {

        //
        // the multiplexer does not expose the configinterleaving interface.
        // this is strange, but not fatal enough for us to bail out.
        //

        LOG((MSP_WARN,
            "CRecordingUnit::put_FileName - mux does not expose IConfigInterleaving. qi hr = %lx",
            hr));

    }
    else
    {


        //
        // try to set interleaving mode
        //

        InterleavingMode iterleavingMode = INTERLEAVE_NONE_BUFFERED;

        hr = pConfigInterleaving->put_Mode(iterleavingMode);

        if (FAILED(hr))
        {
            LOG((MSP_WARN,
                "CRecordingUnit::put_FileName - failed to put interleaving mode. hr = %lx",
                hr));
        }

        //
        // no longer need the configuration interface
        //

        pConfigInterleaving->Release();
        pConfigInterleaving = NULL;

    }


    //
    // we have inserted all the necessary filters into out recording filter graph.
    // the source and the mux are not yet connected.
    //


    LOG((MSP_TRACE, "CRecordingUnit::put_FileName - finished"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CRecordingUnit::CreateRenderingFilter(OUT CBRenderFilter **ppRenderingFilter)
{

    LOG((MSP_TRACE, "CRecordingUnit::CreateRenderingFilter[%p] - enter", this));


    //
    // check arguments
    //

    if (IsBadWritePtr(ppRenderingFilter, sizeof(CBRenderFilter*)))
    {
        LOG((MSP_ERROR, "CRecordingUnit::CreateRenderingFilter - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::CreateRenderingFilter - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // no member access here, no need to lock
    //

    //
    // create a critical section for the rendering filter 
    //

    CCritSec *pRendLock = NULL;

    try
    {
        pRendLock = new CCritSec;
    }
    catch (...)
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - failed to create critical section."));

        return E_OUTOFMEMORY;
    }


    //
    // create new rendering filter 
    //

    HRESULT hr = S_OK;

    CBRenderFilter *pRendFilter = new CBRenderFilter(pRendLock, &hr);

    if (NULL == pRendFilter)
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - failed to create render filter"));

        delete pRendLock;
        pRendLock = NULL;

        return E_OUTOFMEMORY;
    }


    //
    // if the object was constructed, it will manage its critical section even 
    // if the contructor failed.
    //
    
    pRendLock = NULL;

    
    //
    // did filter's constructor fail?
    //

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - render filter's constructor failed. hr = %lx", 
            hr));

        delete pRendFilter;
        pRendFilter = NULL;

        return hr;
    }


    //
    // from now on, use release to let go of the renderer...
    //

    pRendFilter->AddRef();


    //
    // create a critical section for the source filter 
    //

    CCritSec *pSourceLock = NULL;

    try
    {
        pSourceLock = new CCritSec;
    }
    catch (...)
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - failed to create critical section 2."));

        pRendFilter->Release();
        pRendFilter = NULL;

        return E_OUTOFMEMORY;
    }


    //
    // create a new source filter
    //

    CBSourceFilter *pSourceFilter = new CBSourceFilter(pSourceLock, &hr);

    if (NULL == pSourceFilter)
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - failed to create source filter"));

        delete pSourceLock;
        pSourceLock = NULL;

        pRendFilter->Release();
        pRendFilter = NULL;

        return E_OUTOFMEMORY;
    }

    

    //
    // if the object was constructed, it will manage its critical section even 
    // if the contructor failed.
    //
    
    pSourceLock = NULL;


    //
    // did filter's constructor fail?
    //

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - source filter's constructor failed. hr = %lx", 
            hr));

        pRendFilter->Release();
        pRendFilter = NULL;

        delete pSourceFilter;
        pSourceFilter = NULL;

        return hr;
    }


    //
    // from now on, use release to let go of the filter. if everything goes ok
    // this will be the reference kept for the array entry
    //

    pSourceFilter->AddRef();


    //
    // pass the rendering filter a pointer to the source filter. if the 
    // rendrerer kept ths source, it addref'ed it
    //

    hr = pRendFilter->SetSourceFilter(pSourceFilter);;

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::CreateRenderingFilter - SetSourceFilter failed hr = %lx", 
            hr));

        pRendFilter->Release();
        pRendFilter = NULL;

        pSourceFilter->Release();
        pSourceFilter = NULL;

        return hr;
    }


    //
    // we addreff when we just created the filter. an extra reference was added 
    // when the filter was passed to the rendering filter. release now.
    //

    pSourceFilter ->Release();
    pSourceFilter = NULL;


    //
    // at this point we have created a rendering filter with a rendering 
    // pin, a source filter, and "connected" rendering pin to the source filter
    //
    // return the pointer to the rendering filter that we have created
    // the caller will have the only existing reference to this the filter
    //

    *ppRenderingFilter = pRendFilter;


    LOG((MSP_TRACE, "CRecordingUnit::CreateRenderingFilter - finish"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CRecordingUnit::ConnectFilterToMUX(CBSourceFilter *pSourceFilter)
{

    LOG((MSP_TRACE, "CRecordingUnit::ConnectFilterToMUX[%p] - enter", this));

    
    //
    // get source filter's output pin (does not addref)
    //

    IPin *pSourcePin = pSourceFilter->GetPin(0);


    //
    // get mux's pins
    //

    IEnumPins *pMuxPins= NULL;

    HRESULT hr = m_pMuxFilter->EnumPins(&pMuxPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::ConnectFilterToMUX - failed to enumerate pins, hr = %lx",
            hr));

        return hr;
    }


    //
    // find mux's available input pin and attempt to connect to it
    //

    BOOL bConnectSucceeded = FALSE;

    while (TRUE)
    {
 
        ULONG ulFetched = 0;
        IPin *pMuxInputPinToUse = NULL;


        hr = pMuxPins->Next(1, &pMuxInputPinToUse, &ulFetched);

        if (hr != S_OK)
        {
            LOG((MSP_TRACE, 
                "CRecordingUnit::ConnectFilterToMUX - could not get next pin, hr = %lx",
                hr));

            break;
        }


        //
        // check pin's direction
        //

        PIN_INFO PinInfo;

        hr = pMuxInputPinToUse->QueryPinInfo(&PinInfo);

        if (FAILED(hr))
        {

            //
            // failed to get pin's information
            //
            
            LOG((MSP_ERROR,
                "CRecordingUnit::ConnectFilterToMUX - could not get pin's information, hr = %lx",
                hr));

            pMuxInputPinToUse->Release();
            pMuxInputPinToUse = NULL;

            continue;
        }


        //
        // if we sneakily received a filter pointer in this structure, release it now.
        //

        if (NULL != PinInfo.pFilter)
        {
            PinInfo.pFilter->Release();
            PinInfo.pFilter = NULL;
        }



        LOG((MSP_TRACE,
            "CRecordingUnit::ConnectFilterToMUX - considering pin[%S]",
            PinInfo.achName));


        //
        // check pin's direction
        //

        if (PinInfo.dir != PINDIR_INPUT)
        {

            LOG((MSP_TRACE,
                "CRecordingUnit::ConnectFilterToMUX - not an input pin"));

            pMuxInputPinToUse->Release();
            pMuxInputPinToUse = NULL;

            continue;
        }


        //
        // is the pin connected?
        //

        IPin *pConnectedPin = NULL;

        hr = pMuxInputPinToUse->ConnectedTo(&pConnectedPin);

        if (hr == VFW_E_NOT_CONNECTED)
        {


            //
            // the pin is not connected. this is exactly what we need.
            //

            LOG((MSP_TRACE,
                "CRecordingUnit::ConnectFilterToMUX - pin not connected. will use it."));

            hr = m_pIGraphBuilder->ConnectDirect(pSourcePin, pMuxInputPinToUse, NULL);

            if (FAILED(hr))
            {
                LOG((MSP_ERROR,
                    "CRecordingUnit::ConnectFilterToMUX - failed to connect pins. "
                    "Attempting intelligent connection. hr = %lx", hr));

                //
                // attempt intelligent connection
                //

                hr = m_pIGraphBuilder->Connect(pSourcePin, pMuxInputPinToUse);

                if (FAILED(hr))
                {
                    LOG((MSP_ERROR,
                        "CRecordingUnit::ConnectFilterToMUX - intelligent connection failed"
                        "hr = %lx", hr));

                }

            }


            //
            // if connection succeeded, break out
            //

            if (SUCCEEDED(hr))
            {
                LOG((MSP_TRACE,
                    "CRecordingUnit::ConnectFilterToMUX - connection succeeded."));

                pMuxInputPinToUse->Release();
                pMuxInputPinToUse = NULL;

                bConnectSucceeded = TRUE;

                break;
            }

        }
        else if ( SUCCEEDED(hr) )
        {

            pConnectedPin->Release();
            pConnectedPin = NULL;

        }


        //
        // release the current pin continue to the next one
        //

        pMuxInputPinToUse->Release();
        pMuxInputPinToUse = NULL;
    }


    //
    // found or not, no need to keep the enumeration
    //

    pMuxPins->Release();
    pMuxPins = NULL;


    //
    // set hr to return
    //

    if (bConnectSucceeded)
    {
        //
        // tada! filters are connected!
        //

        hr = S_OK;
    }
    else
    {

        //
        // log hr before we overwrite it.
        //

        LOG((MSP_(hr), "CRecordingUnit::ConnectFilterToMUX - failed to connect hr = %lx", hr));

        hr = E_FAIL;
    }


    LOG((MSP_(hr), "CRecordingUnit::ConnectFilterToMUX - finish hr = %lx", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CRecordingUnit::ConfigureSourceFilter(IN CBRenderFilter *pRenderingFilter)
{
    
    LOG((MSP_TRACE, "CRecordingUnit::ConfigureSourceFilter[%p] - enter", this));


    //
    // good pointer?
    //

    if ( IsBadReadPtr(pRenderingFilter, sizeof(CBRenderFilter)) )
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::ConfigureSourceFilter - bad filter pointer passed in[%p]",
            pRenderingFilter));

        return E_POINTER;
    }


    CCSLock Lock(&m_CriticalSection);


    //
    // make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::ConfigureSourceFilter - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // find the source filter corresponding to this rendering filter
    //

    CBSourceFilter *pSourceFilter = NULL;
    
    HRESULT hr = pRenderingFilter->GetSourceFilter(&pSourceFilter);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::ConfigureSourceFilter - failed to get source filter from renderer."));

        return hr;
    }


    //
    // see if the source filter is in the filter graph
    //

    IFilterGraph *pFilterGraph = pSourceFilter->GetFilterGraphAddRef();


    //
    // it's ok if the filter is not in the graph at all -- this simply means it
    // has not yet been added.
    //
    
    if ( NULL != pFilterGraph)
    {

        //
        // signal the source pin that subsequent sample's timestamp sequence 
        // might be restarting and that it needs to adjust the timestamps to 
        // mantain time continuity.
        //
        
        pSourceFilter->NewStreamNotification();


        //
        // don't need source filter anymore
        //

        pSourceFilter->Release();
        pSourceFilter = NULL;


        //
        // if the filter is in the graph, it must be _this_ graph!
        //

        BOOL bSameGraph = IsEqualObject(pFilterGraph, m_pIGraphBuilder);


        pFilterGraph->Release();
        pFilterGraph = NULL;

        if ( ! bSameGraph )
        {

            LOG((MSP_ERROR,
                "CRecordingUnit::ConfigureSourceFilter - the filter is in a different graph"
                "VFW_E_NOT_IN_GRAPH"));


            //
            // debug to see why this happened
            //

            TM_ASSERT(FALSE);

            return VFW_E_NOT_IN_GRAPH;
        }

        
        LOG((MSP_TRACE,
            "CRecordingUnit::ConfigureSourceFilter - filter is already in our graph."));

        return S_OK;
    }


    //
    // the filter is not in the graph. add to the graph and conect
    //

    hr = m_pIGraphBuilder->AddFilter( pSourceFilter, L"File Terminal Source Filter" );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CRecordingUnit::ConfigureSourceFilter - failed to add filter to the graph. hr = %lx",
            hr));

        pSourceFilter->Release();
        pSourceFilter = NULL;

        return hr;

    }


    //
    // connect filter's output pin to mux's input pin
    //

    hr = ConnectFilterToMUX(pSourceFilter);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CRecordingUnit::ConfigureSourceFilter - failed to connect source to mux. hr = %lx",
            hr));


        //
        // try to clean up if possible
        //

        HRESULT hr2 = m_pIGraphBuilder->RemoveFilter(pSourceFilter);

        if (FAILED(hr2))
        {
            LOG((MSP_ERROR,
                "CRecordingUnit::ConfigureSourceFilter - remove filter from graph. hr = %lx",
                hr2));
        }

        pSourceFilter->Release();
        pSourceFilter = NULL;

        return hr;

    }


    //
    // the filter is not in the filter graph and connected. we are done
    //

    pSourceFilter->Release();
    pSourceFilter = NULL;


    LOG((MSP_TRACE, "CRecordingUnit::ConfigureSourceFilter - finish"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CRecordingUnit::RemoveRenderingFilter(IN CBRenderFilter *pRenderingFilter)
{
    
    LOG((MSP_TRACE, "CRecordingUnit::RemoveRenderingFilter[%p] - enter", this));


    //
    // check arguments
    //

    if (IsBadReadPtr(pRenderingFilter, sizeof(CBRenderFilter)))
    {
        LOG((MSP_ERROR, "CRecordingUnit::RemoveRenderingFilter - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::RemoveRenderingFilter - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // find the filter pin corresponding to this rendering filter
    //

    CBSourceFilter *pSourceFilter = NULL;
    
    HRESULT hr = pRenderingFilter->GetSourceFilter(&pSourceFilter);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::RemoveRenderingFilter - failed to get source filter from renderer."));

        return hr;
    }


    //
    // see if the source filter is in the filter graph
    //

    IFilterGraph *pFilterGraph = pSourceFilter->GetFilterGraphAddRef();


    //
    // it's ok if the filter is not in the graph at all
    //
    
    if ( NULL == pFilterGraph)
    {
        LOG((MSP_TRACE, 
            "CRecordingUnit::RemoveRenderingFilter - finished S_OK. filter not in a graph."));


        //
        // don't need the source filter anymore
        //

        pSourceFilter->Release();
        pSourceFilter = NULL;


        //
        // renderer itself should forget about the source
        //

        hr = pRenderingFilter->SetSourceFilter(NULL);

        if (FAILED(hr))
        {

            LOG((MSP_ERROR,
                "CRecordingUnit::RemoveRenderingFilter - SetSourceFilter(NULL) on renderer failed. "
                "hr = %lx", hr));


            //
            // this error is a bug
            //

            TM_ASSERT(FALSE);

            return hr;
        }


        return S_OK;
    }


    //
    // if the filter is in the graph, it must be _this_ graph!
    //

    if (!IsEqualObject(pFilterGraph, m_pIGraphBuilder))
    {

        LOG((MSP_ERROR,
            "CRecordingUnit::RemoveRenderingFilter - the filter is in a different graph"));


        pSourceFilter->Release();
        pSourceFilter = NULL;

        pFilterGraph->Release();
        pFilterGraph = NULL;


        //
        // why did this happen?
        //

        TM_ASSERT(FALSE);

        return hr;
    }


    //
    // don't need the filter graph anymore
    //

    pFilterGraph->Release();
    pFilterGraph = NULL;


    //
    // see if the graph is running... cannot do anything unless the graph is stopped
    //

    OAFilterState GraphState;
    
    hr = GetState(&GraphState);

    if (FAILED(hr))
    {

        //
        // failed to get state. log a message, and try to stop the stream anyway
        //

        LOG((MSP_ERROR, 
            "CRecordingUnit::RemoveRenderingFilter - failed to get state"
            " hr = %lx", hr));
        
        pSourceFilter->Release();
        pSourceFilter = NULL;

        return hr;
    }


    //
    // if the filter is not in the middle of a transition and is stopped, we 
    // don't need to stop substream
    //
    
    if ( State_Stopped != GraphState )
    {
        LOG((MSP_TRACE, 
            "CRecordingUnit::RemoveRenderingFilter - graph not stopped. "));

        pSourceFilter->Release();
        pSourceFilter = NULL;

        return TAPI_E_WRONG_STATE;
    }


    //
    // we will access data members so lock
    //

    CCSLock Lock(&m_CriticalSection);


    //
    // remove source filter
    //

    hr = m_pIGraphBuilder->RemoveFilter(pSourceFilter);


    //
    // if this failed, we cannot rollback the transaction. so the filter graph 
    // will be left in disconnected state with the filter hanging in it. this 
    // should not hurt us (except for a filter leak), so return success.
    //

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::RemoveRenderingFilter - failed to remove source filter. "
            "hr = %lx", hr));

        pSourceFilter->Release();
        pSourceFilter = NULL;

        return hr;
    }


    //
    // renderer itself should forget about the source
    //

    hr = pRenderingFilter->SetSourceFilter(NULL);

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            "CRecordingUnit::RemoveRenderingFilter - SetSourceFilter(NULL) on renderer failed. hr = %lx", 
            hr));


        pSourceFilter->Release();
        pSourceFilter = NULL;

        
        //
        // this error is a bug
        //
        
        TM_ASSERT(FALSE);

        return hr;
    }

    pSourceFilter->Release();
    pSourceFilter = NULL;


    //
    // we did whatever cleanup we could do at this point
    //

    LOG((MSP_TRACE, "CRecordingUnit::RemoveRenderingFilter - finish"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CRecordingUnit::ChangeState(OAFilterState DesiredState)
{
    
    LOG((MSP_TRACE, "CRecordingUnit::ChangeState[%p] - enter", this));


    //
    // make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::ChangeState - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // check the current state first
    //

    OAFilterState GraphState;
    
    HRESULT hr = GetState(&GraphState);


    //
    // is the state transition still in progress?
    //

    if (VFW_S_STATE_INTERMEDIATE == hr)
    {
        LOG((MSP_WARN, "CRecordingUnit::ChangeState - state transition in progress. returing TAPI_E_WRONG_STATE"));

        return TAPI_E_WRONG_STATE;
    }


    //
    // is the return anything other than S_OK
    //

    if (hr != S_OK)
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::ChangeState - failed to get state of the filter graph. hr = %lx",
            hr));

        return hr;
    }

    
    TM_ASSERT(hr == S_OK);


    //
    // nothing to do if we are already in that state
    //

    if (DesiredState == GraphState)
    {
        LOG((MSP_TRACE,
            "CRecordingUnit::ChangeState - graph is already in state %ld. nothing to do.", DesiredState));

        return S_OK;
    }


    //
    // get media control interface so we change state
    //

    IMediaControl *pIMediaControl = NULL;

    {
        //
        // will be accessing data members -- in a lock
        //

        CCSLock Lock(&m_CriticalSection);

        hr = m_pIGraphBuilder->QueryInterface(IID_IMediaControl, (void**)&pIMediaControl);

        if (FAILED(hr))
        {

            LOG((MSP_ERROR, "CRecordingUnit::ChangeState - failed to qi for IMediaControl. hr = %lx", hr));

            return hr;
        }
    }


    //
    // try to make state transition
    //

    switch (DesiredState)
    {

    case State_Stopped:
        
        LOG((MSP_TRACE, "CRecordingUnit::ChangeState - stopping"));
    
        hr = pIMediaControl->Stop();

        break;

    case State_Running:
        
        LOG((MSP_TRACE, "CRecordingUnit::ChangeState - starting"));

        hr = pIMediaControl->Run();

        break;

    case State_Paused:
        
        LOG((MSP_TRACE, "CRecordingUnit::ChangeState - pausing"));

        hr = pIMediaControl->Pause();

        break;

    default:

        LOG((MSP_TRACE, "CRecordingUnit::ChangeState - unknown state %ld", DesiredState));

        hr = E_INVALIDARG;

        break;

    }

    pIMediaControl->Release();
    pIMediaControl = NULL;


    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CRecordingUnit::ChangeState - state change failed. hr = %lx", hr));

        return hr;
    }


    LOG((MSP_TRACE, "CRecordingUnit::ChangeState - finish"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////


HRESULT CRecordingUnit::Start()
{
    
    LOG((MSP_TRACE, "CRecordingUnit::Start[%p] - enter", this));

    HRESULT hr = ChangeState(State_Running);

    LOG((MSP_(hr), "CRecordingUnit::Start - finish. hr = %lx", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CRecordingUnit::Pause()
{
    
    LOG((MSP_TRACE, "CRecordingUnit::Pause[%p] - enter", this));

    HRESULT hr = ChangeState(State_Paused);

    LOG((MSP_(hr), "CRecordingUnit::Pause - finish. hr = %lx", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CRecordingUnit::Stop()
{
    
    LOG((MSP_TRACE, "CRecordingUnit::Stop[%p] - enter", this));

    HRESULT hr = ChangeState(State_Stopped);

    LOG((MSP_(hr), "CRecordingUnit::Stop - finish. hr = %lx", hr));

    return hr;
}



///////////////////////////////////////////////////////////////////////////////


HRESULT CRecordingUnit::GetState(OAFilterState *pGraphState)
{
    
    LOG((MSP_TRACE, "CRecordingUnit::GetState[%p] - enter", this));

    //
    // make sure we have been initialized.
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CRecordingUnit::GetState - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // get media control interface so we change state
    //

    IMediaControl *pIMediaControl = NULL;

    {
        //
        // will be accessing data members -- in a lock
        //

        CCSLock Lock(&m_CriticalSection);


        HRESULT hr = m_pIGraphBuilder->QueryInterface(IID_IMediaControl, 
                                                      (void**)&pIMediaControl);

        if (FAILED(hr))
        {

            LOG((MSP_ERROR, "CRecordingUnit::ChangeState - failed to qi for IMediaControl. hr = %lx", hr));

            return hr;
        }
    }

    
    //
    // try to get state outside the lock
    //

    OAFilterState GraphState = (OAFilterState) -1;
    
    HRESULT hr = pIMediaControl->GetState(10, &GraphState);

    pIMediaControl->Release();
    pIMediaControl = NULL;


    //
    // did we succeed at all?
    //

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CRecordingUnit::ChangeState - failed to get state. hr = %lx", hr));

        return hr;
    }


    //
    // is the state transition still in progress?
    //

    if (VFW_S_STATE_INTERMEDIATE == hr)
    {
        LOG((MSP_WARN, 
            "CRecordingUnit::ChangeState - state transition in progress. "
            "returNing VFW_S_STATE_INTERMEDIATE"));

        //
        // continue -- the state is what we are transitioning to
        //
    }


    //
    // log if we got VFW_S_CANT_CUE 
    //

    if (VFW_S_CANT_CUE == hr)
    {
        LOG((MSP_WARN, 
            "CRecordingUnit::GetState - fg returned VFW_S_CANT_CUE"));

        //
        // continue -- we still should have received a valid state
        //
    }


    //
    // log the state
    //

    switch (GraphState)
    {

    case State_Stopped:
        
        LOG((MSP_TRACE, "CRecordingUnit::GetState - State_Stopped"));

        *pGraphState = GraphState;
    
        break;

    case State_Running:
        
        LOG((MSP_TRACE, "CRecordingUnit::GetState - State_Running"));

        *pGraphState = GraphState;

        break;

    case State_Paused:
        
        LOG((MSP_TRACE, "CRecordingUnit::GetState- State_Paused"));

        *pGraphState = GraphState;

        break;

    default:

        LOG((MSP_TRACE, "CRecordingUnit::GetState- unknown state %ld", GraphState));

        hr = E_FAIL;

        break;

    }


    LOG((MSP_(hr), "CRecordingUnit::GetState - finish. hr = %lx", hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\fpunit.h ===
//
// Playback unit
//

#ifndef _PLAYBACK_UNIT_
#define _PLAYBACK_UNIT_

#include <fpbridge.h>

class CFPTerminal;
class CPBFilter;
class CPBPin;

class CPlaybackUnit

{

public:
    //
    // --- Contstructor/Destructor ---
    //

    CPlaybackUnit();

    ~CPlaybackUnit();


public:

    //
    // --- Public methods ---
    //


    //
    // create graph and stuff
    //

    HRESULT Initialize(
        );

    //
    // communicate file name.
    //

    HRESULT SetupFromFile(
        IN BSTR bstrFileName
        );

    //
    // start the filter graph
    //

    HRESULT Start();


    //
    // Stop the filter graph
    //

    HRESULT Stop();

    //
    // Pause the filter graph
    //

    HRESULT Pause();


    //
    // get filter graph's state
    //

    HRESULT GetState(
        OUT OAFilterState *pGraphState
        );

    //
    // cleanup
    //

    HRESULT Shutdown();

	//
	// retrieve the media supported by the filter
	//

	HRESULT	get_MediaTypes(
		OUT	long* pMediaTypes
		);

	HRESULT GetMediaPin(
		IN	long		nMediaType,
        IN  int         nIndex,
		OUT	CPBPin**	ppPin
		);

private:

    //
    // --- Private methods ---
    //
    
    //
    // the callback called on a filter graph event
    //

    static VOID CALLBACK HandleGraphEvent( IN VOID *pContext,
                                           IN BOOLEAN bReason); 

    //
    // transition playback unit into new state
    //

    HRESULT ChangeState(
        IN  OAFilterState DesiredState
        );

    
private:

    //
    // --- Members ---
    //

    //
    // direct show filter graph
    //

    IGraphBuilder *m_pIGraphBuilder;

    
    //
    // critical section used for thread syncronization
    //

    CRITICAL_SECTION m_CriticalSection;

    //
    // The source filter
    //
    IBaseFilter*    m_pSourceFilter;

    //
    // The bridge filter
    //

    CPBFilter*  m_pBridgeFilter;


    HANDLE                  m_hGraphEventHandle;

private:

    //
    // --- Helper methods ---
    //

    HRESULT IsGraphInState(
        IN  OAFilterState   State
        );

    HRESULT AddBridgeFilter(
        );

    HRESULT RemoveBridgeFilter(
        );

    HRESULT RemoveSourceFilter(
        );

    HRESULT GetSourcePin(
        OUT IPin**  ppPin
        );

};

#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\pbfilter.h ===
//
// pbfilter.h
//

#ifndef _PBFILTER_
#define _PBFILTER_

//
// The maximum of filters in the bridge unit
//

#define MAX_BRIDGE_PINS  16

#include <streams.h>        // DShow streams

class CPBFilter;
class CPlaybackUnit;

class CPBPin : public CBaseInputPin
{
public:
    //
    // --- Constructor / Destructor ---
    //

    CPBPin( 
        CPBFilter*  pFilter,
        CCritSec*   pLock,
        HRESULT*    phr
        );

    ~CPBPin();

public:
    //
    // --- Public methods ---
    //
    HRESULT CheckMediaType(
        const CMediaType* pMediatype
        );

	HRESULT	get_MediaType(
		OUT	long*	pMediaType
		);

	HRESULT get_Format(
		OUT AM_MEDIA_TYPE **ppmt
		);

    HRESULT get_Stream(
        OUT IStream**   ppStream
        );

    HRESULT Initialize(
        );

    //
    // IMemInputPin method
    //

    STDMETHODIMP Receive(
        IN  IMediaSample *pSample
        );

    HRESULT Inactive(
        );


private:
    //
    // --- Members ---
    //

	//
	// The parent filter
	//
	CPBFilter*	m_pPBFilter;

	//
	// The mediatype supported by the pin
	//
	long	m_nMediaSupported;

	//
	// The format
	//

	AM_MEDIA_TYPE* m_pMediaType;

    //
    // The buffer stream
    //

    IStream*        m_pStream;


private:
    //
    // --- Helper methods ---
    //
};


//
// Playback bridge filter
//

class CPBFilter :  public CBaseFilter
{
public:
    //
    // --- Consstructor / Destructor ---
    //

    CPBFilter();
    ~CPBFilter();

public:
    //
    // --- Public methods ---
    //
    int GetPinCount(
        );

    CBasePin* GetPin(
        IN  int nIndex
        );

	HRESULT get_MediaTypes(
		OUT	long*	pMediaTypes
		);

    HRESULT Initialize( 
        IN  CPlaybackUnit* pParentUnit
        );

private:

    CCritSec            m_CriticalSection;
    CPBPin*             m_ppPins[ MAX_BRIDGE_PINS ];
    CPlaybackUnit*      m_pParentUnit;
};


#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\pbfilter.cpp ===
//
// pbfilter.cpp
//

#include "stdafx.h"
#include "pbfilter.h"
#include "fpunit.h"
#include <OBJBASE.h>
#include <INITGUID.H>


// {D76CFA46-7D66-45a3-8708-7E3BC205FFC5}
DEFINE_GUID( CLSID_PlaybackBridgeFilter, 
0xd76cfa46, 0x7d66, 0x45a3, 0x87, 0x8, 0x7e, 0x3b, 0xc2, 0x5, 0xff, 0xc5);

// {DF313A10-5FBE-423a-884D-D4308EB20A09}
DEFINE_GUID( CLSID_PlaybackBridgePin, 
0xdf313a10, 0x5fbe, 0x423a, 0x88, 0x4d, 0xd4, 0x30, 0x8e, 0xb2, 0xa, 0x9);

//
// --- Constructor / Destructor
//

CPBPin::CPBPin(
    CPBFilter*  pFilter,
    CCritSec*   pLock,
    HRESULT*    phr
    )
    : CBaseInputPin(L"PlaybackBridge Pin", pFilter, pLock, phr, L"Input"),
	m_pPBFilter(pFilter),
	m_nMediaSupported(0),
	m_pMediaType(NULL),
    m_pStream(NULL)
{
    LOG((MSP_TRACE, "CPBPin::CPBPin[%p] - enter. ", this));
    LOG((MSP_TRACE, "CPBPin::CPBPin - exit"));
}

CPBPin::~CPBPin()
{
    LOG((MSP_TRACE, "CPBPin::CPBPin[%p] - enter. ", this));

    // Clean-up the media type
	if( m_pMediaType)
	{
		DeleteMediaType( m_pMediaType );
		m_pMediaType = NULL;
	}

    // Clean-up the stream
    if( m_pStream )
    {
        m_pStream->Release();
        m_pStream = NULL;
    }

    LOG((MSP_TRACE, "CPBPin::CPBPin - exit"));
}


//
// --- Public methods ---
//

HRESULT CPBPin::CheckMediaType(
    const CMediaType* pMediaType
    )
{
    LOG((MSP_TRACE, "CPBPin::CheckMediaType[%p] - enter. ", this));

    //
    // Validates parameters
    //

    if( IsBadReadPtr(pMediaType, sizeof(CMediaType)) )
    {
        
        LOG((MSP_ERROR, 
            "CPBPin::CheckMediaType - invalid pointer pMediaType"));

        return E_POINTER;
    }


    //
    // make sure the format block is readable
    //

    if (IsBadReadPtr(pMediaType->pbFormat, pMediaType->cbFormat))
    {
        LOG((MSP_ERROR, 
            "CPBPin::CheckMediaType - the format buffer is MediaType structure is not readable."));
        
        return E_INVALIDARG;
    }

    //
    // check if the format is either audio or video and if it is, make sure it's the kind that we can handle
    //

    if ((MEDIATYPE_Audio == pMediaType->majortype) ||
        (MEDIATYPE_Video == pMediaType->majortype) )
    {
        LOG((MSP_TRACE, "CPBPin::CheckMediaType - supported media type"));

        //
        // we currently only support audio described by WAVEFORMATEX data format block
        //

        if ((FORMAT_WaveFormatEx != pMediaType->formattype) &&
            (FORMAT_VideoInfo != pMediaType->formattype) &&
            (FORMAT_VideoInfo2 != pMediaType->formattype) &&
            (FORMAT_MPEGVideo != pMediaType->formattype) &&
            (FORMAT_MPEG2Video != pMediaType->formattype) )
        {
            LOG((MSP_ERROR, "CPBPin::CheckMediaType - formattype is not FORMAT_WaveFormatEx"));

            return VFW_E_INVALIDMEDIATYPE;
        }

		//
		// Set the media type at the filter level
		//

		TM_ASSERT( m_pPBFilter != NULL);

        if( pMediaType->formattype == FORMAT_WaveFormatEx )
        {
		    m_nMediaSupported = TAPIMEDIATYPE_AUDIO;
        }
        else
        {
            m_nMediaSupported = TAPIMEDIATYPE_VIDEO;
        }

        //
        // Deallocate the previous object
        // if exists one
        //
        if( m_pMediaType != NULL )
        {
            LOG((MSP_TRACE, "CPBPin::CheckMediaType - Delete the old mediatype"));
            DeleteMediaType( m_pMediaType );
            m_pMediaType = NULL;
        }

        //
        // Create a new media type
        //
		m_pMediaType = CreateMediaType( pMediaType );
		if( m_pMediaType == NULL )
		{
            LOG((MSP_ERROR, "CPBPin::CheckMediaType - CreateMediaType failed"));

            return VFW_E_INVALIDMEDIATYPE;
		}

    }
	else
    {
        //
        // we don't even know what it is
        //

        LOG((MSP_ERROR, "CPBPin::CheckMediaType - unrecognized major format"));

        return VFW_E_INVALIDMEDIATYPE;

    }

    LOG((MSP_TRACE, "CPBPin::CheckMediaType - exit"));
    return S_OK;
}

HRESULT	CPBPin::get_MediaType(
	OUT	long*	pMediaType
	)
{
    LOG((MSP_TRACE, "CPBPin::get_MediaType[%p] - enter. ", this));

	TM_ASSERT( pMediaType != NULL );

	*pMediaType = m_nMediaSupported;

    LOG((MSP_TRACE, "CPBPin::get_MediaType - exit"));
    return S_OK;

}

HRESULT CPBPin::get_Format(
	OUT AM_MEDIA_TYPE **ppmt
	)
{
    LOG((MSP_TRACE, "CPBPin::get_Format[%p] - enter. ", this));

	TM_ASSERT( ppmt != NULL );

	*ppmt = CreateMediaType( m_pMediaType );

    LOG((MSP_TRACE, "CPBPin::get_Format - exit"));
    return S_OK;
}

HRESULT CPBPin::get_Stream(
    OUT IStream**   ppStream
    )
{
    LOG((MSP_TRACE, "CPBPin::get_Stream[%p] - enter. ", this));

	TM_ASSERT( ppStream != NULL );
    TM_ASSERT( m_pStream );

    HRESULT hr = m_pStream->QueryInterface(IID_IStream, (void**)ppStream);

    TM_ASSERT( (hr == S_OK));

    LOG((MSP_TRACE, "CPBPin::get_Stream - exit"));
    return S_OK;
}


HRESULT CPBPin::Receive(
    IN  IMediaSample *pSample
    )
{
    LOG((MSP_TRACE, "CPBPin::Receive[%p] - enter. ", this));

    TM_ASSERT( m_pStream );

    //
    // We support at this time just audio streaming
    //
    if( m_nMediaSupported == TAPIMEDIATYPE_AUDIO )
    {
        //
        // Get the size and the buffer
        //
        LONG    cbSize = pSample->GetSize();
        BYTE*   pBuffer = NULL;
        HRESULT hr = pSample->GetPointer(&pBuffer);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CPBPin::Receive - exit "
                "GetPointer failed. Returns 0x%08x", hr));
            return hr;
        }

        //
        // Write media sample into the buffer stream
        //

        ULONG cbWritten = 0;
		while(cbSize > 0)
		{
			hr = m_pStream->Write( pBuffer + cbWritten, sizeof(BYTE)*cbSize, &cbWritten);
			if( FAILED(hr) )
			{
				LOG((MSP_ERROR, "CFPFilter::Deliver - exit "
					"Write failed. Returns 0x%08x", hr));
				return hr;
			}
			cbSize -= cbWritten;
		}

        //
        // VLD_TODELETE
        //

        STATSTG status;
        hr = m_pStream->Stat(&status, STATFLAG_NONAME);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CFPFilter::Deliver - exit "
                "Stat failed. Returns 0x%08x", hr));
            return hr;
        }

        LOG((MSP_TRACE, "CPBPin::Receive - StreamSize=(%ld,%ld)", status.cbSize.LowPart, status.cbSize.HighPart));

    }

    LOG((MSP_TRACE, "CPBPin::Receive - exit"));
    return S_OK;
}

HRESULT CPBPin::Initialize(
    )
{
    LOG((MSP_TRACE, "CPBPin::Initialize[%p] - enter. ", this));

    //
    // Create the stream
    //

    HRESULT hr = CreateStreamOnHGlobal( NULL, TRUE, &m_pStream);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPBPin::Initialize exit - "
            "CreateStreamOnHGlobal failed. returns 0x%08x", hr));

        return hr;
    }

    //
    // Set the NULL size
    //
    ULARGE_INTEGER uliSize;
    uliSize.LowPart = 0;
    uliSize.HighPart = 0;
    hr = m_pStream->SetSize( uliSize );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPBPin::Initialize exit - "
            "SetSize failed. returns 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CPBPin::Initialize - exit"));
    return S_OK;
}

HRESULT CPBPin::Inactive(
    )
{
    LOG((MSP_TRACE, "CPBPin::Inactive[%p] - enter. ", this));

    //
    // Goto at the beginning of the file
    //
    LARGE_INTEGER liPosition;
    liPosition.LowPart = 0;
    liPosition.HighPart = 0;
    HRESULT hr = m_pStream->Seek(liPosition, STREAM_SEEK_SET, NULL);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPBPin::Inactive exit - "
            "Seek failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Revert all the changes
    //
    hr = m_pStream->Revert();
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPBPin::Inactive exit - "
            "Revert failed. Returns 0x%08x", hr));

        return hr;
    }
    
    //
    // Reset all the size
    //
    ULARGE_INTEGER uliSize;
    uliSize.LowPart = 0;
    uliSize.HighPart = 0;
    hr = m_pStream->SetSize( uliSize );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPBPin::Inactive exit - "
            "SetSize failed. Returns 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CPBPin::Inactive - exit"));
    return S_OK;
}


//
// --- Constructor / Destructor
//

CPBFilter::CPBFilter()
    : CBaseFilter(L"PlaybackBridge Filter", NULL, &m_CriticalSection, CLSID_PlaybackBridgeFilter),
    m_pParentUnit( NULL )
{
    LOG((MSP_TRACE, "CPBFilter::CPBFilter[%p] - enter. ", this));

    // Initialize the vector
    for(int i=0; i< MAX_BRIDGE_PINS; i++)
    {
        m_ppPins[i] = NULL;
    }

    LOG((MSP_TRACE, "CPBFilter::CPBFilter - exit"));
}

CPBFilter::~CPBFilter()
{
    LOG((MSP_TRACE, "CPBFilter::~CPBFilter[%p] - enter. ", this));

    // Clean-up the pins
    for(int i = 0; i< MAX_BRIDGE_PINS; i++)
    {
        if( m_ppPins[i] )
        {
            delete m_ppPins[i];
            m_ppPins[i] = NULL;
        }
    }

    LOG((MSP_TRACE, "CPBFilter::~CPBFilter - exit"));
}

//
// --- Public methods ---
//

int CPBFilter::GetPinCount(
    )
{
    LOG((MSP_TRACE, "CPBFilter::GetPinCount[%p] - enter. ", this));
    LOG((MSP_TRACE, "CPBFilter::GetPinCount - exit"));
    return MAX_BRIDGE_PINS;
}

CBasePin* CPBFilter::GetPin(
    IN  int nIndex
    )
{
    LOG((MSP_TRACE, "CPBFilter::GetPin[%p] - enter. ", this));

    if( nIndex >= MAX_BRIDGE_PINS )
    {
        LOG((MSP_ERROR, "CPBFilter::GetPin - exit "
            "invalid argument. Returns NULL"));

        return NULL;
    }

    m_CriticalSection.Lock();

    CBasePin* pPin = m_ppPins[nIndex];

    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CPBFilter::GetPin - exit. returns %p", pPin));
    return pPin;
}


HRESULT CPBFilter::get_MediaTypes(
	OUT	long*	pMediaTypes
	)
{
    LOG((MSP_TRACE, "CPBFilter::get_MediaTypes[%p] - enter. ", this));

	TM_ASSERT( pMediaTypes != NULL );

	m_CriticalSection.Lock();

	long nMediaTypes = 0;

	for( int nPin = 0; nPin< MAX_BRIDGE_PINS; nPin++)
	{
		long nMediaType = 0;
		m_ppPins[nPin]->get_MediaType( &nMediaType );
		nMediaTypes |= nMediaType;
	}

	*pMediaTypes = nMediaTypes;

	m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CPBFilter::get_MediaTypes - exit. Returns S_OK"));
    return S_OK;
}

/*++
Initialize the bridge filter. Create the input pins
--*/
HRESULT CPBFilter::Initialize( 
    IN  CPlaybackUnit* pParentUnit
    )
{
    LOG((MSP_TRACE, "CPBFilter::Initialize[%p] - enter. ", this));

	m_CriticalSection.Lock();

    //
    // Set the parent playback unit
    //

    m_pParentUnit = pParentUnit;

    //
    // Create the input pins for this filter
    //

    for( int nIndex = 0; nIndex < MAX_BRIDGE_PINS; nIndex++)
    {
        //
        // Create the pin
        //
        HRESULT hr = S_OK;

        CPBPin* pPin = new CPBPin(
            this,
            &m_CriticalSection,
            &hr
            );

        if( (pPin == NULL) || (FAILED(hr)) )
        {
            LOG((MSP_ERROR, "CPBFilter::Initialize - exit "
                "allocation failed. Returns E_OUTOFMEMORY"));

            m_CriticalSection.Unlock();

            return E_OUTOFMEMORY;
        }

        //
        // Initialize the pin
        //
        hr = pPin->Initialize();
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CPBFilter::Initialize - exit "
                "Initialize failed. Returns 0x%08x", hr));

            m_CriticalSection.Unlock();

            return hr;
        }

        //
        // Add the pin to the collection
        //
        m_ppPins[nIndex] = pPin;
    }

    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CPBFilter::Initialize - exit. Returns S_OK"));
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\fpunit.cpp ===
//
// fpunit.cpp
//

#include "stdafx.h"
#include "fpunit.h"
#include "pbfilter.h"
#include "vfwmsgs.h"

//
// The unit filter name
//

WCHAR g_bstrUnitFilterName[] = L"PlaybackUnitSource";
WCHAR g_bstrUnitBridgeFilterName[] = L"PlaybackBridgeFilter";

CPlaybackUnit::CPlaybackUnit()
    :m_pIGraphBuilder(NULL),
    m_hGraphEventHandle(NULL),
    m_pBridgeFilter(NULL),
    m_pSourceFilter(NULL)
{
    LOG((MSP_TRACE, "CPlaybackUnit::CPlaybackUnit[%p] - enter. ", this));
    LOG((MSP_TRACE, "CPlaybackUnit::CPlaybackUnit - exit"));
}


CPlaybackUnit::~CPlaybackUnit()
{
    LOG((MSP_TRACE, "CPlaybackUnit::~CPlaybackUnit[%p] - enter. ", this));
    LOG((MSP_TRACE, "CPlaybackUnit::~CPlaybackUnit - exit"));
}

//
// --- Public members ---
//


/*++
Inititalize the playback unit
try to create the graph builder, initialize critical section,
rgisters for the graph events
--*/
HRESULT CPlaybackUnit::Initialize(
    )
{ 
    LOG((MSP_TRACE, "CPlaybackUnit::Initialize[%p] - enter. ", this));

    
    //
    // initialize should only be called once. it it is not, there is a bug in
    // our code
    //

    if (NULL != m_pIGraphBuilder)
    {
        LOG((MSP_ERROR, "CPlaybackUnit::Initialize - already initialized"));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // attempt to initialize critical section
    //
    
    BOOL bCSInitSuccess = InitializeCriticalSectionAndSpinCount(&m_CriticalSection, 0);

    if (!bCSInitSuccess)
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::Initialize - failed to initialize critical section. LastError=%ld", 
            GetLastError()));


        return E_OUTOFMEMORY;
    }

    //
    // Create filter graph
    //

    HRESULT hr = CoCreateInstance(
            CLSID_FilterGraph,     
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IGraphBuilder,
            (void **) &m_pIGraphBuilder
            );


    if (FAILED(hr))
    {

        LOG((MSP_ERROR, "CPlaybackUnit::Initialize - failed to create filter graph. Returns 0x%08x", hr));

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }

    //
    // Register for filter graph events
    //

    IMediaEvent *pMediaEvent = NULL;

    hr = m_pIGraphBuilder->QueryInterface(IID_IMediaEvent, (void**)&pMediaEvent);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - failed to qi graph for IMediaEvent, Returns 0x%08x", hr));

        // Clean-up
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }


    //
    // Get filter graph's event
    //

    HANDLE hEvent = NULL;
    hr = pMediaEvent->GetEventHandle((OAEVENT*)&hEvent);

    //
    // Clean-up
    //
    pMediaEvent->Release();
    pMediaEvent = NULL;

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - failed to get graph's event. Returns 0x%08x", hr));

        // Clean-up
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }

    //
    // Register for the graph event
    //

    BOOL fSuccess = RegisterWaitForSingleObject(
            &m_hGraphEventHandle,               // pointer to the returned handle
            hEvent,                             // the event handle to wait for.
            CPlaybackUnit::HandleGraphEvent,    // the callback function.
            this,                               // the context for the callback.
            INFINITE,                           // wait forever.
            WT_EXECUTEDEFAULT | 
            WT_EXECUTEINWAITTHREAD              // use the wait thread to call the callback.
            );

    if ( ! fSuccess )
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - failed to register wait event", hr));

        // Clean-up
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;

        DeleteCriticalSection(&m_CriticalSection);

        return hr;
    }

    LOG((MSP_TRACE, "CPlaybackUnit::Initialize - exit"));

    return S_OK;
}

//
// SetupFromFile try to create a filter graph and
// the bridge filter with input pins based on the file
//

HRESULT CPlaybackUnit::SetupFromFile(
    IN BSTR bstrFileName
    )
{
    LOG((MSP_TRACE, "CPlaybackUnit::SetupFromFile[%p] - enter", this));

    //
    // Check arguments
    //

    if (IsBadStringPtr(bstrFileName, -1))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::SetupFromFile - bad file name passed in"));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }

    //
    // Make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CPlaybackUnit::SetupFromFile  - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // lock before accessing data members
    //

    CCSLock Lock(&m_CriticalSection);

    //
    // Make sure the graph is stopped
    //

    HRESULT hr = IsGraphInState( State_Stopped );
    if( FAILED(hr) )
    {
        //
        // Stop the graph
        //

        hr = Stop();
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, 
                "CPlaybackUnit::SetupFromFile - "
                "graph cannot be stop. Returns 0x%08x", hr));

            return hr;
        }
    }

    //
    // Remove the existing source filter
    // if we have one
    //

    if( m_pSourceFilter != NULL)
    {
        hr = RemoveSourceFilter();
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, 
                "CPlaybackUnit::SetupFromFile - "
                "RemoveSourceFilter failed. Returns 0x%08x", hr));

            return hr;
        }
    }

    //
    // Add the source filter to the filter graph
    //

    hr = m_pIGraphBuilder->AddSourceFilter(
        bstrFileName,
        g_bstrUnitFilterName,
        &m_pSourceFilter
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::SetupFromFile  - "
            "AddSourceFilter failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Get the source pin
    //

    IPin* pSourcePin = NULL;
    hr = GetSourcePin( &pSourcePin );

    if( FAILED(hr) )
    {
        // Clean-up
        RemoveSourceFilter();

        LOG((MSP_ERROR, 
            "CPlaybackUnit::SetupFromFile  - "
            "GetSourcePin failed. Returns 0x%08x", hr));

        return hr;
    }


    //
    // We add bridge filters to the graph
    //

    hr = AddBridgeFilter();
    if( FAILED(hr) )
    {
        // Clean-up
        pSourcePin->Release();
        RemoveSourceFilter();

        LOG((MSP_ERROR, 
            "CPlaybackUnit::SetupFromFile  - "
            "AddBridgeFilters failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Let graph to render
    //

    hr = m_pIGraphBuilder->Render( pSourcePin );
    if( FAILED(hr) )
    {
        // Clean-up
        pSourcePin->Release();
        RemoveSourceFilter();

        LOG((MSP_ERROR, 
            "CPlaybackUnit::SetupFromFile  - "
            "AddBridgeFilters failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Clean-up
    //

    pSourcePin->Release();
    pSourcePin = NULL;

    LOG((MSP_TRACE, "CPlaybackUnit::SetupFromFile - finished"));

    return S_OK;
}

HRESULT CPlaybackUnit::GetState(OAFilterState *pGraphState)
{
    
    LOG((MSP_TRACE, "CPlaybackUnit::GetState[%p] - enter", this));

    //
    // make sure we have been initialized.
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CPlaybackUnit::GetState - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // get media control interface so we change state
    //

    IMediaControl *pIMediaControl = NULL;

    {
        //
        // will be accessing data members -- in a lock
        //

        CCSLock Lock(&m_CriticalSection);


        HRESULT hr = m_pIGraphBuilder->QueryInterface(
            IID_IMediaControl, 
            (void**)&pIMediaControl
            );

        if (FAILED(hr))
        {

            LOG((MSP_ERROR, "CPlaybackUnit::ChangeState - failed to qi for IMediaControl. hr = %lx", hr));

            return hr;
        }
    }

    
    //
    // try to get state outside the lock
    //

    OAFilterState GraphState = (OAFilterState) -1;
    
    HRESULT hr = pIMediaControl->GetState(10, &GraphState);

    pIMediaControl->Release();
    pIMediaControl = NULL;


    //
    // did we succeed at all?
    //

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::ChangeState - failed to get state. hr = %lx", hr));

        return hr;
    }


    //
    // is the state transition still in progress?
    //

    if (VFW_S_STATE_INTERMEDIATE == hr)
    {
        LOG((MSP_WARN, 
            "CPlaybackUnit::ChangeState - state transition in progress. "
            "returNing VFW_S_STATE_INTERMEDIATE"));

        //
        // continue -- the state is what we are transitioning to
        //
    }


    //
    // log if we got VFW_S_CANT_CUE 
    //

    if (VFW_S_CANT_CUE == hr)
    {
        LOG((MSP_WARN, 
            "CPlaybackUnit::GetState - fg returned VFW_S_CANT_CUE"));

        //
        // continue -- we still should have received a valid state
        //
    }


    //
    // log the state
    //

    switch (GraphState)
    {

    case State_Stopped:
        
        LOG((MSP_TRACE, "CPlaybackUnit::GetState - State_Stopped"));

        *pGraphState = GraphState;
    
        break;

    case State_Running:
        
        LOG((MSP_TRACE, "CPlaybackUnit::GetState - State_Running"));

        *pGraphState = GraphState;

        break;

    case State_Paused:
        
        LOG((MSP_TRACE, "CPlaybackUnit::GetState- State_Paused"));

        *pGraphState = GraphState;

        break;

    default:

        LOG((MSP_TRACE, "CPlaybackUnit::GetState- unknown state %ld", GraphState));

        hr = E_FAIL;

        break;

    }


    LOG((MSP_(hr), "CPlaybackUnit::GetState - finish. hr = %lx", hr));

    return hr;
}


VOID CPlaybackUnit::HandleGraphEvent( 
    IN VOID *pContext,
    IN BOOLEAN bReason)
{
    LOG((MSP_TRACE, "CPlaybackUnit::HandleGraphEvent - enter FT:[%p].", pContext));


    //
    // get recording unit pointer out of context
    //

    CPlaybackUnit *pPlaybackUnit = 
        static_cast<CPlaybackUnit*>(pContext);

    if (IsBadReadPtr(pPlaybackUnit, sizeof(CPlaybackUnit)) )
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - bad context"));

        return;
    }


    //
    // the graph was not initialized. something went wrong.
    //

    if (NULL == pPlaybackUnit->m_pIGraphBuilder)
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - not initialized. filter graph null"));

        return;
    }


    //
    // lock the object (just in case the object pointer is bad, do inside try/catch
    //

    try
    {

        EnterCriticalSection(&(pPlaybackUnit->m_CriticalSection));
    }
    catch(...)
    {

        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - exception accessing critical section"));

        return;
    }


    //
    // get the media event interface so we can retrieve the event
    //

    IMediaEvent *pMediaEvent = NULL;

    HRESULT hr = 
        pPlaybackUnit->m_pIGraphBuilder->QueryInterface(IID_IMediaEvent,
                                                         (void**)&pMediaEvent);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - failed to qi graph for IMediaEvent"));

       
        LeaveCriticalSection(&(pPlaybackUnit->m_CriticalSection));

        return;
    }


    //
    // while holding critical section, get the terminal on which to fire the event
    //

    //CFileRecordingTerminal *pRecordingterminal = pPlaybackUnit->m_pRecordingTerminal;

    //pRecordingterminal->AddRef();


    //
    // no longer need to access data members, release critical section
    //

    LeaveCriticalSection(&(pPlaybackUnit->m_CriticalSection));


    //
    // get the actual event
    //
    
    long     lEventCode = 0;
    LONG_PTR lParam1 = 0;
    LONG_PTR lParam2 = 0;

    hr = pMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::HandleGraphEvent - failed to get the event. hr = %lx", hr));

        // Clean-up
        pMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);
        pMediaEvent->Release();
        pMediaEvent = NULL;

        return;
    }


    LOG((MSP_EVENT, "CPlaybackUnit::HandleGraphEvent - received event code:[0x%lx] param1:[%p] param2:[%p]",
        lEventCode, lParam1, lParam2));


    //
    // ask file terminal to handle the event
    //

    // Clean-up
    pMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);
    pMediaEvent->Release();
    pMediaEvent = NULL;

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CPlaybackUnit::HandleGraphEvent - failed to fire event on the terminal. hr = %lx",
            hr));

        return;
    }


}


HRESULT CPlaybackUnit::IsGraphInState(
    IN  OAFilterState   State
    )
{
    LOG((MSP_TRACE, "CPlaybackUnit::IsGraphInState[%p] - enter", this));

    //
    // Get the graph state
    //

    OAFilterState DSState;
    HRESULT hr = GetState(&DSState);

    //
    // is the state transition still in progress?
    //

    if (VFW_S_STATE_INTERMEDIATE == hr)
    {
        LOG((MSP_ERROR, "CPlaybackUnit::IsGraphInState - exit"
            " graph is not yet initialized. Returns TAPI_E_WRONG_STATE"));

        return TAPI_E_WRONG_STATE;
    }


    //
    // is the return anything other than S_OK
    //

    if (hr != S_OK)
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::IsGraphInState  - exit "
            "failed to get state of the filter graph. Returns 0x%08x", hr));

        return hr;
    }

    
    if (State != DSState)
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::IsGraphInState - exit "
            "other state then we asked for. Returns TAPI_E_WRONG_STATE"));

        return TAPI_E_WRONG_STATE;
    }

    LOG((MSP_(hr), "CPlaybackUnit::IsGraphInState - exit. Returns 0x%08x", hr));
    return hr;
}

/*++

  Renoves the source filter from the filter graph and 
  set the source filter on NULL.
--*/
HRESULT CPlaybackUnit::RemoveSourceFilter()
{
    LOG((MSP_TRACE, "CPlaybackUnit::RemoveSourceFilter[%p] - enter", this));

    //
    // Do we have a source filter?
    //
    if( m_pSourceFilter == NULL )
    {
        LOG((MSP_TRACE, "CPlaybackUnit::ChangeState - "
            "we have a NULL source filter already. Returns S_OK"));

        return S_OK;
    }

    //
    // Get the IFilterGraph interface
    //

    IFilterGraph* pFilterGraph = NULL;
    HRESULT hr = m_pIGraphBuilder->QueryInterface(
        IID_IFilterGraph,
        (void**)&pFilterGraph
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::RemoveSourceFilter - "
            "QI for IFilterGraph failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Remove the source filter from the graph
    //

    pFilterGraph->RemoveFilter( m_pSourceFilter );

    //
    // Clean-up the source filter anyway
    //
    m_pSourceFilter->Release();
    m_pSourceFilter = NULL;


    // Clean-up
    pFilterGraph->Release();
    pFilterGraph = NULL;

    LOG((MSP_(hr), "CPlaybackUnit::AddSourceFilter - exit. Returns 0x%08x", hr));
    return hr;

}

/*++

  Removes the bridge filter from the filter graph and 
  set the bridge filter on NULL.
--*/
HRESULT CPlaybackUnit::RemoveBridgeFilter(
    )
{
    LOG((MSP_TRACE, "CPlaybackUnit::RemoveBridgeFilter[%p] - enter", this));

    //
    // Do we have a bridge filter?
    //
    if( m_pBridgeFilter == NULL )
    {
        LOG((MSP_TRACE, "CPlaybackUnit::RemoveBridgeFilter - "
            "we have a NULL bridge filter already. Returns S_OK"));

        return S_OK;
    }

    //
    // Get the IFilterGraph interface
    //

    IFilterGraph* pFilterGraph = NULL;
    HRESULT hr = m_pIGraphBuilder->QueryInterface(
        IID_IFilterGraph,
        (void**)&pFilterGraph
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::RemoveBridgeFilter - "
            "QI for IFilterGraph failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Remove the bridge filter from the graph
    //

    pFilterGraph->RemoveFilter( m_pBridgeFilter );

    //
    // Clean-up the bridge filter anyway
    //

    m_pBridgeFilter = NULL;


    // Clean-up
    pFilterGraph->Release();
    pFilterGraph = NULL;

    LOG((MSP_(hr), "CPlaybackUnit::RemoveBridgeFilter - exit. Returns 0x%08x", hr));
    return hr;
}


HRESULT CPlaybackUnit::GetSourcePin(
    OUT IPin**  ppPin
    )
{
    LOG((MSP_TRACE, "CPlaybackUnit::GetSourcePin[%p] - enter", this));

    TM_ASSERT( m_pSourceFilter );

    //
    // Reset the value
    //

    *ppPin = NULL;

    //
    // Get the in enumeration
    //

    IEnumPins* pEnumPins = NULL;
    HRESULT hr = m_pSourceFilter->EnumPins( &pEnumPins );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::GetSourcePin - exit "
            "EnumPins failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Get the first pin
    //

    IPin* pPin = NULL;
    ULONG uFetched = 0;
    hr = pEnumPins->Next(1, &pPin, &uFetched );

    //
    // Release the enumeration
    //
    pEnumPins->Release();
    pEnumPins = NULL;

    if( hr != S_OK )
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::GetSourcePin - exit "
            "we don't have a pin. Returns E_FAIL"));

        return E_FAIL;
    }

    //
    // Return the pin
    //

    *ppPin = pPin;

    LOG((MSP_TRACE, "CPlaybackUnit::GetSourcePin - exit S_OK"));
    return S_OK;
}


HRESULT CPlaybackUnit::AddBridgeFilter(
    )
{
    LOG((MSP_TRACE, "CPlaybackUnit::AddBridgeFilter[%p] - enter", this));

    if( m_pBridgeFilter )
    {
        LOG((MSP_TRACE, "CPlaybackUnit::AddBridgeFilter - "
            "we already have a bridge filter. Return S_OK"));

        return S_OK;
    }

    //
    // Create the new bridge filter
    //

    m_pBridgeFilter = new CPBFilter();
    if( m_pBridgeFilter == NULL)
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::AddBridgeFilter - exit "
            "new allocation for CPBFilter failed. Returns E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Initialize the bridge filter
    //
    HRESULT hr = m_pBridgeFilter->Initialize( this );
    if( FAILED(hr) )
    {
        // Clean-up
        delete m_pBridgeFilter;
        m_pBridgeFilter = NULL;

        LOG((MSP_ERROR, 
            "CPlaybackUnit::AddBridgeFilter - exit "
            "initialize failed. Returns 0x%08x", hr));

        return hr;
    }

    //
    // Add this bridge filter to the graph
    //

    hr = m_pIGraphBuilder->AddFilter(
        m_pBridgeFilter,
        g_bstrUnitBridgeFilterName
        );

    if( FAILED(hr) )
    {
        // Clean-up
        delete m_pBridgeFilter;
        m_pBridgeFilter = NULL;

        LOG((MSP_ERROR, 
            "CPlaybackUnit::AddBridgeFilter - exit "
            "Add filter failed. Returns 0x%08x", hr));

        return hr;
    }
    
    LOG((MSP_(hr), "CPlaybackUnit::AddBridgeFilter - exit. Returns 0x%08x", hr));
    return hr;
}

//
// retrieve the media supported by the filter
//

HRESULT CPlaybackUnit::get_MediaTypes(
	OUT	long* pMediaTypes
	)
{
    LOG((MSP_TRACE, "CPlaybackUnit::get_MediaTypes[%p] - enter", this));

	TM_ASSERT( pMediaTypes != NULL );
	TM_ASSERT( m_pBridgeFilter != NULL );

	HRESULT hr = E_FAIL;

    //
    // lock before accessing data members
    //

    CCSLock Lock(&m_CriticalSection);

	//
	// Get the media types from the filter
	//

	hr = m_pBridgeFilter->get_MediaTypes( pMediaTypes );
	if( FAILED(hr) )
	{
        LOG((MSP_ERROR, 
            "CPlaybackUnit::get_MediaTypes - exit "
            "get_MediaTypes failed. Returns 0x%08x", hr));

        return hr;
	}

    LOG((MSP_(hr), "CPlaybackUnit::get_MediaTypes - exit. Returns S_OK"));
    return S_OK;
}

HRESULT CPlaybackUnit::GetMediaPin(
	IN	long		nMediaType,
    IN  int         nIndex,
	OUT	CPBPin**	ppPin
	)
{
    LOG((MSP_TRACE, "CPlaybackUnit::GetMediaPin[%p] - enter", this));

	TM_ASSERT( ppPin != NULL );
	TM_ASSERT( m_pBridgeFilter != NULL );

	HRESULT hr = E_FAIL;
	*ppPin = NULL;

    //
    // lock before accessing data members
    //

    CCSLock Lock(&m_CriticalSection);

	//
	// Get the media types from the filter
	//

	int nPins = m_pBridgeFilter->GetPinCount();
    int nMediaPin = 0;
	for(int nPin=0; nPin < nPins; nPin++)
	{
		CPBPin* pPin = static_cast<CPBPin*>(m_pBridgeFilter->GetPin(nPin));
		if( pPin )
		{
			long mt = 0;
			pPin->get_MediaType( &mt );
			if( (mt == nMediaType) && (nIndex == nMediaPin) )
			{
				*ppPin = pPin;
                hr = S_OK;
				break;
			}

            if( mt == nMediaType )
            {
                nMediaPin++;
            }
		}
	}


    LOG((MSP_(hr), "CPlaybackUnit::GetMediaPin - exit. Returns 0x%08x", hr));
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT CPlaybackUnit::ChangeState(OAFilterState DesiredState)
{
    
    LOG((MSP_TRACE, "CPlaybackUnit::ChangeState[%p] - enter", this));


    //
    // make sure we have been initialized
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_ERROR, "CPlaybackUnit::ChangeState - not yet initialized."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // check the current state first
    //

    OAFilterState GraphState;
    
    HRESULT hr = GetState(&GraphState);


    //
    // is the state transition still in progress?
    //

    if (VFW_S_STATE_INTERMEDIATE == hr)
    {
        LOG((MSP_WARN, "CPlaybackUnit::ChangeState - state transition in progress. returing TAPI_E_WRONG_STATE"));

        return TAPI_E_WRONG_STATE;
    }


    //
    // is the return anything other than S_OK
    //

    if (hr != S_OK)
    {
        LOG((MSP_ERROR, 
            "CPlaybackUnit::ChangeState - failed to get state of the filter graph. hr = %lx",
            hr));

        return hr;
    }

    
    TM_ASSERT(hr == S_OK);


    //
    // nothing to do if we are already in that state
    //

    if (DesiredState == GraphState)
    {
        LOG((MSP_TRACE,
            "CPlaybackUnit::ChangeState - graph is already in state %ld. nothing to do.", DesiredState));

        return S_OK;
    }


    //
    // get media control interface so we change state
    //

    IMediaControl *pIMediaControl = NULL;

    {
        //
        // will be accessing data members -- in a lock
        //

        CCSLock Lock(&m_CriticalSection);

        hr = m_pIGraphBuilder->QueryInterface(IID_IMediaControl, (void**)&pIMediaControl);

        if (FAILED(hr))
        {

            LOG((MSP_ERROR, "CPlaybackUnit::ChangeState - failed to qi for IMediaControl. hr = %lx", hr));

            return hr;
        }
    }


    //
    // try to make state transition
    //

    switch (DesiredState)
    {

    case State_Stopped:
        
        LOG((MSP_TRACE, "CPlaybackUnit::ChangeState - stopping"));
    
        hr = pIMediaControl->Stop();

        break;

    case State_Running:
        
        LOG((MSP_TRACE, "CPlaybackUnit::ChangeState - starting"));

        hr = pIMediaControl->Run();

        break;

    case State_Paused:
        
        LOG((MSP_TRACE, "CPlaybackUnit::ChangeState - pausing"));

        hr = pIMediaControl->Pause();

        break;

    default:

        LOG((MSP_TRACE, "CPlaybackUnit::ChangeState - unknown state %ld", DesiredState));

        hr = E_INVALIDARG;

        break;

    }

    pIMediaControl->Release();
    pIMediaControl = NULL;


    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::ChangeState - state change failed. hr = %lx", hr));

        return hr;
    }


    LOG((MSP_TRACE, "CPlaybackUnit::ChangeState - finish"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CPlaybackUnit::Start()
{
    
    LOG((MSP_TRACE, "CPlaybackUnit::Start[%p] - enter", this));

    HRESULT hr = ChangeState(State_Running);

    LOG((MSP_(hr), "CPlaybackUnit::Start - finish. hr = %lx", hr));

    return hr;
}

HRESULT CPlaybackUnit::Pause()
{
    LOG((MSP_TRACE, "CPlaybackUnit::Pause[%p] - enter", this));

    HRESULT hr = ChangeState(State_Paused);

    LOG((MSP_(hr), "CPlaybackUnit::Pause - finish. hr = %lx", hr));

    return hr;
}

HRESULT CPlaybackUnit::Stop()
{
    
    LOG((MSP_TRACE, "CPlaybackUnit::Stop[%p] - enter", this));

    HRESULT hr = ChangeState(State_Stopped);

    LOG((MSP_(hr), "CPlaybackUnit::Stop - finish. hr = %lx", hr));

    return hr;
}

HRESULT CPlaybackUnit::Shutdown()
{
    //
    // if we don't have filter graph, we have not passed initialization
    //

    if (NULL == m_pIGraphBuilder)
    {

        LOG((MSP_TRACE, "CPlaybackUnit::Shutdown - not yet initialized. nothing to shut down"));
        return S_OK;
    }


    //
    // first of all, make sure the graph is stopped
    //

    HRESULT hr = Stop();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CPlaybackUnit::Shutdown - exit "
            "failed to stop filter graph, hr = 0x%08x", hr));
        return hr;
    }


    //
    // unregister wait event
    //

    BOOL bUnregisterResult = ::UnregisterWaitEx(m_hGraphEventHandle, (HANDLE)-1);

    m_hGraphEventHandle = NULL;

    if (!bUnregisterResult)
    {
        LOG((MSP_ERROR, "CPlaybackUnit::Shutdown - failed to unregisted even. continuing anyway"));
    }


    //
    // Remove the bridge filter
    //

    hr = RemoveBridgeFilter();
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlaybackUnit::Shutdown - exit "
            "RemoveBridgeFilter failed, hr = 0x%08x", hr));
        return hr;
    }

    //
    // Remove the source filter
    //

    hr = RemoveSourceFilter();
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlaybackUnit::Shutdown - exit "
            "RemoveSourceFilter failed, hr = 0x%08x", hr));
        return hr;
    }

    //
    // release filter graph
    //

    if( m_pIGraphBuilder != NULL )
    {
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;
    }

    //
    // no need to keep critical section around any longer -- no one should be 
    // using this object anymore
    //

    DeleteCriticalSection(&m_CriticalSection);

    LOG((MSP_TRACE, "CPlaybackUnit::Shutdown - finished"));

    return S_OK;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\resource.h ===
#define IDS_PROJNAME                    100

#define IDR_TStorageUnitAVI             113
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#define INITGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\rendpinfilter.h ===
///////////////////////////////////////////////////////////////////////////////
//
// render filter and pin
//


#include <streams.h>

//
// a garden variety rendering input pin.
//
// pushes data to the output pin in the other graph.
//

class CBSourcePin;
class CBSourceFilter;

class CBRenderFilter;

class CBRenderPin : public CBaseInputPin
{

public:

    CBRenderPin(IN CBRenderFilter *pFilter,
                IN CCritSec *pLock,
                OUT HRESULT *phr);

    ~CBRenderPin();
    
    // override CBaseInputPin methods.
    // STDMETHOD (GetAllocatorRequirements)(OUT ALLOCATOR_PROPERTIES *pProperties);

    STDMETHOD (ReceiveCanBlock) () 
    { 
        return S_FALSE; 
    }

    STDMETHOD (Receive) (IN IMediaSample *pSample);

    
    //
    // we want to know when we are given an allocator so we can pass it to the 
    // correspoding source filter (which will use it as guidelines as to what 
    // to promose to other stream members)
    //

    STDMETHOD (NotifyAllocator)(IMemAllocator *pAllocator,
                                BOOL bReadOnly);


    
    // CBasePin stuff

    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);

    HRESULT SetMediaType(const CMediaType *pmt);


    //
    // a method called by the filter when it learns media type
    //

    HRESULT put_MediaType(const CMediaType *pmt);

private:

    BOOL m_bMediaTypeSet;
};


//
// a regular one-input-pin filter
//

class CBRenderFilter : public CBaseFilter
{

public:

    CBRenderFilter(CCritSec *pLock, HRESULT *phr);

    ~CBRenderFilter();

    int GetPinCount();
    
    virtual CBasePin *GetPin(int iPinIndex);


    //
    // this methods are called by the recording terminal when it wants to 
    // set/get filter's media type
    //

    HRESULT put_MediaType(IN const AM_MEDIA_TYPE *pMediaType);
    HRESULT get_MediaType(OUT AM_MEDIA_TYPE **ppMediaType);


    //
    // this methods are called by the recording unit when it needs to pass/get the
    // the corresponing source filter
    //

    HRESULT SetSourceFilter(CBSourceFilter *pSourceFilter);
    HRESULT GetSourceFilter(CBSourceFilter **ppSourceFilter);



    // methods called by the input pin.

    // virtual HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    // virtual HRESULT CheckMediaType(IN const CMediaType *pMediatype);

    virtual HRESULT ProcessSample(IN IMediaSample *pSample);

    
    //
    // these two methods are called by the input pin when it needs to pass 
    // media type or allocator to the corresponding source filter
    //

    HRESULT PassMediaTypeToSource(IN const AM_MEDIA_TYPE * const pMediaType);
    HRESULT PassAllocatorToSource(IN IMemAllocator *pAllocator, BOOL bReadOnly);

private:

    CBRenderPin    *m_pRenderingPin;

    CBSourceFilter *m_pSourceFilter;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\rendpinfilter.cpp ===
#include "stdafx.h"

#include "RendPinFilter.h"

#include "SourcePinFilter.h"

// {6D08A085-B751-44ff-9927-107D4F6ADBB1}
static const GUID CLSID_RenderingFilter = 
{ 0x6d08a085, 0xb751, 0x44ff, { 0x99, 0x27, 0x10, 0x7d, 0x4f, 0x6a, 0xdb, 0xb1 } };



///////////////////////////////////////////////////////////////////////////////
//
// filter constructor
//
// accepts a critical section pointer and an hr pointer to return the result.
//
// the filter becomes the owner of the critical section and is responsible for
// destroying it when it is no longer needed
//
// if the constructor returns a failure, the caller will delete the object
//

CBRenderFilter::CBRenderFilter(CCritSec *pLock, HRESULT *phr)
    :m_pSourceFilter(NULL),
    m_pRenderingPin(NULL),
    CBaseFilter(_T("File Terminal Rendering Filter"),
                    NULL,
                    pLock,
                    CLSID_RenderingFilter)
{
    LOG((MSP_TRACE, "CBRenderFilter::CBRenderFilter[%p] - enter", this));


    //
    // create and initialize the pin
    //

    m_pRenderingPin = new CBRenderPin(this, pLock, phr);


    //
    // did pin allocation succeed?
    //

    if (NULL == m_pRenderingPin)
    {
        LOG((MSP_ERROR, 
            "CBRenderFilter::CBRenderFilter - failed to allocate pin"));

        *phr = E_OUTOFMEMORY;

        return;
    }


    //
    // did pin's constructor succeed?
    //

    if (FAILED(*phr))
    {

        LOG((MSP_ERROR, 
            "CBRenderFilter::CBRenderFilter - pin's constructor failed. hr = %lx",
            *phr));

        delete m_pRenderingPin;
        m_pRenderingPin  = NULL;

        return;
    }


    *phr = S_OK;

    LOG((MSP_TRACE, "CBRenderFilter::CBRenderFilter - exit. pin[%p]", m_pRenderingPin));
}


CBRenderFilter::~CBRenderFilter()
{
    LOG((MSP_TRACE, "CBRenderFilter::~CBRenderFilter[%p] - enter", this));


    //
    // we are in charge of deleting our critical section.
    //
    // assumption -- base class' destructor does not use the lock
    //

    delete m_pLock;
    m_pLock = NULL;


    //
    // release source filter if we have it
    //

    if (NULL != m_pSourceFilter)
    {
        LOG((MSP_TRACE, 
            "CBRenderFilter::~CBRenderFilter - releasing source filter[%p]", 
            m_pSourceFilter));


        //
        // we should not really have source filter anymore, the track should 
        // have told us to release it by now
        //

        TM_ASSERT(FALSE);

        m_pSourceFilter->Release();
        m_pSourceFilter = NULL;
    }


    //
    // let go of our pin
    //

    if (NULL != m_pRenderingPin)
    {
        
        LOG((MSP_TRACE, "CBRenderFilter::~CBRenderFilter - deleting pin[%p]", 
            m_pRenderingPin));

        delete m_pRenderingPin;
        m_pRenderingPin  = NULL;
    }

/*
    //
    // let go of our media type
    //

    if (NULL != m_pMediaType)
    {
        DeleteMediaType(m_pMediaType);
        m_pMediaType = NULL;
    }

    */


    LOG((MSP_TRACE, "CBRenderFilter::~CBRenderFilter - exit"));
}


///////////////////////////////////////////////////////////////////////////////

int CBRenderFilter::GetPinCount()
{
    LOG((MSP_TRACE, "CBRenderFilter::GetPinCount[%p] - enter", this));

    
    CAutoLock Lock(m_pLock);


    if (NULL == m_pRenderingPin)
    {

        LOG((MSP_TRACE, "CBRenderFilter::GetPinCount - no pin. returning 0"));

        //
        // should have been created in constructor
        //

        TM_ASSERT(FALSE);

        return 0;
    }
    

    LOG((MSP_TRACE, "CBRenderFilter::GetPinCount - finish. returning 1"));

    return 1;
}


///////////////////////////////////////////////////////////////////////////////

    
CBasePin *CBRenderFilter::GetPin(int iPinIndex)
{
    LOG((MSP_TRACE, "CBRenderFilter::GetPin[%p] - enter", this));


    //
    // if the index is anything but 0, return null
    //

    if (0 != iPinIndex)
    {
        LOG((MSP_WARN, 
            "CBRenderFilter::GetPin - iPinIndex is %d. we have at most 1 pin.", 
            iPinIndex));

        return NULL;

    }


    //  
    // from inside a lock, return pin pointer.
    //

    //
    // note that since we are not addreffing, the lock is not much help...
    //

    CAutoLock Lock(m_pLock);

    CBasePin *pPin = m_pRenderingPin;
   
    LOG((MSP_TRACE, "CBRenderFilter::GetPin - finish. returning pin [%p]", pPin));

    return pPin;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBRenderFilter::SetSourceFilter(CBSourceFilter *pSourceFilter)
{

    LOG((MSP_TRACE, 
        "CBRenderFilter::SetSourceFilter[%p] - enter. pSourceFilter[%p]", 
        this, pSourceFilter));


    //
    // check arguments
    //

    if ( (NULL != pSourceFilter) && IsBadReadPtr(pSourceFilter, sizeof(CBSourceFilter)))
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::SetSourceFilter - bad pSourceFilter[%p]", 
            pSourceFilter));
       
        return E_POINTER;
    }


    CAutoLock Lock(m_pLock);

    //
    // release the current source filter if we have it
    //

    if (NULL != m_pSourceFilter)
    {
        LOG((MSP_TRACE, 
            "CBRenderFilter::SetSourceFilter - releasing old source filter[%p]", 
            m_pSourceFilter));

        m_pSourceFilter->Release();
        m_pSourceFilter = NULL;
    }

    
    //
    // keep the new filter
    //

    m_pSourceFilter = pSourceFilter;

    if (NULL != m_pSourceFilter)
    {
        m_pSourceFilter->AddRef();
    }



    LOG((MSP_TRACE, "CBRenderFilter::SetSourceFilter - finish. new filter[%p]",
        pSourceFilter));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBRenderFilter::GetSourceFilter(CBSourceFilter **ppSourceFilter)
{
    LOG((MSP_TRACE, "CBRenderFilter::GetSourceFilter[%p] - enter.", this));


    //
    // check arguments
    //

    if (IsBadWritePtr(ppSourceFilter, sizeof(CBSourceFilter*)))
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::SetSourceFilter - bad ppSourceFilter[%p]", 
            ppSourceFilter));
       
        return E_POINTER;
    }


    CAutoLock Lock(m_pLock);


    //
    // return an error if we don't have a source filter
    //

    if (NULL == m_pSourceFilter)
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::SetSourceFilter - source filter is NULL"));

        return TAPI_E_WRONG_STATE;
    }

    
    //
    // return the current filter
    //

    *ppSourceFilter = m_pSourceFilter;

    (*ppSourceFilter)->AddRef();


    LOG((MSP_TRACE, "CBRenderFilter::GetSourceFilter - finish. filter [%p]", 
        *ppSourceFilter));

    return S_OK;
}


HRESULT CBRenderFilter::ProcessSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the input pin. This method just pass it on to the
    bridge source filter's IDataBridge interface

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "CBRenderFilter::ProcessSample[%p] - enter. sample[%p]", 
        this, pSample));


    CBSourceFilter *pSourceFilter = NULL;


    //
    // inside a lock, get a reference to the source filter
    //

    {
        CAutoLock Lock(m_pLock);

        if (NULL == m_pSourceFilter)
        {
            LOG((MSP_ERROR, "CBRenderFilter::ProcessSample - no source filter"));

            return E_FAIL;
        }

    
        //
        // addref so we can use outside the lock
        //

        pSourceFilter = m_pSourceFilter;
        pSourceFilter->AddRef();

    }


    //
    // outside the lock, ask source filter to deliver the sample
    //

    HRESULT hr = pSourceFilter->SendSample(pSample);


    //
    // we addref'd while inside critical section. release now.
    //

    pSourceFilter->Release();
    pSourceFilter = NULL;

    LOG((MSP_(hr), "CBRenderFilter::ProcessSample - finish. hr = [%lx]", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBRenderFilter::put_MediaType(IN const AM_MEDIA_TYPE * const pMediaType)
{

    LOG((MSP_TRACE, "CBRenderFilter::put_MediaType[%p] - enter.", this));


    //
    // make sure the structure we got is good
    //

    if (IsBadMediaType(pMediaType))
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::put_MediaType - bad media type stucture passed in"));
        
        return E_POINTER;
    }



    CAutoLock Lock(m_pLock);


    //
    // must have a pin
    //

    if (NULL == m_pRenderingPin)
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::put_MediaType - no pin"));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }



    //
    // tell the rendering pin its new format
    //

    CMediaType cMt(*pMediaType);

    HRESULT hr = m_pRenderingPin->put_MediaType(&cMt);

    if ( FAILED(hr) )
    {

        LOG((MSP_WARN, 
            "CBRenderFilter::put_MediaType - pin refused type. hr = %lx", hr));

        return hr;
    }


    //
    // pass media type to the source filter
    //

    hr = PassMediaTypeToSource(pMediaType);

    if (FAILED(hr))
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::put_MediaType - PassMediaTypeToSource failed. hr = %lx",
            hr));

        return hr;
    }

    
    LOG((MSP_TRACE, "CBRenderFilter::put_MediaType - finish."));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CBRenderFilter::PassAllocatorToSource(IN IMemAllocator *pAllocator, BOOL bReadOnly)
{

    LOG((MSP_TRACE, 
        "CBRenderFilter::PassAllocatorToSource[%p] - enter. pAllocator[%p]", 
        this, pAllocator));



    CAutoLock Lock(m_pLock);


    //
    // makes sure we have a source filter
    //

    if ( NULL == m_pSourceFilter )
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::PassAllocatorToSource - no source filter. "
            "E_FAIL"));

        return E_FAIL;
    }


    //
    // pass media type to the source filter
    //

    HRESULT hr = m_pSourceFilter->put_MSPAllocatorOnFilter(pAllocator, bReadOnly);

    if (FAILED(hr))
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::PassAllocatorToSource - source filter refused media type. hr = %lx",
            hr));

        return hr;
    }

    
    LOG((MSP_TRACE, "CBRenderFilter::PassAllocatorToSource - finish."));

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////

HRESULT CBRenderFilter::PassMediaTypeToSource(IN const AM_MEDIA_TYPE * const pMediaType)
{

    LOG((MSP_TRACE, "CBRenderFilter::PassMediaTypeToSource[%p] - enter.", this));


    //
    // make sure the structure we got is good
    //

    if (IsBadMediaType(pMediaType))
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::PassMediaTypeToSource - bad media type stucture passed in"));
        
        return E_POINTER;
    }



    CAutoLock Lock(m_pLock);


    //
    // makes sure we have a source filter
    //

    if ( NULL == m_pSourceFilter )
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::PassMediaTypeToSource - no source filter. "
            "E_FAIL"));

        return E_FAIL;
    }


    //
    // pass media type to the source filter
    //

    HRESULT hr = m_pSourceFilter->put_MediaTypeOnFilter(pMediaType);

    if (FAILED(hr))
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::PassMediaTypeToSource - source filter refused media type. hr = %lx",
            hr));

        return hr;
    }

    
    LOG((MSP_TRACE, "CBRenderFilter::PassMediaTypeToSource - finish."));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CBRenderFilter::get_MediaType(OUT AM_MEDIA_TYPE **ppMediaType)
{

    LOG((MSP_TRACE, "CBRenderFilter::get_MediaType[%p] - enter.", this));


    //
    // make sure the pointer we got is writeable
    //

    if (IsBadWritePtr(ppMediaType, sizeof(AM_MEDIA_TYPE*)))
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::get_MediaType - bad media type stucture pointer passed in"));
        
        return E_POINTER;
    }


    CAutoLock Lock(m_pLock);


    //
    // must have a pin
    //

    if (NULL == m_pRenderingPin)
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::get_MediaType - no pin"));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // ask pin for its media type
    //

    CMediaType PinMediaType;

    HRESULT hr = m_pRenderingPin->GetMediaType(0, &PinMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CBRenderFilter::get_MediaType - GetMediaType on pin failed. hr = %lx", hr));
        
        return hr;
    }


    //
    // create and return media type based on pin's
    //

    *ppMediaType = CreateMediaType(&PinMediaType);

    if (NULL == *ppMediaType)
    {
        LOG((MSP_ERROR, 
            "CBRenderFilter::get_MediaType - failed to create am_media_type structure"));

        return E_OUTOFMEMORY;
    }

    
    LOG((MSP_TRACE, "CBRenderFilter::get_MediaType - finish."));

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
//
//  pin
//
//
//////////////////////////////////////////////////////////////////////////////


CBRenderPin::CBRenderPin(
    IN CBRenderFilter *pFilter,
    IN CCritSec *pLock,
    OUT HRESULT *phr
    ) 
    : m_bMediaTypeSet(FALSE),
    CBaseInputPin(
        NAME("File Terminal Input Pin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Input"                   // Pin name
        )
{
    LOG((MSP_TRACE, "CBRenderPin::CBRenderPin[%p] - enter", this));

    LOG((MSP_TRACE, "CBRenderPin::CBRenderPin - exit"));
}

CBRenderPin::~CBRenderPin() 
{
    LOG((MSP_TRACE, "CBRenderPin::~CBRenderPin[%p] - enter", this));

    LOG((MSP_TRACE, "CBRenderPin::~CBRenderPin - exit"));
}



///////////////////////////////////////////////////////////////////////////////


inline STDMETHODIMP CBRenderPin::Receive(IN IMediaSample *pSample) 
{
    return ((CBRenderFilter*)m_pFilter)->ProcessSample(pSample);
}



//////////////////////////////////////////////////
//
// CBRenderPin::NotifyAllocator
//
// we are notified of the we are going to use. 
//

HRESULT CBRenderPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly)
{
    
    LOG((MSP_TRACE, 
        "CBRenderPin::NotifyAllocator[%p] - enter. allocator[%p] bReadOnly[%d]", 
        this, pAllocator, bReadOnly));


    //
    // propagate setting to the base class
    //

    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CBRenderPin::NotifyAllocator - base class rejected the allocator. hr = [%lx]", 
            hr));

        return hr;
    }


    //
    // must have a filter
    //

    if (NULL == m_pFilter)
    {

        LOG((MSP_ERROR,
            "CBRenderPin::NotifyAllocator - m_pFilter is NULL"));

        return E_FAIL;
    }


    //
    // pass media type down the chain to rend filter -> source filter -> 
    // source pin
    //

    CBRenderFilter *pParentFilter = static_cast<CBRenderFilter *>(m_pFilter);



    //
    // pass allocator to the source filter. source filter will use it to get 
    // its alloc properties.
    //

    hr = pParentFilter->PassAllocatorToSource(pAllocator, bReadOnly);


    LOG((MSP_(hr), "CBRenderPin::NotifyAllocator - finish. hr = [%lx]", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBRenderPin::SetMediaType(const CMediaType *pmt)
{
    LOG((MSP_TRACE, "CBRenderPin::SetMediaType[%p] - enter", this));


    //
    // media type already set?
    //

    if ( m_bMediaTypeSet )
    {

        LOG((MSP_TRACE,
            "CBRenderPin::SetMediaType - media format already set."));


        //
        // media type must be the same as what we already have
        //

        if (!IsEqualMediaType(m_mt, *pmt))
        {
            LOG((MSP_WARN,
                "CBRenderPin::SetMediaType - format different from previously set "
                "VFW_E_CHANGING_FORMAT"));

            return VFW_E_CHANGING_FORMAT;

        }
        else
        {

            LOG((MSP_TRACE,
                "CBRenderPin::SetMediaType - same format. accepting."));
        }
    }


    //
    // pass media type down the chain to rend filter -> source filter -> source pin
    //
    
    HRESULT hr = ((CBRenderFilter*)m_pFilter)->PassMediaTypeToSource(pmt);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CBRenderPin::SetMediaType - failed to pass media type to the source filter."
            "hr = %lx", hr));

        return hr;
    }


    //
    // pass media type to the base class
    //

    hr = CBasePin::SetMediaType(pmt);


    if (SUCCEEDED(hr))
    {

        m_bMediaTypeSet = TRUE;
    }


    LOG((MSP_(hr), "CBRenderPin::SetMediaType - exit. hr = %lx", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBRenderPin::put_MediaType(const CMediaType *pmt)
{

    LOG((MSP_TRACE, "CBRenderPin::put_MediaType[%p] - enter", this));


    //
    // media type already set?
    //

    //
    // we currently only allow to set media type once. 
    //

    if ( m_bMediaTypeSet )
    {

        LOG((MSP_ERROR,
            "CBRenderFilter::put_MediaType - media format already set. "
            "VFW_E_CHANGING_FORMAT"));

        return VFW_E_CHANGING_FORMAT;
    }


    //
    // pass media type to the base class
    //

    HRESULT hr = CBasePin::SetMediaType(pmt); 


    if (SUCCEEDED(hr))
    {
        m_bMediaTypeSet = TRUE;
    }


    LOG((MSP_(hr), "CBRenderPin::put_MediaType - exit. hr = %lx", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////



HRESULT CBRenderPin::CheckMediaType(
    const CMediaType *pMediaType
    )
{
    LOG((MSP_TRACE, "CBRenderPin::CheckMediaType[%p] - enter.", this));


    //
    // make sure the structure we got is good
    //

    if (IsBadReadPtr(pMediaType, sizeof(CMediaType)))
    {
        LOG((MSP_ERROR,
            "CBRenderPin::CheckMediaType - bad media type stucture passed in"));
        
        return E_POINTER;
    }


    //
    // make sure format buffer is good, as advertized
    //

    if ( (pMediaType->cbFormat > 0) && IsBadReadPtr(pMediaType->pbFormat, pMediaType->cbFormat) )
    {

        LOG((MSP_ERROR,
            "CBRenderPin::CheckMediaType - bad format field in media type structure passed in"));
        
        return E_POINTER;

    }


    //
    // is media type valid?
    //

    if ( !pMediaType->IsValid() )
    {

        LOG((MSP_ERROR,
            "CBRenderPin::CheckMediaType - media type invalid. "
            "VFW_E_INVALIDMEDIATYPE"));
        
        return VFW_E_INVALIDMEDIATYPE;
    }



    CAutoLock Lock(m_pLock);


    //
    // if no media type, we will accept anything
    //

    if ( ! m_bMediaTypeSet )
    {

        LOG((MSP_ERROR,
            "CBRenderPin::CheckMediaType  - no media format yet set. accepting."));

        return S_OK;
    }


    //
    // already have a media type, so we'd better be offered the same kind,
    // otherwise we will reject
    //

    if (!IsEqualMediaType(m_mt, *pMediaType))
    {
        LOG((MSP_WARN, 
            "CBRenderPin::CheckMediaType - different media types"));

        return VFW_E_TYPE_NOT_ACCEPTED;

    }


    LOG((MSP_TRACE, "CBRenderPin::CheckMediaType - finish."));

    return S_OK;
}




//////////////////////////////////////////////////////////////////////////////




/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based.
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success

    E_OUTOFMEMORY - no memory

    VFW_S_NO_MORE_ITEMS no media type set or position is anything but 0.

--*/

HRESULT CBRenderPin::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
{
    LOG((MSP_TRACE, "CBRenderPin::GetMediaType[%p] - enter.", this));


    //
    // make sure the pointer is good
    //

    if (IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)))
    {
        LOG((MSP_TRACE, "CBRenderPin::GetMediaType - bad media type pointer passed in."));

        TM_ASSERT(FALSE);

        return E_POINTER;
    }


    //
    // we have at most one media type.
    //

    if ( (iPosition != 0) )
    {
        LOG((MSP_WARN, 
            "CBRenderPin::GetMediaType - position[%d] is not 0. VFW_S_NO_MORE_ITEMS.", 
            iPosition));


        return VFW_S_NO_MORE_ITEMS;
    }


    //
    // do we have at least one media type?
    //

    if ( ! m_bMediaTypeSet )
    {
        LOG((MSP_WARN, 
            "CBRenderPin::GetMediaType - don't yet have a media type. VFW_S_NO_MORE_ITEMS."));


        return VFW_S_NO_MORE_ITEMS;

    }


    //
    // get media type 
    //

    try
    {

        //
        // there is a memory allocation in CMediaType's assignment operator.
        // do assignment inside try/catch
        //

        *pMediaType = m_mt;

    }
    catch(...)
    {
        LOG((MSP_ERROR, 
            "CBRenderPin::GetMediaType - failed to copy media type. E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }


    LOG((MSP_TRACE, "CBRenderPin::GetMediaType - finish."));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STORAGE_STDAFX_DOT_H_)

#define _STORAGE_STDAFX_DOT_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define STRICT

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <mspbase.h>
#include <msxml.h>
#include <Mmreg.h>
#include <vfw.h>

#include <tm.h>


#include "resource.h"


#endif // !defined(_STORAGE_STDAFX_DOT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\sourcepinfilter.cpp ===
#include "stdafx.h"

#include "SourcePinFilter.h"


// {0397F522-8868-4290-95D3-09606CEBD6CF}
static const GUID CLSID_SourceFilter  = 
{ 0x397f522, 0x8868, 0x4290, { 0x95, 0xd3, 0x9, 0x60, 0x6c, 0xeb, 0xd6, 0xcf } };


CBSourceFilter::CBSourceFilter(CCritSec *pLock, HRESULT *phr)
    :m_pSourcePin(NULL),
    m_rtLastSampleEndTime(0),
    m_rtTimeAdjustment(0),
    CBaseFilter(_T("File Terminal Source Filter"),
                    NULL,
                    pLock,
                    CLSID_SourceFilter)
{
    LOG((MSP_TRACE, "CBSourceFilter::CBSourceFilter[%p] - enter", this));


    //
    // create and initialize the pin
    //

    m_pSourcePin = new CBSourcePin(this, pLock, phr);


    //
    // did pin allocation succeed?
    //

    if (NULL == m_pSourcePin)
    {
        LOG((MSP_ERROR, 
            "CBSourceFilter::CBSourceFilter - failed to allocate pin"));

        *phr = E_OUTOFMEMORY;

        return;
    }


    //
    // did pin's constructor succeed?
    //

    if (FAILED(*phr))
    {

        LOG((MSP_ERROR, 
            "CBSourceFilter::CBSourceFilter - pin's constructor failed. hr = %lx",
            *phr));

        delete m_pSourcePin;
        m_pSourcePin = NULL;

        return;
    }



    LOG((MSP_TRACE, "CBSourceFilter::CBSourceFilter - exit"));
}


CBSourceFilter::~CBSourceFilter()
{
    LOG((MSP_TRACE, "CBSourceFilter::~CBSourceFilter[%p] - enter", this));


    //
    // we are in charge of deleting our critical section.
    //
    // assumption -- base class' destructor does not use the lock
    //

    delete m_pLock;
    m_pLock = NULL;


    //
    // let go of our pin
    //

    if (NULL != m_pSourcePin)
    {
        
        delete m_pSourcePin;
        m_pSourcePin = NULL;
    }


    LOG((MSP_TRACE, "CBSourceFilter::~CBSourceFilter - exit"));
}


///////////////////////////////////////////////////////////////////////////////

int CBSourceFilter::GetPinCount()
{
    LOG((MSP_TRACE, "CBSourceFilter::GetPinCount[%p] - enter", this));

    
    m_pLock->Lock();


    if (NULL == m_pSourcePin)
    {

        m_pLock->Unlock();

        LOG((MSP_TRACE, "CBSourceFilter::GetPinCount - no pin. returning 0"));

        return 0;
    }
    

    m_pLock->Unlock();

    LOG((MSP_TRACE, "CBSourceFilter::GetPinCount - finish. returning 1"));

    return 1;
}


///////////////////////////////////////////////////////////////////////////////

    
CBasePin *CBSourceFilter::GetPin(int iPinIndex)
{
    LOG((MSP_TRACE, "CBSourceFilter::GetPin[%p] - enter", this));


    //
    // if the index is anything but 0, return null
    //

    if (0 != iPinIndex)
    {
        LOG((MSP_WARN, 
            "CBSourceFilter::GetPin - iPinIndex is %d. we have at most 1 pin.", 
            iPinIndex));

        return NULL;

    }


    //  
    // from inside a lock return pin pointer.
    //
    // lock does not really do much since we cannot addref the pin...
    //

    m_pLock->Lock();

    CBasePin *pPin = m_pSourcePin;

    m_pLock->Unlock();

    
    LOG((MSP_TRACE, "CBSourceFilter::GetPin - finish. returning pin [%p]", pPin));

    return pPin;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBSourceFilter::SendSample(IN IMediaSample *pSample)
{

    LOG((MSP_TRACE, "CBSourceFilter::SendSample[%p] - enter. pSample[%p]", 
        this, pSample));


    //
    // pin pointer to be used outside the lock
    //

    CBSourcePin *pSourcePin = NULL;


    {
    
        CAutoLock Lock(m_pLock);


        //
        // do nothing if filter is not running
        //
    
        if (State_Running != m_State)
        {

            LOG((MSP_TRACE,
                "CBSourceFilter::SendSample - filter is not running. doing nothing"));

            return S_OK;
        }


        //
        // we should have a pin
        //

        if (NULL == m_pSourcePin)
        {
            LOG((MSP_ERROR, 
                "CBSourceFilter::SendSample - no pin"));

            TM_ASSERT(FALSE);

            return E_FAIL;
        }


        //
        // get and addref pin pointer to use outside the lock
        //

        pSourcePin = m_pSourcePin;

        pSourcePin->AddRef();


#if DBG 

        //
        // log sample length
        //

        //
        // note the funny signature of the function (hr is the size)
        //

        HRESULT dbghr = pSample->GetActualDataLength();

        if (FAILED(dbghr))
        {
            LOG((MSP_ERROR,
                "CBSourceFilter::SendSample - failed to get sample length. hr = %lx",
                dbghr));
        }
        else
        {

            LOG((MSP_TRACE,
                "CBSourceFilter::SendSample - processing sample of data size[0x%lx]",
                dbghr));
        }


    
        //
        // make sure the buffer is writeable
        //


        // get buffer 

        BYTE *pBuffer = NULL;

        HRESULT dbghr1 = pSample->GetPointer(&pBuffer);

        if (FAILED(dbghr1))
        {
            LOG((MSP_ERROR,
                "CBSourceFilter::SendSample - failed to get buffer. hr = %lx",
                dbghr1));
        }
        else
        {

            LOG((MSP_TRACE,
                "CBSourceFilter::SendSample - sample's buffer at [%p]",
                pBuffer));
        }

    
        // get buffer size

        HRESULT dbghr2 = pSample->GetSize();

        SIZE_T nSampleSize = 0;

        if (FAILED(dbghr2))
        {
            LOG((MSP_ERROR,
                "CBSourceFilter::SendSample - failed to get sample's buffer size. hr = %lx",
                dbghr2));
        }
        else
        {

            nSampleSize = dbghr2;


            LOG((MSP_TRACE,
                "CBSourceFilter::SendSample - sample's buffer of size[0x%lx]",
                dbghr2));
        }


        // writeable?

        if ( SUCCEEDED(dbghr1) && SUCCEEDED(dbghr2) )
        {

            if (IsBadWritePtr(pBuffer, dbghr2))
            {
                LOG((MSP_ERROR,
                    "CBSourceFilter::SendSample - buffer not writeable"));
            }
        }

    #endif


        //
        // get timestamp on the sample
        //

        REFERENCE_TIME rtTimeStart = 0;

        REFERENCE_TIME rtTimeEnd   = 0;
    
        HRESULT hrTime = pSample->GetTime(&rtTimeStart, &rtTimeEnd);

        if (FAILED(hrTime))
        {

            LOG((MSP_ERROR,
                "CBSourceFilter::SendSample - failed to get sample's time hr = %lx",
                hrTime));
        }
        else
        {

    #if DBG

            LOG((MSP_TRACE,
                "CBSourceFilter::SendSample - sample's times (ms) Start[%I64d], End[%I64d]",
                ConvertToMilliseconds(rtTimeStart), ConvertToMilliseconds(rtTimeEnd) ));

            if ( (0 == rtTimeStart) && (0 == rtTimeEnd) )
            {

                LOG((MSP_ERROR,
                    "CBSourceFilter::SendSample - samples don't have timestamp!"));
            }


            //
            // make sure start comes first
            //

            if ( rtTimeStart >= rtTimeEnd )
            {

                LOG((MSP_ERROR,
                    "CBSourceFilter::SendSample - sample duration is zero or start time is later than end time"));
            }


            //
            // is this sample out of order?
            //

            if (m_rtLastSampleEndTime > rtTimeStart)
            {
            
                //
                // log the error. we can also see this after reselecting the same 
                // terminal on a different stream, in which case this is ok.
                //

                LOG((MSP_ERROR,
                    "CBSourceFilter::SendSample - sample's timestamp preceeds previous sample's"));
            }

    #endif

            //
            // adjust sample time if it needs to be adjusted.
            //

            if (0 != m_rtTimeAdjustment)
            {
                LOG((MSP_TRACE,
                    "CBSourceFilter::SendSample - adjusting sample time"));

                rtTimeStart += m_rtTimeAdjustment;
                rtTimeEnd += m_rtTimeAdjustment;

                hrTime = pSample->SetTime(&rtTimeStart, &rtTimeEnd);

                //
                // if failed to adjust the timestamp, just log
                //

                if ( FAILED(hrTime) )
                {
                    LOG((MSP_WARN,
                        "CBSourceFilter::SendSample - SetTime failed hr = %lx", hrTime));
                }
            }


            //
            // keep the time of the last sample.
            //

            m_rtLastSampleEndTime = rtTimeEnd;

        }


    } // end of lock


    //
    // ask pin to deliver the sample for us (outside the lock to avoid deadlocks)
    //

    HRESULT hr = pSourcePin->Deliver(pSample);


    //
    // we addref'ed while holding critical section. we'd better release now.
    //

    pSourcePin->Release();
    pSourcePin = NULL;


    LOG((MSP_(hr), "CBSourceFilter::SendSample - finished", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// subsequent samples' timestamps will be adjusted to continue the current
// timeline. the source filter should set disconetinuity flag for us
//

void CBSourceFilter::NewStreamNotification()
{
    LOG((MSP_TRACE, "CBSourceFilter::NewStreamNotification[%p] - enter. ", this));

    CAutoLock Lock(m_pLock);

    m_rtTimeAdjustment = m_rtLastSampleEndTime;

    LOG((MSP_TRACE, "CBSourceFilter::NewStreamNotification - finish. "));
}

///////////////////////////////////////////////////////////////////////////////

IFilterGraph *CBSourceFilter::GetFilterGraphAddRef()
{
    LOG((MSP_TRACE, "CBSourceFilter::GetFilterGraphAddRef[%p] - enter", this));

    
    m_pLock->Lock();

    IFilterGraph *pGraph = m_pGraph;

    if (NULL != pGraph)
    {
        pGraph->AddRef();
    }
   
    m_pLock->Unlock();


    LOG((MSP_TRACE, 
        "CBSourceFilter::GetFilterGraphAddRef- finish. graph[%p]", pGraph));

    return pGraph;

}





///////////////////////////////////////////////////////////////////////////////

HRESULT CBSourceFilter::put_MediaTypeOnFilter(IN const AM_MEDIA_TYPE * const pMediaType)
{

    LOG((MSP_TRACE, "CBSourceFilter::put_MediaTypeOnFilter[%p] - enter.", this));

    CAutoLock Lock(m_pLock);

    
    CMediaType *pMediaTypeObject = NULL;


    try
    {
        //
        // CMediaType constructor can throw if mem alloc fails
        //

        pMediaTypeObject = new CMediaType(*pMediaType);

    }
    catch(...)
    {
        LOG((MSP_ERROR, "CBSourceFilter::put_MediaTypeOnFilter - media type alloc exception"));
    }


    //
    // allocation succeeded?
    //
    
    if (NULL == pMediaTypeObject)
    {
        LOG((MSP_ERROR, "CBSourceFilter::put_MediaTypeOnFilter - failed to allocate media type"));

        return E_OUTOFMEMORY;
    }


    HRESULT hr = m_pSourcePin->SetMediaType(pMediaTypeObject);

    delete pMediaTypeObject;
    pMediaTypeObject = NULL;

    LOG((MSP_(hr), "CBSourceFilter::put_MediaTypeOnFilter - finish. hr = %lx", hr));

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CBSourceFilter::put_MSPAllocatorOnFilter
//
// this is called by the rendering filter in the msp graph to pass us the 
// allocator to use 
//

HRESULT CBSourceFilter::put_MSPAllocatorOnFilter(IN IMemAllocator *pAllocator, BOOL bReadOnly)
{

    LOG((MSP_TRACE, "CBSourceFilter::put_MSPAllocatorOnFilter[%p] - enter.", this));


    CAutoLock Lock(m_pLock);

    HRESULT hr = m_pSourcePin->SetMSPAllocatorOnPin(pAllocator, bReadOnly);

    LOG((MSP_(hr), "CBSourceFilter::put_MSPAllocatorOnFilter - finish. hr = %lx", hr));

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//
//  pin
//
//
///////////////////////////////////////////////////////////////////////////////


CBSourcePin::CBSourcePin(CBSourceFilter *pFilter,
                CCritSec *pLock,
                HRESULT *phr)
    :m_bMediaTypeSet(FALSE),
    m_pMSPAllocator(NULL),
    m_bAllocatorReadOnly(TRUE),
    CBaseOutputPin(
        NAME("CTAPIBridgeSinkInputPin"),
        pFilter,
        pLock,
        phr,
        L"File Terminal Source Output Pin")
{
    LOG((MSP_TRACE, "CBSourcePin::CBSourcePin[%p] - enter.", this));

    LOG((MSP_TRACE, "CBSourcePin::CBSourcePin - finish."));
}


///////////////////////////////////////////////////////////////////////////////


CBSourcePin::~CBSourcePin()
{
    LOG((MSP_TRACE, "CBSourcePin::~CBSourcePin[%p] - enter.", this));


    //
    // release msp allocator if we have one.
    //

    if ( NULL != m_pMSPAllocator )
    {

        LOG((MSP_TRACE,
            "CBRenderFilter::~CBSourcePin - releasing msp allocator [%p].",
            m_pMSPAllocator));

        m_pMSPAllocator->Release();
        m_pMSPAllocator = NULL;
    }


    //
    // release connected pin if we have it.
    //

    if (NULL != m_Connected)
    {
        LOG((MSP_TRACE,
            "CBRenderFilter::~CBSourcePin - releasing connected pin [%p].",
            m_Connected));

        m_Connected->Release();
        m_Connected = NULL;
    }

   

    LOG((MSP_TRACE, "CBSourcePin::~CBSourcePin - finish."));
}


///////////////////////////////////////////////////////////////////////////////

HRESULT CBSourcePin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    LOG((MSP_TRACE, "CBSourcePin::DecideAllocator[%p] - enter.", this));


    //
    // do a basic check on the pin
    //

    if (IsBadReadPtr(pPin, sizeof(IPin)))
    {
        LOG((MSP_ERROR,
            "CBSourcePin::DecideAllocator - bad pin[%p] passed in.", pPin));

        return E_POINTER;
    }


    //
    // do a basic check on the allocator pointer
    //

    if (IsBadWritePtr(ppAlloc, sizeof(IMemAllocator*)))
    {
        LOG((MSP_ERROR,
            "CBSourcePin::DecideAllocator - bad allocator pointer [%p] passed in.", ppAlloc));

        return E_POINTER;
    }

    
    *ppAlloc = NULL;


    CAutoLock Lock(m_pLock);


    //
    // make sure we were given msp allocator
    //

    if (NULL == m_pMSPAllocator)
    {

        LOG((MSP_ERROR,
            "CBSourcePin::DecideAllocator - no MSP allocator."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // we will insist on using msp's allocator
    //

    HRESULT hr = pPin->NotifyAllocator(m_pMSPAllocator, m_bAllocatorReadOnly);

    if (FAILED(hr))
    {

        //
        // input pin does not want us to use our allocator 
        //

        LOG((MSP_ERROR,
            "CBSourcePin::DecideAllocator - input pin's NotifyAllocator failed. "
            "hr = %lx", hr));

        return hr;

    }


    //
    // input pin accepted the fact that we are using msp's allocator. return 
    // the addreffed allocator pointer.
    //

    *ppAlloc = m_pMSPAllocator;
    (*ppAlloc)->AddRef();


    
#ifdef DBG

    //
    // dump allocator properties in debug build
    //

    ALLOCATOR_PROPERTIES AllocProperties;

    hr = m_pMSPAllocator->GetProperties(&AllocProperties);

    if (FAILED(hr))
    {
        
        //
        // just log 
        //

        LOG((MSP_ERROR, 
            "CBSourcePin::DecideAllocator - failed to get allocator properties. hr = %lx",
            hr));

    }
    else
    {

        DUMP_ALLOC_PROPS("CBSourcePin::DecideAllocator - ", &AllocProperties);
    }

#endif


    LOG((MSP_TRACE, "CBSourcePin::DecideAllocator - finish."));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////


HRESULT CBSourcePin::DecideBufferSize(IMemAllocator *pAlloc,
                                      ALLOCATOR_PROPERTIES *pProperties)
{

    LOG((MSP_TRACE, "CBSourcePin::DecideBufferSize[%p] - enter.", this));


    DUMP_ALLOC_PROPS("CBSourcePin::DecideBufferSize - received:", pProperties);


    //
    // make sure we were given msp allocator
    //

    if (NULL == m_pMSPAllocator)
    {

        LOG((MSP_ERROR,
            "CBSourcePin::DecideBufferSize - no MSP allocator."));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // get allocator properties from msp's allocator
    //

    ALLOCATOR_PROPERTIES MSPAllocatorProperties;

    HRESULT hr = m_pMSPAllocator->GetProperties(&MSPAllocatorProperties);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "CBSourcePin::DecideBufferSize - failed to get allocator properties from MSP allocator. hr = %lx",
            hr));

        return hr;
    }

    
    DUMP_ALLOC_PROPS("CBSourcePin::DecideBufferSize - MSP graph's:", &MSPAllocatorProperties);


    //
    // we will be emitting samples that we get from the msp graph, so we can
    // not promise anything more than msp's allocator can handle. 
    //
    // but we can promise less, if we are asked for fewer or smaller buffers.
    //
    // the only thing we cannot compromize on is prefix!
    //


    //
    // if we are asked for smaller buffers than what the msp provides, this is 
    // what we will be requesting of the local allocator
    //

    if ( (0 != pProperties->cbBuffer) && 
        (MSPAllocatorProperties.cbBuffer > pProperties->cbBuffer) )
    {
        
        //
        // the downstream filters will not need more than they asked for, so 
        // even though we will be passing larger buffers (allocated by msp's 
        // allocator), scale down our request to the allocator.
        //

        MSPAllocatorProperties.cbBuffer = pProperties->cbBuffer;
    }


    //
    // same logic applies to the number of buffer:
    //
    // if the downstream filters need fewer buffers than we already have (from
    // the msp's allocator) do not stress local allocator requesting too more
    // buffers than this graph actually needs.
    //

    if ( (0 != pProperties->cBuffers) && (MSPAllocatorProperties.cBuffers > pProperties->cBuffers) )
    {
        
        //
        // the downstream filters will not need more than they asked for, so
        // even though we will have more buffers allocated by msp's allocator,
        // scale down our request to the allocator of this stream.
        //

        MSPAllocatorProperties.cBuffers = pProperties->cBuffers;
    }


    //
    // tell the allocator what we want
    //

    DUMP_ALLOC_PROPS("CBSourcePin::DecideBufferSize - requesting from the allocator:", &MSPAllocatorProperties);

    ALLOCATOR_PROPERTIES Actual;

    
    hr = pAlloc->SetProperties(&MSPAllocatorProperties, &Actual);


    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CBSourcePin::DecideBufferSize - allocator refused our properties. hr = %lx", hr));

        return hr;
    }


    //
    // log properties that allocator said it could provide
    //

    DUMP_ALLOC_PROPS("CBSourcePin::DecideBufferSize - actual", &Actual);


    //
    // the prefix agreed on by the allocator must be the same as of the msp's.
    //

    if (MSPAllocatorProperties.cbPrefix != Actual.cbPrefix)
    {

        LOG((MSP_ERROR, 
            "CBSourcePin::DecideBufferSize - allocator insists on a different prefix"));

        return E_FAIL;
    }


    //
    // if the allocator insists on larger samples that we can provide, also fail
    //
    // (that would be pretty weird, by the way)
    //

    if ( MSPAllocatorProperties.cbBuffer < Actual.cbBuffer )
    {

        LOG((MSP_ERROR, 
            "CBSourcePin::DecideBufferSize - allocator can only generate samples bigger than what we can provide"));

        return E_FAIL;
    }


    *pProperties = Actual;

    LOG((MSP_TRACE, "CBSourcePin::DecideBufferSize - finish."));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
HRESULT CBSourcePin::CheckMediaType(
    const CMediaType *pMediaType
    )
{
    LOG((MSP_TRACE, "CBSourcePin::CheckMediaType[%p] - enter.", this));


    //
    // make sure the structure we got is good
    //

    //
    // good media type structure?
    //

    if (IsBadMediaType(pMediaType))
    {
        LOG((MSP_ERROR,
            "CBSourcePin::CheckMediaType - bad media type stucture passed in"));
        
        return E_POINTER;
    }


    if ( !pMediaType->IsValid() )
    {

        LOG((MSP_ERROR,
            "CBSourcePin::CheckMediaType - media type invalid. "
            "VFW_E_INVALIDMEDIATYPE"));
        
        return VFW_E_INVALIDMEDIATYPE;
    }



    CAutoLock Lock(m_pLock);


    //
    // should have media type by now
    //

    if ( ! m_bMediaTypeSet )
    {

        LOG((MSP_ERROR, 
            "CBSourceFilter::CheckMediaType - don't have media type. "
            "VFW_E_NO_TYPES"));

        //
        // the filter was selected, but its media type is not yet known? 
        // something is not kosher
        //

        TM_ASSERT(FALSE);

        return VFW_E_NO_TYPES;
    }


    //
    // is this the same media type as what we have?
    //

    if (!IsEqualMediaType(m_mt, *pMediaType))
    {
        LOG((MSP_WARN, 
            "CBSourceFilter::CheckMediaType - different media types"));

        return VFW_E_TYPE_NOT_ACCEPTED;

    }


    LOG((MSP_TRACE, "CBSourcePin::CheckMediaType - finish."));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBSourcePin::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
{
    LOG((MSP_TRACE, "CBSourcePin::GetMediaType[%p] - enter.", this));


    //
    // make sure the pointer is good
    //

    if (IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)))
    {
        LOG((MSP_TRACE, "CBSourcePin::GetMediaType - bad media type pointer passed in."));

        TM_ASSERT(FALSE);

        return E_POINTER;
    }


    //
    // we have at most one media type.
    //

    if ( (iPosition != 0) )
    {
        LOG((MSP_WARN, 
            "CBSourcePin::GetMediaType - position[%d] is not 0. VFW_S_NO_MORE_ITEMS.", 
            iPosition));


        return VFW_S_NO_MORE_ITEMS;
    }


    //
    // do we have at least one media type?
    //

    if ( ! m_bMediaTypeSet )
    {
        LOG((MSP_WARN, 
            "CBSourcePin::GetMediaType - don't yet have a media type. VFW_S_NO_MORE_ITEMS."));

        
        //
        // we should have format by now
        //

        TM_ASSERT(FALSE);

        return VFW_S_NO_MORE_ITEMS;
    }


    //
    // get media type 
    //

    try
    {

        //
        // there is a memory allocation in CMediaType's assignment operator.
        // do assignment inside try/catch
        //

        *pMediaType = m_mt;

    }
    catch(...)
    {

        LOG((MSP_ERROR, 
            "CBSourcePin::GetMediaType - failed to copy media type. E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }


    LOG((MSP_TRACE, "CBSourcePin::GetMediaType - finish."));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CBSourcePin::SetMSPAllocatorOnPin(IN IMemAllocator *pAllocator, BOOL bReadOnly)
{
    
    LOG((MSP_TRACE,
        "CBSourcePin::SetMSPAllocatorOnPin[%p] - enter, pAllocator[%p]",
        this, pAllocator));


    CAutoLock Lock(m_pLock);


    //
    // already have msp allocator? release it.
    //

    if ( NULL != m_pMSPAllocator )
    {

        LOG((MSP_TRACE,
            "CBRenderFilter::SetMSPAllocatorOnPin - releasing existing allocator [%p].",
            m_pMSPAllocator));

        m_pMSPAllocator->Release();
        m_pMSPAllocator = NULL;
    }

    
    //
    // keep the new allocator
    //

    m_pMSPAllocator = pAllocator;

    LOG((MSP_TRACE,
        "CBRenderFilter::SetMSPAllocatorOnPin - keeping new allocator [%p].",
        m_pMSPAllocator));



    //
    // keep allocator's readonly attribute
    //

    m_bAllocatorReadOnly = bReadOnly;


    //
    // addref if got something good
    //

    if (NULL != m_pMSPAllocator)
    {

        m_pMSPAllocator->AddRef();
    }


    LOG((MSP_TRACE, "CBSourcePin::SetMSPAllocatorOnPin - exit."));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//

HRESULT CBSourcePin::SetMediaType(const CMediaType *pmt)
{
    
    LOG((MSP_TRACE, "CBSourcePin::SetMediaType[%p] - enter", this));

    
    //
    // good media type structure?
    //

    if (IsBadMediaType(pmt))
    {
        LOG((MSP_ERROR,
            "CBSourcePin::SetMediaType - bad media type stucture passed in"));
        
        return E_POINTER;
    }


    CAutoLock Lock(m_pLock);


    //
    // media type already set?
    //

    if ( m_bMediaTypeSet )
    {

        LOG((MSP_TRACE,
            "CBRenderFilter::SetMediaType - media format already set."));


        //
        // media type must be the same as what we already have
        //

        if (!IsEqualMediaType(m_mt, *pmt))
        {
            LOG((MSP_WARN,
                "CBSourceFilter::SetMediaType - format different from previously set "
                "VFW_E_TYPE_NOT_ACCEPTED"));

            return VFW_E_CHANGING_FORMAT;

        }
        else
        {

            LOG((MSP_TRACE,
                "CBRenderFilter::SetMediaType - same format. accepting."));
        }
    }


    //
    // pass media type to the base class
    //

    HRESULT hr = CBasePin::SetMediaType(pmt);


    if (SUCCEEDED(hr))
    {

        m_bMediaTypeSet = TRUE;
    }


    LOG((MSP_(hr), "CBSourcePin::SetMediaType - exit. hr = %lx", hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\sourcepinfilter.h ===
///////////////////////////////////////////////////////////////////////////////
//
// recording source pin and filter
//
// multi-pin source filter in the recording graph
//

#include <streams.h>


///////////////////////////////////////////////////////////////////////////////
//
// pin
//


class CBSourceFilter;

class CBSourcePin : public CBaseOutputPin
{

public:


    CBSourcePin(CBSourceFilter *pFilter,
                CCritSec *pLock,
                HRESULT *phr);

    ~CBSourcePin();


    //
    // this method is called by the rendering filter when it gets an allocator
    // we need its allocator so we know what to expect, and what to promise to
    // others
    //

    HRESULT SetMSPAllocatorOnPin(IN IMemAllocator *pAllocator, BOOL bReadOnly);


    //
    // CBasePin override
    //

    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT SetMediaType(const CMediaType *pmt);

    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);


    //
    // CBaseOutputPin override
    //

    HRESULT DecideBufferSize(IMemAllocator *pMemoryAllocator, ALLOCATOR_PROPERTIES *AllocProps);


    //
    // the function called by the input pin in the filter graph to introduce
    // its sample into our filter graph
    //
    
    // impl: this function calls CBaseOutputPin's Deliver()

    HRESULT SubmitSample(IN IMediaSample *pSample);

private:


    IMemAllocator *m_pMSPAllocator;

    BOOL m_bAllocatorReadOnly;

    BOOL m_bMediaTypeSet;
};


///////////////////////////////////////////////////////////////////////////////
//
// filter

class CBSourceFilter : public CBaseFilter 
{

public:

    int GetPinCount();
    CBasePin *GetPin(int iPinIndex);


    CBSourceFilter(CCritSec *pLock, HRESULT *phr);
    ~CBSourceFilter();

    
    //
    // this method returns an addref'fed pointer to filter graph, or NULL if 
    // there is none.
    //

    IFilterGraph *GetFilterGraphAddRef();


    //
    // these methods are called by the rendering filter when it knows its format/alloc props
    //

    HRESULT put_MediaTypeOnFilter(IN const AM_MEDIA_TYPE *pMediaType);
    HRESULT put_MSPAllocatorOnFilter(IN IMemAllocator *pAllocator, BOOL bReadOnly);


    //
    // this method is called by the rendering filter when it has a sample to 
    // deliver
    //

    HRESULT SendSample(IN IMediaSample *pSample);

    
    //
    // this method is called by record unit when it is about to start recording
    // on a new stream
    //

    void NewStreamNotification();

private:

    CBSourcePin *m_pSourcePin;

    REFERENCE_TIME m_rtLastSampleEndTime;
    
    REFERENCE_TIME m_rtTimeAdjustment;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\terminals\storage\storagefactory.cpp ===
// StorageFactory.cpp : Implementation of CDelme2App and DLL registration.

#include "stdafx.h"
#include "StorageFactory.h"



HRESULT STDMETHODCALLTYPE SetIStorage(
        IN IStorage *pIStorage,
        IN const EnStorageMode enStorageMode,
        OUT ITStorage **ppStorage)
{
    LOG((MSP_TRACE, "CTStorageFactory::SetIStorage - enter"));
    
    LOG((MSP_TRACE, "CTStorageFactory::SetIStorage - completed"));

    return E_NOTIMPL;
}



HRESULT OpenStorage(
    IN const OLECHAR *pwcsStorageName,
    EnStorageMode enStorageMode,
    OUT ITStorage **ppStorage)
{

    LOG((MSP_TRACE, "CTStorageFactory::OpenStorage - enter"));


    //
    // check arguments
    // 

    if (IsBadWritePtr(ppStorage, sizeof(ITStorage*)))
    {
        LOG((MSP_ERROR, "CTStorageFactory::OpenStorage - bad pointer passed in ppStorage %p", ppStorage));

        return E_POINTER;
    }


    //
    // don't return garbage if we fail
    //

    *ppStorage = NULL;


    if (IsBadStringPtr(pwcsStorageName, -1))
    {
        LOG((MSP_ERROR, "CTStorageFactory::PrepareStorage - bad pointer passed in pwcsStorageName %p", pwcsStorageName));

        return E_POINTER;
    }


    LOG((MSP_TRACE, "CTStorageFactory::OpenStorage - opening [%S] in mode [%x]", pwcsStorageName, enStorageMode));

    
    //
    // get file extension
    //

    OLECHAR *pszExtention = wcsrchr(pwcsStorageName, '.');


    //
    // make sure file has extension
    //

    if (NULL == pszExtention)
    {
        LOG((MSP_ERROR, "CTStorageFactory::OpenStorage - file name %S does not have extentsion", pwcsStorageName));

        return TAPI_E_NOTSUPPORTED;
    }

    
    //
    // extension follows the dot. 
    //

    pszExtention++;
    
    //
    // (pszExtention is still valid -- if the dot was at the end,
    // we now point to \0)
    //


    CLSID clsID;


    //
    // check extention. we currently only support AVI and wav
    // make this logic more flexible if we want to support asf, wma, wmv)
    //


    if (0 == _wcsicmp(pszExtention, L"avi"))
    {
        LOG((MSP_TRACE, "CTStorageFactory::OpenStorage - creating avi storage unit"));

        //
        // create avi storage
        //

        clsID = CLSID_TStorageUnitAVI;

    }
    else if (0 == _wcsicmp(pszExtention, L"wav"))
    {

        LOG((MSP_TRACE, "CTStorageFactory::OpenStorage - creating wav storage unit"));

        
        //
        // create wav storage
        //

        clsID = CLSID_TStorageUnitAVI;

    }
    else
    {
        //
        // failed to recognize file type
        //

        LOG((MSP_ERROR, "CTStorageFactory::OpenStorage - unrecognized file type"));

        return TAPI_E_NOTSUPPORTED;
    }


    //
    // we know the storage unit class id. attemt to create it
    //

    ITStorage *pStorageUnit = NULL;

    HRESULT hr = CoCreateInstance(clsID,
                    NULL,
                    CLSCTX_ALL,
                    IID_ITStorage, 
                    (void**)&pStorageUnit
                    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CTStorageFactory::OpenStorage - failed to instantiate storage unit"));

        return hr;
    }


    //
    // configure storage unit with file name
    //

    hr = pStorageUnit->Initialize(pwcsStorageName, enStorageMode);


    //
    // if failed, cleanup and bail out
    //

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CTStorageFactory::OpenStorage - failed to initialize storage unit, hr = %lx", hr));

        pStorageUnit->Release();

        return hr;
    }


    //
    // everything went well -- return ITStorage interface of the storage unit 
    // we have just created
    //

    *ppStorage = pStorageUnit;


    LOG((MSP_TRACE, "CTStorageFactory::OpenStorage - exit. returning storage unit %p", *ppStorage));
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\dlldatax.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#if !defined(AFX_DLLDATAX_H__28DCD867_ACA4_11D0_A028_00AA00B605A4__INCLUDED_)
#define AFX_DLLDATAX_H__28DCD867_ACA4_11D0_A028_00AA00B605A4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__28DCD867_ACA4_11D0_A028_00AA00B605A4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\dlldatax.c ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400 //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "termmgr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\allterm.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    AllTerm.h

Abstract:

    Includes all the individual terminal headers

--*/

#include "tmvidrnd.h"
#include "newmes.h"

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\manager.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//
//        Copyright (c) 1998-1999  Microsoft Corporation
//
//        Name: Manager.cpp
//
// Description: Implementation of the CTerminalManager object
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "termmgr.h"
#include "manager.h"
#include "PTUtil.h"

#define INSTANTIATE_GUIDS_NOW
#include "allterm.h"
#undef INSTANTIATE_GUIDS_NOW

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CTerminalManager constructor
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//


CTerminalManager::CTerminalManager()
{
    LOG((MSP_TRACE, "CTerminalManager::CTerminalManager - enter"));
    LOG((MSP_TRACE, "CTerminalManager::CTerminalManager - exit"));
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// GetDynamicTerminalClasses
//
// The MSP will call this method to get a list of dynamic terminal classes
// that the Terminal Manager supports.  The MSP is responsible for allocating
// and deallocating the ppTerminals buffer.
//
// Parameters:
//     dwMediaType:      [in] A DWORD bitmask consisting of one or more
//                           TAPIMEDIATYPEs ORed together. Most MSPs will
//                           pass in (DWORD) (TAPIMEDIATYPE_AUDIO |
//                           TAPIMEDIATYPE_VIDEO). If an MSP is only
//                           interested in terminal classes that can be used
//                           to create terminals with a particular media
//                           type, it may pass in that media type instead
//                           (e.g., TAPIMEDIATYPE_AUDIO).
//     pdwNumClasses:    [in, out] Pointer to a DWORD.  On entry, indicates
//                           the size of the buffer pointed to in
//                           pTerminalClasses. On success, it will be filled
//                           in with the actual number of class IIDs returned.
//                           If the buffer is not big enough, the method will
//                           return TAPI_E_NOTENOUGHMEMORY, and it will be
//                           filled in the with number of IIDs needed. 
//     pTerminalClasses: [out] On success, filled in with an array of terminal
//                           class IIDs that are supported by the MSP for this
//                           address.  This value may be NULL, in which case
//                           pdwNumClasses will return the needed buffer size.
//
// Returns:
//     S_OK                   Success.
//     E_POINTER              A pointer argument is invalid.
//     TAPI_E_NOTENOUGHMEMORY The specified buffer is not large enough to
//                                contain all of the available dynamic
//                                terminal classes.


STDMETHODIMP CTerminalManager::GetDynamicTerminalClasses(
        IN     DWORD                dwMediaTypes,
        IN OUT DWORD              * pdwNumClasses,
        OUT    IID                * pTerminalClasses
        )
{ 
    //
    // no shared data = no locking here
    //

    LOG((MSP_TRACE, "CTerminalManager::GetDynamicTerminalClasses - enter"));

    //
    // Check parameters.
    //

    if ( TM_IsBadWritePtr(pdwNumClasses, sizeof(DWORD) ) )
    { 
        LOG((MSP_ERROR, "CTerminalManager::GetDynamicTerminalClasses - "
            "bad NumClasses pointer - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // Let's find also the temrinals from the registry
    //

    CLSID* pTerminals = NULL;
    DWORD dwTerminals = 0;
    HRESULT hr = E_FAIL;

    hr = CPTUtil::ListTerminalClasses( 
        dwMediaTypes, 
        &pTerminals,
        &dwTerminals
        );

    if( FAILED(hr) )
    {

        LOG((MSP_ERROR, "CTerminalManager::GetDynamicTerminalClasses - "
            "ListTerminalClasses failed - returning 0x%08x", hr)); 
        return hr;
    }

    //
    // If the caller is just asking for the needed buffer size, tell them.
    //

    if (pTerminalClasses == NULL)
    {
        *pdwNumClasses = dwTerminals;
        delete[] pTerminals;

        LOG((MSP_TRACE, "CTerminalManager::GetDynamicTerminalClasses - "
            "provided needed buffer size - "
            "returning S_OK")); 

        return S_OK;
    }

    //
    // Otherwise, the caller is asking for the terminal classes.
    //

    if ( TM_IsBadWritePtr(pTerminalClasses, (*pdwNumClasses) * sizeof(IID) ) )
    { 
        delete[] pTerminals;

        LOG((MSP_ERROR, "CTerminalManager::GetDynamicTerminalClasses - "
            "bad TerminalClasses pointer - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // See if the caller gave us enough buffer space to return all the terminal
    // classes. If not, tell them so and stop.
    //

    if ( dwTerminals > *pdwNumClasses )
    {
        //
        // Fill in the number of classes that are available.
        //

        *pdwNumClasses = dwTerminals;
        delete[] pTerminals;

        LOG((MSP_ERROR, "CTerminalManager::GetDynamicTerminalClasses - "
            "not enough space for requested info - "
            "returning TAPI_E_NOTENOUGHMEMORY")); 

        return TAPI_E_NOTENOUGHMEMORY;
    }

    //
    // Copy the terminal classes that match this/these media type(s)
    // and direction(s).
    //


    //
    // Copy the terminals from registry
    //

    for( DWORD dwTerminal = 0; dwTerminal < dwTerminals; dwTerminal++)
    {
        pTerminalClasses[dwTerminal] = pTerminals[dwTerminal];
    }

    *pdwNumClasses = dwTerminals;

    delete[] pTerminals;

    LOG((MSP_TRACE, "CTerminalManager::GetDynamicTerminalClasses - exit S_OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// CreateDynamicTerminal
//
// This method is called by the MSP to create a dynamic terminal object.  The
// Terminal Manager verifies that the MediaType and Direction are valid for
// the terminal class being created.  This call AddRef()s the terminal object
// before returning it.
//
// Parameters:
//     iidTerminalClass: [in] IID of the terminal class to be created.
//     dwMediaType:      [in] TAPI media type of the terminal to be created.
//     Direction:        [in] Terminal direction of the terminal to be
//                           created.
//     ppTerminal:       [out] Returned created terminal object
//
// Returns:
//
// S_OK           Success.
// E_POINTER      A pointer argument is invalid.
// E_OUTOFMEMORY  There is not enough memory to create the terminal object.
// E_INVALIDARG   The terminal class is invalid or not supported, or the media
//                    type or direction is invalid for the indicated terminal
//                    class.
//


STDMETHODIMP CTerminalManager::CreateDynamicTerminal(
        IN  IUnknown            * pOuterUnknown,
        IN  IID                   iidTerminalClass,
        IN  DWORD                 dwMediaType,
        IN  TERMINAL_DIRECTION    Direction,
        IN  MSP_HANDLE            htAddress,
        OUT ITTerminal         ** ppTerminal
        )
{
    //
    // no shared data = no locking here
    //

    LOG((MSP_TRACE, "CTerminalManager::CreateDynamicTerminal - enter"));

    //
    // Check parameters.
    // Only one media type can be set.
    //

    if ( (pOuterUnknown != NULL) &&
         IsBadReadPtr(pOuterUnknown, sizeof(IUnknown)) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "outer unknown pointer invalid - returning E_POINTER"));

        return E_POINTER;
    }

    if ( TM_IsBadWritePtr(ppTerminal, sizeof(ITTerminal *)) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "terminal output pointer invalid - returning E_POINTER"));

        return E_POINTER;
    }


    //
    // dwMediaType can be a combination of media types, but it still must be 
    // legal
    //

    if ( !IsValidAggregatedMediaType(dwMediaType) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "ivalid media type [%lx] requested - returning E_INVALIDARG", dwMediaType));

        return E_INVALIDARG;
    }

    //
    // Verify also TD_MULTITRACK_MIXED
    //

    if ( ( Direction != TD_CAPTURE ) && 
         ( Direction != TD_RENDER )  &&
         ( Direction != TD_MULTITRACK_MIXED))
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "invalid direction requested - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Declare CLSID for plug-in terminal
    //

    CLSID clsidTerminal = CLSID_NULL;

    //
    // Go to find out the terminal in registry
    //

    HRESULT hr = E_FAIL;
    CPTTerminal Terminal;

    hr = CPTUtil::SearchForTerminal(
        iidTerminalClass,
        dwMediaType,
        Direction,
        &Terminal);

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "SearchForTerminal failed - returning 0x%08x", hr));
        return hr;
    }

    //
    // Using the CLSID field in our array entry, CoCreate the dynamic
    // terminal.
    //

    hr = CoCreateInstance(Terminal.m_clsidCOM,
                          pOuterUnknown,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTerminal,
                          (void **) ppTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "CoCreateInstance of requested terminal failed - "
            "returning 0x%08x", hr));

        return hr;
    }

    //
    // Initialize the dynamic terminal instance with the media type
    // and direction.
    //

    ITPluggableTerminalInitialization * pTerminalInitialization;

    hr = (*ppTerminal)->QueryInterface(IID_ITPluggableTerminalInitialization,
                                       (void **) &pTerminalInitialization);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "QueryInterface for private terminal interface failed - "
            "returning 0x%08x", hr));

        (*ppTerminal)->Release();
        *ppTerminal = NULL;       // make buggy apps more explicitly buggy

        return hr;
    }

    hr = pTerminalInitialization->InitializeDynamic(iidTerminalClass,
                                     dwMediaType,
                                     Direction,
                                     htAddress);

    pTerminalInitialization->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTerminalManager::CreateDynamicTerminal - "
            "private Initialize() failed - "
            "returning 0x%08x", hr));

        (*ppTerminal)->Release();
        *ppTerminal = NULL;       // make buggy apps more explicitly buggy

        return hr;
    }

    LOG((MSP_TRACE, "CTerminalManager::CreateDynamicTerminal - "
        "exit S_OK"));
    return S_OK;
}

// ITTerminalManager2

STDMETHODIMP CTerminalManager::GetPluggableSuperclasses(
        IN OUT  DWORD                  * pdwNumSuperclasses,
        OUT     IID                    * pSuperclasses
        )
{
    LOG((MSP_TRACE, "CTerminalManager::GetPluggableSuperclasses - enter"));

    //
    // Check parameters.
    //

    if ( TM_IsBadWritePtr(pdwNumSuperclasses, sizeof(DWORD) ) )
    { 
        LOG((MSP_ERROR, "CTerminalManager::GetPluggableSuperclasses - "
            "bad NumClasses pointer - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // The SafeArray VAriant for Superclasses
    //

    HRESULT hr = E_FAIL;
    CLSID* pSuperclassesCLSID = NULL;
    DWORD dwSuperclasses = 0;

    hr = CPTUtil::ListTerminalSuperclasses( 
        &pSuperclassesCLSID,
        &dwSuperclasses
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTerminalManager::GetPluggableSuperclasses - "
            "ListTerminalSuperclasses failed - returning 0x%08x", hr)); 
        return hr;
    }

    //
    // If the caller is just asking for the needed buffer size, tell them.
    //

    if (pSuperclasses == NULL)
    {
        *pdwNumSuperclasses = dwSuperclasses;

        delete[] pSuperclassesCLSID;

        LOG((MSP_TRACE, "CTerminalManager::GetPluggableSuperclasses - "
            "provided needed buffer size - returning S_OK")); 

        return S_OK;
    }

    //
    // Otherwise, the caller is asking for the terminal classes.
    //

    if ( TM_IsBadWritePtr(pSuperclasses, (*pdwNumSuperclasses) * sizeof(IID) ) )
    { 
        delete[] pSuperclassesCLSID;

        LOG((MSP_ERROR, "CTerminalManager::GetPluggableSuperclasses - "
            "bad Superclasses pointer - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // See if the caller gave us enough buffer space to return all the terminal
    // classes. If not, tell them so and stop.
    //

    if ( dwSuperclasses > *pdwNumSuperclasses )
    {
        //
        // Fill in the number of classes that are available.
        //

        *pdwNumSuperclasses = dwSuperclasses;

        delete[] pSuperclassesCLSID;

        LOG((MSP_ERROR, "CTerminalManager::GetPluggableSuperclasses - "
            "not enough space for requested info - "
            "returning TAPI_E_NOTENOUGHMEMORY")); 

        return TAPI_E_NOTENOUGHMEMORY;
    }

    //
    // Copy the terminal classes that match this/these media type(s)
    // and direction(s).
    //

    for( DWORD dwSuperclass = 0; dwSuperclass < dwSuperclasses; dwSuperclass++)
    {
        pSuperclasses[dwSuperclass] = pSuperclassesCLSID[dwSuperclass];
    }

    *pdwNumSuperclasses = dwSuperclasses;

    // Clean-up
    delete[] pSuperclassesCLSID;
    
    LOG((MSP_TRACE, "CTerminalManager::GetPluggableSuperclasses - exit S_OK"));
    return S_OK;
}

STDMETHODIMP CTerminalManager::GetPluggableTerminalClasses(
        IN      IID                      iidSuperclass,
        IN      DWORD                    dwMediaTypes,
        IN OUT  DWORD                  * pdwNumTerminals,
        OUT     IID                    * pTerminals
        )
{
    LOG((MSP_TRACE, "CTerminalManager::GetPluggableTerminalClasses - enter"));

    //
    // Check parameters.
    //

    if ( TM_IsBadWritePtr(pdwNumTerminals, sizeof(DWORD) ) )
    { 
        LOG((MSP_ERROR, "CTerminalManager::GetPluggableTerminalClasses - "
            "bad NumSuperlasses pointer - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // Get BSTR for iidSuperclass
    //

    if( dwMediaTypes == 0)
    {
        LOG((MSP_ERROR, "CTerminalManager::GetPluggableTerminalClasses exit -"
            "dwMediaTypes invalid, returns E_INVALIDARG"));

        return E_INVALIDARG;
    }

    if( (dwMediaTypes & (
        ((long)TAPIMEDIATYPE_AUDIO) | 
        ((long)TAPIMEDIATYPE_VIDEO) | 
        ((long)TAPIMEDIATYPE_MULTITRACK))) != dwMediaTypes )
    {
        LOG((MSP_ERROR, "CTerminalManager::GetPluggableTerminalClasses exit -"
            "dwMediaTypes invalid, returns E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Get the object Superclass
    //

    CPTSuperclass Superclass;
    Superclass.m_clsidSuperclass = iidSuperclass;


    //
    // Get the terminals for this superclass
    //

    CLSID* pTerminalClasses = NULL;
    DWORD dwTerminalClasses = 0;
    HRESULT hr = E_FAIL;
    
    hr = Superclass.ListTerminalClasses( 
        dwMediaTypes, 
        &pTerminalClasses,
        &dwTerminalClasses
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CTerminalManager::GetPluggableTerminalClasses - "
            "ListTerminalClasses failed - returning 0x%08x", hr)); 
        return hr;
    }

    //
    // If the caller is just asking for the needed buffer size, tell them.
    //

    if (pTerminals == NULL)
    {
        *pdwNumTerminals = dwTerminalClasses;

        delete[] pTerminalClasses;

        LOG((MSP_TRACE, "CTerminalManager::GetPluggableTerminalClasses - "
            "provided needed buffer size - "
            "returning S_OK")); 

        return S_OK;
    }

    //
    // Otherwise, the caller is asking for the terminal classes.
    //

    if ( TM_IsBadWritePtr(pTerminals, (*pdwNumTerminals) * sizeof(IID) ) )
    { 
        delete[] pTerminalClasses;

        LOG((MSP_ERROR, "CTerminalManager::GetPluggableTerminalClasses - "
            "bad TerminalClasses pointer - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // See if the caller gave us enough buffer space to return all the terminal
    // classes. If not, tell them so and stop.
    //

    if ( dwTerminalClasses > *pdwNumTerminals )
    {
        //
        // Fill in the number of classes that are available.
        //

        *pdwNumTerminals = dwTerminalClasses;

        delete[] pTerminalClasses;

        LOG((MSP_ERROR, "CTerminalManager::GetPluggableTerminalClasses - "
            "not enough space for requested info - "
            "returning TAPI_E_NOTENOUGHMEMORY")); 

        return TAPI_E_NOTENOUGHMEMORY;
    }

    //
    // Copy the terminal classes that match this/these media type(s)
    // and direction(s).
    //


    for( DWORD dwTerminal = 0; dwTerminal < dwTerminalClasses; dwTerminal++)
    {
        pTerminals[dwTerminal] = pTerminalClasses[dwTerminal];
    }

    *pdwNumTerminals = dwTerminalClasses;

    // Clean-up
    delete[] pTerminalClasses;
    
    LOG((MSP_TRACE, "CTerminalManager::GetPluggableTerminalClasses - exit S_OK"));
    return S_OK;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\manager.h ===
///////////////////////////////////////////////////////////////////////////////
//
//
//        Copyright (c) 1998-1999  Microsoft Corporation
//
//
//        Name: Manager.h
//
// Description: Definition of the CTerminalManager class
//
///////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MANAGER_H__E75F58A3_AD1C_11D0_A028_00AA00B605A4__INCLUDED_)
#define AFX_MANAGER_H__E75F58A3_AD1C_11D0_A028_00AA00B605A4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CTerminalManager                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


class CTerminalManager : 
    public ITTerminalManager2,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTerminalManager,&CLSID_TerminalManager>
{

public:

    CTerminalManager();

    BEGIN_COM_MAP(CTerminalManager)
        COM_INTERFACE_ENTRY(ITTerminalManager)
        COM_INTERFACE_ENTRY(ITTerminalManager2)
    END_COM_MAP()

    DECLARE_VQI()
    DECLARE_REGISTRY_RESOURCEID(IDR_TerminalManager)

// ITTerminalManager
public:

    STDMETHOD(GetDynamicTerminalClasses)(
	        IN      DWORD                    dwMediaTypes,
	        IN OUT  DWORD                  * pdwNumClasses,
	        OUT     IID                    * pTerminalClasses
	        );

    STDMETHOD(CreateDynamicTerminal)(
            IN      IUnknown               * pOuterUnknown,
	        IN      IID                      iidTerminalClass,
	        IN      DWORD                    dwMediaType,
	        IN      TERMINAL_DIRECTION       Direction,
            IN      MSP_HANDLE               htAddress,
	        OUT     ITTerminal            ** ppTerminal
	        );

// ITTerminalManager2
public:

    STDMETHOD(GetPluggableSuperclasses)(
	        IN OUT  DWORD                  * pdwNumSuperclasses,
	        OUT     IID                    * pSuperclasses
	        );

    STDMETHOD(GetPluggableTerminalClasses)(
            IN      IID                    iidSuperclass,
	        IN      DWORD                    dwMediaTypes,
	        IN OUT  DWORD                  * pdwNumTerminals,
	        OUT     IID                    * pTerminals
	        );
    
};

#endif // !defined(AFX_MANAGER_H__E75F58A3_AD1C_11D0_A028_00AA00B605A4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\medpump.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#include "stdafx.h"
#include "atlconv.h"
#include "termmgr.h"
#include "meterf.h"
#include "medpump.h"

#include <stdio.h>
#include <limits.h>
#include <tchar.h>

//
// the default value for maximum number of filters serviced by a single 
// pump. can also be configurable through registry.
//

#define DEFAULT_MAX_FILTER_PER_PUMP (20)


//
// registry location where max number of filters per pump is configured
//

#define MST_REGISTRY_PATH _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\MST")
#define MAX_FILTERS_PER_PUMP_KEY _T("MaximumFiltersPerPump")

DWORD WINAPI WriteMediaPumpThreadStart(void *pvPump)
{
    return ((CMediaPump *)pvPump)->PumpMainLoop();
}


CMediaPump::CMediaPump(
    )
    : m_hThread(NULL),
      m_hRegisterBeginSemaphore(NULL),
      m_hRegisterEndSemaphore(NULL)
{
    HRESULT hr;

    LOG((MSP_TRACE, "CMediaPump::CMediaPump - enter"));



    // create semaphores for registration signaling and completion - 
    // m_hRegisterBeginSemaphore is signaled before the Register call tries to acquire  
    // the critical section and m_hRegisterEndSemaphore is signaled when the Register
    // call completes
    // NOTE the names must be NULL, otherwise they will conflict when multiple pump threads
    // are created


    TCHAR *ptszSemaphoreName = NULL;

#if DBG


    //
    // in debug build, use named semaphores.
    //

    TCHAR tszSemaphoreNameString[MAX_PATH];

    _stprintf(tszSemaphoreNameString, _T("RegisterBeginSemaphore_pid[0x%lx]_MediaPump[%p]_"), GetCurrentProcessId(), this);

    LOG((MSP_TRACE, "CMediaPump::CMediaPump - creating semaphore[%S]", tszSemaphoreNameString));

    ptszSemaphoreName = &tszSemaphoreNameString[0];

#endif


    //
    // create the beginning semaphore
    //

    m_hRegisterBeginSemaphore = CreateSemaphore(NULL, 0, LONG_MAX, ptszSemaphoreName);

    if ( NULL == m_hRegisterBeginSemaphore ) goto cleanup;


#if DBG

    //
    // construct a name for registration end semaphore
    //

    _stprintf(tszSemaphoreNameString,
        _T("RegisterEndSemaphore_pid[0x%lx]_MediaPump[%p]"),
        GetCurrentProcessId(), this);

    LOG((MSP_TRACE, "CMediaPump::CMediaPump - creating semaphore[%S]", tszSemaphoreNameString));

    ptszSemaphoreName = &tszSemaphoreNameString[0];

#endif


    //
    // create the end semaphore
    //

    m_hRegisterEndSemaphore = CreateSemaphore(NULL, 0, LONG_MAX, ptszSemaphoreName);

    if ( NULL == m_hRegisterEndSemaphore )  goto cleanup;

    // insert the register event and the filter info to the arrays
    // NOTE: we have to close and null the event in case of failure
    // so that we can just check the register event handle value in 
    // Register to check if initialization was successful
    hr = m_EventArray.Add(m_hRegisterBeginSemaphore);
    if ( FAILED(hr) ) goto cleanup;

    // add a corresponding NULL filter info entry
    hr = m_FilterInfoArray.Add(NULL);
    if ( FAILED(hr) )
    {
        m_EventArray.Remove(m_EventArray.GetSize()-1);
        goto cleanup;
    }

    LOG((MSP_TRACE, "CMediaPump::CMediaPump - exit"));

    return;

cleanup:

    if ( NULL != m_hRegisterBeginSemaphore )
    {
        CloseHandle(m_hRegisterBeginSemaphore);
        m_hRegisterBeginSemaphore = NULL;
    }

    if ( NULL != m_hRegisterEndSemaphore )
    {
        CloseHandle(m_hRegisterEndSemaphore);
        m_hRegisterEndSemaphore = NULL;
    }
    
    LOG((MSP_TRACE, "CMediaPump::CMediaPump - cleanup exit"));
}


CMediaPump::~CMediaPump(void)
{
    LOG((MSP_TRACE, "CMediaPump::~CMediaPump - enter"));

    if ( NULL != m_hThread )
    {
        // when decommit is called on all the write terminals, the thread
        // will return. this will signal the thread handle
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    if ( NULL != m_hRegisterBeginSemaphore )
    {
        CloseHandle(m_hRegisterBeginSemaphore);
        m_hRegisterBeginSemaphore = NULL;
    }

    if ( NULL != m_hRegisterEndSemaphore )
    {
        CloseHandle(m_hRegisterEndSemaphore);
        m_hRegisterEndSemaphore = NULL;
    }

    LOG((MSP_TRACE, "CMediaPump::~CMediaPump - exit"));
} 

HRESULT 
CMediaPump::CreateThreadPump(void)
{
    LOG((MSP_TRACE, "CMediaPump::CreateThreadPump - enter"));

    // release resources for any previous thread
    if (NULL != m_hThread)
    {
        // when decommit is called on all the write terminals, the thread
        // will return. this will signal the thread handle
        // NOTE: this wait cannot cause a deadlock as we know that the 
        // number of entries in the array had dropped to 0 and only thread
        // that can remove entries is the pump. this means that the pump thread
        // must have detected that and returned
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    // create new thread
    m_hThread = CreateThread(
                    NULL, 0, WriteMediaPumpThreadStart, 
                    (void *)this, 0, NULL
                    );
    if (NULL == m_hThread)
    {
        DWORD WinErrorCode = GetLastError();
        
        LOG((MSP_TRACE, 
            "CMediaPump::CreateThreadPump - failed to create thread. LastError = 0x%lx",
            WinErrorCode));

        return HRESULT_FROM_ERROR_CODE(WinErrorCode);
    }

    LOG((MSP_TRACE, "CMediaPump::CreateThreadPump - finish"));

    return S_OK;
}

// add this filter to its wait array
HRESULT 
CMediaPump::Register(
        IN CMediaTerminalFilter *pFilter,
    IN HANDLE               hWaitEvent
        )
{
    LOG((MSP_TRACE, "CMediaPump::Register - enter"));

    TM_ASSERT(NULL != pFilter);
    TM_ASSERT(NULL != hWaitEvent);
    BAIL_IF_NULL(pFilter, E_INVALIDARG);
    BAIL_IF_NULL(hWaitEvent, E_INVALIDARG);

    // check if the register event
    if ( NULL == m_hRegisterBeginSemaphore ) 
    {
        LOG((MSP_ERROR, 
            "CMediaPump::Register - m_hRegisterBeginSemaphore is NULL"));
        
        return E_FAIL;
    }


    LONG lDebug;

    // signal the register event, the pump thread will come out of the
    // critical section and wait on m_hRegisterEndSemaphore
    if ( !ReleaseSemaphore(m_hRegisterBeginSemaphore, 1, &lDebug) )
    {
        DWORD WinErrorCode = GetLastError();
        
        LOG((MSP_ERROR, 
            "CMediaPump::Register - failed to release m_hRegisterBeginSemaphore. LastError = 0x%lx", 
            WinErrorCode));

        return HRESULT_FROM_ERROR_CODE(WinErrorCode);
    }

    LOG((MSP_TRACE, "CMediaPump::Register - released begin semaphore - old count was %d", lDebug));

    // when this SignalRegisterEnd instance is destroyed, it'll signal 
    // the end of registration and unblock the thread pump 
    //
    // NOTE this releases the semaphore on DESTRUCTION of the class instance

    RELEASE_SEMAPHORE_ON_DEST    SignalRegisterEnd(m_hRegisterEndSemaphore);

    HRESULT hr;
    PUMP_LOCK   LocalLock(&m_CritSec);

    TM_ASSERT(m_EventArray.GetSize() == m_FilterInfoArray.GetSize());

    // its possible that there is a duplicate in the array
    // scenario - decommit signals the wait event but commit-register 
    // calls enter the critical section before the pump

    DWORD Index;
    if ( m_EventArray.Find(hWaitEvent, Index) ) 
    {
        LOG((MSP_TRACE, "CMediaPump::Register - event already registered"));

        return S_OK;
    }

    // check if we have reached the maximum allowed filters
    // if we overflow, we must return a very specific error code here
    // (See CMediaPumpPool)
    if ( m_EventArray.GetSize() >= MAX_FILTERS )    
    {
        LOG((MSP_ERROR, "CMediaPump::Register - reached max number of filters for this[%p] pump", this));

        return TAPI_E_ALLOCATED;
    }


    // create CFilterInfo for holding the call parameters

    CFilterInfo *pFilterInfo = new CFilterInfo(pFilter, hWaitEvent);

    if (NULL == pFilterInfo)
    {
        LOG((MSP_ERROR, "CMediaPump::Register - failed to allocate CFilterInfo"));

        return E_OUTOFMEMORY;
    }


    //
    // addref so the filterinfo structure we place into the array has refcount 
    // of one
    //

    pFilterInfo->AddRef();

    // insert wait event into the array
    hr = m_EventArray.Add(hWaitEvent);
    if ( FAILED(hr) )
    {
        pFilterInfo->Release();

        LOG((MSP_ERROR, "CMediaPump::Register - m_EventArray.Add failed hr = %lx", hr));

        return hr;
    }

    // add a corresponding filter info entry
    hr = m_FilterInfoArray.Add(pFilterInfo);
    if ( FAILED(hr) )
    {
        m_EventArray.Remove(m_EventArray.GetSize()-1);
        pFilterInfo->Release();

        LOG((MSP_ERROR, "CMediaPump::Register - m_FilterInfoArray.Add failed hr = %lx", hr));
        return hr;
    }

    // if this is the first entry into the array (beside the 
    // m_hRegisterBeginSemaphore, we need to create a thread pump
    if (m_EventArray.GetSize() == 2)
    {
        hr = CreateThreadPump();
        if ( FAILED(hr) )
        {
            RemoveFilter(m_EventArray.GetSize()-1);

            LOG((MSP_ERROR, "CMediaPump::Register - CreateThreadPump failed hr = %lx", hr));

            return hr;
        }
    }

    // ignore error code. if we have been decommitted in between, it will
    // signal us through the wait event
    pFilter->SignalRegisteredAtPump();

    TM_ASSERT(m_EventArray.GetSize() == m_FilterInfoArray.GetSize());


    LOG((MSP_TRACE, "CMediaPump::Register - exit"));

    return S_OK;
}


// remove this filter from wait array

HRESULT 
CMediaPump::UnRegister(
    IN HANDLE               hWaitEvent
    )
{

    LOG((MSP_TRACE, "CMediaPump::Unregister[%p] - enter. Event[%p]", 
        this, hWaitEvent));

    //
    // if we did not get a valid event handle, debug
    //

    TM_ASSERT(NULL != hWaitEvent);

    BAIL_IF_NULL(hWaitEvent, E_INVALIDARG);


    //
    // if we don't have register event, the pump is not properly initialized
    //

    if ( NULL == m_hRegisterBeginSemaphore ) 
    {

        LOG((MSP_ERROR, 
            "CMediaPump::Unregister[%p] - m_hRegisterBeginSemaphore is nUll. "
            "pump is not initialized. returning E_FAIL - hWaitEvent=[%p]",
            this, hWaitEvent));

        return E_FAIL;
    }


    LONG lDebugSemaphoreCount = 0;

    // signal the register event, the pump thread will come out of the
    // critical section and wait on m_hRegisterEndSemaphore
    if ( !ReleaseSemaphore(m_hRegisterBeginSemaphore, 1, &lDebugSemaphoreCount) )
    {

        DWORD WinErrorCode = GetLastError();

        LOG((MSP_ERROR, 
            "CMediaPump::Unregister - ReleaseSemaphore failed with LastError 0x%lx",
            WinErrorCode));

        return HRESULT_FROM_ERROR_CODE(WinErrorCode);
    }

    LOG((MSP_TRACE, "CMediaPump::UnRegister - released begin semaphore - old count was %d", lDebugSemaphoreCount));


    // when this SignalRegisterEnd instance is destroyed, it'll signal 
    // the end of registration and unblock the thread pump 
    //
    // NOTE this releases the semaphore on DESTRUCTION of the class instance

    RELEASE_SEMAPHORE_ON_DEST    SignalRegisterEnd(m_hRegisterEndSemaphore);


    
    PUMP_LOCK   LocalLock(&m_CritSec);

    TM_ASSERT(m_EventArray.GetSize() == m_FilterInfoArray.GetSize());


    //
    // has this event been registered before
    //

    DWORD Index;

    if ( !m_EventArray.Find(hWaitEvent, Index) ) 
    {

        LOG((MSP_TRACE, 
            "CMediaPump::UnRegister - event is not ours. returning E_FAIL. not an error."));


        return E_FAIL;
    }


    //
    // found the filter that matches the event. remove the filter.
    //
    
    RemoveFilter(Index);

    TM_ASSERT(m_EventArray.GetSize() == m_FilterInfoArray.GetSize());


    LOG((MSP_TRACE, "CMediaPump::Unregister - finish."));


    return S_OK;    
}


void 
CMediaPump::RemoveFilter(
    IN DWORD Index
    )
{

    PUMP_LOCK   LocalLock(&m_CritSec);


    //
    // event array and filterinfo arrays must always be consistent
    //

    TM_ASSERT(m_EventArray.GetSize() == m_FilterInfoArray.GetSize());


    //
    // find the filter that needs to be removed -- it must exist
    //

    CFilterInfo *pFilterInfo = m_FilterInfoArray.Get(Index);

    if (NULL == pFilterInfo)
    {

        LOG((MSP_ERROR, 
            "CMediaPump::RemoveFilter - filter %ld not found in filter array",
            Index));

        TM_ASSERT(FALSE);

        return;
    }


    //
    // remove event and filter from the corresponding arrays
    //

    m_EventArray.Remove(Index);
    m_FilterInfoArray.Remove(Index);

   
    //
    // remove filter from timer q and destroy it
    //

    LOG((MSP_TRACE, 
        "CMediaPump::RemoveFilter - removing filter[%ld] filterinfo[%p] from timerq",
        Index,
        pFilterInfo
        ));

    m_TimerQueue.Remove(pFilterInfo);
    
    pFilterInfo->Release();

    
    TM_ASSERT(m_EventArray.GetSize() == m_FilterInfoArray.GetSize());
}

void 
CMediaPump::RemoveFilter(
    IN CFilterInfo *pFilterInfo
    )
{
    
    //
    // find and remove should be atomic and need to be done in a lock
    //

    PUMP_LOCK   LocalLock(&m_CritSec);


    //
    // find the array index 
    //

    DWORD Index = 0;
    
    if ( !m_FilterInfoArray.Find(pFilterInfo, Index) )
    {
        LOG((MSP_ERROR,
            "CMediaPump::RemoveFilter - filter[%p] is not in the filterinfo array",
            pFilterInfo));

        return;
    }


    //
    // index found, remove the filter
    //
    
    RemoveFilter(Index);
}

 
void 
CMediaPump::ServiceFilter(
        IN CFilterInfo *pFilterInfo                                                
    )
{
    if (NULL == pFilterInfo)
    {

        LOG((MSP_ERROR, 
            "CMediaPump::ServiceFilter - pFilterInfo is NULL"));

        TM_ASSERT(FALSE);

        return;
    }

    if (NULL == pFilterInfo->m_pFilter)
    {

        LOG((MSP_ERROR, 
            "CMediaPump::ServiceFilter - pFilterInfo->m_pFilter is NULL"));

        TM_ASSERT(FALSE);

        return;
    }

    DWORD dwTimeBeforeGetFilledBuffer = timeGetTime();

    IMediaSample *pMediaSample;
    DWORD NextTimeout;
    CMediaTerminalFilter *pFilter = pFilterInfo->m_pFilter;
    HRESULT hr = pFilter->GetFilledBuffer(
                    pMediaSample, NextTimeout
                    );

    if ( SUCCEEDED(hr) ) 
    {
        // if S_FALSE, nothing needs to be done
        // its returned when we were signaled but there is no sample in 
        // the filter pool now. 
        // just continue to wait on event, no timeout needs to be scheduled
        if ( S_FALSE == hr )
        {
            return;
        }

        // if GetFilledBuffer could not get an output buffer from the sample
        // queue, then there is no sample to deliver just yet, but we do
        // need to schedule the next timeout.

        if ( VFW_S_NO_MORE_ITEMS != hr )
        {
            LOG((MSP_TRACE, "CMediaPump::ServiceFilter - calling Receive on downstream filter"));


            //
            // ask filter to process this sample. if everything goes ok, the 
            // filter will pass the sample to a downstream connected pin
            //

            HRESULT hrReceived = pFilter->ProcessSample(pMediaSample);

            LOG((MSP_TRACE, "CMediaPump::ServiceFilter - returned from Receive on downstream filter"));

            if ( pFilter->m_bUsingMyAllocator )
            {
                CSample *pSample = ((CMediaSampleTM *)pMediaSample)->m_pSample;
            
                pSample->m_bReceived = true;
            
                if (hrReceived != S_OK) 
                {
                    LOG((MSP_TRACE, 
                        "CMediaPump::ServiceFilter - downstream filter's ProcessSample returned 0x%08x. "
                        "Aborting I/O operation",
                        hrReceived));

                    pSample->m_MediaSampleIoStatus = E_ABORT;
                }
            }

            pMediaSample->Release();

            //
            // Account for how long it took to get the buffer and call Receive
            // on the sample.
            //

            DWORD dwTimeAfterReceive = timeGetTime();

            DWORD dwServiceDuration;
            
            if ( dwTimeAfterReceive >= dwTimeBeforeGetFilledBuffer )
            {
                dwServiceDuration = 
                    dwTimeAfterReceive - dwTimeBeforeGetFilledBuffer;
            }
            else
            {
                dwServiceDuration = ( (DWORD) -1 )
                    - dwTimeBeforeGetFilledBuffer + dwTimeAfterReceive;
            }

            //
            // Give it an extra 1 ms, just so we err on the side of caution.
            // This won't cause us to fill up the buffers anytime soon.
            //

            dwServiceDuration++;

            //
            // Adjust the timeout.
            //

            if ( dwServiceDuration >= NextTimeout )
            {
                NextTimeout = 0;
            }
            else
            {
                NextTimeout -= dwServiceDuration;
            }

            LOG((MSP_TRACE, "CMediaPump::ServiceFilter - "
                "timeout adjusted by %d ms; resulting timeout is %d ms",
                dwServiceDuration, NextTimeout));
        }

        // if there is a valid timeout, schedule next timeout.
        // otherwise, we'll get only signaled if a new sample is added or
        // the filter is decommitted
        //
        // need to do this in a lock
        //
        
        PUMP_LOCK   LocalLock(&m_CritSec);


        //
        // if the filter has not yet been unregistered, schedule next timeout
        //

        DWORD Index = 0;

        if ( m_FilterInfoArray.Find(pFilterInfo, Index) )
        {

            //
            // filter is still registered, schedule next timeout
            //

            pFilterInfo->ScheduleNextTimeout(m_TimerQueue, NextTimeout);
        }
        else
        {


            //
            // filter was unregistered while we held critical section. this is
            // ok, but we should no longer schedule the filter, since it will 
            // be deleted when this call returns and the filter is released.
            //

            LOG((MSP_TRACE,
                "CMediaPump::ServiceFilter - filter[%p] is not in the filterinfo array",
                pFilterInfo));
        }

    }
    else
    {
        TM_ASSERT(FAILED(hr));
        RemoveFilter(pFilterInfo);
    }
      
    return;
}

void 
CMediaPump::DestroyFilterInfoArray(
    )
{
    for(DWORD i=1; i < m_FilterInfoArray.GetSize(); i++)
    {
        CFilterInfo *pFilterInfo = m_FilterInfoArray.Get(i);
        TM_ASSERT(NULL != pFilterInfo);
        delete pFilterInfo;
        m_FilterInfoArray.Remove(i);
    }
}

// waits for filter events to be activated. also waits
// for registration calls and timer events
HRESULT 
CMediaPump::PumpMainLoop(
    )
{
    HRESULT hr;

    // wait in a loop for the filter events to be set or for the timer
    // events to be fired
    DWORD TimeToWait = INFINITE;
    DWORD ErrorCode;
    BOOL  InRegisterCall = FALSE;
    
    SetThreadPriority(
        GetCurrentThread(), 
        THREAD_PRIORITY_TIME_CRITICAL
        );
    do
    {

        // if a register call is in progress, wait for the call to signal
        // us before proceeding to acquire the critical section
        if ( InRegisterCall )
        {
            LOG((MSP_TRACE, "CMediaPump::PumpMainLoop - waiting for end semaphore"));
            
            InRegisterCall = FALSE;
            DWORD EndErrorCode = WaitForSingleObject(
                                    m_hRegisterEndSemaphore, 
                                    INFINITE
                                    );
            if ( WAIT_OBJECT_0 != EndErrorCode )    
            {
                LOG((MSP_ERROR, 
                    "CMediaPump::PumpMainLoop - failed waiting for m_hRegisterEndSemaphore"));

                return E_UNEXPECTED;
            }


            //
            // lock before accessing array
            //

            m_CritSec.Lock();

            
            //
            // see if the last filter was unregistered... if so, exit the thread.
            //

            if ( (1 == m_EventArray.GetSize()) )
            {

                m_CritSec.Unlock();

                LOG((MSP_TRACE,
                    "CMediaPump::PumpMainLoop - a filter was unregistered. "
                    "no more filters. exiting thread"));

                return S_OK;
            }


            //
            // if did not exit, keeping the lock
            //


            LOG((MSP_TRACE, "CMediaPump::PumpMainLoop - finished waiting for end semaphore"));

        }
        else
        {

            //
            // grab pump lock before starting to wait for events
            //

            m_CritSec.Lock();
        }


        //
        // we should have a lock at this point
        //

        
        TM_ASSERT(m_EventArray.GetSize() > 0);
        TM_ASSERT(m_EventArray.GetSize() == \
                 m_FilterInfoArray.GetSize());


        //
        // calculate time until the thread should wake up
        //

        TimeToWait = m_TimerQueue.GetTimeToTimeout();

        LOG((MSP_TRACE, 
            "CMediaPump::PumpMainLoop - starting waiting for array. timeout %lu",
            TimeToWait));


        //
        // wait to be signaled or until a timeout
        //

        ErrorCode = WaitForMultipleObjects(
                        m_EventArray.GetSize(),
                        m_EventArray.GetData(),
                        FALSE,  // don't wait for all
                        TimeToWait
                        );

        C_ASSERT(WAIT_OBJECT_0 == 0);

        if (WAIT_TIMEOUT == ErrorCode)
        {
            
            //
            // filter timeout
            //

            TM_ASSERT(INFINITE != TimeToWait);
                        TM_ASSERT(!m_TimerQueue.IsEmpty());

            LOG((MSP_TRACE, "CMediaPump::PumpMainLoop - timeout"));

            CFilterInfo *pFilterInfo = m_TimerQueue.RemoveFirst();


            if (NULL == pFilterInfo)
            {
                LOG((MSP_ERROR, 
                    "CMediaPump::PumpMainLoop - m_TimerQueue.RemoveFirst returned NULL"));

                TM_ASSERT(FALSE);
            }
            else
            {

                pFilterInfo->AddRef();

            
                //
                // release the lock while in ServiceFilter to avoid deadlock with 
                // CMediaPump__UnRegister
                //
            
                m_CritSec.Unlock();

                ServiceFilter(pFilterInfo);

                pFilterInfo->Release();

                m_CritSec.Lock();
            }


        }
        else if ( ErrorCode < (WAIT_OBJECT_0 + m_EventArray.GetSize()) )
        {
            LOG((MSP_TRACE, "CMediaPump::PumpMainLoop - signaled"));

            DWORD nFilterInfoIndex = ErrorCode - WAIT_OBJECT_0;

            if (0 == nFilterInfoIndex)
            {
                
                //
                // m_hRegisterBeginSemaphore was signaled
                //

                InRegisterCall = TRUE;
            }
            else
            {
                //
                // one of the filters was signaled
                //

                CFilterInfo *pFilterInfo = m_FilterInfoArray.Get(nFilterInfoIndex);

                if (NULL == pFilterInfo)
                {
                    LOG((MSP_ERROR, 
                        "CMediaPump::PumpMainLoop - pFilterInfo at index %ld is NULL",
                        nFilterInfoIndex));

                    TM_ASSERT(FALSE);
                }
                else
                {

                    pFilterInfo->AddRef();

                
                    //
                    // unlock while in ServiceFilter. we don't want to service
                    // filter in a lock to avoid deadlocks.
                    //

                    m_CritSec.Unlock();

                    ServiceFilter(pFilterInfo);

                    pFilterInfo->Release();

                    m_CritSec.Lock();
                }

            }
        }
        else if ( (WAIT_ABANDONED_0 <= ErrorCode)                          &&
                  (ErrorCode < (WAIT_ABANDONED_0 + m_EventArray.GetSize()) ) )
        {
            
            DWORD nFilterIndex = ErrorCode - WAIT_OBJECT_0;

            LOG((MSP_TRACE, 
                "CMediaPump::PumpMainLoop - event 0x%lx abandoned. removing filter", 
                nFilterIndex));

            // remove item from the arrays
            RemoveFilter(nFilterIndex);
        }
        else
        {

            //
            // something bad happened
            //

            DestroyFilterInfoArray();

            m_CritSec.Unlock();

            DWORD WinErrorCode = GetLastError();
            
            LOG((MSP_ERROR, 
                "CMediaPump::PumpMainLoop - error %ld... exiting", 
                WinErrorCode));

            return HRESULT_FROM_ERROR_CODE(WinErrorCode);

        }


        //
        // this check is performed here so that we detect the empty
        // array and return, thus signaling the thread handle
        //
        // the case when InRegisterCall is on is not handled here -- we will
        // check for the number of filters left after we have waited for the 
        // end event
        //

        if ( (1 == m_EventArray.GetSize()) && !InRegisterCall)
        {
            LOG((MSP_TRACE, 
                "CMediaPump::PumpMainLoop - no more filters in the array. exiting thread"));

            m_CritSec.Unlock();

            return S_OK;
        }


        m_CritSec.Unlock();

    }
    while(1);
}

int CMediaPump::CountFilters()
{
    LOG((MSP_TRACE, "CMediaPump::CountFilters[%p] - enter", this));


    //
    // one of the events is the registration event -- we need to account for 
    // it -- hence the -1
    //

    //
    // note: it is ok to do this without locking media pump.
    //
    // the getsize operation is purely get, and it is ok if the value is
    // sometimes misread -- this would lead to the new filter being distributed
    // not in the most optimal fashion on extremely rare occasions. this slight
    // abnormality in distribution will be corrected later as new filters are
    // coming in.
    //
    // on the other hand, locking media pump to get filter count will lead to
    // "deadlocks" (when main pump loop is sleeping, and nothing happens to
    // wake it up), and it is not trivial to get around this deadlock condition
    // without affecting performance. not locking the pump is a simple and very
    // inexpensive way to accomplish the objective, with an acceptable 
    // trade-off.
    //

    int nFilters = m_EventArray.GetSize() - 1;

    LOG((MSP_TRACE, "CMediaPump::CountFilters - exit. [%d] filters", nFilters));

    return nFilters;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// ZoltanS: non-optimal, but relatively painless way to get around scalability
// limitation of 63 filters per pump thread. This class presents the same
// external interface as the single thread pump, but creates as many pump
// threads as are needed to serve the filters that are in use.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CMediaPumpPool::CMediaPumpPool()
{

    LOG((MSP_TRACE, "CMediaPumpPool::CMediaPumpPool - enter"));


    //
    // setting the default value. registry setting, if present, overwrites this
    // 

    m_dwMaxNumberOfFilterPerPump = DEFAULT_MAX_FILTER_PER_PUMP;


    LOG((MSP_TRACE, "CMediaPumpPool::CMediaPumpPool - exit"));

}

//////////////////////////////////////////////////////////////////////////////
//
// Destructor: This destroys the individual pumps.
//

CMediaPumpPool::~CMediaPumpPool(void)
{
    LOG((MSP_TRACE, "CMediaPumpPool::~CMediaPumpPool - enter"));

    CLock lock(m_CritSection);

    //
    // Shut down and delete each CMediaPump; the array itself is
    // cleaned up in its destructor.
    //

    int iSize = m_aPumps.GetSize();

    for (int i = 0; i < iSize; i++ )
    {
        delete m_aPumps[i];
    }

    LOG((MSP_TRACE, "CMediaPumpPool::~CMediaPumpPool - exit"));
}


//////////////////////////////////////////////////////////////////////////////
//
// CMediaPumpPool::CreatePumps
//
// this function creates the media pumps, the number of which is passed as an
// argument
//

HRESULT CMediaPumpPool::CreatePumps(int nPumpsToCreate)
{
    LOG((MSP_TRACE, "CMediaPumpPool::CreatePumps - enter. nPumpsToCreate = [%d]", nPumpsToCreate));


    for (int i = 0; i < nPumpsToCreate; i++)
    {
        
        //
        // attempt to create a media pump
        //

        CMediaPump * pNewPump = new CMediaPump;

        if ( pNewPump == NULL )
        {
            LOG((MSP_ERROR, "CMediaPumpPool::CreatePumps - "
                            "cannot create new media pump - "
                            "exit E_OUTOFMEMORY"));

            //
            // delete all the pumps we have created in this call
            //

            for (int j = i - 1; j >= 0; j--)
            {
                delete m_aPumps[j];
                m_aPumps.RemoveAt(j);
            }

            return E_OUTOFMEMORY;
        }


        //
        // attempt to add the new media pump to the array of media pumps.
        //

        if ( ! m_aPumps.Add(pNewPump) )
        {
            LOG((MSP_ERROR, "CMediaPumpPool::CreatePumps - cannot add new media pump to array - exit E_OUTOFMEMORY"));

            //
            // delete all the pumps we have created in this call
            //

            delete pNewPump;

            for (int j = i - 1; j >= 0; j--)
            {

                delete m_aPumps[j];
                m_aPumps.RemoveAt(j);
            }

            return E_OUTOFMEMORY;
        }
    }


    LOG((MSP_TRACE, "CMediaPumpPool::CreatePumps - finished."));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
//  CMediaPumpPool::ReadRegistryValuesIfNeeded
//  
//  this function reads the registry setting for max number of filters per pump
//  and in case of success, keeps the new value.
//
//  this function is not thread safe. the caller must guarantee thread safety
//

HRESULT CMediaPumpPool::ReadRegistryValuesIfNeeded()
{
    
    //
    // we don't want to access registry more than once. so we have this static 
    // flag that helps us limit registry access
    //

    static bRegistryChecked = FALSE;


    if (TRUE == bRegistryChecked)
    {

        //
        // checked registry before. no need to do (or log) anything here
        //

        return S_OK;
    }


    //
    // we don't want to log until we know we will try to read registry
    //

    LOG((MSP_TRACE, "CMediaPumpPool::ReadRegistryValuesIfNeeded - enter"));


    //
    // whether we will succeed or fail, do not check the registry again
    //

    bRegistryChecked = TRUE;


    //
    // Open the registry key
    //

    HKEY hKey = 0;
    
    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                MST_REGISTRY_PATH,
                                0,
                                KEY_READ,
                                &hKey);


    //
    // did we manage to open the key?
    //

    if( ERROR_SUCCESS != lResult )
    {
        LOG((MSP_WARN, "CPTUtil::ReadRegistryValuesIfNeeded - "
            "RegOpenKeyEx failed, returns E_FAIL"));

        return E_FAIL;
    }

    
    //
    // read the value 
    //

    DWORD dwMaxFiltersPerPump = 0;

    DWORD dwDataSize = sizeof(DWORD);

    lResult = RegQueryValueEx(
                        hKey,
                        MAX_FILTERS_PER_PUMP_KEY,
                        NULL,
                        NULL,
                        (LPBYTE) &dwMaxFiltersPerPump,
                        &dwDataSize
                       );

    
    //
    // don't need the key anymore
    //

    RegCloseKey(hKey);
    hKey = NULL;


    //
    // any luck reading the value?
    //

    if( ERROR_SUCCESS != lResult )
    {
        LOG((MSP_WARN, "CPTUtil::ReadRegistryValuesIfNeeded - RegQueryValueEx failed, return E_FAIL"));

        return E_FAIL;
    }


    //
    // got the value, keeping it.
    //

    m_dwMaxNumberOfFilterPerPump = dwMaxFiltersPerPump;

    
    LOG((MSP_TRACE, 
        "CMediaPumpPool::ReadRegistryValuesIfNeeded - exit. MaxNumberOfFilterPerPump = %lx",
        m_dwMaxNumberOfFilterPerPump));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CMediaPumpPool::GetOptimalNumberOfPumps
//
// this function returns the number of pumps required to process all the 
// filters that are currently being handled, plus the filter that is about to 
// be registered
// 

HRESULT CMediaPumpPool::GetOptimalNumberOfPumps(int *pnPumpsNeeded)
{

    LOG((MSP_TRACE, "CMediaPumpPool::GetOptimalNumberOfPumps - enter"));

    
    //
    // if the argument is bad, it's a bug
    //

    if (IsBadWritePtr(pnPumpsNeeded, sizeof(int)))
    {
        LOG((MSP_ERROR, 
            "CMediaPumpPool::GetOptimalNumberOfPumps - pnPumpsNeeded[%p] is bad", 
            pnPumpsNeeded));

        TM_ASSERT(FALSE);

        return E_POINTER;
    }


    //
    // calculate the total number of service filters
    //

    int nTotalExistingPumps = m_aPumps.GetSize();

    
    //
    // start with one filter (to adjust for the filter we are adding)
    //

    int nTotalFilters = 1;

    for (int i = 0; i < nTotalExistingPumps; i++)
    {

        //
        // note that the number of filters we get could be slightly higher then
        // the real number, since the filters can be removed without involving
        // pump pool (and thus getting its critical section). this is ok -- 
        // the worst that will happen is that we will sometimes have more pumps
        // then we really need.
        //

        nTotalFilters += m_aPumps[i]->CountFilters();
    }


    //
    // calculated how many filters are being serviced
    //


    //
    // what is the max number of filters a pump can service
    //

    DWORD dwMaxNumberOfFilterPerPump = GetMaxNumberOfFiltersPerPump();


    //
    // find the number of pumps needed to service all our filters
    //

    *pnPumpsNeeded = nTotalFilters / dwMaxNumberOfFilterPerPump;


    //
    // if the number of filters is not evenly divisible by the max number of
    // filters serviced by a pump, we need to round up.
    //

    if ( 0 != (nTotalFilters % dwMaxNumberOfFilterPerPump) )
    {
        
        //
        // uneven divide, roundup adjustment is necessary
        //

        *pnPumpsNeeded += 1;
    }


    //
    // we have calculated the number of pumps needed to process all our filters
    //

    LOG((MSP_TRACE, 
        "CMediaPumpPool::GetOptimalNumberOfPumps - exit. [%d] filters should be serviced by [%d] pump(s)",
        nTotalFilters, *pnPumpsNeeded));

    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CMediaPumpPool::PickThePumpToUse
//
// this method chooses the pump that should be used to service the new filter
// the pump is picked based on the load and the number of pumps needed to 
// service all pf the current filters
//


HRESULT CMediaPumpPool::PickThePumpToUse(int *pPumpToUse)
{

    LOG((MSP_TRACE, "CMediaPumpPool::PickThePumpToUse - enter"));
    
    
    //
    // if the argument is bad, it's a bug
    //

    if (IsBadWritePtr(pPumpToUse, sizeof(int)))
    {
        LOG((MSP_ERROR, "CMediaPumpPool::PickThePumpToUse - pPumpToUse[%p] is bad", pPumpToUse));

        TM_ASSERT(FALSE);

        return E_POINTER;
    }


    //
    // calculate the optimal number of pumps needed for the current number of filters
    //

    int nPumpsNeeded = 0;

    HRESULT hr = GetOptimalNumberOfPumps(&nPumpsNeeded);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CMediaPumpPool::PickThePumpToUse - GetOptimalNumberOfPumps failed hr = [%lx]", 
            hr));

        return hr;
    }

    
    //
    // if we don't have enough pumps, create more
    //
    
    int nTotalExistingPumps = m_aPumps.GetSize();

    if (nTotalExistingPumps < nPumpsNeeded)
    {
        
        //
        // this is how many more pumps we need to create
        //

        int nNewPumpsToCreate = nPumpsNeeded - nTotalExistingPumps;

        
        //
        // we will never need to create more than one new pump at a time
        //
        
        TM_ASSERT(1 == nNewPumpsToCreate);


        //
        // special case if we currently don't have any pumps -- create one pump
        // for each processor. this will help us scale on symmetric 
        // multiprocessor machines.
        //

        if (0 == nTotalExistingPumps)
        {

            //
            // get the number of processors. according to documentation, 
            // GetSystemInfo cannot fail, so there is return code to check
            //

            SYSTEM_INFO SystemInfo;

            GetSystemInfo(&SystemInfo);


            //
            // we will want to create at least as many new pumps as we have 
            // processors, but maybe more if needed
            //
            //
            // note: we may also want to look at the affinity mask, it may 
            // tell us how many CPUs are actually used
            //

            int nNumberOfProcessors = SystemInfo.dwNumberOfProcessors;

            if (nNewPumpsToCreate < nNumberOfProcessors)
            {

                nNewPumpsToCreate = SystemInfo.dwNumberOfProcessors;
            }

        }

        
        //
        // we now have all the information needed to create the pumps we need.
        //

        hr = CreatePumps(nNewPumpsToCreate);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR,
                "CMediaPumpPool::PickThePumpToUse - CreatePumps failed hr = [%lx]", 
                hr));

            return hr;

        }

        
        LOG((MSP_TRACE, "CMediaPumpPool::PickThePumpToUse - create [%d] pumps", nNewPumpsToCreate));
    }


    //
    // walk trough the pumps (only use pumps starting from the first N pumps, 
    // N being the number of pumps needed to service the number of filters that
    // we are servicing
    // 
    
    
    nTotalExistingPumps = m_aPumps.GetSize();

    
    int nLowestLoad = INT_MAX;
    int nLowestLoadPumpIndex = -1;


    for (int nPumpIndex = 0; nPumpIndex < nTotalExistingPumps; nPumpIndex++)
    {
    
        int nNumberOfFiltersAtPump = 0;
        
        
        //
        // how many filters is this pump serving?
        //

        nNumberOfFiltersAtPump = m_aPumps[nPumpIndex]->CountFilters();

        
        //
        // if the pump we are looking at has less load then any of the 
        // previously evaluated pumps, remember it. if we don't find anything
        // better, this is what we will use.
        //

        if (nNumberOfFiltersAtPump < nLowestLoad)
        {

            nLowestLoadPumpIndex = nPumpIndex;
            nLowestLoad = nNumberOfFiltersAtPump;
        }
    }

    
    //
    // we had to get something!
    //

    if (-1 == nLowestLoadPumpIndex)
    {
        LOG((MSP_ERROR,
            "CMediaPumpPool::PickThePumpToUse - did not find a pump to use"));


        //
        // we have a bug -- need to investigate
        //

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // we found a pump to use
    //

    *pPumpToUse = nLowestLoadPumpIndex;


    LOG((MSP_TRACE, 
        "CMediaPumpPool::PickThePumpToUse - finish. using pump %d, current load %d",
        *pPumpToUse, nLowestLoad));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// Register: This delegates to the individual pumps, creating new ones as
// needed.
//

HRESULT CMediaPumpPool::Register(
    IN CMediaTerminalFilter *pFilter,
    IN HANDLE               hWaitEvent
    )
{
    LOG((MSP_TRACE, "CMediaPumpPool::Register - enter"));


    CLock   lock(m_CritSection);


    //
    // find the pump with which to register filter
    //

    int nPumpToUse = 0;

    HRESULT hr = PickThePumpToUse(&nPumpToUse);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CMediaPumpPool::Register - failed to find the pump to be used to service the new filter, hr = [%lx]", 
            hr));

        return hr;
    }


    //
    // just to be on the safe side, make sure the index we got makes sense
    //

    int nTotalPumps = m_aPumps.GetSize();

    if (nTotalPumps - 1 < nPumpToUse)
    {
        LOG((MSP_ERROR, 
            "CMediaPumpPool::Register - PickThePumpToUse return bad pump index [%d]",
            nPumpToUse));

        TM_ASSERT(FALSE);

        return E_UNEXPECTED;
    }


    //
    // ok, all is well, register with the pump
    //

    hr = m_aPumps[nPumpToUse]->Register(pFilter, hWaitEvent);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CMediaPumpPool::Register - failed to register with pump [%d] at [%p]", 
            nPumpToUse, m_aPumps[nPumpToUse]));

        return hr;
    }


    LOG((MSP_TRACE, "CMediaPumpPool::Register - finished"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// UnRegister: Unregister filter. This delegates to the individual pumps
//

HRESULT CMediaPumpPool::UnRegister(
    IN HANDLE               hWaitEvent
    )
{
    
    LOG((MSP_TRACE, "CMediaPumpPool::UnRegister - enter"));


    HRESULT hr = E_FAIL;


    //
    // All of this is done within a single critical section, to
    // synchronize access to our array
    //

    CLock   lock(m_CritSection);


    //
    // try to unregister from a pump thread in the array
    //

    int iSize = m_aPumps.GetSize();

    for (int i = 0; i < iSize; i++ )
    {

        //
        // Try to unregister from this pump thread.
        //

        hr = m_aPumps[i]->UnRegister(hWaitEvent);


        //
        // If succeeded unregistering from this pump, then we are done.
        // Otherwise just try the next one.
        //

        if ( hr == S_OK )
        {
            LOG((MSP_TRACE, 
                "CMediaPumpPool::UnRegister - unregistered with media pump %d",
                 i));

            break;
        }
    }


    LOG((MSP_TRACE, 
        "CMediaPumpPool::UnRegister - exit. hr = 0x%08x", hr));

    return hr;
}


//
// eof
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\medpump.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __MEDIA_STREAM_PUMP__
#define __MEDIA_STREAM_PUMP__

// atl fns
#include <atlcom.h>

// CTimerQueue
#include "timerq.h"

// we can wait for at most this many filters (per thread -- see CMediaPumpPool)
// this limitation is imposed by WaitForMultipleObjects
const DWORD MAX_FILTERS = MAXIMUM_WAIT_OBJECTS;


// expandable array of scalar/pointer values
template <class T>
class CMyArray
{
public:

    CMyArray(
        IN DWORD BlockSize = 4
        )
        : m_pData(NULL),
          m_AllocElements(0),
          m_NumElements(0),
          m_BlockSize(BlockSize)
    {}

    virtual ~CMyArray()
    {
        if (NULL != m_pData) delete m_pData;
    }

    inline T *GetData()
    {
        return m_pData;
    }

    inline DWORD GetSize()
    {
        return m_NumElements;
    }

    HRESULT Add(
        IN T NewVal
        );

    inline T Get(
        IN  DWORD   Index
        );

    inline HRESULT Set(
        IN  DWORD   Index,
        IN  T       Val
        );

    inline BOOL Find(
        IN  T       Val,
        OUT DWORD   &Index
        );
    
    HRESULT Remove(
        IN DWORD Index
        );

    inline HRESULT Remove(
        IN  T   Val
        );

protected:

    T       *m_pData;
    DWORD   m_NumElements;

    DWORD   m_AllocElements;

    DWORD   m_BlockSize;
};


template <class T>
HRESULT 
CMyArray<T>::Add(
    IN T NewVal
    )
{
    // check if new memory needs to be allocated
    if ( m_AllocElements <= m_NumElements )
    {
        T *pData = new T[(m_NumElements+1) + m_BlockSize];
        BAIL_IF_NULL(pData, E_OUTOFMEMORY);

        if (NULL != m_pData)
        {
            CopyMemory(pData, m_pData, m_NumElements * sizeof(T));
            delete [] m_pData;
        }
        m_pData = pData;
        m_AllocElements = (m_NumElements+1) + m_BlockSize;
    }

    m_pData[m_NumElements] = NewVal;
    m_NumElements++;

    return S_OK;
}

template <class T>
T 
CMyArray<T>::Get(
    IN  DWORD   Index
    )
{
    TM_ASSERT(Index < m_NumElements);
    if (Index >= m_NumElements) return NULL;

    return m_pData[Index];
}

template <class T>
HRESULT 
CMyArray<T>::Set(
    IN  DWORD   Index,
    IN  T       Val
    )
{
    TM_ASSERT(Index < m_NumElements);
    if (Index >= m_NumElements) return E_INVALIDARG;

    m_pData[Index] = Val;
    return S_OK;
}

template <class T>
HRESULT 
CMyArray<T>::Remove(
    IN DWORD Index
    )
{
    TM_ASSERT(Index < m_NumElements);
    if (Index >= m_NumElements) return E_INVALIDARG;

    // copy all elements to the right of Index leftwards
    for(DWORD i=Index; i < (m_NumElements-1); i++)
    {
        m_pData[i] = m_pData[i+1];
    }

    // decrement the number of elements
    m_NumElements--;
    return S_OK;
}

template <class T>
inline BOOL 
CMyArray<T>::Find(
    IN  T       Val,
    OUT DWORD   &Index
    )
{
    for(Index = 0; Index < m_NumElements; Index++)
    {
        if (Val == m_pData[Index])  return TRUE;
    }

    return FALSE;
}

template <class T>
inline HRESULT 
CMyArray<T>::Remove(
    IN  T   Val
    )
{
    DWORD Index;
    if ( Find(Val, Index) ) return Remove(Index);

    return E_FAIL;
}

class RELEASE_SEMAPHORE_ON_DEST
{
public:

    inline RELEASE_SEMAPHORE_ON_DEST(
            IN HANDLE hEvent
            )
            : m_hEvent(hEvent)
    {
        TM_ASSERT(NULL != m_hEvent);

        LOG((MSP_TRACE, 
            "RELEASE_SEMAPHORE_ON_DEST::RELEASE_SEMAPHORE_ON_DEST[%p] - event[%p]", this, hEvent));
    }

    inline ~RELEASE_SEMAPHORE_ON_DEST()
    {
        if (NULL != m_hEvent)
        {
            LONG lDebug;

            ReleaseSemaphore(m_hEvent, 1, &lDebug);

            LOG((MSP_TRACE,
                "RELEASE_SEMAPHORE_ON_DEST::~RELEASE_SEMAPHORE_ON_DEST[%p] - released end semaphore[%p] -- old count was %ld",
                this, m_hEvent, lDebug));
        }
    }

protected:

    HANDLE  m_hEvent;
};


class CMediaTerminalFilter;
class CFilterInfo;

// implements single thread pump for the write media streaming terminal 
// filters. it creates a thread if necessary when a write terminal registers
// itself (in commit). the filter signals its wait handle in decommit,
// causing the thread to wake up and remove the filter from its data 
// structures. the thread returns when there are no more filters to service
class CMediaPump
{
public:

    CMediaPump();

    virtual ~CMediaPump();

    // adds this filter to its wait array
	HRESULT Register(
		IN CMediaTerminalFilter *pFilter,
        IN HANDLE               hWaitEvent
		);


    //
    // removes this filter from its wait array and timerq, and restarts sleep 
    // with recalculated time
    //

    HRESULT UnRegister(
        IN HANDLE hWaitEvent  // filter's event, used as filter id
        );


    // waits for filter events to be activated. also waits
    // for registration calls and timer events
    virtual HRESULT PumpMainLoop();

    
    int CountFilters();

protected:

    typedef LOCAL_CRIT_LOCK<CComAutoCriticalSection> PUMP_LOCK;

    // thread pump - this is closed by the thread pump itself,
    // when the 
    HANDLE                      m_hThread;

    // this event is used to signal the thread pump to exit the
    // critical section
    // all calls to Register first signal this event before trying
    // to acquire the critical section
    HANDLE                      m_hRegisterBeginSemaphore;

    // when a register call is in progress (m_hRegisterEvent was signaled)
    // the thread pump exits the critical section and blocks on this semaphore 
    // the registering thread must release this semaphore if it signaled 
    // m_hRegisterBeginSemaphore
    HANDLE                      m_hRegisterEndSemaphore;

    // regulates access to the member variables
    // the pump holds this during its wait and service actions
    // but releases it at the bottom of the loop
    CComAutoCriticalSection     m_CritSec;

    // wait related members
    CMyArray<HANDLE>            m_EventArray;
    CMyArray<CFilterInfo *>     m_FilterInfoArray;
    CTimerQueue                 m_TimerQueue;

    HRESULT CreateThreadPump();

    void RemoveFilter(
        IN DWORD Index
        );

    void RemoveFilter(
        IN CFilterInfo *pFilterInfo
        );

	void ServiceFilter(
		IN CFilterInfo *pFilterInfo						   
		);

    void DestroyFilterInfoArray();

};


//////////////////////////////////////////////////////////////////////////////
//
// ZoltanS: non-optimal, but relatively painless way to get around scalability
// limitation of 63 filters per pump thread. This class presents the same
// external interface as the single thread pump, but creates as many pump
// threads as are needed to serve the filters that are in use.
//

class CMediaPumpPool
{
public:

    CMediaPumpPool();

    
    ~CMediaPumpPool();

    HRESULT Register(
        IN CMediaTerminalFilter *pFilter,
        IN HANDLE               hWaitEvent
        );


    HRESULT UnRegister(
        IN HANDLE               hWaitEvent // filter's event, used as filter id
        );

private:


    //
    // read optional user configuration from registry (only on the first call, 
    // subsequent calls do nothing)
    //

    HRESULT ReadRegistryValuesIfNeeded();


    //
    // create new pumps, nPumpsToCreate is the number of new pumps to create 
    //

    HRESULT CreatePumps(int nPumpsToCreate);


    //
    // calculate the optimal number of pumps needed to service the number of 
    // filters that we have
    //

    HRESULT GetOptimalNumberOfPumps(OUT int *pNumberOfPumps);


    //
    // this method returns the pump to be used to service the new filter
    //

    HRESULT PickThePumpToUse(int *pnPumpToUse);


    //
    // utility function that calculates the number of filters per pump
    //

    inline DWORD GetMaxNumberOfFiltersPerPump()
    {

        //
        // check if the value is configured in the registry
        //

        ReadRegistryValuesIfNeeded();


        //
        // return the value -- it was either read from the registry on the 
        // first call to GetMaxNumberOfFiltersPerPump, or using default
        //

        return m_dwMaxNumberOfFilterPerPump;
    }


private:

    CMSPArray<CMediaPump *> m_aPumps;
    CMSPCritSection         m_CritSection;


    //
    // the value that specifies the max number of filters to be serviced by one
    // pump
    //

    DWORD m_dwMaxNumberOfFilterPerPump;

};


#endif // __MEDIA_STREAM_PUMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\meterf.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

/*
NOTE: regarding AMOVIE code

1. Timing info is messed up (as noted by the owner, robin speed himself)
2. Atleast a few obvious bugs - mostly in the derived classes, but a few in
   the base classes as well. The current approach is to try and cover it up
   by over-riding the method

ZoltanS note: and now that the amovie code is folded into this directory,
    I am trying to collapse the humongous class hierarchy and just replace
    the  original methods with the fixed overrides

*/

#include "stdafx.h"
#include "atlconv.h"
#include "termmgr.h"

#include "medpump.h"
#include "meterf.h"

// for some reason ddstream.lib requires this .. TO DO ** (get rid of it)

#ifdef DBG
BOOL bDbgTraceFunctions;
BOOL bDbgTraceInterfaces;
BOOL bDbgTraceTimes;
#endif // DBG

#ifdef DBG
#include <stdio.h>
#endif // DBG


// static variables

// implements single thread pump for the write media streaming terminal 
// filters. it creates a thread if necessary when a write terminal registers
// itself (in commit). the filter signals its wait handle in decommit,
// causing the thread to wake up and remove the filter from its data 
// structures. the thread returns when there are no more filters to service

// ZoltanS: now a pool of pump threads

CMediaPumpPool   CMediaTerminalFilter::ms_MediaPumpPool;

// checks if the two am media type structs are same
// a simple equality of struct won't do here
BOOL
IsSameAMMediaType(
    IN const AM_MEDIA_TYPE *pmt1,
    IN const AM_MEDIA_TYPE *pmt2
    )
{
    // we don't expect the the two pointers to be null
    TM_ASSERT(NULL != pmt1);
    TM_ASSERT(NULL != pmt2);

    // if the two pointer values are same, there is nothing more
    // to check
    if (pmt1 == pmt2)    return TRUE;

    // each of the members of the AM_MEDIA_TYPE struct must be
    // the same (majortype, subtype, formattype 
    // and (cbFormat, pbFormat))
    if ( (pmt1->majortype    != pmt2->majortype) || 
         (pmt1->subtype        != pmt2->subtype)    ||
         (pmt1->formattype    != pmt2->formattype) )
//         || (pmt1->cbFormat    != pmt2->cbFormat)     )
    {
        return FALSE;
    }

    // if the pbFormat pointer is null for either, they can't be
    // the same
    if ( (NULL == pmt1->pbFormat) || (NULL == pmt2->pbFormat) )
    {
        return FALSE;
    }

    DWORD dwSize = ( pmt1->cbFormat < pmt2->cbFormat ) ? pmt1->cbFormat :
                                                         pmt2->cbFormat;

    // we don't handle anything other than waveformatex or videoinfo,
    // and as these two don't have any member pointers, a bitwise
    // comparison is sufficient to check for equality
    if ( (FORMAT_WaveFormatEx == pmt1->formattype) ||
         (FORMAT_VideoInfo == pmt1->formattype)        )
    {
        return !memcmp(
                    pmt1->pbFormat, 
                    pmt2->pbFormat, 
                    dwSize 
                    );
    }


    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
//
// Equal
//
// this is a helper method that returns TRUE if the properties are identical
//

BOOL Equal(const ALLOCATOR_PROPERTIES *pA, const ALLOCATOR_PROPERTIES *pB)
{

    if ( pA->cBuffers != pB->cBuffers )
    {
        return FALSE;
    }

    if ( pA->cbBuffer != pB->cbBuffer )
    {
        return FALSE;
    }

    if ( pA->cbPrefix != pB->cbPrefix )
    {
        return FALSE;
    }

    if ( pA->cbPrefix != pB->cbPrefix )
    {
        return FALSE;
    }

    if ( pA->cbAlign != pB->cbAlign )
    {
        return FALSE;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Helper function to test if two sets of allocator properties are
// significantly different.
//
  
BOOL AllocatorPropertiesDifferSignificantly(
    const ALLOCATOR_PROPERTIES * pRequested,
    const ALLOCATOR_PROPERTIES * pActual
    )
{
    if ( pActual->cBuffers != pRequested->cBuffers )
    {
        return TRUE;
    }

    if ( pActual->cbBuffer != pRequested->cbBuffer )
    {
        return TRUE;
    }

    //
    // we do not care about alignment - cbAlign
    //

    if ( pActual->cbPrefix != pRequested->cbPrefix )
    {
        return TRUE;
    }

    return FALSE;
}


// free the allocated member variables 
// virtual
CMediaTerminalFilter::~CMediaTerminalFilter(
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::~CMediaTerminalFilter called"));

    // if memory was allocated for the media type, release it
    // it checks for NULL == m_pSuggestedMediaType
    DeleteMediaType(m_pSuggestedMediaType);

    // Moved from base class:
    SetState(State_Stopped);        // Make sure we're decommitted and pump is dead
}


// calls the IAMMediaStream::Initialize(NULL, 0, PurposeId, StreamType),
// sets certain member variables
// ex. m_pAmovieMajorType
HRESULT 
CMediaTerminalFilter::Init(
    IN REFMSPID             PurposeId, 
    IN const STREAM_TYPE    StreamType,
    IN const GUID           &AmovieMajorType
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::Init[%p] (%p, %p, %p) called",
        this, &PurposeId, &StreamType, &AmovieMajorType));

    HRESULT hr;

    // initialize the CStream by calling IAMMediaStream::Initialize
    hr = Initialize(
        NULL, 
        (StreamType == STREAMTYPE_READ) ? AMMSF_STOPIFNOSAMPLES : 0,
        PurposeId, 
        StreamType
        );

    BAIL_ON_FAILURE(hr);

    // set member variables
    m_bIsAudio = (MSPID_PrimaryAudio == PurposeId) ? TRUE : FALSE;
    m_pAmovieMajorType = &AmovieMajorType;

    SetDefaultAllocatorProperties();

    LOG((MSP_TRACE, "CMediaTerminalFilter::Init - succeeded"));
    return S_OK;
}


// CMediaPump calls this to get the next filled buffer to pass downstream
// for audio filters, this method is also responsible for waiting 
// for 20ms and sending the data in one filled buffer
HRESULT
CMediaTerminalFilter::GetFilledBuffer(
    OUT IMediaSample    *&pMediaSample, 
    OUT DWORD           &WaitTime
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::GetFilledBuffer[%p] ([out]pMediaSample=%p, [out]WaitTime=%lx) called",
        this, pMediaSample, WaitTime));

    HRESULT hr = S_OK;

    Lock();

    if ( ! m_bCommitted )
    {
        Unlock();

        return VFW_E_NOT_COMMITTED;
    }

    if ( m_pSampleBeingFragmented == NULL )
    {
        // get a sample
        CSample *pSample = m_pFirstFree;

        // if no sample, someone must have forced termination
        // of the sample(s) which caused signaling of the wait
        // event, or it must have decommitted and committed again
        if (NULL == pSample)
        {
            // we'll wait for someone to add a sample to the pool
            m_lWaiting = 1;
            
            Unlock();

            return S_FALSE;
        }

        m_pFirstFree = pSample->m_pNextFree;
        if (m_pFirstFree)   m_pFirstFree->m_pPrevFree = NULL;
        else                m_pLastFree = NULL;

        pSample->m_pNextFree = NULL;        // Just to be tidy
        TM_ASSERT(pSample->m_Status == MS_S_PENDING);
        CHECKSAMPLELIST

        // all samples in the pool have a refcnt on them, this
        // must be released before m_pSampleBeingFragmented is set to NULL
        m_pSampleBeingFragmented = (CUserMediaSample *)pSample;

        // note the current time only for audio samples
        m_pSampleBeingFragmented->BeginFragment(m_bIsAudio);
    }

    //
    // Implementations diverge here depending on whether we are using the
    // sample queue (CNBQueue; m_bUsingMyAllocator == FALSE) and fragmenting
    // samples by reference, or using a downstream allocator and copying
    // samples.
    //

    BOOL fDone;

    if ( m_bUsingMyAllocator )
    {
        hr = FillMyBuffer(
            pMediaSample, // OUT
            WaitTime,     // OUT
            & fDone       // OUT
            );
    }
    else
    {
        hr = FillDownstreamAllocatorBuffer(
            pMediaSample, // OUT
            WaitTime,     // OUT
            & fDone       // OUT
            );
    }

    //
    // S_OK means everything is ok, and we need to return the wait time,
    // update m_pSampleBeingFragmented, and addref the IMediaSample.
    // other success codes (or failure codes) mean return immediately.
    //
    if ( hr != S_OK )
    {
        Unlock();
        return hr;
    }

    // return the time to wait in milliseconds
    if (m_bIsAudio)
    {
    
        WaitTime = m_pSampleBeingFragmented->GetTimeToWait(m_AudioDelayPerByte);

    }
    else
    {
        WaitTime = m_VideoDelayPerFrame;
    }

    //
    // ZoltanS: make the second sample after we start playing
    // a little early, to account for a bit of jitter in delivery to
    // the waveout filter, and also to "prime" buggy wave drivers
    // such as Dialogic, which need a backlog to operate properly.
    // This is fine for IP as long as the timestamps are set correctly
    // (note that the most advancement we ever do is one packet's worth
    // on the second packet only).
    //
    // This needs to be done before SetTime, because SetTime
    // changes m_rtLastSampleEndedAt.
    //

    const DWORD SECOND_SAMPLE_EARLINESS = 500;

    if ( m_rtLastSampleEndedAt == 0 )
    {
        LOG((MSP_TRACE, "CMediaTerminalFilter::GetFilledBuffer - "
            "this is the first sample; making the next sample %d ms early",
            SECOND_SAMPLE_EARLINESS));

        if ( WaitTime < SECOND_SAMPLE_EARLINESS )
        {
            WaitTime = 0;
        }
        else
        {
            WaitTime -= SECOND_SAMPLE_EARLINESS;
        }
    }


    //
    // if the sample came in late, set discontinuity flag. this flag may be 
    // used by the downstream filters in their dejitter algorithms.
    //
    // this needs to be called before settime (because settime will reset 
    // m_rtLastSampleDuration to duration of the _current_ sample
    //

    hr = SetDiscontinuityIfNeeded(pMediaSample);

    if ( FAILED(hr) )
    {

        //
        // not fatal, log and continue
        //

        LOG((MSP_ERROR,
            "CMediaTerminalFilter::GetFilledBuffer - SetDiscontinuityIfNeeded failed. "
            "hr = 0x%lx", hr));
    }

    
    //
    // put a timestamp on the sample
    //

    hr = SetTime( pMediaSample );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "CMediaTerminalFilter::GetFilledBuffer() "
            "Failed putting timestamp on the sample; hr = 0x%lx", hr));
    }


    // if fDone, we reached the end of the buffer we were fragmenting
    if ( fDone )
    {
        ((IStreamSample *)m_pSampleBeingFragmented)->Release();
        m_pSampleBeingFragmented = NULL;
    }

    Unlock();

    LOG((MSP_TRACE, "CMediaTerminalFilter::GetFilledBuffer(%p, %u) succeeded",
        pMediaSample, WaitTime));
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// FillDownstreamAllocatorBuffer
//
// This is called in GetFilledBuffer when we are using the downstream
// allocator. It gets a sample from our outgoing sample pool and copies the
// data 
//
// Note that GetBuffer can block here, which means we are just as hosed as if
// Receive blocks (but there is no deadlock situation possible as is remedied
// in FillMyBuffer).
//

HRESULT CMediaTerminalFilter::FillDownstreamAllocatorBuffer(
    OUT IMediaSample   *& pMediaSample, 
    OUT DWORD          &  WaitTime,
    OUT BOOL           *  pfDone
    )
{
    //
    // Get a buffer from the downstream allocator.
    //

    TM_ASSERT( ! m_bUsingMyAllocator );

    HRESULT hr;

    hr = m_pAllocator->GetBuffer(
        & pMediaSample,
        NULL,       // no start time (used by video renderer only)
        NULL,       // no no end time (used by video renderer only)
        0           // no flags (could be: not a sync point, prev frame skipped)
        );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // Got a free output buffer, so put some data in it.
    //
    // if audio, fragment the buffer else, pass the whole buffer
    // (no fragmentation for video as video data is frame based)
    //
    // CUserMediaSample::CopyFragment is just like CUserMediaSample::Fragment
    // except that the outgoing sample is an IMediaSample interface instead
    // of our own CQueueMediaSample.
    //

    hr = m_pSampleBeingFragmented->CopyFragment(
        m_bIsAudio,             // allow fragmentation if audio, not if video (IN)
        m_AllocProps.cbBuffer,  // outgoing buffer size (IN)
        pMediaSample,           // outgoing sample (IN)
        *pfDone                 // done with user sample? reference (OUT)
        );
        
    //
    // We've filled out pMediaSample. The caller fills out the wait time if the
    // result of this method is S_OK.
    //

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// FillMyBuffer
//
// This is called in GetFilledBuffer when we are using our own allocator. It
// gets a sample from our outgoing sample pool. If no sample is available
// right now, it sets the wait time and returns a special success code.
// If a sample is available, it sets it up to point to an appropriate chunk
// of the "fragmented" source buffer.
//


HRESULT CMediaTerminalFilter::FillMyBuffer(
    OUT IMediaSample   *& pMediaSample, 
    OUT DWORD          &  WaitTime,
    OUT BOOL           *  pfDone
    )
{
    //
    // Try to dequeue an output sample to send to. FALSE tells it to return NULL
    // rather than blocking if there is nothing on the queue. If there is nothing
    // on the queue, that means that the fact that we are holding the lock is
    // preventing the sample from being returned to the queue. We've only seen
    // this happen when ksproxy is used as the MSP's transport, since ksproxy
    // releases its samples asynchronously (on a separate Io completion thread).
    // With other transports, samples are released asynchronously each time,
    // and so we never get this situation.
    //
    // If the transport is truly messed up and no samples are completing, then
    // there is the additional consideration that we don't want to use up 100%
    // CPU and we want to be able to service other filters (this is on the
    // pump thread, serving up to 63 filters per thread). So rather than
    // retrying immediately we need to set a short dormancy time (for the
    // PumpMainLoop wait) before we try again.
    //
    
    CQueueMediaSample * pQueueSample;

    pQueueSample = m_SampleQueue.DeQueue( FALSE );

    if ( pQueueSample == NULL )
    {
        //
        // After return we will unlock, allowing async
        // FinalMediaSampleRelease to release sample.
        //

        //
        // Let's try again in three milliseconds. This is short enough not
        // to cause a noticeable quality degradation, and long enough to
        // prevent eating 100% CPU when the transport is broken and does not
        // return samples.
        //

        WaitTime = 3;

        LOG((MSP_TRACE, "CMediaTerminalFilter::FillMyBuffer - no available "
                        "output samples in queue; returning "
                        "VFW_S_NO_MORE_ITEMS"));

        return VFW_S_NO_MORE_ITEMS;
    }

    
    //
    // Got a free output buffer, so put some data in it.
    //
    // if audio, fragment the buffer else, pass the whole buffer
    // (no fragmentation for video as video data is frame based)
    //

    m_pSampleBeingFragmented->Fragment(
        m_bIsAudio,             // allow fragmentation if audio, not if video
        m_AllocProps.cbBuffer,  // outgoing buffer size
        *pQueueSample,          // outgoing sample -- reference (IN parameter)
        *pfDone                 // done with user sample? -- reference (OUT parameter)
        );

    //
    // CODEWORK: to support combining as well as fragmentation, we would need to
    // (1) modify CUserMediaSample::Fragment and code underneath to append to outgoing
    //     buffer (copy into it) -- this may get interesting considering we are dealing
    //     with CQueueMediaSample as the outgoing samples!
    // (2) introduce a loop here in GetFilledBuffer -- keep getting more input samples
    //     until the output sample is full or the input queue has been exhausted.
    //     Interesting case is what to do if the input queue has been exhausted -- we
    //     can perhaps just send the outgoing sample at that point. NOTE that this is
    //     always going to happen on the last sample in a long stretch, and it will happen
    //     a lot if the app is written to not submit all the samples at once (need to
    //     document the latter)
    //

    //
    // Fill out pMediaSample. The caller fills out the wait time if the
    // result of this method is S_OK.
    //

    
    pMediaSample = (IMediaSample *)(pQueueSample->m_pMediaSample);
    pMediaSample->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// SetTime
//
// This is called from GetFilledBuffer() to set the timestamp on the sample 
// before sending it down the filter graph.
//
// The timestamp is determined based on the duration of the sample and the 
// timestamp of the last sample.
//
//////////////////////////////////////////////////////////////////////////////

HRESULT CMediaTerminalFilter::SetTime(IMediaSample *pMediaSample)
{
    HRESULT hr = S_OK;

    // the sample starts when the previous sample ended
    REFERENCE_TIME rtStartTime = m_rtLastSampleEndedAt;
    REFERENCE_TIME rtEndTime = rtStartTime;
    
    // calculate sample's duration

    if (m_bIsAudio)
    {
        HRESULT nSampleSize = pMediaSample->GetSize();

        m_rtLastSampleDuration = 
           (REFERENCE_TIME)((double)nSampleSize * m_AudioDelayPerByte) * 10000;
    }
    else
    {
        // NOTE: assumption is that if not audio, it is video. 
        // another assumption is that one media sample is one frame
        m_rtLastSampleDuration = m_VideoDelayPerFrame * 10000;
    }
    
    // when does the sample end?
    rtEndTime += m_rtLastSampleDuration;
   
    LOG((MSP_TRACE, 
        "CMediaTerminal::SetTime setting timestamp to (%lu, %lu) ",
        (DWORD)(rtStartTime/10000), (DWORD)(rtEndTime/10000)));

    // we know when it started and when it ended. set the timestamp
    hr = pMediaSample->SetTime(&rtStartTime, &rtEndTime);

    m_rtLastSampleEndedAt = rtEndTime;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CMediaTerminalFilter::SetDiscontinuityIfNeeded
//
// this function sets discontinuity flag if the sample came too late to 
// smoothly continue the data flow. the assumption is that if the app did not 
// feed us with data for some time, then that means there was no data, and the 
// new data coming after the pause is a new part of the data stream, with a new
// timeline
//

HRESULT CMediaTerminalFilter::SetDiscontinuityIfNeeded(IMediaSample *pMediaSample)
{


    //
    // have a filter? (need it to get clock to get real time)
    //

    if ( NULL == m_pBaseFilter )
    {

        LOG((MSP_ERROR,
            "CMediaTerminalFilter::SetDiscontinuityIfNeeded() - no filter"));

        return E_UNEXPECTED;
    }


    //
    // ask filter for clock
    //

    IReferenceClock *pClock = NULL;

    HRESULT hr = m_pBaseFilter->GetSyncSource(&pClock);

    if (FAILED(hr))
    {

        //
        // no clock...
        //

        LOG((MSP_ERROR,
            "CMediaTerminalFilter::SetDiscontinuityIfNeeded() - no clock. hr = %lx", hr));

        return hr;
    }


    //
    // try to get real time
    //

    REFERENCE_TIME rtRealTimeNow = 0;

    hr = pClock->GetTime(&rtRealTimeNow);

    pClock->Release();
    pClock = NULL;

    if (FAILED(hr))
    {

        LOG((MSP_ERROR,
            "CMediaTerminalFilter::SetDiscontinuityIfNeeded() - failed to get time. "
            "hr = %lx", hr));

        return hr;
    }


    //
    // how much time passed since the last sample was sent?
    //

    REFERENCE_TIME rtRealTimeDelta = rtRealTimeNow - m_rtRealTimeOfLastSample;


    //
    // keep current real time as the "last sample's" real time, to be used for
    // in continuity determination for the next sample
    //

    m_rtRealTimeOfLastSample = rtRealTimeNow;


    //
    // how long was it supposed to take for the last sample to play? if too 
    // much time passed since the sample was supposed to be done, this is 
    // a discontinuity.
    //
    // note that SetTime on this sample should be called _after_ this method so
    // it does not set m_rtLastSampleDuration to duration of the current 
    // sample before we figure out if this is a discontinuity or not
    //

    REFERENCE_TIME rtMaximumAllowedJitter = m_rtLastSampleDuration * 2;

    if ( rtRealTimeDelta > rtMaximumAllowedJitter )
    {

        //
        // too much real time passed since the last sample. discontinuity.
        //

        LOG((MSP_TRACE,
            "CMediaTerminalFilter::SetDiscontinuityIfNeeded - late sample. setting discontinuity"));

        hr = pMediaSample->SetDiscontinuity(TRUE);


        //
        // did we fail to set the discontinuity flag? propagate error to the caller
        //

        if (FAILED(hr))
        {

            LOG((MSP_ERROR,
                "CMediaTerminalFilter::SetDiscontinuityIfNeeded() - pMediaSample->SetTime failed. "
                "hr = 0x%lx", hr));

            return hr;
        }

    } // late sample


    return S_OK;
}



// the application is supposed to call DeleteMediaType(*ppmt) (on success)
// if the pin is not connected, return the suggested media type if 
// one exists, else return error
// else return the media format of the connected pin - this is stored in
// m_ConnectedMediaType during Connect or ReceiveConnection 
HRESULT
CMediaTerminalFilter::GetFormat(
    OUT  AM_MEDIA_TYPE **ppmt
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminal::GetFormat(%p) called", ppmt));
    // validate the parameter
    BAIL_IF_NULL(ppmt, E_POINTER);

    // the operator == is defined on CComPtr, hence, NULL comes second
    if (m_pConnectedPin == NULL) 
    {
        // if a media type was suggested by the user before connection
        // create and return a media type structure with those values. The pin need not
        // be connected
        if (NULL != m_pSuggestedMediaType)
        {
            // create and copy the media type
            *ppmt = CreateMediaType(m_pSuggestedMediaType);
            return S_OK;
        }

        return VFW_E_NOT_CONNECTED;
    }

    // create and copy the media type
    *ppmt = CreateMediaType(&m_ConnectedMediaType);

    LOG((MSP_TRACE, "CMediaTerminal::GetFormat(%p) succeeded", ppmt));    
    return S_OK;
}

    
// if this is called when the stream is connected,
// an error value is returned.
// it is only used in  unconnected terminals to set the media format to negotiate
// when connected to the filter graph.
HRESULT
CMediaTerminalFilter::SetFormat(
    IN  AM_MEDIA_TYPE *pmt
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::SetFormat(%p) - enter", pmt));

    // check if already connected
    if (m_pConnectedPin != NULL)
    {
        LOG((MSP_ERROR, "CMediaTerminalFilter::SetFormat(%p) - "
            "already connected - exit VFW_E_ALREADY_CONNECTED", pmt));

        return VFW_E_ALREADY_CONNECTED;
    }

    //
    // ZoltanS: To aid the MSPs in conveying to the application the media type
    // being used on a stream, SetFormat can no longer be successfully called
    // more than once with different media types.
    //
    // if pmt == NULL and m_psmt == NULL then do nothing, return S_OK
    // if pmt == NULL and m_psmt != NULL then do nothing, return error
    // if pmt != NULL and m_psmt != NULL then
    //          if media types are the same then do nothing, return S_OK
    //          if media types differ then do nothing, return error
    //
    // only if pmt != NULL and m_psmt == NULL then try to set the media type
    //

    if ( pmt == NULL )
    {
        if ( m_pSuggestedMediaType == NULL )
        {
            LOG((MSP_WARN, "CMediaTerminalFilter::SetFormat(%p) - "
                "was NULL, set to NULL - this does nothing - exit S_OK",
                pmt));

            return S_OK;
        }
        else
        {
            LOG((MSP_ERROR, "CMediaTerminalFilter::SetFormat(%p) - "
                "was non-NULL, tried to set to NULL - rejected because once "
                "a type is set it is permanent - exit VFW_E_TYPE_NOT_ACCEPTED",
                pmt));

            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    else if ( m_pSuggestedMediaType != NULL )
    {
        if ( IsSameAMMediaType(pmt, m_pSuggestedMediaType) )
        {
            LOG((MSP_WARN, "CMediaTerminalFilter::SetFormat(%p) - "
                "was non-NULL, set same type again - this does nothing - "
                "exit S_OK", pmt));

            return S_OK;
        }
        else
        {
            LOG((MSP_ERROR, "CMediaTerminalFilter::SetFormat(%p) - "
                "was non-NULL, tried to set to new, different type - "
                "rejected because once a type is set it is permanent - "
                "exit VFW_E_TYPE_NOT_ACCEPTED", pmt));

            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }

    LOG((MSP_TRACE, "CMediaTerminalFilter::SetFormat(%p) - OK to try setting "
        "format - calling QueryAccept", pmt));

    //
    // check if the media type is acceptable for the terminal
    // return VFW_E_INVALIDMEDIATYPE if we can't accept it 
    //

    HRESULT hr = QueryAccept(pmt);

    if ( hr != S_OK ) // NOTE: S_FALSE from QueryAccept indicates rejection.
    {
        LOG((MSP_ERROR, "CMediaTerminalFilter::SetFormat(%p) - "
            "QueryAccept rejected type - exit VFW_E_INVALIDMEDIATYPE", pmt));

        return VFW_E_INVALIDMEDIATYPE;
    }

    //
    // Accepted. Create an am media type initialized with the pmt value.
    //

    m_pSuggestedMediaType = CreateMediaType(pmt);
    
    if ( m_pSuggestedMediaType == NULL )
    {
        LOG((MSP_ERROR, "CMediaTerminalFilter::SetFormat(%p) - "
            "out of memory in CreateMediaType - exit E_OUTOFMEMORY", pmt));

        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CMediaTerminalFilter::SetFormat succeeded - new media "
        "type (%p) set", pmt));

    return S_OK;
}

// This method may only be called before connection and will
// force the MST to convert buffers to this buffer size.
// If this is set then we try these values during filter negotiation
// and if the connecting filter doesn't accept these, then we convert

STDMETHODIMP
CMediaTerminalFilter::SetAllocatorProperties(
    IN  ALLOCATOR_PROPERTIES *pAllocProperties
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminal::SetAllocatorProperties[%p] - enter. pAllocProperties[%p]", 
        this, pAllocProperties));

    AUTO_CRIT_LOCK;

    //
    // check if already connected
    //

    if (m_pConnectedPin != NULL)
    {
        LOG((MSP_WARN,
            "CMediaTerminal::SetAllocatorProperties -  VFW_E_ALREADY_CONNECTED"));

        return VFW_E_ALREADY_CONNECTED;
    }
    
    if (NULL == pAllocProperties)
    {
        m_bUserAllocProps = FALSE;

        if ( ! m_bSuggestedAllocProps )
        {
            SetDefaultAllocatorProperties();
        }

        return S_OK;
    }
    
    if (!CUserMediaSample::VerifyAllocatorProperties(
            m_bAllocateBuffers, 
            *pAllocProperties
            ))
    {
        return E_FAIL;
    }

    
    DUMP_ALLOC_PROPS("CMediaTerminal::SetAllocatorProperties - new properties:", pAllocProperties);

    //
    // the user wants to use these properties on their samples
    //

    m_bUserAllocProps = TRUE;
    m_UserAllocProps = *pAllocProperties;

    
    m_AllocProps = m_UserAllocProps;

    LOG((MSP_TRACE, 
        "CMediaTerminal::SetAllocatorProperties - succeeded"));

    return S_OK;
}

    
// an ITAllocatorProperties method
// calls to IAMBufferNegotiation::GetAllocatorProperties are also forwarded to
// this method by the terminal
//
// gets current values for the allocator properties
// after connection, this provides the negotiated values
// it is invalid before connection. The MST will accept
// any values suggested by the filters it connects to

STDMETHODIMP
CMediaTerminalFilter::GetAllocatorProperties(
    OUT  ALLOCATOR_PROPERTIES *pAllocProperties
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminalFilter::GetAllocatorProperties(%p) called", 
        pAllocProperties));

    BAIL_IF_NULL(pAllocProperties, E_POINTER);

    AUTO_CRIT_LOCK;
    
    *pAllocProperties = m_AllocProps;

    DUMP_ALLOC_PROPS("CMediaTerminalFilter::GetAllocatorProperties", pAllocProperties);
    
    LOG((MSP_TRACE, 
        "CMediaTerminalFilter::GetAllocatorProperties - succeeded"));

    return S_OK;
}

// an IAMBufferNegotiation method, forwarded to us by the terminal

STDMETHODIMP
CMediaTerminalFilter::SuggestAllocatorProperties(
    IN  const ALLOCATOR_PROPERTIES *pAllocProperties
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminal::SuggestAllocatorProperties(%p) called", 
        pAllocProperties));

    AUTO_CRIT_LOCK;

    // check if already connected
    if (m_pConnectedPin != NULL)
    {
        return VFW_E_ALREADY_CONNECTED;
    }
    
    //
    // Passing in NULL sets us back to our defaults. This would seem to make
    // sense, but it's nowhere to be found in the spec for the interface.
    //

    if (NULL == pAllocProperties)
    {
        m_bSuggestedAllocProps = FALSE;

        if ( m_bUserAllocProps )
        {
            m_AllocProps = m_UserAllocProps;
        }
        else
        {
            SetDefaultAllocatorProperties();
        }

        return S_OK;
    }


    //
    // If any of the fields in the suggested allocator properties
    // structure is negative, then we use the current values for those
    // fields. This is as per the interface definition. We can't just
    // change pAllocProperties because it's const.
    //

    ALLOCATOR_PROPERTIES FinalProps = * pAllocProperties;

    if ( FinalProps.cbAlign  < 0 )
    {
        FinalProps.cbAlign  = DEFAULT_AM_MST_BUFFER_ALIGNMENT;
    }

    if ( FinalProps.cbBuffer < 0 )
    {
        FinalProps.cbBuffer = DEFAULT_AM_MST_SAMPLE_SIZE;
    }

    if ( FinalProps.cbPrefix < 0 )
    {
        FinalProps.cbPrefix = DEFAULT_AM_MST_BUFFER_PREFIX;
    }

    if ( FinalProps.cBuffers < 0 )
    {
        FinalProps.cBuffers = DEFAULT_AM_MST_NUM_BUFFERS;
    }

    //
    // Sanity-check the resulting properties.
    //

    if (!CUserMediaSample::VerifyAllocatorProperties(
            m_bAllocateBuffers, 
            FinalProps
            ))
    {
        return E_FAIL;
    }


    DUMP_ALLOC_PROPS("CMediaTerminalFilter::SuggestAllocatorProperties - suggested:", &FinalProps);

    // 
    // if allocator properties were already set using SetAllocatorProperties,
    // fail -- suggesting does not override the value that has been set.
    //

    if (m_bUserAllocProps)
    {

        //
        // the properties have been Set by SetAllocatorProperties, whoever is 
        // suggesting new properties had better be suggesting exactly same set,
        // otherwise we will fail the call.
        //

        if ( !Equal(&m_UserAllocProps, pAllocProperties) )
        {

            //
            // the application has requested specific allocator properties. 
            // but someone is now suggesting a different set of properties.
            // the properties that have been set can only be re-set.
            //

            LOG((MSP_WARN,
                "CMediaTerminal::SuggestAllocatorProperties "
                "- can't override SetAllocatorProperties settings. VFW_E_WRONG_STATE"));

            return VFW_E_WRONG_STATE;
        }
    }


    // the MSP wants us to try these properties

    m_bSuggestedAllocProps = TRUE;
    m_AllocProps = FinalProps;


    DUMP_ALLOC_PROPS("CMediaTerminalFilter::SuggestAllocatorProperties - kept:", &m_AllocProps);
    
    LOG((MSP_TRACE, "CMediaTerminal::SuggestAllocatorProperties - finish"));

    return S_OK;
}

// TRUE by default. when set to FALSE, the sample allocated
// by the MST don't have any buffers and they must be supplied
// before Update is called on the samples
STDMETHODIMP
CMediaTerminalFilter::SetAllocateBuffers(
    IN  BOOL bAllocBuffers
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminal::SetAllocateBuffers(%u) called", 
        bAllocBuffers));

    AUTO_CRIT_LOCK;
    
    // check if already connected
    if (m_pConnectedPin != NULL)    return VFW_E_ALREADY_CONNECTED;
    
    if (!CUserMediaSample::VerifyAllocatorProperties(
            bAllocBuffers, 
            m_AllocProps
            ))
    {
        return E_FAIL;
    }

    // set flag for allocating buffers for samples
    m_bAllocateBuffers = bAllocBuffers;
    
    LOG((MSP_TRACE, 
        "CMediaTerminal::SetAllocateBuffers(%u) succeeded", 
        bAllocBuffers));

    return S_OK;
}

// returns the current value of this boolean configuration parameter
STDMETHODIMP
CMediaTerminalFilter::GetAllocateBuffers(
    OUT  BOOL *pbAllocBuffers
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminal::GetAllocateBuffers(%p) called", 
        pbAllocBuffers));

    BAIL_IF_NULL(pbAllocBuffers, E_POINTER);

    AUTO_CRIT_LOCK;
    
    *pbAllocBuffers = m_bAllocateBuffers;
    
    LOG((MSP_TRACE, 
        "CMediaTerminal::GetAllocateBuffers(*%p = %u) succeeded", 
        pbAllocBuffers, *pbAllocBuffers));

    return S_OK;
}


// this size is used for allocating buffers when AllocateSample is
// called (if 0, the negotiated allocator properties' buffer size is
// used). this is only valid when we have been told to allocate buffers
STDMETHODIMP
CMediaTerminalFilter::SetBufferSize(
    IN  DWORD    BufferSize
    )
{
    AUTO_CRIT_LOCK;

    m_AllocateSampleBufferSize = BufferSize;

    return S_OK;
}

// returns the value used to allocate buffers when AllocateSample is
// called. this is only valid when we have been told to allocate buffers
STDMETHODIMP
CMediaTerminalFilter::GetBufferSize(
    OUT  DWORD    *pBufferSize
    )
{
    BAIL_IF_NULL(pBufferSize, E_POINTER);

    AUTO_CRIT_LOCK;

    *pBufferSize = m_AllocateSampleBufferSize;

    return S_OK;
}

    
// over-ride this to return failure. we don't allow it to join a multi-media
// stream because the multi-media stream thinks it owns the stream
STDMETHODIMP
CMediaTerminalFilter::JoinAMMultiMediaStream(
    IN  IAMMultiMediaStream *pAMMultiMediaStream
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::JoinAMMultiMediaStream(%p) called",
        pAMMultiMediaStream));
    return E_FAIL;
}
        

// over-ride this to return failure if a non-null proposed filter is 
// anything other than the media stream filter that is acceptable to us
// This acceptable filter is set in SetMediaStreamFilter()
STDMETHODIMP
CMediaTerminalFilter::JoinFilter(
    IN  IMediaStreamFilter *pMediaStreamFilter
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::JoinFilter(%p) called", pMediaStreamFilter));

    // check if the caller is trying to remove references to the media stream filter
    if (NULL == pMediaStreamFilter)
    {
        // null out references to the filter that were set when JoinFilter was called
        // with a valid media stream filter
        m_pFilter = NULL;
        m_pBaseFilter = NULL;

        return S_OK;
    }

    // check if the passed in filter is different from the one 
    // that is acceptable
    if (pMediaStreamFilter != m_pMediaStreamFilterToAccept)
    {
        return E_FAIL;
    }

    // if the filter is already set, it must have joined the graph already
    if (NULL != m_pFilter)
    {
        return S_OK;
    }

    // save a pointer to the media stream filter
    m_pFilter = pMediaStreamFilter;

    // get the base filter i/f
    HRESULT hr;
    hr = pMediaStreamFilter->QueryInterface(IID_IBaseFilter, (void **)&m_pBaseFilter);
    BAIL_ON_FAILURE(hr);

    // release a reference as this method is not supposed to increase ref count on the filter
    // NOTE: this is being done in CStream - merely following it. TO DO ** why?
    m_pBaseFilter->Release();
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::JoinFilter(%p) succeeded", pMediaStreamFilter));
    return S_OK;
}

    
// create an instance of CUserMediaSample and initialize it
STDMETHODIMP
CMediaTerminalFilter::AllocateSample(
    IN   DWORD dwFlags,
    OUT  IStreamSample **ppSample
    )
{
    LOG((MSP_TRACE, 
            "CMediaTerminalFilter::AllocateSample(dwFlags:%u, ppSample:%p)",
            dwFlags, ppSample));

    // validate parameters
    // we don't support any flags
    if (0 != dwFlags) return E_INVALIDARG;

    BAIL_IF_NULL(ppSample, E_POINTER);

    AUTO_CRIT_LOCK;

    // create a sample and initialize it
    HRESULT hr;
    CComObject<CUserMediaSample> *pUserSample;
    hr = CComObject<CUserMediaSample>::CreateInstance(&pUserSample);
    BAIL_ON_FAILURE(hr);

    // uses the allocator properties to allocate a bufer, if the
    // user has asked for one to be created
    hr = pUserSample->Init(
        *this, m_bAllocateBuffers, 
        m_AllocateSampleBufferSize, m_AllocProps
        );
    if (HRESULT_FAILURE(hr))
    {
        delete pUserSample;
        return hr;
    }

    hr = pUserSample->QueryInterface(IID_IStreamSample, (void **)ppSample);
    if ( FAILED(hr) )
    {
        delete pUserSample;
        return hr;
    }
    
    LOG((MSP_TRACE, 
            "CMediaTerminalFilter::AllocateSample(dwFlags:%u, ppSample:%p) succeeded",
            dwFlags, ppSample));
    return S_OK;
}


// return E_NOTIMPL - we don't have a mechanism to share a sample currently
STDMETHODIMP
CMediaTerminalFilter::CreateSharedSample(
    IN   IStreamSample *pExistingSample,
    IN   DWORD dwFlags,
    OUT  IStreamSample **ppNewSample
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::CreateSharedSample called"));
    return E_NOTIMPL;
}


// supposed to get the format information for the passed in IMediaStream
// set this instance's media format
// not implemented currently
STDMETHODIMP 
CMediaTerminalFilter::SetSameFormat(
    IN  IMediaStream *pStream, 
    IN  DWORD dwFlags
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::SetSameFormat called"));
    return E_NOTIMPL;
}


// CMediaTerminalFilter uses CMediaPump ms_MediaPumpPool instead of 
// CPump *m_WritePump. therefore, CStream::SetState which uses CPump 
// had to be overridden here
// also, it resets the end of stream flag when a connected stream is
// told to run
STDMETHODIMP 
CMediaTerminalFilter::SetState(
    IN  FILTER_STATE State
    )
{
    LOG((MSP_TRACE, "IMediaStream::SetState(%d) called",State));

    Lock();
    if (m_pConnectedPin == NULL) {
        Unlock();
        if (State == STREAMSTATE_RUN) {
            EndOfStream();
        }
    } else {
        TM_ASSERT(m_pAllocator != NULL);
        m_FilterState = State;
        if (State == State_Stopped) {
            m_pAllocator->Decommit();
            if (!m_bUsingMyAllocator) {
                Decommit();
            }
            Unlock();
        }  else {
            // rajeevb - clear the end of stream flag
            m_bEndOfStream = false;

            // zoltans - moved Unlock here to avoid deadlock in commit.
            // some of what's done within Commit needs to have the lock
            // released. That's to avoid holding the stream lock while
            // trying to acquire the pump lock.

            Unlock();

            m_pAllocator->Commit();
            if (!m_bUsingMyAllocator) {
                Commit();
            }
        }
    }

    if (State == State_Stopped)
    {
      LOG((MSP_TRACE, "CMediaTerminalFilter::SetState stopped. "));

      m_rtLastSampleEndedAt = 0;
    }

    LOG((MSP_TRACE, "IMediaStream::SetState(%d) succeeded",State));    
    return S_OK;
}


// if own allocator, just set completion on the sample
// NOTE: this is not being done in the derived classes
// else, get a stream sample from pool,
//       copy the media sample onto the stream sample
//       set completion
// NOTE: find out why the quality notifications are being sent in the
// derived classes


STDMETHODIMP
CMediaTerminalFilter::Receive(
    IN  IMediaSample *pSample
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::Receive(%p) called", pSample));

    COM_LOCAL_CRIT_LOCK LocalLock(this);
    
    if (m_bFlushing)    return S_FALSE;
    if (0 > pSample->GetActualDataLength()) return S_FALSE;

    if (m_bUsingMyAllocator) 
    {
        CUserMediaSample *pSrcSample = 
            (CUserMediaSample *)((CMediaSampleTM *)pSample)->m_pSample;
        pSrcSample->m_bReceived = true;

        // the completion state need not be set because, the caller holds the last reference
        // on the media sample and when it is released (after the return of this fn), 
        // the completion state gets set
        return S_OK;
    } 
    
    CUserMediaSample *pDestSample;

    REFERENCE_TIME rtStart, rtEnd;
    
    pSample->GetTime(&rtStart, &rtEnd);

    LOG((MSP_TRACE, 
        "CMediaTerminalFilter::Receive: (start - %l, stop - %l)\n", 
        rtStart, rtEnd));

    // unlock to wait for a sample
    LocalLock.Unlock();

    HRESULT hr;

    // get the buffer ptr
    BYTE *pSrcBuffer = NULL;

    // ignore error code, the pointer will be checked in the loop
    pSample->GetPointer(&pSrcBuffer);

    // determine the number of bytes to copy
    LONG SrcDataSize = pSample->GetActualDataLength();


    //
    // allocate samples from the pool, copy the received sample data into
    // the allocated sample buffer until all of the data has been copied
    // NOTE: This works for both combining and splitting samples.
    //   * splitting: loop until distributed to enough samples
    //   * combining: stick it in the first sample; SetCompletionStatus
    //     queues it up again for next time
    //

    do
    {
        //
        // Get a destination / user / outgoing sample from the pool.
        // Wait for it if none is available right now.
        // The obtained CSample has a ref count on it that must be released
        // after we are done with it.
        //

        hr = AllocSampleFromPool(NULL, (CSample **)&pDestSample, 0);
        BAIL_ON_FAILURE(hr);

        //
        // Copy the media sample into the destination sample and 
        // signal destination sample completion.
        //
        // CUserMediaSample::CopyFrom returns ERROR_MORE_DATA if there's more
        //    data that can fit into this user sample
        // CUserMediaSample::SetCompletionStatus passes through the HRESULT
        //    value that's passed into it, unless it encounters an error of
        //    its own
        //

        LONG OldSrcDataSize = SrcDataSize;
        hr = pDestSample->SetCompletionStatus(
                pDestSample->CopyFrom(pSample, pSrcBuffer, SrcDataSize)
                );

        //
        // Release the destination sample.
        //

        ((IStreamSample *)pDestSample)->Release();
    }
    while(ERROR_MORE_DATA == HRESULT_CODE(hr));

    LOG((MSP_TRACE, "CMediaTerminalFilter::Receive(%p) succeeded", pSample));

    return S_OK;
}


STDMETHODIMP
CMediaTerminalFilter::GetBuffer(
    IMediaSample **ppBuffer, 
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime, 
    DWORD dwFlags
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::GetBuffer(%p, %p, %p, %u) called",
        ppBuffer, pStartTime, pEndTime, dwFlags));

    if (NULL == ppBuffer)   return E_POINTER;

#ifdef DBG
    {
        COM_LOCAL_CRIT_LOCK LocalLock(this);
        TM_ASSERT(m_bUsingMyAllocator);
    }
#endif // DBG

    // no lock needed here as AllocSampleFromPool acquires lock.
    // shouldn't hold lock at this point as the fn waits on a single
    // event inside
    *ppBuffer = NULL;
    CUserMediaSample *pSample;
    HRESULT hr = AllocSampleFromPool(NULL, (CSample **)&pSample, dwFlags);
    BAIL_ON_FAILURE(hr);

    // the sample has a refcnt on it. this will be released after we
    // signal the user in FinalMediaSampleRelease

    pSample->m_bReceived = false;
    pSample->m_bModified = true;
    *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
    (*ppBuffer)->AddRef();

    LOG((MSP_TRACE, "CMediaTerminalFilter::GetBuffer(%p, %p, %p, %u) succeeded",
        ppBuffer, pStartTime, pEndTime, dwFlags));
    return hr;
}


STDMETHODIMP
CMediaTerminalFilter::SetProperties(
    ALLOCATOR_PROPERTIES* pRequest, 
    ALLOCATOR_PROPERTIES* pActual
    )
{

    LOG((MSP_TRACE,
        "CMediaTerminalFilter::SetProperties[%p] - enter. requested[%p] actual[%p]",
        this, pRequest, pActual));


    //
    // check pRequest argument
    //

    if (IsBadReadPtr(pRequest, sizeof(ALLOCATOR_PROPERTIES)))
    {
        LOG((MSP_ERROR,
            "CMediaTerminalFilter::SetProperties - bad requested [%p] passed in",
            pRequest));

        return E_POINTER;
    }


    //
    // if the caller passed us a non-NULL pointer for allocator properties for us to 
    // return, it'd better be good.
    //

    if ( (NULL != pActual) && IsBadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES)))
    {
        LOG((MSP_ERROR,
            "CMediaTerminalFilter::SetProperties - bad actual [%p] passed in",
            pRequest));

        return E_POINTER;
    }


    
    // this critical section is needed for the allocator

    AUTO_CRIT_LOCK;

    
    if (m_bCommitted) 
    {
         LOG((MSP_WARN, 
             "CMediaTerminalFilter::SetProperties - already commited"));

        return VFW_E_ALREADY_COMMITTED;
    }


    if (!CUserMediaSample::VerifyAllocatorProperties(
            m_bAllocateBuffers, 
            *pRequest
            ))
    {

        LOG((MSP_ERROR,
             "CMediaTerminalFilter::SetProperties - requested properties failed verification"));

        return E_FAIL;
    }


    DUMP_ALLOC_PROPS("CMediaTerminalFilter::SetProperties. Requested:", pRequest);


    //
    // if the app set alloc properties by calling SetAllocatorProperties, we 
    // can only use those properties, and no others
    //

    if (m_bUserAllocProps)
    {

        //
        // properties were already set 
        //

        LOG((MSP_TRACE, 
            "CMediaTerminalFilter::SetProperties - properties were configured through SetAllocatorProperties"));
       
    }
    else
    {

        //
        // no one has asked us for specific properties before, so
        // we can accept the properties that we are given now.
        //

        LOG((MSP_TRACE,
            "CMediaTerminalFilter::SetProperties - accepting requested properties"));

        m_AllocProps = *pRequest;
    }


    //
    // tell the caller what properties we can actually provide
    //

    if (NULL != pActual)    
    {

        *pActual = m_AllocProps;
    }

    
    DUMP_ALLOC_PROPS("CMediaTerminalFilter::SetProperties - ours:", &m_AllocProps);

    LOG((MSP_TRACE, "CMediaTerminalFilter::SetProperties - succeeded"));

    return S_OK;
}

    
STDMETHODIMP
CMediaTerminalFilter::GetProperties(
    ALLOCATOR_PROPERTIES* pProps
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::GetProperties(%p) called", 
        pProps));

    BAIL_IF_NULL(pProps, E_POINTER);

    // this critical section is required for the allocator
    AUTO_CRIT_LOCK;
    
    *pProps = m_AllocProps;

    DUMP_ALLOC_PROPS("CMediaTerminalFilter::GetProperties - our properties:", pProps);

    LOG((MSP_TRACE, "CMediaTerminalFilter::GetProperties - succeeded"));

    return NOERROR;
}

// the thread pump calls the filter back during the registration
// to tell it that registration succeeded and that the pump will be
// waiting on the m_hWaitFreeSem handle
HRESULT
CMediaTerminalFilter::SignalRegisteredAtPump(
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminalFilter::SignalRegisteredAtPump[%p] - started",
        this));


    AUTO_CRIT_LOCK;

    TM_ASSERT(PINDIR_OUTPUT == m_Direction);

    // check if not committed
    if (!m_bCommitted)
    {
        // if we missed a decommit in between, 
        // signal the thread that we have been decommited
        ReleaseSemaphore(m_hWaitFreeSem, 1, 0);
        return VFW_E_NOT_COMMITTED;
    }

    TM_ASSERT(0 == m_lWaiting);
    m_lWaiting = 1;

    LOG((MSP_TRACE, "CMediaTerminalFilter::SignalRegisteredAtPump - completed, m_lWaiting = 1"));

    return S_OK;
}

//
// Override Commit to provide the number of buffers promised in negotiation
// as well as to register with the media pump thread.
// no need to call the adapted base class Commit
STDMETHODIMP CMediaTerminalFilter::Commit()
{

    LOG((MSP_TRACE, "CMediaTerminalFilter[0x%p]::Commit - entered", this));


    HRESULT hr = E_FAIL;

    COM_LOCAL_CRIT_LOCK LocalLock(this);
        
    if (m_bCommitted)   return S_OK;

    m_bCommitted = true;

    
    // Now actually allocate whatever number of buffers we've promised.
    // We need to do this only if we are a WRITE terminal, the read
    // terminal doesn't expose an allocator and thus hasn't promised any
    // samples
    // NOTE: the direction only changes in Init so we can safely access
    // m_Direction without the lock
    if (PINDIR_OUTPUT == m_Direction)
    {

        LOG((MSP_TRACE, "CMediaTerminalFilter::Commit pindir_output"));


        //
        // If we are a WRITE MST but we are using a downstream allocator,
        // then we do not use the NBQueue; instead we copy into the
        // downstream allocator's samples.
        //

        if ( m_bUsingMyAllocator )
        {
            
            LOG((MSP_TRACE, "CMediaTerminalFilter::Commit using myallocator"));


            //
            // initialize sample queue
            //

            BOOL bQueueInitialized = m_SampleQueue.InitializeQ(m_AllocProps.cBuffers);

            if ( ! bQueueInitialized )
            {
                LOG((MSP_ERROR, 
                    "CMediaTerminalFilter::Commit - failed to initialize sample queue."));

                return Decommit();
            }

            
            //
            // allocate samples and put them into the queue
            //

            for (LONG i = 0; i < m_AllocProps.cBuffers; i++)
            {


                //
                // create a sample
                //

                CComObject<CQueueMediaSample> *pQueueSample = NULL;
                
                hr = CComObject<CQueueMediaSample>::CreateInstance(&pQueueSample);

                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, 
                        "CMediaTerminalFilter::Commit - failed to create queue sample"));

                    return Decommit();
                }

                
                //
                // initialize the sample
                //

                hr = pQueueSample->Init(*this, m_SampleQueue);

                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, 
                        "CMediaTerminalFilter::Commit - failed to initialize queue sample"));

                    //
                    // failed to initializ. cleanup.
                    //

                    delete pQueueSample;
                    return Decommit();
                }


                //
                // put sample into the queue
                //

                BOOL QnQSuccess = m_SampleQueue.EnQueue(pQueueSample);


                if ( ! QnQSuccess )
                {
                    
                    LOG((MSP_ERROR, 
                        "CMediaTerminalFilter::Commit - failed to enqueue queue sample"));

                    //
                    // failed to put sample into the queue. cleanup.
                    //

                    delete pQueueSample;
                    return Decommit();

                }  // failed to enqueue sample

            } // for ( allocate and enqueue samples )
        
        } // if m_bUsingMyAllocator 

        

        // register this write filter with the thread pump.
        // we have to release our own lock - scenario - if we had a prior
        // registration which was decommitted, but the thread pump didn't
        // remove our entry (to be done when it waits on the wait event), the 
        // thread could be trying to get the filter lock while holding its own
        // we should not try to get the pump lock while holding our own
        HANDLE hWaitEvent = m_hWaitFreeSem;
        LocalLock.Unlock();
        
        hr = ms_MediaPumpPool.Register(this, hWaitEvent);

        if ( HRESULT_FAILURE(hr) ) 
        {
            return Decommit(); 
        }
    }

    LOG((MSP_TRACE, "CMediaTerminalFilter::Commit - completed"));

    return S_OK;
}


STDMETHODIMP CMediaTerminalFilter::ProcessSample(IMediaSample *pSample)
{

    LOG((MSP_TRACE, "CMediaTerminalFilter[%p]::ProcessSample - entered", this));


    Lock();


    //
    // in a lock, get a reference to the connected pin.
    //

    IMemInputPin *pConnectedPin = m_pConnectedMemInputPin;

    
    //
    // not connected? do nothing
    //

    if ( NULL == pConnectedPin ) 
    {

        Unlock();

        LOG((MSP_TRACE, 
            "CMediaTerminalFilter::ProcessSample - not connected. dropping sample. "
            "VFW_E_NOT_CONNECTED"));

        return VFW_E_NOT_CONNECTED;
    }


    //
    // addref so we can safely use this outside the lock
    //

    pConnectedPin->AddRef();


    //
    // receive may take a while, do not call inside a lock...
    //

    Unlock();


    //
    // pass the sample along to the connected pin
    //

    HRESULT hr = pConnectedPin->Receive(pSample);


    //
    // done, release the outstanding reference we requested.
    //

    pConnectedPin->Release();
    pConnectedPin = NULL;


    LOG((MSP_(hr), "CMediaTerminalFilter::ProcessSample - finish. hr = %lx", hr));

    return hr;
}


// release any waiting threads, dump the samples we allocated,
// abort the sample being fragmented and all the samples in the pool
STDMETHODIMP CMediaTerminalFilter::Decommit()
{

    LOG((MSP_TRACE, "CMediaTerminalFilter[%p]::Decommit - entered", this));


    Lock();

    // if not committed, do nothing
    if ( !m_bCommitted ) 
    {
        Unlock();

        return S_OK;
    }

    m_bCommitted = false;

    if ( m_lWaiting > 0 ) 
    {

        LOG((MSP_TRACE, 
            "CMediaTerminalFilter::Decommit - releasing m_hWaitFreeSem by %ld", 
            m_lWaiting));

        ReleaseSemaphore(m_hWaitFreeSem, m_lWaiting, 0);
        m_lWaiting = 0;
    }


    //
    // unlock while calling into Unregister, to avoid a deadlock on trying to lock the pump
    // while another thread has pump locked in CMediaPump::ServiceFilter while waiting to get
    // to filter's lock which we are holding
    //

    Unlock();


    //
    // unregister filter from media pump
    //

    ms_MediaPumpPool.UnRegister(m_hWaitFreeSem);


    //
    // lock the object again
    //

    Lock();


    //
    // If we are a write filter and we are using our own allocator, then
    // we have internal samples to destroy.
    // The read filter doesn't maintain a queue.
    //

    if ( ( PINDIR_OUTPUT == m_Direction ) && m_bUsingMyAllocator )
    {
        // don't wait for the samples, return if there are no more
        
        CQueueMediaSample *pSamp = NULL;

        while ((pSamp = m_SampleQueue.DeQueue(FALSE)) != NULL)
        {
            delete pSamp;
        }


        m_SampleQueue.ShutdownQ();
    }

    if (NULL != m_pSampleBeingFragmented)
    {
        // abort the sample when the last refcnt to its internal
        // IMediaStream is released
        m_pSampleBeingFragmented->AbortDuringFragmentation();
        ((IStreamSample *)m_pSampleBeingFragmented)->Release();
        m_pSampleBeingFragmented = NULL;
    }

    // all the threads waiting for a CStream pool buffer 
    // have been woken up by now
    // NOTE: no more samples can be added to the CStream pool
    // from now as we have decommitted (so no race conditions
    // possible if other threads are trying to add buffers to it)

    // go through the CStream sample q and for each sample
    // remove sample, unlock, abort the sample
    CSample *pSample = m_pFirstFree;
    while (NULL != pSample)
    {
        // remove sample from q
        m_pFirstFree = pSample->m_pNextFree;
        if (NULL != m_pFirstFree) m_pFirstFree->m_pPrevFree = NULL;
        else m_pLastFree = NULL;

        pSample->m_pNextFree = NULL;
        TM_ASSERT(pSample->m_Status == MS_S_PENDING);
        CHECKSAMPLELIST

        // unlock so that we don't have a deadlock due to the sample
        // trying to access the stream
        Unlock();

        // we know that the sample must be alive now because 
        // we have a reference to it
        // abort the sample, ignore error code (it'll return E_ABORT)
        pSample->SetCompletionStatus(E_ABORT);
        pSample->Release();

        // obtain lock
        Lock();

        // reset pSample to the top of the q
        pSample = m_pFirstFree;
    }


    Unlock();


    LOG((MSP_TRACE, "CMediaTerminalFilter::Decommit - finish"));

    // at this point, we hold a lock
    // return the result of PumpOverrideDecommit
    return S_OK;
}


// try to follow the cstream code when possible for Connect
// the cstream implementation calls ReceiveConnection on self! hence need
// to over-ride it
// use the pmt parameter or the suggested media type if not null?, else
// enumerate the input pin's media types and save a ptr to the first
// media type (to be written into the m_ConnectedMediaType, m_ActualMediaType
// on success). we accept any media type and we want to use our own allocator
// so, NotifyAllocator() and on success, set the allocator and copy the
// media type

STDMETHODIMP
CMediaTerminalFilter::Connect(
    IPin * pReceivePin, 
    const AM_MEDIA_TYPE *pmt
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::Connect(%p, %p) called", 
        pReceivePin, pmt));

    // if there is a suggested media type, we can't accept any 
    // suggested media type that is not same as it
    if ( (NULL != pmt) && 
         (NULL != m_pSuggestedMediaType) &&
         (!IsSameAMMediaType(pmt, m_pSuggestedMediaType)) )
    {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // get IMemInputPin i/f on the pReceivePin
    CComQIPtr<IMemInputPin, &IID_IMemInputPin> 
        pConnectedMemInputPin = pReceivePin; 
    BAIL_IF_NULL(pConnectedMemInputPin, VFW_E_TYPE_NOT_ACCEPTED);

    HRESULT hr;
    const AM_MEDIA_TYPE *pMediaType;

    // check if the passed in media type is non-null
    if (NULL != pmt)
    {
        // we have already checked it to be same as the suggested
        // media type, so no more checks are required
        pMediaType = pmt;
    }
    else if (NULL != m_pSuggestedMediaType) // try the suggested terminal media type
    {
        // we verified that the suggested media type was acceptable in put_MediaType
        pMediaType = m_pSuggestedMediaType;
    }
    else    // NOTE: we still try if the passed in media type (non-null) is not acceptable
    {
        // else, enumerate the input pin for media types and call QueryAccept for each to
        // check if the media type is acceptable

        // get the enumerator
        IEnumMediaTypes *pEnum;
        hr = EnumMediaTypes(&pEnum);
        BAIL_ON_FAILURE(hr);

        TM_ASSERT(NULL != pEnum);

        // for each media type, call QueryAccept. we are looking for the first acceptable media type
        DWORD NumObtained;
        while (S_OK == (hr = pEnum->Next(1, (AM_MEDIA_TYPE **)&pMediaType, &NumObtained)))
        {
            hr = QueryAccept(pMediaType);
            if (HRESULT_FAILURE(hr))
            {
                break;
            }
        }
        BAIL_ON_FAILURE(hr);

        // found an acceptable media type
    }

    if (NULL == pMediaType->pbFormat)
    {
        return VFW_E_INVALIDMEDIATYPE;
    }
       
    // call the input pin with the media type
    hr = pReceivePin->ReceiveConnection(this, pMediaType);
    BAIL_ON_FAILURE(hr);

    //////////////////////////////////////////////////////////////////////////
    //
    // Formats negotiated. Now deal with allocator properties.
    //
    // if ( other pin has allocator requirements: )
    //     if they exist and are usable then we must use them, overriding our
    //     own wishes. If they exist and are unusable then we fail to connect.
    //     if we use these, we do m_AllocProps = <required props>
    //
    //
    // The rest of the logic is not done here, but rather in the two
    //     methods: SuggestAllocatorProperties (msp method) and
    //     SetAllocatorProperties (user method). The net effect is:
    //
    // else if ( m_bSuggestedAllocProps == TRUE )
    //     MSP has set properties that they want us to use on the graph. If
    //     this is true then we try to use these properties.
    //     these are in m_AllocProps
    // else if ( m_bUserAllocProps == TRUE )
    //     user has properties they want us to convert to. if the suggested
    //     (MSP) setting hasn't happened, it'll be most efficient if we use
    //     these. these are in both m_AllocProps and m_UserAllocProps so that
    //     if the MSP un-suggests then we can go back to the user's settings
    // else
    //     just use m_AllocProps (these are set to default values on creation)
    //
    // in any of these cases we just use m_AllocProps as it already is filled
    // in with the correct values.
    //
    //////////////////////////////////////////////////////////////////////////

    
    //
    // So first of all, try to get the other pin's requirements.
    //

    ALLOCATOR_PROPERTIES DownstreamPreferred;

    //
    // downstream pin hints us of its preferences. we don't have to use them

    hr = pConnectedMemInputPin->GetAllocatorRequirements(&DownstreamPreferred);

    if ( ( hr != S_OK ) && ( hr != E_NOTIMPL ) )
    {
        // strange failure -- something's very wrong
        Disconnect();
        pReceivePin->Disconnect();
        return hr;
    }
    else if ( hr == S_OK )
    {
        //
        // This means that the downstream filter has allocator requirements.
        //

        if (!CUserMediaSample::VerifyAllocatorProperties(
                m_bAllocateBuffers,
                DownstreamPreferred
                ))
        {
            Disconnect();
            pReceivePin->Disconnect();
            return E_FAIL;
        }



        DUMP_ALLOC_PROPS("CMediaTerminalFilter::Connect - downstream preferences:", 
                         &DownstreamPreferred);


        //
        // see if the application asked for or suggested specific allocator properties
        //

        if (m_bUserAllocProps || m_bSuggestedAllocProps )
        {
           
            LOG((MSP_WARN, 
                "CMediaTerminalFilter::Connect "
                "- connected pin wants allocator props different from set or suggested"));
        }
        else
        {
        
            //
            // accept allocator properties asked by the downstream pin
            //

            m_AllocProps = DownstreamPreferred;
        }
    }


    DUMP_ALLOC_PROPS("CMediaTerminalFilter::Connect - properties to use:", &m_AllocProps);

    //
    // At this point, we know what allocator properties we are going to
    // use -- it's in m_AllocProps.
    //
    // Next we determine if the downstream filter has an allocator that
    // we can use.
    //

    IMemAllocator * pAllocatorToUse = NULL;

    //
    // Don't bother using a downstream allocator if the buffers are less than
    // a minimum size.
    //

    if ( m_AllocProps.cbBuffer < 2000 )
    {
        LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
            "small buffers - using our allocator"));

        hr = E_FAIL; // don't use downstream allocator
    }
    else
    {
        hr = pConnectedMemInputPin->GetAllocator( & pAllocatorToUse );

        if ( SUCCEEDED(hr) )
        {
            LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
                "downstream filter has an allocator"));

            //
            // The input pin on the downstream filter has its own allocator.
            // See if it will accept our allocator properties.
            //

            ALLOCATOR_PROPERTIES ActualAllocProps;

            hr = pAllocatorToUse->SetProperties( & m_AllocProps, & ActualAllocProps );

            if ( FAILED(hr) )
            {
                LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
                    "downstream allocator did not allow us to SetProperties - "
                    "0x%08x", hr));

                pAllocatorToUse->Release();
                pAllocatorToUse = NULL;
            }
            else if ( AllocatorPropertiesDifferSignificantly( & ActualAllocProps,
                                                              & m_AllocProps ) )
            {
                LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
                    "downstream allocator did allow us to SetProperties "
                    "but it changed the properties rather than accepting them"));

                // It succeeded but it modified the allocator properties
                // we gave it. To be safe, we use our own allocator instead.
                //
                // Note: The waveout filter enforces minimum sizes when its
                // allocator is used. This means that we only use the waveout
                // filter's allocator when our buffer size is sufficiently large
                // that the waveout filter doesn't tamper with them.

                hr = E_FAIL;

                pAllocatorToUse->Release();
                pAllocatorToUse = NULL;
            }
            else
            {
                LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
                    "downstream allocator accepted our allocator properties"));
            }
        } // if downstream filter has an allocator
    } // if large buffers

    //
    // At this point we have hr (success or failure) and a reference to the
    // downstream filter's alloactor if hr is success.
    //
    // If hr is success, then the downstream filter has an allocator that we can
    // use, and pAllocatorToUse points to that allocator. If hr is failure, then
    // we use our own allocator.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
            "using our own allocator"));

        pAllocatorToUse = this;
        pAllocatorToUse->AddRef(); // to match Release below

        m_bUsingMyAllocator = true;
    }
    else
    {
        LOG((MSP_TRACE, "CMediaTerminalFilter::Connect - "
            "using downstream allocator"));

        m_bUsingMyAllocator = false;
    }

    //
    // Notify the downstream input pin of the allocator we decided to use.
    //

    hr = pConnectedMemInputPin->NotifyAllocator(
        pAllocatorToUse,
        m_bUsingMyAllocator // if user's buffers, then read-only
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMediaTerminalFilter::Connect - "
            "downstream filter rejected our allocator choice - exit 0x%08x", hr));
    
        pAllocatorToUse->Release();

        Disconnect();
        pReceivePin->Disconnect();
        return hr;
    }

    //
    // Connection has succeeded.
    // Make sure we let ourselves know that this is our allocator!
    // NOTE: m_pAllocator is a CComPtr!!! It holds a reference to
    // the object after the assignment, so we need to release our
    // local reference now.
    //

    m_pAllocator = pAllocatorToUse;
    pAllocatorToUse->Release();
    
    // copy the media type into m_ConnectedMediaType
    CopyMediaType(&m_ConnectedMediaType, pMediaType);

    // member ptr to IMemInputPin i/f of the input pin
    m_pConnectedMemInputPin = pConnectedMemInputPin;

    // save a pointer to the connected pin
    m_pConnectedPin = pReceivePin;

    // get time to delay samples
    GetTimingInfo(m_ConnectedMediaType);

    LOG((MSP_TRACE, "CMediaTerminalFilter::Connect(%p, %p) succeeded", 
        pReceivePin, pmt));

    return hr;
}
    

// Return E_NOTIMPL to indicate that we have no requirements,
// since even if the user has specified properties, we now
// accept connections with other propertoes.

STDMETHODIMP CMediaTerminalFilter::GetAllocatorRequirements(
    OUT ALLOCATOR_PROPERTIES    *pProps
    )    
{
    LOG((MSP_TRACE,
        "CMediaTerminalFilter::GetAllocatorRequirements[%p] - enter", this));


    //
    // make sure some filter did not pass us a bad pointer
    //

    if (IsBadWritePtr(pProps, sizeof(ALLOCATOR_PROPERTIES)))
    {
        LOG((MSP_ERROR,
            "CMediaTerminalFilter::GetAllocatorRequirements - bad pointer [%p]", pProps));

        return E_POINTER;
    }


    AUTO_CRIT_LOCK;


    //
    // were allocator properties set or suggested? 
    //
    // fail if not -- this will indicate that we don't have a preference for 
    // specific allocator properties
    //

    if ( !m_bUserAllocProps && !m_bSuggestedAllocProps )
    {

        LOG((MSP_TRACE,
            "CMediaTerminalFilter::GetAllocatorRequirements - allocator properties were not set."));

        //
        // E_NOTIMPL is the base class' way to show that we don't care about allocator properties. 
        // return E_NOTIMPL so we don't break callers that depend on this error as a sign that 
        // allocator properties make not difference to us.
        //

        return E_NOTIMPL;
    }


    //
    // allocator properties were set -- return them.
    //

    *pProps = m_AllocProps;


    DUMP_ALLOC_PROPS("CMediaTerminalFilter::GetAllocatorRequirements - ours:",
        pProps);


    LOG((MSP_TRACE,
        "CMediaTerminalFilter::GetAllocatorRequirements - exit. "
        "returning previously set allocator properties."));

    return S_OK;
}

// we accept any media type
// call CheckReceiveConnectionPin to verify the pin and if successful
// copy media type and save the connector in m_pConnectedPin 
STDMETHODIMP
CMediaTerminalFilter::ReceiveConnection(
    IPin * pConnector, 
    const AM_MEDIA_TYPE *pmt
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::ReceiveConnection(%p, %p) called",
        pConnector, pmt));
    // validate the passed-in media type pointer
    BAIL_IF_NULL(pmt, E_POINTER);
    BAIL_IF_NULL(pmt->pbFormat, VFW_E_INVALIDMEDIATYPE);

    AUTO_CRIT_LOCK;

    //
    //  This helper function in CStream checks basic parameters for the Pin such as
    //  the connecting pin's direction (we need to check this -- Sometimes the filter
    //  graph will try to connect us to ourselves!) and other errors like already being
    //  connected, etc.
    //
    HRESULT hr;
    hr= CheckReceiveConnectionPin(pConnector);
    BAIL_ON_FAILURE(hr);

    // if there is a suggested media type, we can't accept any 
    // suggested media type that is not same as it
    if ( (NULL != m_pSuggestedMediaType) &&
         (!IsSameAMMediaType(pmt, m_pSuggestedMediaType)) )
    {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // copy media type and save the connector in m_pConnectedPin 
    CopyMediaType(&m_ConnectedMediaType, pmt);
    m_pConnectedPin = pConnector;

    // get time to delay samples
    GetTimingInfo(m_ConnectedMediaType);

    LOG((MSP_TRACE, "CMediaTerminalFilter::ReceiveConnection(%p, %p) succeeded",
        pConnector, pmt));
    return S_OK;
}

    
// the base class implementation doesn't validate the parameter
// validate the parameter and call base class
STDMETHODIMP
CMediaTerminalFilter::ConnectionMediaType(
    AM_MEDIA_TYPE *pmt
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::ConnectionMediaType(%p) called", pmt));
    BAIL_IF_NULL(pmt, E_POINTER);

    return CStream::ConnectionMediaType(pmt);
}


// should accept all media types which match the major type corresponding to the purpose id
STDMETHODIMP
CMediaTerminalFilter::QueryAccept(
    const AM_MEDIA_TYPE *pmt
    )
{
    AUTO_CRIT_LOCK;
    
    LOG((MSP_TRACE, "CMediaTerminalFilter::QueryAccept(%p) called", pmt));
    BAIL_IF_NULL(pmt, E_POINTER);
    BAIL_IF_NULL(m_pAmovieMajorType, MS_E_NOTINIT);

    // compare the filter major type with the queried AM_MEDIA_TYPE's major type
    if (0 != memcmp(&pmt->majortype, m_pAmovieMajorType, sizeof(GUID)))
        return S_FALSE;

    // if read side, return S_OK as we accepts any format
    // NOTE: FOR THE READ SIDE, QueryAccept is only called in SetFormat.
    // In ReceiveConnect, it checks against any user set properties 
    // directly instead of calling QueryAccept
    if (PINDIR_INPUT == m_Direction)    return S_OK;

    TM_ASSERT(NULL != pmt->pbFormat);
    if (NULL == pmt->pbFormat)
    {
        LOG((MSP_ERROR, "CMediaTerminalFilter::QueryAccept(%p) - returning S_FALSE, \
                pbFormat = NULL", 
                pmt));
        return S_FALSE;
    }

    if (m_bIsAudio)
    {
        // if not the acceptable media type, return error
        TM_ASSERT(FORMAT_WaveFormatEx == pmt->formattype);
        if (FORMAT_WaveFormatEx != pmt->formattype)
        {
            LOG((MSP_ERROR, "CMediaTerminalFilter::QueryAccept(%p) - returning S_FALSE, \
                    audio format is not WaveFormatEx", 
                    pmt));
            return S_FALSE;
        }

        if (0 == ((WAVEFORMATEX *)pmt->pbFormat)->nAvgBytesPerSec)
        {
            LOG((MSP_ERROR, "CMediaTerminalFilter::QueryAccept(%p) - returning S_FALSE, \
                    nAvgBytesPerSec = 0", 
                    pmt));
            return S_FALSE;
        }
    }
    else
    {
        TM_ASSERT(MSPID_PrimaryVideo == m_PurposeId);

        TM_ASSERT(FORMAT_VideoInfo == pmt->formattype);
        if (FORMAT_VideoInfo != pmt->formattype)
        {
            LOG((MSP_ERROR, "CMediaTerminalFilter::QueryAccept(%p) - returning S_FALSE, \
                    video format is not VideoInfo", 
                    pmt));
            return S_FALSE;
        }


        TM_ASSERT(0 != ((VIDEOINFO *)pmt->pbFormat)->AvgTimePerFrame);
        if (0 == ((VIDEOINFO *)pmt->pbFormat)->AvgTimePerFrame)    
        {
            LOG((MSP_ERROR, "CMediaTerminalFilter::QueryAccept(%p) - returning S_FALSE, \
                    AvgTimePerFrame = 0", 
                    pmt));
            return S_FALSE;
        }
    }

    LOG((MSP_TRACE, "CMediaTerminalFilter::QueryAccept(%p) succeeded", pmt));
    return S_OK;
}


// CStream doesn't reset the end of stream flag, so over-ride
STDMETHODIMP 
CMediaTerminalFilter::Disconnect(
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::Disconnect[%p] - enter", this));


    Lock();


    m_bEndOfStream = false; // this is a bool value

    //
    // If the MSP suggested allocator properties, then those
    // are never touched.
    // If the user has provided the allocator properties, then
    // reset modified allocator properties to the user's values.
    // If the user hasn't provided the allocator properties
    // reset modified allocator properties to default values.
    //

    if ( ! m_bSuggestedAllocProps )
    {
        if ( m_bUserAllocProps )
        {
            m_AllocProps = m_UserAllocProps;
        }
        else
        {
            SetDefaultAllocatorProperties();
        }
    }


    HRESULT hr = CStream::Disconnect();

    Unlock();
    
    LOG((MSP_(hr), "CMediaTerminalFilter::Disconnect- finish. hr = %lx", hr));

    return hr;
}

// if the ds queries us for our preferred media types 
// - we return the user suggested media type (suggested in SetFormat) if
// there is one
HRESULT 
CMediaTerminalFilter::GetMediaType(
    ULONG Index, 
    AM_MEDIA_TYPE **ppMediaType
    )
{
    LOG((MSP_TRACE, 
        "CMediaTerminalFilter::GetMediaType(%u, %p) called", 
        Index, ppMediaType));

    // we can have atmost one user suggested media type
    if (0 != Index)
    {
        LOG((MSP_ERROR, 
            "CMediaTerminalFilter::GetMediaType(%u, %p) - invalid index,\
            returning S_FALSE", 
            Index, ppMediaType));
        return S_FALSE;
    }

    
    //
    // ppMediaType must point to a pointer to AM_MEDIA_TYPE
    //

    if (TM_IsBadWritePtr(ppMediaType, sizeof(AM_MEDIA_TYPE *)))
    {
        LOG((MSP_ERROR, 
            "CMediaTerminalFilter::GetMediaType(%u, %p) - bad input pointer "
            "returning E_POINTER", Index, ppMediaType));

        return E_POINTER;
    }

    AUTO_CRIT_LOCK;

    // if no user suggested media type, return error
    if (NULL == m_pSuggestedMediaType)
    {
        LOG((MSP_ERROR, 
            "CMediaTerminalFilter::GetMediaType(%u, %p) - \
            no suggested media type, returning S_FALSE", 
            Index, ppMediaType));
        return S_FALSE;
    }

    // copy the user suggested media type into the passed in ppMediaType
    // create media type if necessary
    TM_ASSERT(NULL != m_pSuggestedMediaType);

    // creates an am media type initialized with the pmt value
    *ppMediaType = CreateMediaType(m_pSuggestedMediaType);
    BAIL_IF_NULL(*ppMediaType, E_OUTOFMEMORY);

    LOG((MSP_TRACE, 
        "CMediaTerminalFilter::GetMediaType(%u, %p) succeeded", 
        Index, ppMediaType));
    return S_OK;
}


HRESULT 
CMediaTerminalFilter::AddToPoolIfCommitted(
    IN  CSample *pSample
    )
{
    TM_ASSERT(NULL != pSample);

    AUTO_CRIT_LOCK;

    // check if committed
    if (!m_bCommitted)  return VFW_E_NOT_COMMITTED;

    // addref the sample and
    // call AddSampleToFreePool
    pSample->AddRef();
    AddSampleToFreePool(pSample);

    // we must have atleast one item in our queue
    TM_ASSERT(m_pFirstFree != NULL);
    return S_OK;
}


// first check if this sample is the one being fragmented currently, then
// check the free pool
BOOL 
CMediaTerminalFilter::StealSample(
    IN CSample *pSample
    )
{
    LOG((MSP_TRACE, "CMediaTerminalFilter::StealSample(%p) called",
        pSample));

    BOOL bWorked = FALSE;
    AUTO_CRIT_LOCK;

    // if not committed, do nothing
    if ( !m_bCommitted )
    {
        LOG((MSP_TRACE, "CMediaTerminalFilter::StealSample(%p) \
                not committed - can't find sample", pSample));
        return FALSE;
    }

    if (pSample == m_pSampleBeingFragmented)
    {
        // abort the sample when the last refcnt to its internal
        // IMediaStream is released
        m_pSampleBeingFragmented->AbortDuringFragmentation();
        ((IStreamSample *)m_pSampleBeingFragmented)->Release();
        m_pSampleBeingFragmented = NULL;

        LOG((MSP_TRACE, "CMediaTerminalFilter::StealSample(%p) \
                was being fragmented - aborting", pSample));

        // the caller wants to abort this sample immediately. since
        // we must wait for the last refcnt on IMediaStream to be released
        // tell the caller that the sample was not found
        return FALSE;
    }

    if (m_pFirstFree) 
    {
        if (m_pFirstFree == pSample) 
        {
            m_pFirstFree = pSample->m_pNextFree;
            if (m_pFirstFree)   m_pFirstFree->m_pPrevFree = NULL;
            else                m_pLastFree = NULL;

            pSample->m_pNextFree = NULL;    // We know the prev ptr is already null!
            TM_ASSERT(pSample->m_pPrevFree == NULL);
            bWorked = TRUE;
        } 
        else 
        {
            if (pSample->m_pPrevFree) 
            {
                pSample->m_pPrevFree->m_pNextFree = pSample->m_pNextFree;
                if (pSample->m_pNextFree) 
                    pSample->m_pNextFree->m_pPrevFree = pSample->m_pPrevFree;
                else 
                    m_pLastFree = pSample->m_pPrevFree;

                pSample->m_pNextFree = pSample->m_pPrevFree = NULL;
                bWorked = TRUE;
            }
        }
        CHECKSAMPLELIST
    }

    LOG((MSP_TRACE, "CMediaTerminalFilter::StealSample(%p) returns %d",
        pSample, bWorked));

    return bWorked;
}


// sets the time to delay - per byte for audio, per frame for video
void 
CMediaTerminalFilter::GetTimingInfo(
    IN const AM_MEDIA_TYPE &MediaType
    )
{
    AUTO_CRIT_LOCK;

    if (m_bIsAudio)
    {
        // assert if not an audio format
        TM_ASSERT(FORMAT_WaveFormatEx == MediaType.formattype);
        TM_ASSERT(NULL != MediaType.pbFormat);

        // number of milliseconds to delay per byte
        m_AudioDelayPerByte = 
          DOUBLE(1000)/((WAVEFORMATEX *)MediaType.pbFormat)->nAvgBytesPerSec;
    }
    else
    {
        TM_ASSERT(MSPID_PrimaryVideo == m_PurposeId);
        TM_ASSERT(FORMAT_VideoInfo == MediaType.formattype);

        // number of milliseconds to delay per frame
        // AvgTimePerFrame is in 100ns units - convert to milliseconds
        m_VideoDelayPerFrame = 
          DWORD(10000*((VIDEOINFO *)MediaType.pbFormat)->AvgTimePerFrame);
    }
}

void 
CMediaTerminalFilter::SetDefaultAllocatorProperties(
    )
{
    m_AllocProps.cbBuffer   = DEFAULT_AM_MST_SAMPLE_SIZE;
    m_AllocProps.cBuffers   = DEFAULT_AM_MST_NUM_BUFFERS;
    m_AllocProps.cbAlign    = DEFAULT_AM_MST_BUFFER_ALIGNMENT;
    m_AllocProps.cbPrefix   = DEFAULT_AM_MST_BUFFER_PREFIX;
}



// CTMStreamSample

// calls InitSample(pStream, bIsInternalSample)
// sets member variables
HRESULT 
CTMStreamSample::Init(
    CStream &Stream, 
    bool    bIsInternalSample,
    PBYTE   pBuffer,
    LONG    BufferSize
    )
{
    LOG((MSP_TRACE, "CTMStreamSample::Init(&%p, %d, %p, %d) called",
        &Stream, bIsInternalSample, pBuffer, BufferSize));

    TM_ASSERT(NULL == m_pBuffer);

    HRESULT hr;
    hr = InitSample(&Stream, bIsInternalSample);
    BAIL_ON_FAILURE(hr);

    m_BufferSize = BufferSize;
    m_pBuffer = pBuffer;

    LOG((MSP_TRACE, "CTMStreamSample::Init(&%p, %d, %p, %d) succeeded",
        &Stream, bIsInternalSample, pBuffer, BufferSize));
    return S_OK;
}



void 
CTMStreamSample::CopyFrom(
    IMediaSample *pSrcMediaSample
    )
{
    m_bModified = true;
    HRESULT HResult = pSrcMediaSample->GetTime(
                        &m_pMediaSample->m_rtStartTime, 
                        &m_pMediaSample->m_rtEndTime
                        );
    m_pMediaSample->m_dwFlags = (!HRESULT_FAILURE(HResult)) ?
                                AM_SAMPLE_TIMEVALID | AM_SAMPLE_STOPVALID : 
                                0;

    m_pMediaSample->m_dwFlags |= (pSrcMediaSample->IsSyncPoint() == S_OK) ? 
                                0 : AM_GBF_NOTASYNCPOINT;
    m_pMediaSample->m_dwFlags |= (pSrcMediaSample->IsDiscontinuity() == S_OK) ? 
                                AM_GBF_PREVFRAMESKIPPED : 0;
    m_pMediaSample->m_bIsPreroll = (pSrcMediaSample->IsPreroll() == S_OK);
}


// calls CTMStreamSample::Init, sets members
HRESULT 
CQueueMediaSample::Init(
    IN CStream                   &Stream, 
    IN CNBQueue<CQueueMediaSample> &Queue
    )
{
    m_pSampleQueue = &Queue;
    return CTMStreamSample::Init(Stream, TRUE, NULL, 0);
}


// this is used to hold a ptr to a segment of a user sample buffer
// it also holds a reference to the user sample's IMediaSample i/f and
// releases it when done
void 
CQueueMediaSample::HoldFragment(
    IN DWORD        FragSize,
    IN BYTE         *pbData,
    IN IMediaSample &FragMediaSample
    )
{
    LOG((MSP_TRACE, 
            "CQueueMediaSample::HoldFragment(%u, %p, &%p) called",
            FragSize, pbData, &FragMediaSample));

    AUTO_SAMPLE_LOCK;

    TM_ASSERT(0 < (LONG) FragSize);
    TM_ASSERT(NULL != pbData);

    //
    // set media sample properties
    // timestamp is set by the CMediaTerminalFilter
    //

    m_pMediaSample->m_dwFlags = 0;
    m_bReceived = FALSE;
    m_bModified = TRUE;

    SetBufferInfo(FragSize,     // buffer size
                  pbData,       // pointer to buffer
                  FragSize      // amount of buffer currently used
                  );

    // ref to the user sample's media sample
    // NOTE: m_pFragMediaSample is a CComPtr

    m_pFragMediaSample = &FragMediaSample;

    LOG((MSP_TRACE, 
            "CQueueMediaSample::HoldFragment(%u, %p, &%p) succeeded",
            FragSize, pbData, &FragMediaSample));
}


void 
CQueueMediaSample::FinalMediaSampleRelease(
    )
{
    LOG((MSP_TRACE, "CQueueMediaSample::FinalMediaSampleRelease[%p] - enter", this));

    // NOTE : no one holds a reference to the media sample at this point
    LOCK_SAMPLE;

    // if we hold a reference to the IMediaSample i/f of a user sample
    // being fragmented, release it
    // NOTE: m_pFragMediaSample is a CComPtr

    if (m_pFragMediaSample != NULL) m_pFragMediaSample = NULL;

    // check if the stream is still committed, otherwise destroy self
    if ( m_pStream->m_bCommitted )
    {
        BOOL bNQSuccess = m_pSampleQueue->EnQueue(this);
        UNLOCK_SAMPLE;

        //
        // if failed to enqueue -- kill itself, no one cares.
        //

        if (!bNQSuccess)
        {
            LOG((MSP_WARN,
                "CQueueMediaSample::FinalMediaSampleRelease - failed to enqueue. delete this"));
            delete this;
        }

    }
    else
    {
        // this is in case the stream has already been decommitted
        UNLOCK_SAMPLE;
        delete this;

        LOG((MSP_WARN,
            "CQueueMediaSample::FinalMediaSampleRelease - stream not committed. delete this"));
    }

    LOG((MSP_TRACE, "CQueueMediaSample::FinalMediaSampleRelease succeeded"));
}

#if DBG

// virtual
CQueueMediaSample::~CQueueMediaSample(
    )
{
}

#endif // DBG

// if asked to allocate buffers, verify allocator properties
/* static */ 
BOOL 
CUserMediaSample::VerifyAllocatorProperties(
    IN BOOL                         bAllocateBuffers,
    IN const ALLOCATOR_PROPERTIES   &AllocProps
    )
{
    if (!bAllocateBuffers)  return TRUE;

    if (0 != AllocProps.cbPrefix) return FALSE;

    if (0 == AllocProps.cbAlign) return FALSE;

    return TRUE;
}

// this is called in AllocateSample (creates an instance and initializes it)
// creates a data buffer if none is provided (current behaviour)
// also calls CTMStreamSample::InitSample(pStream, bIsInternalSample)
HRESULT 
CUserMediaSample::Init(
    IN CStream                      &Stream, 
    IN BOOL                         bAllocateBuffer,
    IN DWORD                        ReqdBufferSize,
    IN const ALLOCATOR_PROPERTIES   &AllocProps
    )
{
    LOG((MSP_TRACE, "CUserMediaSample::Init[%p](&%p, %u, &%p) called",
        this, &Stream, bAllocateBuffer, &AllocProps));

    TM_ASSERT(VerifyAllocatorProperties(bAllocateBuffer, AllocProps));

    TM_ASSERT(FALSE == m_bWeAllocatedBuffer);
    TM_ASSERT(NULL == m_pBuffer);

    HRESULT hr;
    hr = CTMStreamSample::InitSample(&Stream, FALSE);
    BAIL_ON_FAILURE(hr);

    // the caller wants us to create the buffer
    if (bAllocateBuffer)
    {
        // determine size of buffer to allocate
        // we use the user suggested buffer size (if not 0), else
        // we use the negotiated allocator properties' buffer size
        m_BufferSize = 
            (0 != ReqdBufferSize) ? ReqdBufferSize : AllocProps.cbBuffer;

        LOG((MSP_TRACE, 
            "CUserMediaSample::Init creating buffer buffersize[%d]", 
            m_BufferSize));

        m_pBuffer = new BYTE[m_BufferSize];
        BAIL_IF_NULL(m_pBuffer, E_OUTOFMEMORY);

        m_bWeAllocatedBuffer = TRUE;
    }
    else    // the user will provide the buffer later
    {
        
        //
        // the user will need to submit buffers of at least this size -- filter
        // promised this during allocator properties negotiation
        //
        
        m_dwRequiredBufferSize = AllocProps.cbBuffer;

        LOG((MSP_TRACE, 
            "CUserMediaSample::Init -- the app will need to provide buffers of size 0x%lx",
            m_dwRequiredBufferSize));

        m_BufferSize = 0;
        m_pBuffer = NULL;

        TM_ASSERT(!m_bWeAllocatedBuffer);
    }

    TM_ASSERT(0 == m_DataSize);

    LOG((MSP_TRACE, "CUserMediaSample::Init(&%p, %u, &%p) succeeded",
        &Stream, bAllocateBuffer, &AllocProps));
    return S_OK;
}


void 
CUserMediaSample::BeginFragment(
    IN BOOL    bNoteCurrentTime
    )
{
    LOG((MSP_TRACE, 
        "CUserMediaSample::BeginFragment (frag=%p)", this));

    AUTO_SAMPLE_LOCK;

    // we are being fragmented
    m_bBeingFragmented = TRUE;

    // note current time
    if (bNoteCurrentTime)    m_BeginFragmentTime = timeGetTime();

    // nothing has been fragmented yet
    m_NumBytesFragmented = 0;

    // increment refcnt to the internal media sample. this ensures that
    // FinalMediaSampleRelease is not called until the last fragment is
    // completed
    m_pMediaSample->AddRef();

    // increment refcnt to self. this ensures that we'll exist while 
    // the last fragment has not returned
    ((IStreamSample *)this)->AddRef();
}

//////////////////////////////////////////////////////////////////////////////
//
// Fragment
//
// For write -- Assigns a chunk of this user media sample to an outgoing
// sample in the filter graph, a CQueueMediaSample. The data is not actually
// copied; instead, CQeueMediaSample::HoldFragment is called to set the pointers
// to the appropriate pointer of the user media sample.
//

void 
CUserMediaSample::Fragment(
    IN      BOOL                bFragment,         // actually fragment? false if video
    IN      LONG                AllocBufferSize,   // max amount of data to copy
    IN OUT  CQueueMediaSample   &QueueMediaSample, // destination sample
    OUT     BOOL                &bDone             // out: set to true if no data left in source
    )
{
    LOG((MSP_TRACE, 
        "CUserMediaSample::Fragment(%u, %l, &%p, &%p) called (frag=%p)", 
        bFragment, AllocBufferSize, &QueueMediaSample, &bDone, this));

    AUTO_SAMPLE_LOCK;

    TM_ASSERT(m_bBeingFragmented);
    TM_ASSERT(m_NumBytesFragmented < m_DataSize);

    //
    // DestSize = amount of data we are actually going to copy
    //

    LONG DestSize;
    if (bFragment)
    {
        DestSize = min(AllocBufferSize, m_DataSize - m_NumBytesFragmented);
    }
    else
    {
        TM_ASSERT(0 == m_NumBytesFragmented);
        DestSize = m_DataSize;
    }

    //
    // pass the fragment to the queue sample
    //

    QueueMediaSample.HoldFragment(
            DestSize,
            m_pBuffer + m_NumBytesFragmented,
            *m_pMediaSample
        );

    //
    // increment number of bytes fragmented
    //

    m_NumBytesFragmented += DestSize;

    //
    // let the caller know if we are done with fragmenting our buffer
    //

    bDone = ((m_NumBytesFragmented >= m_DataSize) ? TRUE : FALSE);
    
    //
    // if we are done, we should release our reference to the internal
    // IMediaSample instance. this was acquired when BeginFragment was called
    //

    if (bDone)  
    {
        m_bReceived = TRUE; // needed for FinalMediaSampleRelease
        m_pMediaSample->Release();
    }

    LOG((MSP_TRACE, 
        "CUserMediaSample::Fragment(%u, %l, &%p, &%p) succeeded (frag=%p)", 
        bFragment, AllocBufferSize, &QueueMediaSample, &bDone, this));
}


//////////////////////////////////////////////////////////////////////////////
//
// CopyFragment
//
// For write -- copies a chunk of this user media sample to an outgoing
// sample in the filter graph. This is for when we are using a downstream
// allocator.
//

HRESULT
CUserMediaSample::CopyFragment(
    IN      BOOL           bFragment,         // actually fragment? false if video
    IN      LONG           AllocBufferSize,   // max amount of data to copy
    IN OUT  IMediaSample * pDestMediaSample,  // destination sample
    OUT     BOOL         & bDone              // out: set to true if no data left in source
    )
{
    LOG((MSP_TRACE, 
        "CUserMediaSample::CopyFragment(%u, %ld, &%p, &%p) called (frag=%p)", 
        bFragment, AllocBufferSize, &pDestMediaSample, &bDone, this));

    AUTO_SAMPLE_LOCK;

    TM_ASSERT(m_bBeingFragmented);
    TM_ASSERT(m_NumBytesFragmented < m_DataSize);

    //
    // DestSize = amount of data we are actually going to copy
    //
    // IMediaSmaple::GetSize has a weird prototype -- returns HRESULT
    // but it's actually just the size as a LONG
    //

    LONG lDestSize;

    if ( bFragment )
    {
        //
        // We copy as much as we have left to copy or as much as will fit in
        // a sample, whichever is less.
        //

        lDestSize = min( AllocBufferSize, m_DataSize - m_NumBytesFragmented );

        //
        // If the sample has less space than the allocator propeties said it
        // would have, then trim lDestSize to that value. We don't just use
        // pDestMediaSample->GetSize() instead of AllocBufferSize above because
        // we want to use the allocator properties size if the sample has *more*
        // space than the allocator properties specify.
        //

        lDestSize = min( pDestMediaSample->GetSize(), lDestSize );
    }
    else
    {
        // video case -- copy entire sample
        // we bail if the destination sample isn't big enough

        TM_ASSERT(0 == m_NumBytesFragmented);
        lDestSize = m_DataSize;

        if ( ( lDestSize > AllocBufferSize ) ||
             ( lDestSize > pDestMediaSample->GetSize() ) )
        {
            return VFW_E_BUFFER_OVERFLOW;
        }
    }

    //
    // copy the fragment to the destination sample
    // instead of CQUeueMediaSample::HoldFragment
    //

    HRESULT hr;


    BYTE * pDestBuffer;

    hr = pDestMediaSample->GetPointer( & pDestBuffer );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CopyMemory(
        pDestBuffer,                       // destination buffer
        m_pBuffer + m_NumBytesFragmented,  // source buffer
        lDestSize
        );
    
    hr = pDestMediaSample->SetActualDataLength( lDestSize );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // increment number of bytes fragmented
    //

    m_NumBytesFragmented += lDestSize;

    //
    // let the caller know if we are done with fragmenting our buffer
    //

    bDone = ((m_NumBytesFragmented >= m_DataSize) ? TRUE : FALSE);
    
    //
    // if we are done, we should release our reference to the internal
    // IMediaSample instance. this was acquired when BeginFragment was called
    //

    if (bDone)  
    {
        m_bReceived = TRUE; // needed for FinalMediaSampleRelease
        m_pMediaSample->Release();
    }

    LOG((MSP_TRACE, 
        "CUserMediaSample::CopyFragment(%u, %ld, &%p, &%p) succeeded (frag=%p)", 
        bFragment, AllocBufferSize, &pDestMediaSample, &bDone, this));

    return S_OK;
}

// computes the time to wait. it checks the time at which the first
// byte of the current fragment would be due and subtracts the
// time delay since the beginning of fragmentation 
DWORD
CUserMediaSample::GetTimeToWait(
    IN DOUBLE DelayPerByte
    )
{
    LOG((MSP_TRACE, 
        "CUserMediaSample::GetTimeToWait(%f) called", 
        DelayPerByte));

    // get current time
    DWORD CurrentTime = timeGetTime();

    AUTO_SAMPLE_LOCK;

    // calculate the time elapsed since BeginFragment was called,
    // account for wrap around
    DWORD TimeSinceBeginFragment = 
             (CurrentTime >= m_BeginFragmentTime) ? 
                 (CurrentTime - m_BeginFragmentTime) :
                 (DWORD(-1) - m_BeginFragmentTime + CurrentTime);

    DWORD DueTime = DWORD(m_NumBytesFragmented*DelayPerByte);

    LOG((MSP_INFO,
        "DueTime = %u, TimeSinceBeginFragment = %u",
        DueTime, TimeSinceBeginFragment));

    // if due in future, return the difference, else return 0
    DWORD TimeToWait;
    if (DueTime > TimeSinceBeginFragment) 
        TimeToWait = DueTime - TimeSinceBeginFragment;
    else
        TimeToWait = 0;

    LOG((MSP_INFO,
        "CUserMediaSample::GetTimeToWait(%f) returns %u successfully", 
        DelayPerByte, TimeToWait));

    return TimeToWait;
}

// when we are decommitted/aborted while being fragmented, we
// need to get rid of our refcnt on internal IMediaSample and set
// the error code to E_ABORT. this will be signaled to the user only when
// the last refcnt on IMediaSample is released (possibly by an outstanding
// queue sample)
void 
CUserMediaSample::AbortDuringFragmentation(
    )
{
    LOG((MSP_TRACE, 
        "CUserMediaSample::AbortDuringFragmentation (frag=%p)", this));

    AUTO_SAMPLE_LOCK;

    TM_ASSERT(m_bBeingFragmented);
    m_MediaSampleIoStatus = E_ABORT;

    // release reference on internal IMediaSample instance
    // this was acquired when BeginFragment was called
    m_pMediaSample->Release();
}


STDMETHODIMP 
CUserMediaSample::SetBuffer(
    IN  DWORD cbSize,
    IN  BYTE * pbData,
    IN  DWORD dwFlags
    )
{
    LOG((MSP_TRACE, "CUserMediaSample::SetBuffer[%p](%lu, %p, %lu) called",
        this, cbSize, pbData, dwFlags));

    if (dwFlags != 0 || cbSize == 0) 
    {
        return E_INVALIDARG;
    }


    // cannot accept a positive value that doesn't fit in a LONG
    // currently (based upon CSample implementation)
    if ((LONG)cbSize < 0)   
    {
        LOG((MSP_WARN, 
            "CUserMediaSample::SetBuffer - the buffer is too large. "
            "returning E_FAIL"));

        return E_FAIL;
    }


    // cannot accept null data buffer

    //
    // we don't want to do IsBadWritePtr here as this method could be called 
    // on every sample, so veryfying the memory could be expensive
    //

    if (NULL == pbData) 
    {
        LOG((MSP_WARN, 
            "CUserMediaSample::SetBuffer - buffer pointer is NULL "
            "returning E_POINTER"));
        
        return E_POINTER;
    }


    //
    // the app needs to give us at least as much memory as we have promised to
    // other filters in the graph (this number was specified when the sample was
    // created and initialized). 
    //
    // if we don't do this check, a downstream filter may av because it expects 
    // a bigger buffer.
    // 

    if ( m_dwRequiredBufferSize > cbSize )
    {
        LOG((MSP_WARN, 
            "CUserMediaSample::SetBuffer - the app did not allocate enough memory "
            "Need 0x%lx bytes, app allocated 0x%lx. returning TAPI_E_NOTENOUGHMEMORY",
            m_dwRequiredBufferSize, cbSize));

        return TAPI_E_NOTENOUGHMEMORY;
    }


    AUTO_SAMPLE_LOCK;

    //  Free anything we allocated ourselves 
    // -- We allow multiple calls to this method
    if (m_bWeAllocatedBuffer) 
    {
        delete m_pBuffer;
        m_bWeAllocatedBuffer = FALSE;
        m_pBuffer = NULL;
    }
        
    m_BufferSize = cbSize;
    m_DataSize = 0;
    m_pBuffer = pbData;
        
    LOG((MSP_TRACE, "CUserMediaSample::SetBuffer(%u, %p, %u) succeeded",
        cbSize, pbData, dwFlags));
    return S_OK;
}



STDMETHODIMP 
CUserMediaSample::GetInfo(
    OUT  DWORD *pdwLength,
    OUT  BYTE **ppbData,
    OUT  DWORD *pcbActualData
    )
{
    AUTO_SAMPLE_LOCK;
    
    LOG((MSP_TRACE, "CUserMediaSample::GetInfo(%p, %p, %p) called",
        pdwLength, ppbData, pcbActualData));

    
    if (m_BufferSize == 0) 
    {
        LOG((MSP_WARN, "CUserMediaSample::GetInfo - sample not initialized"));

        return MS_E_NOTINIT;
    }
        
    if (NULL != pdwLength) 
    {
        LOG((MSP_TRACE,
            "CUserMediaSample::GetInfo - pdwLength is not NULL."));

        *pdwLength = m_BufferSize;
    }

    if (NULL != ppbData) 
    {
        LOG((MSP_TRACE,
            "CUserMediaSample::GetInfo - ppbData is not NULL."));

        *ppbData = m_pBuffer;
    }
        
    if (NULL != pcbActualData) 
    {
        LOG((MSP_TRACE,
            "CUserMediaSample::GetInfo - pcbActualData is not NULL."));

        *pcbActualData = m_DataSize;
    }
        
    
    LOG((MSP_TRACE, 
        "CUserMediaSample::GetInfo - succeeded. "
        "m_BufferSize[%lu(decimal)] m_pBuffer[%p] m_DataSize[%lx]", 
        m_BufferSize, m_pBuffer, m_DataSize));

    return S_OK;
}


STDMETHODIMP 
CUserMediaSample::SetActual(
    IN  DWORD cbDataValid
    )
{
    AUTO_SAMPLE_LOCK;
    
    LOG((MSP_TRACE, "CUserMediaSample::SetActual(%u) called", cbDataValid));

    // cannot accept a positive value that doesn't fit in a LONG
    // currently (based upon CSample implementation)
    if ((LONG)cbDataValid < 0)  return E_FAIL;

    if ((LONG)cbDataValid > m_BufferSize) return E_INVALIDARG;
        
    m_DataSize = cbDataValid;

    LOG((MSP_TRACE, "CUserMediaSample::SetActual(%u) succeeded", cbDataValid));
    return S_OK;
}


// redirects this call to ((CMediaTerminalFilter *)m_pStream)
STDMETHODIMP 
CUserMediaSample::get_MediaFormat(
    /* [optional]??? */ OUT AM_MEDIA_TYPE **ppFormat
    )
{
    AUTO_SAMPLE_LOCK;
    
    LOG((MSP_TRACE, "CUserMediaSample::get_MediaFormat(%p) called", ppFormat));

    return ((CMediaTerminalFilter *)m_pStream)->GetFormat(ppFormat);
}


// this is not allowed
STDMETHODIMP 
CUserMediaSample::put_MediaFormat(
        IN  const AM_MEDIA_TYPE *pFormat
    )
{
    AUTO_SAMPLE_LOCK;
    
    LOG((MSP_TRACE, "CUserMediaSample::put_MediaFormat(%p) called", pFormat));

    return E_NOTIMPL;
}

// calls the base class FinalMediaSampleRelease and then releases
// self refcnt. this self refcnt ensures that when this method is
// called, the sample still exists
void
CUserMediaSample::FinalMediaSampleRelease(
    )
{
    AUTO_SAMPLE_LOCK;
    
    // this signals the user that the sample has completed
    CTMStreamSample::FinalMediaSampleRelease();

    // release self reference if we are being fragmented
    // this is only needed to ensure that we exist when the last 
    // reference to the internal IMediaSample interface is released
    if (m_bBeingFragmented)    m_bBeingFragmented = FALSE;

    // this self reference was obtained when
    // when fragmentation began (for write side) or 
    // when the sample refcnt was not released on removal from pool in
    // GetBuffer (for read side)
    // NOTE: the sample may go away after this release
    ((IStreamSample *)this)->Release();
}


HRESULT 
CUserMediaSample::CopyFrom(
    IN IMediaSample *pSrcMediaSample
    )
{
    LOG((MSP_TRACE, "CUserMediaSample::CopyFrom(%p) called", pSrcMediaSample));

    AUTO_SAMPLE_LOCK;

    TM_ASSERT(NULL != m_pBuffer);

    // sets the "non-data" member values
    CTMStreamSample::CopyFrom(pSrcMediaSample);

    // get the buffer ptr
    BYTE *pBuffer;
    HRESULT hr;
    hr = pSrcMediaSample->GetPointer(&pBuffer);
    BAIL_ON_FAILURE(hr);
    TM_ASSERT(NULL != pBuffer);

    // determine the number of bytes to copy
    LONG lDataSize = pSrcMediaSample->GetActualDataLength();
    TM_ASSERT(0 <= lDataSize);
    if (0 > lDataSize)  return E_FAIL;

    if (lDataSize > m_BufferSize) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        lDataSize = m_BufferSize;
    }
        
    // copy data and set the data size to the number of bytes copied
    memcpy(m_pBuffer, pBuffer, lDataSize);
    m_DataSize = lDataSize;

    LOG((MSP_TRACE, "CUserMediaSample::CopyFrom(%p) returns hr=%u", 
        pSrcMediaSample, hr));

    // we may return ERROR_MORE_DATA after copying the buffer, so return hr
    return hr;
}


// copies the non-data members of pSrcMediaSample
// copies as much as possible of the data buffer into own buffer
// and advances pBuffer and DataLength beyond the copied data
HRESULT 
CUserMediaSample::CopyFrom(
    IN        IMediaSample    *pSrcMediaSample,
    IN OUT    BYTE            *&pBuffer,
    IN OUT    LONG            &DataLength
    )
{
    LOG((MSP_TRACE, 
        "CUserMediaSample::CopyFrom(%p, &%p, &%l) called", 
        pSrcMediaSample, pBuffer, DataLength));

    if (NULL == pBuffer) return E_FAIL;
    if (0 > DataLength)  return E_FAIL;

    AUTO_SAMPLE_LOCK;

    TM_ASSERT(NULL != m_pBuffer);
    TM_ASSERT(NULL != pBuffer);
    TM_ASSERT(0 <= DataLength);

    // sets the "non-data" member values
    CTMStreamSample::CopyFrom(pSrcMediaSample);

    HRESULT hr = S_OK;
    LONG lDataSize = DataLength;
    if (lDataSize > m_BufferSize) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        lDataSize = m_BufferSize;
    }
        
    // copy data and set the data size to the number of bytes copied
    memcpy(m_pBuffer, pBuffer, lDataSize);
    m_DataSize = lDataSize;

    // advance the parameters beyond the copied data
    pBuffer += lDataSize;
    DataLength -= lDataSize;

    LOG((MSP_TRACE, 
        "CUserMediaSample::CopyFrom(&%p, &%p, %l) returns hr=%u", 
        pSrcMediaSample, pBuffer, DataLength, hr));

    // we may return ERROR_MORE_DATA after copying the buffer, so return hr
    return hr;
}


// NOTE : This has been copied from the CSample base class because
// StealSampleFromFreePool doesn't Release the ref count on the stolen
// sample
// in this implementation, we have made sure that each sample in the 
// CStream free pool has a refcnt increase. therefore, we need to decrease
// it if stealing is successful. Moreover, we also try to steal the 
// sample being fragmented currently although its not in the free pool
STDMETHODIMP 
CUserMediaSample::CompletionStatus(DWORD dwFlags, DWORD dwMilliseconds)
{
    LOG((MSP_TRACE, "CUserMediaSample::CompletionStatus(0x%8.8X, 0x%8.8X) called",
                   dwFlags, dwMilliseconds));
    LOCK_SAMPLE;
    HRESULT hr = m_Status;
    if (hr == MS_S_PENDING) {
        if (dwFlags & (COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT) ||
            (m_bContinuous && m_bModified && (dwFlags & COMPSTAT_WAIT))) {
                m_bContinuous = false;
                if (dwFlags & COMPSTAT_ABORT) {
                    m_bWantAbort = true;    // Set this so we won't add it back to the free pool if released
                }
                if (((CMediaTerminalFilter *)m_pStream)->StealSample(this)) {
                    UNLOCK_SAMPLE;
                    hr = SetCompletionStatus(m_bModified ? S_OK : MS_S_NOUPDATE);
                    ((IStreamSample *)this)->Release();
                    return hr;
                } // If doesn't work then return MS_S_PENDING unless we're told to wait!
            }
        if (dwFlags & COMPSTAT_WAIT) {
            m_bContinuous = false;  // Make sure it will complete!
            UNLOCK_SAMPLE;
            WaitForSingleObject(m_hCompletionEvent, dwMilliseconds);
            LOCK_SAMPLE;
            hr = m_Status;
        }
    }
    UNLOCK_SAMPLE;

    LOG((MSP_TRACE, "CUserMediaSample::CompletionStatus(0x%8.8X, 0x%8.8X) succeeded",
                   dwFlags, dwMilliseconds));    
    return hr;
}

// NOTE : This has been copied from the CSample base class
// because it calls m_pStream->AddSampleToFreePool to add sample
// to the CStream q. Since this shouldn't be happening after Decommit,
// m_pStream->AddSampleToFreePool has been replaced by another call
// m_pStream->AddToPoolIfCommitted that checks m_bCommitted and if 
// FALSE, returns error
//
//  Set the sample's status and signal completion if necessary.
//
//  Note that when the application has been signalled by whatever method
//  the application can immediately turn around on another thread
//  and Release() the sample.  This is most likely when the completion
//  status is set from the quartz thread that's pushing the data.
//
HRESULT 
CUserMediaSample::SetCompletionStatus(
    IN HRESULT hrStatus
    )
{
    LOCK_SAMPLE;
    TM_ASSERT(m_Status == MS_S_PENDING);
    if (hrStatus == MS_S_PENDING || (hrStatus == S_OK && m_bContinuous)) 
    {
        //
        // We are not done with the sample -- put it back in our pool so that
        // we can use it again.
        //

        HRESULT hr;
        hr = ((CMediaTerminalFilter *)m_pStream)->AddToPoolIfCommitted(this);
        
        // there is an error, so signal this to the user
        if (HRESULT_FAILURE(hr))    hrStatus = hr;
        else
        {
            UNLOCK_SAMPLE;
            return hrStatus;
        }
    } 

    //
    // The sample is ready to be returned to the app -- signal comletion.
    // We still have a lock.
    //

    HANDLE handle = m_hUserHandle;
    PAPCFUNC pfnAPC = m_UserAPC;
    DWORD_PTR dwptrAPCData = m_dwptrUserAPCData; // win64 fix
    m_hUserHandle = m_UserAPC = NULL;
    m_dwptrUserAPCData = 0;
    m_Status = hrStatus;
    HANDLE hCompletionEvent = m_hCompletionEvent;
    UNLOCK_SAMPLE;

    //  DANGER DANGER - sample can go away here
    SetEvent(hCompletionEvent);
    if (pfnAPC) {
        // queue the APC and close the targe thread handle
        // the calling thread handle was duplicated when Update 
        // was called
        QueueUserAPC(pfnAPC, handle, dwptrAPCData);
        CloseHandle(handle);
    } else {
        if (handle) {
            SetEvent(handle);
        }
    }

    return hrStatus;
}


// this method has been copied from the CSample implementation
// Now SetCompletionStatus returns an error code that can be failure
// this method didn't check for the error code and hence had to
// be over-ridden and modified to do so
// we must not reset user event as the user may pass in the same event for
// all samples
HRESULT 
CUserMediaSample::InternalUpdate(
    DWORD dwFlags,
    HANDLE hEvent,
    PAPCFUNC pfnAPC,
    DWORD_PTR dwptrAPCData
    )
{
    if ((hEvent && pfnAPC) || (dwFlags & (~(SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS)))) {
    return E_INVALIDARG;
    }
    if (m_Status == MS_S_PENDING) {
    return MS_E_BUSY;
    }

    // if we don't have a buffer to operate upon, return error
    if (NULL == m_pBuffer)  return E_FAIL;

    if (NULL != m_pStream->m_pMMStream) {
        STREAM_STATE StreamState;
        m_pStream->m_pMMStream->GetState(&StreamState);
        if (StreamState != STREAMSTATE_RUN) {
        return MS_E_NOTRUNNING;
    }
    }

    ResetEvent(m_hCompletionEvent);
    m_Status = MS_S_PENDING;
    m_bWantAbort = false;
    m_bModified = false;
    m_bContinuous = (dwFlags & SSUPDATE_CONTINUOUS) != 0;
    m_UserAPC = pfnAPC;

    TM_ASSERT(NULL == m_hUserHandle);
    if (pfnAPC) {
        BOOL bDuplicated = 
                DuplicateHandle(
                    GetCurrentProcess(),
                    GetCurrentThread(),
                    GetCurrentProcess(),
                    &m_hUserHandle,
                    0,                        // ignored
                    TRUE,
                    DUPLICATE_SAME_ACCESS 
                    );
        if (!bDuplicated) 
        {
            DWORD LastError = GetLastError();
            LOG((MSP_ERROR, "CUserMediaSample::InternalUpdate - \
                couldn't duplicate calling thread handle - error %u",
                LastError));
            return HRESULT_FROM_ERROR_CODE(LastError);
        }
        m_dwptrUserAPCData = dwptrAPCData;
    } else {
        m_hUserHandle = hEvent;
        // rajeevb - also used to reset the user provided event
        // this is not being done any more as the user may provide
        // the same event for more than one sample and we may reset
        // a signaled event
    }

    //
    //  If we're at the end of the stream, wait until this point before punting it
    //  because we need to signal the event or fire the APC.
    //
    if (m_pStream->m_bEndOfStream) {
        //  Because this is called synchronously from Update the
        //  application must have a ref count on the sample until we
        //  return so we don't have to worry about it going away here
        return SetCompletionStatus(MS_S_ENDOFSTREAM);
    }

    // rajeevb - need to check for SetCompletionStatus error code
    HRESULT hr;
    hr = SetCompletionStatus(MS_S_PENDING);   // This adds us to the free pool.
    BAIL_ON_FAILURE(hr);

    if (hEvent || pfnAPC || (dwFlags & SSUPDATE_ASYNC)) {
    return MS_S_PENDING;
    } else {
    return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\newmes.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __MEDIA_STREAM_TERMINAL__
#define __MEDIA_STREAM_TERMINAL__

//
// The CLSID that's used to create us.
//

EXTERN_C const CLSID CLSID_MediaStreamingTerminal_PRIVATE;

#ifdef INSTANTIATE_GUIDS_NOW

    // {AED6483F-3304-11d2-86F1-006008B0E5D2}
    const GUID CLSID_MediaStreamingTerminal_PRIVATE = 
    { 0xaed6483f, 0x3304, 0x11d2, { 0x86, 0xf1, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xd2 } };

#endif // INSTANTIATE_GUIDS_NOW

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// The terminal object itself
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// forward declaration for the class being aggregated by CMediaTerminal
class CMediaTerminalFilter;

class CMediaTerminal :
    public CComCoClass<CMediaTerminal, &CLSID_MediaStreamingTerminal_PRIVATE>,
    public CBaseTerminal,
    public ITPluggableTerminalInitialization,
    public ITAMMediaFormat,
    public IAMStreamConfig,
    public IAMBufferNegotiation,
    public CMSPObjectSafetyImpl
{    
public:
    // REMOVE THESE when we derive from CSingleFilterTerminal.

    STDMETHOD(RunRenderFilter) (void) { return E_NOTIMPL; }
    STDMETHOD(StopRenderFilter) (void) { return E_NOTIMPL; }

     virtual HRESULT GetNumExposedPins(
        IN   IGraphBuilder * pGraph,
        OUT  DWORD         * pdwNumPins
        );

     virtual HRESULT GetExposedPins(
        OUT    IPin  ** ppPins
        );

public:

BEGIN_COM_MAP(CMediaTerminal)
    COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
    COM_INTERFACE_ENTRY(ITAMMediaFormat)
    COM_INTERFACE_ENTRY(IAMStreamConfig)
    COM_INTERFACE_ENTRY(IAMBufferNegotiation)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CBaseTerminal)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pIUnkTerminalFilter.p)
END_COM_MAP()

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_REGISTRY_RESOURCEID(IDR_MediaStreamingTerminal)

    // set the member variables
    inline CMediaTerminal();

#ifdef DEBUG
    virtual ~CMediaTerminal();
#endif // DEBUG

    HRESULT FinalConstruct();

    void FinalRelease();

// ITPluggableTerminalInitialization
    STDMETHOD(InitializeDynamic) (
	        IN   IID                   iidTerminalClass,
	        IN   DWORD                 dwMediaType,
	        IN   TERMINAL_DIRECTION    Direction,
            IN   MSP_HANDLE            htAddress
            );

// IAMStreamConfig - this is for use by the filter graph end of the terminal
    // to configure the format and capture capabilities if relevant

    // the application is supposed to call DeleteMediaType(*ppmt) (on success)
    // implemented using the aggregated filter's public GetFormat method
    STDMETHOD(GetFormat)(
        OUT  AM_MEDIA_TYPE **ppmt
        );
    
    // implemented using the aggregated filter's public SetFormat method
    STDMETHOD(SetFormat)(
        IN  AM_MEDIA_TYPE *pmt
        );

    // IAMStreamConfig - Used by the MSP, queried from the output pin
    // if our pin is an input pin (we are a render MST) then these return VFW_E_INVALID_DIRECTION
    STDMETHOD(GetNumberOfCapabilities)(
            /*[out]*/ int *piCount,
            /*[out]*/ int *piSize
            // ); // pSCC of GetStreamC
            ) { return E_NOTIMPL; }

    STDMETHOD(GetStreamCaps)(
            /*[in]*/  int iIndex,   // 0 to #caps-1
            /*[out]*/ AM_MEDIA_TYPE **ppmt,
            /*[out]*/ BYTE *pSCC
            ) { return E_NOTIMPL; }


// IAMBufferNegotiation - these return E_NOTIMPL
    STDMETHOD(GetAllocatorProperties)(
        OUT  ALLOCATOR_PROPERTIES *pProperties
        );
    
    STDMETHOD(SuggestAllocatorProperties)(
        IN  const ALLOCATOR_PROPERTIES *pProperties
        );

// ITAMMediaFormat - the read/write user of the terminal uses this to
    // get and set the media format of the samples

    // since there is only one filter in this base class implementation (i.e. the two
    // ends of the terminal have the same media format), both of
    // the get and set methods are redirected to Get/Set Format

    STDMETHOD(get_MediaFormat)(
        OUT  AM_MEDIA_TYPE **ppFormat
        );

    STDMETHOD(put_MediaFormat)(
        IN  const AM_MEDIA_TYPE *pFormat
        );

protected:

    typedef CComAggObject<CMediaTerminalFilter> FILTER_COM_OBJECT;

    // we create an aggregated instance of this
    FILTER_COM_OBJECT   *m_pAggInstance;

    // ptr to the created media terminal filter
    CComContainedObject<CMediaTerminalFilter> *m_pAggTerminalFilter;

    // NOTE: m_pIUnkTerminalFilter, m_pOwnPin are references
    // to the media terminal filter that are obtained in 
    // FinalConstruct. The corresponding refcnts are released
    // immediately after obtaining the interfaces

    // IUnknown i/f of the aggregated media terminal filter
    CComPtr<IUnknown>   m_pIUnkTerminalFilter;

    // holds the pin exposed by the aggregated media terminal filter
    // this is returned in GetTerminalPin()
    // its a weak reference and shouldn't be a CComPtr
    IPin                *m_pOwnPin;

    // holds the IAMMediaStream i/f exposed by the aggregated media 
    // terminal filter
    // its a weak reference and shouldn't be a CComPtr
    IAMMediaStream      *m_pIAMMediaStream;

    // holds the internally created Media stream filter interface
    // needed in JoinFilter to compare the internally created filter with
    // the passed in filter to join
    CComPtr<IMediaStreamFilter> m_pICreatedMediaStreamFilter;

    // the base filter interface for the internally created media
    // stream filter
    CComPtr<IBaseFilter>    m_pBaseFilter;

    long m_lMediaType;

    // CBaseTerminal methods

    virtual HRESULT AddFiltersToGraph();

    virtual HRESULT RemoveFiltersFromGraph();

    virtual DWORD GetSupportedMediaTypes(void)
    {
        return (DWORD) (TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO) ;
    }

private:

    // used to implement other methods

    void SetMemberInfo(
        IN  DWORD           dwFriendlyName,
        IN  long            lMediaType
        );

    HRESULT SetNameInfo(
        IN  long                lMediaType,
        IN  TERMINAL_DIRECTION  TerminalDirection,
        OUT MSPID               &PurposeId,
        OUT STREAM_TYPE         &StreamType,
        OUT const GUID          *&pAmovieMajorType
        );

    // creates the media stream filter and adds own IAMMediaStream i/f to it
    HRESULT CreateAndJoinMediaStreamFilter();
};


// set the member variables
inline 
CMediaTerminal::CMediaTerminal(
    )
    : m_pAggInstance(NULL),
      m_pAggTerminalFilter(NULL),
      m_pIUnkTerminalFilter(NULL),
      m_pOwnPin(NULL),
      m_pIAMMediaStream(NULL),
      m_lMediaType(0)
{
}

#endif // __MEDIA_STREAM_TERMINAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\mtenum.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/


#include "stdafx.h"


CMediaTypeEnum::CMediaTypeEnum() :
    m_cCurrentPos(0),
    m_pStream(NULL)
{
}

void CMediaTypeEnum::Initialize(CStream *pStream, ULONG cCurPos)
{
    m_pStream = pStream;
    m_pStream->GetControllingUnknown()->AddRef();
    m_cCurrentPos = cCurPos;
}

CMediaTypeEnum::~CMediaTypeEnum()
{
    m_pStream->GetControllingUnknown()->Release();
}


STDMETHODIMP CMediaTypeEnum::Next(ULONG cNumToFetch, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched)
{
    if (pcFetched == NULL) {
        return E_POINTER;
    }
    HRESULT hr = S_OK;
    *pcFetched = 0;
    for (; cNumToFetch > 0; ) {
        if (S_OK == hr) {
            hr = m_pStream->GetMediaType(m_cCurrentPos, ppMediaTypes);
            if (S_OK != hr) {
                *ppMediaTypes = NULL;
            } else {
                m_cCurrentPos++;
                (*pcFetched)++;
            }
        }
        ppMediaTypes++;
        cNumToFetch--;
    }
    return hr;
}


STDMETHODIMP CMediaTypeEnum::Skip(ULONG cSkip)
{
    m_cCurrentPos += cSkip;
    return NOERROR;
}

STDMETHODIMP CMediaTypeEnum::Reset()
{
    m_cCurrentPos = 0;
    return NOERROR;
}

STDMETHODIMP CMediaTypeEnum::Clone(IEnumMediaTypes **ppEnumMediaTypes)
{
    HRESULT hr = S_OK;
    CMediaTypeEnum *pNewEnum = new CComObject<CMediaTypeEnum>; 
    if (pNewEnum == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
        pNewEnum->Initialize(m_pStream, m_cCurrentPos);
    }
    pNewEnum->GetControllingUnknown()->QueryInterface(IID_IEnumMediaTypes, (void **)ppEnumMediaTypes);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\ptreg.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ptreg.cpp

Abstract:

    Implementation of Plug-Terminal Registration classes.
--*/

#include "stdafx.h"
#include "PTReg.h"
#include "manager.h"
#include <atlwin.h>
#include <atlwin.cpp>


//
// CPlugTerminal class implementation
// Create free thread marshaler
//

HRESULT CPlugTerminal::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CPlugTerminal::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CPlugTerminal::FinalConstruct - exit S_OK"));

    return S_OK;

}

//
// CPlugTerminal class implementation
// --- ITPTRegTerminal interface ---
//

STDMETHODIMP CPlugTerminal::get_Name(
    /*[out, retval]*/ BSTR*     pName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_Name - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pName, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Name exit -"
            "pName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_Terminal.m_bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Name exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pName = SysAllocString( m_Terminal.m_bstrName );

    //
    // Validates SysAllocString
    //

    if( *pName == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::get_Name - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_Name(
    /*[in]*/    BSTR            bstrName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_Name - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Name exit -"
            "bstrName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_Terminal.m_bstrName, (UINT)-1) )
    {
        SysFreeString( m_Terminal.m_bstrName );
        m_Terminal.m_bstrName = NULL;
    }

    //
    // Set the new name
    //

    m_Terminal.m_bstrName = SysAllocString( bstrName );

    //
    // Validates SysAllocString
    //

    if( NULL == m_Terminal.m_bstrName )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::put_Name - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::get_Company(
    /*[out, retval]*/ BSTR*     pCompany
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_Company - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pCompany, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Company exit -"
            "pCompany invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the company
    //

    if( IsBadStringPtr( m_Terminal.m_bstrCompany, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Company exit -"
            "m_bstrCompany invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the Company
    //

    *pCompany = SysAllocString( m_Terminal.m_bstrCompany );

    //
    // Validates SysAllocString
    //

    if( *pCompany == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Company exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::get_Company - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_Company(
    /*[in]*/    BSTR            bstrCompany
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_Company - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrCompany, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Company exit -"
            "bstrCompany invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old company
    //

    if(!IsBadStringPtr( m_Terminal.m_bstrCompany, (UINT)-1) )
    {
        SysFreeString( m_Terminal.m_bstrCompany );
        m_Terminal.m_bstrCompany = NULL;
    }

    //
    // Set the new company
    //

    m_Terminal.m_bstrCompany = SysAllocString( bstrCompany );

    //
    // Validates SysAllocString
    //

    if( NULL == m_Terminal.m_bstrCompany )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Company exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::put_Company - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::get_Version(
    /*[out, retval]*/ BSTR*     pVersion
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_Version - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pVersion, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Version exit -"
            "pVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the version
    //

    if( IsBadStringPtr( m_Terminal.m_bstrVersion, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Version exit -"
            "m_bstrVersion invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the Version
    //

    *pVersion = SysAllocString( m_Terminal.m_bstrVersion );

    //
    // Validates SysAllocString
    //

    if( *pVersion == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Version exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::get_Version - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_Version(
    /*[in]*/    BSTR            bstrVersion
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_Version - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrVersion, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Version exit -"
            "bstrVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old version
    //

    if(!IsBadStringPtr( m_Terminal.m_bstrVersion, (UINT)-1) )
    {
        SysFreeString( m_Terminal.m_bstrVersion );
        m_Terminal.m_bstrVersion = NULL;
    }

    //
    // Set the new Version
    //

    m_Terminal.m_bstrVersion = SysAllocString( bstrVersion );

    //
    // Validates SysAllocString
    //

    if( NULL == m_Terminal.m_bstrVersion )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Version exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::put_Version - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::get_TerminalClass(
    /*[out, retval]*/ BSTR*     pTerminalClass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_TerminalClass - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pTerminalClass, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_TerminalClass exit -"
            "pTerminalClass invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Return the TerminalClass
    //

    LPOLESTR lpszTerminalClass  = NULL;
    HRESULT hr = StringFromCLSID( 
        m_Terminal.m_clsidTerminalClass, 
        &lpszTerminalClass
        );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_TerminalClass exit -"
            "StringFromCLSID failed, returns 0x%08x", hr));
        return hr;
    }

    *pTerminalClass = SysAllocString( lpszTerminalClass );

    // Clean-up
    CoTaskMemFree( lpszTerminalClass );

    //
    // Validates SysAllocString
    //

    if( *pTerminalClass == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_TerminalClass exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::get_TerminalClass - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_TerminalClass(
    /*[in]*/    BSTR            bstrTerminalClass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_TerminalClass - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrTerminalClass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_TerminalClass exit -"
            "bstrTerminalClass invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID?
    //

    CLSID clsidTerminalClass;
    HRESULT hr = CLSIDFromString(bstrTerminalClass, &clsidTerminalClass);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_TerminalClass exit -"
            "bstrTerminalClass is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Clean-up the old TerminalClass
    //

    m_Terminal.m_clsidTerminalClass = clsidTerminalClass;

    LOG((MSP_TRACE, "CPlugTerminal::put_TerminalClass - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::get_CLSID(
    /*[out, retval]*/ BSTR*     pCLSID
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_CLSID - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pCLSID, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_CLSID exit -"
            "pCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    if( m_Terminal.m_clsidCOM == CLSID_NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_CLSID exit -"
            "clsid is NULL, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the CLSID
    //

    LPOLESTR lpszCLSID = NULL;
    HRESULT hr = StringFromCLSID( m_Terminal.m_clsidCOM, &lpszCLSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_CLSID exit -"
            "StringFromCLSID failed, returns 0x%08x", hr));
        return hr;
    }

    *pCLSID = SysAllocString( lpszCLSID );

    // Clean-up
    CoTaskMemFree( lpszCLSID );

    //
    // Validates SysAllocString
    //

    if( *pCLSID == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_CLSID exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminal::get_CLSID - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_CLSID(
    /*[in]*/    BSTR            bstrCLSID
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_CLSID - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrCLSID, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_CLSID exit -"
            "bstrCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID?
    //

    CLSID clsidCOM;
    HRESULT hr = CLSIDFromString(bstrCLSID, &clsidCOM);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_CLSID exit -"
            "bstrCLSID is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Clean-up the old CLSID
    //

    m_Terminal.m_clsidCOM = clsidCOM;


    LOG((MSP_TRACE, "CPlugTerminal::put_CLSID - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::get_Direction(
    /*[out, retval]*/ TMGR_DIRECTION*     pDirection
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_Direction - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pDirection, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_Direction exit -"
            "pDirections invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Return the Direction
    //

    *pDirection = (TMGR_DIRECTION)m_Terminal.m_dwDirections;

    LOG((MSP_TRACE, "CPlugTerminal::get_Direction - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_Direction(
    /*[in]*/    TMGR_DIRECTION     nDirection
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_Direction - enter"));

    if( nDirection == 0 )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Direction exit -"
            "nDirections invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    if( (nDirection & (
        ((long)TMGR_TD_RENDER) | 
        ((long)TMGR_TD_CAPTURE))) != nDirection )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_Direction exit -"
            "nDirections invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Set the new direction
    //

    m_Terminal.m_dwDirections = nDirection;

    LOG((MSP_TRACE, "CPlugTerminal::put_Direction - exit S_OK"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::get_MediaTypes(
    /*[out, retval]*/ long*     pMediaTypes
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::get_MediaTypes - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pMediaTypes, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::get_MediaTypes exit -"
            "pMediaTypes invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Return the MediaTypes
    //

    *pMediaTypes = (long)m_Terminal.m_dwMediaTypes;

    LOG((MSP_TRACE, "CPlugTerminal::get_MediaTypes - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::put_MediaTypes(
    /*[in]*/    long            nMediaTypes
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::put_MediaTypes - enter"));

    if( nMediaTypes == 0)
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_MediaTypes exit -"
            "nMediaTypes invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    if( (nMediaTypes & (
        ((long)TAPIMEDIATYPE_AUDIO) | 
        ((long)TAPIMEDIATYPE_VIDEO) | 
        ((long)TAPIMEDIATYPE_MULTITRACK))) != nMediaTypes )
    {
        LOG((MSP_ERROR, "CPlugTerminal::put_MediaTypes exit -"
            "nMediaTypes invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Set the new direction
    //

    m_Terminal.m_dwMediaTypes = nMediaTypes;

    LOG((MSP_TRACE, "CPlugTerminal::put_MediaTypes - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminal::Add(
    /*[in]*/    BSTR            bstrSuperclass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::Add - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrSuperclass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::Add exit -"
            "bstrTermClassCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID
    //
    CLSID clsidSuperclass = CLSID_NULL;
    HRESULT hr = E_FAIL;
    hr = CLSIDFromString( bstrSuperclass, &clsidSuperclass);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::Add exit -"
            "bstrTermClassCLSID is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Add
    //

    hr = m_Terminal.Add( clsidSuperclass );

    LOG((MSP_TRACE, "CPlugTerminal::Add - exit 0x%08x", hr));
    return hr;
}

STDMETHODIMP CPlugTerminal::Delete(
    /*[in]*/    BSTR            bstrSuperclass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::Delete - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrSuperclass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::Delete exit -"
            "bstrTermClassCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID
    //
    CLSID clsidSuperclass = CLSID_NULL;
    HRESULT hr = E_FAIL;
    hr = CLSIDFromString( bstrSuperclass, &clsidSuperclass);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::Delete exit -"
            "bstrTermClassCLSID is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Delete
    //

    hr = m_Terminal.Delete( clsidSuperclass );

    LOG((MSP_TRACE, "CPlugTerminal::Delete - exit 0x%08x", hr));
    return hr;
}

STDMETHODIMP CPlugTerminal::GetTerminalClassInfo(
    /*[in]*/    BSTR            bstrSuperclass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminal::GetTerminal - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrSuperclass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::GetTerminal exit -"
            "bstrTermClassCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID
    //
    CLSID clsidSuperclass = CLSID_NULL;
    HRESULT hr = E_FAIL;
    hr = CLSIDFromString( bstrSuperclass, &clsidSuperclass);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminal::GetTerminal exit -"
            "bstrTermClassCLSID is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Get terminal
    //

    hr = m_Terminal.Get( clsidSuperclass );

    LOG((MSP_TRACE, "CPlugTerminal::GetTerminal - exit 0x%08x", hr));
    return hr;
}

//
// CPlugTerminalSuperlass class implementation
// Create free thread marshaler
//

HRESULT CPlugTerminalSuperclass::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CPlugTerminalSuperclass::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::FinalConstruct - exit S_OK"));

    return S_OK;
}


//
// CPlugTerminalSuperlass class implementation
// --- ITPTRegTerminalClass interface ---
//

STDMETHODIMP CPlugTerminalSuperclass::get_Name(
    /*[out, retval]*/ BSTR*          pName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::get_Name - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pName, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_Name exit -"
            "pName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validate internal name
    //

    if( IsBadStringPtr( m_Superclass.m_bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_Name exit -"
            "bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Returns name
    //

    *pName = SysAllocString( m_Superclass.m_bstrName);

    //
    // Validate SysAllocString
    //

    if( *pName == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::get_Name - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminalSuperclass::put_Name(
    /*[in]*/          BSTR            bstrName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::put_Name - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::put_Name exit -"
            "bstrName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_Superclass.m_bstrName, (UINT)-1) )
    {
        SysFreeString( m_Superclass.m_bstrName );
        m_Superclass.m_bstrName = NULL;
    }

    //
    // Set the new name
    //

    m_Superclass.m_bstrName = SysAllocString( bstrName );

    //
    // Validates the sysAllocString
    //

    if( NULL == m_Superclass.m_bstrName )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::put_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::put_Name - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminalSuperclass::get_CLSID(
    /*[out, retval]*/ BSTR*           pCLSIDClass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::get_CLSIDClass - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pCLSIDClass, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_CLSIDClass exit -"
            "pCLSIDClass invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Returns CLSID
    //
    LPOLESTR lpszSuperclassCLSID = NULL;
    HRESULT hr = StringFromCLSID( m_Superclass.m_clsidSuperclass, &lpszSuperclassCLSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_CLSIDClass exit -"
            "StringFromClSID failed, returns 0x%08x", hr));
        return hr;
    }

    *pCLSIDClass = SysAllocString( lpszSuperclassCLSID);

    // Clean-up
    CoTaskMemFree( lpszSuperclassCLSID );

    //
    // Validates SysAllocString
    //

    if( *pCLSIDClass == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_CLSIDClass exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::get_CLSIDClass - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminalSuperclass::put_CLSID(
    /*[in]*/         BSTR            bstrCLSIDClass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::put_CLSIDClass - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrCLSIDClass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::put_CLSIDClass exit -"
            "bstrCLSIDClass invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID?
    //

    CLSID clsidSuperclassClSID;
    HRESULT hr = CLSIDFromString(bstrCLSIDClass, &clsidSuperclassClSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::put_CLSIDClass exit -"
            "bstrCLSIDClass is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Clean-up the old CLSID
    //

    m_Superclass.m_clsidSuperclass = clsidSuperclassClSID;

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::put_CLSIDClasse - exit"));
    return S_OK;
}

STDMETHODIMP CPlugTerminalSuperclass::Add(
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::Add - enter"));

    //
    // Add terminal class
    //

    HRESULT hr = E_FAIL;
    hr = m_Superclass.Add();

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::Add - exit 0x%08x", hr));
    return hr;
}

STDMETHODIMP CPlugTerminalSuperclass::Delete(
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::Deletee - enter"));

    //
    // Delete terminalc class
    //

    HRESULT hr = E_FAIL;
    hr = m_Superclass.Delete();

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::Delete - exit 0x%08x",hr));
    return hr;
}

STDMETHODIMP CPlugTerminalSuperclass::GetTerminalSuperclassInfo(
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::GetTerminalSuperclassInfo - enter"));

    //
    // Get terminal class from registry
    //

    HRESULT hr = E_FAIL;
    hr = m_Superclass.Get();

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::GetTerminalSuperclassInfo - exit 0x%08x",hr));
    return hr;
}

STDMETHODIMP CPlugTerminalSuperclass::get_TerminalClasses(
    /*[out, retval]*/ VARIANT*         pVarTerminals
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::get_TerminalClasses - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( pVarTerminals, sizeof(VARIANT)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_TerminalClasses exit -"
            "pTerminals invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // reset the output argument
    //

    pVarTerminals->parray = NULL;
    pVarTerminals->vt = VT_EMPTY;

    //
    // List the terminals
    //

    HRESULT hr = E_FAIL;
    CLSID* pTerminals = NULL;
    DWORD dwTerminals = 0;

    hr = m_Superclass.ListTerminalClasses( 0, 
        &pTerminals,
        &dwTerminals
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_TerminalClasses exit -"
            "ListTerminalClasses failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Create a safe array for the terminasl
    //

    SAFEARRAY* psaTerminals = NULL;
    SAFEARRAYBOUND rgsabound;
    rgsabound.lLbound = 1;
    rgsabound.cElements = dwTerminals;
    psaTerminals = SafeArrayCreate( 
        VT_BSTR,
        1,
        &rgsabound);
    if( psaTerminals == NULL )
    {
        // Clean-up
        delete[] pTerminals;

        LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_TerminalClasses exit -"
            "SafeArrayCreate failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Copies into the safe array the elements
    // 

    for( DWORD dwTerminal = 0; dwTerminal < dwTerminals; dwTerminal++)
    {
        LPOLESTR lpszTerminalClass = NULL;
        hr = StringFromCLSID( pTerminals[dwTerminal], &lpszTerminalClass);
        if( FAILED(hr) )
        {
            // Clean-up
            delete[] pTerminals;
            SafeArrayDestroy( psaTerminals );

            LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_TerminalClasses exit -"
                "StringFromCLSID failed, returns 0x%08x", hr));
            return hr;
        }

        BSTR bstrTerminalClass = SysAllocString( lpszTerminalClass );

        CoTaskMemFree( lpszTerminalClass );

        if( bstrTerminalClass == NULL )
        {
            // Clean-up
            delete[] pTerminals;
            SafeArrayDestroy( psaTerminals );

            LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_TerminalClasses exit -"
                "sysAloocString failed, returns E_OUTOFMEMORY"));
            return E_OUTOFMEMORY;
        }

        // Put the element into the array
        long nIndex = (long)(dwTerminal+1);
        hr = SafeArrayPutElement( psaTerminals, &nIndex, bstrTerminalClass );
        if( FAILED(hr) )
        {
            // Clean-up
            delete[] pTerminals;
            SafeArrayDestroy( psaTerminals );
            SysFreeString( bstrTerminalClass );

            LOG((MSP_ERROR, "CPlugTerminalSuperclass::get_TerminalClasses exit -"
                "SafeArrayPutElement failed, returns 0x%08x", hr));
            return hr;
        }
    }

    // Clean-up
    delete[] pTerminals;

    // Return values
    pVarTerminals->parray = psaTerminals;
    pVarTerminals->vt = VT_ARRAY | VT_BSTR;

    LOG((MSP_TRACE, "CPlugTerminalSuperclass::get_TerminalClasses - exit 0x%08x", hr));
    return hr;
}

STDMETHODIMP CPlugTerminalSuperclass::EnumerateTerminalClasses(
    OUT IEnumTerminalClass** ppTerminals
    )
{
    LOG((MSP_TRACE, "CPlugTerminalSuperclass::EnumerateTerminalClasses - enter"));

    //
    // Validate argument
    //
    if( TM_IsBadWritePtr( ppTerminals, sizeof(IEnumTerminalClass*)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::EnumerateTerminalClasses exit -"
            "ppTerminals invalid, returns E_POINTER"));
        return E_POINTER;
    }

    CLSID* pTerminals = NULL;
    DWORD dwTerminals = 0;

    HRESULT hr = m_Superclass.ListTerminalClasses( 0, 
        &pTerminals,
        &dwTerminals
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::EnumerateTerminalClasses exit -"
            "ListTerminalClasses failed, returns 0x%08x", hr));
        return hr;
    }

    // 
    // Create a buffer with exactly dwTerminals size
    //
    CLSID* pTerminalsCLSID = new CLSID[dwTerminals];
    if( pTerminalsCLSID == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::EnumerateTerminalClasses exit -"
            "new operator failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Copies into the new buffer
    //
    memcpy( pTerminalsCLSID, pTerminals, sizeof(CLSID)*dwTerminals);

    //
    // Delete the old buffer
    //
    delete[] pTerminals;

    //
    // Create the enumerator
    //
    typedef CSafeComEnum<IEnumTerminalClass,
                     &IID_IEnumTerminalClass,
                     GUID, _Copy<GUID> > CEnumerator;

    CComObject<CEnumerator> *pEnum = NULL;
    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if( FAILED(hr) )
    {
        delete[] pTerminalsCLSID;

        LOG((MSP_ERROR, "CPlugTerminalSuperclass::EnumerateTerminalClasses exit -"
            "CreateInstance failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Initialize enumerator
    //
    hr = pEnum->Init(pTerminalsCLSID,
                     pTerminalsCLSID+dwTerminals,
                     NULL,
                     AtlFlagTakeOwnership); 

    if( FAILED(hr) )
    {
        delete pEnum;
        delete[] pTerminalsCLSID;

        LOG((MSP_ERROR, "CPlugTerminalSuperclass::EnumerateTerminalClasses exit -"
            "Init failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Query for the desired interface.
    //

    hr = pEnum->_InternalQueryInterface(
        IID_IEnumTerminalClass, 
        (void**) ppTerminals
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclass::EnumerateTerminalClasses exit - "
            "can't get enumerator interface - exit 0x%08x", hr));

        delete pEnum;
        delete[] pTerminalsCLSID;
        
        return hr;
    }


    LOG((MSP_TRACE, "CPlugTerminalSuperclass::EnumerateTerminalClasses - exit S_OK"));
    return S_OK;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\meterf.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __MEDIA_TERMINAL_FILTER__
#define __MEDIA_TERMINAL_FILTER__

// include header files for the amovie types
#include "Stream.h"
#include "Sample.h"

// number of internal buffers allocated by default
// (for write terminal)
const DWORD DEFAULT_AM_MST_NUM_BUFFERS = 5;

// while this is a LONG, it should actually be a positive value that'll
// fit in a LONG (the buffer size and data size variables of the sample)
// are LONG, so this is long as well
const LONG DEFAULT_AM_MST_SAMPLE_SIZE = 640;

// alignment of buffers allocated
const LONG DEFAULT_AM_MST_BUFFER_ALIGNMENT = 1;

// number of prefix bytes in buffers allocated
const LONG DEFAULT_AM_MST_BUFFER_PREFIX = 0;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// CNBQueue
//
// Non blocking version of active movie queue class.  Very basic Q built
// entirely on Win32.
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

template <class T> class CNBQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T             **QueueObjects;   // Array of objects (ptr's to void)

public:
    
    
    BOOL InitializeQ(int n) 
    {

        LOG((MSP_TRACE, "CNBQueue::InitializeQ[%p] - enter", this));

        //
        // the argument had better be valid
        //

        if (0 > n)
        {
            TM_ASSERT(FALSE);

            return FALSE;
        }


        if (QueueObjects != NULL)
        {

            //
            // already initialized. this is a bug.
            //

            TM_ASSERT(FALSE);

            return FALSE;
        }


        iNextPut = 0;
        iNextGet = 0;

        
        //
        // attempt to create critical section
        //
        
        try
        {

            InitializeCriticalSection(&CritSect);
        }
        catch(...)
        {

            //
            // failed to create critical section
            //

            LOG((MSP_ERROR, "CNBQueue::InitializeQ - failed to initialize critical section"));

            return FALSE;
        }


        //
        // attempt to create a semaphore
        //

        TCHAR *ptczSemaphoreName = NULL;

#if DBG

        //
        // in debug build, use named semaphores.
        //

        TCHAR tszPutSemaphoreName[MAX_PATH];

        _stprintf(tszPutSemaphoreName, 
            _T("CNBQueuePutSemaphore_pid[0x%lx]_CNBQueue[%p]_"),
            GetCurrentProcessId(), this);

        
        LOG((MSP_TRACE, "CNBQueue::InitializeQ - creating put semaphore [%S]",
            tszPutSemaphoreName));


        ptczSemaphoreName = &tszPutSemaphoreName[0];


#endif

        hSemPut = CreateSemaphore(NULL, n, n, ptczSemaphoreName);

        if (NULL == hSemPut)
        {
            //
            // cleanup and exit
            //

            DeleteCriticalSection(&CritSect);
            
            LOG((MSP_ERROR, "CNBQueue::InitializeQ - failed to create put semaphore"));

            return FALSE;
        }



#if DBG

        //
        // in debug build, use named semaphores.
        //

        TCHAR tszGetSemaphoreName[MAX_PATH];

        _stprintf(tszGetSemaphoreName, 
            _T("CNBQueueGetSemaphore_pid[0x%lx]_CNBQueue[%p]_"),
            GetCurrentProcessId(), this);

        
        LOG((MSP_TRACE, "CNBQueue::InitializeQ - creating get semaphore [%S]",
            tszGetSemaphoreName));


        ptczSemaphoreName = &tszGetSemaphoreName[0];


#endif


        hSemGet = CreateSemaphore(NULL, 0, n, ptczSemaphoreName);

        if (NULL == hSemGet)
        {
            //
            // cleanup and exit
            //

            CloseHandle(hSemPut);
            hSemPut = NULL;


            DeleteCriticalSection(&CritSect);

            
            LOG((MSP_ERROR, "CNBQueue::InitializeQ - failed to create get semaphore"));

            return FALSE;

        }


        //
        // attempt to allocate queue
        //

        QueueObjects = new T*[n];

        if (NULL == QueueObjects)
        {

            //
            // cleanup and exit
            //

            CloseHandle(hSemPut);
            hSemPut = NULL;


            CloseHandle(hSemGet);
            hSemGet = NULL;


            DeleteCriticalSection(&CritSect);

            LOG((MSP_ERROR, "CNBQueue::InitializeQ - failed to allocate queue objects"));

            return FALSE;

        }


        nMax = n;
        
        LOG((MSP_TRACE, "CNBQueue::InitializeQ - exit"));

        return TRUE;
    }

    void ShutdownQ()
    {
        //
        // QueueObjects also doubles as "Object Initialized" flag
        //
        // if object is initialized, _all_ its resource data members must 
        // be released
        //

        if (NULL != QueueObjects)
        {
            delete [] QueueObjects;
            QueueObjects = NULL;

            DeleteCriticalSection(&CritSect);
            
            CloseHandle(hSemPut);
            hSemPut = NULL;

            CloseHandle(hSemGet);
            hSemGet = NULL;
        }

    }


public:

    CNBQueue()		
        : QueueObjects(NULL),
          hSemPut(NULL),
          hSemGet(NULL),
          iNextPut(0),
          iNextGet(0),
          nMax(0)
    {}

    ~CNBQueue()
    {

        //
        // deallocate resources if needed
        //

        ShutdownQ();
    }


    T *DeQueue(BOOL fBlock = TRUE)
    {

        
        if (NULL == QueueObjects)
        {

            //
            // the queue is not initialized
            //

            return NULL;
        }



        //
        // block as needed
        //

        if (fBlock)
        {
            DWORD dwr = WaitForSingleObject(hSemGet, INFINITE);

            if ( WAIT_OBJECT_0 != dwr)
            {
                //
                // something's wrong
                // 

                return NULL;
            }
        }
        else 
        {
            //
            // Check for something on the queue but don't wait.  If there
            //  is nothing in the queue then we'll let the caller deal with
            //  it.
            //
            DWORD dwr = WaitForSingleObject(hSemGet, 0);

            if (dwr == WAIT_TIMEOUT)
            {
                return NULL;
            }
        }


        //
        // get an object from the queue
        //

        EnterCriticalSection(&CritSect);
        
        int iSlot = iNextGet++ % nMax;
        T *pObject = QueueObjects[iSlot];
        
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        
        ReleaseSemaphore(hSemPut, 1L, NULL);
        return pObject;
    }

    BOOL EnQueue(T *pObject)
    {

        
        if (NULL == QueueObjects)
        {

            //
            // the queue is not initialized
            //

            return FALSE;
        }


        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        DWORD dwr = WaitForSingleObject(hSemPut, INFINITE);

        if ( WAIT_OBJECT_0 != dwr)
        {
            //
            // something's wrong
            // 

            return FALSE;
        }


        EnterCriticalSection(&CritSect);
        int iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = pObject;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, NULL);

        return TRUE;
    }
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// define class CTMStreamSample - this is used by CMediaTerminalFilter
// currently, the actual buffer used by the sample is created dynamically on 
// the heap and when the sample is destroyed the buffer is also destroyed
// this may be changed to using a fixed size buffer pool in future
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

class CTMStreamSample : public CSample
{
    friend class CMediaTerminalFilter;
public:

    inline CTMStreamSample();

    // needs to be virtual, or the derived classes' destructor may  not
    // be called when a CTMStreamSample * is deleted
    virtual ~CTMStreamSample()
    {}

    // calls CSample::InitSample(pStream, bIsInternalSample)
    // sets member variables
    HRESULT Init(
        CStream &Stream, 
        bool    bIsInternalSample,
        PBYTE   pBuffer,
        LONG    BufferSize
        );
        
    inline void SetBufferInfo(
        DWORD   BufferSize,
        BYTE    *pBuffer,
        DWORD   DataSize
        );


    inline void GetBufferInfo(
        DWORD &BufferSize,
        BYTE  *&pBuffer,
        DWORD &DataSize
        );
    
    // copy the contents of the src media sample into this instance
    // CSample::CopyFrom doesn't set time (start/stop) valid flags
    // this fixes the problem.
    void CopyFrom(
        IN IMediaSample *pSrcMediaSample
        );

protected:

    PBYTE   m_pBuffer;
    LONG    m_BufferSize;
    LONG    m_DataSize;

private:

    //  Methods forwarded from MediaSample object.

    HRESULT MSCallback_GetPointer(BYTE ** ppBuffer) { *ppBuffer = m_pBuffer; return NOERROR; }

    LONG MSCallback_GetSize(void) { return m_BufferSize; }
        
    LONG MSCallback_GetActualDataLength(void) { return m_DataSize; }
        
    HRESULT MSCallback_SetActualDataLength(LONG lActual)
    {
        if (lActual <= m_BufferSize) {
            m_DataSize = lActual;
            return NOERROR;
            }
        return E_INVALIDARG;
    };
};

inline 
CTMStreamSample::CTMStreamSample(
    )
    : m_pBuffer(NULL),
      m_BufferSize(0),
      m_DataSize(0)
{
}


inline void 
CTMStreamSample::SetBufferInfo(
    DWORD   BufferSize,
    BYTE    *pBuffer,
    DWORD   DataSize
    )
{
    m_BufferSize    = BufferSize;
    m_pBuffer       = pBuffer;
    m_DataSize      = DataSize;
}


inline void 
CTMStreamSample::GetBufferInfo(
    DWORD &BufferSize,
    BYTE  *&pBuffer,
    DWORD &DataSize
    )
{
    BufferSize  = m_BufferSize;
    pBuffer     = m_pBuffer;
    DataSize    = m_DataSize;
}


class CQueueMediaSample : public CTMStreamSample
{
public:

    inline CQueueMediaSample();

#if DBG
	virtual ~CQueueMediaSample();
#endif // DBG

    // calls CTMStreamSample::Init, sets members
    HRESULT Init(
        IN CStream                      &pStream, 
        IN CNBQueue<CQueueMediaSample>  &pQueue
        );

    void HoldFragment(
        IN DWORD        FragSize,
        IN BYTE         *pbData,
        IN IMediaSample &FragMediaSample
        );

	inline DWORD GetDataSize() { return m_DataSize; }

protected:

    // pointer to a queue that contains us!
    CNBQueue<CQueueMediaSample> *m_pSampleQueue;

    // ptr to the sample being fragmented
    CComPtr<IMediaSample>       m_pFragMediaSample;
    
    // Overridden to provide different behavior
    void FinalMediaSampleRelease();

};


inline 
CQueueMediaSample::CQueueMediaSample(
    )
    : m_pSampleQueue(NULL)
{
}


class CUserMediaSample : 
        public CTMStreamSample,
        public IMemoryData,
        public ITAMMediaFormat
{
public:

BEGIN_COM_MAP(CUserMediaSample)
    COM_INTERFACE_ENTRY2(IUnknown, IStreamSample)
    COM_INTERFACE_ENTRY(IStreamSample)
    COM_INTERFACE_ENTRY(IMemoryData)
    COM_INTERFACE_ENTRY(ITAMMediaFormat)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()
    
    inline CUserMediaSample();

    virtual ~CUserMediaSample();

    // if asked to allocate buffers, verify allocator properties
    static BOOL VerifyAllocatorProperties(
        IN BOOL                         bAllocateBuffers,
        IN const ALLOCATOR_PROPERTIES   &AllocProps
        );

    // calls CTMStreamSample::Init, sets members
    HRESULT Init(
        IN CStream              &Stream, 
        IN BOOL                 bAllocateBuffer,
		IN DWORD				ReqdBufferSize,
        IN const ALLOCATOR_PROPERTIES &AllocProps
        );

    void BeginFragment(
        IN      BOOL                bNoteCurrentTime
        );

    // assign fragment to CQueueMediaSample
    void Fragment(
        IN      BOOL                bFragment,
        IN      LONG                AllocBufferSize,
        IN OUT  CQueueMediaSample   &QueueMediaSample,
        OUT     BOOL                &bDone
        );

    // copy fragment to downstream allocator's IMediaSample
    HRESULT CopyFragment(
        IN      BOOL           bFragment,
        IN      LONG           AllocBufferSize,
        IN OUT  IMediaSample * pDestMediaSample,
        OUT     BOOL         & bDone
        );

    // computes the time to wait. it checks the time at which the last
    // fragmented byte would be due and determines the time to wait using
    // the time delay since the beginning of fragmentation 
    DWORD GetTimeToWait(
        IN DOUBLE DelayPerByte
        );

    // when we are decommitted/aborted while being fragmented, we
    // need to get rid of our refcnt on internal IMediaSample and set
    // the error code to E_ABORT. this will be signaled to the user 
    // only when the last refcnt on IMediaSample is released 
    // (possibly by an outstanding queue sample)
    void AbortDuringFragmentation();

    // copy the contents of the src media sample into this instance
    HRESULT CopyFrom(
        IN IMediaSample *pSrcMediaSample
        );

	HRESULT CopyFrom(
		IN		IMediaSample	*pSrcMediaSample,
		IN OUT	BYTE			*&pBuffer,
		IN OUT	LONG			&DataLength
		);
        
    // over-ridden to check if the instance is committed before
    // adding the sample to the CStream buffer pool
    virtual HRESULT SetCompletionStatus(HRESULT hrCompletionStatus);

    // IStreamSample

    // this method is over-ridden from the base class so that we can
    // decrement the refcnt on a sample if stealing it from the CStream
    // free buffer pool is successful
    STDMETHODIMP CompletionStatus(
        IN   DWORD dwFlags,
        IN   /* [optional] */ DWORD dwMilliseconds
        );

    // IMemoryData

    STDMETHOD(SetBuffer)(
        IN  DWORD cbSize,
        IN  BYTE * pbData,
        IN  DWORD dwFlags
        );


    STDMETHOD(GetInfo)(
        OUT  DWORD *pdwLength,
        OUT  BYTE **ppbData,
        OUT  DWORD *pcbActualData
        );


    STDMETHOD(SetActual)(
        IN   DWORD cbDataValid
        );

    // ITAMMediaFormat

    // redirect this call to ((CMediaTerminalFilter *)m_pStream)
    STDMETHOD(get_MediaFormat)(
        OUT /* [optional] */ AM_MEDIA_TYPE **ppFormat
        );

    // this is not allowed
    STDMETHOD(put_MediaFormat)(
        IN  const AM_MEDIA_TYPE *pFormat
        );

protected:

    // marshaller
	IUnknown *m_pFTM;

    // TRUE if we allocated the buffer (then, we need to destroy it too)
    BOOL    m_bWeAllocatedBuffer;

    // time at which BeginFragment was called (value returned
    // by timeGetTime)
    DWORD   m_BeginFragmentTime;

    // these many bytes of the buffer have already been fragmented
    LONG   m_NumBytesFragmented;

    // TRUE if being fragmented
    BOOL    m_bBeingFragmented;


    // size of the buffer that the application will have to provide, if app 
    // does its own memory allocation

    DWORD m_dwRequiredBufferSize;

        
    // this calls the base class FinalMediaSampleRelease and
    // then releases reference to self obtained in BeginFragment
    virtual void FinalMediaSampleRelease();

private:

    virtual HRESULT InternalUpdate(
                        DWORD dwFlags,
                        HANDLE hEvent,
                        PAPCFUNC pfnAPC,
                        DWORD_PTR dwptrAPCData
                        );
};


inline 
CUserMediaSample::CUserMediaSample(
    )
    : m_bWeAllocatedBuffer(FALSE),
      m_NumBytesFragmented(0),
      m_bBeingFragmented(FALSE),
      m_BeginFragmentTime(0),
      m_dwRequiredBufferSize(0)
{
    // can fail
    CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), 
            &m_pFTM
            );
}


inline
CUserMediaSample::~CUserMediaSample(
    )
{
    if (m_bWeAllocatedBuffer) 
    {
        if (NULL != m_pBuffer)
        {
            delete m_pBuffer;
        }
    }

    // if there is an outstanding APC call and the user handle
    // (the targe thread handle) has not been closed, close it
    if ((NULL != m_UserAPC) && (NULL != m_hUserHandle))
    {
        CloseHandle(m_hUserHandle);
    }
    
    if (NULL != m_pFTM)
    {
        m_pFTM->Release();
        m_pFTM = NULL;
    }
}


/* The media stream terminal filter */

// uses class CMediaPumpPool
class CMediaPumpPool;

// friend
class CMediaTerminal;

class CMediaTerminalFilter :
        public CStream,
        public ITAllocatorProperties
{    
    friend CMediaTerminal;

public:

DECLARE_AGGREGATABLE(CMediaTerminalFilter)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMediaTerminalFilter)
        COM_INTERFACE_ENTRY(ITAllocatorProperties)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

    // set the member variables
    inline CMediaTerminalFilter();

    virtual ~CMediaTerminalFilter();

    // calls the IAMMediaStream::Initialize(NULL, 0, PurposeId, StreamType),
    // sets certain member variables
    // ex. m_pAmovieMajorType
    virtual HRESULT Init(
        IN REFMSPID             PurposeId, 
        IN const STREAM_TYPE    StreamType,
        IN const GUID           &AmovieMajorType
        );

    // the thread pump calls the filter back during the registration
    // to tell it that registration succeeded and that the pump will be
    // waiting on the m_hWaitFreeSem handle
    HRESULT SignalRegisteredAtPump();

    // this method only makes sense for a write terminal and is used by CMediaPump
    // to obtain a filled buffer for passing downstream
    virtual HRESULT GetFilledBuffer(
        OUT IMediaSample    *&pMediaSample,
        OUT DWORD           &WaitTime
        );

    // the caller is supposed to call DeleteMediaType(*ppmt) (on success)
    HRESULT GetFormat(
        OUT AM_MEDIA_TYPE **ppmt
        );
    
    // This method can only be called after initialization when the stream 
    // is not connected. It can only be called if the stream is writeable.
    // it is used in writeable filters to set the media format to negotiate
    // when connected to the filter graph.
    HRESULT SetFormat(
        IN AM_MEDIA_TYPE *pmt
        );

    // checks if the filter is committed before adding the sample
    // to the CStream buffer pool
    HRESULT AddToPoolIfCommitted(
        IN  CSample *pSample
        );

    // first check if this sample is the one being fragmented currently, 
    // then check the free pool
    BOOL StealSample(
        IN CSample *pSample
        );

    // ITAllocatorProperties -
    // exposes the allocator properties of the Media Streaming Terminal 
    // (MST) to a user. A user only needs to use this interface when he 
    // needs to use his own buffers or needs to operate with a fixed set 
    // of samples

    // this method may only be called before connection and will
    // force the MST to use these values during filter negotiation
    // if the connecting filter doesn't accept these, the connection
    // shall not be established
    STDMETHOD(SetAllocatorProperties)(
        IN  ALLOCATOR_PROPERTIES *pAllocProperties
        );

    // gets current values for the allocator properties
    // after connection, this provides the negotiated values
    // it is invalid before connection. The MST will accept
    // any values suggested by the filters it connects to
    STDMETHOD(GetAllocatorProperties)(
        OUT  ALLOCATOR_PROPERTIES *pAllocProperties
        );

    // TRUE by default. when set to FALSE, the sample allocated
    // by the MST don't have any buffers and they must be supplied
    // before Update is called on the samples
    STDMETHOD(SetAllocateBuffers)(
        IN  BOOL bAllocBuffers
        );

    // returns the current value of this boolean configuration parameter
    STDMETHOD(GetAllocateBuffers)(
        OUT  BOOL *pbAllocBuffers
        );

    // this size is used for allocating buffers when AllocateSample is
	// called. this is only valid when we have been told to allocate buffers
    STDMETHOD(SetBufferSize)(
        IN  DWORD	BufferSize
        );

    // returns the value used to allocate buffers when AllocateSample is
	// called. this is only valid when we have been told to allocate buffers
    STDMETHOD(GetBufferSize)(
        OUT  DWORD	*pBufferSize
        );

    // over-ridden base class methods

    // CStream
    // IAMMediaStream

    // over-ride this to return failure. we don't allow it to join a multi-media
    // stream because the multi-media stream thinks it owns the stream
    STDMETHOD(JoinAMMultiMediaStream)(
        IN  IAMMultiMediaStream *pAMMultiMediaStream
        );
        
    // over-ride this to return failure if the filter is anything other than the internally
    // created filter. The internally created media stream filter has only one IAMMediaStream 
    // (this one) in it
    STDMETHOD(JoinFilter)(
        IN  IMediaStreamFilter *pMediaStreamFilter
        );

    STDMETHOD(AllocateSample)(
        IN   DWORD dwFlags,
        OUT  IStreamSample **ppSample
        );

    STDMETHOD(CreateSharedSample)(
        IN   IStreamSample *pExistingSample,
        IN   DWORD dwFlags,
        OUT  IStreamSample **ppNewSample
        );

    STDMETHOD(SetSameFormat)(
        IN  IMediaStream *pStream, 
        IN  DWORD dwFlags
        );

    // CStream over-ride - this method had to be replaced because 
    // of references to CPump which itself is being replaced by CMediaPump
    STDMETHODIMP SetState(
        IN  FILTER_STATE State
        );

    // CStream - end

    // IMemInputPin
        
    STDMETHOD(GetAllocatorRequirements)(
        IN  ALLOCATOR_PROPERTIES*pProps
        );

    STDMETHOD(Receive)(
        IN  IMediaSample *pSample
        );



    // supports IAMBufferNegotiation interface on TERMINAL
    // this is necessary because ITAllocatorProperties also
    // has an identical GetAllocatorProperties method!

    STDMETHOD(SuggestAllocatorProperties)(
        IN  const ALLOCATOR_PROPERTIES *pProperties
        );

    // IMemAllocator

    STDMETHOD(GetBuffer)(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);

    // ** figure out what needs to be done for this allocator interface
    // since the number of buffers that can be created is unbounded
    STDMETHOD(SetProperties)(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);

    STDMETHOD(GetProperties)(ALLOCATOR_PROPERTIES* pProps);

    STDMETHOD(Commit)();

    STDMETHOD(Decommit)();

    // IPin
        
    STDMETHOD(Connect)(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt);  
    
    STDMETHOD(ReceiveConnection)(IPin * pConnector, const AM_MEDIA_TYPE *pmt);

    // the base class implementation doesn't validate the parameter
    STDMETHOD(ConnectionMediaType)(AM_MEDIA_TYPE *pmt);

    // should accept all media types which match the major type corresponding to the purpose id
    STDMETHOD(QueryAccept)(const AM_MEDIA_TYPE *pmt);

    // over-ridden from CStream to set the end of stream flag to false
    // this is done instead of setting it in Connect and ReceiveConnection
    STDMETHODIMP Disconnect();



    //
    // this is called by media pump when it has a sample for us to process
    //

    STDMETHODIMP ProcessSample(IMediaSample *pSample);

protected:

    // last sample ended at this (calculated) time

    REFERENCE_TIME m_rtLastSampleEndedAt;

    //
    // calculated duration of the sample that was last submitted
    //

    REFERENCE_TIME m_rtLastSampleDuration;


    //
    // real (measured) time of submission of the last sample
    //
    
    REFERENCE_TIME m_rtRealTimeOfLastSample;


    // flag to check if this is an audio filter, the CStream member 
    // m_PurposeId is a guiid and this just provides a less expensive 
    // way of checking the same thing
    BOOL m_bIsAudio;

    // contains the samples that will be passed to downstream filters.
    CNBQueue<CQueueMediaSample> m_SampleQueue;

    // These datamembers provide some fragmentation support 
    // for buffers going downstream
    CUserMediaSample *m_pSampleBeingFragmented;

    // flag for allocating buffers for samples when AllocateSample is 
    // called. Its TRUE by default, but the user can set it before 
    // connection
    BOOL    m_bAllocateBuffers;

	// size of buffers to allocate in AllocateSample if m_bAllocateBuffers
	// is TRUE. if this isn't set (i.e. set to 0), the negotiated 
	// allocator properties buffer size is used in its place
	DWORD	m_AllocateSampleBufferSize;

    // FALSE by default. This is set to TRUE if the user specifies 
    // allocator properties for them to see.
    // (we used to insist on our own allocator properties when this
    //  was TRUE, but now this just means that we need to translate
    //  between disjoint buffer sizes if needed)
    BOOL                 m_bUserAllocProps;
    ALLOCATOR_PROPERTIES m_UserAllocProps;

    // allocator properties negotiated -- if none suggested (by msp) and
    // none requested by user, we use whatever the other filter has
    BOOL                 m_bSuggestedAllocProps;
    ALLOCATOR_PROPERTIES m_AllocProps;

	// per byte delay for audio samples - only valid for write filter
	DOUBLE	m_AudioDelayPerByte;

	// per frame delay for video samples - only valid for write filter
	DWORD	m_VideoDelayPerFrame;

    // the filter restricts the acceptable media types to those that match the major type
    // this corresponds to the purpose id of the IAMMediaStream (set in Init)
    const GUID *m_pAmovieMajorType;

    // this is the media type suggested by a user of the terminal
    // it is only valid for writeable streams if put_MediaType was called
    // (i.e. not valid for readable streams)
    // this needs to be freed in the destructor
    // cstream - cbaseterm gets\sets it through methods
    AM_MEDIA_TYPE *m_pSuggestedMediaType;

    // this pump replaces the CStream related implementation of CPump
    // CPump uses a separate thread for each write terminal, 
    // it uses IMemAllocator::GetBuffer to get a user written media 
    // sample (for passing on downstream). This method should only be 
    // used to get the next free buffer to write into.

    // CStream methods

    // this is only used during Connect and ReceiveConnect to supply the optional media type
    // since we over-ride Connect and ReceiveConnection methods, this should never get called
    virtual HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);

    // others

    // sets the time to delay - per byte for audio, per frame for video
    void GetTimingInfo(
        IN const AM_MEDIA_TYPE &MediaType
        );

    // timestamps the sample
    HRESULT SetTime(
            IN IMediaSample *pMediaSample
            );


    // set discontinuity flag on the sample it the sample came too late -- we
    // assume that if the application stopped feeding mst with data, this is 
    // because there was a gap in the actual data flow

    HRESULT SetDiscontinuityIfNeeded(
            IN IMediaSample *pMediaSample
            );

    // set the default allocator properties
    void SetDefaultAllocatorProperties();

    //
    // Helper methods for GetFilledBuffer.
    //

    virtual HRESULT FillDownstreamAllocatorBuffer(
        OUT IMediaSample   *& pMediaSample, 
        OUT DWORD          &  WaitTime,
        OUT BOOL           *  pfDone
        );

    virtual HRESULT FillMyBuffer(
        OUT IMediaSample   *& pMediaSample, 
        OUT DWORD          &  WaitTime,
        OUT BOOL           *  pfDone
        );


private :

    // this is a weak reference and should not be a CComPtr
    // this tells us that we should only accept this media stream filter
    // when a non-null value is proposed in JoinFilter
    IMediaStreamFilter *m_pMediaStreamFilterToAccept;

    // sets the media stream filter that may be acceptable
    inline void SetMediaStreamFilter(
        IN IMediaStreamFilter *pMediaStreamFilter
        )
    {
        m_pMediaStreamFilterToAccept = pMediaStreamFilter;
    }

public:
    // implements single thread pump for all write terminal filters
    // it uses GetFilledBuffer to obtain filled samples to write downstream
    // and to detect when to remove this filter from its list of filters to
    // service
    // ZoltanS: must be public so we can access it in DllMain
    // ZoltanS: no longer single thread pump; it is a wrapper which delegated
    // to one or more single thread pumps

    static CMediaPumpPool   ms_MediaPumpPool;

};


// set the member variables
inline 
CMediaTerminalFilter::CMediaTerminalFilter(
    )
    : m_bIsAudio(TRUE),
      m_bAllocateBuffers(TRUE),
      m_AllocateSampleBufferSize(0),
      m_bUserAllocProps(FALSE),
      m_bSuggestedAllocProps(FALSE),
      m_AudioDelayPerByte(0),
      m_VideoDelayPerFrame(0),
      m_pAmovieMajorType(NULL),
      m_pSuggestedMediaType(NULL),
      m_pSampleBeingFragmented(NULL),
      m_pMediaStreamFilterToAccept(NULL),
      m_rtLastSampleEndedAt(0),
      m_rtLastSampleDuration(0),
      m_rtRealTimeOfLastSample(0)
{
}


#endif // __MEDIA_TERMINAL_FILTER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\mtenum.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __MTENUM_H_INC__
#define __MTENUM_H_INC__

class ATL_NO_VTABLE CMediaTypeEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumMediaTypes
{
public:
        // 
        // METHODS
        //
        CMediaTypeEnum();
        ~CMediaTypeEnum();

        DECLARE_GET_CONTROLLING_UNKNOWN()

        void Initialize(CStream *pStream, ULONG cCurPos);

        //
        // IEnumMediaTypes
        //
        STDMETHODIMP Next(ULONG cNumToFetch, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched);
        STDMETHODIMP Skip(ULONG cSkip);
        STDMETHODIMP Reset();
        STDMETHODIMP Clone(IEnumMediaTypes **ppEnumMediaTypes);

BEGIN_COM_MAP(CMediaTypeEnum)
        COM_INTERFACE_ENTRY(IEnumMediaTypes)
END_COM_MAP()

public:
        ULONG           m_cCurrentPos;
        CStream         *m_pStream;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\ptreg.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __PTREG__
#define __PTREG__

#include "PTUtil.h"



//
// CPlugTerminal implements ITPTRegTerminal interface
//
class ATL_NO_VTABLE CPlugTerminal : 
    public CComCoClass<CPlugTerminal, &CLSID_PluggableTerminalRegistration>,
    public IDispatchImpl<ITPluggableTerminalClassRegistration, &IID_ITPluggableTerminalClassRegistration, &LIBID_TERMMGRLib>,
    public CComObjectRootEx<CComMultiThreadModel>
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_PTREGTERMINAL)
DECLARE_NOT_AGGREGATABLE(CPlugTerminal) 
DECLARE_GET_CONTROLLING_UNKNOWN()

virtual HRESULT FinalConstruct(void);


BEGIN_COM_MAP(CPlugTerminal)
    COM_INTERFACE_ENTRY(ITPluggableTerminalClassRegistration)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

public:
    CPlugTerminal() :
        m_pFTM(NULL)
    {
    }

    ~CPlugTerminal()
    {
        if( m_pFTM )
        {
            m_pFTM->Release();
            m_pFTM = NULL;
        }
    }

public:
    STDMETHOD(get_Name)(
        /*[out, retval]*/ BSTR*     pName
        );

    STDMETHOD(put_Name)(
        /*[in]*/    BSTR            bstrName
        );

    STDMETHOD(get_Company)(
        /*[out, retval]*/ BSTR*     pCompany
        );

    STDMETHOD(put_Company)(
        /*[in]*/    BSTR            bstrCompany
        );

    STDMETHOD(get_Version)(
        /*[out, retval]*/ BSTR*     pVersion
        );

    STDMETHOD(put_Version)(
        /*[in]*/    BSTR            bstrVersion
        );

    STDMETHOD(get_TerminalClass)(
        /*[out, retval]*/ BSTR*     pTerminalClass
        );

    STDMETHOD(put_TerminalClass)(
        /*[in]*/    BSTR            bstrTerminalClass
        );

    STDMETHOD(get_CLSID)(
        /*[out, retval]*/ BSTR*     pCLSID
        );

    STDMETHOD(put_CLSID)(
        /*[in]*/    BSTR            bstrCLSID
        );

    STDMETHOD(get_Direction)(
        /*[out, retval]*/ TMGR_DIRECTION*  pDirection
        );

    STDMETHOD(put_Direction)(
        /*[in]*/    TMGR_DIRECTION  nDirection
        );

    STDMETHOD(get_MediaTypes)(
        /*[out, retval]*/ long*     pMediaTypes
        );

    STDMETHOD(put_MediaTypes)(
        /*[in]*/    long            nMediaTypes
        );

    STDMETHOD(Add)(
        /*[in]*/    BSTR            bstrSuperclass
        );

    STDMETHOD(Delete)(
        /*[in]*/    BSTR            bstrSuperclass
        );

    STDMETHOD(GetTerminalClassInfo)(
        /*[in]*/    BSTR            bstrSuperclass
        );
private:
    CMSPCritSection     m_CritSect;     // Critical Section 
    CPTTerminal         m_Terminal;     // Terminal stuff
    IUnknown*            m_pFTM;         // pointer to the free threaded marshaler
};

//
// CPlugTerminalSuperclass implements ITPTRegTerminalClass interface
//
class ATL_NO_VTABLE CPlugTerminalSuperclass : 
    public CComCoClass<CPlugTerminalSuperclass, &CLSID_PluggableSuperclassRegistration>,
    public IDispatchImpl<ITPluggableTerminalSuperclassRegistration, &IID_ITPluggableTerminalSuperclassRegistration, &LIBID_TERMMGRLib>,
    public CComObjectRootEx<CComMultiThreadModel>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_PTREGTERMCLASS)
DECLARE_NOT_AGGREGATABLE(CPlugTerminalSuperclass) 
DECLARE_GET_CONTROLLING_UNKNOWN()

virtual HRESULT FinalConstruct(void);


BEGIN_COM_MAP(CPlugTerminalSuperclass)
    COM_INTERFACE_ENTRY(ITPluggableTerminalSuperclassRegistration)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

public:
    CPlugTerminalSuperclass() :
        m_pFTM(NULL)
    {
    }

    ~CPlugTerminalSuperclass()
    {
        if( m_pFTM )
        {
            m_pFTM->Release();
            m_pFTM = NULL;
        }
    }

public:
    STDMETHOD(get_Name)(
        /*[out, retval]*/ BSTR*          pName
        );

    STDMETHOD(put_Name)(
        /*[in]*/          BSTR            bstrName
        );

    STDMETHOD(get_CLSID)(
        /*[out, retval]*/ BSTR*           pCLSID
        );

    STDMETHOD(put_CLSID)(
        /*[in]*/         BSTR            bstrCLSID
        );

    STDMETHOD(Add)(
        );

    STDMETHOD(Delete)(
        );

    STDMETHOD(GetTerminalSuperclassInfo)(
        );

    STDMETHOD(get_TerminalClasses)(
        /*[out, retval]*/ VARIANT*         pTerminals
        );

    STDMETHOD(EnumerateTerminalClasses)(
        OUT IEnumTerminalClass** ppTerminals
        );


private:
    CMSPCritSection     m_CritSect;     // Critical Section 
    CPTSuperclass       m_Superclass;   // Terminal superclass
    IUnknown*            m_pFTM;         // pointer to the free threaded marshaler
};


#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\newmes.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/


#include "stdafx.h"
#include "atlconv.h"
#include "termmgr.h"
#include "meterf.h"
#include "newmes.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// These will be obsolete when we derive from CSingleFilterTerminal

HRESULT CMediaTerminal::GetNumExposedPins(
        IN   IGraphBuilder * pGraph,
        OUT  DWORD         * pdwNumPins)
{
    LOG((MSP_TRACE, "CMediaTerminal::GetNumExposedPins - enter"));

    //
    // We ignote pGraph because we don't need to do anything special to find
    // out how many pins we have.
    //

    *pdwNumPins = 1;
    
    LOG((MSP_TRACE, "CMediaTerminal::GetNumExposedPins - exit S_OK"));

    return S_OK;
}

HRESULT CMediaTerminal::GetExposedPins(
        OUT    IPin  ** ppPins
        )
{
    LOG((MSP_TRACE, "CMediaTerminal::GetExposedPins - enter"));

    TM_ASSERT( ! TM_IsBadWritePtr(ppPins, 1 * sizeof(IPin *) ) );

    //
    // Return our single pin.
    //

    *ppPins = m_pOwnPin;
    (*ppPins)->AddRef();

    LOG((MSP_TRACE, "CMediaTerminal::GetExposedPins - exit S_OK"));
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



// for CLSID_MediaStreamFilter
// "amguids.h" has the guid value 
// but requires #define INITGUID before including compobj.h
EXTERN_C const GUID CLSID_MediaStreamFilter = { 
    0x49c47ce0,
    0x9ba4,
    0x11d0,
    {0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45}
};


// this is used for indexing into the friendly name array
// it is needed because neither the tapi media type (string guid) nor
// the IMediaStream media consts (not an enum) can be used
enum MEDIA_STREAM_TERMINAL_MEDIA 
{
    MEDIA_STREAM_TERMINAL_AUDIO=0, 
    MEDIA_STREAM_TERMINAL_VIDEO
};

// the MEDIA_STREAM_TERMINAL_MEDIA and TERMINAL_DIRECTION values are used as 
// indices into this array to determine the friendly name
// these should ideally be const WCHAR *, but the base class member m_szName is
// a pointer to BSTR (should be const WCHAR * as per current usage)
DWORD gs_MSTFriendlyName[2][2] = 
{
    {    
        IDS_MSTR_AUDIO_WRITE,    // capture
        IDS_MSTR_AUDIO_READ,     // render
    },
    {
        IDS_MSTR_VIDEO_WRITE,    // capture
        IDS_MSTR_VIDEO_READ,     // render
    }
};


// CMediaTerminal


STDMETHODIMP CMediaTerminal::InitializeDynamic (
	    IN   IID                   iidTerminalClass,
	    IN   DWORD                 dwMediaType,
	    IN   TERMINAL_DIRECTION    Direction,
        IN   MSP_HANDLE            htAddress
        )
{
    LOG((MSP_TRACE, "CMediaTerminal::Initialize - enter"));

    //
    // We are OK with either direction. Just do the base class method...
    //

    HRESULT hr;
    hr = CBaseTerminal::Initialize(iidTerminalClass,
                                   dwMediaType,
                                   Direction,
                                   htAddress);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
                "base class method failed - returning 0x%08x", hr));

        return hr;
    }

    //
    // Now do our own initialization:
    //
    // sets certain member variables
    // ex. m_TerminalType, m_szName
    // initialize the aggregated filter
    //

    MSPID       PurposeId;
    STREAM_TYPE StreamType;
    const GUID  *pAmovieMajorType;     

    // uses pTapiMediaType, TerminalDirection to determine the 
    // purpose id and stream type. 
    // sets PurposeId, StreamType, pAmovieMajorType among others
    hr = SetNameInfo(
                     (long) dwMediaType,
                     Direction, 
                     PurposeId, 
                     StreamType,
                     pAmovieMajorType
                     );
    BAIL_ON_FAILURE(hr);
    ASSERT(NULL != pAmovieMajorType);

    // initialize the aggregated filter
    ASSERT(NULL != m_pAggTerminalFilter);
    hr = m_pAggTerminalFilter->Init(PurposeId, StreamType, *pAmovieMajorType);
    BAIL_ON_FAILURE(hr);

    LOG((MSP_TRACE, "CMediaTerminal::Initialize - exit S_OK"));
    return S_OK;
}


// free the allocated member variables 
HRESULT
CMediaTerminal::FinalConstruct(
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::FinalConstruct called"));

    HRESULT hr;
    m_pAggInstance = new FILTER_COM_OBJECT(GetControllingUnknown());
    BAIL_IF_NULL(m_pAggInstance, E_OUTOFMEMORY);

    hr = m_pAggInstance->FinalConstruct();
    if (HRESULT_FAILURE(hr))
    {
        // delete the aggregating instance
        delete m_pAggInstance;
        return hr;
    }


    // we get the nondelegating IUnknown i/f of the aggregating shell
    // around the contained object. keep this refcnt around during our
    // lifetime
    hr = m_pAggInstance->QueryInterface(
                IID_IUnknown, 
                (void **)&m_pIUnkTerminalFilter
                );

    if ( FAILED(hr) )
    {
        // must call final release
        m_pAggInstance->FinalRelease();

        // delete the aggregating instance
        delete m_pAggInstance;
        return hr;
    }

    // these query interface calls increase our own refcnt
    // release the refcnt as soon as the interface is obtained
    // these shouldn't be CComPtrs as they are weak references

    hr = m_pAggInstance->QueryInterface(
                IID_IPin, 
                (void **)&m_pOwnPin
                );

    if ( FAILED(hr) )
    {
        goto error;
    }

    if (NULL != m_pOwnPin)
    {
        m_pOwnPin->Release();
    }

    hr = m_pAggInstance->QueryInterface(
            IID_IAMMediaStream, 
            (void **)&m_pIAMMediaStream
            );

    if ( FAILED(hr) )
    {
        goto error;
    }

    if (NULL != m_pIAMMediaStream)
    {
        m_pIAMMediaStream->Release();
    }

    // point m_pAggTerminalFilter to the contained member of the
    // aggregating instance
    m_pAggTerminalFilter = &m_pAggInstance->m_contained;

    LOG((MSP_TRACE, "CMediaTerminal::FinalConstruct succeeded"));
    return S_OK;

error:  // we come here in case of errors after calling FinalConstruct

    ASSERT( FAILED(hr) );

    // final release the aggregating shell
    ASSERT(NULL != m_pAggInstance);
    m_pAggInstance->FinalRelease();

    // null any CComPtrs
    // this should destroy the aggregated instance and the contained 
    // media terminal filter
    m_pIUnkTerminalFilter = NULL;

    LOG((MSP_TRACE, "CMediaTerminal::FinalConstruct failed"));
    return hr;
}


void 
CMediaTerminal::FinalRelease(
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::FinalRelease called"));

    // final release the aggregating shell
    ASSERT(NULL != m_pAggInstance);
    m_pAggInstance->FinalRelease();

    // null any CComPtrs
    // this should destroy the aggregating instance and the contained
    // media terminal filter
    m_pIUnkTerminalFilter = NULL;

    LOG((MSP_TRACE, "CMediaTerminal::FinalRelease succeeded"));
}

// we only have a destructor with debug bits
#ifdef DEBUG

// free the allocated member variables 
// virtual
CMediaTerminal::~CMediaTerminal(
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::~CMediaTerminal called"));
}

#endif // DEBUG

// point to the m_ppTapiMediaType, 
// copies friendly name into m_szName
void 
CMediaTerminal::SetMemberInfo(
    IN  DWORD           dwFriendlyName,
    IN  long            lMediaType
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::SetMemberInfo(%d, &(%l)) called", \
        dwFriendlyName,lMediaType));

    // copy the friendly terminal name into the member name
    // the max number of TCHARs to copy is MAX_PATH+1 (it includes
    // the terminating NULL character)
    TCHAR szTemp[MAX_PATH];
    if (::LoadString(_Module.GetResourceInstance(), dwFriendlyName, szTemp, MAX_PATH))
    {
        lstrcpyn(m_szName, szTemp, MAX_PATH);
    }
    else
    {
        LOG((MSP_ERROR, "CMediaTerminal::SetMemberInfo (LoadString) failed"));
    }

    m_lMediaType = lMediaType;

    LOG((MSP_TRACE, "CMediaTerminal::SetMemberInfo(%d, &(%d)) succeeded", \
        dwFriendlyName,lMediaType));
};

// uses the purpose id and the stream type to figure out the name 
// and terminal class id.
// sets PurposeId, StreamType, m_szName, m_TerminalClassID
// m_ppTapiMediaType, m_TerminalType, m_TerminalDirection
HRESULT 
CMediaTerminal::SetNameInfo(
    IN  long                lMediaType,
    IN  TERMINAL_DIRECTION  TerminalDirection,
    OUT MSPID               &PurposeId,
    OUT STREAM_TYPE         &StreamType,
    OUT const GUID          *&pAmovieMajorType
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::SetNameInfo(%d, %u, %p, %p, %p) called", \
        lMediaType, TerminalDirection, &PurposeId, &StreamType, pAmovieMajorType));

    //
    // Check arguments
    //

    if ( ( TerminalDirection != TD_CAPTURE ) &&
         ( TerminalDirection != TD_RENDER )     )
    {
        return E_INVALIDARG;
    }

    // set the stream type
    // if its a capture terminal, the user has to write the samples
    StreamType      = (TD_CAPTURE == TerminalDirection)? STREAMTYPE_WRITE : STREAMTYPE_READ;

    if (lMediaType == TAPIMEDIATYPE_AUDIO)
    {
        // set the PurposeId, major media type
        PurposeId           = MSPID_PrimaryAudio;
        pAmovieMajorType    = &MEDIATYPE_Audio;

        // copy the name and point to the tapi media type
        SetMemberInfo(
            gs_MSTFriendlyName[MEDIA_STREAM_TERMINAL_AUDIO][TerminalDirection], 
            TAPIMEDIATYPE_AUDIO
            );
    }
    else if (lMediaType == TAPIMEDIATYPE_VIDEO)
    {
        // set the PurposeId, major media type
        PurposeId           = MSPID_PrimaryVideo;
        pAmovieMajorType    = &MEDIATYPE_Video;

        // copy the name and point to the tapi media type
        SetMemberInfo(
            gs_MSTFriendlyName[MEDIA_STREAM_TERMINAL_VIDEO][TerminalDirection], 
            TAPIMEDIATYPE_VIDEO
            );
    }
    else
    {
        return E_INVALIDARG;
    }

    // its a dynamic terminal
    m_TerminalType  = TT_DYNAMIC;

    LOG((MSP_TRACE, "CMediaTerminal::SetNameInfo[%p] (%u, %u, %p, %p, %p) succeeded", \
        this, lMediaType, TerminalDirection, &PurposeId, &StreamType, pAmovieMajorType));
    
    return S_OK;
}


// implement using the aggregated filter's public GetFormat method
STDMETHODIMP
CMediaTerminal::GetFormat(
    OUT  AM_MEDIA_TYPE **ppmt
    )
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CMediaTerminal::GetFormat(%p) called", ppmt));

    return m_pAggTerminalFilter->GetFormat(ppmt);
}

    
// implement using the aggregated filter's public SetFormat method
STDMETHODIMP
CMediaTerminal::SetFormat(
    IN  AM_MEDIA_TYPE *pmt
    )
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CMediaTerminal::SetFormat(%p) called", pmt));
    return m_pAggTerminalFilter->SetFormat(pmt);
}


// an IAMBufferNegotiation method - passed to our filter
STDMETHODIMP
CMediaTerminal::GetAllocatorProperties(
    OUT  ALLOCATOR_PROPERTIES *pProperties
    )
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CMediaTerminal::GetAllocatorProperties(%p) called", pProperties));
    return m_pAggTerminalFilter->GetAllocatorProperties(pProperties);
}

    
// an IAMBufferNegotiation method - used to be not implemented
// but now we must return S_OK to work with IP
STDMETHODIMP
CMediaTerminal::SuggestAllocatorProperties(
    IN  const ALLOCATOR_PROPERTIES *pProperties
    )
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CMediaTerminal::SuggestAllocatorProperties - enter"));

    HRESULT hr = m_pAggTerminalFilter->SuggestAllocatorProperties(pProperties);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMediaTerminal::SuggestAllocatorProperties - "
            "method on filter failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CMediaTerminal::SuggestAllocatorProperties - exit S_OK"));

    return S_OK;
}


// since there is only one filter in this base class implementation (i.e. the two
// ends of the terminal have the same media format), both of
// the get and set methods are redirected to Get/Set Format
STDMETHODIMP 
CMediaTerminal::get_MediaFormat(
    OUT  AM_MEDIA_TYPE **ppFormat
    )
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CMediaTerminal::get_MediaFormat(%p) called", ppFormat));
    return GetFormat(ppFormat);
}


// cast the input format to a non-const as we know that we won't change the struct
// in SetFormat (this problem exists because IAMStreamConfig::SetFormat expects a
// non-const). this saves creating, copying and then destroying a struct for this call
STDMETHODIMP 
CMediaTerminal::put_MediaFormat(
        IN  const AM_MEDIA_TYPE *pFormat
    )
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CMediaTerminal::put_MediaFormat(%p) called", pFormat));
    return SetFormat((AM_MEDIA_TYPE *)pFormat);
}


HRESULT 
CMediaTerminal::CreateAndJoinMediaStreamFilter(
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::CreateAndJoinMediaStreamFilter called"));

    ASSERT(m_pICreatedMediaStreamFilter == NULL);

    // in case of an error at any stage, no clean-up of member variables
    // or filter logic (JoinFilter(NULL) etc.) needs to be done as the
    // driving CBaseTerminal::ConnectTerminal would call DisconnectTerminal
    // which performs that work

    // create the media stream filter
    HRESULT hr;
    hr = CoCreateInstance(
                 CLSID_MediaStreamFilter,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_IMediaStreamFilter,
                 (void **)&m_pICreatedMediaStreamFilter
                );
    BAIL_ON_FAILURE(hr);

    hr = m_pICreatedMediaStreamFilter->QueryInterface(
            IID_IBaseFilter, (void **)&m_pBaseFilter
            );
    BAIL_ON_FAILURE(hr);

    // tell the aggregated filter of our media stream filter, so that
    // it can reject any other media stream filter if proposed
    m_pAggTerminalFilter->SetMediaStreamFilter(m_pICreatedMediaStreamFilter);

    // add the IAMMediaStream i/f of the aggregated terminal filter
    // to the media stream filter
    hr = m_pICreatedMediaStreamFilter->AddMediaStream(m_pIAMMediaStream);
    BAIL_ON_FAILURE(hr);

    LOG((MSP_TRACE, "CMediaTerminal::CreateAndJoinMediaStreamFilter succeeded"));    
    return S_OK;
}


// if m_pFilter is null, return error
// add m_pFilter to graph
HRESULT 
CMediaTerminal::AddFiltersToGraph(
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::AddFiltersToGraph called"));

    HRESULT hr;
    hr = CreateAndJoinMediaStreamFilter();
    BAIL_ON_FAILURE(hr);

    ASSERT(m_pGraph != NULL);

    BAIL_IF_NULL(m_pBaseFilter, MS_E_NOTINIT);

    try 
    {
        USES_CONVERSION;
        hr = m_pGraph->AddFilter(m_pBaseFilter, T2CW(m_szName));
    }
    catch (...)
    {
        LOG((MSP_ERROR, "CMediaTerminal::AddFiltersToGraph - T2CW threw an exception - "
            "return E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    if ( ( hr != S_OK ) && ( VFW_S_DUPLICATE_NAME != hr ) )
    {
        return hr;
    }

    LOG((MSP_TRACE, "CMediaTerminal::AddFiltersToGraph succeeded"));
    return S_OK;
}


// if m_pFilter is null, return success
// remove m_pFilter from graph 
HRESULT
CMediaTerminal::RemoveFiltersFromGraph(
    )
{
    LOG((MSP_TRACE, "CMediaTerminal::RemoveFiltersFromGraph called"));

    // the base filter is set when CreateAndJoinMediaStreamFilter succeeds
    // in it, the media stream filter is created and the IAMMediaStream 
    // interface is added to the filter. During addition, the media stream filter
    // calls JoinFilter on the IAMMediaStream and thus sets the m_pBaseFilter

    HRESULT hr = S_OK;
    if ((m_pGraph != NULL) && (m_pBaseFilter != NULL)) 
    { 
        hr = m_pGraph->RemoveFilter(m_pBaseFilter);
    }

    // inform the aggregate media terminal filter that we don't have a
    // media stream filter any longer
    m_pAggTerminalFilter->SetMediaStreamFilter(NULL);
 
    // remove associated properties of the media stream filter
    m_pIAMMediaStream->JoinFilter(NULL);
    m_pIAMMediaStream->JoinFilterGraph(NULL);
   
    // null m_pBaseFilter and m_pICreatedMediaStreamFilter 
    // which hold the last reference to the filter
    m_pBaseFilter = NULL;
    m_pICreatedMediaStreamFilter = NULL;

    return hr;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\stdafx.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

//
// stdafx.h: Precompiled header file for termmgr.dll
//

#ifndef __TERMMGR_STDAFX_H__
#define __TERMMGR_STDAFX_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

//
// MSP base classes (terminal base classes, etc.)
//

#include <mspbase.h>

//
// Multimedia and DirectShow stuff.
//

#include <mmsystem.h>
#include <mmreg.h>
#include <control.h>
#include <mmstream.h>
#include <amstream.h>
#include <strmif.h>
#include <vfwmsgs.h>
#include <amvideo.h>
#include <uuids.h>
#include <mtype.h>


//
// Termmgr.dll's own private headers
//


//
// tm.h contains definitions shared throughout modules composing terminal manager
//

#include "tm.h"

#include "stream.h"
#include "sample.h"
#include "mtenum.h"
#include "tmutils.h"

#define TM_IsBadWritePtr(x, y) IsBadWritePtr((x), (y))

#endif // __TERMMGR_STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\resource.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by termmgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_TERMINALMANAGER_DESC        101
#define IDR_TerminalManager             102
#define IDR_VideoRenderTerminal         103
#define IDR_MediaStreamingTerminal      104
#define IDS_VIDREND_DESC                105
#define IDS_MICROSOFT_SOUND_MAPPER      106
#define IDS_MSTR_AUDIO_WRITE            107
#define IDS_MSTR_AUDIO_READ             108
#define IDS_MSTR_VIDEO_WRITE            109
#define IDS_MSTR_VIDEO_READ             110
#define IDR_PTREGTERMCLASS              111
#define IDR_PTREGTERMINAL               112

#define IDR_FILE_RECORDING              120
#define IDS_FR_TERMINAL_NAME            121
#define IDS_FR_TRACK_NAME               122

#define IDR_FILE_PLAYBACK               130

#define IDS_FPTERMINAL                  150
#define IDS_FPTRACK                     151

#define IDS_VIDEO_SUPERCLASS            160
#define IDS_STREAMING_SUPERCLASS        161
#define IDS_FILE_SUPERCLASS             162


//
// strings for video window terminal
//

#define IDS_VIDEO_WINDOW_TERMINAL_NAME          180
#define IDS_TERMINAL_COMPANY_NAME_MICROSOFT     181
#define IDS_VIDEO_TERMINAL_VERSION              182


//
// strings for the mst
//

#define IDS_MEDIA_STREAMING_TERMINAL_NAME       183
#define IDS_MEDIA_STREAMING_TERMINAL_VERSION    184


//
// strings for file playback
//

#define IDS_FILE_PLAYBACK_TERMINAL_NAME         185
#define IDS_FILE_PLAYBACK_TERMINAL_VERSION      186


//
// strings for file record
//

#define IDS_FILE_RECORD_TERMINAL_NAME           187
#define IDS_FILE_RECORD_TERMINAL_VERSION        188


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\ptutil.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __PTUTIL__
#define __PTUTIL__

///////////////////////////////////////////
// Constants
//
#define PTKEY_TERMINALS     TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Terminal Manager")
#define PTKEY_NAME          TEXT("Name")
#define PTKEY_COMPANY       TEXT("Company")
#define PTKEY_VERSION       TEXT("Version")
#define PTKEY_DIRECTIONS    TEXT("Directions")
#define PTKEY_MEDIATYPES    TEXT("MediaTypes")
#define PTKEY_CLSIDCREATE   TEXT("CLSID")

#define PTKEY_MAXSIZE           256

///////////////////////////////////////////
// CPTUtil
//

class CPTTerminal;

class CPTUtil
{
public:

private:
    static HRESULT RecursiveDeleteKey(
        IN  HKEY    hKey,
        IN  BSTR    bstrKeyChild
        );

    static HRESULT ListTerminalSuperclasses(
        OUT CLSID** ppCLSIDs,
        OUT DWORD*  pdwCount
        );

    static HRESULT SearchForTerminal(
        IN  IID     iidTerminal,
        IN  DWORD   dwMediaType,
        IN  TERMINAL_DIRECTION  Direction,
        OUT CPTTerminal*        pTerminal
        );

    static HRESULT FindTerminal(
        IN  CLSID               clsidSuperclass,
        IN  CLSID               clsidTerminal,
        IN  DWORD               dwMediaType,
        IN  TERMINAL_DIRECTION  Direction,
        IN  BOOL                bExact,
        OUT CPTTerminal*        pTerminal
        );

    static HRESULT ListTerminalClasses(
        IN  DWORD   dwMediaTypes,
        OUT CLSID** ppTerminalsClasses,
        OUT DWORD*  pdwCount
        );


friend class CPTSuperclass;
friend class CPTTerminal;
friend class CPTRegControl;
friend class CTerminalManager;
};

///////////////////////////////////////////
// CPTTerminal
//

class CPTTerminal
{
public:
    // Constructor/destructor
    CPTTerminal();
    ~CPTTerminal();

public:
    // Attributes
    BSTR    m_bstrName;             // Terminal name
    BSTR    m_bstrCompany;          // Company name
    BSTR    m_bstrVersion;          // Terminal version

    CLSID   m_clsidTerminalClass;   // Public terminal CLSID
    CLSID   m_clsidCOM;             // Terminal CLSID used by CoCreate

    DWORD   m_dwDirections;         // Terminal directions
    DWORD   m_dwMediaTypes;         // Media types supported

public:
    // Methods
    HRESULT Add(
        IN  CLSID    clsidSuperclass
        );

    HRESULT Delete(
        IN  CLSID    clsidSuperclass
        );

    HRESULT Get(
        IN  CLSID   clsidSuperclass
        );

    CPTTerminal& operator=(const CPTTerminal& term)
    {
        m_dwDirections = term.m_dwDirections;
        m_dwMediaTypes = term.m_dwMediaTypes;

        m_bstrName = SysAllocString( term.m_bstrName);
        m_bstrCompany = SysAllocString( term.m_bstrCompany);
        m_bstrVersion = SysAllocString( term.m_bstrVersion);

        m_clsidTerminalClass = term.m_clsidTerminalClass;
        m_clsidCOM = term.m_clsidCOM;

        return *this;
    }
};

///////////////////////////////////////////
// CPTTerminalClass
//

class CPTSuperclass
{
public:
    // Constructor/Destructor
    CPTSuperclass();
    ~CPTSuperclass();

public:
    // Attributes
    BSTR    m_bstrName;         // Terminal superclass name
    CLSID   m_clsidSuperclass;  // Teminal superclass CLSID

public:
    // Methods
    HRESULT Add();              // Add/edit a terminal class
    HRESULT Delete();           // Delete a terminal class
    HRESULT Get();              // Get all the information

    // Lists all child terminals
    HRESULT ListTerminalClasses(  
        IN  DWORD    dwMediaTypes,
        OUT CLSID**  ppTerminals,
        OUT DWORD*   pdwCount
        );
};

#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\sample.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/


// Sample.cpp: implementation of the Sample class.
//
//////////////////////////////////////////////////////////////////////


/*
      Overview of handling of sample states
      -------------------------------------


      A sample can be in one of the following states:

      -- Application - Application owned - not updated
      -- Stream owned (in our queue)
      -- Owned by a filter for update

      The state can only change under the protection of the stream
      critical section.

      Stealing a sample occurs on WaitForCompletion with NOUPDATEOK or
      ABORT specified.

      Also, not that WaitForCompletion turns off continuous updates
      if and of the 3 flags are set.


      Action

Owner            Update    GetBuffer    Receive      Release     Steal
               completion                            sample
  ---------------------------------------------------------------------------
  Application    Note 3    Impossible   Impossible   Impossible  Application
  ---------------------------------------------------------------------------
  Stream         Invalid   Filter       Impossible   Impossible  Application
  ---------------------------------------------------------------------------
  Filter         Invalid   Impossible   Note 1       Note 2      Filter
  ---------------------------------------------------------------------------

  Notes:
      1.  New owner is
          Stream for continuous update
          Application otherwise

      2.  New owner is
          Application if at end of stream or abort
          Stream otherwise

      3.  If at end of stream status is MS_S_ENDOFSTREAM


*/

#include "stdafx.h"


CSample::CSample() :
    m_pStream(NULL),
    m_pMediaSample(NULL),
    m_hUserHandle(NULL),
    m_UserAPC(NULL),
    m_Status(S_OK),
    m_MediaSampleIoStatus(S_OK),
    m_pNextFree(NULL),
    m_pPrevFree(NULL),
    m_hCompletionEvent(NULL),
    m_bReceived(false),
    m_bTemp(false)
{
    LOG((MSP_TRACE, "CSample::CSample[%p] - enter", this));
    LOG((MSP_TRACE, "CSample::CSample - exit"));
}

HRESULT CSample::InitSample(CStream *pStream, bool bIsInternalSample)
{
    // this check at beginning apparently added by Rajeev
    TM_ASSERT(NULL != pStream);
    
    if ( pStream == NULL )
    {
        return E_INVALIDARG;
    }

    // original DShow code starts here
    if (!m_pMediaSample) {
        m_pMediaSample = new CMediaSampleTM(this);
        if (!m_pMediaSample) {
            return E_OUTOFMEMORY;
        }
    }
    m_pStream = pStream;
    m_bInternal = bIsInternalSample;
    if (!bIsInternalSample) {
    pStream->Lock();
    pStream->m_cAllocated++;
    pStream->Unlock();
    //
    //  Hold a strong reference to the stream and the multi media stream.
    //  The pMMStream can not change once we have incremented m_cAllocted on the stream, so we're sure that this
    //  addref and the final release of the multi-media stream won't change.
    //
    pStream->GetControllingUnknown()->AddRef();
        if (pStream->m_pMMStream) {
            pStream->m_pMMStream->AddRef();
        }
    }


    TCHAR *ptczEventName = NULL;

#if DBG

    //
    // in debug build, use named events
    //

    TCHAR tszEventName[MAX_PATH];

    _stprintf(tszEventName,
        _T("CSample_CompletionEvent_pid[0x%lx]_CStream[%p]_"),
        GetCurrentProcessId(), this);

    ptczEventName = &tszEventName[0];

#endif

    TM_ASSERT(NULL == m_hCompletionEvent);

    m_hCompletionEvent = CreateEvent(NULL, FALSE, TRUE, ptczEventName);
    return m_hCompletionEvent ? S_OK : E_OUTOFMEMORY;
}

void CSample::FinalRelease(void)
{
    CompletionStatus(COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE);
}

CSample::~CSample()
{
    LOG((MSP_TRACE, "CSample::~CSample[%p] - enter", this));

    CompletionStatus(COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT, 0);
    if (m_hCompletionEvent) {
    CloseHandle(m_hCompletionEvent);
    }
    if (!m_bInternal) {
    m_pStream->Lock();
        IMultiMediaStream *pMMStream = m_pStream->m_pMMStream;
    m_pStream->m_cAllocated--;
    if (m_pStream->m_bStopIfNoSamples && m_pStream->m_cAllocated == 0) {
        if (m_pStream->m_pAllocator) {
            m_pStream->m_pAllocator->Decommit();
        }
    }
    m_pStream->Unlock();    // Unlock it before we release it!
        if (pMMStream) {
            pMMStream->Release();
        }
    m_pStream->GetControllingUnknown()->Release();
    }
    if (m_pMediaSample) {
        delete m_pMediaSample;
    }

    LOG((MSP_TRACE, "CSample::~CSample - exit"));
}

//
// IStreamSample
//
STDMETHODIMP CSample::GetMediaStream(IMediaStream **ppMediaStream)
{
    LOG((MSP_TRACE, "IStreamSample::GetMediaStream(%p)",
                   ppMediaStream));
    *ppMediaStream = m_pStream;
    (*ppMediaStream)->AddRef();
    return S_OK;
}

STDMETHODIMP CSample::GetSampleTimes(STREAM_TIME *pStartTime, STREAM_TIME *pEndTime,
                     STREAM_TIME *pCurrentTime)
{
    LOG((MSP_TRACE, "IStreamSample::GetSampleTimes(%p, %p, %p)",
                   pStartTime, pEndTime, pCurrentTime));

    REFERENCE_TIME rtSegmentStart = m_pStream->m_rtSegmentStart;
    m_pMediaSample->GetTime(pStartTime, pEndTime);
    if (pStartTime) {
    *pStartTime += rtSegmentStart;
    }
    if (pEndTime) {
    *pEndTime += rtSegmentStart;
    }


    HRESULT hr = S_OK;

    if (pCurrentTime) 
    {

        //
        // if the filter is still around, ask it for stream time
        //

        m_pStream->Lock();

        if (NULL != m_pStream->m_pFilter)
        {
            m_pStream->m_pFilter->GetCurrentStreamTime(pCurrentTime);
        }
        else
        {
            LOG((MSP_WARN, "CSample::GetSampleTimes - m_pStream->m_pFilter is NULL. returning VFW_E_NOT_IN_GRAPH"));

            hr = VFW_E_NOT_IN_GRAPH;
        }

        m_pStream->Unlock();

     }

    return hr;
}

STDMETHODIMP CSample::SetSampleTimes(const STREAM_TIME *pStartTime, const STREAM_TIME *pEndTime)
{
    LOG((MSP_TRACE, "IStreamSample::SetSampleTimes(%p, %p)",
                   pStartTime, pEndTime));
    /*  Only settable for writable streams */
    if (m_pStream->m_StreamType != STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    /*  Since writable streams can't be seeked we don't need to
        compensate here for any seek offsets
    */
    return m_pMediaSample->SetTime((REFERENCE_TIME *)pStartTime, (REFERENCE_TIME *)pEndTime);
}

STDMETHODIMP CSample::Update(DWORD dwFlags, HANDLE hEvent, PAPCFUNC pfnAPC, DWORD_PTR dwAPCData)
{
    LOG((MSP_TRACE, "IStreamSample::Update(0x%8.8X, %p, %p, %p)",
                   dwFlags, hEvent, pfnAPC, dwAPCData));
    LOCK_SAMPLE;
    HRESULT hr = InternalUpdate(dwFlags, hEvent, pfnAPC, dwAPCData);
    UNLOCK_SAMPLE;
    if (S_OK == hr) {
    hr = CompletionStatus(COMPSTAT_WAIT, INFINITE);
    }
    return hr;
}


void CSample::FinalMediaSampleRelease(void)
{
    if (m_bTemp) {
        GetControllingUnknown()->Release();
        return;
    }
    LOCK_SAMPLE;
    HRESULT hrStatus = m_MediaSampleIoStatus;
    if (hrStatus != S_OK) {
    m_MediaSampleIoStatus = S_OK;    // Reset this here so we don't need to reset it every time.
    } else {
    if (!m_bReceived) {
        if (m_pStream->m_bEndOfStream) {
        hrStatus = MS_S_ENDOFSTREAM;
        } else {
        if (m_bWantAbort) {
            m_bWantAbort = false;
            hrStatus = E_ABORT;
        } else {
            // Upstream guy just allocated the sample and never used it! -- Keep it pending.
            hrStatus = MS_S_PENDING;
        }
        }
    }
    }
    UNLOCK_SAMPLE;
    SetCompletionStatus(hrStatus);
    // DANGER!  Sample may be dead right here
}



//
//  Set the sample's status and signal completion if necessary.
//
//  Note that when the application has been signalled by whatever method
//  the application can immediately turn around on another thread 
//  and Release() the sample.  This is most likely when the completion
//  status is set from the quartz thread that's pushing the data.
//
//  Should we actually keep a reference count on the sample ourselves while
//  it's being updated?  Currently we don't.
//
HRESULT CSample::SetCompletionStatus(HRESULT hrStatus)
{
    LOCK_SAMPLE;
    TM_ASSERT(m_Status == MS_S_PENDING);
    if (hrStatus == MS_S_PENDING || (hrStatus == S_OK && m_bContinuous)) {
    m_pStream->AddSampleToFreePool(this);
        UNLOCK_SAMPLE;
    } else {
    HANDLE handle = m_hUserHandle;
    PAPCFUNC pfnAPC = m_UserAPC;
    DWORD_PTR dwAPCData = m_dwptrUserAPCData;
    m_hUserHandle = m_UserAPC = NULL;
    m_dwptrUserAPCData = 0;
    m_Status = hrStatus;
        HANDLE hCompletionEvent = m_hCompletionEvent;
        UNLOCK_SAMPLE;

        //  DANGER DANGER - sample can go away here
    SetEvent(hCompletionEvent);
    if (pfnAPC) {
        QueueUserAPC(pfnAPC, handle, dwAPCData);
            BOOL bClose = CloseHandle(handle);
            TM_ASSERT(bClose);
    } else {
        if (handle) {
        SetEvent(handle);
        }
    }
    }
    return hrStatus;
}


STDMETHODIMP CSample::CompletionStatus(DWORD dwFlags, DWORD dwMilliseconds)
{
    LOG((MSP_TRACE, "IStreamSample::CompletionStatus(0x%8.8X, 0x%8.8X)",
                   dwFlags, dwMilliseconds));
    LOCK_SAMPLE;
    HRESULT hr = m_Status;
    if (hr == MS_S_PENDING) {
    if (dwFlags & (COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT) ||
        (m_bContinuous && m_bModified && (dwFlags & COMPSTAT_WAIT))) {
        m_bContinuous = false;
        if (dwFlags & COMPSTAT_ABORT) {
        m_bWantAbort = true;    // Set this so we won't add it back to the free pool if released
        }
        if (m_pStream->StealSampleFromFreePool(this, dwFlags & COMPSTAT_ABORT)) {
        UNLOCK_SAMPLE;
        return SetCompletionStatus(m_bModified ? S_OK : MS_S_NOUPDATE);
        } // If doesn't work then return MS_S_PENDING unless we're told to wait!
    }
    if (dwFlags & COMPSTAT_WAIT) {
        m_bContinuous = false;  // Make sure it will complete!
        UNLOCK_SAMPLE;
        WaitForSingleObject(m_hCompletionEvent, dwMilliseconds);
        LOCK_SAMPLE;
        hr = m_Status;
    }
    }
    UNLOCK_SAMPLE;
    return hr;
}

void CSample::CopyFrom(CSample *pSrcSample)
{
    m_bModified = true;
    m_pMediaSample->m_rtStartTime = pSrcSample->m_pMediaSample->m_rtStartTime;
    m_pMediaSample->m_rtEndTime = pSrcSample->m_pMediaSample->m_rtEndTime;
    m_pMediaSample->m_dwFlags = pSrcSample->m_pMediaSample->m_dwFlags;
    m_pMediaSample->m_bIsPreroll = pSrcSample->m_pMediaSample->m_bIsPreroll;
}


void CSample::CopyFrom(IMediaSample *pSrcMediaSample)
{
    m_bModified = true;
    pSrcMediaSample->GetTime(&m_pMediaSample->m_rtStartTime, &m_pMediaSample->m_rtEndTime);
    m_pMediaSample->m_dwFlags = (pSrcMediaSample->IsSyncPoint() == S_OK) ? 0 : AM_GBF_NOTASYNCPOINT;
    m_pMediaSample->m_dwFlags |= (pSrcMediaSample->IsDiscontinuity() == S_OK) ? AM_GBF_PREVFRAMESKIPPED : 0;
    m_pMediaSample->m_bIsPreroll = (pSrcMediaSample->IsPreroll() == S_OK);
}





/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Implementation of IMediaSample
//


CMediaSampleTM::CMediaSampleTM(CSample *pSample) :
    m_pSample(pSample),
    m_cRef(0),
    m_dwFlags(0),
    m_bIsPreroll(FALSE),
    m_pMediaType(NULL),
    m_rtStartTime(0),
    m_rtEndTime(0)
{
    LOG((MSP_TRACE, "CMediaSampleTM::CMediaSampleTM[%p] - enter", this));

    LOG((MSP_TRACE, "CMediaSampleTM::CMediaSampleTM - exit"));
}

CMediaSampleTM::~CMediaSampleTM()
{
    LOG((MSP_TRACE, "CMediaSampleTM::~CMediaSampleTM[%p] - enter", this));

    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
    }

    LOG((MSP_TRACE, "CMediaSampleTM::~CMediaSampleTM - exit"));
}



STDMETHODIMP CMediaSampleTM::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid==IID_IUnknown || riid==IID_IMediaSample) {
    *ppv = (IMediaSample *)this;
    AddRef();
    return S_OK;
    }
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CMediaSampleTM::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMediaSampleTM::Release()
{
    long lRef = InterlockedDecrement(&m_cRef);
    if (lRef == 0) {
    m_pSample->FinalMediaSampleRelease();
    }
    return lRef;
}


STDMETHODIMP CMediaSampleTM::GetPointer(BYTE ** ppBuffer)
{
    return m_pSample->MSCallback_GetPointer(ppBuffer);
}

STDMETHODIMP_(LONG) CMediaSampleTM::GetSize(void)
{
    return m_pSample->MSCallback_GetSize();
}


// get the stream time at which this sample should start and finish.
// changed from original CMediaSampleTM code -- borrowed from amovie\sdk\classes\base\amfilter.cpp
STDMETHODIMP
CMediaSampleTM::GetTime(
    REFERENCE_TIME * pTimeStart,     // put time here
    REFERENCE_TIME * pTimeEnd
)
{
    if ( TM_IsBadWritePtr(pTimeStart, sizeof(REFERENCE_TIME) )) return E_INVALIDARG;
    if ( TM_IsBadWritePtr(pTimeEnd, sizeof(REFERENCE_TIME) )) return E_INVALIDARG;

    if (!(m_dwFlags & AM_SAMPLE_STOPVALID)) {
        if (!(m_dwFlags & AM_SAMPLE_TIMEVALID)) {
            return VFW_E_SAMPLE_TIME_NOT_SET;
        } else {
            *pTimeStart = m_rtStartTime;

            //  Make sure old stuff works
            *pTimeEnd = m_rtStartTime + 1;
            return VFW_S_NO_STOP_TIME;
        }
    }

    *pTimeStart = m_rtStartTime;
    *pTimeEnd = m_rtEndTime;
    return NOERROR;
}

// Set the stream time at which this sample should start and finish.
// NULL pointers means the time is reset
// changed from original CMediaSampleTM code -- borrowed from sdk\classes\base\amfilter.cpp
STDMETHODIMP
CMediaSampleTM::SetTime(
    REFERENCE_TIME * pTimeStart,
    REFERENCE_TIME * pTimeEnd
)
{
    if ( (pTimeStart != NULL) && IsBadReadPtr(pTimeStart, sizeof(REFERENCE_TIME) ) )
    {
        LOG((MSP_ERROR, "IMediaSample::SetTime - bad pointer pTimeStart"));
        return E_POINTER;
    }

    if ( (pTimeEnd != NULL) && IsBadReadPtr(pTimeEnd, sizeof(REFERENCE_TIME) ) )
    {
        LOG((MSP_ERROR, "IMediaSample::SetTime - bad pointer pTimeEnd"));
        return E_POINTER;
    }

    if ( pTimeStart == NULL ) {
        TM_ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~(AM_SAMPLE_TIMEVALID | AM_SAMPLE_STOPVALID);
    } else {
        if ( pTimeEnd == NULL ) {
            m_rtStartTime = *pTimeStart;
            m_dwFlags |= AM_SAMPLE_TIMEVALID;
            m_dwFlags &= ~AM_SAMPLE_STOPVALID;
        } else {
            TM_ASSERT(*pTimeEnd >= *pTimeStart);

            m_rtStartTime = *pTimeStart;
            m_rtEndTime = *pTimeEnd;
            m_dwFlags |= AM_SAMPLE_TIMEVALID | AM_SAMPLE_STOPVALID;
        }
    }
    return NOERROR;
}


STDMETHODIMP CMediaSampleTM::IsSyncPoint(void)
{
    return ((m_dwFlags & AM_GBF_NOTASYNCPOINT) ? S_FALSE : S_OK);
}

STDMETHODIMP CMediaSampleTM::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
    m_dwFlags &= (~AM_GBF_NOTASYNCPOINT);
    } else {
    m_dwFlags |= AM_GBF_NOTASYNCPOINT;
    }
    return NOERROR;
}


STDMETHODIMP CMediaSampleTM::IsPreroll(void)
{
    return (m_bIsPreroll ? S_OK : S_FALSE);
}

STDMETHODIMP CMediaSampleTM::SetPreroll(BOOL bIsPreroll)
{
    m_bIsPreroll = bIsPreroll;
    return S_OK;
}

STDMETHODIMP_(LONG) CMediaSampleTM::GetActualDataLength(void)
{
    return m_pSample->MSCallback_GetActualDataLength();
}

STDMETHODIMP CMediaSampleTM::SetActualDataLength(LONG lActual)
{
    return m_pSample->MSCallback_SetActualDataLength(lActual);
}


STDMETHODIMP CMediaSampleTM::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    if (m_pMediaType) {
    *ppMediaType = CreateMediaType(m_pMediaType);
        if (*ppMediaType) {
        return NOERROR;
        } else {
            return E_OUTOFMEMORY;
        }
    } else {
    *ppMediaType = NULL;
    return S_FALSE;
    }
}


STDMETHODIMP CMediaSampleTM::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    if ((!m_pMediaType && !pMediaType) ||
        (m_pMediaType && pMediaType && IsEqualMediaType(*m_pMediaType, *pMediaType))) {
        return S_OK;
    }
    if (!m_pSample->MSCallback_AllowSetMediaTypeOnMediaSample()) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
    }
    m_pMediaType = NULL;
    if (pMediaType) {
        m_pMediaType = CreateMediaType(pMediaType);
        if (!m_pMediaType) {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}


STDMETHODIMP CMediaSampleTM::IsDiscontinuity(void)
{
    return ((m_dwFlags & AM_GBF_PREVFRAMESKIPPED) ? S_OK : S_FALSE);
}

STDMETHODIMP CMediaSampleTM::SetDiscontinuity(BOOL bDiscontinuity)
{
    if (bDiscontinuity) {
    m_dwFlags |= AM_GBF_PREVFRAMESKIPPED;
    } else {
    m_dwFlags &= (~AM_GBF_PREVFRAMESKIPPED);
    }
    return NOERROR;
}

STDMETHODIMP CMediaSampleTM::GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd)
{
    return E_NOTIMPL; 
}

STDMETHODIMP CMediaSampleTM::SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\ptutil.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ptutil.cpp

Abstract:

    Implementation of Plug terminal registration classes.
--*/

#include "stdafx.h"
#include "PTUtil.h"
#include "manager.h"

///////////////////////////////////////////
// CPTUtil implementation
//


HRESULT CPTUtil::RecursiveDeleteKey(
    IN  HKEY    hKey,
    IN  BSTR    bstrKeyChild
    )
{
    LOG((MSP_TRACE, "CPTUtil::RecursiveDeleteKey - enter"));

    //
    // Validates the arguments
    //

    if( NULL == hKey )
    {
        LOG((MSP_TRACE, "CPTUtil::RecursiveDeleteKey exit -"
            "hKey was NULL"));
        return S_OK;
    }

    if( IsBadStringPtr( bstrKeyChild, (UINT)-1))
    {
        LOG((MSP_ERROR, "CPTUtil::RecursiveDeleteKey exit - "
            "bstrKeyChild invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Open the child key
    //

    HKEY hKeyChild;
    LONG lResult = RegOpenKeyEx(
        hKey,
        bstrKeyChild,
        0,
        KEY_ALL_ACCESS,
        &hKeyChild);

    if( ERROR_SUCCESS != lResult )
    {
        LOG((MSP_ERROR, "CPTUtil::RecursiveDeleteKey exit - "
            "RegOpenKeyEx failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Enumerate the descendents
    //

    FILETIME time;
    TCHAR szBuffer[PTKEY_MAXSIZE];
    DWORD dwSize = PTKEY_MAXSIZE;

    while( RegEnumKeyEx(
        hKeyChild,
        0,
        szBuffer,
        &dwSize,
        NULL,
        NULL,
        NULL,
        &time) == ERROR_SUCCESS)
    {
        //
        // Put the child name into a BSTR
        //

        BSTR bstrChild = SysAllocString(szBuffer);
        if( IsBadStringPtr( bstrChild, (UINT)(-1)) )
        {
           RegCloseKey(hKeyChild);

           LOG((MSP_ERROR, "CPTUtil::RecursiveDeleteKey exit - "
               "SysAllocString failed, return E_OUTOFMEMORY"));
           return E_OUTOFMEMORY;
        }

        //
        // Delete the child
        //

        HRESULT hr;
        hr = RecursiveDeleteKey(hKeyChild, bstrChild);

        //
        // Clean-up bstrChild
        //

        SysFreeString(bstrChild);

        if( FAILED(hr) )
        {
           RegFlushKey(hKeyChild);
           RegCloseKey(hKeyChild);

           LOG((MSP_ERROR, "CPTUtil::RecursiveDeleteKey exit - "
               "RecursiveDeleteKey failed, returns 0%08x", hr));
           return hr;
        }

        //
        // Reset the buffer size
        //

        dwSize = PTKEY_MAXSIZE;
    }

    //
    // Close the child
    //

    RegFlushKey(hKeyChild);
    RegCloseKey(hKeyChild);

    HRESULT hr;
    hr = RegDeleteKey( hKey, bstrKeyChild);
    RegFlushKey( hKey );
    
    LOG((MSP_TRACE, "CPTUtil::RecursiveDeleteKey - exit 0x%08x", hr));
    return hr;
}

HRESULT CPTUtil::ListTerminalSuperclasses(
    OUT CLSID**     ppSuperclasses,
    OUT DWORD*      pdwCount
    )
{
    LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( ppSuperclasses, sizeof(CLSID*)) )
    {
        LOG((MSP_ERROR, "CPTUtil::ListTerminalSuperclasses exit -"
            "pClasses invalid, returns E_POINTER"));
        return E_POINTER;
    }

    if( TM_IsBadWritePtr( pdwCount, sizeof(DWORD)) )
    {
        LOG((MSP_ERROR, "CPTUtil::ListTerminalSuperclasses exit -"
            "pClasses invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Initialize the output arguments
    //

    *ppSuperclasses = NULL;
    *pdwCount = 0;


    //
    // Get the key path for terminal class
    //

    WCHAR szKey[ 256 ];
    wsprintf( szKey, L"%s", PTKEY_TERMINALS );
    LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - "
        "TerminalsKey is %s", szKey));

    //
    // Open the terminal class key
    //

    HKEY hKey;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        KEY_READ,
        &hKey);


    //
    // Validates registry operation
    //

    if( ERROR_SUCCESS != lResult )
    {
        LOG((MSP_ERROR, "CPTUtil::ListTerminalSuperclasses exit - "
            "RegOpenKeyEx failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Create the buffer for the CLSIDs
    //

    DWORD dwArraySize = 8;
    CLSID* pCLSIDs = new CLSID[ dwArraySize ];
    if( pCLSIDs == NULL )
    {
        // Clean-up hKey
        RegCloseKey( hKey );

        LOG((MSP_ERROR, "CPTUtil::ListTerminalSuperclasses exit - "
            "new operator failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Enumerate the descendents
    //

    HRESULT hr = S_OK;              // The error code
    FILETIME time;                  // We need this in RegEnumKeyEx
    TCHAR szBuffer[PTKEY_MAXSIZE];  // Buffer
    DWORD dwSize = PTKEY_MAXSIZE;   // Buffer size
    DWORD dwChildKey = 0;           // Child key index from the registry
    DWORD dwCLSIDIndex = 0;         // CLSID index into the array

    while( RegEnumKeyEx(
        hKey,
        dwChildKey,
        szBuffer,
        &dwSize,
        NULL,
        NULL,
        NULL,
        &time) == ERROR_SUCCESS)
    {
        LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - "
            "we read the buffer: %s", szBuffer));

        // Prepare for the next child key
        dwChildKey++;
        dwSize = PTKEY_MAXSIZE;

        // Try to get the CLSID from this key
        CLSID clsid = CLSID_NULL;
        HRESULT hr = CLSIDFromString( szBuffer, &clsid);
        if( FAILED(hr) )
        {
            // Go to the next child key
            continue;
        }

        // Have we enougth space for this element?
        if( dwArraySize <= dwCLSIDIndex )
        {
            LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - "
                "we have to increase the buffer size"));

            // We have to increase the space, double the size
            dwArraySize *= 2;

            CLSID* pNewCLSIDs = new CLSID[ dwArraySize ];
            if( pNewCLSIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            // Copies into the new buffer the old buffer
            memcpy( pNewCLSIDs, pCLSIDs, sizeof(CLSID)*dwArraySize/2);

            // Delete the old array
            delete[] pCLSIDs;

            // Set the new array to the old pointer
            pCLSIDs = pNewCLSIDs;
        }

        // We set the item into the CLSID array
        pCLSIDs[ dwCLSIDIndex] = clsid;
        dwCLSIDIndex++;

    }

    //
    // Clean-up hKey
    //

    RegCloseKey( hKey );


    if( FAILED(hr) )
    {
        // Clean-up
        delete[] pCLSIDs;

        LOG((MSP_ERROR, "CPTUtil::ListTerminalSuperclasses exit - "
            "failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Set the returning values
    //

    *ppSuperclasses = pCLSIDs;
    *pdwCount = dwCLSIDIndex;

    LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - exit"));
    return S_OK;
}

HRESULT CPTUtil::SearchForTerminal(
    IN  IID     iidTerminal,
    IN  DWORD   dwMediaType,
    IN  TERMINAL_DIRECTION  Direction,
    OUT CPTTerminal*        pTerminal
    )
{
    LOG((MSP_TRACE, "CPTUtil::SearchForTerminal - enter"));

    //
    // Get the plug-in terminal superclasses
    //

    CLSID* pSuperclasses = NULL;
    DWORD dwSuperclasses = 0;
    HRESULT hr = E_FAIL;

    hr = ListTerminalSuperclasses( 
        &pSuperclasses,
        &dwSuperclasses
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTUtil::SearchForTerminal - exit "
            "ListTerminalSuperclasses failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Enumerate the plug-in terminal superclasses
    //

    for( DWORD dwSuperclass = 0; dwSuperclass < dwSuperclasses; dwSuperclass++)
    {

        //
        // If we want a exact terminal (Exact) or just first matching
        // terminal from this superclass
        //

        BOOL bPTExact = (pSuperclasses[dwSuperclass] != iidTerminal);

        //
        // Get the terminal
        //

        hr = FindTerminal(
            pSuperclasses[dwSuperclass],
            bPTExact ? iidTerminal : CLSID_NULL,
            dwMediaType,
            Direction,
            bPTExact,
            pTerminal);


        if( FAILED(hr))
        {
            if( !bPTExact)
            {
                //
                // We had to find a terminal in this terminal class
                // sorry!!!

                break;
            }
        }
        else
        {
            //
            // cool! we found it
            //

            break;
        }
    }

    //
    // Clean-up superclasses array, bstrTermialGUID
    //
    delete[] pSuperclasses;

    //
    // Return
    //

    LOG((MSP_TRACE, "CPTUtil::SearchForTerminal - exit 0x%08x", hr));
    return hr;
}

HRESULT CPTUtil::FindTerminal(
    IN  CLSID   clsidSuperclass,
    IN  CLSID   clsidTerminal,
    IN  DWORD   dwMediaType,
    IN  TERMINAL_DIRECTION  Direction,
    IN  BOOL    bExact,
    OUT CPTTerminal*    pTerminal)
{
    LOG((MSP_TRACE, "CPTUtil::FindTerminal - exit"));

    //
    // Terminal class object
    //

    CPTSuperclass Superclass;
    Superclass.m_clsidSuperclass = clsidSuperclass;

    //
    // The terminals array
    //

    CLSID* pTerminals = NULL;
    DWORD dwTerminals = 0;
    HRESULT hr = E_FAIL;

    //
    // Lists the terminals for a specific terminal class
    //

    hr = Superclass.ListTerminalClasses( 
        dwMediaType, 
        &pTerminals,
        &dwTerminals
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTUtil::FindTerminal - exit "
            "ListTerminalSuperclasses failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Enumerate terminals
    //

    hr = E_FAIL;

    for( DWORD dwTerminal = 0; dwTerminal < dwTerminals; dwTerminal++)
    {

        //
        // CPTTerminal object from registry
        //

        CPTTerminal Terminal;
        Terminal.m_clsidTerminalClass = pTerminals[dwTerminal];
        hr = Terminal.Get( clsidSuperclass );

        if( FAILED(hr) )
        {
            continue;
        }


        //
        // try to log the name of the terminal that we are looking at
        //

        if (NULL != Terminal.m_bstrName)
        {
            //
            // log the name
            // 

            LOG((MSP_TRACE, "CPTUtil::FindTerminal - checking terminal %S", Terminal.m_bstrName));
        }
        else
        {

            //
            // no name?? strange, but not much we can do...
            //

            LOG((MSP_TRACE, "CPTUtil::FindTerminal - terminal name is unavaliable"));
        }

        
        //
        // Is matching
        //

        if( (dwMediaType & Terminal.m_dwMediaTypes) == 0 )
        {
            LOG((MSP_TRACE, "CPTUtil::FindTerminal - MediaType unmatched"));
            hr = E_FAIL;
            continue;
        }


        //
        // map TERMINAL_DIRECTION values to OR'able TMGR_DIRECTION values
        //

        DWORD dwRegistryDirection = 0;

        if (Direction == TD_RENDER)
        {
            
            dwRegistryDirection = TMGR_TD_RENDER;
        }
        else if (Direction == TD_CAPTURE)
        {

            dwRegistryDirection = TMGR_TD_CAPTURE;
        }
        else
        {
            
            //
            // should not happen, really
            //

            LOG((MSP_ERROR, "CPTUtil::FindTerminal - bad direction value %lx", Direction));

            hr = E_FAIL;


            //
            // this is strange, so debug to see how we got here
            //

            TM_ASSERT(FALSE);

            break;
        }


        //
        // requested direction -- is it one of the directions supported by this terminal?
        //

        if ((dwRegistryDirection & Terminal.m_dwDirections) == 0)
        {
            LOG((MSP_TRACE, "CPTUtil::FindTerminal - Direction unmatched"));

            hr = E_FAIL;
            continue;
        }



        if( bExact )
        {
            if( Terminal.m_clsidTerminalClass != clsidTerminal )
            {
                LOG((MSP_TRACE, "CPTUtil::FindTerminal - PublicCLSID unmatched"));
                hr = E_FAIL;
                continue;
            }
        }

        if( SUCCEEDED(hr) )
        {
            LOG((MSP_TRACE, "CPTUtil::FindTerminal - find a matching"));
            *pTerminal = Terminal;
            break;
        }
    }

    //
    // Clean-up the safearray
    //

    delete[] pTerminals;

    //
    // Return
    //

    LOG((MSP_TRACE, "CPTUtil::FindTerminal - exit 0x%08x", hr));
    return hr;
}

HRESULT CPTUtil::ListTerminalClasses(
    IN  DWORD       dwMediaTypes,
    OUT CLSID**     ppTerminalsClasses,
    OUT DWORD*      pdwCount
    )
{
    LOG((MSP_TRACE, "CPTUtil::ListTerminalClasses - enter"));

    //
    // reset the output arguments
    //

    *ppTerminalsClasses = NULL;
    *pdwCount = 0;

    //
    // Get all terminal classes
    //
    HRESULT hr = E_FAIL;
    CLSID* pSuperclasses = NULL;
    DWORD dwSuperclasses = 0;

    hr = ListTerminalSuperclasses( 
        &pSuperclasses,
        &dwSuperclasses
        );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTUtil::ListTerminalClasses - exit "
            "ListTerminalSuperclasses failed, returns 0x%08x", hr));
        return hr;
    }

    DWORD dwArraySize = 8;
    CLSID* pTerminals = new CLSID[ dwArraySize];
    DWORD dwIndex = 0;

    if( pTerminals == NULL )
    {
        // Cleanup
        delete[] pSuperclasses;

        LOG((MSP_ERROR, "CPTUtil::ListTerminalClasses - exit "
            "new operator failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Enumerate all superclasses
    //

    for( DWORD dwSuperclass = 0; dwSuperclass < dwSuperclasses; dwSuperclass++)
    {
        //
        // List the terminals for this class
        //

        CPTSuperclass Superclass;
        Superclass.m_clsidSuperclass = pSuperclasses[dwSuperclass];

        CLSID* pLocalTerminals = NULL;
        DWORD dwLocalTerminals = 0;

        hr = Superclass.ListTerminalClasses( 
            0, 
            &pLocalTerminals,
            &dwLocalTerminals
            );

        if( FAILED(hr) )
        {
            hr = S_OK;

            LOG((MSP_TRACE, "CPTUtil::ListTerminalClasses - "
                "ListTerminalSuperclasses failed"));
            continue;
        }

        //
        // Increase the array room if it's necessary
        //

        if( dwArraySize <= dwIndex + dwLocalTerminals)
        {
            CLSID* pOldTerminals = pTerminals;

            // Create the new buffer
            dwArraySize *= 2;
            pTerminals = new CLSID[dwArraySize];

            if( pTerminals == NULL )
            {
                // Clean-up
                delete[] pLocalTerminals;

                //
                // Recover the old list of terminals
                //
                pTerminals = pOldTerminals;

                LOG((MSP_TRACE, "CPTUtil::ListTerminalClasses - "
                    "new operator failed"));
                break;
            }

            // Copies the old one into the new one
            memcpy( pTerminals, pOldTerminals, sizeof(CLSID) * dwArraySize/2);

            // Delete old terminals
            delete[] pOldTerminals;
        }

        //
        // Add the terminals into terminals array
        //

        for( DWORD dwTerminal = 0; dwTerminal < dwLocalTerminals; dwTerminal++)
        {
            //
            // MediaTypes is right?
            //

            CPTTerminal Terminal;
            Terminal.m_clsidTerminalClass = pLocalTerminals[dwTerminal];
            hr = Terminal.Get( pSuperclasses[dwSuperclass] );

            if( FAILED(hr) )
            {
                hr = S_OK;

                LOG((MSP_TRACE, "CPTUtil::ListTerminalClasses - "
                    "GetTerminal failed"));
                continue;
            }

            if( 0 == (dwMediaTypes & Terminal.m_dwMediaTypes) )
            {
                LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - "
                    "wrong mediatype"));
                continue;
            }

            //
            // Add public clasid to the base safearray
            //
            pTerminals[dwIndex] = pLocalTerminals[dwTerminal];
            dwIndex++;

        }

        // Clean-up
        delete[] pLocalTerminals;

    }

    // Clean-up
    delete[] pSuperclasses;

    //
    // Return values
    //

    if( SUCCEEDED(hr) )
    {
        *ppTerminalsClasses = pTerminals;
        *pdwCount = dwIndex;
    }

    LOG((MSP_TRACE, "CPTUtil::ListTerminalSuperclasses - exit 0x%08x", hr));
    return hr;
}


///////////////////////////////////////////
// CPTTerminal Implementation
//

// Constructor/destructor
CPTTerminal::CPTTerminal()
{
    LOG((MSP_TRACE, "CPTTerminal::CPTTerminal - enter"));

    m_bstrName = NULL;
    m_bstrCompany = NULL;
    m_bstrVersion = NULL;

    m_clsidTerminalClass = CLSID_NULL;
    m_clsidCOM = CLSID_NULL;
    

    //
    // initialize with invalid direction and media type -- there is no other
    // good default
    //

    m_dwDirections = 0;
    m_dwMediaTypes = 0;

    LOG((MSP_TRACE, "CPTTerminal::CPTTerminal - exit"));
}

CPTTerminal::~CPTTerminal()
{
    LOG((MSP_TRACE, "CPTTerminal::~CPTTerminal - enter"));

    if(m_bstrName)
        SysFreeString( m_bstrName );

    if( m_bstrCompany)
        SysFreeString( m_bstrCompany );

    if( m_bstrVersion)
        SysFreeString( m_bstrVersion );

    LOG((MSP_TRACE, "CPTTerminal::~CPTTerminal - exit"));
}

// CPTTerminal methods
HRESULT CPTTerminal::Add(
    IN  CLSID   clsidSuperclass
    )
{
    LOG((MSP_TRACE, "CPTTerminal::Add - enter"));

    //
    // we should have a valid media type
    //

    if ( !IsValidAggregatedMediaType(m_dwMediaTypes) )
    {
        LOG((MSP_ERROR, "CPTTerminal::Add exit -"
            "media type is not valid %lx. return TAPI_E_INVALIDMEDIATYPE", 
            m_dwMediaTypes));

        return TAPI_E_INVALIDMEDIATYPE;
    }


    //
    // we should have a valid direction 
    //

    if ( ( TMGR_TD_CAPTURE != m_dwDirections ) && 
         ( TMGR_TD_RENDER  != m_dwDirections ) &&
         ( TMGR_TD_BOTH    != m_dwDirections ) )
    {
        LOG((MSP_ERROR, "CPTTerminal::Add exit - "
            "direction is not valid %lx. return TAPI_E_INVALIDDIRECTION",
            TAPI_E_INVALIDDIRECTION));

        return TAPI_E_INVALIDDIRECTION;
    }

    //
    // We determine the terminal path into registry
    //
    LPOLESTR lpszSuperclass = NULL;
    LPOLESTR lpszTerminalClass = NULL;
    HRESULT hr = E_FAIL;

    hr = StringFromCLSID( clsidSuperclass, &lpszSuperclass );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTTerminal::Add exit -"
            "StringFromCLSID for Superclass failed, returns 0x%08x", hr));
        return hr;
    }

    hr = StringFromCLSID( m_clsidTerminalClass, &lpszTerminalClass );
    if( FAILED(hr) )
    {
        CoTaskMemFree( lpszSuperclass );

        LOG((MSP_ERROR, "CPTTerminal::Add exit -"
            "StringFromCLSID for Superclass failed, returns 0x%08x", hr));
        return hr;
    }

    WCHAR szKey[PTKEY_MAXSIZE];
    WCHAR szKeySuperclass[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s\\%s"), 
        PTKEY_TERMINALS, 
        lpszSuperclass, 
        lpszTerminalClass
        );

    wsprintf( szKeySuperclass, TEXT("%s\\%s"),
        PTKEY_TERMINALS,
        lpszSuperclass);

    // Clean-up, we need later the TerminalClass
    CoTaskMemFree( lpszSuperclass );
    CoTaskMemFree( lpszTerminalClass );

    //
    // Try to see if the superclass key exist
    //

    HKEY hKeySuperclass = NULL;
    long lResult;

    lResult = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        szKeySuperclass,
        &hKeySuperclass);

    if( ERROR_SUCCESS != lResult )
    {
        // We don't have the superclass
        LOG((MSP_ERROR, "CPTTerminal::Add exit -"
            "RegOpenKey for superclass failed, returns E_FAIL"));
        return E_FAIL;
    }

    RegCloseKey( hKeySuperclass );


    //
    // Open or create key
    //

    HKEY hKey = NULL;

    lResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        NULL);


    //
    // Validates registry operation
    //

    if( ERROR_SUCCESS != lResult  )
    {
        LOG((MSP_ERROR, "CPTTerminal::Add exit -"
            "RegCreateKeyEx failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Edit terminal name
    //

    if( !IsBadStringPtr(m_bstrName, (UINT)-1) )
    {
        lResult = RegSetValueEx(
            hKey,
            PTKEY_NAME,
            0,
            REG_SZ,
            (BYTE *)m_bstrName,
            (SysStringLen( m_bstrName) + 1) * sizeof(WCHAR)
            );
    }

    //
    // Edit company name
    //

    if( !IsBadStringPtr(m_bstrCompany, (UINT)-1) )
    {
        lResult = RegSetValueEx(
            hKey,
            PTKEY_COMPANY,
            0,
            REG_SZ,
            (BYTE *)m_bstrCompany,
            (SysStringLen( m_bstrCompany) + 1) * sizeof(WCHAR)
            );
    }

    //
    // Edit terminal version
    //

    if( !IsBadStringPtr(m_bstrVersion, (UINT)-1) )
    {
        lResult = RegSetValueEx(
            hKey,
            PTKEY_VERSION,
            0,
            REG_SZ,
            (BYTE *)m_bstrVersion,
            (SysStringLen( m_bstrVersion) + 1) * sizeof(WCHAR)
            );
    }

    //
    // Edit terminal CLSID create
    //

    if( m_clsidCOM != CLSID_NULL )
    {
        LPOLESTR lpszCOM = NULL;
        hr = StringFromCLSID( m_clsidCOM, &lpszCOM );
        if( SUCCEEDED(hr) )
        {
            lResult = RegSetValueEx(
                hKey,
                PTKEY_CLSIDCREATE,
                0,
                REG_SZ,
                (BYTE *)lpszCOM,
                (wcslen( lpszCOM) + 1) * sizeof(WCHAR)
                );

            // Clean-up
            CoTaskMemFree( lpszCOM );
        }
    }

    //
    // Edit terminal directions
    //

    lResult = RegSetValueEx(
        hKey,
        PTKEY_DIRECTIONS,
        0,
        REG_DWORD,
        (BYTE *)&m_dwDirections,
        sizeof( m_dwDirections )
        );

    //
    // Edit terminal mediatypes
    //

    lResult = RegSetValueEx(
        hKey,
        PTKEY_MEDIATYPES,
        0,
        REG_DWORD,
        (BYTE *)&m_dwMediaTypes,
        sizeof( m_dwMediaTypes )
        );

    //
    // Clean-up hKey
    //

    RegFlushKey( hKey );
    RegCloseKey( hKey );

    LOG((MSP_TRACE, "CPTTerminal::Add - exit"));
    return S_OK;
}

HRESULT CPTTerminal::Delete(
    IN  CLSID   clsidSuperclass
    )
{
    LOG((MSP_TRACE, "CPTTerminal::Delete - enter"));

    //
    // We determine the terminal path into registry
    //
    LPOLESTR lpszSuperclass = NULL;
    LPOLESTR lpszTerminalClass = NULL;
    HRESULT hr = E_FAIL;

    hr = StringFromCLSID( clsidSuperclass, &lpszSuperclass );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTTerminal::Delete exit -"
            "StringFromCLSID for Superclass failed, returns 0x%08x", hr));
        return hr;
    }

    hr = StringFromCLSID( m_clsidTerminalClass, &lpszTerminalClass );
    if( FAILED(hr) )
    {
        CoTaskMemFree( lpszSuperclass );

        LOG((MSP_ERROR, "CPTTerminal::Delete exit -"
            "StringFromCLSID for Superclass failed, returns 0x%08x", hr));
        return hr;
    }

    WCHAR szKey[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s\\%s"), 
        PTKEY_TERMINALS, 
        lpszSuperclass, 
        lpszTerminalClass
        );

    // Clean-up, we need later the TerminalClass
    CoTaskMemFree( lpszSuperclass );
    CoTaskMemFree( lpszTerminalClass );

    //
    // Remove key
    //

    hr = CPTUtil::RecursiveDeleteKey(
        HKEY_LOCAL_MACHINE, 
        szKey
        );

    //
    // Return value
    //

    LOG((MSP_TRACE, "CPTTerminal::Delete - exit (0x%08x)", hr));
    return hr;
}

HRESULT CPTTerminal::Get(
    IN  CLSID   clsidSuperclass
    )
{
    LOG((MSP_TRACE, "CPTTerminal::Get - enter"));


    //
    // Reset members
    //

    if(m_bstrName)
    {
        SysFreeString( m_bstrName );
        m_bstrName = NULL;
    }

    if( m_bstrCompany)
    {
        SysFreeString( m_bstrCompany );
        m_bstrCompany = NULL;
    }

    if( m_bstrVersion)
    {
        SysFreeString( m_bstrVersion );
        m_bstrVersion = NULL;
    }

    m_clsidCOM = CLSID_NULL;

    
    //
    // initialize with invalid direction and media type
    //

    m_dwDirections = 0;
    m_dwMediaTypes = 0;


    //
    // We determine the terminal path into registry
    //
    LPOLESTR lpszSuperclass = NULL;
    LPOLESTR lpszTerminalClass = NULL;
    HRESULT hr = E_FAIL;

    hr = StringFromCLSID( clsidSuperclass, &lpszSuperclass );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTTerminal::Get exit -"
            "StringFromCLSID for Superclass failed, returns 0x%08x", hr));
        return hr;
    }

    hr = StringFromCLSID( m_clsidTerminalClass, &lpszTerminalClass );
    if( FAILED(hr) )
    {
        CoTaskMemFree( lpszSuperclass );

        LOG((MSP_ERROR, "CPTTerminal::Get exit -"
            "StringFromCLSID for Superclass failed, returns 0x%08x", hr));
        return hr;
    }

    WCHAR szKey[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s\\%s"), 
        PTKEY_TERMINALS, 
        lpszSuperclass, 
        lpszTerminalClass
        );

    // Clean-up, we need later the TerminalClass
    CoTaskMemFree( lpszSuperclass );
    CoTaskMemFree( lpszTerminalClass );

    //
    // Open terminal key
    //

    HKEY hKey = NULL;
    LONG lResult;

    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        KEY_QUERY_VALUE,
        &hKey);

    //
    // Validates registry operation
    //

    if( ERROR_SUCCESS != lResult  )
    {
        LOG((MSP_ERROR, "CPTTerminal::Get exit -"
            "RegOpenKeyEx failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Query for name
    //

    TCHAR szBuffer[PTKEY_MAXSIZE];
    DWORD dwSize = PTKEY_MAXSIZE * sizeof( TCHAR );
    DWORD dwType = REG_SZ;

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_NAME,
        0,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        m_bstrName = SysAllocString( szBuffer );
    }

    //
    // Query for company
    //

    dwSize = PTKEY_MAXSIZE * sizeof( TCHAR );
    dwType = REG_SZ;

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_COMPANY,
        0,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        m_bstrCompany = SysAllocString( szBuffer );
    }

    //
    // Query for version
    //

    dwSize = PTKEY_MAXSIZE * sizeof( TCHAR );
    dwType = REG_SZ;

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_VERSION,
        0,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        m_bstrVersion = SysAllocString( szBuffer );
    }

    //
    // Query for CLSID create
    //

    dwSize = PTKEY_MAXSIZE * sizeof( TCHAR );
    dwType = REG_SZ;

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_CLSIDCREATE,
        0,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        HRESULT hr = CLSIDFromString( szBuffer, &m_clsidCOM);
        if( FAILED(hr) )
        {
            m_clsidCOM = CLSID_NULL;
        }
    }

    //
    // Query for directions
    //

    dwType = REG_DWORD;
    DWORD dwValue = 0;
    dwSize = sizeof( dwValue );

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_DIRECTIONS,
        0,
        &dwType,
        (LPBYTE)&dwValue,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        m_dwDirections = dwValue;
    }

    //
    // Query for media types
    //

    dwSize = sizeof( dwValue );
    dwType = REG_DWORD;
    dwValue = 0;

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_MEDIATYPES,
        0,
        &dwType,
        (LPBYTE)&dwValue,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        m_dwMediaTypes = dwValue;
    }

    //
    // Clean-up hKey
    //

    RegCloseKey( hKey );

    LOG((MSP_TRACE, "CPTTerminal::Get - exit"));
    return S_OK;
}

///////////////////////////////////////////
// CPTSuperclass Implementation
//

// Constructor/Destructor
CPTSuperclass::CPTSuperclass()
{
    LOG((MSP_TRACE, "CPTSuperclass::CPTSuperclass - enter"));

    m_bstrName = NULL;
    m_clsidSuperclass = CLSID_NULL;

    LOG((MSP_TRACE, "CPTSuperclass::CPTSuperclass - exit"));
}

CPTSuperclass::~CPTSuperclass()
{
    LOG((MSP_TRACE, "CPTSuperclass::~CPTSuperclass - enter"));

    if(m_bstrName)
        SysFreeString( m_bstrName );

    LOG((MSP_TRACE, "CPTSuperclass::~CPTSuperclass - exit"));
}

// CPTSuperclass methods

HRESULT CPTSuperclass::Add()
{
    LOG((MSP_TRACE, "CPTSuperclass::Add - enter"));

    //
    // Get the superclass CLSID as string
    //

    LPOLESTR lpszSuperclassCLSID = NULL;
    HRESULT hr = E_FAIL;
    hr = StringFromCLSID( m_clsidSuperclass, &lpszSuperclassCLSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTSuperclass::Add exit -"
            "StringFromCLSID failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Create  key path for superclass
    //

    WCHAR szKey[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s"), PTKEY_TERMINALS, lpszSuperclassCLSID);

    // Clean-up
    CoTaskMemFree( lpszSuperclassCLSID );

    //
    // Open the registry key
    //

    HKEY hKey = NULL;
    long lResult;

    lResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        NULL);

    //
    // Validates the registry operation
    //

    if( ERROR_SUCCESS != lResult  )
    {
        LOG((MSP_ERROR, "CPTSuperclass::Add exit -"
            "RegCreateKeyEx failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Edit the name of the terminal class
    //

    if( !IsBadStringPtr(m_bstrName, (UINT)-1) )
    {
        lResult = RegSetValueEx(
            hKey,
            PTKEY_NAME,
            0,
            REG_SZ,
            (BYTE *)m_bstrName,
            (SysStringLen( m_bstrName) + 1) * sizeof(WCHAR)
            );
    }

    //
    // Clean-up hKey
    //

    RegFlushKey( hKey );
    RegCloseKey( hKey );

    LOG((MSP_TRACE, "CPTSuperclass::Add - exit"));
    return S_OK;
}

HRESULT CPTSuperclass::Delete()
{
    LOG((MSP_TRACE, "CPTSuperclass::Delete - enter"));

    //
    // Get the superclass CLSID as string
    //

    LPOLESTR lpszSuperclassCLSID = NULL;
    HRESULT hr = E_FAIL;
    hr = StringFromCLSID( m_clsidSuperclass, &lpszSuperclassCLSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTSuperclass::Delete exit -"
            "StringFromCLSID failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Create  key path for superclass
    //

    WCHAR szKey[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s"), PTKEY_TERMINALS, lpszSuperclassCLSID);

    // Clean-up
    CoTaskMemFree( lpszSuperclassCLSID );

    //
    // Remove key
    //

    hr = CPTUtil::RecursiveDeleteKey(
        HKEY_LOCAL_MACHINE, 
        szKey
        );

    //
    // Return value
    //

    LOG((MSP_TRACE, "CPTSuperclass::Delete - exit (0x%08x)", hr));
    return hr;
}

HRESULT CPTSuperclass::Get()
{
    LOG((MSP_TRACE, "CPTSuperclass::Get - enter"));

    //
    // Get the superclass CLSID as string
    //

    LPOLESTR lpszSuperclassCLSID = NULL;
    HRESULT hr = E_FAIL;
    hr = StringFromCLSID( m_clsidSuperclass, &lpszSuperclassCLSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTSuperclass::Get exit -"
            "StringFromCLSID failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Create  key path for superclass
    //

    WCHAR szKey[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s"), PTKEY_TERMINALS, lpszSuperclassCLSID);

    // Clean-up
    CoTaskMemFree( lpszSuperclassCLSID );

    //
    // Reset members
    //

    if(m_bstrName)
    {
        SysFreeString( m_bstrName );
        m_bstrName = NULL;
    }

    //
    // Open terminal key
    //

    HKEY hKey = NULL;
    LONG lResult;

    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        KEY_QUERY_VALUE,
        &hKey);


    //
    // Validates registry operation
    //

    if( ERROR_SUCCESS != lResult  )
    {
        LOG((MSP_ERROR, "CPTSuperclass::Get exit -"
            "RegOpenKeyEx failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Query for name
    //

    TCHAR szBuffer[PTKEY_MAXSIZE];
    DWORD dwSize = PTKEY_MAXSIZE * sizeof( TCHAR );
    DWORD dwType = REG_SZ;

    lResult = RegQueryValueEx(
        hKey,
        PTKEY_NAME,
        0,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize);

    if( ERROR_SUCCESS == lResult )
    {
        m_bstrName = SysAllocString( szBuffer );
    }
    else
    {
        m_bstrName = SysAllocString(_T(""));
    }

    //
    // Clean-up hKey
    //

    RegCloseKey( hKey );

    LOG((MSP_TRACE, "CPTSuperclass::Get - exit"));
    return S_OK;
}

HRESULT CPTSuperclass::ListTerminalClasses(
    IN  DWORD       dwMediaTypes,
    OUT CLSID**     ppTerminals,
    OUT DWORD*      pdwCount
    )
{
    LOG((MSP_TRACE, "CPTSuperclass::ListTerminalSuperclasses - enter"));

    //
    // Validates argument
    //

    if( TM_IsBadWritePtr( ppTerminals, sizeof(CLSID*)) )
    {
        LOG((MSP_ERROR, "CPTSuperclass::ListTerminalSuperclasses exit -"
            "pTerminals invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Reset the output arguments
    //

    *ppTerminals = NULL;
    *pdwCount = 0;

    //
    // Get the superclass CLSID as string
    //

    LPOLESTR lpszSuperclassCLSID = NULL;
    HRESULT hr = E_FAIL;
    hr = StringFromCLSID( m_clsidSuperclass, &lpszSuperclassCLSID);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPTSuperclass::Get exit -"
            "StringFromCLSID failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Create  key path for superclass
    //

    WCHAR szKey[PTKEY_MAXSIZE];
    wsprintf( szKey, TEXT("%s\\%s"), PTKEY_TERMINALS, lpszSuperclassCLSID);

    // Clean-up
    CoTaskMemFree( lpszSuperclassCLSID );

    //
    // Open the terminal class key
    //

    HKEY hKey;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        KEY_READ,
        &hKey);

    //
    // Validates registry operation
    //

    if( ERROR_SUCCESS != lResult )
    {
        LOG((MSP_ERROR, "CPTSuperclass::ListTerminalSuperclasses exit - "
            "RegOpenKeyEx failed, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    DWORD dwArraySize = 8;
    CLSID* pTerminals = new CLSID[dwArraySize];

    if( pTerminals == NULL )
    {
        // Clean-up hKey
        RegCloseKey( hKey );

        LOG((MSP_ERROR, "CPTSuperclass::ListTerminalSuperclasses exit - "
            "new operator failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Enumerate the descendents
    //

    FILETIME time;
    TCHAR szBuffer[PTKEY_MAXSIZE];      // Buffer 
    DWORD dwSize = PTKEY_MAXSIZE;       // Buffer size
    DWORD dwIndex = 0;                  // Index into array
    DWORD dwChildIndex = 0;             // Child index into registry

    while( RegEnumKeyEx(
        hKey,
        dwChildIndex,
        szBuffer,
        &dwSize,
        NULL,
        NULL,
        NULL,
        &time) == ERROR_SUCCESS)
    {
        //
        // Prepare for the nex child
        //

        dwChildIndex++;
        dwSize = PTKEY_MAXSIZE;

        //
        // I have to qury MediaType value for this entry
        //

        CPTTerminal Terminal;
        HRESULT hr = CLSIDFromString( szBuffer, &Terminal.m_clsidTerminalClass);
        if( FAILED(hr) )
        {
            hr = S_OK;

            continue;
        }

        if( dwMediaTypes )
        {
            HRESULT hr = E_FAIL;
            hr = Terminal.Get( m_clsidSuperclass );
            if( FAILED(hr) )
            {
                hr = S_OK;

                continue;
            }

            if( !(Terminal.m_dwMediaTypes & dwMediaTypes) )
            {
                continue;
            }
        }

        //
        // Increase the array room if it's necessary
        //

        if( dwArraySize <= dwIndex)
        {
            // Old buffer
            CLSID* pOldTerminals = pTerminals;

            // New buffer
            dwArraySize *= 2;
            pTerminals = new CLSID[dwArraySize];
            if( pTerminals == NULL )
            {
                delete[] pOldTerminals;
                LOG((MSP_ERROR, "CPTSuperclass::ListTerminalSuperclasses exit - "
                    "new operator failed, returns E_OUTOFMEMORY"));
                return E_OUTOFMEMORY;
            }

            // Copies the old buffer into the new one
            memcpy( pTerminals, pOldTerminals, sizeof(CLSID)*dwArraySize/2);

            // Delete the old buffer
            delete[] pOldTerminals;
        }

        //
        // Add the terminal class
        //

        pTerminals[dwIndex] = Terminal.m_clsidTerminalClass;
        dwIndex++;
    }

    //
    // Clean-up hKey
    //

    RegCloseKey( hKey );


    //
    // Return values
    //

    if( SUCCEEDED(hr) )
    {
        *ppTerminals = pTerminals;
        *pdwCount = dwIndex;
    }

    LOG((MSP_TRACE, "CPTSuperclass::ListTerminalSuperclasses - exit Len=%ld, 0x%08x", dwIndex, hr));
    return hr;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\sample.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __SAMPLE_H_
#define __SAMPLE_H_

#include "resource.h"       // main symbols
#include "stream.h"


//
//  Samples don't use their own critical sections -- They always take the critical section of their
//  stream.  This avoids all sorts of deadlocks, and reduces the number of locks we take.  These
//  macros are helpers.
//
#define LOCK_SAMPLE m_pStream->Lock();
#define UNLOCK_SAMPLE m_pStream->Unlock();
#define AUTO_SAMPLE_LOCK  CAutoObjectLock lck(m_pStream);


class CSample;

class CMediaSampleTM : public IMediaSample
{
public:
    CMediaSampleTM(CSample *pSample);
    virtual ~CMediaSampleTM();

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // IMediaSample
    //
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);
    STDMETHODIMP_(LONG) GetSize(void);
    STDMETHODIMP GetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);
    STDMETHODIMP IsDiscontinuity(void);
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);

public:
    CSample        *m_pSample;

    BOOL            m_bIsPreroll;
    DWORD           m_dwFlags;
    long            m_cRef;
    AM_MEDIA_TYPE  *m_pMediaType;

    REFERENCE_TIME  m_rtStartTime;
    REFERENCE_TIME  m_rtEndTime;
};





/////////////////////////////////////////////////////////////////////////////
// CSample
class ATL_NO_VTABLE CSample :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IStreamSample
{
public:
        //
        // METHODS
        //
        CSample();
        HRESULT InitSample(CStream *pStream, bool bIsInternalSample);
        virtual ~CSample();

        DECLARE_GET_CONTROLLING_UNKNOWN()

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream);

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime);

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime);

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData);

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds);


        //
        //  Forwarding functions for various Media Sample interfaces that can be 
        //  
        virtual HRESULT MSCallback_GetPointer(BYTE ** ppBuffer) = 0;
        virtual LONG MSCallback_GetSize(void) = 0;
        virtual LONG MSCallback_GetActualDataLength(void) = 0;
        virtual HRESULT MSCallback_SetActualDataLength(LONG lActual) = 0;
        virtual bool MSCallback_AllowSetMediaTypeOnMediaSample(void) {return false;}

        //
        // ATL class methods
        //
        void FinalRelease(void);

        //
        // Internal methods
        //
        virtual void FinalMediaSampleRelease(void);
        virtual HRESULT SetCompletionStatus(HRESULT hrCompletionStatus);
        void CopyFrom(CSample *pSrcSample);
        void CopyFrom(IMediaSample *pSrcMediaSample);
        
        virtual HRESULT InternalUpdate(
            DWORD dwFlags,
            HANDLE hEvent,
            PAPCFUNC pfnAPC,
            DWORD_PTR dwAPCData)
        {
            return E_NOTIMPL;
        }


        //  Temp?
        bool IsTemp() { return m_bTemp; }
    
BEGIN_COM_MAP(CSample)
        COM_INTERFACE_ENTRY(IStreamSample)
END_COM_MAP()

public:
        //
        //  MEMBER VARIABLES
        //
        CMediaSampleTM *                  m_pMediaSample;
        bool                            m_bReceived;
        bool                            m_bWantAbort;
        bool                            m_bContinuous;
        bool                            m_bModified;
        bool                            m_bInternal;
        bool                            m_bTemp;
        CStream                         *m_pStream;
        CSample                         *m_pNextFree;
        CSample                         *m_pPrevFree;
        HANDLE                          m_hUserHandle;
        PAPCFUNC                        m_UserAPC;
        DWORD_PTR                       m_dwptrUserAPCData;
        HRESULT                         m_Status;
        HRESULT                         m_MediaSampleIoStatus;
        HANDLE                          m_hCompletionEvent;

};




#endif //__SAMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\timerq.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#include "stdafx.h"
#include "atlconv.h"
#include "termmgr.h"
#include "timerq.h"

DWORD
CTimerQueue::GetTimeToTimeout(
    )
{
    if ( IsEmpty() )    return INFINITE;

    CFilterInfo *FirstEntry = m_Head.m_pNext;

    DWORD FirstTimeout = FirstEntry->m_WaitTime;

    // get current time
    DWORD CurrentTime = timeGetTime();

    // get the minimum time difference between the two
    // this should get rid of the wrap problem
    BOOL bIsWrap;
    DWORD TimeDiff = GetMinDiff(CurrentTime, FirstTimeout, bIsWrap);

    // if this time diff value is > MAX_TIMEOUT, it has to be in the 
    // past - schedule it now
    if (TimeDiff > MAX_TIMEOUT)    return 0;
    
    // check if the timeout event is in the past - schedule it for now
    if ( bIsWrap )
    {
        // if there is a wrap around, the first timeout must be the 
        // one causing it (the wrap around), otherwise its in the past
        if ( CurrentTime <= FirstTimeout )    return 0;
    }
    else
    {
        // no wrap around, so if we timeout is behind current time, its past
        if ( FirstTimeout <= CurrentTime )    return 0;
    }

    return TimeDiff;
}


DWORD 
CTimerQueue::GetMinDiff(
    IN  DWORD Time1,
    IN  DWORD Time2,
    OUT BOOL  &bIsWrap
    )
{
    DWORD NormalDiff;
    DWORD WrapDiff;
    if (Time1 < Time2)
    {
        NormalDiff = Time2 - Time1;
        WrapDiff = MAX_DWORD - NormalDiff;
    }
    else
    {
        NormalDiff = Time1 - Time2;
        WrapDiff = MAX_DWORD - NormalDiff;
    }

    if (NormalDiff < WrapDiff)
    {
        bIsWrap = FALSE;
        return NormalDiff;
    }
    else
    {
        bIsWrap = TRUE;
        return WrapDiff;
    }

    // should never reach this place
    TM_ASSERT(FALSE);
    return 0;
}

void 
CTimerQueue::Insert(
    IN CFilterInfo *pNewFilterInfo
    )
{
    TM_ASSERT(NULL != pNewFilterInfo);
    TM_ASSERT(!pNewFilterInfo->InQueue());

    // walk through the queue until an entry with
    // an equal or greater wait time is found
    // need to account for the wrap

    DWORD NewTime = pNewFilterInfo->m_WaitTime;
    CFilterInfo *pCurrent = m_Head.m_pNext;
    while (!IsHead(pCurrent))
    {
        // get the minimum time difference between the two
        // this should get rid of the wrap problem
        BOOL IsWrap;
        DWORD TimeDiff = GetMinDiff(pCurrent->m_WaitTime, NewTime, IsWrap);
   
        // if there is a wrap around, and the pCurrent time causes it, the
        // current entry must be greater than the new time
        if ( IsWrap && (pCurrent->m_WaitTime  <= NewTime) ) break;

        // if the current time is greater than the new time
        if ( !IsWrap && (NewTime <= pCurrent->m_WaitTime) ) break;

        pCurrent = pCurrent->m_pNext;
    }
    
    // insert before pCurrent
    pCurrent->m_pPrev->m_pNext = pNewFilterInfo;
    pNewFilterInfo->m_pPrev = pCurrent->m_pPrev;
    pCurrent->m_pPrev = pNewFilterInfo;
    pNewFilterInfo->m_pNext = pCurrent;
}


BOOL 
CTimerQueue::Remove(
    IN CFilterInfo *pFilterInfo
    )
{
    TM_ASSERT(NULL != pFilterInfo);
    TM_ASSERT(!IsHead(pFilterInfo));

    // either both prev/next are null or both are not null
    TM_ASSERT((NULL == pFilterInfo->m_pPrev) == \
             (NULL == pFilterInfo->m_pNext));

    if ( (NULL == pFilterInfo->m_pNext) && (NULL == pFilterInfo->m_pPrev) )
        return FALSE;

    pFilterInfo->m_pPrev->m_pNext = pFilterInfo->m_pNext;
    pFilterInfo->m_pNext->m_pPrev = pFilterInfo->m_pPrev;
    pFilterInfo->m_pNext = pFilterInfo->m_pPrev = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\stream.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// Stream.cpp : Implementation of CStream
#include "stdafx.h"





/////////////////////////////////////////////////////////////////////////////
// CStream

CStream::CStream() :
    m_bCommitted(false),
    m_lRequestedBufferCount(0),
    m_bFlushing(false),
    m_rtWaiting(0),
    m_lWaiting(0),
    m_hWaitFreeSem(NULL),
    m_pFirstFree(NULL),
    m_pLastFree(NULL),
    m_cAllocated(0),
    m_bEndOfStream(false),
    m_FilterState(State_Stopped),
    m_pFilter(NULL),
    m_pFilterGraph(NULL),
    m_pMMStream(NULL),
    m_rtSegmentStart(0),
    m_bStopIfNoSamples(false)
{
    InitMediaType(&m_ConnectedMediaType);
    InitMediaType(&m_ActualMediaType);
    CHECKSAMPLELIST
}

#ifdef DEBUG
bool CStream::CheckSampleList()
{
    if (m_pFirstFree) {
        CSample *pSample = m_pFirstFree;
        if (pSample->m_pPrevFree != NULL) {
            return false;
        }
        while (pSample->m_pNextFree) {
            if (pSample->m_pNextFree->m_pPrevFree != pSample) {
                return false;
            }
            pSample = pSample->m_pNextFree;
        }
        if (pSample != m_pLastFree) {
            return false;
        }
    } else {
        if (m_pLastFree) {
            return false;
        }
    }
    return true;
}
#endif

HRESULT CStream::FinalConstruct(void)
{

    //
    // attempt to create a semaphore
    //

    TCHAR *ptczSemaphoreName = NULL;

#if DBG

    //
    // in debug build, use named semaphores.
    //

    TCHAR tszSemaphoreName[MAX_PATH];

    _stprintf(tszSemaphoreName, 
        _T("CStream_Semaphore_pid[0x%lx]_CStream[%p]_"),
        GetCurrentProcessId(), this);

    LOG((MSP_TRACE, "CStream::FinalConstruct[%p] - creating semaphore[%S]",
        this, tszSemaphoreName));

    ptczSemaphoreName = &tszSemaphoreName[0];

#endif

    m_hWaitFreeSem = CreateSemaphore(NULL, 0, 0x7FFFFFF, ptczSemaphoreName);
    return m_hWaitFreeSem ? S_OK : E_OUTOFMEMORY;
}


CStream::~CStream()
{
    // Normally we would do:
    // SetState(State_Stopped);        // Make sure we're decommitted and pump is dead
    // but since this is now a pure virtual method it's not linking.
    // moved this to the derived class, which will eventually be the only stream class anyway

    Disconnect();                   // Free any allocated media types and release held references
    if (m_hWaitFreeSem) {
        CloseHandle(m_hWaitFreeSem);
    }
}

STDMETHODIMP CStream::GetMultiMediaStream(IMultiMediaStream **ppMultiMediaStream)
{
    LOG((MSP_TRACE, "IMediaStream::GetMultiMediaStream(%p)",
                   ppMultiMediaStream));
    if (NULL == ppMultiMediaStream) {
	return E_POINTER;
    }

    if (m_pMMStream != NULL) {
    	m_pMMStream->AddRef();
    }

    *ppMultiMediaStream = m_pMMStream;
    return S_OK;
}

STDMETHODIMP CStream::GetInformation(MSPID *pPurposeId, STREAM_TYPE *pType)
{
    LOG((MSP_TRACE, "IMediaStream::GetInformation(%p, %p)\n",
                   pPurposeId, pType));
    if (pPurposeId) {
        *pPurposeId = m_PurposeId;
    }
    if (pType) {
        *pType = m_StreamType;
    }
    return S_OK;
}

STDMETHODIMP CStream::SendEndOfStream(DWORD dwFlags)
{
    LOG((MSP_TRACE, "IMediaStream::SendEndOfStream(0x%8.8X)",
                   dwFlags));
    if (m_StreamType != STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    if (m_pConnectedPin) {
        return m_pConnectedPin->EndOfStream();
    }
    return S_OK;
}


STDMETHODIMP CStream::Initialize(IUnknown *pSourceObject, DWORD dwFlags,
    REFMSPID PurposeId, const STREAM_TYPE StreamType)
{
    LOG((MSP_TRACE, "IMediaStream::Initalize(%p, 0x%8.8X, %p)",
                   pSourceObject, dwFlags, &StreamType));
    HRESULT hr = NOERROR;

    if (dwFlags & ~(AMMSF_CREATEPEER | AMMSF_STOPIFNOSAMPLES)) {
        return E_INVALIDARG;
    }
    m_PurposeId = PurposeId;
    m_StreamType = StreamType;
    m_Direction = (StreamType == STREAMTYPE_WRITE) ? PINDIR_OUTPUT : PINDIR_INPUT;
    if (dwFlags & AMMSF_CREATEPEER) {
        if (!pSourceObject) {
            hr = E_INVALIDARG;
        } else {
            CComQIPtr<IMediaStream, &IID_IMediaStream> pMediaStream(pSourceObject);
            if (!pSourceObject) {
                hr = E_INVALIDARG;
            } else {
                hr = SetSameFormat(pMediaStream, 0);
            }
        }
    }
    m_bStopIfNoSamples = dwFlags & AMMSF_STOPIFNOSAMPLES ? true : false;
    return hr;
}

STDMETHODIMP CStream::JoinAMMultiMediaStream(IAMMultiMediaStream *pAMMultiMediaStream)
{
    TM_ASSERT(pAMMultiMediaStream == NULL || m_pMMStream == NULL);
    AUTO_CRIT_LOCK;
    HRESULT hr;
    if (m_cAllocated) {
        hr = MS_E_SAMPLEALLOC;
    } else {
        m_pMMStream = pAMMultiMediaStream;
    }
    return S_OK;
}

STDMETHODIMP CStream::JoinFilter(IMediaStreamFilter *pMediaStreamFilter)
{
    TM_ASSERT(pMediaStreamFilter == NULL || m_pFilter == NULL);
    m_pFilter = pMediaStreamFilter;
    pMediaStreamFilter->QueryInterface(IID_IBaseFilter, (void **)&m_pBaseFilter);
    m_pBaseFilter->Release();
    return S_OK;
}

STDMETHODIMP CStream::JoinFilterGraph(IFilterGraph *pFilterGraph)
{
    TM_ASSERT(pFilterGraph == NULL || m_pFilterGraph == NULL);
    m_pFilterGraph = pFilterGraph;
    return S_OK;
}



//
//  IPin Implementation
//

STDMETHODIMP CStream::Disconnect()
{
    m_pConnectedPin = NULL;
    m_pConnectedMemInputPin.Release();  // Magically sets to NULL here
    m_pQC.Release();
    m_pAllocator = NULL;
    m_lRequestedBufferCount = 0;
    FreeMediaType(m_ConnectedMediaType);
    FreeMediaType(m_ActualMediaType);
    return S_OK;
}

STDMETHODIMP CStream::ConnectedTo(IPin **pPin)
{
    *pPin = m_pConnectedPin;
    if (*pPin) {
        (*pPin)->AddRef();
        return S_OK;
    } else {
        return VFW_E_NOT_CONNECTED;
    }
}

STDMETHODIMP CStream::ConnectionMediaType(AM_MEDIA_TYPE *pmt)
{
    if (m_pConnectedPin) {
        CopyMediaType(pmt, &m_ConnectedMediaType);
        return S_OK;
    } else {
        ZeroMemory(pmt, sizeof(*pmt));
        pmt->lSampleSize = 1;
        pmt->bFixedSizeSamples = TRUE;
        return VFW_E_NOT_CONNECTED;
    }
}



void CStream::GetName(LPWSTR pszBuf)
{
    if (m_PurposeId == GUID_NULL) {
        pszBuf[0] = 0;
    } else {
        pszBuf[0] = (m_Direction == PINDIR_INPUT) ? (WCHAR)'I' : (WCHAR)'O';
        WStringFromGUID(&m_PurposeId, &pszBuf[1]);
    }
}


STDMETHODIMP CStream::QueryPinInfo(PIN_INFO * pInfo)
{
    pInfo->dir = m_Direction;
    GetName(pInfo->achName);
    return m_pFilter->QueryInterface(IID_IBaseFilter, (void **)&pInfo->pFilter);
}

STDMETHODIMP CStream::QueryDirection(PIN_DIRECTION * pPinDir)
{
    *pPinDir = m_Direction;
    return S_OK;
}


STDMETHODIMP CStream::QueryId(LPWSTR * Id)
{
    *Id = (LPWSTR)CoTaskMemAlloc(128 * sizeof(WCHAR));
    if (*Id) {
        GetName(*Id);
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


//
//  Derived classes must override this method
//
STDMETHODIMP CStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    return E_NOTIMPL;
};


STDMETHODIMP CStream::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    //
    //  Returning E_NOTIMPL tells the filter graph manager that all input pins are connected to
    //  all output pins.
    //
    return E_NOTIMPL;
};


STDMETHODIMP CStream::EndOfStream(void)
{
    HRESULT hr = S_OK;
    Lock();
    if (m_bFlushing || m_bEndOfStream) {
        hr = E_FAIL;
    } else {
        m_bEndOfStream = true;
        CSample *pSample = m_pFirstFree;
        m_pFirstFree = m_pLastFree = NULL;              // Out of paranoia, clear these pointers first
        while (pSample) {
            CSample *pNext = pSample->m_pNextFree;
            pSample->SetCompletionStatus(MS_S_ENDOFSTREAM);  // WARNING!  This sample may go away!!!
            pSample = pNext;
        }
        CHECKSAMPLELIST
    }
    if (S_OK == hr) {
        m_pFilter->EndOfStream();
    }
    Unlock();

    return hr;
}


STDMETHODIMP CStream::BeginFlush(void)
{
    HRESULT hr = S_OK;
    Lock();
    const BOOL bCancelEOS = m_bEndOfStream;
    if (m_bFlushing) {
        hr = S_FALSE;
    } else {
        m_bFlushing = true;
        m_bEndOfStream = false;
        Decommit();     // Force everyone to unblock
    }
    if (S_OK == hr) {
        m_pFilter->Flush(bCancelEOS);
    }
    Unlock();

    return hr;
}

STDMETHODIMP CStream::EndFlush(void)
{
    AUTO_CRIT_LOCK;
    m_bFlushing = false;
    TM_ASSERT(!m_bEndOfStream);
    Commit();   // Let getbuffer work again
    return S_OK;
}

STDMETHODIMP CStream::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate)
{
    Lock();
    m_rtSegmentStart = tStart;
    m_bEndOfStream = false;
    Unlock();
    return S_OK;
}

//
// IMemInputPin
//
STDMETHODIMP CStream::GetAllocator(IMemAllocator ** ppAllocator)
{
    return GetControllingUnknown()->QueryInterface(IID_IMemAllocator, (void **)ppAllocator);
}

STDMETHODIMP CStream::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    m_bUsingMyAllocator = IsSameObject(pAllocator, GetControllingUnknown());
    m_bSamplesAreReadOnly = bReadOnly ? true : false;
    HRESULT hr = S_OK;
    if (!m_bUsingMyAllocator) {
        //  Transfer the properties across
        ALLOCATOR_PROPERTIES Props;
        hr = pAllocator->GetProperties(&Props);
        if (FAILED(hr)) {
            return hr;
        }
        ALLOCATOR_PROPERTIES PropsActual;
        hr = SetProperties(&Props, &PropsActual);
    }
    m_pAllocator = pAllocator;
    return hr;
}


STDMETHODIMP CStream::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    // Return E_NOTIMPL to indicate that we don't have any requirement and will not accept someone
    // elses allocator.
    return E_NOTIMPL;
}


STDMETHODIMP CStream::ReceiveMultiple(IMediaSample **pSamples, long nSamples, long *nSamplesProcessed)
{
    HRESULT hr = S_OK;
    *nSamplesProcessed = 0;
    while (nSamples-- > 0) {
        hr = Receive(pSamples[*nSamplesProcessed]);
        if (hr != S_OK) {
            break;
        }
        (*nSamplesProcessed)++;
    }
    return hr;
}

STDMETHODIMP CStream::ReceiveCanBlock()
{
    return S_OK;    // Pin can block if not using our allocator or using read-only samples
}



//
//  This method assumes the critical section is taken.
//
HRESULT CStream::ConnectThisMediaType(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = pReceivePin->ReceiveConnection(this, pmt);
    if (SUCCEEDED(hr)) {
        m_pConnectedMemInputPin = pReceivePin;  // Does a magic QI here!
        if (!m_pConnectedMemInputPin) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            hr = ReceiveConnection(pReceivePin, pmt);
            if (SUCCEEDED(hr)) {
                hr = m_pConnectedMemInputPin->NotifyAllocator(this, TRUE);
            }
            if (SUCCEEDED(hr)) {
                m_pAllocator = this;
                m_bUsingMyAllocator = true;
            } else {
                Disconnect();
            }
        }
    }
    return hr;
}

STDMETHODIMP CStream::Connect(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;
    AUTO_CRIT_LOCK;

    if (pmt) {
        hr = ConnectThisMediaType(pReceivePin, pmt);
    } else {
        AM_MEDIA_TYPE *pCurMediaType;
        hr = GetMediaType(0, &pCurMediaType);
        if (SUCCEEDED(hr)) {
            hr = ConnectThisMediaType(pReceivePin, pCurMediaType);
            DeleteMediaType(pCurMediaType);
        }
    }
    return hr;
}



STDMETHODIMP CStream::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    HRESULT hr = S_OK;
    CMediaTypeEnum *pNewEnum = new CComObject<CMediaTypeEnum>;
    if (pNewEnum == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
        pNewEnum->Initialize(this, 0);
    }
    pNewEnum->GetControllingUnknown()->QueryInterface(IID_IEnumMediaTypes, (void **)ppEnum);
    return hr;
}


//
//  This method is not supported and never will be!
//
STDMETHODIMP CStream::ReleaseBuffer(IMediaSample *pBuffer)
{
    return E_UNEXPECTED;
};


//
//  The caller holds the reference to the sample after this point.
//
HRESULT CStream::AllocSampleFromPool(
    const REFERENCE_TIME *pStartTime, 
    CSample **ppSample,
    DWORD dwFlag
)
{

    LONGLONG llLate = 0;
    Lock();
    
    // Check we are committed -- This can happen after we've blocked and then
    // wake back up due to a decommit.
    if (!m_bCommitted) 
    {
        Unlock();
    	return VFW_E_NOT_COMMITTED;
    }


    //
    // if start time has been specified, wait as needed
    //

    if (pStartTime) {
        REFERENCE_TIME CurTime;
        if (m_pFilter->GetCurrentStreamTime(&CurTime) == S_OK) {
            llLate = CurTime - *pStartTime;

            /*  Block if more than a millisecond early */
            if (-llLate >= 10000) {
                m_rtWaiting = *pStartTime;
                Unlock();
                m_pFilter->WaitUntil(*pStartTime);
                Lock();
                m_rtWaiting = 0;


                //
                // make sure we are still commited
                //

                if (!m_bCommitted)
                {
                    Unlock();

    	            return VFW_E_NOT_COMMITTED;
                }
            }
        }
    }

    
    HRESULT hr = VFW_E_BUFFER_NOTSET;


    //
    // try to get a sample from the pool
    //

    CSample *pSample = m_pFirstFree;


    //
    // if no sample was readily available, wait for one.
    //

    if ( pSample == NULL)
    {

    
        //
        // if the nowait flag was set, don't bother waiting
        //

        if ( !(AM_GBF_NOWAIT & dwFlag) ) 
        {

            //
            // indicate that one more thread is waiting for a sample
            //

            m_lWaiting++;


            //
            // unlock to allow a new sample to become available while we are waiting
            //


            Unlock();


            //
            // wait for a sample to become available
            //

            DWORD dwWaitResult = WaitForSingleObject(m_hWaitFreeSem, INFINITE);


            //
            // if wait succeeded, proceed to the next iteration of the loop and
            // try to get a sample again.
            //

            if (WAIT_OBJECT_0 != dwWaitResult)
            {
                return VFW_E_BUFFER_NOTSET;
            }


            //
            // get the lock back
            //

            Lock();


            //
            // check if the allocator was decommited while we were waiting
            //

            if (!m_bCommitted) 
            {
                Unlock();

    	        return VFW_E_NOT_COMMITTED;
            }

    
            pSample = m_pFirstFree;

        } // nowait flag set

    } // if ( pSample == NULL )


    //
    // did we get the sample after all?
    //

    if ( pSample != NULL )
    {

        //
        // we have the sample. our mission was successful.
        //

        hr = NOERROR;


        //
        // remove from the sample we found from the pool of available samples
        //

        m_pFirstFree = pSample->m_pNextFree;

        if (m_pFirstFree) 
        {
        
            m_pFirstFree->m_pPrevFree = NULL;
        } 
        else 
        {
            m_pLastFree = NULL;
        }

        pSample->m_pNextFree = NULL;

        TM_ASSERT(pSample->m_Status == MS_S_PENDING);
        CHECKSAMPLELIST

    }

    Unlock();
    *ppSample = pSample;
    return hr;
}


void CStream::AddSampleToFreePool(CSample *pSample)
{

    Lock();

    TM_ASSERT(pSample->m_pPrevFree == NULL && pSample->m_pNextFree == NULL);
    if (m_pFirstFree) {
        pSample->m_pPrevFree = m_pLastFree;
        m_pLastFree->m_pNextFree = pSample;
    } else {
        pSample->m_pPrevFree = NULL;
        m_pFirstFree = pSample;
    }
    pSample->m_pNextFree = NULL;    // We know that the prev ptr is already null
    m_pLastFree = pSample;
    CHECKSAMPLELIST
    if (m_lWaiting > 0) {
        ReleaseSemaphore(m_hWaitFreeSem, 1, 0);
    	m_lWaiting--;
    }
    Unlock();
    
}


//
//  The caller holds the reference to the sample after this point!
//
bool CStream::StealSampleFromFreePool(CSample *pSample, BOOL bAbort)
{
    bool bWorked = false;
    Lock();
    if (m_pFirstFree) {
        if (m_pFirstFree == pSample) {
            // We'll only steal the first sample if there's nobody waiting for it right now.
            bool bTakeFirstFree = true;
            if (!bAbort && m_bCommitted) {
                REFERENCE_TIME CurTime;
                if (m_rtWaiting && m_pFilter->GetCurrentStreamTime(&CurTime) == S_OK) {
                    bTakeFirstFree = m_rtWaiting > CurTime;
                }
            }
            if (bTakeFirstFree) {
                m_pFirstFree = pSample->m_pNextFree;
                if (m_pFirstFree) {
                    m_pFirstFree->m_pPrevFree = NULL;
                } else {
                    m_pLastFree = NULL;
                }
                pSample->m_pNextFree = NULL;    // We know the prev ptr is already null!
                TM_ASSERT(pSample->m_pPrevFree == NULL);
                bWorked = true;
            }
        } else {
            if (pSample->m_pPrevFree) {
                pSample->m_pPrevFree->m_pNextFree = pSample->m_pNextFree;
                if (pSample->m_pNextFree) {
                    pSample->m_pNextFree->m_pPrevFree = pSample->m_pPrevFree;
                } else {
                    m_pLastFree = pSample->m_pPrevFree;
                }
                pSample->m_pNextFree = pSample->m_pPrevFree = NULL;
                bWorked = true;
            }
        }
        CHECKSAMPLELIST
    }
    Unlock();
    return bWorked;
}


HRESULT CStream::CheckReceiveConnectionPin(IPin * pPin)
{
    HRESULT hr;
    if (!pPin) {
        hr = E_POINTER;
    } else {
        if (m_pConnectedPin != NULL) {
            hr = VFW_E_ALREADY_CONNECTED;
        } else {
            PIN_INFO pinfo;
            hr = pPin->QueryPinInfo(&pinfo);
            if (hr == NOERROR) {
                pinfo.pFilter->Release();
                if (pinfo.dir == m_Direction) {
                    hr = VFW_E_INVALID_DIRECTION;
                }
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\stream.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// Stream.h : Declaration of the CStream

#ifndef __STREAM_H_
#define __STREAM_H_

class CSample;

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE CStream :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IPin,
    public IMemInputPin,
    public IAMMediaStream,
    public IMemAllocator
{
public:
    typedef CComObjectRootEx<CComMultiThreadModel> _BaseClass;
    DECLARE_GET_CONTROLLING_UNKNOWN()
    //
    // METHODS
    //
    CStream();
    virtual ~CStream();

    //
    // IMediaStream
    //

    STDMETHODIMP GetMultiMediaStream(
        /* [out] */ IMultiMediaStream **ppMultiMediaStream);

    STDMETHODIMP GetInformation(
        /* [optional][out] */ MSPID *pPurposeId,
        /* [optional][out] */ STREAM_TYPE *pType);

    STDMETHODIMP SendEndOfStream(DWORD dwFlags);

    //
    // IAMMediaStream
    //
    STDMETHODIMP Initialize(
        IUnknown *pSourceObject,
        DWORD dwFlags,
        /* [in] */ REFMSPID PurposeId,
        /* [in] */ const STREAM_TYPE StreamType);

    STDMETHODIMP SetState(
        /* [in] */ FILTER_STATE State) = 0; // derived class supplies pump class

    STDMETHODIMP JoinAMMultiMediaStream(
        /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream);

    STDMETHODIMP JoinFilter(
        /* [in] */ IMediaStreamFilter *pMediaStreamFilter);

    STDMETHODIMP JoinFilterGraph(
        /* [in] */ IFilterGraph *pFilterGraph);


    //
    // IPin
    //
    STDMETHODIMP Disconnect();
    STDMETHODIMP ConnectedTo(IPin **pPin);
    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP QueryPinInfo(PIN_INFO * pInfo);
    STDMETHODIMP QueryDirection(PIN_DIRECTION * pPinDir);
    STDMETHODIMP QueryId(LPWSTR * Id);
    STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP QueryInternalConnections(IPin* *apPin, ULONG *nPin);
    STDMETHODIMP EndOfStream(void);
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    //
    // IMemInputPin
    //
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);
    STDMETHODIMP ReceiveMultiple(IMediaSample **pSamples, long nSamples, long *nSamplesProcessed);
    STDMETHODIMP ReceiveCanBlock();
    STDMETHODIMP Connect(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    //
    // IMemAllocator
    //
    STDMETHODIMP Commit() = 0; // derived class supplies pump class
    STDMETHODIMP Decommit() = 0; // derived class supplies pump class
    STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);

    // Note that NotifyAllocator calls this so override it
    // if you care.  Audio doesn't care becuase it's not
    // really using this allocator at all.
    STDMETHODIMP SetProperties(
    	ALLOCATOR_PROPERTIES* pRequest,
    	ALLOCATOR_PROPERTIES* pActual)
    {
        return S_OK;
    }
    STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps)
    {
        return E_UNEXPECTED;
    }

    //
    // Special CStream methods
    //
    virtual HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType) = 0;

public:
    //
    //  Private methods
    //
    void GetName(LPWSTR);
    HRESULT AllocSampleFromPool(const REFERENCE_TIME * pStartTime, CSample **ppSample, DWORD dwFlags);
    void AddSampleToFreePool(CSample *pSample);
    bool StealSampleFromFreePool(CSample *pSample, BOOL bAbort);
    HRESULT FinalConstruct(void);
    HRESULT ConnectThisMediaType(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
    HRESULT CheckReceiveConnectionPin(IPin * pConnector);
#ifdef DEBUG
    #define CHECKSAMPLELIST TM_ASSERT(CheckSampleList());
    bool CheckSampleList();
#else
    #define CHECKSAMPLELIST
#endif

BEGIN_COM_MAP(CStream)
    COM_INTERFACE_ENTRY(IPin)
    COM_INTERFACE_ENTRY(IMemInputPin)
    COM_INTERFACE_ENTRY(IMemAllocator)
    COM_INTERFACE_ENTRY2(IMediaStream, IAMMediaStream)
    COM_INTERFACE_ENTRY(IAMMediaStream)
END_COM_MAP()

    //
    //  MEMBER VARIABLES
    //
public:
    //
    //  These SHOULD NOT BE CCOMPTRS since we hold weak references to both of them
    //  (we never addref them).
    //
    IMediaStreamFilter             *m_pFilter;
    IBaseFilter                    *m_pBaseFilter;
    IFilterGraph                   *m_pFilterGraph;
    IAMMultiMediaStream            *m_pMMStream;

    //  Allocator held during connection
    CComPtr<IMemAllocator>          m_pAllocator;

    //  Stream configuration
    STREAM_TYPE                     m_StreamType;
    PIN_DIRECTION                   m_Direction;
    MSPID                           m_PurposeId;
    REFERENCE_TIME                  m_rtSegmentStart;

    //  Allocator state information
    bool                            m_bUsingMyAllocator;
    bool                            m_bSamplesAreReadOnly;
    bool                            m_bCommitted;
    long                            m_lRequestedBufferCount;

    //  Sample list and semaphores
    CSample                         *m_pFirstFree;
    CSample                         *m_pLastFree;
    long                            m_cAllocated;
    long                            m_lWaiting;
    HANDLE                          m_hWaitFreeSem;
    REFERENCE_TIME                  m_rtWaiting;

    //  Filter state
    FILTER_STATE                    m_FilterState;

    //  Pin state
    CComPtr<IPin>                   m_pConnectedPin;
    CComPtr<IQualityControl>        m_pQC;
    CComQIPtr<IMemInputPin, &IID_IMemInputPin> m_pConnectedMemInputPin;
    AM_MEDIA_TYPE                   m_ConnectedMediaType;
    AM_MEDIA_TYPE                   m_ActualMediaType;
    bool                            m_bFlushing;
    bool                            m_bEndOfStream;
    bool                            m_bStopIfNoSamples;
};


#endif //__STREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\timerq.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#ifndef __TIMER_QUEUE__
#define __TIMER_QUEUE__

#include "meterf.h"

// we don't allow timeouts greater than 1 day
// this ensures that we don't get multiple wraparounds in the timerqueue,
// which has a wraparound time of 49 days

const DWORD MAX_TIMEOUT         = 1000 * 60 * 60 * 24;

const DWORD MAX_DWORD           = DWORD(-1);

class CTimerQueue;
class CMediaPump;

class CFilterInfo
{
    friend CTimerQueue;
    friend CMediaPump;

public:

    // null entries
    inline CFilterInfo(
        IN CMediaTerminalFilter *pFilter    = NULL,
        IN HANDLE               hWaitEvent  = NULL
        );

    inline BOOL InQueue();

    inline void ScheduleNextTimeout(
        IN  CTimerQueue &TimerQueue,
        IN  DWORD       TimeOut
        );


    LONG AddRef()
    {
        return InterlockedIncrement(&m_lRefCount);
    }

    LONG Release()
    {
        LONG l = InterlockedDecrement(&m_lRefCount);

        if (0 == l)
        {
            delete this;
        }

        return l;
    }

private:

    LONG m_lRefCount;

protected:

    //
    // the only way to destroy filterinfo is through Release()
    //

    inline ~CFilterInfo();


    // m_pFilter holds a refcnt.
    // the wait event is signaled when a new sample 
    // is available
    CMediaTerminalFilter    *m_pFilter;
    HANDLE                  m_hWaitEvent;

    // contains the absolute time to trigger the timeout event
    // this is based upon the value returned by timeGetTime()
    DWORD                   m_WaitTime;

    // prev and next ptrs in an intrusive doubly linked list
    CFilterInfo             *m_pPrev;
    CFilterInfo             *m_pNext;
};


// null entries
inline 
CFilterInfo::CFilterInfo(
    IN CMediaTerminalFilter *pFilter,   /* = NULL */
    IN HANDLE               hWaitEvent  /* = NULL */
    )
    : m_pFilter(pFilter),
      m_hWaitEvent(hWaitEvent),
      m_pPrev(NULL),
      m_pNext(NULL),
      m_lRefCount(0)

{
    // either both pFilter and hWaitEvent are null, or both are non-null
    // enough to assert on this
    TM_ASSERT((NULL == pFilter) == (NULL == hWaitEvent));

    if (NULL != m_pFilter)  m_pFilter->GetControllingUnknown()->AddRef();
}

CFilterInfo::~CFilterInfo(
    )
{
    // release refcnt on the filter
    if (NULL != m_pFilter)  m_pFilter->GetControllingUnknown()->Release();
}

inline BOOL 
CFilterInfo::InQueue(
    )
{
    // either both prev/next are null or both are not null
    TM_ASSERT((NULL == m_pPrev) == (NULL == m_pNext));

    return (NULL != m_pPrev) ? TRUE : FALSE;
}

// ScheduleNextTimeout(2 params) - declared at the end of the file
// as it uses CTimerQueue::Insert and has to be inline

// CTimerQueue is a doubly linked intrusive list of CFilterInfo
// the wait time values in the entries represents the absolute time at which
// they must be fired.
// we assume that the timeout values are small (<=MAX_TIMEOUT) and, 
// therefore, we can have atmost one wrap around in the list at a time.
// to deal with a wrap around, when computing the time difference between two
// time values, we use the least time to get to one time from the other
// ex. MAX_DWORD-1, 5 - the difference is (MAX_DWORD - (MAX_DWORD-1) + 5)
// this is quite reasonable as the value range is 49.1 days (MAX_DWORD)
class CTimerQueue
{
public:

    inline CTimerQueue()
    {
        m_Head.m_pNext = m_Head.m_pPrev = &m_Head;
    }

    inline BOOL         IsEmpty();

    DWORD   GetTimeToTimeout();

    inline CFilterInfo  *RemoveFirst();

    void Insert(
        IN CFilterInfo *pNewFilterInfo
        );

    BOOL Remove(
        IN CFilterInfo *pFilterInfo
        );

protected:

    // no need to call Init
    CFilterInfo m_Head;

    inline BOOL IsHead(
        IN const CFilterInfo *pFilterInfo
        )
    {
        return (&m_Head == pFilterInfo) ? TRUE : FALSE;
    }

    // to deal with a wrap around, when computing the time difference 
    // between two time values, we use the least time to get to one time 
    // from the other - ex. MAX_DWORD-1, 5 - the difference is 
    // (MAX_DWORD - (MAX_DWORD-1) + 5). this is quite reasonable as the 
    // value range is 49.1 days (MAX_DWORD)
    DWORD GetMinDiff(
        IN  DWORD Time1,
        IN  DWORD Time2,
        OUT BOOL  &bIsWrap
        );
};


inline BOOL         
CTimerQueue::IsEmpty(
    )
{
    return IsHead(m_Head.m_pNext);
}


CFilterInfo *
CTimerQueue::RemoveFirst(
    )
{
    TM_ASSERT(!IsEmpty());

    CFilterInfo *ToReturn = m_Head.m_pNext;
    Remove(ToReturn);

    return ToReturn;
}


// this method has to be declared after the CTimerQueue declaration as it
// uses its Insert method

// this is called after returning from GetFilledBuffer. the filter suggests
// a timeout offset for the next call into GetFilledBuffer, but the timer
// puts a limit on the time out value to a max of MAX_TIMEOUT
inline void 
CFilterInfo::ScheduleNextTimeout(
    IN  CTimerQueue &TimerQueue,
    IN  DWORD       TimeOut
    )
{
    TM_ASSERT(!InQueue());

    if (MAX_TIMEOUT < TimeOut)  TimeOut = MAX_TIMEOUT;
    m_WaitTime = TimeOut + timeGetTime();
    TimerQueue.Insert(this);
}


#endif // __TIMER_QUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\tmutils.h ===
///////////////////////////////////////////////////////////////////////////////
//
//         File: tmutils.h
//
//  Description: Useful Tepmlate Code, debugging stuff, general utilities
//               used throughout the termmgr and MST
//
///////////////////////////////////////////////////////////////////////////////


//
//  Note:
//
//  use tm.h to define symbols shared throughout modules composing terminal 
//  manager
//


#ifndef ___TM_UTILS_INCLUDED___
    #define ___TM_UTILS_INCLUDED___


    #if defined(_DEBUG)
        #define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
    #endif

    #define DECLARE_VQI() \
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0; \
        STDMETHOD_(ULONG, AddRef)() = 0; \
        STDMETHOD_(ULONG, Release)() = 0;

    bool IsSameObject(IUnknown *pUnk1, IUnknown *pUnk2);

    STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf);

    #ifdef UNICODE
    #define WStringFromGUID TStringFromGUID
    #else
    STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf);
    #endif

    void InitMediaType(AM_MEDIA_TYPE *pmt);

    // We use ATL for our lists
    // #include <atlapp.h>
    // #define CList CSimpleArray

    // We use our own assertions
    #define ASSERT(x) TM_ASSERT(x)

    // inline fns, macros

    inline BOOL 
    HRESULT_FAILURE(
        IN HRESULT HResult
        )
    { 
        // ZoltanS: We now consider S_FALSE to be success. Hopefully nothing
        // depends on this...

        // return (FAILED(HResult) || (S_FALSE == HResult));
        return FAILED(HResult);
    }

    // ZoltanS: We now consider S_FALSE to be success. Hopefully nothing
    // depends on this...
    //    if ( FAILED(LocalHResult) || (S_FALSE == LocalHResult) )

    #define BAIL_ON_FAILURE(MacroHResult)       \
    {                                           \
        HRESULT LocalHResult = MacroHResult ;   \
        if ( FAILED(LocalHResult) )    \
        {                                                           \
            LOG((MSP_ERROR, "BAIL_ON_FAILURE - error %x", LocalHResult));   \
            return LocalHResult;                                                \
        }                                                                       \
    }


    // NULL is second - this way if an == operator
    // is defined on Ptr, the operator may be used
    #define BAIL_IF_NULL(Ptr, ReturnValue)  \
    {                                       \
        void *LocalPtr = (void *)Ptr;       \
        if ( LocalPtr == NULL )             \
        {                                   \
            LOG((MSP_ERROR, "BAIL_IF_NULL - ret value %x", ReturnValue));   \
            return ReturnValue;             \
        }                                   \
    }


    // sets the first bit to indicate error
    // sets the win32 facility code
    // this is used instead of the HRESULT_FROM_WIN32 macro because that clears the customer flag
    inline long
    HRESULT_FROM_ERROR_CODE(
        IN          long    ErrorCode
        )
    {
        // LOG((MSP_ERROR, "HRESULT_FROM_ERROR_CODE - error %x", (0x80070000 | (0xa000ffff & ErrorCode))));
        return ( 0x80070000 | (0xa000ffff & ErrorCode) );
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    // Better auto critical section lock
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////

    // locks a critical section, and unlocks it automatically
    // when the lock goes out of scope ONLY if (and as many times as)
    // it holds it
    // It may also be locked and unlocked independently

    template <class T>
    class LOCAL_CRIT_LOCK 
    {
    public:

        LOCAL_CRIT_LOCK(
            IN  T *plock
            )
        {
            m_pLock = plock;
            m_pLock->Lock();
            NumLocksHeld = 1;
        }

        BOOL IsLocked(
            )
        {
            return ( (NumLocksHeld > 0)? TRUE : FALSE );
        }

        void Lock(
            )
        {
            m_pLock->Lock();
            NumLocksHeld++;
        }

        void Unlock(
            )
        {
            NumLocksHeld--;
            m_pLock->Unlock();
        }        

        ~LOCAL_CRIT_LOCK(
            ) 
        {
            while (IsLocked())
            { 
                Unlock();
            }
        }

    protected:

        DWORD   NumLocksHeld;
        T       *m_pLock;

    private:
        // make copy constructor and assignment operator inaccessible

        LOCAL_CRIT_LOCK(
            IN const LOCAL_CRIT_LOCK<T> &RefLocalLock
            );

        LOCAL_CRIT_LOCK<T> &operator=(const LOCAL_CRIT_LOCK<T> &RefLocalLock);
    };

    typedef LOCAL_CRIT_LOCK<CComObjectRoot> COM_LOCAL_CRIT_LOCK;


    #ifdef DBG

        //
        // Declare methods to log the AddRef/Release calls and values
        //
        #define DECLARE_DEBUG_ADDREF_RELEASE(x) \
            void LogDebugAddRef(DWORD dw) \
            { LOG((MSP_TRACE, "%s::AddRef() = %d", _T(#x), dw)); } \
            void LogDebugRelease(DWORD dw) \
            { LOG((MSP_TRACE, "%s::Release() = %d", _T(#x), dw)); }

        //
        // Create a template class derived from CComObject to supply
        //  the debug logic.
        //
        template <class base>
        class CTMComObject : public CComObject<base>
        {
            typedef CComObject<base> _BaseClass;
            STDMETHOD_(ULONG, AddRef)()
            {
                DWORD dwR = _BaseClass::AddRef();
                base::LogDebugAddRef(m_dwRef);
                return dwR;
            }
            STDMETHOD_(ULONG, Release)()
            {
                DWORD dwRef = m_dwRef;
                DWORD dwR = _BaseClass::Release();
                LogDebugRelease(--dwRef);
                return dwR;
            }
        };

    #else // #ifdef DBG

        #define DECLARE_DEBUG_ADDREF_RELEASE(x)

    #endif // #ifdef DBG

    // ??? why???
    #ifndef __WXUTIL__

        // locks a critical section, and unlocks it automatically
        // when the lock goes out of scope
        class CAutoObjectLock {

            // make copy constructor and assignment operator inaccessible

            CAutoObjectLock(const CAutoObjectLock &refAutoLock);
            CAutoObjectLock &operator=(const CAutoObjectLock &refAutoLock);

        protected:
            CComObjectRoot * m_pObject;

        public:
            CAutoObjectLock(CComObjectRoot * pobject)
            {
                m_pObject = pobject;
                m_pObject->Lock();
            };

            ~CAutoObjectLock() {
                m_pObject->Unlock();
            };
        };

        #define AUTO_CRIT_LOCK CAutoObjectLock lck(this);

        #ifdef _DEBUG
            #define EXECUTE_ASSERT(_x_) TM_ASSERT(_x_)
        #else
            #define EXECUTE_ASSERT(_x_) _x_
        #endif

    // ??? why???
    #endif // #ifndef __WXUTIL__


#endif // ___TM_UTILS_INCLUDED___

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\tmutils.cpp ===
//
// tmutils.cpp : Utility functions
//

#include "stdafx.h"
#include <fourcc.h>

bool IsSameObject(IUnknown *pUnk1, IUnknown *pUnk2)
{
    if (pUnk1 == pUnk2) {
  	return TRUE;
    }
    //
    // NOTE:  We can't use CComQIPtr here becuase it won't do the QueryInterface!
    //
    IUnknown *pRealUnk1;
    IUnknown *pRealUnk2;
    pUnk1->QueryInterface(IID_IUnknown, (void **)&pRealUnk1);
    pUnk2->QueryInterface(IID_IUnknown, (void **)&pRealUnk2);
    pRealUnk1->Release();
    pRealUnk2->Release();
    return (pRealUnk1 == pRealUnk2);
}


STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf)
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), pguid->Data1,
            pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1], pguid->Data4[2],
            pguid->Data4[3], pguid->Data4[4], pguid->Data4[5], pguid->Data4[6], pguid->Data4[7]);
}

#ifndef UNICODE
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf)
{
    char szAnsi[40];
    TStringFromGUID(pguid, szAnsi);
    MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszBuf, sizeof(szAnsi));
}
#endif


//
//  Media Type helpers
//

void InitMediaType(AM_MEDIA_TYPE * pmt)
{
    ZeroMemory(pmt, sizeof(*pmt));
    pmt->lSampleSize = 1;
    pmt->bFixedSizeSamples = TRUE;
}



bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2)
{
    return ((IsEqualGUID(mt1.majortype,mt2.majortype) == TRUE) &&
        (IsEqualGUID(mt1.subtype,mt2.subtype) == TRUE) &&
        (IsEqualGUID(mt1.formattype,mt2.formattype) == TRUE) &&
        (mt1.cbFormat == mt2.cbFormat) &&
        ( (mt1.cbFormat == 0) ||
        ( memcmp(mt1.pbFormat, mt2.pbFormat, mt1.cbFormat) == 0)));
}


//
// Load string for this resource. Safe with respect to string size. 
// the caller is responsible for freeing returned memory by calling 
// SysFreeString
//

BSTR SafeLoadString( UINT uResourceID )
{

    TCHAR *pszTempString = NULL;

    int nCurrentSizeInChars = 128;
    
    int nCharsCopied = 0;
    

    do
    {

        if ( NULL != pszTempString )
        {
            delete pszTempString;
            pszTempString = NULL;
        }

        nCurrentSizeInChars *= 2;

        pszTempString = new TCHAR[nCurrentSizeInChars];

        if (NULL == pszTempString)
        {
            return NULL;
        }

        nCharsCopied = ::LoadString( _Module.GetResourceInstance(),
                                     uResourceID,
                                     pszTempString,
                                     nCurrentSizeInChars
                                    );

        if ( 0 == nCharsCopied )
        {
            delete pszTempString;
            return NULL;
        }

        //
        // nCharsCopied does not include the null terminator
        // so compare it to the size of the buffer - 1
        // if the buffer was filled completely, retry with a bigger buffer
        //

    } while ( (nCharsCopied >= (nCurrentSizeInChars - 1) ) );


    //
    // allocate bstr and initialize it with the string we have
    //
    
    BSTR bstrReturnString = SysAllocString(pszTempString);


    //
    // no longer need this
    //

    delete pszTempString;
    pszTempString = NULL;


    return bstrReturnString;
}




///////////////////////////////////////////////////////////////////////////////
//
// DumpAllocatorProperties
//
// helper function that dumps allocator properties preceeded by the argumen 
// string
//

void DumpAllocatorProperties(const char *szString, 
                             const ALLOCATOR_PROPERTIES *pAllocProps)
{

    LOG((MSP_INFO,
        "%s - AllocatorProperties at [%p]\n"
        "   cBuffers  [%ld] \n"
        "   cbBuffer  [%ld] \n"
        "   cbAlign   [%ld] \n"
        "   cbPrefix  [%ld]",
        szString,
        pAllocProps,
        pAllocProps->cBuffers,
        pAllocProps->cbBuffer,
        pAllocProps->cbAlign,
        pAllocProps->cbPrefix
        ));
}


//
// returns true if the media type structure is bad
//

BOOL IsBadMediaType(IN const AM_MEDIA_TYPE *pMediaType)
{

    //
    // make sure the structure we got is good
    //

    if (IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)))
    {
        LOG((MSP_ERROR,
            "CBSourcePin::put_MediaTypeOnPin - bad media type stucture passed in"));
        
        return TRUE;
    }


    //
    // make sure format buffer is good, as advertized
    //

    if ( (pMediaType->cbFormat > 0) && IsBadReadPtr(pMediaType->pbFormat, pMediaType->cbFormat) )
    {

        LOG((MSP_ERROR,
            "CBSourcePin::put_MediaTypeOnPin - bad format field in media type structure passed in"));
        
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\tmvidrnd.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

//
// tmVidrnd.cpp : Implementation of video render terminal.
//

#include "stdafx.h"
#include "termmgr.h"
#include "tmvidrnd.h"


///////////////////////////////////////////////////////////////////////////////


CMSPThread g_VideoRenderThread;



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::InitializeDynamic(
	        IN  IID                   iidTerminalClass,
	        IN  DWORD                 dwMediaType,
	        IN  TERMINAL_DIRECTION    Direction,
            IN  MSP_HANDLE            htAddress
            )
{
    USES_CONVERSION;

    LOG((MSP_TRACE, "CVideoRenderTerminal::Initialize - enter"));

    if ( Direction != TD_RENDER )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
                "invalid direction - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    HRESULT hr;

    //
    // Now do the base class method.
    //

    hr = CBaseTerminal::Initialize(iidTerminalClass,
                                   dwMediaType,
                                   Direction,
                                   htAddress);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
                "base class method failed - returning 0x%08x", hr));

        return hr;
    }

    //
    // attempt to "start" thread for doing asyncronous work
    //
    // the global thread object has a "start count". each initialized terminal
    // will start it on initialization (only the first terminal will actually
    // _start_ the thread).
    //
    // on cleanup, each initialized terminal will "stop" the thread object 
    // (same run count logic applies -- only the last terminal will actually
    // _stop_ the thread).
    //

    hr = g_VideoRenderThread.Start();    

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
            "Creating thread failed. return: %x", hr));

        return hr;
    }


    
    //
    // it seems the tread started successfully. set this flag so that we know 
    // if we need to stop in destructor
    //

    m_bThreadStarted = TRUE;


    //
    // Create the video renderer filter as a synchronous work item on our
    // worker thread, because the filter needs a window message pump.
    //

    CREATE_VIDEO_RENDER_FILTER_CONTEXT Context;

    Context.ppBaseFilter     = & m_pIFilter;    // will be filled in on completion
    Context.hr               = E_UNEXPECTED;    // will be used as return value

    hr = g_VideoRenderThread.QueueWorkItem(WorkItemProcCreateVideoRenderFilter,
                                (void *) & Context,
                                TRUE); // synchronous
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
            "can't queue work item - returning 0x%08x", hr));


        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;
        
        return hr;
    }

    //
    // We successfully queued and completed the work item. Now check the
    // return value.
    //

    if ( FAILED(Context.hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
            "CoCreateInstance work item failed - returning 0x%08x",
            Context.hr));

        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;


        return Context.hr;
    }

    //
    // Find our exposed pin.
    //

    hr = FindTerminalPin();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize - "
            "FindTerminalPin failed; returning 0x%08x", hr));

        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;

        return hr;
    }

    //
    // Get the basic video interface for the filter.
    //

    hr = m_pIFilter->QueryInterface(IID_IBasicVideo,
                                    (void **) &m_pIBasicVideo);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize "
            "(IBasicVideo QI) - returning error: 0x%08x", hr));

        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;

        return hr;
    }

    //
    // Get the video window interface for the filter.
    //

    hr = m_pIFilter->QueryInterface(IID_IVideoWindow,
                                    (void **) &m_pIVideoWindow);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize "
            "(IVideoWindow QI) - returning error: 0x%08x", hr));

        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;

        return hr;
    }

    //
    // Get the draw video image interface for the filter.
    //

    hr = m_pIFilter->QueryInterface(IID_IDrawVideoImage,
                                    (void **) &m_pIDrawVideoImage);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize "
            "(IDrawVideoImage QI) - returning error: 0x%08x", hr));

        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;

        return hr;
    }

    //
    // Since this filter does not support a name we get one from our resources.
    //

    TCHAR szTemp[MAX_PATH];

    if (::LoadString(_Module.GetResourceInstance(), IDS_VIDREND_DESC, szTemp, MAX_PATH))
    {
        lstrcpyn(m_szName, szTemp, MAX_PATH);
    }
    else
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::Initialize "
            "(LoadString) - returning E_UNEXPECTED"));

        //
        // undo our starting the thread
        //

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;

        return E_UNEXPECTED;
    }


    LOG((MSP_TRACE, "CVideoRenderTerminal::Initialize - exit S_OK"));
    return S_OK;
}


CVideoRenderTerminal::~CVideoRenderTerminal()
{

    LOG((MSP_TRACE, "CVideoRenderTerminal::~CVideoRenderTerminal - enter"));


    //
    // we nee to explicitly release these before stopping the thread, since 
    // stopping the thread will cause couninitialize that will cause eventual
    // unload of the dll containing code for objects referred by these 
    // pointers.
    //
    // these are smart pointers, so we just ground them,
    //

    m_pIBasicVideo     = NULL;
    m_pIVideoWindow    = NULL;
    m_pIDrawVideoImage = NULL;


    //
    // release base class' data members. a bit hacky, but we need to do this 
    // before stopping the worker thread.
    //

    m_pIPin    = NULL;
    m_pIFilter = NULL;
    m_pGraph   = NULL;

    //
    // if the terminal successfully initialized and the thread started, 
    // stop it (the thread object has start count).
    //

    if (m_bThreadStarted)
    {
        LOG((MSP_TRACE, "CVideoRenderTerminal::~CVideoRenderTerminal - stopping thread"));

        g_VideoRenderThread.Stop();
        m_bThreadStarted = FALSE;

    }

    LOG((MSP_TRACE, "CVideoRenderTerminal::~CVideoRenderTerminal - finish"));

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


DWORD WINAPI WorkItemProcCreateVideoRenderFilter(LPVOID pVoid)
{
    LOG((MSP_TRACE, "WorkItemProcCreateVideoRenderFilter - enter"));

    CREATE_VIDEO_RENDER_FILTER_CONTEXT * pContext =
        (CREATE_VIDEO_RENDER_FILTER_CONTEXT *) pVoid;

    (pContext->hr) = CoCreateInstance(
                                      CLSID_VideoRenderer,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IBaseFilter,
                                      (void **) (pContext->ppBaseFilter)
                                     );

    LOG((MSP_TRACE, "WorkItemProcCreateVideoRenderFilter - exit"));

    return 0;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CVideoRenderTerminal::FindTerminalPin(
    )
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::FindTerminalPin - enter"));

    if (m_pIPin != NULL)
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::FindTerminalPin - "
            "already got a pin - returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    HRESULT hr;
    CComPtr<IEnumPins> pIEnumPins;
    ULONG cFetched;
    //
    // Find the render pin for the filter.
    //
    if (FAILED(hr = m_pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR,
            "CVideoRenderTerminal::FindTerminalPin - can't enum pins %8x",
            hr));
        return hr;
    }

    if (S_OK != (hr = pIEnumPins->Next(1, &m_pIPin, &cFetched)))
    {
        LOG((MSP_ERROR,
            "CVideoRenderTerminal::FindTerminalPin - can't get a pin %8x",
            hr));
        return (hr == S_FALSE) ? E_FAIL : hr;
    }

    LOG((MSP_TRACE, "CVideoRenderTerminal::FindTerminalPin - exit S_OK"));
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CVideoRenderTerminal::AddFiltersToGraph(
    )
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::AddFiltersToGraph() - enter"));

    USES_CONVERSION;

    if ( m_pGraph == NULL)
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::AddFiltersToGraph() - "
            "we have no graph - returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    if ( m_pIFilter == NULL)
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::AddFiltersToGraph() - "
            "we have no filter - returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    // AddFilter returns VFW_S_DUPLICATE_NAME if name is duplicate; still succeeds

    HRESULT hr;

    try 
    {
        USES_CONVERSION;
        hr = m_pGraph->AddFilter(m_pIFilter, T2CW(m_szName));
    }
    catch (...)
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::AddFiltersToGraph - T2CW threw an exception - "
            "return E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::AddFiltersToGraph() - "
            "Can't add filter. %08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CVideoRenderTerminal::AddFiltersToGraph - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::CompleteConnectTerminal(void)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::CompleteConnectTerminal - "
        "enter"));

    //
    // Don't clobber the base class.
    //

    HRESULT hr = CSingleFilterTerminal::CompleteConnectTerminal();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::CompleteConnectTerminal - "
            "base class method failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Perform sanity checks.
    //

    if (m_pIVideoWindow == NULL)
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::CompleteConnectTerminal - "
            "null ivideowindow ptr - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    if (m_pGraph == NULL)
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::CompleteConnectTerminal - "
            "null graph ptr - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Make the video window invisible by default, ignoring the return code as
    // we can't do anything if it fails. We use the cached AutoShow value
    // in case the app has told us that it wants the window to be AutoShown
    // as soon as streaming starts.
    //

    m_pIVideoWindow->put_Visible( 0 );

    m_pIVideoWindow->put_AutoShow( m_lAutoShowCache );

    LOG((MSP_TRACE, "CVideoRenderTerminal::CompleteConnectTerminal - "
        "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_AvgTimePerFrame(REFTIME * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_AvgTimePerFrame - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof( REFTIME ) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

	HRESULT hr = pIBasicVideo->get_AvgTimePerFrame(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_BitRate(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_BitRate - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_BitRate(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_BitErrorRate(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_BitErrorRate - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_BitErrorRate(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_VideoWidth(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_VideoWidth - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_VideoWidth(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_VideoHeight(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_VideoHeight - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_VideoHeight(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_SourceLeft(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_SourceLeft - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_SourceLeft(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_SourceLeft(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_SourceLeft - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_SourceLeft(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_SourceWidth(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_SourceWidth - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_SourceWidth(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_SourceWidth(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_SourceWidth - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_SourceWidth(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_SourceTop(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_SourceTop - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_SourceTop(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_SourceTop(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_SourceTop - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_SourceTop(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_SourceHeight(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_SourceHeight - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_SourceHeight(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_SourceHeight(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_SourceHeight - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_SourceHeight(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_DestinationLeft(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_DestinationLeft - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_DestinationLeft(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_DestinationLeft(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Destinationleft - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_DestinationLeft(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_DestinationWidth(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_DestinationWidth - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_DestinationWidth(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_DestinationWidth(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_DestinationWidth - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_DestinationWidth(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_DestinationTop(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_DestinationTop - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_DestinationTop(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_DestinationTop(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_DestinationTop - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_DestinationTop(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_DestinationHeight(long * pVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_DestinationHeight - enter"));

    if ( TM_IsBadWritePtr( pVal, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->get_DestinationHeight(pVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_DestinationHeight(long newVal)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_DestinationHeight - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->put_DestinationHeight(newVal);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::SetSourcePosition(long lLeft,
                                                     long lTop,
                                                     long lWidth,
                                                     long lHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::SetSourcePosition - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->SetSourcePosition(lLeft, lTop, lWidth, lHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::GetSourcePosition(long * plLeft,
                                                     long * plTop,
                                                     long * plWidth,
                                                     long * plHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetSourcePosition - enter"));

    if ( TM_IsBadWritePtr( plLeft,   sizeof (long) ) ||
         TM_IsBadWritePtr( plTop,    sizeof (long) ) ||
         TM_IsBadWritePtr( plWidth,  sizeof (long) ) ||
         TM_IsBadWritePtr( plHeight, sizeof (long) )    )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->GetSourcePosition(plLeft, plTop, plWidth, plHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::SetDefaultSourcePosition()
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::SetDefaultSourcePosition - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->SetDefaultSourcePosition();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::SetDestinationPosition(long lLeft,
                                                          long lTop,
                                                          long lWidth,
                                                          long lHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::SetDestinationPosition - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->SetDestinationPosition(lLeft, lTop, lWidth, lHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::GetDestinationPosition(long *plLeft,
                                                          long *plTop,
                                                          long *plWidth,
                                                          long *plHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetDestinationPosition - enter"));

    if ( TM_IsBadWritePtr( plLeft, sizeof (long) ) ||
         TM_IsBadWritePtr( plTop, sizeof (long) ) ||
         TM_IsBadWritePtr( plWidth, sizeof (long) ) ||
         TM_IsBadWritePtr( plHeight, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->GetDestinationPosition(plLeft, plTop, plWidth, plHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::SetDefaultDestinationPosition()
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::SetDefaultDestinationPosition - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->SetDefaultDestinationPosition();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::GetVideoSize(long * plWidth,
                                                long * plHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetVideoSize - enter"));

    if ( TM_IsBadWritePtr( plWidth, sizeof (long) ) ||
         TM_IsBadWritePtr( plHeight, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->GetVideoSize(plWidth, plHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::GetVideoPaletteEntries(
	long lStartIndex,
	long lcEntries,
	long * plcRetrieved,
	long * plPalette
	)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetVideoPaletteEntries - enter"));

    if ( TM_IsBadWritePtr( plcRetrieved, sizeof (long) ) ||
         TM_IsBadWritePtr( plPalette,    sizeof (long) )    )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->GetVideoPaletteEntries(lStartIndex,
                                              lcEntries,
                                              plcRetrieved,
                                              plPalette);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::GetCurrentImage(long * plBufferSize,
                                                   long * pDIBImage)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetCurrentImage - enter"));

    if ( TM_IsBadWritePtr( plBufferSize, sizeof (long) ) ||
         TM_IsBadWritePtr( pDIBImage,    sizeof (long) )    )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->GetCurrentImage(plBufferSize, pDIBImage);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::IsUsingDefaultSource()
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::IsUsingDefaultSource - enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->IsUsingDefaultSource();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::IsUsingDefaultDestination()
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::IsUsingDefaultDestination - "
        "enter"));

    m_CritSec.Lock();
	CComPtr <IBasicVideo> pIBasicVideo = m_pIBasicVideo;
    m_CritSec.Unlock();

    if (pIBasicVideo == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIBasicVideo->IsUsingDefaultDestination();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// IVideoWindow
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::put_Caption(BSTR strCaption)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Caption - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_Caption(strCaption);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CVideoRenderTerminal::get_Caption(BSTR FAR* strCaption)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Caption - enter"));

    if ( TM_IsBadWritePtr( strCaption, sizeof (BSTR) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_Caption(strCaption);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_WindowStyle(long WindowStyle)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_WindowStyle - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_WindowStyle(WindowStyle);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_WindowStyle(long FAR* WindowStyle)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_WindowStyle - enter"));

    if ( TM_IsBadWritePtr( WindowStyle, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_WindowStyle(WindowStyle);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_WindowStyleEx(long WindowStyleEx)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_WindowStyleEx - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_WindowStyleEx(WindowStyleEx);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_WindowStyleEx(long FAR* WindowStyleEx)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_WindowStyleEx - enter"));

    if ( TM_IsBadWritePtr( WindowStyleEx, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_WindowStyleEx(WindowStyleEx);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_AutoShow(long AutoShow)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_AutoShow - enter"));

    //
    // Salvage broken C++ apps that don't know the difference between TRUE and
    // VARIANT_TRUE -- treat any nonzero value as VARIANT_TRUE.
    //

    if ( AutoShow )
    {
        AutoShow = VARIANT_TRUE;
    }

    //
    // Always cache our AutoShow state. If we happen to be connected at this
    // time, then actually propagate the state to the filter.
    // (All of this is because the filter can't change state when it's not
    // connected, and we need to be able to do that to simplify apps.)
    //

    m_CritSec.Lock();

    LOG((MSP_TRACE, "CVideoRenderTerminal::put_AutoShow - "
        "cache was %d, setting to %d", m_lAutoShowCache, AutoShow));

    m_lAutoShowCache = AutoShow;

    TERMINAL_STATE         ts            = m_TerminalState;
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;

    //
    // Need to unlock before we call on the filter, which
    // calls into user32, causing possible deadlocks!
    //

    m_CritSec.Unlock();

    if ( pIVideoWindow == NULL )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::put_AutoShow - "
            "no video window pointer - exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr;

    if ( ts == TS_INUSE)
    {
        LOG((MSP_TRACE, "CVideoRenderTerminal::put_AutoShow - "
            "terminal is in use - calling method on filter"));

        hr = pIVideoWindow->put_AutoShow(AutoShow);
    }
    else
    {
        LOG((MSP_TRACE, "CVideoRenderTerminal::put_AutoShow - "
            "terminal is not in use - only the cache was set"));

        hr = S_OK;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::put_AutoShow - "
            "exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CVideoRenderTerminal::put_AutoShow - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_AutoShow(long FAR* pAutoShow)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_AutoShow - enter"));

    //
    // Check arguments.
    //

    if ( TM_IsBadWritePtr( pAutoShow, sizeof (long) ) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::get_AutoShow - "
            "bad return pointer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // We always cache our state (see the put_AutoShow method) so we can just
    // return the cached state. There should be no other way the filter's
    // visibility can be messed with.
    //

    m_CritSec.Lock();

    LOG((MSP_TRACE, "CVideoRenderTerminal::put_AutoShow - "
        "indicating cached value (%d)", m_lAutoShowCache));

    *pAutoShow = m_lAutoShowCache;

    m_CritSec.Unlock();

    LOG((MSP_TRACE, "CVideoRenderTerminal::get_AutoShow - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_WindowState(long WindowState)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_WindowState - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_WindowState(WindowState);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_WindowState(long FAR* WindowState)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_WindowState - enter"));

    if ( TM_IsBadWritePtr( WindowState, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_WindowState(WindowState);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_BackgroundPalette(
    long BackgroundPalette
    )
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_BackgroundPalette - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_BackgroundPalette(BackgroundPalette);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_BackgroundPalette(
    long FAR* pBackgroundPalette
    )
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_BackgroundPalette - enter"));

    if ( TM_IsBadWritePtr( pBackgroundPalette, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_BackgroundPalette(pBackgroundPalette);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_Visible(long Visible)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Visible - enter"));

    //
    // Salvage broken C++ apps that don't know the difference between TRUE and
    // VARIANT_TRUE -- treat any nonzero value as VARIANT_TRUE.
    //

    if ( Visible )
    {
        Visible = VARIANT_TRUE;
    }

    m_CritSec.Lock();

    CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;

    //
    // Need to unlock before we call on the filter, which
    // calls into user32, causing possible deadlocks!
    //

    m_CritSec.Unlock();

    if ( pIVideoWindow == NULL )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::put_Visible - "
            "no video window pointer - exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr = pIVideoWindow->put_Visible(Visible);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::put_Visible - "
            "exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Visible - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_Visible(long FAR* pVisible)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Visible - enter"));

    //
    // Check arguments.
    //

    if ( TM_IsBadWritePtr( pVisible, sizeof (long) ) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::get_Visible - "
            "bad return pointer - exit E_POINTER"));

        return E_POINTER;
    }

    m_CritSec.Lock();

    CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;

    //
    // Need to unlock before we call on the filter, which
    // calls into user32, causing possible deadlocks!
    //

    m_CritSec.Unlock();

    if ( pIVideoWindow == NULL )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::get_Visible - "
            "no video window pointer - exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr = pIVideoWindow->get_Visible(pVisible);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::get_Visible - "
            "exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Visible - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_Left(long Left)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Left - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_Left(Left);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_Left(long FAR* pLeft)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Left - enter"));

    if ( TM_IsBadWritePtr( pLeft, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_Left(pLeft);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_Width(long Width)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Width - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_Width(Width);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_Width(long FAR* pWidth)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Width - enter"));

    if ( TM_IsBadWritePtr( pWidth, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_Width(pWidth);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_Top(long Top)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Top - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_Top(Top);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_Top(long FAR* pTop)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Top - enter"));

    if ( TM_IsBadWritePtr( pTop, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_Top(pTop);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_Height(long Height)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Height - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_Height(Height);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_Height(long FAR* pHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Height - enter"));

    if ( TM_IsBadWritePtr( pHeight, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_Height(pHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_Owner(OAHWND Owner)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_Owner - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_Owner(Owner);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_Owner(OAHWND FAR* Owner)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_Owner - enter"));

    if ( TM_IsBadWritePtr( Owner, sizeof (OAHWND) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_Owner(Owner);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_MessageDrain(OAHWND Drain)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_MessageDrain - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_MessageDrain(Drain);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_MessageDrain(OAHWND FAR* Drain)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_MessageDrain - enter"));

    if ( TM_IsBadWritePtr( Drain, sizeof (OAHWND) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_MessageDrain(Drain);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_BorderColor(long FAR* Color)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_BorderColor - enter"));

    if ( TM_IsBadWritePtr( Color, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_BorderColor(Color);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_BorderColor(long Color)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_BorderColor - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_BorderColor(Color);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::get_FullScreenMode(long FAR* FullScreenMode)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::get_FullScreenMode - enter"));

    if ( TM_IsBadWritePtr( FullScreenMode, sizeof (long) ) )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->get_FullScreenMode(FullScreenMode);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::put_FullScreenMode(long FullScreenMode)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::put_FullScreenMode - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->put_FullScreenMode(FullScreenMode);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::SetWindowForeground(long Focus)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::SetWindowForeground - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->SetWindowForeground(Focus);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::NotifyOwnerMessage(OAHWND   hwnd,
                                                      long     uMsg,
                                                      LONG_PTR wParam,
                                                      LONG_PTR lParam)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::NotifyOwnerMessage - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->NotifyOwnerMessage(hwnd, uMsg, wParam, lParam);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::SetWindowPosition(long Left,
                                                     long Top,
                                                     long Width,
                                                     long Height)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::SetWindowPosition - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->SetWindowPosition(Left, Top, Width, Height);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::GetWindowPosition(
	long FAR* pLeft, long FAR* pTop, long FAR* pWidth, long FAR* pHeight
	)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetWindowPosition - enter"));

    if ( TM_IsBadWritePtr( pLeft,   sizeof (long) ) ||
         TM_IsBadWritePtr( pTop,    sizeof (long) ) ||
         TM_IsBadWritePtr( pWidth,  sizeof (long) ) ||
         TM_IsBadWritePtr( pHeight, sizeof (long) )    )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->GetWindowPosition(pLeft, pTop, pWidth, pHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::GetMinIdealImageSize(long FAR* pWidth,
                                                        long FAR* pHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GerMinIdealImageSize - enter"));

    if ( TM_IsBadWritePtr( pWidth,  sizeof (long) ) ||
         TM_IsBadWritePtr( pHeight, sizeof (long) )    )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->GetMinIdealImageSize(pWidth, pHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::GetMaxIdealImageSize(long FAR* pWidth,
                                                        long FAR* pHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetMaxIdealImageSize - enter"));

    if ( TM_IsBadWritePtr( pWidth,  sizeof (long) ) ||
         TM_IsBadWritePtr( pHeight, sizeof (long) )    )
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->GetMaxIdealImageSize(pWidth, pHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::GetRestorePosition(long FAR* pLeft,
                                                      long FAR* pTop,
                                                      long FAR* pWidth,
                                                      long FAR* pHeight)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::GetRestorePosition - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->GetRestorePosition(pLeft, pTop, pWidth, pHeight);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::HideCursor(long HideCursor)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::HideCursor - enter"));

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->HideCursor(HideCursor);

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::IsCursorHidden(long FAR* CursorHidden)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::IsCursorHidden - enter"));

    if ( TM_IsBadWritePtr( CursorHidden, sizeof (long) ))
    {
        return E_POINTER;
    }

    m_CritSec.Lock();
	CComPtr <IVideoWindow> pIVideoWindow = m_pIVideoWindow;
    m_CritSec.Unlock();

    if (pIVideoWindow == NULL)
    {
        return E_FAIL; // minimal fix...
    }

    HRESULT hr;

    hr = pIVideoWindow->IsCursorHidden(CursorHidden);

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// IDrawVideoImage
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::DrawVideoImageBegin(void)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::DrawVideoImageBegin - enter"));

    m_CritSec.Lock();
	CComPtr <IDrawVideoImage> pIDrawVideoImage = m_pIDrawVideoImage;
    m_CritSec.Unlock();

    if ( pIDrawVideoImage == NULL )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::DrawVideoImageBegin - "
            "exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr;

    hr = pIDrawVideoImage->DrawVideoImageBegin();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::DrawVideoImageBegin - "
            "exit 0x%08x", hr));

        return hr;
    }
    
    LOG((MSP_TRACE, "CVideoRenderTerminal::DrawVideoImageBegin - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::DrawVideoImageEnd  (void)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::DrawVideoImageEnd - enter"));

    m_CritSec.Lock();
	CComPtr <IDrawVideoImage> pIDrawVideoImage = m_pIDrawVideoImage;
    m_CritSec.Unlock();

    if ( pIDrawVideoImage == NULL )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::DrawVideoImageEnd - "
            "exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr;

    hr = pIDrawVideoImage->DrawVideoImageEnd();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::DrawVideoImageEnd - "
            "exit 0x%08x", hr));

        return hr;
    }
    
    LOG((MSP_TRACE, "CVideoRenderTerminal::DrawVideoImageEnd - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CVideoRenderTerminal::DrawVideoImageDraw (IN  HDC hdc,
                                                       IN  LPRECT lprcSrc,
                                                       IN  LPRECT lprcDst)
{
    LOG((MSP_TRACE, "CVideoRenderTerminal::DrawVideoImageBegin - enter"));

    m_CritSec.Lock();
	CComPtr <IDrawVideoImage> pIDrawVideoImage = m_pIDrawVideoImage;
    m_CritSec.Unlock();

    if ( pIDrawVideoImage == NULL )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::DrawVideoImageDraw - "
            "exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr;

    hr = pIDrawVideoImage->DrawVideoImageDraw(hdc, lprcSrc, lprcDst);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoRenderTerminal::DrawVideoImageDraw - "
            "exit 0x%08x", hr));

        return hr;
    }
    
    LOG((MSP_TRACE, "CVideoRenderTerminal::DrawVideoImageDraw - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\termmgr.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    termmgr.cpp

Abstract:

    Implementation of DLL Exports.

Author:
    
    Created 05/01/97 Michael Clark.

--*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "termmgr.h"
#include "dlldatax.h"

#include "Manager.h"
#include "allterm.h"
#include "meterf.h"
#include "medpump.h"

#include <initguid.h>
#include <uuids.h>

#include <vfwmsgs.h>

#include "FileRecordingTerminal.h"
#include "FPTerm.h"

#include "PTUtil.h"
#include "PTReg.h"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.
//
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#ifdef DEBUG_HEAPS
// ZoltanS: for heap debugging
#include <crtdbg.h>
#endif // DEBUG_HEAPS

CComModule _Module;

// Must have an entry here for each cocreatable object.

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TerminalManager,                CTerminalManager)
    OBJECT_ENTRY(CLSID_VideoWindowTerminal_PRIVATE,    CVideoRenderTerminal)
    OBJECT_ENTRY(CLSID_MediaStreamingTerminal_PRIVATE, CMediaTerminal)
    OBJECT_ENTRY(CLSID_FileRecordingTerminalCOMClass,  CFileRecordingTerminal)
    OBJECT_ENTRY(CLSID_FilePlaybackTerminalCOMClass,   CFPTerminal)
    OBJECT_ENTRY(CLSID_PluggableSuperclassRegistration,CPlugTerminalSuperclass)
    OBJECT_ENTRY(CLSID_PluggableTerminalRegistration,  CPlugTerminal)
END_OBJECT_MAP()

//
// PTInfo
// Structure used to store information about
// our pluggable temrinals implemented into Termmgr.dll

typedef struct
{
    UINT            nSuperclassName;        // Superclass Name
    BSTR            bstrSueprclassCLSID;    // Superclass CLSID
    const CLSID*    pClsidTerminalClass;    // Terminal Class (public CLSID)
    const CLSID*    pClsidCOM;              // COM clsid (private CLSID)
    UINT            nTerminalName;          // Terminal name
    UINT            nCompanyName;           // Company name
    UINT            nVersion;               // Terminal version
    DWORD           dwDirections;           // Terminal directions
    DWORD           dwMediaTypes;           // Media types supported
} PTInfo;

//
// Global array with pluggable terminals implemented into Termmgr.dll
//

PTInfo    g_PlugTerminals[] =
{

    #define SUPERCLASS_CLSID_VIDEO_WINDOW L"{714C6F8C-6244-4685-87B3-B91F3F9EADA7}"

    {
        // VideoWindowTerminal
        IDS_VIDEO_SUPERCLASS,                   // superclass name
        SUPERCLASS_CLSID_VIDEO_WINDOW,          //L"{714C6F8C-6244-4685-87B3-B91F3F9EADA7}",
        &CLSID_VideoWindowTerm,
        &CLSID_VideoWindowTerminal_PRIVATE,     // com class id of the terminal object
        IDS_VIDEO_WINDOW_TERMINAL_NAME,         // L"VideoWindow Terminal",
        IDS_TERMINAL_COMPANY_NAME_MICROSOFT,    // L"Microsoft",
        IDS_VIDEO_TERMINAL_VERSION,             // L"1.1",
        TMGR_TD_RENDER,
        TAPIMEDIATYPE_VIDEO
    },

    
    #define SUPERCLASS_CLSID_MST L"{214F4ACC-AE0B-4464-8405-07029003F8E2}"

    {
        // MediaStreaming Terminal
        IDS_STREAMING_SUPERCLASS,
        SUPERCLASS_CLSID_MST,                   //L"{214F4ACC-AE0B-4464-8405-07029003F8E2}",
        &CLSID_MediaStreamTerminal,
        &CLSID_MediaStreamingTerminal_PRIVATE,
        IDS_MEDIA_STREAMING_TERMINAL_NAME,      //L"MediaStreaming Terminal",
        IDS_TERMINAL_COMPANY_NAME_MICROSOFT,    //L"Microsoft",
        IDS_MEDIA_STREAMING_TERMINAL_VERSION,   //L"1.1",
        TMGR_TD_BOTH,
        TAPIMEDIATYPE_AUDIO
    },


    #define SUPERCLASS_CLSID_FILE L"{B4790031-56DB-4D3E-88C8-6FFAAFA08A91}"

    {
        // FileRecording Terminal
        IDS_FILE_SUPERCLASS,
        SUPERCLASS_CLSID_FILE,                  //L"{B4790031-56DB-4d3e-88C8-6FFAAFA08A91}",
        &CLSID_FileRecordingTerminal,
        &CLSID_FileRecordingTerminalCOMClass,
        IDS_FILE_RECORD_TERMINAL_NAME,          //L"FileRecording Terminal",
        IDS_TERMINAL_COMPANY_NAME_MICROSOFT,    //L"Microsoft",
        IDS_FILE_RECORD_TERMINAL_VERSION,       //L"1.1",
        TMGR_TD_RENDER,
        TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_MULTITRACK
    },


    {
        // FilePlayback Terminal
        IDS_FILE_SUPERCLASS,
        SUPERCLASS_CLSID_FILE,                  //L"{B4790031-56DB-4d3e-88C8-6FFAAFA08A91}",
        &CLSID_FilePlaybackTerminal,
        &CLSID_FilePlaybackTerminalCOMClass,
        IDS_FILE_PLAYBACK_TERMINAL_NAME,        //L"FilePlayback Terminal",
        IDS_TERMINAL_COMPANY_NAME_MICROSOFT,    //L"Microsoft",
        IDS_FILE_PLAYBACK_TERMINAL_VERSION,     //L"1.1",
        TMGR_TD_CAPTURE,
        TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_MULTITRACK
    }

};

/*++
PTRegisterTerminal

Is called by PTRegister,
read the information from the global Pluggable terminals array
--*/
HRESULT PTRegisterTerminal(
    IN int                nTerminal
    )
{
    CPTSuperclass    Superclass;


    LOG((MSP_TRACE, "PTRegisterTerminal - enter"));

    
    //
    // Get the superclass name
    //

    Superclass.m_bstrName = SafeLoadString(g_PlugTerminals[nTerminal].nSuperclassName);

    if( Superclass.m_bstrName == NULL )
    {
        return E_OUTOFMEMORY;
    }


    LOG((MSP_TRACE, "PTRegisterTerminal - superclass [%S]", Superclass.m_bstrName));

    //
    // Get the superclass CLSID
    //
    HRESULT hr = CLSIDFromString(
        g_PlugTerminals[nTerminal].bstrSueprclassCLSID,
        &Superclass.m_clsidSuperclass);
    if( FAILED(hr) )
    {
        return hr;
    }

    Superclass.Add();

    CPTTerminal Terminal;
    PTInfo& TermInfo = g_PlugTerminals[nTerminal];

    //
    // Get the TerminalClass clsid
    //

    Terminal.m_clsidTerminalClass = *TermInfo.pClsidTerminalClass;

    //
    // Get terminal's com class id
    //

    Terminal.m_clsidCOM = *TermInfo.pClsidCOM;

    //
    // Set the other terminal fileds
    // CPTTerminal will deallocate the memory
    //


    Terminal.m_bstrName = SafeLoadString( TermInfo.nTerminalName );
    if( Terminal.m_bstrName == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    LOG((MSP_TRACE, "PTRegisterTerminal - terminal [%S]", Terminal.m_bstrName));


    Terminal.m_bstrCompany = SafeLoadString( TermInfo.nCompanyName );
    if( Terminal.m_bstrCompany == NULL )
    {
        return E_OUTOFMEMORY;
    }

    Terminal.m_bstrVersion = SafeLoadString( TermInfo.nVersion );
    if( Terminal.m_bstrVersion == NULL )
    {
        return E_OUTOFMEMORY;
    }

    Terminal.m_dwDirections = TermInfo.dwDirections;
    Terminal.m_dwMediaTypes = TermInfo.dwMediaTypes;

    //
    // Register terminal
    //

    hr = Terminal.Add( Superclass.m_clsidSuperclass );

    return hr;
}

/*++
PTUnregisterTerminal

  Is called by PTUnregister,
  Read the information from global pluggable terminals array
--*/
HRESULT PTUnregisterTerminal(
    IN    int                nTerminal
    )
{
    CPTSuperclass    Superclass;

    {
        //
        // Get the superclass name
        //
        TCHAR szName[MAX_PATH+1];
        int nRetVal = LoadString( _Module.GetResourceInstance(), 
            g_PlugTerminals[nTerminal].nSuperclassName,
            szName,
            MAX_PATH
            );
        if( 0 == nRetVal )
        {
            return E_OUTOFMEMORY;
        }

        Superclass.m_bstrName = SysAllocString( szName );
    }

    //
    // Get the superclass CLSID
    //
    HRESULT hr = CLSIDFromString(
        g_PlugTerminals[nTerminal].bstrSueprclassCLSID,
        &Superclass.m_clsidSuperclass);

    //
    // Unregister a terminal
    //

    CPTTerminal Terminal;
    Terminal.m_clsidTerminalClass = *g_PlugTerminals[nTerminal].pClsidTerminalClass;
    Terminal.Delete( Superclass.m_clsidSuperclass );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// PTRegister

HRESULT PTRegister()
{
    //
    // Register each pluggable terminal
    //

    for(int nItem = 0; 
        nItem < (sizeof( g_PlugTerminals) / sizeof(PTInfo));
        nItem++)
    {
            PTRegisterTerminal( 
                nItem
                );
    }

   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// PTUnregister
HRESULT PTUnregister()
{
    // Unregister each pluggable terminal
    for(int nItem = 0; 
        nItem < (sizeof( g_PlugTerminals) / sizeof(PTInfo));
        nItem++)
    {
            PTUnregisterTerminal( 
                nItem
                );
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {

#ifdef DEBUG_HEAPS
        // ZoltanS: turn on leak detection on process exit
        _CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF );

        // ZoltanS: force a memory leak
        char * leak = new char [ 1977 ];
        sprintf(leak, "termmgr.dll NORMAL leak");
        leak = NULL;
#endif // DEBUG_HEAPS
        
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        // Register for trace output.
        MSPLOGREGISTER(_T("termmgr"));
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {

        //
        // do not deregister if the process is terminating -- working around 
        // bugs in rtutils that could cause a "deadlock" if DeregisterTracing
        // is called from DllMain on process termination
        //

        if (NULL == lpReserved)
        {
            // Deregister for trace output.

            MSPLOGDEREGISTER();
        }

        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if ( PrxDllCanUnloadNow() != S_OK )
    {
        return S_FALSE;
    }
#endif

    if ( _Module.GetLockCount() == 0 )
    {
        //
        // All references to COM objects in this DLL have been released, so
        // the DLL can now be safely unloaded. After this returns, DllMain
        // will be called with dwReason == DLL_PROCESS_DETACH.
        //

        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if ( PrxDllGetClassObject(rclsid, riid, ppv) == S_OK )
    {
        return S_OK;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    //
    // Register terminals
    HRESULT hReg = PTRegister();

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();

    if ( FAILED(hRes) )
    {
        return hRes;
    }
#endif

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);

    if( FAILED(hr) )
    {
        //
        // This is real bad
        //

        return hr;
    }

    if( FAILED(hReg) )
    {
        //
        // Something was wrong with the
        // registration of pluggable terminals
        // 

        return hReg;
    }

    //
    // Everything was OK
    //

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    //
    // Unregister terminals
    //
    PTUnregister();

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    _Module.UnregisterServer();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\stdafx.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <mspbase.h>
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\common.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <mtype.h>
#include <g711uids.h>
#include <evcode.h>

#include "wavemsp.h"
#include "propbag.h"
#include "waveaddr.h"
#include "wavestrm.h"
#include "wavecall.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\resource.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wavemsp.rc
//
#define IDS_PROJNAME                    100
#define IDR_WaveMSP                     101
#define IDR_MSPCALL                     102
#define IDR_MSPSTREAM                   103
#define IDR_MSPPropBag                  104
#define IDS_CAPTURE_STREAM              105
#define IDS_RENDER_STREAM               106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           1000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\propbag.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// propbag.h : Declaration of the CMyPropertyBag

#ifndef __CMyPropertyBag_H_
#define __CMyPropertyBag_H_

//
// CMyPropertyBag
class ATL_NO_VTABLE CMyPropertyBag :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IPropertyBag
{
private:
    
    DWORD m_dwDeviceInID;
    DWORD m_dwDeviceOutID;
    
public:

    BEGIN_COM_MAP(CMyPropertyBag)
            COM_INTERFACE_ENTRY(IPropertyBag)
    END_COM_MAP()


    HRESULT
    STDMETHODCALLTYPE
    Read( 
          LPCOLESTR pszPropName,
          VARIANT *pVar,
          IErrorLog *pErrorLog
        )
    {
        if (lstrcmpiW( pszPropName, L"WaveInId" ) == 0)
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_dwDeviceInID;
            return S_OK;
        }

        if (lstrcmpiW( pszPropName, L"WaveOutId" ) == 0)
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_dwDeviceOutID;
            return S_OK;
        }

        return S_FALSE;
    }
        
    HRESULT
    STDMETHODCALLTYPE
    Write( 
           LPCOLESTR pszPropName,
           VARIANT *pVar
         )
    {
        if (lstrcmpiW( pszPropName, L"WaveInId" ) == 0)
        {
            m_dwDeviceInID = pVar->lVal;
            return S_OK;
        }

        if (lstrcmpiW( pszPropName, L"WaveOutId" ) == 0)
        {
            m_dwDeviceOutID = pVar->lVal;
            return S_OK;
        }

        

        return S_FALSE;
        
    };
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\waveaddr.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    waveaddr.h

Abstract:

    Declaration of the CWaveMSP

Author:
    
    Zoltan Szilagyi September 6th, 1998

--*/

#ifndef __WAVEADDR_H_
#define __WAVEADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CWaveMSP
/////////////////////////////////////////////////////////////////////////////
class CWaveMSP : 
    public CMSPAddress,
    public IDispatchImpl<ITLegacyWaveSupport, &IID_ITLegacyWaveSupport, &LIBID_TAPI3Lib>,
    public CComCoClass<CWaveMSP, &CLSID_WaveMSP>,
    public CMSPObjectSafetyImpl
{
public:
    CWaveMSP();
    virtual ~CWaveMSP();

    virtual ULONG MSPAddressAddRef(void);
    virtual ULONG MSPAddressRelease(void);

DECLARE_REGISTRY_RESOURCEID(IDR_WaveMSP)
DECLARE_POLY_AGGREGATABLE(CWaveMSP)

BEGIN_COM_MAP(CWaveMSP)
    COM_INTERFACE_ENTRY( IObjectSafety )
    COM_INTERFACE_ENTRY( ITLegacyWaveSupport )
    COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
END_COM_MAP()

public:
    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE     htCall,
        IN      DWORD          dwReserved,
        IN      DWORD          dwMediaType,
        IN      IUnknown    *  pOuterUnknown,
        OUT     IUnknown   **  ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *          pMSPCall
        );

    //
    // Public method for creating the filter mapper cache up front.
    // Called by the stream/call when an intelligent connection is
    // attempted. Does nothing if the cache has already been created.
    //

    virtual HRESULT CreateFilterMapper(void);

protected:

    DWORD GetCallMediaTypes(void);

    //
    // Extra overrides for hiding our wave devices.
    //

    virtual HRESULT ReceiveTSPAddressData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    virtual HRESULT UpdateTerminalList(void);

    //
    // Helper functions.
    //

    virtual BOOL TerminalHasWaveID(
        IN      BOOL         fCapture,
        IN      ITTerminal * pTerminal,
        IN      DWORD        dwWaveID
        );

    //
    // ITLegacyWaveSupport
    //
    
    STDMETHOD (IsFullDuplex) (
        OUT     FULLDUPLEX_SUPPORT * pSupport
        );
    
    //
    // Data for hiding our wave devices.
    //

    BOOL  m_fHaveWaveIDs;
    DWORD m_dwWaveInID;
    DWORD m_dwWaveOutID;
    FULLDUPLEX_SUPPORT  m_fdSupport;

    //
    // Data for creating the filter mapper cache up front.
    //

    IFilterMapper * m_pFilterMapper;
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\termmgr\tmvidrnd.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// tmvidrnd.h: Definition of the CVideoRenderTerminalE class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VIDEOOUTT_H__D1691429_B6CA_11D0_82A4_00AA00B5CA1B__INCLUDED_)
#define AFX_VIDEOOUTT_H__D1691429_B6CA_11D0_82A4_00AA00B5CA1B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

//
// The CLSID that's used to create us.
//

EXTERN_C const CLSID CLSID_VideoWindowTerminal_PRIVATE;

#ifdef INSTANTIATE_GUIDS_NOW

    // {AED6483E-3304-11d2-86F1-006008B0E5D2}
    const CLSID CLSID_VideoWindowTerminal_PRIVATE =
    { 0xaed6483e, 0x3304, 0x11d2, { 0x86, 0xf1, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xd2 } };

#endif // INSTANTIATE_GUIDS_NOW




typedef struct 
{

    OUT  IBaseFilter        ** ppBaseFilter;
    OUT  HRESULT               hr;
   
} CREATE_VIDEO_RENDER_FILTER_CONTEXT;


DWORD WINAPI WorkItemProcCreateVideoRenderFilter(LPVOID pVoid);




/////////////////////////////////////////////////////////////////////////////
// CVideoRenderTerminal
//

class CVideoRenderTerminal :
    public CComCoClass<CVideoRenderTerminal, &CLSID_VideoWindowTerminal_PRIVATE>,
    public CComDualImpl<IBasicVideo, &IID_IBasicVideo, &LIBID_QuartzTypeLib>,
    public CComDualImpl<IVideoWindow, &IID_IVideoWindow, &LIBID_QuartzTypeLib>,
    public IDrawVideoImage,
    public ITPluggableTerminalInitialization,
    public CSingleFilterTerminal,
    public CMSPObjectSafetyImpl
{
public:

    CVideoRenderTerminal()
        :m_bThreadStarted(FALSE)
    {
        LOG((MSP_TRACE, "CVideoRenderTerminal::CVideoRenderTerminal - enter"));

        m_lAutoShowCache = 0;         // window invisible by default
        m_TerminalType  = TT_DYNAMIC; // this is a dynamic terminal

        LOG((MSP_TRACE, "CVideoRenderTerminal::CVideoRenderTerminal - finish"));
    }

    ~CVideoRenderTerminal();
    


// ITPluggableTerminalInitialization
    STDMETHOD(InitializeDynamic) (
	        IN  IID                   iidTerminalClass,
	        IN  DWORD                 dwMediaType,
	        IN  TERMINAL_DIRECTION    Direction,
            IN  MSP_HANDLE            htAddress
            );

    HRESULT FindTerminalPin(void);

BEGIN_COM_MAP(CVideoRenderTerminal)
    COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
    COM_INTERFACE_ENTRY(IBasicVideo)
    COM_INTERFACE_ENTRY(IVideoWindow)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IDrawVideoImage)
    COM_INTERFACE_ENTRY_CHAIN(CSingleFilterTerminal)
END_COM_MAP()

DECLARE_DEBUG_ADDREF_RELEASE(CVideoRenderTerminal)
DECLARE_REGISTRY_RESOURCEID(IDR_VideoRenderTerminal)

// ITBasicVideo
public:

    STDMETHOD(IsUsingDefaultDestination)    (void);
    STDMETHOD(IsUsingDefaultSource)         (void);
    STDMETHOD(GetCurrentImage)              (     long    *plBufferSize,
                                                  long    *pDIBImage);
    STDMETHOD(GetVideoPaletteEntries)       (     long     lStartIndex,
                                                  long     lcEntries,
                                                  long    *plcRetrieved,
                                                  long    *plPalette);
    STDMETHOD(GetVideoSize)                 (     long    *plWidth,
                                                  long    *plHeight);
    STDMETHOD(SetDefaultDestinationPosition)(void);
    STDMETHOD(GetDestinationPosition)       (     long    *plLeft,
                                                  long    *plTop,
                                                  long    *plWidth,
                                                  long    *plHeight);
    STDMETHOD(SetDestinationPosition)       (     long     lLeft,
                                                  long     lTop,
                                                  long     lWidth,
                                                  long     lHeight);
    STDMETHOD(SetDefaultSourcePosition)     (void);
    STDMETHOD(GetSourcePosition)            (     long    *plLeft,
                                                  long    *plTop,
                                                  long    *plWidth,
                                                  long    *plHeight);
    STDMETHOD(SetSourcePosition)            (     long     lLeft,
                                                  long     lTop,
                                                  long     lWidth,
                                                  long     lHeight);
    STDMETHOD(get_DestinationHeight)        (OUT  long    *pVal);
    STDMETHOD(put_DestinationHeight)        (IN   long     newVal);
    STDMETHOD(get_DestinationTop)           (OUT  long    *pVal);
    STDMETHOD(put_DestinationTop)           (IN   long     newVal);
    STDMETHOD(get_DestinationWidth)         (OUT  long    *pVal);
    STDMETHOD(put_DestinationWidth)         (IN   long     newVal);
    STDMETHOD(get_DestinationLeft)          (OUT  long    *pVal);
    STDMETHOD(put_DestinationLeft)          (IN   long     newVal);
    STDMETHOD(get_SourceHeight)             (OUT  long    *pVal);
    STDMETHOD(put_SourceHeight)             (IN   long     newVal);
    STDMETHOD(get_SourceTop)                (OUT  long    *pVal);
    STDMETHOD(put_SourceTop)                (IN   long     newVal);
    STDMETHOD(get_SourceWidth)              (OUT  long    *pVal);
    STDMETHOD(put_SourceWidth)              (IN   long     newVal);
    STDMETHOD(get_SourceLeft)               (OUT  long    *pVal);
    STDMETHOD(put_SourceLeft)               (IN   long     newVal);
    STDMETHOD(get_VideoHeight)              (OUT  long    *pVal);
    STDMETHOD(get_VideoWidth)               (OUT  long    *pVal);
    STDMETHOD(get_BitErrorRate)             (OUT  long    *pVal);
    STDMETHOD(get_BitRate)                  (OUT  long    *pVal);
    STDMETHOD(get_AvgTimePerFrame)          (OUT  REFTIME *pVal);

// IVideoWindow methods
public:

    STDMETHOD(put_Caption)          (THIS_ BSTR        strCaption);
    STDMETHOD(get_Caption)          (THIS_ BSTR   FAR* strCaption);
    STDMETHOD(put_WindowStyle)      (THIS_ long        WindowStyle);
    STDMETHOD(get_WindowStyle)      (THIS_ long   FAR* WindowStyle);
    STDMETHOD(put_WindowStyleEx)    (THIS_ long        WindowStyleEx);
    STDMETHOD(get_WindowStyleEx)    (THIS_ long   FAR* WindowStyleEx);
    STDMETHOD(put_AutoShow)         (THIS_ long        AutoShow);
    STDMETHOD(get_AutoShow)         (THIS_ long   FAR* AutoShow);
    STDMETHOD(put_WindowState)      (THIS_ long        WindowState);
    STDMETHOD(get_WindowState)      (THIS_ long   FAR* WindowState);
    STDMETHOD(put_BackgroundPalette)(THIS_ long        BackgroundPalette);
    STDMETHOD(get_BackgroundPalette)(THIS_ long   FAR* pBackgroundPalette);
    STDMETHOD(put_Visible)          (THIS_ long        Visible);
    STDMETHOD(get_Visible)          (THIS_ long   FAR* pVisible);
    STDMETHOD(put_Left)             (THIS_ long        Left);
    STDMETHOD(get_Left)             (THIS_ long   FAR* pLeft);
    STDMETHOD(put_Width)            (THIS_ long        Width);
    STDMETHOD(get_Width)            (THIS_ long   FAR* pWidth);
    STDMETHOD(put_Top)              (THIS_ long        Top);
    STDMETHOD(get_Top)              (THIS_ long   FAR* pTop);
    STDMETHOD(put_Height)           (THIS_ long        Height);
    STDMETHOD(get_Height)           (THIS_ long   FAR* pHeight);
    STDMETHOD(put_Owner)            (THIS_ OAHWND Owner);
    STDMETHOD(get_Owner)            (THIS_ OAHWND FAR* Owner);
    STDMETHOD(put_MessageDrain)     (THIS_ OAHWND Drain);
    STDMETHOD(get_MessageDrain)     (THIS_ OAHWND FAR* Drain);
    STDMETHOD(get_BorderColor)      (THIS_ long   FAR* Color);
    STDMETHOD(put_BorderColor)      (THIS_ long        Color);
    STDMETHOD(get_FullScreenMode)   (THIS_ long   FAR* FullScreenMode);
    STDMETHOD(put_FullScreenMode)   (THIS_ long        FullScreenMode);
    STDMETHOD(SetWindowForeground)  (THIS_ long        Focus);
    STDMETHOD(NotifyOwnerMessage)   (THIS_ OAHWND      hwnd,
                                           long        uMsg,
                                           LONG_PTR    wParam,
                                           LONG_PTR    lParam);
    STDMETHOD(SetWindowPosition)    (THIS_ long        Left,
                                           long        Top,
                                           long        Width,
                                           long        Height);
    STDMETHOD(GetWindowPosition)    (THIS_ long   FAR* pLeft,
                                           long   FAR* pTop,
                                           long   FAR* pWidth,
                                           long   FAR* pHeight);
    STDMETHOD(GetMinIdealImageSize) (THIS_ long   FAR* pWidth,
                                           long   FAR* pHeight);
    STDMETHOD(GetMaxIdealImageSize) (THIS_ long   FAR* pWidth,
                                           long   FAR* pHeight);
    STDMETHOD(GetRestorePosition)   (THIS_ long   FAR* pLeft,
                                           long   FAR* pTop,
                                           long   FAR* pWidth,
                                           long   FAR* pHeight);
    STDMETHOD(HideCursor)           (THIS_ long        HideCursor);
    STDMETHOD(IsCursorHidden)       (THIS_ long   FAR* CursorHidden);

// IDrawVideoImage
public:

    STDMETHOD(DrawVideoImageBegin)(void);
    STDMETHOD(DrawVideoImageEnd)  (void);
    STDMETHOD(DrawVideoImageDraw) (IN  HDC hdc,
                                   IN  LPRECT lprcSrc,
                                   IN  LPRECT lprcDst);

// Implementation
private:

    //
    // Data members
    //

    CComPtr<IBasicVideo>     m_pIBasicVideo;
    CComPtr<IVideoWindow>    m_pIVideoWindow;
    CComPtr<IDrawVideoImage> m_pIDrawVideoImage;
    long m_lAutoShowCache;


    BOOL m_bThreadStarted;

public:

    //
    // Methods
    //


    // CBaseTerminal required overrides

    STDMETHODIMP CompleteConnectTerminal(void);

    virtual HRESULT AddFiltersToGraph(void);

    virtual DWORD GetSupportedMediaTypes(void)
    {
        return (DWORD) TAPIMEDIATYPE_VIDEO;
    }
};

#endif // !defined(AFX_VIDEOOUTT_H__D1691429_B6CA_11D0_82A4_00AA00B5CA1B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\waveaddr.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    waveaddr.cpp 

Abstract:

    This module contains implementation of CWaveMSP.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSP::CWaveMSP()
{
    LOG((MSP_TRACE, "CWaveMSP::CWaveMSP entered."));
    
    m_fHaveWaveIDs = FALSE;
    m_dwWaveInID   = 0xfeedface;
    m_dwWaveOutID  = 0xfeedface;
    m_fdSupport   = FDS_UNKNOWN;

    m_pFilterMapper = NULL;

    LOG((MSP_TRACE, "CWaveMSP::CWaveMSP exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSP::~CWaveMSP()
{
    LOG((MSP_TRACE, "CWaveMSP::~CWaveMSP entered."));

    if ( m_pFilterMapper )
    {
        m_pFilterMapper->Release();
    }

    LOG((MSP_TRACE, "CWaveMSP::~CWaveMSP exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

ULONG CWaveMSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CWaveMSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSP::CreateMSPCall(
    IN      MSP_HANDLE      htCall,
    IN      DWORD           dwReserved,
    IN      DWORD           dwMediaType,
    IN      IUnknown     *  pOuterUnknown,
    OUT     IUnknown    **  ppMSPCall
    )
{
    LOG((MSP_TRACE, "CWaveMSP::CreateMSPCall - enter"));

    CWaveMSPCall * pCWaveMSPCall;

    HRESULT hr = CreateMSPCallHelper<CWaveMSPCall>(this,
                                                   htCall,
                                                   dwReserved,
                                                   dwMediaType,
                                                   pOuterUnknown,
                                                   ppMSPCall,
                                                   &pCWaveMSPCall);

    //
    // pCWaveMSPCall is not addrefed; no need to release.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::CreateMSPCall - template helper returned"
            "0x%08x", hr));

        return hr;
    }

    //
    // If we know the wave IDs, tell the call. If we don't know the wave IDs
    // or if the setting fails, we still successfully create the call; we will
    // just get failure events during streaming.
    //

    if ( m_fHaveWaveIDs )
    {
        pCWaveMSPCall->SetWaveIDs( m_dwWaveInID, m_dwWaveOutID );
    }

    LOG((MSP_TRACE, "CWaveMSP::CreateMSPCall - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSP::ShutdownMSPCall (
    IN      IUnknown *          pMSPCall
    )
{
    LOG((MSP_TRACE, "CWaveMSP::ShutdownMSPCall - enter"));

    CWaveMSPCall * pCWaveMSPCall;

    HRESULT hr = ShutdownMSPCallHelper<CWaveMSPCall>(pMSPCall,
                                                     &pCWaveMSPCall);

    //
    // pCWaveMSPCall is not addrefed; no need to release.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::ShutdownMSPCall - template helper returned"
            "0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSP::ShutdownMSPCall - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Mandatory CMSPAddress override. This indicates the media types that
// we support.
//

DWORD CWaveMSP::GetCallMediaTypes(void)
{
    return (DWORD) TAPIMEDIATYPE_AUDIO;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Optional CMSPAddress override. Used to find out the wave id's before any
// calls are created, allowing us to exclude our own wave devices from our
// enumeration of static terminals.
//
// We now also use these as the wave ids for all our calls on this address.
// We must get one of these messages before we make any calls -- these
// messages are sent while tapi is initializing the address, and it is
// done synchronously.
//

HRESULT CWaveMSP::ReceiveTSPAddressData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        )
{
    LOG((MSP_TRACE, "CWaveMSP::ReceiveTSPAddressData - enter"));

    //
    // Check that the buffer is as big as advertised.
    //

    if ( IsBadWritePtr(pBuffer, sizeof(BYTE) * dwSize) )
    {
        LOG((MSP_ERROR, "CWaveMSP::ReceiveTSPAddressData - "
            "bad buffer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Check if we have a command DWORD.
    //

    if ( dwSize < sizeof(DWORD) )
    {
        LOG((MSP_ERROR, "CWaveMSP::ReceiveTSPAddressData - "
            "need a DWORD for command - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    int i;
    HRESULT hr;

    //
    // Based on the command, take action:
    //

    switch ( ((DWORD *) pBuffer) [0] )
    {
    case 3: // use wave IDs to hide terminals
        {
            if ( dwSize < 3 * sizeof(DWORD) )
            {
                LOG((MSP_ERROR, "CWaveMSP::ReceiveTSPAddressData - "
                    "need 3 DWORDs for SetWaveID command - "
                    "exit E_INVALIDARG"));

                return E_INVALIDARG;
            }

            m_TerminalDataLock.Lock();

            _ASSERTE( m_fTerminalsUpToDate == FALSE );

            m_fHaveWaveIDs = TRUE;
            m_dwWaveInID   = ((DWORD *) pBuffer) [1];
            m_dwWaveOutID  = ((DWORD *) pBuffer) [2];

            m_TerminalDataLock.Unlock();

            LOG((MSP_INFO, "CWaveMSP::ReceiveTSPAddressData - "
                "setting WaveInID=%d, WaveOutID=%d",
                m_dwWaveInID, m_dwWaveOutID));
        }
        break;

    case 4: // don't use wave IDs to hide terminals
        {
            _ASSERTE( m_fTerminalsUpToDate == FALSE );

            LOG((MSP_INFO, "CWaveMSP::ReceiveTSPAddressData - "
                "got command 4 - not setting wave IDs"));

            // m_fHaveWaveIDs remains FALSE
        }
        break;

    case 8:
        {
            if ( dwSize < 2 * sizeof(DWORD) )
            {
                LOG((MSP_INFO, "CWaveMSP::ReceiveTSPAddressData - "
                     "need 2 DWORDS for set duplex support command - "
                     "exit E_INVALIDARG"));

                return E_INVALIDARG;
            }

            m_TerminalDataLock.Lock();

            if ( 1 == ((DWORD *) pBuffer) [1] )
            {
                m_fdSupport = FDS_SUPPORTED;

                LOG((MSP_INFO, "CWaveMSP::ReceiveTSPAddressData - "
                     "Full Duplex supported"));
            }
            else
            {
                m_fdSupport = FDS_NOTSUPPORTED;
                
                LOG((MSP_INFO, "CWaveMSP::ReceiveTSPAddressData - "
                     "Full Duplex not supported"));
            }

            m_TerminalDataLock.Unlock();
        }
        break;
    
    default:
        LOG((MSP_ERROR, "CWaveMSP::ReceiveTSPAddressData - "
            "invalid command - exit E_INVALIDARG"));

        return E_INVALIDARG;

    }

    LOG((MSP_TRACE, "CWaveMSP::ReceiveTSPAddressData - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Optional CMSPAddress override. Used to remove our own wave devices from
// the list of static terminals.
//

HRESULT CWaveMSP::UpdateTerminalList(void)
{
    LOG((MSP_TRACE, "CWaveMSP::UpdateTerminalList - enter"));

    //
    // Call the base class method. This builds up the list of terminals.
    //

    HRESULT hr = CMSPAddress::UpdateTerminalList();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::UpdateTerminalList - "
            "base class method failed - exit 0x%08x", hr));

        return hr;
    }

    m_TerminalDataLock.Lock();

    if ( m_fHaveWaveIDs )
    {
        int iSize = m_Terminals.GetSize();

        for ( int i = 0; i < iSize; i++ )
        {
            ITTerminal * pTerminal = m_Terminals[i];
            long         lMediaType;

            if ( SUCCEEDED( pTerminal->get_MediaType( & lMediaType ) ) )
            {
                if ( lMediaType == TAPIMEDIATYPE_AUDIO )
                {
                    TERMINAL_DIRECTION dir;
                    
                    if ( SUCCEEDED( pTerminal->get_Direction( & dir ) ) )
                    {
                        if ( TerminalHasWaveID( dir == TD_CAPTURE,
                                                pTerminal,
                                                m_dwWaveOutID      ) )
                        {
                            pTerminal->Release();
                            m_Terminals.RemoveAt(i);
                            i--;
                            iSize--;
                        }

                    } // if direction is available
            
                } // if audio
        
            } // if media type is available
    
        } // for each terminal

    } // if we have wave ids

    m_TerminalDataLock.Unlock();

    LOG((MSP_TRACE, "CWaveMSP::UpdateTerminalList - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Private helpers to check if a terminal has a given wave IDs.
//

BOOL CWaveMSP::TerminalHasWaveID(
    IN      BOOL         fCapture,
    IN      ITTerminal * pTerminal,
    IN      DWORD        dwWaveID
    )
{
    LOG((MSP_TRACE, "CWaveMSP::TerminalHasWaveID - enter"));

    _ASSERTE( ! IsBadReadPtr(pTerminal, sizeof(ITTerminal) ) );

    IMoniker * pMoniker;

    //
    // Cast to the correct type of terminal and get the moniker.
    //

    if ( fCapture )
    {
        CAudioCaptureTerminal * pCaptureTerminal;

        pCaptureTerminal = dynamic_cast<CAudioCaptureTerminal *> (pTerminal);

        if ( pCaptureTerminal == NULL )
        {
            LOG((MSP_ERROR, "CWaveMSP::TerminalHasWaveID - "
                "dynamic cast (capture) failed - exit FALSE"));

            return FALSE;
        }

        pMoniker = pCaptureTerminal->m_pMoniker;
    }
    else
    {
        CAudioRenderTerminal * pRenderTerminal;

        pRenderTerminal = dynamic_cast<CAudioRenderTerminal *> (pTerminal);

        if ( pRenderTerminal == NULL )
        {
            LOG((MSP_ERROR, "CWaveMSP::TerminalHasWaveID - "
                "dynamic cast (render) failed - exit FALSE"));

            return FALSE;
        }

        pMoniker = pRenderTerminal->m_pMoniker;
    }

    //
    // Check the moniker pointer.
    //

    if ( IsBadWritePtr( pMoniker, sizeof(IMoniker) ) )
    {
        LOG((MSP_ERROR, "CWaveMSP::TerminalHasWaveID - "
            "bad moniker pointer - exit FALSE"));

        return FALSE;
    }

    //
    // Get a property bag from the moniker.
    //

    IPropertyBag * pBag;

    HRESULT hr = pMoniker->BindToStorage(0,
                                         0,
                                         IID_IPropertyBag,
                                         (void **) &pBag);
    
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CWaveMSP::TerminalHasWaveID - "
            "can't get property bag - exit FALSE"));

        return FALSE;
    }

    //
    // Get the ID from the property bag.
    //

    WCHAR * pwszWaveID;

    if ( fCapture )
    {
        pwszWaveID = L"WaveInId";
    }
    else
    {
        pwszWaveID = L"WaveOutId";
    }

    VARIANT var;
    var.vt = VT_I4;
    hr = pBag->Read(pwszWaveID, &var, 0);

    pBag->Release();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CWaveMSP::TerminalHasWaveID - "
            "can't read wave ID - exit FALSE"));

        return FALSE;
    }

    if ( var.lVal == (long) dwWaveID )
    {
        LOG((MSP_TRACE, "CWaveMSP::TerminalHasWaveID - "
            "matched wave ID (%d) - exit TRUE", var.lVal));

        return TRUE;
    }
    else
    {
        LOG((MSP_TRACE, "CWaveMSP::TerminalHasWaveID - "
            "didn't match wave ID (%d) - exit FALSE", var.lVal));

        return FALSE;
    }
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Public method for creating and saving a reference to the DShow filter
// mapper object on an intelligent connect. Called by the stream/call when an
// intelligent connection is attempted. Does nothing if the cache has already
// been created.
//

HRESULT CWaveMSP::CreateFilterMapper(void)
{
    LOG((MSP_TRACE, "CWaveMSP::CreateFilterMapper - enter"));

    if ( m_pFilterMapper != NULL )
    {
        LOG((MSP_TRACE, "CWaveMSP::CreateFilterMapper - "
            "mapper cache already created - doing nothing"));
    }
    else
    {
        //
        // Create an extra filter mapper to keep the filter mapper cache around,
        // and create the cache up front, This speeds up DShow's performance
        // when we do intelligent connects.
        //

        HRESULT hr;

        hr = CoCreateInstance(CLSID_FilterMapper,
                              NULL, 
                              CLSCTX_INPROC_SERVER,
                              IID_IFilterMapper,
                              (void**) & m_pFilterMapper
                              );

        if ( FAILED(hr) )
        {
            LOG((MSP_WARN, "CWaveMSP::CreateFilterMapper - "
                "failed to create filter mapper - 0x%08x - continuing", hr));

            m_pFilterMapper = NULL; // just to be safe
        }

        //
        // No need to enumerate filters on the mapper cache, because this is
        // called at connection time anyway, so there is nothing to be gained
        // that way -- the intelligent connection will just do it.
        //
    }

    LOG((MSP_TRACE, "CWaveMSP::CreateFilterMapper - exit S_OK"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Returns full duplex support on this device
//

HRESULT CWaveMSP::IsFullDuplex( FULLDUPLEX_SUPPORT * pSupport )
{
    LOG((MSP_TRACE, "CWaveMSP::IsFullDuplex - enter"));

    if (IsBadWritePtr( pSupport, sizeof(FULLDUPLEX_SUPPORT) ))
    {
        LOG((MSP_TRACE, "CWaveMSP::IsFullDuplex - bad pointer"));

        return E_POINTER;
    }

    m_TerminalDataLock.Lock();

    *pSupport = m_fdSupport;
    
    m_TerminalDataLock.Unlock();
    
    LOG((MSP_TRACE, "CWaveMSP::IsFullDuplex - exit S_OK"));
    
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\wavecall.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    wavecall.cpp 

Abstract:

    This module contains implementation of CWaveMSPCall.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPCall::CWaveMSPCall() : CMSPCallMultiGraph()
{
    LOG((MSP_TRACE, "CWaveMSPCall::CWaveMSPCall entered."));

    m_fHavePerAddressWaveIDs = FALSE;
    m_dwPerAddressWaveInID   = 0xfeedface;
    m_dwPerAddressWaveOutID  = 0xfeedface;
    
    LOG((MSP_TRACE, "CWaveMSPCall::CWaveMSPCall exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPCall::~CWaveMSPCall()
{
    LOG((MSP_TRACE, "CWaveMSPCall::~CWaveMSPCall entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::~CWaveMSPCall exited."));
}

ULONG CWaveMSPCall::MSPCallAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CWaveMSPCall::MSPCallRelease(void)
{
    return MSPReleaseHelper(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

HRESULT CWaveMSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
{
    // No need to acquire locks on this call because it is called only
    // once when the object is created. No other calls can be made on
    // this object at this point.

    LOG((MSP_TRACE, "CWaveMSPCall::Init - enter"));
    
    //
    // First do the base class method. We are adding to the functionality,
    // not replacing it.
    //

    HRESULT hr;

    hr = CMSPCallMultiGraph::Init(pMSPAddress,
                                  htCall,
                                  dwReserved,
                                  dwMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "base class method failed: %x", hr));

        return hr;
    }

    //
    // Our calls always come with two streams. Create them now. Use the base class
    // methods, as our overriden methods (exposed to the user) purposely fail in order
    // to keep the user from creating or removing streams themselves.
    // These methods return a pointer to the ITStream. They get saved in our list of
    // ITStreams, and we also save them here as CWaveMSPStream pointers.
    //

    ITStream * pStream;

    //
    // Create the capture stream.
    //

    hr = InternalCreateStream (dwMediaType,
                               TD_CAPTURE,
                               &pStream);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't create capture stream: %x", hr));

        return hr;
    }

    m_pCaptureStream = dynamic_cast<CWaveMSPStream *> (pStream);

    if ( m_pCaptureStream == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't dynamic_cast capture stream - exit E_FAIL"));

        return E_FAIL;
    }

    pStream->Release();
 
    //
    // Create the render stream.
    //

    hr = InternalCreateStream (dwMediaType,
                               TD_RENDER,
                               &pStream);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't create capture stream: %x", hr));

        return hr;
    }

    m_pRenderStream = dynamic_cast<CWaveMSPStream *> (pStream);

    if ( m_pRenderStream == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't dynamic_cast render stream - exit E_FAIL"));

        return E_FAIL;
    }

    pStream->Release();

    LOG((MSP_TRACE, "CWaveMSPCall::Init - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Public method called by the address to tell us the per-address wave IDs. We
// hold on to them until we know whether we have per-call waveids, and if we
// don't, then we set them on the streams.
//
//

HRESULT CWaveMSPCall::SetWaveIDs(
    IN      DWORD               dwWaveInID,
    IN      DWORD               dwWaveOutID
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::SetWaveIDs - enter"));

    m_fHavePerAddressWaveIDs = TRUE;
    m_dwPerAddressWaveInID   = dwWaveInID;
    m_dwPerAddressWaveOutID  = dwWaveOutID;

    LOG((MSP_TRACE, "CWaveMSPCall::SetWaveIDs - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// We override this to make sure the number of
// streams we have is constant.
//

STDMETHODIMP CWaveMSPCall::CreateStream (
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStream entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStream - "
        "we have a fixed set of streams - exit TAPI_E_MAXSTREAMS"));

    return TAPI_E_MAXSTREAMS;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// We override this to make sure the number of
// streams we have is constant.
//

STDMETHODIMP CWaveMSPCall::RemoveStream (
    IN      ITStream *          pStream
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::RemoveStream entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::RemoveStream - "
        "we have a fixed set of streams - exit TAPI_E_NOTSUPPORTED"));

    return TAPI_E_NOTSUPPORTED;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// This is our override to create the right kind of stream on stream creation.
// The base class checks the arguments for us.
//

HRESULT CWaveMSPCall::CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        )
{
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStreamObject - enter"));

    HRESULT hr;
    CMSPComObject<CWaveMSPStream> * pStream;
 
    hr = CMSPComObject<CWaveMSPStream>::CreateInstance( &pStream );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't create stream object - 0x%08x", hr));

        return hr;
    }

    hr = pStream->_InternalQueryInterface( IID_ITStream,
                                           (void **) ppStream );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't get ITStream interface - 0x%08x", hr));

        delete pStream;
        return hr;
    }

    hr = pStream->Init( (MSP_HANDLE) m_pMSPAddress,
                       this,
                       pGraph,
                       dwMediaType,
                       Direction);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't Init stream object - 0x%08x", hr));

        (*ppStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPCall::CreateStreamObject - exit S_OK"));
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// First DWORD =  Command                Second DWORD  Third DWORD
// -------------  -------                ------------  -----------
// 0              Set wave IDs           WaveIn ID     WaveOut ID
// 1              Start streaming        <ignored>     <ignored>
// 2              Stop streaming         <ignored>     <ignored>
// 3 <per-address, not per-call>
// 4 <per-address, not per-call>
// 5              Suspend streaming      <ignored>     <ignored>
// 6              Resume streaming       <ignored>     <ignored>
// 7              Wave IDs unavailable   <ignored>     <ignored>
//
// The method returns S_OK even if an individual stream failed to
// start, stop, or initialize. This is because TAPI 3.0 doesn't need to
// know about streaming failures in this code path. Instead, we
// generate events to note failures (in the stream code).
//

HRESULT CWaveMSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::ReceiveTSPCallData - enter"));

    //
    // Check that the buffer is as big as advertised.
    //

    if ( IsBadWritePtr(pBuffer, sizeof(BYTE) * dwSize) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "bad buffer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Check if we have a command DWORD.
    //

    if ( dwSize < sizeof(DWORD) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "need a DWORD for command - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // We are going to access the streams lists -- grab the lock
    //

    CLock lock(m_lock);

    _ASSERTE( m_Streams.GetSize() == 2 );

    int i;
    HRESULT hr;

    //
    // Based on the command, take action:
    //

    switch ( ((DWORD *) pBuffer) [0] )
    {
        //
        // Notes on waveid messages:
        //
        //    * The capture stream is the one with a capture terminal, and thus we
        //      need to give it the wave out id, and we need to give the render
        //      terminal the wave in ID.
        //    * We do not return errors or fire events on failure. If something
        //      fails, then the waveid will not be set for that stream, and
        //      a failure event will be fired when streaming begins.
        //

    case 0: // set per-call wave IDs (overrides per-address waveids)
        {
            if ( dwSize < 3 * sizeof(DWORD) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "need 3 DWORDs for SetWaveID command - "
                    "exit E_INVALIDARG"));

                return E_INVALIDARG;
            }

            LOG((MSP_INFO, "CWaveMSPCall::ReceiveTSPCallData - "
                "setting WaveInID=%d, WaveOutID=%d",
                ((DWORD *) pBuffer) [1],
                ((DWORD *) pBuffer) [2]));

            // waveout
            hr = m_pCaptureStream->SetWaveID( ((DWORD *) pBuffer) [2] );

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "capture stream SetWaveID (per-call) failed 0x%08x - "
                    "continuing", hr));
            }

            // wavein
            hr = m_pRenderStream ->SetWaveID( ((DWORD *) pBuffer) [1] );

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "render stream SetWaveID (per-call) failed 0x%08x - "
                    "continuing", hr));
            }

        }
        break;


    case 7: // no per-call wave IDs (use per-address waveids if available)
        {
            if ( m_fHavePerAddressWaveIDs )
            {
                hr = m_pCaptureStream->SetWaveID( m_dwPerAddressWaveOutID );

                if ( FAILED(hr) )
                {
                    LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                        "capture stream SetWaveID (cached per-address id) "
                        "failed 0x%08x - continuing", hr));
                }

                hr = m_pRenderStream ->SetWaveID( m_dwPerAddressWaveInID );

                if ( FAILED(hr) )
                {
                    LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                        "render stream SetWaveID (cached per-address id) "
                        "failed 0x%08x - continuing", hr));
                }
            }
            else
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "no per-address and no per-call wave ids - continuing"));
            }
        }
        break;


    //
    // Notes on streaming state control messages:
    //
    // It is crucial that the order of invocations here be
    // kept the same for each message that is dispatched to streams;
    // otherwise you may get a different stream resuming than had
    // originally started in the case where only one stream can
    // run at a time (half-duplex hardware). Also, the exact order
    // (capture first, render second) is important as well! We get
    // better error reporting -- synchronous instead of asynchronous
    // -- for half-duplex line devices this way.
    //

    case 1: // start streaming
        {
            hr = m_pCaptureStream ->StartStream(); // waveout
            hr = m_pRenderStream  ->StartStream(); // wavein
        }
        break;

    case 2: // stop streaming
        {
            hr = m_pCaptureStream ->StopStream(); // waveout
            hr = m_pRenderStream  ->StopStream(); // wavein
        }
        break;

    case 5: // suspend streaming
        {
            hr = m_pCaptureStream ->SuspendStream(); // waveout
            hr = m_pRenderStream  ->SuspendStream(); // wavein
        }
        break;

    case 6: // resume streaming
        {
            hr = m_pCaptureStream ->ResumeStream(); // waveout
            hr = m_pRenderStream  ->ResumeStream(); // wavein
        }
        break;

    default:
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "invalid command - exit E_INVALIDARG"));

        return E_INVALIDARG;

    }

    LOG((MSP_TRACE, "CWaveMSPCall::ReceiveTSPCallData - exit S_OK"));
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\wavecall.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    wavecall.h

Abstract:

    Declaration of the CWaveMSPCall

Author:
    
    Zoltan Szilagyi September 7th, 1998

--*/

#ifndef __WAVECALL_H_
#define __WAVECALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CWaveMSPCall
/////////////////////////////////////////////////////////////////////////////

class CWaveMSPCall : public CMSPCallMultiGraph, public CMSPObjectSafetyImpl
{
public:
// DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSPCall)
     COM_INTERFACE_ENTRY( IObjectSafety )
     COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

public:
    CWaveMSPCall();
    virtual ~CWaveMSPCall();
    virtual ULONG MSPCallAddRef(void);
    virtual ULONG MSPCallRelease(void);

    virtual HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    virtual HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    //
    // We override these to make sure the number of
    // streams we have is constant.
    //

    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

    //
    // Public method called by the address to tell us the
    // per-address wave IDs. We hold on to them until
    // we know whether we have per-call waveids, and if we
    // don't, then we set them on the streams.
    //

    virtual HRESULT SetWaveIDs(
        IN      DWORD               dwWaveInID,
        IN      DWORD               dwWaveOutID
        );

    //
    // Public method for creating the filter mapper cache up front.
    // Called by the stream when an intelligent connection is
    // attempted. Simply forwarded to the call's owning address object.
    //

    virtual HRESULT CreateFilterMapper(void)
    {
        //
        // m_pMSPAddress is valid here, because it is released in
        // CMSPCallBase::FinalRelease, and FinalRelease cannot occur
        // until after all connection attempts are complete.
        //

        return ((CWaveMSP *) m_pMSPAddress)->CreateFilterMapper();
    }

protected:
    // 
    // Protected data members.
    //

    CWaveMSPStream * m_pRenderStream;
    CWaveMSPStream * m_pCaptureStream;

    BOOL  m_fHavePerAddressWaveIDs;
    DWORD m_dwPerAddressWaveInID;
    DWORD m_dwPerAddressWaveOutID;
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\wavemsp.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

// wavemsp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for wavemsp.idl by adding the following 
//		files to the Outputs.
//			wavemsp_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f wavemspps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wavemsp_i.c"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#ifdef DEBUG_HEAPS
#include <crtdbg.h>
#endif // DEBUG_HEAPS

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_WaveMSP, CWaveMSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
		return FALSE;
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
	{

#ifdef DEBUG_HEAPS
	    // ZoltanS: turn on leak detection on process exit
	    _CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF );

	    // ZoltanS: force a memory leak
	    char * leak = new char [ 1977 ];
    	sprintf(leak, "wavemsp.dll NORMAL leak");
    	leak = NULL;
#endif // DEBUG_HEAPS

        _Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

        // Register for trace output.
        MSPLOGREGISTER(_T("wavemsp"));
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        // Deregister for trace output.
        MSPLOGDEREGISTER();

        _Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\wavestrm.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    wavestrm.h

Abstract:

    Declaration of the CWaveMSPStream

Author:
    
    Zoltan Szilagyi September 7th, 1998

--*/

#ifndef __WAVESTRM_H_
#define __WAVESTRM_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CWaveMSPStream
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CWaveMSPStream : public CMSPStream, public CMSPObjectSafetyImpl

{
public:

// DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSPStream)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

    virtual ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return CMSPStream::AddRef();
    }

    virtual ULONG STDMETHODCALLTYPE Release(void)
    {
        return CMSPStream::Release();
    }

public:

    //
    // Construction and destruction.
    //

    CWaveMSPStream();
    virtual ~CWaveMSPStream();
    virtual void FinalRelease();

    //
    // Required base class overrides.
    // 

    STDMETHOD (get_Name) (
        OUT     BSTR *                  ppName
        );

    //
    // We override these methods to implement our terminal handling.
    // This consists of only allowing one terminal on the stream at a time
    // and adding our filters and the terminal to the graph at the right
    // times.
    //

    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (StartStream) ();

    STDMETHOD (PauseStream) ();

    STDMETHOD (StopStream) ();

    //
    // Overrides for event handling.
    //

    virtual HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    //
    // Public methods specific to our implementation.
    //

    virtual      HRESULT SuspendStream(void);
    virtual      HRESULT ResumeStream (void);
    static  DWORD WINAPI ResumeStreamWI(VOID * pContext);
    virtual      HRESULT ResumeStreamAsync(void);

    
    virtual HRESULT SetWaveID(DWORD dwWaveID);
    virtual HRESULT FireEvent(IN MSP_CALL_EVENT        type,
                              IN HRESULT               hrError,
                              IN MSP_CALL_EVENT_CAUSE  cause);

protected:
    //
    // Protected data members.
    //

    BOOL          m_fHaveWaveID;
    BOOL          m_fTerminalConnected;
    DWORD         m_dwSuspendCount;
    IBaseFilter * m_pFilter;
    IBaseFilter * m_pG711Filter;
    FILTER_STATE  m_DesiredGraphState;
    FILTER_STATE  m_ActualGraphState;

private:
    //
    // Private helper methods.
    //

    HRESULT ConnectTerminal(
        IN   ITTerminal * pTerminal
        );

    HRESULT ConnectToTerminalPin(
        IN   IPin * pTerminalPin
        );
    
    HRESULT TryToConnect(
        IN   IPin * pOutputPin,
        IN   IPin * pInputPin,
        OUT  BOOL * pfIntelligent
        );

    
    //
    // remove all filters from the filter graph
    //

    HRESULT RemoveAllFilters();


    //
    // helper function that removes all the filters and then adds the wave filter
    //

    HRESULT CleanFilterGraph();


    //
    // a helper function that disconnects terminal and removes its filters from 
    // the filter graph
    //

    HRESULT RemoveTerminal();


    //
    // a helper function that adds the terminal to the filter graph
    //
    
    HRESULT ReAddTerminal();

    
    //
    // this function will attempt to create g711 if needed and add it to the graph.
    //

    HRESULT AddG711();

    HRESULT RemoveAndReAddFilter(
        IN IBaseFilter * pFilter
        );

    void    RemoveAndReAddG711(
        void
        );
    
    void    DisconnectAllFilters(
        void
        );

    void    RemoveAndReAddTerminal(
        void
        );

    HRESULT ConnectUsingG711(
        IN   IPin * pOutputPin,
        IN   IPin * pInputPin
        );

    HRESULT FindPinInFilter(
        IN   BOOL           bWantOutputPin, // if false, we want the input pin
        IN   IBaseFilter *  pFilter,        // the filter to examine
        OUT  IPin        ** ppPin           // the pin we found
        );
    
    HRESULT FindPin(
        OUT  IPin ** ppPin
        );
    
    HRESULT DecideDesiredCaptureBufferSize(
        IN   IPin * pPin,
        OUT  long * plDesiredSize
        );
    
    HRESULT ExamineCaptureProperties(
        IN   IPin *pPin
        );
    
    HRESULT ConfigureCapture(
        IN   IPin * pOutputPin,
        IN   IPin * pInputPin,
        IN   long   lDefaultBufferSize
        );
    
    HRESULT SetLiveMode(
        IN   BOOL          fEnable,
        IN   IBaseFilter * pFilter
        );

    HRESULT ProcessSoundDeviceEvent(
        IN   long lEventCode,
        IN   LONG_PTR lParam1,
        IN   LONG_PTR lParam2
        );
};

#endif //__WAVESTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\wavemsp\wavestrm.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    wavestrm.cpp 

Abstract:

    This module contains implementation of CWaveMSPStream.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

#include <audevcod.h> // audio device error codes
#include <initguid.h>
#include <g711uids.h>

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Custom logging helper macro, usable only within this class.
//

#ifdef MSPLOG

#define STREAM_PREFIX(x)  m_Direction == TD_RENDER ? \
                          "CWaveMSPStream(RENDER)::" x : \
                          "CWaveMSPStream(CAPTURE)::" x

#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPStream::CWaveMSPStream() : CMSPStream()
{
    LOG((MSP_TRACE, STREAM_PREFIX("CWaveMSPStream entered.")));

    m_fTerminalConnected = FALSE;
    m_fHaveWaveID        = FALSE;
    m_dwSuspendCount     = 0;
    m_DesiredGraphState  = State_Stopped;
    m_ActualGraphState   = State_Stopped;
    m_pFilter            = NULL;
    m_pG711Filter        = NULL;

    LOG((MSP_TRACE, STREAM_PREFIX("CWaveMSPStream exited.")));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPStream::~CWaveMSPStream()
{
    LOG((MSP_TRACE, STREAM_PREFIX("~CWaveMSPStream entered.")));
    LOG((MSP_TRACE, STREAM_PREFIX("~CWaveMSPStream exited.")));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// FinalRelease
//
// Called on destruction of the stream object, before the destructor. Releases
// all of the stream's references to filters.
//
// Arguments: none
//
// Returns:   nothing
//

void CWaveMSPStream::FinalRelease()
{
    LOG((MSP_TRACE, STREAM_PREFIX("FinalRelease entered.")));

    //
    // At this point we should have no terminals selected, since
    // Shutdown is supposed to be called before we are destructed.
    //

    _ASSERTE( 0 == m_Terminals.GetSize() );

    //
    // Remove our filter from the graph and release it.
    //

    if ( m_fHaveWaveID )
    {
        _ASSERTE( m_pFilter );

    	m_pIGraphBuilder->RemoveFilter( m_pFilter );
        m_pFilter->Release();
    }

	if ( m_pG711Filter )
    {
    	m_pIGraphBuilder->RemoveFilter( m_pG711Filter );
        m_pG711Filter->Release();
    }

    //
    // Call the base class method to clean up everything else.
    //

    CMSPStream::FinalRelease();

    LOG((MSP_TRACE, STREAM_PREFIX("FinalRelease exited.")));
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// ITStream::get_Name
//
// This method returns the name of the stream. The stream name is a friendly
// name which the app can use for UI. The name is determined by the direction
// of the stream and is retrieved from the string table.
//
// Arguments:
//     OUT  ppName - Returns a BSTR containing the name. The caller is
//                   responsible for calling SysFreeString when it is done
//                   with this string.
//
// Returns HRESULT:
//     S_OK          - success
//     E_POINTER     - ppName argument is invalid
//     E_UNEXPECTED  - string cannot be loaded from string table
//     E_OUTOFMEMORY - not enough memory to allocate return string
//

STDMETHODIMP CWaveMSPStream::get_Name (
    OUT     BSTR *                  ppName
    )
{
    LOG((MSP_TRACE, STREAM_PREFIX("get_Name - enter")));

    //
    // Check argument.
    //

    if ( IsBadWritePtr(ppName, sizeof(BSTR) ) )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("get_Name - "
            "bad return pointer - returning E_POINTER")));

        return E_POINTER;
    }

    //
    // Decide what string to return based on which stream this is.
    //

    ULONG ulID;
    
    if ( m_Direction == TD_CAPTURE )
    {
        ulID = IDS_CAPTURE_STREAM;
    }
    else
    {
        ulID = IDS_RENDER_STREAM;
    }

    //
    // Get the string from the string table.
    //

    const int   ciAllocSize = 2048;
    WCHAR       wszName[ciAllocSize];

    int iReturn = LoadStringW( _Module.GetModuleInstance(),
                               ulID,
                               wszName,
                               ciAllocSize - 1 );

    if ( iReturn == 0 )
    {
        _ASSERTE( FALSE );
        
        *ppName = NULL;

        LOG((MSP_ERROR, STREAM_PREFIX("get_Name - "
            "LoadString failed - returning E_UNEXPECTED")));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    *ppName = SysAllocString(wszName);

    if ( *ppName == NULL )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("get_Name - "
            "SysAllocString failed - returning E_OUTOFMEMORY")));

        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("get_Name - exit S_OK")));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// ITStream::SelectTerminal
//
// The app calls this method to indicate that the given terminal should be used
// on this stream. Only one terminal per stream is supported at this time.
// If the stream's desired graph state is not stopped, then a successful
// terminal selection causes the stream to attempt to regain the desired graph
// state. (The desired graph state is manipulated using ITStream::StartStream,
// etc.) If such a state change is unsuccessful, an event is fired but the
// SelectTerminal call still returns S_OK. This is to maintain consistency
// between synchronous and asynchronous streaming failures.
//
// Arguments:
//     IN   pTerminal - Pointer to the terminal to select.
//
// Returns HRESULT:
//     S_OK                - success
//     TAPI_E_MAXTERMINALS - a terminal is already selected
//     other               - from CMSPStream::SelectTerminal
//

STDMETHODIMP CWaveMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
{
    LOG((MSP_TRACE, STREAM_PREFIX("SelectTerminal - enter")));

    //
    // We are going to access the terminal list -- grab the lock
    //

    CLock lock(m_lock);

    //
    // Reject if we already have a terminal selected.
    //

    if ( 0 != m_Terminals.GetSize() )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SelectTerminal - "
            "exit TAPI_E_MAXTERMINALS")));

        return TAPI_E_MAXTERMINALS;
    }

    //
    // Use base class method to add it to our list of terminals.
    //

    HRESULT hr = CMSPStream::SelectTerminal(pTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SelectTerminal - "
            "base class method failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // Re-pause or re-start the stream if needed.
    //
    // Note that our behavior does not depend on whether TAPI
    // has suspended the stream. If TAPI has suspended the stream,
    // that's handled with these methods.
    //
    // Also note that if an error occurs on trying to regain the
    // desired graph state, we leave the terminal selected and
    // do not return an error code. This is as it should be, for
    // consistency with asynchronous failure cases.
    //

    if ( m_DesiredGraphState == State_Paused )
    {
        PauseStream();
    }
    else if ( m_DesiredGraphState == State_Running )
    {
        StartStream();
    }
    else
    {
        _ASSERTE( m_DesiredGraphState == State_Stopped );

        hr = S_OK;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_WARN, STREAM_PREFIX("SelectTerminal - "
            "can't regain old graph state "
            "0x%08x - continuing anyway"), hr));
    }

    LOG((MSP_TRACE, STREAM_PREFIX("SelectTerminal - exit S_OK")));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// ITStream::UnselectTerminal
//
// The app calls this method to indicate that the given terminal should no
// longer be used on this stream. This is relatively easy to do if the
// terminal is not connected to the stream, as is the case for a stream whose
// desired graph state has never deviated from State_Stopped since the terminal
// was selected, or for a stream where connection with the terminal was
// attempted but the connection failed. In these cases the terminal is simply
// removed from the stream's list.
//
// However, if the terminal was successfully connected to the stream earlier
// ( m_fTerminalConnected == TRUE ) then the terminal must also be
// disconnected from the stream. This also requires that the stream's graph
// be stopped. Stopping the graph to disconnect the terminal does not affect
// the desired graph state, so that reselecting a terminal without any changes
// to the desired graph state will result in an attempt to regain the same
// desired graph state that was present before the terminal was unselected.
// (The desired graph state is manipulated using ITStream::StartStream,
// etc.)
//
// Another complication arises from the fact that the G711 codec filter may
// be present in the graph and conected. In order to assure that future
// connections can succeed, this method disconnects and removes the G711
// codec filter from the graph.
//
// Arguments:
//     IN   pTerminal - Pointer to the terminal to unselect.
//
// Returns HRESULT:
//     S_OK                - success
//     other               - from CMSPStream::UnselectTerminal
//                            or  QI for ITTerminalControl
//                            or  ITTerminalControl::DisconnectTerminal
//

STDMETHODIMP CWaveMSPStream::UnselectTerminal (
        IN     ITTerminal *             pTerminal
        )
{
    LOG((MSP_TRACE, STREAM_PREFIX("UnselectTerminal - enter")));

    //
    // check the argument -- it has to be a reasonably good pointer
    //

    if (IsBadReadPtr(pTerminal, sizeof(ITTerminal)))
    {
        LOG((MSP_ERROR, STREAM_PREFIX("UnselectTerminal - "
            "bad terminal pointer passed in. returning E_POINTER")));

        return E_POINTER;
    }

    CLock lock(m_lock);

    //
    // check the argument -- it has to be in the array of terminals
    //

    if (m_Terminals.Find(pTerminal) < 0)
    {
        LOG((MSP_ERROR, STREAM_PREFIX("UnselectTerminal - "
            "terminal [%p] is not selected on this stream. "
            "returning TAPI_E_INVALIDTERMINAL"), pTerminal));

        return TAPI_E_INVALIDTERMINAL;
    }

    //
    // Add an extra reference to the terminal so it doesn't go away
    // after we call CMSPStream::UnselectTerminal. We need it later
    // in the function.
    //
    pTerminal->AddRef();

    //
    // Use base class method to remove terminal from our list of terminals.
    //
    // Note that if the graph won't stop or the terminal won't disconnect,
    // then we will never be able to try again, as the terminal will be gone
    // from our list. That's bad. If we just check here if we have the
    // terminal selected and then do the base class unselection at the end,
    // then we have a different problem -- we can potentially never release a
    // terminal from our list that for some reason won't stop/disconnect.
    // Therefore we should probably unselect it from our list even if stop/
    // disconnect fails. But then we have the same problem we started with.
    // Need to think more about how to solve this.
    //

    HRESULT hr = CMSPStream::UnselectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, STREAM_PREFIX("UnselectTerminal - "
            "base class method failed - exit 0x%08x"), hr));

        pTerminal->Release();
        return hr;
    }

    //
    // Stop the graph and disconnect the terminal if this call had it
    // connected. (We need a stopped graph to disconnect properly, and
    // couldn't have started the graph if the terminal isn't connected.)
    //

    if ( m_fTerminalConnected )
    {
        //
        // At this point we need to make sure the stream is stopped.
        // We can't use our own StopStream method because it
        // (1) changes the desired graph state to Stopped and 
        // (2) does nothing if no terminal has been selected (which it now
        //     thinks is the case)
        //
        // Note also that our behavior does not depend on whether TAPI
        // has suspended the stream. If TAPI has suspended the stream,
        // it just means we're already stopped.
        //

        _ASSERTE( m_fHaveWaveID );

        //
        // Stop the stream via the base class method.
        //

        hr = CMSPStream::StopStream();

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, STREAM_PREFIX("UnselectTerminal - "
                "Stop failed - 0x%08x"), hr));

            // don't return hr -- we really want to continue and
            // disconnect if we can!
        }
        
        if ( m_ActualGraphState == State_Running )
        {
            FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);
        }

        m_ActualGraphState = State_Stopped;

        //
        // Get the ITTerminalControl interface.
        //

        ITTerminalControl * pTerminalControl;

        hr = pTerminal->QueryInterface(IID_ITTerminalControl,
                                       (void **) &pTerminalControl);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, STREAM_PREFIX("UnselectTerminal - "
                "QI for ITTerminalControl failed - exit 0x%08x"), hr));

            pTerminal->Release();
            return hr;
        }

        //
        // Disconnect the terminal.
        //

        hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        pTerminalControl->Release();

        m_fTerminalConnected = FALSE;

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, STREAM_PREFIX("UnselectTerminal - "
                "DisconnectTerminal failed - exit 0x%08x"), hr));

            pTerminal->Release();
            return hr;
        }

        //
        // Our graph now contains our wave filter and possibly the G711
        // codec. The G711 codec may or may not be connected to the wave
        // filter. Alternatively, various other filters, pulled in as a
        // side-effect of an earlier intelligent connection, may be connected
        // to the wave filter. Clean this up.
        //

        hr = CleanFilterGraph();

        if (FAILED(hr))
        {
            
            //
            // the graph is in a bad state and can no longer be used.
            // this is not very good, but we cannot rollback to the original 
            // state at this point, so we will have to live with this
            //

            LOG((MSP_ERROR, 
                STREAM_PREFIX("UnselectTerminal - CleanFilterGraph failed. hr = %lx"),
                hr));
        
            pTerminal->Release();

            return hr;
        }
    }

    
    pTerminal->Release();
    pTerminal = NULL;

    LOG((MSP_TRACE, STREAM_PREFIX("UnselectTerminal - exit")));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// ITStream::StartStream
//
// The app calls this method to indicate that the stream should start playing.
// Tapi3.dll also calls this method when the call is connected (so that 
// streaming starts by default on a newly connected call).
//
// First, a new desired graph state is set on the stream. If there is no
// terminal selected, then this is all that happens, and the stream will start
// the next time a terminal is selected.
//
// If a terminal has been selected, then this method checks if the wave ID
// has been set. If the wave ID has not been set, this indicates a problem
// with the TSP or the transport filter. An event is fired and an error code
// is returned. If the wave ID has been set, then the terminal is connected
// (if this has not already occured) and, unless TAPI3.DLL has suspended the
// stream due to an outstanding TSPI call, the stream is started and an event
// is fired. (But the event is only fired if this is an actual Active/Inactive
// transition.)
// 
// Arguments: none
//
// Returns HRESULT:
//     S_OK                - success
//     E_FAIL              - wave ID not set
//     other               - from ConnectTerminal
//                            or  FireEvent
//                            or  CMSPStream::StartStream
//

STDMETHODIMP CWaveMSPStream::StartStream (void)
{
    LOG((MSP_TRACE, STREAM_PREFIX("StartStream - enter")));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Running;

    //
    // Can't start the stream if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, STREAM_PREFIX("StartStream - "
            "no Terminal so nothing to do yet - exit S_OK")));

        return S_OK;
    }

    //
    // Can't start the stream if we don't know the waveid.
    // (We create our filters on discovery of the waveid.)
    // Here we fire a failure event, as this indicates an
    // improperly-installed TSP or a failure during filter
    // creation or setup, rendering this stream unusable.
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, STREAM_PREFIX("StartStream - "
            "no waveid - event + exit E_FAIL")));

        FireEvent(CALL_STREAM_FAIL, E_FAIL, CALL_CAUSE_UNKNOWN);

        return E_FAIL;
    }

    //
    // Connect the terminal. This does nothing if this call already
    // connected the terminal and fails if another call has the
    // terminal connected.
    //

    HRESULT hr;

    hr = ConnectTerminal(m_Terminals[0]);

    if ( FAILED(hr) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);

        LOG((MSP_ERROR, STREAM_PREFIX("StartStream - "
            "our ConnectTerminal failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // If the stream is suspended, we're done. Since we've set the
    // desired graph state to State_Running, the rest of this
    // process will complete when TAPI resumes the stream.
    //

    if ( 0 != m_dwSuspendCount )
    {
        //
        // By the way, this is quite normal as the suspend/resume happens
        // behind the scenes -- use MSP_TRACE rather than MSP_WARN
        //

        LOG((MSP_TRACE, STREAM_PREFIX("StartStream - "
            "stream is suspended so terminal is connected but we are not "
            "running the graph yet - exit S_OK")));

        return S_OK;
    }

    //
    // Run the stream via the base class method.
    //

    hr = CMSPStream::StartStream();

    if ( FAILED(hr) )
    {
        //
        // Failed to run -- tell the app.
        //

        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, STREAM_PREFIX("StartStream - "
            "Run failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // Fire event if this just made us active.
    //

    if ( m_ActualGraphState != State_Running )
    {
        m_ActualGraphState = State_Running;

        HRESULT hr2 = FireEvent(CALL_STREAM_ACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

        if ( FAILED(hr2) )
        {
            LOG((MSP_ERROR, STREAM_PREFIX("StartStream - "
                "FireEvent failed - exit 0x%08x"), hr2));

            return hr2;
        }
    }

    LOG((MSP_TRACE, STREAM_PREFIX("StartStream - exit S_OK")));

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// ITStream::PauseStream
//
// The app calls this method to indicate that the stream should transition to
// the paused state.
//
// First, a new desired graph state is set on the stream. If there is no
// terminal selected, then this is all that happens, and the stream will pause
// the next time a terminal is selected.
//
// If a terminal has been selected, then this method checks if the wave ID
// has been set. If the wave ID has not been set, this indicates a problem
// with the TSP or the transport filter. An event is fired and an error code
// is returned. If the wave ID has been set, then the terminal is connected
// (if this has not already occured) and, unless TAPI3.DLL has suspended the
// stream due to an outstanding TSPI call, the stream is paused and an event
// is fired. (But the event is only fired if this is an actual Active/Inactive
// transition.)
// 
// Arguments: none
//
// Returns HRESULT:
//     S_OK                - success
//     E_FAIL              - wave ID not set
//     other               - from ConnectTerminal
//                            or  FireEvent
//                            or  CMSPStream::StartStream
//

STDMETHODIMP CWaveMSPStream::PauseStream (void)
{
    LOG((MSP_TRACE, STREAM_PREFIX("PauseStream - enter")));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Paused;

    //
    // Can't pause the stream if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, STREAM_PREFIX("PauseStream - "
            "no Terminal so nothing to do yet - exit S_OK")));

        return S_OK;
    }

    //
    // Can't start the stream if we don't know the waveid.
    // (We create our filters on discovery of the waveid.)
    // Here we fire a failure event, as this indicates an
    // improperly-installed TSP or a failure during filter
    // creation or setup, rendering this stream unusable.
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, STREAM_PREFIX("PauseStream - "
            "no waveid - event + exit E_FAIL")));

        FireEvent(CALL_STREAM_FAIL, E_FAIL, CALL_CAUSE_UNKNOWN);

        return E_FAIL;
    }

    //
    // Connect the terminal. This does nothing if this call already
    // connected the terminal and fails if another call has the
    // terminal connected.
    //

    HRESULT hr;

    hr = ConnectTerminal(m_Terminals[0]);

    if ( FAILED(hr) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);

        LOG((MSP_ERROR, STREAM_PREFIX("StartStream - "
            "our ConnectTerminal failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // If the stream is suspended, we're done. Since we've set the
    // desired graph state to State_Paused, the rest of this
    // process will complete when TAPI resumes the stream.
    //

    if ( 0 != m_dwSuspendCount )
    {
        //
        // By the way, this is quite normal as the suspend/resume happens
        // behind the scenes -- use MSP_TRACE rather than MSP_WARN
        //

        LOG((MSP_TRACE, STREAM_PREFIX("PauseStream - "
            "stream is suspended so terminal is connected but we are not "
            "pausing the graph yet - exit S_OK")));

        return S_OK;
    }

    //
    // Pause the stream via the base class method.
    //

    hr = CMSPStream::PauseStream();

    if ( FAILED(hr) )
    {
        //
        // Failed to pause -- tell the app.
        //
        
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, STREAM_PREFIX("PauseStream - "
            "Pause failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // Fire event if this just made us inactive.
    //

    if ( m_ActualGraphState == State_Running )
    {
        HRESULT hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

        if ( FAILED(hr2) )
        {
            m_ActualGraphState = State_Paused;

            LOG((MSP_ERROR, STREAM_PREFIX("PauseStream - "
                "FireEvent failed - exit 0x%08x"), hr2));

            return hr2;
        }
    }

    m_ActualGraphState = State_Paused;

    LOG((MSP_TRACE, STREAM_PREFIX("PauseStream - exit S_OK")));

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// ITStream::StopStream
//
// The app calls this method to indicate that the stream should transition to
// the stopped state. Tapi3.dll also calls this method when the call is
// disconnected (so that streaming stops by default on a disconnected call).
//
// First, a new desired graph state is set on the stream. If there is no
// terminal selected, then this is all that happens, and the stream will start
// the next time a terminal is selected.
//
// If a terminal has been selected, then this method checks if the wave ID
// has been set. If the wave ID has not been set, then there is nothing to do.
// If the wave ID has been set, then the stream is stopped and an event
// is fired. (But the event is only fired if this is an actual Active/Inactive
// transition.)
// 
// Arguments: none
//
// Returns HRESULT:
//     S_OK                - success
//     E_FAIL              - wave ID not set
//     other               - from ConnectTerminal
//                            or  FireEvent
//                            or  CMSPStream::StartStream
//

STDMETHODIMP CWaveMSPStream::StopStream (void)
{
    LOG((MSP_TRACE, STREAM_PREFIX("StopStream - enter")));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Stopped;

    //
    // Nothing to do if we don't know our waveid.
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, STREAM_PREFIX("StopStream - "
            "no waveid - exit S_OK")));

        return S_OK;
    }

    //
    // Nothing to do if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, STREAM_PREFIX("StopStream - "
            "no Terminal - exit S_OK")));

        return S_OK;
    }

    //
    // Nothing special here if we are suspended. Stopping while suspended just
    // means that we are already stopped. The StopStream call will do nothing
    // and no event will be fired in this case.
    //

    //
    // Stop the stream via the base class method.
    //

    HRESULT hr;

    hr = CMSPStream::StopStream();

    if ( FAILED(hr) )
    {
        //
        // Failed to stop -- tell the app.
        //

        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);
        
        m_DesiredGraphState = m_ActualGraphState;

        LOG((MSP_ERROR, STREAM_PREFIX("StopStream - "
            "Stop failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // Fire event if this just made us inactive.
    //

    if ( m_ActualGraphState == State_Running )
    {
        HRESULT hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

        if ( FAILED(hr2) )
        {
            m_ActualGraphState = State_Stopped;

            LOG((MSP_ERROR, STREAM_PREFIX("StopStream - "
                "FireEvent failed - exit 0x%08x"), hr2));

            return hr2;
        }
    }

    m_ActualGraphState = State_Stopped;

    LOG((MSP_TRACE, STREAM_PREFIX("StopStream - exit S_OK")));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

HRESULT CWaveMSPStream::SetWaveID(DWORD dwWaveID)
{
    LOG((MSP_TRACE, STREAM_PREFIX("SetWaveID - enter")));

    CLock lock(m_lock);

    //
    // create the correct wave filter
    //

    HRESULT hr;

    hr = CoCreateInstance(
                          (m_Direction == TD_RENDER) ? CLSID_AudioRecord :
                                                       CLSID_AudioRender,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IBaseFilter,
                          (void **) &m_pFilter
                         );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "Filter creation failed - exit 0x%08x"), hr));
        
        return hr;
    }

    //
    // If this is a wavein filter, turn on sample dropping for
    // live graphs. Ignore failure here.
    //

    if ( m_Direction == TD_RENDER )
    {
        SetLiveMode( TRUE, m_pFilter );
    }

    CComObject< CMyPropertyBag >      * pMyBag;
    IPropertyBag *        pPropertyBag;
    VARIANT               var;

    //
    // create a propertybag
    //
    hr = CComObject< CMyPropertyBag >::CreateInstance( &pMyBag );
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "failed to create property bag - exit 0x%08x")));

        m_pFilter->Release();
        m_pFilter = NULL;

        return hr;
    }
    

    //
    // create the variant for the propertybag
    //
    VariantInit( &var );
    var.vt = VT_I4;
    var.lVal = dwWaveID;

    //
    // get the correct interface
    //
    hr = pMyBag->QueryInterface(
                                IID_IPropertyBag,
                                (void **) &pPropertyBag
                               );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "failed to get the proppag interface - exit 0x%08x")));

        delete pMyBag;

        m_pFilter->Release();
        m_pFilter = NULL;
        
        return hr;
    }
    //
    // save the variant in the property bag
    //
    hr = pPropertyBag->Write(
                             ( (m_Direction == TD_RENDER) ? (L"WaveInId") :
                                                            (L"WaveOutID")),
                             &var
                            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "failed to write to the proppag interface - exit 0x%08x")));

        pPropertyBag->Release();

        m_pFilter->Release();
        m_pFilter = NULL;
        
        return hr;
    }
    
    //
    // get the IPersistPropertyBag interface
    // and save the propertybag through it
    //
    
    IPersistPropertyBag * pPersistPropertyBag;

    hr = m_pFilter->QueryInterface(
                                   IID_IPersistPropertyBag,
                                   (void **) &pPersistPropertyBag
                                  );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "failed to get the IPersisPropertyBag interface - exit 0x%08x")));

        pPropertyBag->Release();
        
        m_pFilter->Release();
        m_pFilter = NULL;

        return hr;
    }

    //
    // Load() tells the filter object to read in the
    // properties it is interested in from the property bag
    //
    hr = pPersistPropertyBag->Load( pPropertyBag, NULL );

    pPropertyBag->Release();
    pPersistPropertyBag->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "failed to save device id - exit 0x%08x")));

        m_pFilter->Release();
        m_pFilter = NULL;

        return hr;
    }

    //
    // Before adding a RENDER filter to the graph (ie, the wave filter on
    // a CAPTURE stream), do SetDefaultSyncSource
    // to enable drop-sample code in DirectShow which will prevent
    // forever-increasing latency with mismatched wave clocks.
    //

    if ( m_Direction == TD_CAPTURE )
    {
        hr = m_pIGraphBuilder->SetDefaultSyncSource();

        if ( FAILED(hr) )
        {
            LOG((MSP_WARN, STREAM_PREFIX("SetWaveID - "
                "SetDefaultSyncSource failed 0x%08x - continuing anyway"), hr));
        }
    }
    
    //
    // Add the filter. Supply a name to make debugging easier.
    //

	WCHAR * pName = (m_Direction == TD_RENDER) ?
						(L"The Stream's WaveIn (on line device)") :
						(L"The Stream's WaveOut (on line device)");

    hr = m_pIGraphBuilder->AddFilter(m_pFilter, pName);
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SetWaveID - "
            "AddFilter failed - exit 0x%08x"), hr));
        
        m_pFilter->Release();
        m_pFilter = NULL;

        return hr;
    }

    //
    // We now have the wave ID.
    //

    m_fHaveWaveID = TRUE;

    LOG((MSP_TRACE, STREAM_PREFIX("SetWaveID - exit S_OK")));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Suspend the stream. Only TAPI itself can ask us to do this. Tapi asks us
// to do this when it's calling a tapi call control function, and the TSP
// requires that its wave devices be closed for the call control function to
// work.
//

HRESULT CWaveMSPStream::SuspendStream(void)
{
    LOG((MSP_TRACE, STREAM_PREFIX("SuspendStream - enter")));

    CLock lock(m_lock);

    m_dwSuspendCount++;

    if ( m_dwSuspendCount > 1 )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("SuspendStream - "
            "just bumping up suspend count - exit S_OK")));

        return S_OK;
    }

    //
    // We are now suspended. If we're actually not stopped (this
    // implies wave ids present, terminal selected, etc.) then
    // we need to close the wave device by stopping the stream
    // if it's not stopped, send an event to the
    // the app saying that the stream is inactive, and update
    // m_ActualGraphState so that resuming the stream will fire a
    // a stream active event. However we must not change our
    // m_DesiredGraphState, as doing so would prevent us from being
    // resumed to the correct state.
    //

    HRESULT hr = S_OK;

    if ( m_ActualGraphState != State_Stopped )
    {
        //
        // Stop the stream via the base class method.
        //

        hr = CMSPStream::StopStream();

        //
        // Send an event to the app.
        //

        HRESULT hr2;

        if ( SUCCEEDED(hr) )
        {
            hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);
        }
        else
        {
            hr2 = FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);
        }

        //
        // Update the the actual graph state; desired graph state remains the
        // same.
        //

        m_ActualGraphState = State_Stopped;

        //
        // Debug log only for failed FireEvent.
        // 
        
        if ( FAILED(hr2) )
        {
            LOG((MSP_ERROR, STREAM_PREFIX("SuspendStream - "
                "FireEvent failed - 0x%08x"), hr2));
        }
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("SuspendStream - "
            "Stop failed - 0x%08x"), hr));

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("SuspendStream - exit S_OK")));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Resume the stream after a SuspendStream. Only TAPI itself can ask us to do
// this. Tapi asks us to do this when it's finished calling a tapi call
// control function, and we can now start using our wave device again.
//
// Tapi does this on the (callback? / async events?) thread, so we post an
// async work item to our own thread to avoid blocking tapi's thread.
//

HRESULT CWaveMSPStream::ResumeStream (void)
{
    LOG((MSP_TRACE, STREAM_PREFIX("ResumeStream - enter")));

    HRESULT hr;

    this->AddRef();
    
    hr = g_Thread.QueueWorkItem(
                                ResumeStreamWI, // the callback
                                this,           // the context
                                FALSE           // FALSE -> asynchronous
                               );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ResumeStream - "
            "failed to queue work item - exit 0x%08x"), hr));
        
        this->Release();

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("ResumeStream - queued async work item - " \
        "exit S_OK")));

    return S_OK;
}

DWORD WINAPI CWaveMSPStream::ResumeStreamWI (VOID * pContext)
{
    CWaveMSPStream * pStream = (CWaveMSPStream *) pContext;

    pStream->ResumeStreamAsync();
    pStream->Release();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Resume the stream after a SuspendStream. Only TAPI itself can ask us to do
// this. Tapi asks us to do this when it's finished calling a tapi call
// control function, and we can now start using our wave device again.
//
// This is the actual routine, processed on our worker thread (see above).
//

HRESULT CWaveMSPStream::ResumeStreamAsync (void)
{
    LOG((MSP_TRACE, STREAM_PREFIX("ResumeStreamAsync - enter")));

    CLock lock(m_lock);

    if ( 0 == m_dwSuspendCount )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ResumeStreamAsync - "
            "resume count was already zero - exit E_UNEXPECTED")));

        return S_OK;
    }

    m_dwSuspendCount--;

    if ( 0 != m_dwSuspendCount )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("ResumeStreamAsync - "
            "just decrementing suspend count - exit S_OK")));

        return S_OK;
    }

    //
    // We are no longer suspended. Try to regain the desired graph state.
    // These methods fire all applicable events automatically.
    //

    HRESULT hr;

    if ( m_DesiredGraphState == State_Paused )
    {
        hr = PauseStream();
    }
    else if ( m_DesiredGraphState == State_Running )
    {
        hr = StartStream();
    }
    else
    {
        _ASSERTE( m_DesiredGraphState == State_Stopped );

        hr = S_OK;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("ResumeStreamAsync - "
            "can't regain old graph state - exit 0x%08x"), hr));

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("ResumeStreamAsync - exit S_OK")));

    return S_OK;
}





//////////////////////////////////////////////////////////////////////////////
//
// ProcessSoundDeviceEvent
//
// Called only from within ProcessGraphEvent. This function outputs some trace
// info indicating the details of the sound device event received, and fires
// appropriate events to the application.
//

HRESULT CWaveMSPStream::ProcessSoundDeviceEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_EVENT, STREAM_PREFIX("ProcessSoundDeviceEvent - enter")));

#ifdef MSPLOG

    //
    // Spew some debug output to indicate what this is.
    //

    char * pszType;

    switch ( lParam1 )
    {
    case SNDDEV_ERROR_Open:       
        pszType = "SNDDEV_ERROR_Open";
        break;

    case SNDDEV_ERROR_Close:
        pszType = "SNDDEV_ERROR_Close";
        break;

    case SNDDEV_ERROR_GetCaps:
        pszType = "SNDDEV_ERROR_GetCaps";
        break;
    
    case SNDDEV_ERROR_PrepareHeader:
        pszType = "SNDDEV_ERROR_PrepareHeader";
        break;
    
    case SNDDEV_ERROR_UnprepareHeader:
        pszType = "SNDDEV_ERROR_UnprepareHeader";
        break;
    
    case SNDDEV_ERROR_Reset:
        pszType = "SNDDEV_ERROR_Reset";
        break;
    
    case SNDDEV_ERROR_Restart:
        pszType = "SNDDEV_ERROR_Restart";
        break;
    
    case SNDDEV_ERROR_GetPosition:
        pszType = "SNDDEV_ERROR_GetPosition";
        break;
    
    case SNDDEV_ERROR_Write:
        pszType = "SNDDEV_ERROR_Write";
        break;
    
    case SNDDEV_ERROR_Pause:
        pszType = "SNDDEV_ERROR_Pause";
        break;
    
    case SNDDEV_ERROR_Stop:
        pszType = "USNDDEV_ERROR_Stop";
        break;
    
    case SNDDEV_ERROR_Start:
        pszType = "SNDDEV_ERROR_Start";
        break;
    
    case SNDDEV_ERROR_AddBuffer:
        pszType = "SNDDEV_ERROR_AddBuffer";
        break;

    case SNDDEV_ERROR_Query:
        pszType = "SNDDEV_ERROR_Query";
        break;

    default:
        pszType = "Unknown sound device call";
        break;
    }

    LOG((MSP_EVENT, STREAM_PREFIX("ProcessSoundDeviceEvent - "
                    "EVENT DUMP: type = %s; "), pszType));


    LOG((MSP_EVENT, STREAM_PREFIX("ProcessSoundDeviceEvent - "
                    "EVENT DUMP: this event is for a %s device"),
                    ( lEventCode == EC_SNDDEV_IN_ERROR ) ? "capture" :
                                                           "render"));

    //
    // The rest of the info is dumped in FireEvent if logging is enabled.
    //

#endif // ifdef MSPLOG

    //
    // Determine the error code to use when firing events.
    //

    HRESULT hr;

    switch ( lParam2 )
    {
    case MMSYSERR_NOERROR:      // no error
        hr = S_OK;
        break;

    case MMSYSERR_ERROR:        // unspecified error
    case MMSYSERR_BADDB:        // bad registry database
    case MMSYSERR_KEYNOTFOUND:  // registry key not found
    case MMSYSERR_READERROR:    // registry read error
    case MMSYSERR_WRITEERROR:   // registry write error
    case MMSYSERR_DELETEERROR:  // registry delete error
    case MMSYSERR_VALNOTFOUND:  // registry value not found
        hr = E_FAIL;
        break;

    case MMSYSERR_ALLOCATED:    // device already allocated
        hr = TAPI_E_ALLOCATED;
        break;

    case MMSYSERR_NOMEM:        // memory allocation error
        hr = E_OUTOFMEMORY;
        break;

    case MMSYSERR_BADDEVICEID:  // device ID out of range
    case MMSYSERR_NOTENABLED:   // driver failed enable
    case MMSYSERR_INVALHANDLE:  // device handle is invalid
    case MMSYSERR_NODRIVER:     // no device driver present
    case MMSYSERR_NOTSUPPORTED: // function isn't supported
    case MMSYSERR_BADERRNUM:    // error value out of range
    case MMSYSERR_INVALFLAG:    // invalid flag passed
    case MMSYSERR_INVALPARAM:   // invalid parameter passed
    case MMSYSERR_HANDLEBUSY:   // handle being used simultaneously on another
                                // thread (eg callback)
    case MMSYSERR_INVALIDALIAS: // specified alias not found
    case MMSYSERR_NODRIVERCB:   // driver does not call DriverCallback
    case MMSYSERR_MOREDATA:     // more data to be returned

    default:
        hr = E_UNEXPECTED; // these would appear to indicate a bug in the wave
                           // driver, Quartz, or Qcap)
        break;
    }

    //
    // If this event concerns our terminal, fire a terminal fail event to the
    // app.
    //

    if ( ( m_Direction == TD_CAPTURE ) ==
         ( lEventCode == EC_SNDDEV_IN_ERROR ) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_BAD_DEVICE);
    }

    //
    // Fire a stream failed event to the app. Even if the event concerned a
    // terminal and not the stream, since we currently have only one
    // terminal per stream, the failure of a terminal results in the failure
    // of a stream.
    //

    FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_BAD_DEVICE);

    LOG((MSP_EVENT, STREAM_PREFIX("ProcessSoundDeviceEvent - exit S_OK")));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ProcessGraphEvent
//
// Sends an event to the app when we get an event from the filter graph.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_EVENT, STREAM_PREFIX("ProcessGraphEvent - enter")));

    HRESULT        hr = S_OK;

    switch (lEventCode)
    {
    case EC_COMPLETE:
        
        hr = FireEvent(CALL_STREAM_INACTIVE,
                       (HRESULT) lParam1,
                       CALL_CAUSE_UNKNOWN);
        break;
    
    case EC_USERABORT:
        
        hr = FireEvent(CALL_STREAM_INACTIVE, S_OK, CALL_CAUSE_UNKNOWN);
        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        hr = FireEvent(CALL_STREAM_FAIL,
                       (HRESULT) lParam1,
                       CALL_CAUSE_UNKNOWN);
        break;

    case EC_SNDDEV_IN_ERROR:
    case EC_SNDDEV_OUT_ERROR:

        //
        // async error accessing an audio device
        //

        ProcessSoundDeviceEvent(lEventCode, lParam1, lParam2);
        break;

    default:
        
        LOG((MSP_EVENT, STREAM_PREFIX("ProcessGraphEvent - "
            "ignoring event code %d"), lEventCode));
        break;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ProcessGraphEvent - "
            "FireEvent failed - exit 0x%08x"), hr));

        return hr;
    }

    LOG((MSP_EVENT, STREAM_PREFIX("ProcessGraphEvent - exit S_OK")));

    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// FireEvent
//
// Fires an event to the application. Does its own locking.
//

HRESULT CWaveMSPStream::FireEvent(
    IN MSP_CALL_EVENT        type,
    IN HRESULT               hrError,
    IN MSP_CALL_EVENT_CAUSE  cause
    )                                          
{
    LOG((MSP_EVENT, STREAM_PREFIX("FireEvent - enter")));

    //
    // First, need to check if the call is shutting down. This is important
    // because UnselectTerminal can fire an event, and UnselectTerminal can
    // be called within ITStream::Shutdown. We can safely discard such
    // events because there is nothing the app can do with them anyway.
    //
    // Note on locking: It is convenient to check the m_pMSPCall here
    // and we don't use it until the end of the method, so we simply lock
    // during the entire method. This could be optimized at the expense of
    // some code complexity; note that we also need to lock while accessing
    // m_Terminals. 
    //

    CLock lock(m_lock);

    if ( m_pMSPCall == NULL )
    {
        LOG((MSP_EVENT, STREAM_PREFIX("FireEvent - "
            "call is shutting down; dropping event - exit S_OK")));
        
        return S_OK;
    }

    //
    // Create the event structure. Must use "new" as it will be
    // "delete"d later.
    //

    MSPEVENTITEM * pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, STREAM_PREFIX("FireEvent - "
            "can't create MSPEVENTITEM structure - exit E_OUTOFMEMORY")));

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the necessary fields for the event structure.
    //

    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;

    ITTerminal * pTerminal = NULL;

    if ( 0 != m_Terminals.GetSize() )
    {
        _ASSERTE( 1 == m_Terminals.GetSize() );
        pTerminal = m_Terminals[0];
        pTerminal->AddRef();
    }

    ITStream * pStream = (ITStream *) this;
    pStream->AddRef();

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type      = type;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause     = cause;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream   = pStream;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError   = hrError;


#ifdef MSPLOG
    //
    // Spew some debug output to indicate what this is.
    //

    char * pszType;
    DWORD dwLevel;

    switch (type)
    {
    case CALL_NEW_STREAM:
        pszType = "CALL_NEW_STREAM (unexpected)";
        dwLevel = MSP_ERROR;
        break;

    case CALL_STREAM_FAIL:
        pszType = "CALL_STREAM_FAIL";
        dwLevel = MSP_INFO;
        break;

    case CALL_TERMINAL_FAIL:
        pszType = "CALL_TERMINAL_FAIL";
        dwLevel = MSP_INFO;
        break;

    case CALL_STREAM_NOT_USED:
        pszType = "CALL_STREAM_NOT_USED (unexpected)";
        dwLevel = MSP_ERROR;
        break;

    case CALL_STREAM_ACTIVE:
        pszType = "CALL_STREAM_ACTIVE";
        dwLevel = MSP_INFO;
        break;

    case CALL_STREAM_INACTIVE:
        pszType = "CALL_STREAM_INACTIVE";
        dwLevel = MSP_INFO;
        break;

    default:
        pszType = "UNKNOWN EVENT TYPE";
        dwLevel = MSP_ERROR;
        break;
    }

    LOG((dwLevel, STREAM_PREFIX("FireEvent - "
                  "EVENT DUMP: type      = %s"), pszType));
    LOG((dwLevel, STREAM_PREFIX("FireEvent - "
                  "EVENT DUMP: pStream   = %p"), pStream));    
    LOG((dwLevel, STREAM_PREFIX("FireEvent - "
                  "EVENT DUMP: pTerminal = %p"), pTerminal));    
    LOG((dwLevel, STREAM_PREFIX("FireEvent - "
                  "EVENT DUMP: hrError   = %08x"), hrError));    

#endif // ifdef MSPLOG

    //
    // Send the event to the app.
    //

    HRESULT hr = m_pMSPCall->HandleStreamEvent(pEventItem);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, STREAM_PREFIX("FireEvent - "
            "HandleStreamEvent failed - returning 0x%08x"), hr));

		pStream->Release();
		pTerminal->Release();
        FreeEventItem(pEventItem);

        return hr;
    }

    LOG((MSP_EVENT, STREAM_PREFIX("FireEvent - exit S_OK")));

    return S_OK;
}




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// The rest of this file deals with the connection path.
// This could be pulled out into separate file in the future.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Create the G711 filter, which we will try to connect if direct
// connection fails.
//

HRESULT CWaveMSPStream::AddG711()
{
    LOG((MSP_TRACE, STREAM_PREFIX("AddG711 - enter")));

    //
    // if we don't yet have the G711 filter, create it
    //

    HRESULT hr = S_OK;

    if (NULL == m_pG711Filter)
    {

        hr = CoCreateInstance(
                              CLSID_G711Codec,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IBaseFilter,
                              (void **) &m_pG711Filter
                             );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, STREAM_PREFIX("AddG711 - Failed to create G711 codec: %lx"), hr));

            //
            // Method #2 for connection will not be available.
            //

            m_pG711Filter = NULL;

            return hr;
        }

        LOG((MSP_TRACE, STREAM_PREFIX("AddG711 - created filter [%p]"), m_pG711Filter));

    }



    //
    // add the G711 filter to the graph
    //

    hr = m_pIGraphBuilder->AddFilter(
                                    m_pG711Filter,
                                    NULL
                                   );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("AddG711 - Failed to add G711 filter: %lx"), hr));

        //
        // If we couldn't add it to the graph, then it's useless to us.
        // Method #2 for connection will not be available.
        //

        m_pG711Filter->Release();
        m_pG711Filter = NULL; 

        return hr;
    }


    LOG((MSP_TRACE, STREAM_PREFIX("AddG711 - finish")));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CWaveMSPStream::RemoveAllFilters
//
//  this method cleans filter graph by removing and releasing all the filters
//  if the graph cannot be cleaned, this method returns an error that indicates
//  a failure and does not guarantee that the graph remains in its original
//  state. in fact, in case of error, the caller should assume that the graph 
//  can no longer be used.
//

HRESULT CWaveMSPStream::RemoveAllFilters()
{

    LOG((MSP_INFO, STREAM_PREFIX("RemoveAllFilters - enter.")));


    //
    // get an enumeration with all the filters in the filter graph
    //

    IEnumFilters *pFilterEnumeration = NULL;

    HRESULT hr = m_pIGraphBuilder->EnumFilters( &pFilterEnumeration );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("RemoveAllFilters - failed to enumerate filters. hr = %lx"), hr));

        return hr;
    }


    //
    // we will keep the last error from RemoveFilter if it fails
    //

    HRESULT hrFIlterRemovalError = S_OK;


    //
    // walk through the enumeration and remove and release each filter
    //

    while (TRUE)
    {
        
        IBaseFilter *pFilter = NULL;

        ULONG nFiltersFetched = 0;

        hr = pFilterEnumeration->Next(1, &pFilter, &nFiltersFetched);


        //
        // did the enumeration fail?
        //

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                STREAM_PREFIX("RemoveAllFilters - failed to fetch another filter. hr = %lx"), hr));

            break;
        }


        //
        // did we reach the end of the enumeration?
        //

        if ( hr != S_OK )
        {
            LOG((MSP_INFO, 
                STREAM_PREFIX("RemoveAllFilters - no more filters in the enumeration")));

            
            //
            // if there was an error removing a filter, keep it in hr
            //

            hr = hrFIlterRemovalError;

            break;
        }


        
        LOG((MSP_INFO, STREAM_PREFIX("RemoveAllFilters - removing filter %p."), pFilter));


        //
        // we got a filter. remove it from the graph and then release it
        //

        hr = m_pIGraphBuilder->RemoveFilter( pFilter );


        if (FAILED(hr))
        {
            //
            // we failed to remove a filter from the graph. it is not safe to 
            // continue to use the graph. so we will continue to remove all 
            // other filters and then return the error
            //

            hrFIlterRemovalError = hr;

            LOG((MSP_ERROR, 
                STREAM_PREFIX("RemoveAllFilters - failed to remove filter [%p]. hr = %lx"), 
                pFilter, hr));
  
        }
        else
        {

            //
            // reset enumeration -- the set of filters in the enumeration needs
            // to be updated.
            //

            //
            // note: we only need to reset enumeration if Remove succeeded. 
            // otherwise, we could get into an infinite loop trying to remove
            // failing filter
            //

            hr = pFilterEnumeration->Reset();

            if (FAILED(hr))
            {


                //
                // log a message, but don't do anything else -- next() will most 
                // likely fail and that error will be handled
                //

                LOG((MSP_ERROR,
                    STREAM_PREFIX("RemoveAllFilters - failed to reset enumeration. hr = %lx"),
                    hr));
            }
        }



        pFilter->Release();
        pFilter = NULL;

    }


    //
    // done with the enumeration
    //

    pFilterEnumeration->Release();
    pFilterEnumeration = NULL;


    //
    // note that an error returned from this method means that the graph could
    // not be cleaned and is not guaranteed to be in useable state.
    //

    LOG((MSP_(hr), STREAM_PREFIX("RemoveAllFilters - finish. hr = %lx"), hr));

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CWaveMSPStream::CleanFilterGraph
//
//
//  this function removes all the filters from the filter graph and then readds
//  the wave filter
//
//  if the method returns a failure, the graph is in undefined state and cannot
//  be used.
//

HRESULT CWaveMSPStream::CleanFilterGraph()
{
    LOG((MSP_TRACE, STREAM_PREFIX("CleanFilterGraph - enter")));


    //
    // completely clean filter graph
    //
    
    HRESULT hr = RemoveAllFilters();

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, 
            STREAM_PREFIX("CleanFilterGraph - remove all filters 0x%x"), hr));

        return hr;
    }


    //
    // Add the wave filter back to the graph
    //

    hr = m_pIGraphBuilder->AddFilter( m_pFilter,
                                      NULL );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("CleanFilterGraph - failed to re-add filter: 0x%x"), hr));

        return hr;
    }


    LOG((MSP_TRACE, STREAM_PREFIX("CleanFilterGraph - exit")));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Remove and readd the terminal. This is only needed between a successful
// intelligent connection and the subsequent reconnection.
//

//////////////////////////////////////////////////////////////////////////////


HRESULT CWaveMSPStream::RemoveTerminal()
{
    LOG((MSP_TRACE, STREAM_PREFIX("RemoveTerminal - enter")));


    //
    // verify the assumptin that we have exactly one terminal
    //

    if (1 != m_Terminals.GetSize() )
    {

        LOG((MSP_ERROR,
            STREAM_PREFIX("RemoveTerminal - expecting one terminal. have %d "),
            m_Terminals.GetSize()));

        _ASSERTE(FALSE);

        return E_UNEXPECTED;
    }


    //
    // Get the ITTerminalControl interface.
    //
    
    ITTerminalControl *pTerminalControl = NULL;

    HRESULT hr = m_Terminals[0]->QueryInterface(IID_ITTerminalControl,
                                        (void **) &pTerminalControl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("RemoveTerminal - QI for ITTerminalControl failed hr = 0x%x"), hr));

        return hr;
    }


    //
    // Disconnect the terminal (this also removes it from the filter graph)
    //

    hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

    pTerminalControl->Release();
    pTerminalControl = NULL;

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("RemoveTerminal - DisconnectTerminal failed hr = 0x%x"), hr));

        return hr;
    }

   
    LOG((MSP_TRACE, STREAM_PREFIX("RemoveTerminal - exit")));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


HRESULT CWaveMSPStream::ReAddTerminal()
{
    LOG((MSP_TRACE, STREAM_PREFIX("ReAddTerminal - enter")));

    //
    // verify the assumptin that we have exactly one terminal
    //

    if (1 != m_Terminals.GetSize() )
    {

        LOG((MSP_ERROR,
            STREAM_PREFIX("RemoveTerminal - expecting one terminal. have %d "),
            m_Terminals.GetSize()));

        _ASSERTE(FALSE);

        return E_UNEXPECTED;
    }


    //
    // Get the ITTerminalControl interface.
    //

    ITTerminalControl *pTerminalControl = NULL;

    HRESULT hr = m_Terminals[0]->QueryInterface(IID_ITTerminalControl,
                                                (void **) &pTerminalControl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("ReAddTerminal - QI for ITTerminalControl failed hr = 0x%x"), hr));

        return hr;
    }


    //
    // Find out how many pins the terminal has. If not one then bail as
    // we have no idea what to do with multiple-pin terminals at this point.
    //

    DWORD dwNumPinsAvailable = 0;

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ReAddTerminal - "
            "query for number of terminal pins failed 0x%x)"), hr));
    
        pTerminalControl->Release();
        pTerminalControl = NULL;
        
        return hr;
    }

    if ( 1 != dwNumPinsAvailable )
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("ReAddTerminal - unsupported number of terminal pins %ld ")));

        pTerminalControl->Release();
        pTerminalControl = NULL;

        return E_INVALIDARG;
    }


    //
    // Before adding a RENDER filter to the graph (ie, the terminal on
    // a RENDER stream), do SetDefaultSyncSource
    // to enable drop-sample code in DirectShow which will prevent
    // forever-increasing latency with mismatched wave clocks.
    //

    if ( m_Direction == TD_RENDER )
    {
        hr = m_pIGraphBuilder->SetDefaultSyncSource();

        if ( FAILED(hr) )
        {
	        LOG((MSP_WARN, 
                STREAM_PREFIX(
                "ReAddTerminal - SetDefaultSyncSource failed hr = 0x%x - continuing anyway"),
                hr));
        }
    }


    //
    // Actually connect the terminal.
    //

    IPin *pTerminalPin = NULL;

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           &pTerminalPin);

    pTerminalControl->Release();
    pTerminalControl = NULL;


    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            STREAM_PREFIX("ReAddTerminal - ConnectTerminal on terminal failed hr = 0x%x"), 
            hr));

        return hr;
    }


    //
    // also try to check if the terminal returned a bad pin.
    //

    if ( IsBadReadPtr(pTerminalPin, sizeof(IPin)) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ReAddTerminal - "
            "ConnectTerminal on terminal succeeded but returned a bad pin ")));

        return E_FAIL;
    }


    pTerminalPin->Release();
    pTerminalPin = NULL;

    LOG((MSP_TRACE, STREAM_PREFIX("ReAddTerminal- exit")));

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// DecideDesiredCaptureBufferSize
//
// This method must be called when the graph is connected. It uses the
// connection format on the passed-in pin to determine how many bytes should
// be used in each buffer to achieve DESIRED_BUFFER_SIZE_MS milliseconds of
// sound in each buffer.
//
// In the past, on slow machines with buggy wave drivers, small sample sizes
// have led to bad audio quality, invariably on devices that are not designed
// for interactive use anyway, where latency would be important. We've been
// successful in getting key wave drivers fixed to work well with small
// buffer sizes. It doesn't make sense to increase the default buffer size for
// the benefit of buggy drivers, as we want to achieve low latency with the
// good drivers, which is now pretty much all of them. If someone wants to use
// the WaveMSP for interactive calls and they have a really lousy driver, they
// need to get the driver fixed. Nevertheless it may be a good idea to make
// a registry value for this, for the rare case where fixing the driver may
// not be possible or convenient.
//

static const long DESIRED_BUFFER_SIZE_MS = 20; // milliseconds

HRESULT CWaveMSPStream::DecideDesiredCaptureBufferSize(IPin * pPin,
                                                       long * plDesiredSize)
{
    LOG((MSP_TRACE, STREAM_PREFIX("DecideDesiredCaptureBufferSize - "
        "enter")));

    _ASSERTE( ! IsBadReadPtr(pPin, sizeof(IPin)) );
    _ASSERTE( ! IsBadWritePtr(plDesiredSize, sizeof(long)) );

    //
    // Get the format being used for this pin's connection.
    //

    HRESULT hr;

    AM_MEDIA_TYPE MediaType;
    
    hr = pPin->ConnectionMediaType( & MediaType );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("DecideDesiredCaptureBufferSize - "
            "ConnectionMediaType failed - hr = 0x%08x"), hr));

        return hr;
    }

    _ASSERTE( MediaType.formattype == FORMAT_WaveFormatEx );
    _ASSERTE( MediaType.cbFormat >= sizeof(WAVEFORMATEX)  );

    //
    // Calculate the desired capture buffer size.
    //

    *plDesiredSize = DESIRED_BUFFER_SIZE_MS * 
          ((WAVEFORMATEX *) (MediaType.pbFormat) )->nChannels *
        ( ((WAVEFORMATEX *) (MediaType.pbFormat) )->nSamplesPerSec / 1000 ) * 
        ( ((WAVEFORMATEX *) (MediaType.pbFormat) )->wBitsPerSample / 8    );

    FreeMediaType( MediaType );

    LOG((MSP_TRACE, STREAM_PREFIX("DecideDesiredCaptureBufferSize - "
        "exit S_OK")));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// ConfigureCapture
//
// This is a helper function that sets up the allocator properties on the
// capture filter, given the terminal's pin and our filter's pin. This
// involves determining if either of the pins belongs to an MST, since we
// don't want to set the default buffer size in the non-interactive case,
// but if the input pin belongs to an MST, we want to propagate the MST's
// properties to the output pin. If no MSTs are involved, then we set the
// passed-in default buffer size.
//
// We are already in a lock; no need to do locking here.
//
    
HRESULT CWaveMSPStream::ConfigureCapture(
    IN   IPin * pOutputPin,
    IN   IPin * pInputPin,
    IN   long   lDefaultBufferSize
    )
{
    LOG((MSP_TRACE, STREAM_PREFIX("ConfigureCapture - enter")));

    //
    // If the output pin belongs to an MST, then we do not want
    // to mess with its allocator properties.
    //

    HRESULT hr;
    ITAllocatorProperties * pProperties;

    hr = pOutputPin->QueryInterface(IID_ITAllocatorProperties,
                                    (void **) &pProperties);
 
    if ( SUCCEEDED(hr) )
    {
        pProperties->Release();

        LOG((MSP_TRACE, STREAM_PREFIX("ConfigureCapture - "
            "output pin is on an MST - not changing capture "
            "allocator properties - exit S_OK")));

        return S_OK;
    }

    //
    // Ask the output pin for its buffer negotiation interface.
    // This will be used to suggest allocator propreties on the
    // output pin.
    //

    IAMBufferNegotiation * pNegotiation;

    hr = pOutputPin->QueryInterface(IID_IAMBufferNegotiation,
                                    (void **) &pNegotiation);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConfigureCapture - "
            "IAMBufferNegotiation QI failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // If the input pin belongs to an MST and the MST divulges its
    // allocator properties, then we just propage them to the output
    // pin. Otherwise we set our own default properties on the
    // output pin.
    //

    ALLOCATOR_PROPERTIES props;

    hr = pInputPin->QueryInterface(IID_ITAllocatorProperties,
                                   (void **) &pProperties);
 
    if ( SUCCEEDED(hr) )
    {
        hr = pProperties->GetAllocatorProperties(&props);

        pProperties->Release();
    }

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("ConfigureCapture - "
            "using downstream MST allocator properties")));
    }
    else
    {
        LOG((MSP_TRACE, STREAM_PREFIX("ConfigureCapture - "
            "using our default allocator properties")));
    
        props.cBuffers  = 32;   // we use 32 to avoid starvation
        props.cbBuffer  = lDefaultBufferSize;
        props.cbAlign   = -1;   // means "default"
        props.cbPrefix  = -1;   // means "default"
    }

    //
    // "props" now contains the properties that we need to set.
    // Suggest them to the output pin.
    //

    hr = pNegotiation->SuggestAllocatorProperties( &props );

    pNegotiation->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConfigureCapture - "
            "SuggestAllocatorProperties failed - exit 0x%08x"), hr));

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("ConfigureCapture - exit S_OK")));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// This function is for debugging purposes only. It pops up a
// couple of message boxes telling you various information about
// media formats and allocator properties. It's called after
// connection has taken place. pPin is the output pin of the
// wavein filter.
//
        
HRESULT CWaveMSPStream::ExamineCaptureProperties(IPin *pPin)
{
    LOG((MSP_TRACE, STREAM_PREFIX("ExamineCaptureProperties - enter")));

    HRESULT hr;
    IAMBufferNegotiation * pNegotiation = NULL;

    hr = pPin->QueryInterface(IID_IAMBufferNegotiation,
                              (void **) &pNegotiation
                             );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ExamineCaptureProperties - "
            "IAMBufferNegotiation QI failed on pin 0x%08x; hr = 0x%08x"),
            pPin, hr));

        return hr;
    }

    ALLOCATOR_PROPERTIES prop;
    
    hr = pNegotiation->GetAllocatorProperties(&prop);

    pNegotiation->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ExamineCaptureProperties - "
            "GetAllocatorProperties failed; hr = 0x%08x"),
            hr));

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("GetAllocatorProperties info:\n"
            "buffer count: %d\n"
            "size of each buffer: %d bytes\n"
            "alignment multiple: %d\n"
            "each buffer has a prefix: %d bytes"),
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
           ));

    AM_MEDIA_TYPE MediaType;
    
    hr = pPin->ConnectionMediaType( & MediaType );
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ExamineCaptureProperties - "
            "ConnectionMediaType failed - hr = 0x%08x"), hr));

        return hr;
    }

    //
    // Check if this media type has a WAVE format.
    //

    if ( MediaType.formattype != FORMAT_WaveFormatEx )
    {
        //
        // might want to print the format type guid here if we ever care
        //

        _ASSERTE( FALSE );
        LOG((MSP_TRACE, STREAM_PREFIX("connected media type: NON-WAVE")));
	}
	else
	{
        _ASSERTE( MediaType.cbFormat >= sizeof(WAVEFORMATEX) );

        LOG((MSP_TRACE, STREAM_PREFIX("connected media type:\n"
			"sample size: %d bytes\n"
			"format tag: %d\n"
			"channels: %d\n"
			"samples per second: %d\n"
			"bits per sample: %d\n"),

            MediaType.lSampleSize,
			((WAVEFORMATEX *) (MediaType.pbFormat) )->wFormatTag,
			((WAVEFORMATEX *) (MediaType.pbFormat) )->nChannels,
			((WAVEFORMATEX *) (MediaType.pbFormat) )->nSamplesPerSec,
			((WAVEFORMATEX *) (MediaType.pbFormat) )->wBitsPerSample
		   ));
    }

    FreeMediaType( MediaType );

    LOG((MSP_TRACE, STREAM_PREFIX("ExamineCaptureProperties - "
        "exit S_OK")));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SetLiveMode
//
// If this is a wavein filter, tell it that it should do its best to
// counter the effects of mismatched clocks and drop samples when the
// latency gets too great. We really should do this on terminal
// selection dependin on whether we have at least one terminal selected on
// the stream that requires real-time performance, but this will have to
// do for now.
//

HRESULT CWaveMSPStream::SetLiveMode(BOOL fEnable, IBaseFilter * pFilter)
{
    return S_OK;
#if 0
    HRESULT         hr;
    IAMPushSource * pPushSource;

    hr = pFilter->QueryInterface(
                                 IID_IAMPushSource,
                                 (void **) & pPushSource
                                );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, STREAM_PREFIX("SetLiveMode - "
            "QI for IAMPushSource returned 0x%08x - continuing"), hr));
    }
    else
    {
        hr = pPushSource->SetLiveMode( fEnable );

        if ( FAILED(hr) )
        {
            LOG((MSP_INFO, STREAM_PREFIX("SetLiveMode - "
                "IAMPushSource::SetLiveMode( %d ) returned 0x%08x"
                " - continuing"), fEnable, hr));
        }
        else
        {
            LOG((MSP_INFO, STREAM_PREFIX("SetLiveMode - "
                "IAMPushSource::SetLiveMode( %d ) succeeded"
                " - continuing"), fEnable, hr));
        }

        pPushSource->Release();
    }
    return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Add the terminal to the graph and connect it to our
// filters, if it is not already in use.
//

HRESULT CWaveMSPStream::ConnectTerminal(ITTerminal * pTerminal)
{
    LOG((MSP_TRACE, STREAM_PREFIX("ConnectTerminal - enter")));


    //
    // If we've already connected the terminal on this stream, then
    // there is nothing for us to do.
    //

    if ( m_fTerminalConnected )
    {

        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "terminal already connected on this stream - exit S_OK")));

        return S_OK;
    }


    //
    // Get the ITTerminalControl interface.
    //

    ITTerminalControl * pTerminalControl = NULL;

    HRESULT hr = m_Terminals[0]->QueryInterface(IID_ITTerminalControl,
                                        (void **) &pTerminalControl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "QI for ITTerminalControl failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // Find out how many pins the terminal has. If not one then bail as
    // we have no idea what to do with multiple-pin terminals at this point.
    //

    DWORD dwNumPinsAvailable;

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "query for number of terminal pins failed - exit 0x%08x"), hr));
        
        pTerminalControl->Release();

        return hr;
    }

    if ( 1 != dwNumPinsAvailable )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "unsupported number of terminal pins - exit E_FAIL")));

        pTerminalControl->Release();

        return E_FAIL;
    }

    //
    // Before adding a RENDER filter to the graph (ie, the terminal on
    // a RENDER stream), do SetDefaultSyncSource
    // to enable drop-sample code in DirectShow which will prevent
    // forever-increasing latency with mismatched wave clocks.
    //

    if ( m_Direction == TD_RENDER )
    {
        hr = m_pIGraphBuilder->SetDefaultSyncSource();

        if ( FAILED(hr) )
        {
            LOG((MSP_WARN, STREAM_PREFIX("ConnectTerminal - "
                "SetDefaultSyncSource failed 0x%08x - continuing anyway"), hr));
        }
    }
    
    //
    // Actually connect the terminal.
    //

    IPin * pTerminalPin;

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           &pTerminalPin);
    
    if ( FAILED(hr) )
    {
        pTerminalControl->Release();

        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "ConnectTerminal on terminal failed - exit 0x%08x"), hr));

        return hr;
    }


    //
    // also try to check if the terminal returned a bad pin.
    //

    if ( IsBadReadPtr(pTerminalPin, sizeof(IPin)) )
    {
        pTerminalControl->Release();

        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "ConnectTerminal on terminal succeeded but returned a bad pin "
            "- returning E_POINTER")));

        return E_POINTER;
    }

    //
    // For a CAPTURE filter's pin, (ie, the terminal on a CAPTURE stream), get
    // the filter and turn on sample dropping for live graphs. Ignore failure
    // here. Note -- this will not work for multi-filter terminals. Luckily
    // our interactive audio terminals are single-filter terminals.
    // Multi-filter terminals can do this themselves.
    //

    if ( m_Direction == TD_CAPTURE )
    {
        PIN_INFO info;

        hr = pTerminalPin->QueryPinInfo( & info );

        if ( FAILED(hr) )
        {
            LOG((MSP_WARN, STREAM_PREFIX("ConnectTerminal - "
                "get filter in preparation for SetLiveMode failed "
                "0x%08x - continuing anyway"), hr));
        }
        else
        {
            SetLiveMode( TRUE, info.pFilter );

            info.pFilter->Release();
        }
    }

    //
    // Now make the connection between our filters and the terminal's pin.
    //

    hr = ConnectToTerminalPin(pTerminalPin);

    pTerminalPin->Release();

    if ( FAILED(hr) )
    {
        pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        pTerminalControl->Release();


        //
        // remove all the filters except for the wave filter
        //

        HRESULT hr2 = CleanFilterGraph();

        if (FAILED(hr2))
        {
            
            LOG((MSP_ERROR, 
                STREAM_PREFIX("ConnectTerminal - CleanFilterGraph failed- exit 0x%x"), 
                hr2));

            //
            // filter graph may be in a bad shape, but there is nothing we can really do at this point.
            //

        }


        LOG((MSP_ERROR, STREAM_PREFIX("ConnectTerminal - "
            "ConnectToTerminalPin failed - exit 0x%08x"), hr));

        return hr;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //

    m_fTerminalConnected  = TRUE;

    pTerminalControl->CompleteConnectTerminal();

    pTerminalControl->Release();

    LOG((MSP_TRACE, STREAM_PREFIX("ConnectTerminal - exit S_OK")));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

void ShowMediaTypes(IEnumMediaTypes * pEnum)
{
    //
    // Look at each media type in the enumerator.
    //

    AM_MEDIA_TYPE * pMediaType;

    while (pEnum->Next(1, &pMediaType, NULL) == S_OK)
    {
        //
        // Check if this media type has a WAVE format.
        //

        if ( pMediaType->formattype != FORMAT_WaveFormatEx )
        {
            //
            // might want to print the format type guid here if we ever care
            //

	        LOG((MSP_TRACE, "Media Type: *** non-wave"));
		}
		else
		{
			LOG((MSP_TRACE,"Media Type: [format tag %d][%d channels]"
                "[%d samples/sec][%d bits/sample]",
				((WAVEFORMATEX *) (pMediaType->pbFormat) )->wFormatTag,
				((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels,
				((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec,
				((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample
			   ));
		}

        //
        // Release the format info.
        //

        DeleteMediaType(pMediaType);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// ConnectUsingG711
//
// This method connects pOutputPin to pInputPin using the G711 codec and
// returns success if the connection was successful. If the connection was
// unsuccessful, it does its best to fully disconnect the filters and then
// returns a failure code.
//
// Assumptions:
//      * direct connection has already failed
//      * the g711 codec has been created and added to the graph
//
// Parameters:
//     IN   IPin * pOutputPin -- output pin on the capture filter or terminal
//     IN   IPin * pInputPin  -- input pin on the render filter or terminal
//
//

HRESULT CWaveMSPStream::ConnectUsingG711(
    IN  IPin * pOutputPin,
    IN  IPin * pInputPin
    )
{
    HRESULT hr;
    
    IPin * pG711InputPin = NULL;

    hr = FindPinInFilter(
                         false,          // want input pin
                         m_pG711Filter,
                         &pG711InputPin
                        );

    if ( SUCCEEDED(hr) )
    {
        hr = m_pIGraphBuilder->ConnectDirect(
                              pOutputPin,
                              pG711InputPin,
                              NULL
                             );

        // We don't release the G711's input pin here because we must
        // hang onto it in order to break the connection if any of the
        // subsequent steps fail.

        if ( SUCCEEDED(hr) )
        {
            IPin * pG711OutputPin = NULL;

            hr = FindPinInFilter(
                                 true,          // want output pin
                                 m_pG711Filter,
                                 &pG711OutputPin
                                );

            if ( SUCCEEDED(hr) )
            {
                hr = m_pIGraphBuilder->ConnectDirect(
                                      pG711OutputPin,
                                      pInputPin,
                                      NULL
                                     );

                pG711OutputPin->Release();

                if ( SUCCEEDED(hr) )
                {
                    LOG((MSP_TRACE, STREAM_PREFIX("ConnectUsingG711 - G711 connection succeeded - exit S_OK")));

                    // Held onto this in case of failure... see above
                    pG711InputPin->Release();

                    return S_OK;
                }
                else
                {
                    LOG((MSP_ERROR, STREAM_PREFIX("ConnectUsingG711 - could not connect "
                                      "G711 codec's output pin - %lx"), hr));

                }
            }
            else
            {
                LOG((MSP_ERROR, STREAM_PREFIX("ConnectUsingG711 - could not find "
                                  "G711 codec's input pin - %lx"), hr));
            }


            if ( FAILED(hr) )
            {
                //
                // The first G711 connection succeeded but something else
                // subsequently failed. This means we must disconnect the left
                // end of the G711 filter. Luckily, we held onto the G711 filter's
                // input pin above. We must disconnect the them here, otherwise
                // method #3 won't work.
                //

                HRESULT hr2;

                hr2 = m_pIGraphBuilder->Disconnect(pOutputPin);

                if ( FAILED(hr2) )
                {
                    LOG((MSP_ERROR, STREAM_PREFIX("ConnectUsingG711 - error undoing g711 "
                        "connection attempt - could not disconnect the "
                        "wave filter's output pin! hr = 0x%08x"), hr2));
                }

                hr2 = m_pIGraphBuilder->Disconnect(pG711InputPin);

                if ( FAILED(hr2) )
                {
                    LOG((MSP_ERROR, STREAM_PREFIX("ConnectUsingG711 - error undoing g711 "
                        "connection attempt - could not disconnect the "
                        "g711 filter's input pin! hr = 0x%08x"), hr2));
                }

                //
                // Now we no longer need to talk to the pin...
                //

                pG711InputPin->Release();

                //
                // And the G711 filter itself sticks around in the graph for next time.
                //
            }
        }
        else
        {
            LOG((MSP_ERROR, STREAM_PREFIX("ConnectUsingG711 - could not connect "
                              "G711 codec's input pin - %lx"), hr));
        }
    }
    else
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConnectUsingG711 - could not find "
                          "G711 codec's input pin - %lx"), hr));
    }

    return hr;
}
        
//////////////////////////////////////////////////////////////////////////////
//
// TryToConnect
//
// This is a private helper method.
//
// This method connects an output pin to an input pin. It first tries
// direct connection; failing this, it adds the G711 filter to the graph
// and tries a G711 connection; failing that, it tries an intelligent
// connection (which can be disabled at compile time). 
//
// Arguments:
//     pOutputPin    - IN  - output pin on the capture filter or terminal
//     pInputPin     - IN  - input pin on the render filter or terminal
//     pfIntelligent - OUT - if NULL, then this parameter is ignored
//                           otherwise, BOOl value at this location is
//                           set to TRUE if intelligent connection was
//                           used, FALSE otherwise. Invalid if connection
//                           was unsuccessful.
//
// Return values:
//     S_OK    -- success
//     various -- from other helpers and DShow methods
//
//

HRESULT CWaveMSPStream::TryToConnect(
    IN   IPin * pOutputPin,
    IN   IPin * pInputPin,
    OUT  BOOL * pfIntelligent
    )
{
    LOG((MSP_TRACE, STREAM_PREFIX("TryToConnect - enter")));

    //
    // Assume unintelligent connection unless we actually happen
    // to use it.
    //

    if ( pfIntelligent != NULL )
    {
        _ASSERTE( ! IsBadWritePtr( pfIntelligent, sizeof( BOOL ) ) );

        *pfIntelligent = FALSE;
    }

    HRESULT       hr;

    //
    // Method 1: direct connection
    //

    hr = m_pIGraphBuilder->ConnectDirect(
                              pOutputPin,
                              pInputPin,
                              NULL
                             );

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("TryToConnect: direct connection worked - exit S_OK")));
        return S_OK;
    }

    LOG((MSP_ERROR, STREAM_PREFIX("TryToConnect - direct connection failed - %lx"), hr));

    //
    // Method 2: direct connection with G711 filter in between.
    // If we haven't created and added the G711 filter to the graph yet,
    // do so now.
    //

    hr = AddG711();


    //
    // If the AddG711 method worked, try to use the G711.
    //

    if (SUCCEEDED(hr) && m_pG711Filter)
    {
        hr = ConnectUsingG711(pOutputPin,
                              pInputPin);

        if ( SUCCEEDED(hr) )
        {
            LOG((MSP_TRACE, STREAM_PREFIX("TryToConnect - "
                "g711 connection worked - exit S_OK")));

            return S_OK;
        }
        else
        {
            LOG((MSP_TRACE, STREAM_PREFIX("TryToConnect - "
                "G711 connection failed - %lx"), hr));
        }
    }
    else
    {
        LOG((MSP_ERROR, STREAM_PREFIX("TryToConnect - G711 codec does not exist. hr = %lx"), hr));

        hr = E_FAIL;

    }

    //
    // Method 3: intelligent connection, which may pull in who knows what
    // other filters
    //

#ifdef ALLOW_INTELLIGENT_CONNECTION

    //
    // Before intelligent connection, create the DShow filter mapper object if
    // it doesn't already exist, and save it until the address is shut down.
    // This will make all intelligent connects after the first much faster.
    // No need to check the return code; if it fails, we just continue. The
    // WaveMspCall object forwards this call to our address object.
    //
    // m_pMSPCall is valid here, because it is released in
    // CMSPStream::ShutDown. ShutDown grabs the stream lock, releases
    // m_pMSPCall, and unselects all terminals. The connection process starts
    // with a StartStream or PauseStream, and those methods all grab the
    // stream lock and return immediately if there are no terminals selected.
    // Therefore, there is no danger of the call pointer being invalid during
    // connection on a stream.
    //

    ((CWaveMSPCall *) m_pMSPCall)->CreateFilterMapper();

    hr = m_pIGraphBuilder->Connect(pOutputPin,
                                   pInputPin);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("TryToConnect - "
            "intelligent connection failed - %lx"), hr));

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("TryToConnect - "
        "intelligent connection worked - exit S_OK")));

    if ( pfIntelligent != NULL )
    {
        *pfIntelligent = TRUE;
    }

    return S_OK;

#else // ALLOW_INTELLIGENT_CONNECTION

    LOG((MSP_ERROR, STREAM_PREFIX("TryToConnect - NOTE: we never allow intelligent "
        "connection - exit 0x%08x"), hr));
    
    return hr;

#endif // ALLOW_INTELLIGENT_CONNECTION

}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

HRESULT CWaveMSPStream::ConnectToTerminalPin(IPin * pTerminalPin)
{
    LOG((MSP_TRACE, STREAM_PREFIX("ConnectToTerminalPin - enter")));

    HRESULT         hr = S_OK;

    //
    // Find our own filter's pin.
    //
        
    IPin *          pMyPin;

    hr = FindPin( &pMyPin );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConnectToTerminalPin - "
            "could not find pin - exit 0x%08x"), hr));

        return hr; // we can't continue without this pin
    }

    // The OUTPUT pin from WAVEIN; the INPUT pin from WAVEOUT
    IPin * pOutputPin  = ( m_Direction == TD_RENDER  ) ? pMyPin : pTerminalPin;
    IPin * pInputPin   = ( m_Direction == TD_CAPTURE ) ? pMyPin : pTerminalPin;

#ifdef MSPLOG

    //
    // In the interests of easier diagnosis, do some tracing of the formats
    // that are available.
    //

    IEnumMediaTypes * pEnum;

    hr = pOutputPin->EnumMediaTypes(&pEnum);

    if ( SUCCEEDED(hr) )
    {  
        LOG((MSP_TRACE, STREAM_PREFIX("Output pin media types:")));
        ShowMediaTypes(pEnum);
        pEnum->Release();
    }

    hr = pInputPin->EnumMediaTypes(&pEnum);
    
    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("Input pin media types:")));
        ShowMediaTypes(pEnum);
        pEnum->Release();
    }

#endif // #ifdef MSPLOG

    //
    // Do a preliminary connection between the terminal and our filter,
    // without having configured the capturer's allocator properties.
    //
    // fIntelligent is assigned TRUE if intelligent connection was used,
    // FALSE otherwise -- only valid on success.
    //

    BOOL fIntelligent;

    hr = TryToConnect(pOutputPin,
                      pInputPin,
                      & fIntelligent
                      );

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, STREAM_PREFIX("ConnectToTerminalPin - "
            "preliminary connection succeeded")));

        //
        // Now that we are connected, find out the default buffer size we
        // should use at the capture filter with interactive terminals.
        // This can only be gleaned when the capture filter is connected, but
        // we cannot make use of the information until we disconnect the
        // filters.
        //

        long lDefaultBufferSize;

        hr = DecideDesiredCaptureBufferSize(pOutputPin,
                                            & lDefaultBufferSize);

        if ( SUCCEEDED(hr) )
        {
            LOG((MSP_TRACE, STREAM_PREFIX("ConnectToTerminalPin - "
                "default buffer size determination succeeded")));


            //
            // remove the terminal from the graph
            //

            hr = RemoveTerminal();

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, 
                    STREAM_PREFIX("ConnectToTerminalPin - RemoveTerminal Failed hr=0x%x"), hr));

            }
            else
            {

                //
                // clean filter graph by removing all the filters other than 
                // the wave filter
                //

                CleanFilterGraph();

            
                //
                // we can now re-add the terminal.
                //

                hr = ReAddTerminal();

                if ( FAILED(hr) )
                {

                    LOG((MSP_ERROR, 
                        STREAM_PREFIX("ConnectToTerminalPin - ReAddTerminal failed - hr=0x%x"),
                        hr));
                }
                else
                {

                    //
                    // Perform our settings on the capture filter.
                    // We don't need to bail if this fails -- we will just have worse
                    // latency / performance.
                    //

                    ConfigureCapture(pOutputPin,
                                     pInputPin,
                                     lDefaultBufferSize);

                    //
                    // Now do the actual connection between the terminal and our filter.
                    // Last argument is NULL because we don't care if it's intelligent
                    // this time
                    //

                    hr = TryToConnect(pOutputPin,
                                      pInputPin,
                                      NULL
                                     );

                }
            }
        }
    }

#ifdef MSPLOG

    if ( SUCCEEDED(hr) )
    {
        // Do some extra debug output.
        // don't care if something fails in here...

        ExamineCaptureProperties(pOutputPin);
    }

#endif

    pMyPin->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, STREAM_PREFIX("ConnectToTerminalPin - "
            "could not connect to pin - exit 0x%08x"), hr));

        
        //
        // cleanup by removing all filters except for the wave filter
        //

        CleanFilterGraph();

        return hr;
    }

    LOG((MSP_TRACE, STREAM_PREFIX("ConnectToTerminalPin - exit S_OK")));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::FindPinInFilter(
                     BOOL           bWantOutputPin, // IN:  if false, we want the input pin
                     IBaseFilter *  pFilter,        // IN:  the filter to examine
                     IPin        ** ppPin           // OUT: the pin we found
                     )
{    
    HRESULT         hr;
    IEnumPins     * pEnumPins;
    
    
    *ppPin = NULL;

    // enumerate the pins on the filter
    hr = pFilter->EnumPins( &pEnumPins );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // go through the pins
    while (TRUE)
    {
        PIN_DIRECTION       pd;
        
        hr = pEnumPins->Next( 1, ppPin, NULL );

        if (S_OK != hr)
        {
            // didn't find a pin!
            break;
        }

        // get the pin info
        hr = (*ppPin)->QueryDirection( &pd );

        // does it meet the criteria?
        if (bWantOutputPin && (pd == PINDIR_OUTPUT))
        {
            // yes
            break;
        }

        if ( ! bWantOutputPin && (pd == PINDIR_INPUT))
        {
            // yes
            break;
        }
        
        (*ppPin)->Release();
        *ppPin = NULL;
    }

    pEnumPins->Release();

    if (NULL == *ppPin)
    {
        // error
        return E_FAIL;
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// FindPin
//
// Finds the first pin in the filter that meets criteria.
// For bWaveIn == TRUE, the pin must be direction PINDIR_OUTPUT
// For bWaveIn == FALSE, the pin must be direction PINDIR_INPUT
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CWaveMSPStream::FindPin(
        IPin ** ppPin
       )
{
    return FindPinInFilter(m_Direction == TD_RENDER,
                           m_pFilter,
                           ppPin);
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\atsp32\atsp.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    atsp.h

Notes:

--*/

#include <windows.h>
#include "tapi.h"
#include "tspi.h"
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "resource.h"


#define  MAX_DEV_NAME_LENGTH    63
#define  ATSP_TIMEOUT           60000   // milliseconds


typedef struct _DRVLINE
{
    HTAPILINE               htLine;

    LINEEVENT               pfnEventProc;

    DWORD                   dwDeviceID;

    char                    szComm[8];

    HTAPICALL               htCall;

    DWORD                   dwCallState;

    DWORD                   dwCallStateMode;

    DWORD                   dwMediaMode;

    HANDLE                  hComm;

    BOOL                    bDropInProgress;

    OVERLAPPED              Overlapped;

} DRVLINE, FAR *PDRVLINE;


typedef struct _DRVLINECONFIG
{
    char                    szPort[8];

    char                    szCommands[64];

} DRVLINECONFIG, FAR *PDRVLINECONFIG;


typedef struct _ASYNC_REQUEST
{
    DWORD                   dwRequestID;

    DWORD                   dwCommand;

    char                    szCommand[32];

    struct _ASYNC_REQUEST  *pNext;

} ASYNC_REQUEST, *PASYNC_REQUEST;


#if DBG

typedef struct _FUNC_PARAM
{
    char        *lpszVal;

    ULONG_PTR   dwVal;

} FUNC_PARAM, *PFUNC_PARAM;

#endif

typedef struct _FUNC_INFO
{

#if DBG

    char        *lpszFuncName;

    DWORD       dwNumParams;

    PFUNC_PARAM aParams;

#endif

    LONG        lResult;

} FUNC_INFO, *PFUNC_INFO;


DWORD               gdwLineDeviceIDBase;
DWORD               gdwPermanentProviderID;
HANDLE              ghInst;
ASYNC_COMPLETION    gpfnCompletionProc;

char gszAtspKey[]      = "Software\\Microsoft\\ATSP";
char gszNumLines[]     = "NumLines";
char gszDefLineConfigParams[] = "my new line,COM1,L0";

#if DBG

char gszTab[]          = "    ";
char gszhdLine[]       = "hdLine";
char gszhdCall[]       = "hdCall";
char gszdwSize[]       = "dwSize";
char gszhwndOwner[]    = "hwndOwner";
char gszdwDeviceID[]   = "dwDeviceID";
char gszdwRequestID[]  = "dwRequestID";
char gszlpCallParams[] = "lpCallParams";
char gszdwPermanentProviderID[] = "dwPermanentProviderID";

DWORD   gdwDebugLevel = 0;

void
CDECL
DebugOutput(
    DWORD   dwLevel,
    LPCSTR  lpszFormat,
    ...
    );

#define DBGOUT(arg) DebugOutput arg

LONG
PASCAL
Epilog(
    PFUNC_INFO  pInfo,
    LONG        lResult
    );

void
PASCAL
Prolog(
    PFUNC_INFO  pInfo
    );

#else

#define DBGOUT(arg)

#define Epilog(pAsyncRequestInfo, lResult) (lResult)

#define Prolog(pAsyncRequestInfo)

#endif


LPWSTR
PASCAL
My_lstrcpyW(
    WCHAR   *pString1,
    WCHAR   *pString2
    );

LPVOID
PASCAL
DrvAlloc(
    DWORD dwSize
    );

VOID
PASCAL
DrvFree(
    LPVOID lp
    );

void
PASCAL
SetCallState(
    PDRVLINE    pLine,
    DWORD       dwCallState,
    DWORD       dwCallStateMode
    );

INT_PTR
CALLBACK
ConfigDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

LONG
PASCAL
ProviderInstall(
    char   *pszProviderName,
    BOOL    bNoMultipleInstance
    );

void
PASCAL
DropActiveCall(
    PDRVLINE    pLine
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\atsp32\resource.h ===
#define IDD_DIALOG1     101
#define IDC_DEVICES     1001
#define IDC_NAME        1002
#define IDC_PORT        1003
#define IDC_COMMANDS    1004
#define IDC_ADD         1005
#define IDC_REMOVE      1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\atsp32\atsp.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    atsp.c

Notes:

--*/


#include "atsp.h"


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    if (dwReason ==  DLL_PROCESS_ATTACH)
    {
        ghInst = hDLL;

#if DBG
        {
            HKEY    hKey;
            DWORD   dwDataSize, dwDataType;
            char    szAtsp32DebugLevel[] = "Atsp32DebugLevel";


            RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                gszAtspKey,
                0,
                KEY_ALL_ACCESS,
                &hKey
                );

            dwDataSize = sizeof (DWORD);
            gdwDebugLevel=0;

            RegQueryValueEx(
                hKey,
                szAtsp32DebugLevel,
                0,
                &dwDataType,
                (LPBYTE) &gdwDebugLevel,
                &dwDataSize
                );

            RegCloseKey (hKey);
        }
#endif

    }

    return TRUE;
}


void
CommThread(
    PDRVLINE    pLine
    )
{
    char            buf[4];
    DWORD           dwThreadID = GetCurrentThreadId(), dwNumBytes;
    HANDLE          hComm = pLine->hComm, hEvent;
    LPOVERLAPPED    pOverlapped = &pLine->Overlapped;


    DBGOUT((
        3,
        "CommThread (id=%d): enter, port=%s",
        dwThreadID,
        pLine->szComm
        ));

    hEvent = pOverlapped->hEvent;
    buf[0] = buf[1] = '.';


    //
    // Loop waiting for i/o to complete (either the Write done in
    // TSPI_lineMakeCall or the Reads done to retrieve status info).
    // Note that TSPI_lineDrop or TSPI_lineCloseCall may set the
    // event to alert us that they're tearing down the call, in
    // which case we just exit.
    //

    for (;;)
    {
        if (WaitForSingleObject (hEvent, ATSP_TIMEOUT) == WAIT_OBJECT_0)
        {
            if (pLine->bDropInProgress == TRUE)
            {
                DBGOUT((2, "CommThread (id=%d): drop in progress"));
                goto CommThread_exit;
            }

            GetOverlappedResult (hComm, pOverlapped, &dwNumBytes, FALSE);
            ResetEvent (hEvent);
        }
        else
        {
            DBGOUT((2, "CommThread (id=%d): wait timeout"));
            SetCallState (pLine, LINECALLSTATE_IDLE, 0);
            goto CommThread_exit;
        }

        buf[1] &= 0x7f; // nuke the parity bit

        DBGOUT((
            3,
            "CommThread (id=%d): read '%c'",
            dwThreadID,
            (buf[1] == '\r' ? '.' : buf[1])
            ));

        switch ((buf[0] << 8) + buf[1])
        {
        case 'CT':  // "CONNECT"
        case 'OK':  // "OK"

            SetCallState (pLine, LINECALLSTATE_CONNECTED, 0);
            goto CommThread_exit;

        case 'SY':  // "BUSY"
        case 'OR':  // "ERROR"
        case 'NO':  // "NO ANSWER", "NO DIALTONE", "NO CARRIER"

            SetCallState (pLine, LINECALLSTATE_IDLE, 0);
            goto CommThread_exit;

        default:

            break;
        }

        buf[0] = buf[1];

        ZeroMemory (pOverlapped, sizeof (OVERLAPPED) - sizeof (HANDLE));
        if ( 0 == ReadFile (hComm, &buf[1], 1, &dwNumBytes, pOverlapped))
		{
            DBGOUT((2, "CommThread (id=%d): fail to read from line"));
			goto CommThread_exit;
		}
    }

CommThread_exit:

    CloseHandle (hEvent);
    DBGOUT((3, "CommThread (id=%d): exit", dwThreadID));
    ExitThread (0);
}


//
// We get a slough of C4047 (different levels of indrection) warnings down
// below in the initialization of FUNC_PARAM structs as a result of the
// real func prototypes having params that are types other than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4047)


//
// --------------------------- TAPI_lineXxx funcs -----------------------------
//

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine, hdLine }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineClose",
        1,
        params,
    };
#endif

    Prolog (&info);
    DrvFree ((PDRVLINE) hdLine);
    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
    )
{
    PDRVLINE    pLine = (PDRVLINE) hdCall;
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdCall, hdCall  }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineCloseCall",
        1,
        params
    };
#endif


    //
    // Note that in TAPI 2.0 TSPI_lineCloseCall can get called
    // without TSPI_lineDrop ever being called, so we need to
    // be prepared for either case.
    //

    Prolog (&info);
    DropActiveCall (pLine);
    pLine->htCall = NULL;
    return (Epilog (&info, 0));
}


LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine,        hdLine       },
        { "dwMediaModes",   dwMediaModes },
        { gszlpCallParams,  lpCallParams }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineConditionalMediaDetection",
        3,
        params
    };
#endif


    //
    // This func is really a no-op for us, since we don't look
    // for incoming calls (though we do say we support them to
    // make apps happy)
    //

    Prolog (&info);
    return (Epilog (&info, 0));
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    PDRVLINE    pLine = (PDRVLINE) hdCall;
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszdwRequestID,        dwRequestID     },
        { gszhdCall,             hdCall          },
        { "lpsUserUserInfo",    lpsUserUserInfo },
        { gszdwSize,             dwSize          }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineDrop",
        4,
        params
    };
#endif


    Prolog (&info);
    DropActiveCall (pLine);
    SetCallState (pLine, LINECALLSTATE_IDLE, 0);
    (*gpfnCompletionProc)(dwRequestID, 0);
    return (Epilog (&info, dwRequestID));
}


LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
    )
{

#if DBG
    FUNC_PARAM  params[] =
    {
        { gszdwDeviceID,     dwDeviceID      },
        { "dwAddressID",    dwAddressID     },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwExtVersion",   dwExtVersion    },
        { "lpAddressCaps",  lpAddressCaps   }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetAddressCaps",
        5,
        params
    };
#endif

    LONG        lResult = 0;


    Prolog (&info);

    if (dwAddressID != 0)
    {
        lResult = LINEERR_INVALADDRESSID;
    }

    lpAddressCaps->dwNeededSize =
    lpAddressCaps->dwUsedSize   = sizeof(LINEADDRESSCAPS);

    lpAddressCaps->dwLineDeviceID       = dwDeviceID;
    lpAddressCaps->dwAddressSharing     = LINEADDRESSSHARING_PRIVATE;
    lpAddressCaps->dwCallInfoStates     = LINECALLINFOSTATE_MEDIAMODE |
                                          LINECALLINFOSTATE_APPSPECIFIC;
    lpAddressCaps->dwCallerIDFlags      =
    lpAddressCaps->dwCalledIDFlags      =
    lpAddressCaps->dwRedirectionIDFlags =
    lpAddressCaps->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    lpAddressCaps->dwCallStates         = LINECALLSTATE_IDLE |
                                          LINECALLSTATE_OFFERING |
                                          LINECALLSTATE_ACCEPTED |
                                          LINECALLSTATE_DIALTONE |
                                          LINECALLSTATE_DIALING |
                                          LINECALLSTATE_CONNECTED |
                                          LINECALLSTATE_PROCEEDING |
                                          LINECALLSTATE_DISCONNECTED |
                                          LINECALLSTATE_UNKNOWN;
    lpAddressCaps->dwDialToneModes      = LINEDIALTONEMODE_UNAVAIL;
    lpAddressCaps->dwBusyModes          = LINEBUSYMODE_UNAVAIL;
    lpAddressCaps->dwSpecialInfo        = LINESPECIALINFO_UNAVAIL;
    lpAddressCaps->dwDisconnectModes    = LINEDISCONNECTMODE_NORMAL |
                                          LINEDISCONNECTMODE_BUSY |
                                          LINEDISCONNECTMODE_NOANSWER |
                                          LINEDISCONNECTMODE_UNAVAIL |
                                          LINEDISCONNECTMODE_NODIALTONE;
    lpAddressCaps->dwMaxNumActiveCalls  = 1;
    lpAddressCaps->dwAddrCapFlags       = LINEADDRCAPFLAGS_DIALED;
    lpAddressCaps->dwCallFeatures       = LINECALLFEATURE_ACCEPT |
                                          LINECALLFEATURE_ANSWER |
                                          LINECALLFEATURE_DROP |
                                          LINECALLFEATURE_SETCALLPARAMS;
    lpAddressCaps->dwAddressFeatures    = LINEADDRFEATURE_MAKECALL;

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine,             hdLine         },
        { "dwAddressID",        dwAddressID     },
        { "lpAddressStatus",    lpAddressStatus }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetAddressStatus",
        3,
        params
    };
#endif

    LONG        lResult = 0;
    PDRVLINE    pLine = (PDRVLINE) hdLine;


    Prolog (&info);

    lpAddressStatus->dwNeededSize =
    lpAddressStatus->dwUsedSize   = sizeof(LINEADDRESSSTATUS);

    lpAddressStatus->dwNumActiveCalls  = (pLine->htCall ? 1 : 0);
    lpAddressStatus->dwAddressFeatures = LINEADDRFEATURE_MAKECALL;

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL            hdCall,
    LPDWORD             lpdwAddressID
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdCall,        hdCall          },
        { "lpdwAddressID",  lpdwAddressID   }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetCallAddressID",
        2,
        params
    };
#endif


    //
    // We only support 1 address (id=0)
    //

    Prolog (&info);
    *lpdwAddressID = 0;
    return (Epilog (&info, 0));
}


LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpLineInfo
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdCall,     hdCall      },
        { "lpLineInfo", lpLineInfo  }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetCallInfo",
        2,
        params
    };
#endif
    LONG        lResult = 0;
    PDRVLINE    pLine = (PDRVLINE) hdCall;


    Prolog (&info);

    lpLineInfo->dwNeededSize =
    lpLineInfo->dwUsedSize   = sizeof(LINECALLINFO);

    lpLineInfo->dwBearerMode         = LINEBEARERMODE_VOICE;
    lpLineInfo->dwMediaMode          = pLine->dwMediaMode;
    lpLineInfo->dwCallStates         = LINECALLSTATE_IDLE |
                                       LINECALLSTATE_DIALTONE |
                                       LINECALLSTATE_DIALING |
                                       LINECALLSTATE_CONNECTED |
                                       LINECALLSTATE_PROCEEDING |
                                       LINECALLSTATE_DISCONNECTED |
                                       LINECALLSTATE_UNKNOWN;
    lpLineInfo->dwOrigin             = LINECALLORIGIN_OUTBOUND;
    lpLineInfo->dwReason             = LINECALLREASON_DIRECT;
    lpLineInfo->dwCallerIDFlags      =
    lpLineInfo->dwCalledIDFlags      =
    lpLineInfo->dwConnectedIDFlags   =
    lpLineInfo->dwRedirectionIDFlags =
    lpLineInfo->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpLineStatus
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdCall,         hdCall          },
        { "lpLineStatus",   lpLineStatus    }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetCallStatus",
        2,
        params
    };
#endif
    LONG        lResult = 0;
    PDRVLINE    pLine = (PDRVLINE) hdCall;


    Prolog (&info);

    lpLineStatus->dwNeededSize =
    lpLineStatus->dwUsedSize   = sizeof(LINECALLSTATUS);

    lpLineStatus->dwCallState  = pLine->dwCallState;

    if (pLine->dwCallState != LINECALLSTATE_IDLE)
    {
        lpLineStatus->dwCallFeatures = LINECALLFEATURE_DROP;
    }

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwExtVersion",   dwExtVersion    },
        { "lpLineDevCaps",  lpLineDevCaps   }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetDevCaps",
        4,
        params
    };
#endif

    LONG            lResult = 0;
    static WCHAR    szProviderInfo[] = L"AT-compatible modem service provider";

    #define PROVIDER_INFO_SIZE (37 * sizeof (WCHAR))

    Prolog (&info);

    lpLineDevCaps->dwNeededSize = sizeof (LINEDEVCAPS) + PROVIDER_INFO_SIZE +
        (MAX_DEV_NAME_LENGTH + 1) * sizeof (WCHAR);

    if (lpLineDevCaps->dwTotalSize >= lpLineDevCaps->dwNeededSize)
    {
        #define LINECONFIG_SIZE   (2 * (MAX_DEV_NAME_LENGTH + 1) + 40)

        char    szLineConfig[LINECONFIG_SIZE], szLineN[16], *p;
        HKEY    hKey;
        DWORD   dwDataSize, dwDataType;


        lpLineDevCaps->dwUsedSize = lpLineDevCaps->dwNeededSize;

        lpLineDevCaps->dwProviderInfoSize   = PROVIDER_INFO_SIZE;
        lpLineDevCaps->dwProviderInfoOffset = sizeof(LINEDEVCAPS);

        My_lstrcpyW ((WCHAR *)(lpLineDevCaps + 1), szProviderInfo);

        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszAtspKey,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );

        dwDataSize = LINECONFIG_SIZE;
        wsprintf (szLineN, "Line%d", dwDeviceID - gdwLineDeviceIDBase);
        lstrcpy (szLineConfig, gszDefLineConfigParams);

        RegQueryValueEx(
            hKey,
            szLineN,
            0,
            &dwDataType,
            (LPBYTE) szLineConfig,
            &dwDataSize
            );

        RegCloseKey (hKey);

        for (p = szLineConfig; *p != ','; p++);
        *p = 0;

        lpLineDevCaps->dwLineNameSize   = (lstrlen (szLineConfig) + 1) *
            sizeof (WCHAR);
        lpLineDevCaps->dwLineNameOffset = sizeof(LINEDEVCAPS) +
            PROVIDER_INFO_SIZE;

        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            szLineConfig,
            -1,
            (WCHAR *) ((LPBYTE) (lpLineDevCaps + 1) + PROVIDER_INFO_SIZE),
            lpLineDevCaps->dwLineNameSize
            );
    }
    else
    {
        lpLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS);
    }

    lpLineDevCaps->dwStringFormat      = STRINGFORMAT_ASCII;
    lpLineDevCaps->dwAddressModes      = LINEADDRESSMODE_ADDRESSID;
    lpLineDevCaps->dwNumAddresses      = 1;
    lpLineDevCaps->dwBearerModes       = LINEBEARERMODE_VOICE;
    lpLineDevCaps->dwMaxRate           = 9600;
    lpLineDevCaps->dwMediaModes        = LINEMEDIAMODE_INTERACTIVEVOICE |
                                         LINEMEDIAMODE_DATAMODEM;
    lpLineDevCaps->dwDevCapFlags       = LINEDEVCAPFLAGS_CLOSEDROP |
                                         LINEDEVCAPFLAGS_DIALBILLING |
                                         LINEDEVCAPFLAGS_DIALQUIET |
                                         LINEDEVCAPFLAGS_DIALDIALTONE;
    lpLineDevCaps->dwMaxNumActiveCalls = 1;
    lpLineDevCaps->dwRingModes         = 1;
    lpLineDevCaps->dwLineFeatures      = LINEFEATURE_MAKECALL;

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine,             hdLine          },
        { "dwAddressID",        dwAddressID     },
        { gszhdCall,             hdCall          },
        { "dwSelect",           dwSelect        },
        { "lpDeviceID",         lpDeviceID      },
        { "lpszDeviceClass",    lpszDeviceClass },
        { "hTargetProcess",     hTargetProcess  }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetID",
        7,
        params
    };
#endif

    DWORD       dwNeededSize = sizeof(VARSTRING) + sizeof (DWORD);
    LONG        lResult = 0;
    PDRVLINE    pLine = (dwSelect == LINECALLSELECT_CALL ?
                    (PDRVLINE) hdCall : (PDRVLINE) hdLine);


    Prolog (&info);

    if (lstrcmpiW (lpszDeviceClass, L"tapi/line") == 0)
    {
        if (lpDeviceID->dwTotalSize < dwNeededSize)
        {
            lpDeviceID->dwUsedSize = 3*sizeof(DWORD);
        }
        else
        {
            lpDeviceID->dwUsedSize = dwNeededSize;

            lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
            lpDeviceID->dwStringSize   = sizeof(DWORD);
            lpDeviceID->dwStringOffset = sizeof(VARSTRING);

            *((LPDWORD)(lpDeviceID + 1)) = pLine->dwDeviceID;
        }

        lpDeviceID->dwNeededSize = dwNeededSize;
    }
    else if (lstrcmpiW (lpszDeviceClass, L"comm/datamodem") == 0)
    {
        dwNeededSize += (strlen (pLine->szComm) + 1) * sizeof (WCHAR);

        if (lpDeviceID->dwTotalSize < dwNeededSize)
        {
            lpDeviceID->dwUsedSize = 3 * sizeof(DWORD);
        }
        else
        {
            HANDLE hCommDup = NULL;


            if (!pLine->htCall)
            {
                DBGOUT((1, "TSPI_lineGetID32: error, no active call"));

                lResult = LINEERR_OPERATIONFAILED;

                goto TSPI_lineGetID_epilog;
            }

            if (!DuplicateHandle(
                    GetCurrentProcess(),
                    pLine->hComm,
                    hTargetProcess,
                    &hCommDup,
                    0,
                    TRUE,
                    DUPLICATE_SAME_ACCESS
                    ))
            {
                DBGOUT((
                    1,
                    "TSPI_lineGetID: DupHandle failed, err=%ld",
                    GetLastError()
                    ));

                lResult = LINEERR_OPERATIONFAILED;

                goto TSPI_lineGetID_epilog;
            }

            lpDeviceID->dwUsedSize = dwNeededSize;

            lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
            lpDeviceID->dwStringSize   = dwNeededSize - sizeof(VARSTRING);
            lpDeviceID->dwStringOffset = sizeof(VARSTRING);

            *((HANDLE *)(lpDeviceID + 1)) = hCommDup;

            lstrcpy(
                ((char *)(lpDeviceID + 1)) + sizeof (HANDLE),
                pLine->szComm
                );

            MultiByteToWideChar(
                CP_ACP,
                0,
                pLine->szComm,
                -1,
                ((WCHAR *)(lpDeviceID + 1)) + sizeof (HANDLE),
                256
                );
        }

        lpDeviceID->dwNeededSize = dwNeededSize;
    }
    else
    {
        lResult = LINEERR_NODEVICE;
    }

TSPI_lineGetID_epilog:

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine,            hdLine          },
        { "lpLineDevStatus",    lpLineDevStatus }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetLineDevStatus",
        2,
        params
    };
#endif

    LONG        lResult = 0;
    PDRVLINE    pLine = (PDRVLINE) hdLine;


    Prolog (&info);

    lpLineDevStatus->dwUsedSize =
    lpLineDevStatus->dwNeededSize = sizeof (LINEDEVSTATUS);

    lpLineDevStatus->dwNumActiveCalls = (pLine->htCall ? 1 : 0);
    //lpLineDevStatus->dwLineFeatures =
    lpLineDevStatus->dwDevStatusFlags = LINEDEVSTATUSFLAGS_CONNECTED |
                                        LINEDEVSTATUSFLAGS_INSERVICE;
    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine,            hdLine            },
        { "lpdwNumAddressIDs",  lpdwNumAddressIDs }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineGetNumAddressIDs",
        2,
        params
    };
#endif

    LONG        lResult = 0;
    PDRVLINE    pLine = (PDRVLINE) hdLine;


    //
    // We only support 1 address (id=0)
    //

    Prolog (&info);
    *lpdwNumAddressIDs = 1;
    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    char        szCommands[64], szCommand[64], szDestAddress[128];
    DWORD       dwThreadID, dwNumBytes, dwError;
    PDRVLINE    pLine = (PDRVLINE) hdLine;
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszdwRequestID,       dwRequestID     },
        { gszhdLine,            hdLine          },
        { "htCall",             htCall          },
        { "lphdCall",           lphdCall        },
        { "lpszDestAddress",    szDestAddress   },
        { "dwCountryCode",      dwCountryCode   },
        { gszlpCallParams,      lpCallParams    }
    };
    FUNC_INFO info =
    {
        "TSPI_lineMakeCall",
        7,
        params
    };
#endif


    if (lpszDestAddress)
    {
        WideCharToMultiByte(
            CP_ACP,
            0,
            lpszDestAddress,
            -1,
            (LPSTR) szDestAddress,
            128,
            NULL,
            NULL
            );
    }

    Prolog (&info);


    //
    // Check to see if there's already another call
    //

    if (pLine->htCall)
    {
        (*gpfnCompletionProc)(dwRequestID, LINEERR_CALLUNAVAIL);
        goto TSPI_lineMakeCall_return;
    }


    //
    // Since we don't support TSPI_lineDial, fail if app tries
    // to pass a NULL lpszDestAddress (implying that app just
    // wants to go offhook)
    //

    if (lpszDestAddress == NULL)
    {
        (*gpfnCompletionProc)(dwRequestID, LINEERR_INVALADDRESS);
        goto TSPI_lineMakeCall_return;
    }


    //
    // Get the line's config info
    //

    {
        HKEY    hKey;
        DWORD   dwDataSize, dwDataType;
        char    szLineN[8], *pszConfig, *p, *p2;


        wsprintf(
            szLineN,
            "Line%d",
            ((PDRVLINE) hdLine)->dwDeviceID - gdwLineDeviceIDBase
            );

        dwDataSize = 256;

        pszConfig = DrvAlloc (dwDataSize);

        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszAtspKey,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );

        RegQueryValueEx(
            hKey,
            szLineN,
            0,
            &dwDataType,
            (LPBYTE) pszConfig,
            &dwDataSize
            );

        pszConfig[dwDataSize] = '\0';       // *pszConfig = "MyLine,COM1,L0"

        RegCloseKey (hKey);


        //
        // szComm
        //

        for (p = pszConfig; *p != ','; p++);
        p++;                                // *p = "COM1,L0"
        for (p2 = p; *p2 != ','; p2++);
        *p2 = 0;                            // *p = "COM1"

        lstrcpy (pLine->szComm, p);


        //
        // szCommands
        //

        p2++;                               // *p2 = "L0"
        lstrcpy (szCommands, p2);

        DrvFree (pszConfig);
    }


    //
    // Open the port
    //

    if ((pLine->hComm = CreateFile(
            pLine->szComm,
            GENERIC_READ | GENERIC_WRITE,
            0, //FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, // no security attrs
            OPEN_EXISTING,
            FILE_FLAG_OVERLAPPED,
            NULL  // no template file

            )) == INVALID_HANDLE_VALUE)
    {
        DBGOUT((
            3,
            "TSPI_lineMakeCall: CreateFile(%s) failed, err=%ld",
            pLine->szComm,
            GetLastError()
            ));

        (*gpfnCompletionProc)(dwRequestID, LINEERR_RESOURCEUNAVAIL);
        goto TSPI_lineMakeCall_return;
    }


    //
    // Setup up the modem command string.  If there's an initial 'T'
    // or 'P' (for Tone or Pulse) in the dest address then disregard
    // it.  Also if it's a voice call add the semi colon so we return
    // to cmd mode.
    //

    {
        char *p = (char *) szDestAddress;


        if (*p == 'T'  ||  *p == 'P')
        {
            p++;
        }

        if (lpCallParams &&
            lpCallParams->dwMediaMode != LINEMEDIAMODE_INTERACTIVEVOICE)
        {
            wsprintf (szCommand, "AT%sDT%s\r", szCommands, p);
        }
        else
        {
            wsprintf (szCommand, "AT%sDT%s;\r", szCommands, p);
        }
    }


    //
    // Init the data structure & tell tapi our handle to the call
    //

    pLine->htCall          = htCall;
    pLine->bDropInProgress = FALSE;
    pLine->dwMediaMode     = (lpCallParams ? lpCallParams->dwMediaMode :
        LINEMEDIAMODE_INTERACTIVEVOICE);

    *lphdCall = (HDRVCALL) pLine;


    //
    // Do an overlapped write, the comm thread will deal with the results
    //

    pLine->Overlapped.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

    if (!WriteFile(
            pLine->hComm,
            szCommand,
            lstrlen (szCommand),
            &dwNumBytes,
            &pLine->Overlapped
            )

        && (dwError = GetLastError()) != ERROR_IO_PENDING)
    {
        DBGOUT((
            1,
            "TSPI_lineMakeCall: WriteFile(%s) failed, error=%d",
            pLine->szComm,
            dwError
            ));

        pLine->htCall = NULL;
        CloseHandle (pLine->hComm);
        CloseHandle (pLine->Overlapped.hEvent);
        (*gpfnCompletionProc)(dwRequestID, LINEERR_OPERATIONFAILED);
        goto TSPI_lineMakeCall_return;
    }


    //
    // Complete the requests & set the initial call state
    //

    (*gpfnCompletionProc)(dwRequestID, 0);
    SetCallState (pLine, LINECALLSTATE_DIALING, 0);


    //
    // Spin the comm thread to handle the results of the Write above
    //

    {
        HANDLE hCommThread;


        if (!(hCommThread = CreateThread(
                (LPSECURITY_ATTRIBUTES) NULL,
                0,
                (LPTHREAD_START_ROUTINE) CommThread,
                pLine,
                0,
                &dwThreadID
                )))
        {
            DBGOUT((
                1,
                "TSPI_lineMakeCall: CreateThread failed, err=%ld",
                GetLastError()
                ));

            GetOverlappedResult(
                pLine->hComm,
                &pLine->Overlapped,
                &dwNumBytes,
                TRUE
                );

            SetCallState (pLine, LINECALLSTATE_IDLE, 0);
            CloseHandle (pLine->hComm);
            CloseHandle (pLine->Overlapped.hEvent);
            goto TSPI_lineMakeCall_return;
        }

        CloseHandle (hCommThread);
    }


TSPI_lineMakeCall_return:

    return (Epilog (&info, dwRequestID));
}


LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszdwDeviceID,        dwDeviceID      },
        { "dwLowVersion",       dwLowVersion    },
        { "dwHighVersion",      dwHighVersion   },
        { "lpdwTSPIVersion",    lpdwTSPIVersion }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineNegotiateTSPIVersion",
        4,
        params
    };
#endif

    Prolog (&info);
    *lpdwTSPIVersion = 0x00020000;
    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
    )
{
    LONG        lResult;
    PDRVLINE    pLine;
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszdwDeviceID,    dwDeviceID      },
        { "htLine",         htLine          },
        { "lphdLine",       lphdLine        },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "lpfnEventProc",  lpfnEventProc   }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineOpen",
        5,
        params
    };
#endif


    Prolog (&info);

    if ((pLine = DrvAlloc (sizeof (DRVLINE))))
    {
        pLine->htLine       = htLine;
        pLine->pfnEventProc = lpfnEventProc;
        pLine->dwDeviceID   = dwDeviceID;

        *lphdLine = (HDRVLINE) pLine;

        lResult = 0;
    }
    else
    {
        lResult = LINEERR_NOMEM;
    }

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
#if DBG
    FUNC_PARAM  params[] =
    {
        { gszhdLine,        hdLine       },
        { "dwMediaModes",   dwMediaModes }
    };
    FUNC_INFO   info =
    {
        "TSPI_lineSetDefaultMediaDetection",
        2,
        params
    };
#endif


    //
    // This func is really a no-op for us, since we don't look
    // for incoming calls (though we do say we support them to
    // make apps happy)
    //

    Prolog (&info);
    return (Epilog (&info, 0));
}


//
// ------------------------- TSPI_providerXxx funcs ---------------------------
//

LONG
TSPIAPI
TSPI_providerConfig(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can configure this provider via lineConfigProvider(),
    // otherwise Telephon.cpl will not consider it configurable
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerGenericDialogData(
    ULONG_PTR           dwObjectID,
    DWORD               dwObjectType,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { "dwObjectID",     dwObjectID      },
        { "dwObjectType",   dwObjectType    },
        { "lpParams",       lpParams        },
        { "dwSize",         dwSize          }
    };
    FUNC_INFO   info =
    {
        "TSPI_providerGenericDialogData",
        4,
        params
    };
#endif


    Prolog (&info);
    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { "dwTSPIVersion",          dwTSPIVersion           },
        { gszdwPermanentProviderID, dwPermanentProviderID   },
        { "dwLineDeviceIDBase",     dwLineDeviceIDBase      },
        { "dwPhoneDeviceIDBase",    dwPhoneDeviceIDBase     },
        { "dwNumLines",             dwNumLines              },
        { "dwNumPhones",            dwNumPhones             },
        { "lpfnCompletionProc",     lpfnCompletionProc      }
    };
    FUNC_INFO   info =
    {
        "TSPI_providerInit",
        7,
        params
    };
#endif

    Prolog (&info);
    gdwLineDeviceIDBase = dwLineDeviceIDBase;
    gpfnCompletionProc  = lpfnCompletionProc;
    *lpdwTSPIOptions = LINETSPIOPTION_NONREENTRANT;
    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can add this provider via lineAddProvider(), otherwise
    // Telephon.cpl will not consider it installable
    //
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can remove this provider via lineRemoveProvider(), otherwise
    // Telephon.cpl will not consider it removable
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { "dwTSPIVersion",          dwTSPIVersion },
        { gszdwPermanentProviderID, dwPermanentProviderID   }
    };
    FUNC_INFO   info =
    {
        "TSPI_providerShutdown",
        2,
        params
    };
#endif


    Prolog (&info);

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
   HKEY     hKey;
   DWORD    dwNumLines, dwDataType, dwDataSize;


   //
   // Retrieve the number of devices we're
   // configured for from our registry section
   //

   if (ERROR_SUCCESS !=
       RegOpenKeyEx(
       HKEY_LOCAL_MACHINE,
       gszAtspKey,
       0,
       KEY_ALL_ACCESS,
       &hKey
       ))
   {
       return LINEERR_OPERATIONFAILED;
   }

   dwDataSize = sizeof(dwNumLines);
   dwNumLines = 0;

   RegQueryValueEx(
       hKey,
       gszNumLines,
       0,
       &dwDataType,
       (LPBYTE) &dwNumLines,
       &dwDataSize
       );

   RegCloseKey (hKey);

   *lpdwNumLines  = dwNumLines;
   *lpdwNumPhones = 0;
   return 0;
}


LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { "lpsUIDLLName",  lpszUIDLLName }
    };
    FUNC_INFO   info =
    {
        "TSPI_providerUIIdentify",
        1,
        params
    };
#endif


    Prolog (&info);
    My_lstrcpyW(lpszUIDLLName, L"atsp32.tsp");
    return (Epilog (&info, lResult));
}


//
// ---------------------------- TUISPI_xxx funcs ------------------------------
//

LONG
TSPIAPI
TUISPI_lineConfigDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
    char        szDeviceClass[128];
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { "lpfnUIDLLCallback",   lpfnUIDLLCallback },
        { gszdwDeviceID,         dwDeviceID        },
        { gszhwndOwner,          hwndOwner         },
        { "lpszDeviceClass",     szDeviceClass     }
    };
    FUNC_INFO   info =
    {
        "TUISPI_lineConfigDialog",
        4,
        params
    };
#endif


    if (lpszDeviceClass)
    {
        WideCharToMultiByte(
            CP_ACP,
            0,
            lpszDeviceClass,
            -1,
            (LPSTR) szDeviceClass,
            128,
            NULL,
            NULL
            );
    }

    Prolog (&info);

    DialogBoxParam(
        ghInst,
        MAKEINTRESOURCE(IDD_DIALOG1),
        hwndOwner,
        ConfigDlgProc,
        0
        );

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LONG        lResult = 0;
#if DBG
    FUNC_PARAM  params[] =
    {
        { "lpfnUIDLLCallback",      lpfnUIDLLCallback },
        { gszhwndOwner,             hwndOwner    },
        { gszdwPermanentProviderID, dwPermanentProviderID   }
    };
    FUNC_INFO   info =
    {
        "TUISPI_providerConfig",
        3,
        params
    };
#endif


    Prolog (&info);

    DialogBoxParam(
        ghInst,
        MAKEINTRESOURCE(IDD_DIALOG1),
        hwndOwner,
        ConfigDlgProc,
        0
        );

    return (Epilog (&info, lResult));
}


LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LONG    lResult;


    if ((lResult = ProviderInstall ("atsp32.tsp", TRUE)) == 0)
    {
        DialogBoxParam(
            ghInst,
            MAKEINTRESOURCE(IDD_DIALOG1),
            hwndOwner,
            ConfigDlgProc,
            0
            );
    }

    return lResult;
}


LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    HKEY    hKey;
    char    szSoftwareMsft[] = "Software\\Microsoft", szATSP[] = "ATSP";
	LONG	lResult;	

    //
    // Clean up our registry section
    //

    lResult = RegOpenKeyExA(
					HKEY_LOCAL_MACHINE,
					szSoftwareMsft,
					0,
					KEY_ALL_ACCESS,
					&hKey
					);

	if (ERROR_SUCCESS != lResult)
		return 0;

    RegDeleteKeyA (hKey, szATSP);
    RegCloseKey (hKey);
    return 0;
}


#pragma warning (default:4047)


//
// ---------------------- Misc private support routines -----------------------
//

LPWSTR
PASCAL
My_lstrcpyW(
    WCHAR   *pString1,
    WCHAR   *pString2
    )
{
    WCHAR *p = pString1;


    for (; (*p = *pString2); p++, pString2++);
    return pString1;
}


void
PASCAL
EnableChildren(
    HWND    hwnd,
    BOOL    bEnable
    )
{
    int i;
    static int aiControlIDs[] =
    {
        IDC_DEVICES,
        IDC_NAME,
        IDC_PORT,
        IDC_COMMANDS,
        IDC_REMOVE,
        0
    };


    for (i = 0; aiControlIDs[i]; i++)
    {
        EnableWindow (GetDlgItem (hwnd, aiControlIDs[i]), bEnable);
    }
}


void
PASCAL
SelectDevice(
    HWND    hwnd,
    LRESULT lDevice
    )
{
    SendDlgItemMessage (hwnd, IDC_DEVICES, LB_SETCURSEL, lDevice, 0);
    PostMessage(hwnd, WM_COMMAND, IDC_DEVICES | (LBN_SELCHANGE << 16), 0);
}


INT_PTR
CALLBACK
ConfigDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static  HKEY    hAtspKey;

    DWORD   dwDataSize;
    DWORD   dwDataType;


    switch (msg)
    {
    case WM_INITDIALOG:
    {
        char   *pBuf;
        DWORD   i, iNumLines;


        //
        // Create or open our configuration key in the registry.  If the
        // create fails it may well be that the current user does not
        // have write access to this portion of the registry, so we'll
        // just show a "read only" dialog and not allow user to make any
        // changes
        //

        {
            LONG    lResult;
            DWORD   dwDisposition;


            if ((lResult = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszAtspKey,
                    0,
                    "",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    (LPSECURITY_ATTRIBUTES) NULL,
                    &hAtspKey,
                    &dwDisposition

                    )) != ERROR_SUCCESS)
            {
                DBGOUT((
                    3,
                    "RegCreateKeyEx(%s,ALL_ACCESS) failed, err=%d",
                    gszAtspKey,
                    lResult
                    ));

                if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        gszAtspKey,
                        0,
                        KEY_QUERY_VALUE,
                        &hAtspKey

                        )) != ERROR_SUCCESS)
                {
                    DBGOUT((
                        3,
                        "RegOpenKeyEx(%s,ALL_ACCESS) failed, err=%d",
                        gszAtspKey,
                        lResult
                        ));

                    EndDialog (hwnd, 0);
                    return FALSE;
                }

                {
                    int i;
                    static int aiControlIDs[] =
                    {
                        IDC_NAME,
                        IDC_PORT,
                        IDC_COMMANDS,
                        IDC_ADD,
                        IDC_REMOVE,
                        IDOK,
                        0
                    };


                    for (i = 0; aiControlIDs[i]; i++)
                    {
                        EnableWindow(
                            GetDlgItem (hwnd, aiControlIDs[i]),
                            FALSE
                            );
                    }
                }
            }
        }


        //
        // Retrieve our configuration info from the registry
        //

        dwDataSize = sizeof(iNumLines);
        iNumLines = 0;

        RegQueryValueEx(
            hAtspKey,
            gszNumLines,
            0,
            &dwDataType,
            (LPBYTE) &iNumLines,
            &dwDataSize
            );

        SendDlgItemMessage(
            hwnd,
            IDC_NAME,
            EM_LIMITTEXT,
            MAX_DEV_NAME_LENGTH,
            0
            );

        SendDlgItemMessage(
            hwnd,
            IDC_COMMANDS,
            EM_LIMITTEXT,
            MAX_DEV_NAME_LENGTH,
            0
            );

        pBuf = DrvAlloc (256);

        for (i = 0; i < iNumLines; i++)
        {
            char           *p, *p2, szLineN[8];
            PDRVLINECONFIG  pLineConfig = DrvAlloc (sizeof(DRVLINECONFIG));
            LONG            lResult;


            wsprintf (szLineN, "Line%d", i);

            dwDataSize = 256;

            lResult = RegQueryValueEx(
                hAtspKey,
                szLineN,
                0,
                &dwDataType,
                (LPBYTE) pBuf,
                &dwDataSize
                );


            //
            // If there was a problem, use the default config
            //

            if (0 != lResult)
            {
               lstrcpy (pBuf, gszDefLineConfigParams);
            }

            for (p = pBuf; *p != ','; p++);
            *p = 0;

            SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_ADDSTRING,
                0,
                (LPARAM) pBuf
                );

            SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_SETITEMDATA,
                i,
                (LPARAM) pLineConfig
                );

            p++;
            for (p2 = p; *p2 != ','; p2++);
            *p2 = 0;

            lstrcpy (pLineConfig->szPort, p);

            p = p2 + 1;

            lstrcpy (pLineConfig->szCommands, p);
        }

        DrvFree (pBuf);


        //
        // Fill up the various controls with configuration options
        //

        {
            static char *aszPorts[] = { "COM1","COM2","COM3",NULL };

            for (i = 0; aszPorts[i]; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_PORT,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) aszPorts[i]
                    );
            }
        }

        if (iNumLines == 0)
        {
            EnableChildren (hwnd, FALSE);
        }
        else
        {
            SelectDevice (hwnd, 0);
        }

        break;
    }
    case WM_COMMAND:
    {
        LRESULT         lSelection;
        PDRVLINECONFIG  pLineConfig;


        lSelection = SendDlgItemMessage(
            hwnd,
            IDC_DEVICES,
            LB_GETCURSEL,
            0,
            0
            );

        pLineConfig = (PDRVLINECONFIG) SendDlgItemMessage(
            hwnd,
            IDC_DEVICES,
            LB_GETITEMDATA,
            (WPARAM) lSelection,
            0
            );

        switch (LOWORD((DWORD)wParam))
        {
        case IDC_DEVICES:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                char buf[MAX_DEV_NAME_LENGTH + 1];


                SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_GETTEXT,
                    lSelection,
                    (LPARAM) buf
                    );

                SetDlgItemText (hwnd, IDC_NAME, buf);

                SendDlgItemMessage(
                    hwnd,
                    IDC_PORT,
                    LB_SELECTSTRING,
                    (WPARAM) -1,
                    (LPARAM) pLineConfig->szPort
                    );

                SetDlgItemText (hwnd, IDC_COMMANDS, pLineConfig->szCommands);
            }

            break;

        case IDC_NAME:

            if ((HIWORD(wParam) == EN_CHANGE) && (lSelection != LB_ERR))
            {
                char    buf[MAX_DEV_NAME_LENGTH + 1];


                GetDlgItemText (hwnd, IDC_NAME, buf, MAX_DEV_NAME_LENGTH);

                SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_DELETESTRING,
                    lSelection,
                    0
                    );

                SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_INSERTSTRING,
                    lSelection,
                    (LPARAM) buf
                    );

                SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_SETCURSEL,
                    lSelection,
                    0
                    );

                SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_SETITEMDATA,
                    lSelection,
                    (LPARAM) pLineConfig
                    );
            }

            break;

        case IDC_PORT:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                lSelection = SendDlgItemMessage(
                    hwnd,
                    IDC_PORT,
                    LB_GETCURSEL,
                    0,
                    0
                    );

                SendDlgItemMessage(
                    hwnd,
                    IDC_PORT,
                    LB_GETTEXT,
                    lSelection,
                    (LPARAM) pLineConfig->szPort
                    );
            }

            break;

        case IDC_COMMANDS:

            if ((HIWORD(wParam) == EN_CHANGE) && (lSelection != LB_ERR))
            {
                GetDlgItemText(
                    hwnd,
                    IDC_COMMANDS,
                    pLineConfig->szCommands,
                    63
                    );
            }

            break;

        case IDC_ADD:
        {
            LRESULT         lNumLines, l = 2;
            char            szLineName[32];
            PDRVLINECONFIG  pLineConfig = DrvAlloc (sizeof(DRVLINECONFIG));


            lNumLines = SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_GETCOUNT,
                0,
                0
                );

            lstrcpy (pLineConfig->szPort, "COM1");

            lstrcpy (szLineName, "my new line");

find_unique_line_name:

            if (SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_FINDSTRING,
                    (WPARAM) -1,
                    (LPARAM) szLineName

                    ) != LB_ERR)
            {
                wsprintf (szLineName, "my new line%d", l++);
                goto find_unique_line_name;
            }

            SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_ADDSTRING,
                0,
                (LPARAM) szLineName
                );

            SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_SETITEMDATA,
                lNumLines,
                (LPARAM) pLineConfig
                );

            EnableChildren (hwnd, TRUE);

            SelectDevice (hwnd, lNumLines);

            SetFocus (GetDlgItem (hwnd, IDC_NAME));

            SendDlgItemMessage(
                hwnd,
                IDC_NAME,
                EM_SETSEL,
                0,
                (LPARAM) -1
                );

            break;
        }
        case IDC_REMOVE:
        {
            LRESULT lNumLines;


            DrvFree (pLineConfig);

            lNumLines = SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_DELETESTRING,
                lSelection,
                0
                );

            if (lNumLines == 0)
            {
                SetDlgItemText (hwnd, IDC_NAME, "");
                SetDlgItemText (hwnd, IDC_COMMANDS, "");

                EnableChildren (hwnd, FALSE);
            }
            else
            {
                SelectDevice (hwnd, 0);
            }

            break;
        }
        case IDOK:
        {
            char   *pBuf;
            LRESULT l, lNumLines;


            //
            // Update the num lines & num phones values
            //

            pBuf = DrvAlloc (256);

            lNumLines = SendDlgItemMessage(
                hwnd,
                IDC_DEVICES,
                LB_GETCOUNT,
                0,
                0
                );

            RegSetValueEx(
                hAtspKey,
                gszNumLines,
                0,
                REG_DWORD,
                (LPBYTE) &lNumLines,
                sizeof(DWORD)
                );


            //
            // For each installed device save it's config info
            //

            for (l = 0; l < lNumLines; l++)
            {
                char szLineN[8];
                PDRVLINECONFIG pLineConfig;


                SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_GETTEXT,
                    l,
                    (LPARAM) pBuf
                    );

                pLineConfig = (PDRVLINECONFIG) SendDlgItemMessage(
                    hwnd,
                    IDC_DEVICES,
                    LB_GETITEMDATA,
                    l,
                    0
                    );

                wsprintf(
                    pBuf + strlen (pBuf),
                    ",%s,%s",
                    pLineConfig->szPort,
                    pLineConfig->szCommands
                    );

                wsprintf (szLineN, "Line%d", l);

                RegSetValueEx(
                    hAtspKey,
                    szLineN,
                    0,
                    REG_SZ,
                    (LPBYTE) pBuf,
                    lstrlen (pBuf) + 1
                    );

                DrvFree (pLineConfig);
            }

            DrvFree (pBuf);

            // fall thru to EndDialog...
        }
        case IDCANCEL:

            RegCloseKey (hAtspKey);
            EndDialog (hwnd, 0);
            break;

        } // switch (LOWORD((DWORD)wParam))

        break;
    }
    } // switch (msg)

    return FALSE;
}


LPVOID
PASCAL
DrvAlloc(
    DWORD dwSize
    )
{
    return (LocalAlloc (LPTR, dwSize));
}


VOID
PASCAL
DrvFree(
    LPVOID lp
    )
{
    LocalFree (lp);
}


void
PASCAL
SetCallState(
    PDRVLINE    pLine,
    DWORD       dwCallState,
    DWORD       dwCallStateMode
    )
{
    if (dwCallState != pLine->dwCallState)
    {
        pLine->dwCallState     = dwCallState;
        pLine->dwCallStateMode = dwCallStateMode;

        (*pLine->pfnEventProc)(
            pLine->htLine,
            pLine->htCall,
            LINE_CALLSTATE,
            dwCallState,
            dwCallStateMode,
            pLine->dwMediaMode
            );
    }
}


#if DBG

void
PASCAL
Prolog(
    PFUNC_INFO  pInfo
    )
{
    DWORD i;


    DBGOUT((3, "%s: enter", pInfo->lpszFuncName));

    for (i = 0; i < pInfo->dwNumParams; i++)
    {
        if (pInfo->aParams[i].dwVal &&
            pInfo->aParams[i].lpszVal[3] == 'z') // lpszVal = "lpsz..."
        {
            DBGOUT((
                3,
                "%s%s=x%lx, '%s'",
                gszTab,
                pInfo->aParams[i].lpszVal,
                pInfo->aParams[i].dwVal,
                pInfo->aParams[i].dwVal
                ));
        }
        else
        {
            DBGOUT((
                3,
                "%s%s=x%lx",
                gszTab,
                pInfo->aParams[i].lpszVal,
                pInfo->aParams[i].dwVal
                ));
        }
    }
}


LONG
PASCAL
Epilog(
    PFUNC_INFO  pInfo,
    LONG        lResult
    )
{
    DBGOUT((3, "%s: returning x%x", pInfo->lpszFuncName, lResult));

    return lResult;
}


void
CDECL
DebugOutput(
    DWORD   dwDbgLevel,
    LPCSTR  lpszFormat,
    ...
    )
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[128] = "ATSP32: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[8], lpszFormat, ap);

        lstrcat (buf, "\n");

        OutputDebugString (buf);

        va_end(ap);
    }
}

#endif


LONG
PASCAL
ProviderInstall(
    char   *pszProviderName,
    BOOL    bNoMultipleInstance
    )
{
    LONG    lResult;


    //
    // If only one installation instance of this provider is
    // allowed then we want to check the provider list to see
    // if the provider is already installed
    //

    if (bNoMultipleInstance)
    {
        LONG                (WINAPI *pfnGetProviderList)();
        DWORD               dwTotalSize, i;
        HINSTANCE           hTapi32;
        LPLINEPROVIDERLIST  pProviderList;
        LPLINEPROVIDERENTRY pProviderEntry;


        //
        // Load Tapi32.dll & get a pointer to the lineGetProviderList
        // func.  We don't want to statically link because this module
        // plays the part of both core SP & UI DLL, and we don't want
        // to incur the performance hit of automatically loading
        // Tapi32.dll when running as a core SP within Tapisrv.exe's
        // context.
        //

        if (!(hTapi32 = LoadLibrary ("tapi32.dll")))
        {
            DBGOUT((
                1,
                "LoadLibrary(tapi32.dll) failed, err=%d",
                GetLastError()
                ));

            lResult = LINEERR_OPERATIONFAILED;
            goto ProviderInstall_return;
        }

        if (!((FARPROC) pfnGetProviderList = GetProcAddress(
                hTapi32,
                (LPCSTR) "lineGetProviderList"
                )))
        {
            DBGOUT((
                1,
                "GetProcAddr(lineGetProviderList) failed, err=%d",
                GetLastError()
                ));

            lResult = LINEERR_OPERATIONFAILED;
            goto ProviderInstall_unloadTapi32;
        }


        //
        // Loop until we get the full provider list
        //

        dwTotalSize = sizeof (LINEPROVIDERLIST);

        goto ProviderInstall_allocProviderList;

ProviderInstall_getProviderList:

        if ((lResult = (*pfnGetProviderList)(0x00020000, pProviderList)) != 0)
        {
            goto ProviderInstall_freeProviderList;
        }

        if (pProviderList->dwNeededSize > pProviderList->dwTotalSize)
        {
            dwTotalSize = pProviderList->dwNeededSize;

            LocalFree (pProviderList);

ProviderInstall_allocProviderList:

            if (!(pProviderList = LocalAlloc (LPTR, dwTotalSize)))
            {
                lResult = LINEERR_NOMEM;
                goto ProviderInstall_unloadTapi32;
            }

            pProviderList->dwTotalSize = dwTotalSize;

            goto ProviderInstall_getProviderList;
        }


        //
        // Inspect the provider list entries to see if this provider
        // is already installed
        //

        pProviderEntry = (LPLINEPROVIDERENTRY) (((LPBYTE) pProviderList) +
            pProviderList->dwProviderListOffset);

        for (i = 0; i < pProviderList->dwNumProviders; i++)
        {
            char   *pszInstalledProviderName = ((char *) pProviderList) +
                        pProviderEntry->dwProviderFilenameOffset,
                   *p;


            //
            // Make sure pszInstalledProviderName points at <filename>
            // and not <path>\filename by walking backeards thru the
            // string searching for last '\\'
            //

            p = pszInstalledProviderName +
                lstrlen (pszInstalledProviderName) - 1;

            for (; *p != '\\'  &&  p != pszInstalledProviderName; p--);

            pszInstalledProviderName =
                (p == pszInstalledProviderName ? p : p + 1);

            if (lstrcmpiA (pszInstalledProviderName, pszProviderName) == 0)
            {
                lResult = LINEERR_NOMULTIPLEINSTANCE;
                goto ProviderInstall_freeProviderList;
            }

            pProviderEntry++;
        }


        //
        // If here then the provider isn't currently installed,
        // so do whatever configuration stuff is necessary and
        // indicate SUCCESS
        //

        lResult = 0;


ProviderInstall_freeProviderList:

        LocalFree (pProviderList);

ProviderInstall_unloadTapi32:

        FreeLibrary (hTapi32);
    }
    else
    {
        //
        // Do whatever configuration stuff is necessary and return SUCCESS
        //

        lResult = 0;
    }

ProviderInstall_return:

    return lResult;
}


void
PASCAL
DropActiveCall(
    PDRVLINE    pLine
    )
{
    if (pLine->hComm)
    {
        DWORD       dwNumBytes, dwError;
        OVERLAPPED  overlapped;


        pLine->bDropInProgress = TRUE;

        SetEvent (pLine->Overlapped.hEvent);

        ZeroMemory (&overlapped, sizeof (OVERLAPPED));

        overlapped.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (pLine->dwMediaMode != LINEMEDIAMODE_INTERACTIVEVOICE)
        {
            if (!WriteFile(
                    pLine->hComm,
                    "+++\r", 4,
                    &dwNumBytes,
                    &overlapped
                    ))
            {
                if ((dwError = GetLastError()) == ERROR_IO_PENDING)
                {
                    GetOverlappedResult(
                        pLine->hComm,
                        &overlapped,
                        &dwNumBytes,
                        TRUE
                        );

                    ResetEvent (overlapped.hEvent);
                }
                else
                {
                }
            }
        }

        if (!WriteFile (pLine->hComm, "ATH\r", 4, &dwNumBytes, &overlapped))
        {
            if ((dwError = GetLastError()) == ERROR_IO_PENDING)
            {
                GetOverlappedResult(
                    pLine->hComm,
                    &overlapped,
                    &dwNumBytes,
                    TRUE
                    );
            }
            else
            {
            }
        }

        CloseHandle (overlapped.hEvent);
        CloseHandle (pLine->hComm);
        pLine->hComm = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\exe\espidl_c_stub.c ===
#include "espidl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\exe\espexe.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    espexe.h

Abstract:



Author:

    Dan Knudson (DanKn)    15-Sep-1995

Revision History:

--*/


#include "windows.h"
#include "tapi.h"
#include "tspi.h"
#include "..\tsp\intrface.h"
#include "resource.h"
#include "espidl.h"


#define MAX_STRING_PARAM_SIZE   32

#define PT_DWORD                1
#define PT_FLAGS                2
#define PT_STRING               3
#define PT_ORDINAL              4

typedef struct _MYWIDGET
{
    DWORD               dwWidgetID;

    DWORD               dwWidgetType;

    ULONG_PTR           hdXxx;

    ULONG_PTR           htXxx;

    DWORD               dwCallState;

    DWORD               dwCallAddressID;

    struct _MYWIDGET   *pPrev;

    struct _MYWIDGET   *pNext;

} MYWIDGET, *PMYWIDGET;


typedef struct _LOOKUP
{
    DWORD               dwVal;

    char far           *pszVal;

} LOOKUP, *PLOOKUP;


typedef struct _PBXSETTING
{
    DWORD               dwNumber;

    LPCSTR              pszEvent;

    DWORD               dwTime;

} PBXSETTING, *PPBXSETTING;


typedef struct _EVENT_PARAM
{
    char far           *szName;

    DWORD               dwType;

    ULONG_PTR           dwValue;

    union
    {
        PLOOKUP         pLookup;

        char far       *buf;

        LPVOID          ptr;

        ULONG_PTR       dwDefValue;

    };

} EVENT_PARAM, far *PEVENT_PARAM;


typedef struct _EVENT_PARAM_HEADER
{
    DWORD               dwNumParams;

    LPSTR               pszDlgTitle;

    DWORD               dwEventType;

    PEVENT_PARAM        aParams;

} EVENT_PARAM_HEADER, far *PEVENT_PARAM_HEADER;



LOOKUP aPBXNumbers[] =
{
    { 0,    "0"     },
    { 1,    "1"     },
    { 2,    "2"     },
    { 5,    "5"     },
    { 10,   "10"    },
    { 20,   "20"    },
    { 50,   "50"    },
    { 100,  "100"   },
    { 200,  "200"   },
    { 500,  "500"   },
    { 1000, "1000"  },
    { 0,    NULL    }
};


LOOKUP aPBXTimes[] =
{
    { 1000,      "second" },
    { 60000,     "minute" },
    { 3600000,   "hour"   },
    { 86400000,  "day"    },
    { 604800000, "week"   },
    { 0,         NULL     }
};


#define NUM_PBXSETTINGS 2


PBXSETTING gPBXSettings[NUM_PBXSETTINGS] =
{
    { 0, "incoming calls", 0 },
    { 0, "disconnections", 0 }
};


LOOKUP aCallStates[] =
{
    { LINECALLSTATE_IDLE               ,"IDLE"               },
    { LINECALLSTATE_OFFERING           ,"OFFERING"           },
    { LINECALLSTATE_ACCEPTED           ,"ACCEPTED"           },
    { LINECALLSTATE_DIALTONE           ,"DIALTONE"           },
    { LINECALLSTATE_DIALING            ,"DIALING"            },
    { LINECALLSTATE_RINGBACK           ,"RINGBACK"           },
    { LINECALLSTATE_BUSY               ,"BUSY"               },
    { LINECALLSTATE_SPECIALINFO        ,"SPECIALINFO"        },
    { LINECALLSTATE_CONNECTED          ,"CONNECTED"          },
    { LINECALLSTATE_PROCEEDING         ,"PROCEEDING"         },
    { LINECALLSTATE_ONHOLD             ,"ONHOLD"             },
    { LINECALLSTATE_CONFERENCED        ,"CONFERENCED"        },
    { LINECALLSTATE_ONHOLDPENDCONF     ,"ONHOLDPENDCONF"     },
    { LINECALLSTATE_ONHOLDPENDTRANSFER ,"ONHOLDPENDTRANSFER" },
    { LINECALLSTATE_DISCONNECTED       ,"DISCONNECTED"       },
    { LINECALLSTATE_UNKNOWN            ,"UNKNOWN"            },
    { 0xffffffff                       ,""                   }
};


LOOKUP aLineErrs[] =
{
    { 0                                ,"<SUCCESS>"              },
    { LINEERR_ALLOCATED                ,"ALLOCATED"              },
    { LINEERR_BADDEVICEID              ,"BADDEVICEID"            },
    { LINEERR_BEARERMODEUNAVAIL        ,"BEARERMODEUNAVAIL"      },
    { LINEERR_CALLUNAVAIL              ,"CALLUNAVAIL"            },
    { LINEERR_COMPLETIONOVERRUN        ,"COMPLETIONOVERRUN"      },
    { LINEERR_CONFERENCEFULL           ,"CONFERENCEFULL"         },
    { LINEERR_DIALBILLING              ,"DIALBILLING"            },
    { LINEERR_DIALDIALTONE             ,"DIALDIALTONE"           },
    { LINEERR_DIALPROMPT               ,"DIALPROMPT"             },
    { LINEERR_DIALQUIET                ,"DIALQUIET"              },
    { LINEERR_INCOMPATIBLEAPIVERSION   ,"INCOMPATIBLEAPIVERSION" },
    { LINEERR_INCOMPATIBLEEXTVERSION   ,"INCOMPATIBLEEXTVERSION" },
    { LINEERR_INIFILECORRUPT           ,"INIFILECORRUPT"         },
    { LINEERR_INUSE                    ,"INUSE"                  },
    { LINEERR_INVALADDRESS             ,"INVALADDRESS"           },
    { LINEERR_INVALADDRESSID           ,"INVALADDRESSID"         },
    { LINEERR_INVALADDRESSMODE         ,"INVALADDRESSMODE"       },
    { LINEERR_INVALADDRESSSTATE        ,"INVALADDRESSSTATE"      },
    { LINEERR_INVALAPPHANDLE           ,"INVALAPPHANDLE"         },
    { LINEERR_INVALAPPNAME             ,"INVALAPPNAME"           },
    { LINEERR_INVALBEARERMODE          ,"INVALBEARERMODE"        },
    { LINEERR_INVALCALLCOMPLMODE       ,"INVALCALLCOMPLMODE"     },
    { LINEERR_INVALCALLHANDLE          ,"INVALCALLHANDLE"        },
    { LINEERR_INVALCALLPARAMS          ,"INVALCALLPARAMS"        },
    { LINEERR_INVALCALLPRIVILEGE       ,"INVALCALLPRIVILEGE"     },
    { LINEERR_INVALCALLSELECT          ,"INVALCALLSELECT"        },
    { LINEERR_INVALCALLSTATE           ,"INVALCALLSTATE"         },
    { LINEERR_INVALCALLSTATELIST       ,"INVALCALLSTATELIST"     },
    { LINEERR_INVALCARD                ,"INVALCARD"              },
    { LINEERR_INVALCOMPLETIONID        ,"INVALCOMPLETIONID"      },
    { LINEERR_INVALCONFCALLHANDLE      ,"INVALCONFCALLHANDLE"    },
    { LINEERR_INVALCONSULTCALLHANDLE   ,"INVALCONSULTCALLHANDLE" },
    { LINEERR_INVALCOUNTRYCODE         ,"INVALCOUNTRYCODE"       },
    { LINEERR_INVALDEVICECLASS         ,"INVALDEVICECLASS"       },
    { LINEERR_INVALDEVICEHANDLE        ,"INVALDEVICEHANDLE"      },
    { LINEERR_INVALDIALPARAMS          ,"INVALDIALPARAMS"        },
    { LINEERR_INVALDIGITLIST           ,"INVALDIGITLIST"         },
    { LINEERR_INVALDIGITMODE           ,"INVALDIGITMODE"         },
    { LINEERR_INVALDIGITS              ,"INVALDIGITS"            },
    { LINEERR_INVALEXTVERSION          ,"INVALEXTVERSION"        },
    { LINEERR_INVALGROUPID             ,"INVALGROUPID"           },
    { LINEERR_INVALLINEHANDLE          ,"INVALLINEHANDLE"        },
    { LINEERR_INVALLINESTATE           ,"INVALLINESTATE"         },
    { LINEERR_INVALLOCATION            ,"INVALLOCATION"          },
    { LINEERR_INVALMEDIALIST           ,"INVALMEDIALIST"         },
    { LINEERR_INVALMEDIAMODE           ,"INVALMEDIAMODE"         },
    { LINEERR_INVALMESSAGEID           ,"INVALMESSAGEID"         },
    { LINEERR_INVALPARAM               ,"INVALPARAM"             },
    { LINEERR_INVALPARKID              ,"INVALPARKID"            },
    { LINEERR_INVALPARKMODE            ,"INVALPARKMODE"          },
    { LINEERR_INVALPOINTER             ,"INVALPOINTER"           },
    { LINEERR_INVALPRIVSELECT          ,"INVALPRIVSELECT"        },
    { LINEERR_INVALRATE                ,"INVALRATE"              },
    { LINEERR_INVALREQUESTMODE         ,"INVALREQUESTMODE"       },
    { LINEERR_INVALTERMINALID          ,"INVALTERMINALID"        },
    { LINEERR_INVALTERMINALMODE        ,"INVALTERMINALMODE"      },
    { LINEERR_INVALTIMEOUT             ,"INVALTIMEOUT"           },
    { LINEERR_INVALTONE                ,"INVALTONE"              },
    { LINEERR_INVALTONELIST            ,"INVALTONELIST"          },
    { LINEERR_INVALTONEMODE            ,"INVALTONEMODE"          },
    { LINEERR_INVALTRANSFERMODE        ,"INVALTRANSFERMODE"      },
    { LINEERR_LINEMAPPERFAILED         ,"LINEMAPPERFAILED"       },
    { LINEERR_NOCONFERENCE             ,"NOCONFERENCE"           },
    { LINEERR_NODEVICE                 ,"NODEVICE"               },
    { LINEERR_NODRIVER                 ,"NODRIVER"               },
    { LINEERR_NOMEM                    ,"NOMEM"                  },
    { LINEERR_NOREQUEST                ,"NOREQUEST"              },
    { LINEERR_NOTOWNER                 ,"NOTOWNER"               },
    { LINEERR_NOTREGISTERED            ,"NOTREGISTERED"          },
    { LINEERR_OPERATIONFAILED          ,"OPERATIONFAILED"        },
    { LINEERR_OPERATIONUNAVAIL         ,"OPERATIONUNAVAIL"       },
    { LINEERR_RATEUNAVAIL              ,"RATEUNAVAIL"            },
    { LINEERR_RESOURCEUNAVAIL          ,"RESOURCEUNAVAIL"        },
    { LINEERR_REQUESTOVERRUN           ,"REQUESTOVERRUN"         },
    { LINEERR_STRUCTURETOOSMALL        ,"STRUCTURETOOSMALL"      },
    { LINEERR_TARGETNOTFOUND           ,"TARGETNOTFOUND"         },
    { LINEERR_TARGETSELF               ,"TARGETSELF"             },
    { LINEERR_UNINITIALIZED            ,"UNINITIALIZED"          },
    { LINEERR_USERUSERINFOTOOBIG       ,"USERUSERINFOTOOBIG"     },
    { LINEERR_REINIT                   ,"REINIT"                 },
    { LINEERR_ADDRESSBLOCKED           ,"ADDRESSBLOCKED"         },
    { LINEERR_BILLINGREJECTED          ,"BILLINGREJECTED"        },
    { LINEERR_INVALFEATURE             ,"INVALFEATURE"           },
    { LINEERR_NOMULTIPLEINSTANCE       ,"NOMULTIPLEINSTANCE"     },
    { 0xffffffff                       ,""                   }
};


LOOKUP aLineMsgs[] =
{
    { LINE_ADDRESSSTATE                ,"ADDRESSSTATE"           },
    { LINE_CALLDEVSPECIFIC             ,"CALLDEVSPECIFIC"        },
    { LINE_CALLDEVSPECIFICFEATURE      ,"CALLDEVSPECIFICFEATURE" },
    { LINE_CREATEDIALOGINSTANCE        ,"CREATEDIALOGINSTANCE"   },
    { LINE_CLOSE                       ,"CLOSE"                  },
    { LINE_DEVSPECIFIC                 ,"DEVSPECIFIC"            },
    { LINE_DEVSPECIFICFEATURE          ,"DEVSPECIFICFEATURE"     },
    { LINE_GATHERDIGITS                ,"GATHERDIGITS"           },
    { LINE_GENERATE                    ,"GENERATE"               },
    { LINE_LINEDEVSTATE                ,"LINEDEVSTATE"           },
    { LINE_MONITORDIGITS               ,"MONITORDIGITS"          },
    { LINE_MONITORMEDIA                ,"MONITORMEDIA"           },
    { LINE_MONITORTONE                 ,"MONITORTONE"            },
    { LINE_CREATE                      ,"CREATE"                 },
    { LINE_REMOVE                      ,"REMOVE"                 },
    { LINE_SENDDIALOGINSTANCEDATA      ,"SENDDIALOGINSTANCEDATA" },
    { 0xffffffff                       ,""                       }
};


LOOKUP aPhoneMsgs[] =
{
    { PHONE_BUTTON                     ,"BUTTON"                 },
    { PHONE_CLOSE                      ,"CLOSE"                  },
    { PHONE_DEVSPECIFIC                ,"DEVSPECIFIC"            },
    { PHONE_STATE                      ,"STATE"                  },
    { PHONE_CREATE                     ,"CREATE"                 },
    { PHONE_REMOVE                     ,"REMOVE"                 },
    { 0xffffffff                       ,""                       }
};


LOOKUP aVersions[] =
{
    { 0x00010003                       ,"1.0"                    },
    { 0x00010004                       ,"1.4"                    },
    { 0x00020000                       ,"2.0"                    },
    { 0x00020001                       ,"2.1"                    },
    { 0x00020002                       ,"2.2"                    },
    { 0x00030000                       ,"3.0"                    },
    { 0x00030001                       ,"3.1"                    },
    { 0xffffffff                       ,""                       }
};


BOOL        gbESPLoaded = FALSE;
            gbPBXThreadRunning,
            gbAutoClose,
            gbDisableUI;
LONG        cxList1,
            cxWnd;
HWND        ghwndMain,
            ghwndList1,
            ghwndList2,
            ghwndEdit;
DWORD       gdwTSPIVersion,
            gdwNumLines,
            gdwNumAddrsPerLine,
            gdwNumCallsPerAddr,
            gdwNumPhones,
            gdwDebugOptions,
            gdwCompletionMode,
            gbAutoGatherGenerateMsgs;
HMENU       ghMenu;
HINSTANCE   ghInstance;
PMYWIDGET   gpWidgets;

char        szMySection[] = "ESP32";

INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

INT_PTR
CALLBACK
PBXConfigDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
HelpDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

void
ProcessWidgetEvent(
    PWIDGETEVENT    pEvent
    );

void
UpdateESPOptions(
    void
    );

void
SaveIniFileSettings(
    void
    );

void
xxxShowStr(
    char   *psz
    );

void
ShowStr(
    char   *pszFormat,
    ...
    );

LPVOID
MyAlloc(
    size_t numBytes
    );

void
MyFree(
    LPVOID  p
    );

INT_PTR
CALLBACK
ValuesDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\exe\espexe.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    espexe.c

Abstract:



Author:

    Dan Knudson (DanKn)    15-Sep-1995

Revision History:

--*/


#include "espexe.h"


typedef LONG (WINAPI *TAPIPROC)();


int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{
    MSG msg;
    HACCEL  hAccel;


    ghInstance = hInstance;

    ghwndMain = CreateDialog(
        ghInstance,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG1),
        (HWND)NULL,
        MainWndProc
        );

    if (!ghwndMain)
    {
    }

    hAccel = LoadAccelerators(
        ghInstance,
        (LPCSTR)MAKEINTRESOURCE(IDR_ACCELERATOR1)
        );

    while (GetMessage (&msg, (HWND) NULL, 0, 0))
    {
        if (!hAccel || !TranslateAccelerator (ghwndMain, hAccel, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }

    DestroyWindow (ghwndMain);

    DestroyAcceleratorTable (hAccel);

    return 0;
}


void
ESPServiceThread(
    LPVOID  pParams
    )
{
    HANDLE  hInitEvent;


    ShowStr ("ESPServiceThread: enter");

    hInitEvent = CreateEvent(
        (LPSECURITY_ATTRIBUTES) NULL,
        FALSE,      // auto-reset
        FALSE,      // non-signaled
        "ESPevent"
        );

    while (1)
    {
        HANDLE  ahEvents[3];


wait_for_esp_to_init:

        gbESPLoaded = FALSE;

        EnableWindow (GetDlgItem (ghwndMain, IDC_BUTTON1), FALSE);
        EnableWindow (GetDlgItem (ghwndMain, IDC_BUTTON2), FALSE);


        //
        //
        //

        {
            DWORD       dwUsedSize;
            RPC_STATUS  status;

            #define CNLEN              25   // computer name length
            #define UNCLEN        CNLEN+2   // \\computername
            #define PATHLEN           260   // Path
            #define MAXPROTSEQ         20   // protocol sequence "ncacn_np"

            unsigned char   pszNetworkAddress[UNCLEN+1];
            unsigned char * pszUuid          = NULL;
            unsigned char * pszOptions       = NULL;
            unsigned char * pszStringBinding = NULL;


            pszNetworkAddress[0] = '\0';

            status = RpcStringBindingCompose(
                pszUuid,
                "ncalrpc",
                pszNetworkAddress,
                "esplpc",
                pszOptions,
                &pszStringBinding
                );

            if (status)
            {
                ShowStr(
                    "RpcStringBindingCompose failed: err=%d, szNetAddr='%s'",
                    status,
                    pszNetworkAddress
                    );
            }

			else 
			{
				status = RpcBindingFromStringBinding(
					pszStringBinding,
					&hEsp
					);

				if (status)
				{
					ShowStr(
						"RpcBindingFromStringBinding failed, err=%d, szBinding='%s'",
						status,
						pszStringBinding
						);
				}
			}

            RpcStringFree  (&pszStringBinding);
        }

        ShowStr ("ESPServiceThread: waiting for esp init event");

        WaitForSingleObject (hInitEvent, INFINITE);


        RpcTryExcept
        {
            ESPAttach(
                (long) GetCurrentProcessId(),
                (ULONG_PTR *) ahEvents,     // &hShutdownEvent
                (ULONG_PTR *) ahEvents + 1, // &hDebugOutputEvent
                (ULONG_PTR *) ahEvents + 2  // &hWidgetEventsEvent
                );
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
        	ShowStr ("ESPServiceThread: esp init event signaled, EXCEPTION while trying to attach to esp");
        	continue;
        }
        RpcEndExcept

        gbESPLoaded = TRUE;

        UpdateESPOptions();

        gbPBXThreadRunning = FALSE;
        EnableMenuItem (ghMenu, IDM_PBXSTART, MF_BYCOMMAND | MF_ENABLED);

        ShowStr ("ESPServiceThread: esp init event signaled, attached to esp");

        gpWidgets = NULL;

        EnableWindow (GetDlgItem (ghwndMain, IDC_BUTTON1), TRUE);
        EnableWindow (GetDlgItem (ghwndMain, IDC_BUTTON2), TRUE);


        //
        //
        //

        {
            DWORD   dwBufSize = 50 * sizeof (WIDGETEVENT);
            char   *buf = MyAlloc (dwBufSize);

			// fix for bug 57370
            if (!buf) break;


            while (1)
            {
                switch (WaitForMultipleObjects (3, ahEvents, FALSE, INFINITE))
                {
                case WAIT_OBJECT_0+1:
                {
                    DWORD   dwSize;

get_debug_output:
                    dwSize = dwBufSize - 1;

                    RpcTryExcept
                    {
                        ESPGetDebugOutput (buf, &dwSize);
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
  	                {
	   			      	ShowStr ("ESPServiceThread: EXCEPTION while calling ESPGetDebugOutput()");
                        break;
                    }
                    RpcEndExcept

                    buf[dwSize] = 0;

                    xxxShowStr (buf);

                    if (dwSize == (dwBufSize - 1))
                    {
                        char *newBuf;


                        if ((newBuf = MyAlloc (2*dwBufSize)))
                        {
                            MyFree (buf);
                            buf = newBuf;
                            dwBufSize *= 2;
                        }

                        goto get_debug_output;
                    }

                    break;
                }
                case WAIT_OBJECT_0+2:
                {
                    DWORD           dwSize, i, dwNumEvents;
                    PWIDGETEVENT    pEvent;

get_widget_events:
                    dwSize = dwBufSize;

                    RpcTryExcept
                    {
                        ESPGetWidgetEvents (buf, &dwSize);
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                    {
       			      	ShowStr ("ESPServiceThread: EXCEPTION while calling ESPGetWidgetEvents()");
                        break;
                    }
                    RpcEndExcept

                    dwNumEvents = dwSize / sizeof (WIDGETEVENT);

                    pEvent = (PWIDGETEVENT) buf;

                    for (i = 0; i < dwNumEvents; i++)
                    {
                        ProcessWidgetEvent (pEvent++);
                    }

                    if (dwSize == dwBufSize)
                    {
                        goto get_widget_events;
                    }

                    break;
                }
                default:

                    RpcBindingFree (&hEsp);

                    SaveIniFileSettings();

                    CloseHandle (ahEvents[0]);
                    CloseHandle (ahEvents[1]);
                    CloseHandle (ahEvents[2]);

                    MyFree (buf);

                    SendMessage (ghwndList1, LB_RESETCONTENT, 0, 0);

                    while (gpWidgets)
                    {
                        PMYWIDGET   pNextWidget = gpWidgets->pNext;


                        MyFree (gpWidgets);
                        gpWidgets = pNextWidget;
                    }

                    // BUGBUG disable lots of menuitems, etc.

                    EnableMenuItem(
                        ghMenu,
                        IDM_PBXSTART,
                        MF_BYCOMMAND | MF_GRAYED
                        );

                    EnableMenuItem(
                        ghMenu,
                        IDM_PBXSTOP,
                        MF_BYCOMMAND | MF_GRAYED
                        );

                    if (gbAutoClose)
                    {
                        gbESPLoaded = FALSE;
                        PostMessage (ghwndMain, WM_CLOSE, 0, 0);
                        goto ESPServiceThread_exit;
                    }

                    goto wait_for_esp_to_init;

                } // switch (WaitForMultipleObjects (...))

            } // while (1)
        }

    } // while (1)

ESPServiceThread_exit:

    CloseHandle (hInitEvent);

    ExitThread (0);
}


INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static int      icyButton, icyBorder, cyWnd;
    static BOOL     bCaptured = FALSE;
    static LONG     xCapture, cxVScroll;
    static HFONT    hFont;
    static HICON    hIcon;


    switch (msg)
    {
    case WM_INITDIALOG:
    {
        char buf[64];
        RECT rect;


        //
        // Init some globals
        //

        hIcon = LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_ICON1));

        ghwndMain  = hwnd;
        ghwndList1 = GetDlgItem (hwnd, IDC_LIST1);
        ghwndList2 = GetDlgItem (hwnd, IDC_LIST2);
        ghwndEdit  = GetDlgItem (hwnd, IDC_EDIT1);
        ghMenu     = GetMenu (hwnd);

        icyBorder = GetSystemMetrics (SM_CYFRAME);
        GetWindowRect (GetDlgItem (hwnd, IDC_BUTTON1), &rect);
        icyButton = (rect.bottom - rect.top) + icyBorder + 3;
        cxVScroll = 2*GetSystemMetrics (SM_CXVSCROLL);

        gbPBXThreadRunning = FALSE;

        EnableMenuItem (ghMenu, IDM_PBXSTART, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (ghMenu, IDM_PBXSTOP, MF_BYCOMMAND | MF_GRAYED);


        //
        //
        //

        {
            typedef struct _XXX
            {
                DWORD    dwDefValue;

                LPCSTR   pszValueName;

                LPDWORD  pdwValue;

            } XXX, *PXXX;

            XXX axxx[] =
            {
                { DEF_SPI_VERSION,          "TSPIVersion",      &gdwTSPIVersion },
                { 0,                        "AutoClose",        &gbAutoClose },
                { DEF_NUM_LINES,            "NumLines",         &gdwNumLines },
                { DEF_NUM_ADDRS_PER_LINE,   "NumAddrsPerLine",  &gdwNumAddrsPerLine },
                { DEF_NUM_CALLS_PER_ADDR,   "NumCallsPerAddr",  &gdwNumCallsPerAddr },
                { DEF_NUM_PHONES,           "NumPhones",        &gdwNumPhones },
                { DEF_DEBUG_OPTIONS,        "DebugOutput",      &gdwDebugOptions },
                { DEF_COMPLETION_MODE,      "Completion",       &gdwCompletionMode },
                { 0,                        "DisableUI",        &gbDisableUI },
                { 1,                        "AutoGatherGenerateMsgs",   &gbAutoGatherGenerateMsgs },
                { 0,                        NULL,               NULL },
            };
            DWORD   i;

            for (i = 0; axxx[i].pszValueName; i++)
            {
                *(axxx[i].pdwValue) = (DWORD) GetProfileInt(
                    szMySection,
                    axxx[i].pszValueName,
                    (int) axxx[i].dwDefValue
                    );
            }

            for (i = 0; i < 6; i++)
            {
                if (gdwDebugOptions & (0x1 << i))
                {
                    CheckMenuItem(
                        ghMenu,
                        IDM_SHOWFUNCENTRY + i,
                        MF_BYCOMMAND | MF_CHECKED
                        );
                }
            }

            CheckMenuItem(
                ghMenu,
                IDM_SYNCCOMPL + gdwCompletionMode,
                MF_BYCOMMAND | MF_CHECKED
                );

            CheckMenuItem(
                ghMenu,
                IDM_AUTOCLOSE,
                MF_BYCOMMAND | (gbAutoClose ? MF_CHECKED : MF_UNCHECKED)
                );

            CheckMenuItem(
                ghMenu,
                IDM_AUTOGATHERGENERATEMSGS,
                MF_BYCOMMAND |
                    (gbAutoGatherGenerateMsgs ? MF_CHECKED : MF_UNCHECKED)
                );

            CheckMenuItem(
                ghMenu,
                IDM_DISABLEUI,
                MF_BYCOMMAND | (gbDisableUI ? MF_CHECKED : MF_UNCHECKED)
                );
        }


        //
        // Set control fonts
        //

        {
            HWND hwndCtrl = GetDlgItem (hwnd, IDC_BUTTON1);
            hFont = CreateFont(
                13, 5, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 34, "MS Sans Serif"
                );

            do
            {
                SendMessage(
                    hwndCtrl,
                    WM_SETFONT,
                    (WPARAM) hFont,
                    0
                    );

            } while ((hwndCtrl = GetNextWindow (hwndCtrl, GW_HWNDNEXT)));
        }


        //
        // Read in control size ratios
        //

        cxWnd   = GetProfileInt (szMySection, "cxWnd",   100);
        cxList1 = GetProfileInt (szMySection, "cxList1", 25);


        //
        // Send self WM_SIZE to position child controls correctly
        //

        GetProfileString(
            szMySection,
            "Left",
            "0",
            buf,
            63
            );

        if (strcmp (buf, "max") == 0)
        {
            ShowWindow (hwnd, SW_SHOWMAXIMIZED);
        }
        else if (strcmp (buf, "min") == 0)
        {
            ShowWindow (hwnd, SW_SHOWMINIMIZED);
        }
        else
        {
            int left, top, right, bottom;
            int cxScreen = GetSystemMetrics (SM_CXSCREEN);
            int cyScreen = GetSystemMetrics (SM_CYSCREEN);


            left   = GetProfileInt (szMySection, "Left",   0);
            top    = GetProfileInt (szMySection, "Top",    3*cyScreen/4);
            right  = GetProfileInt (szMySection, "Right",  cxScreen);
            bottom = GetProfileInt (szMySection, "Bottom", cyScreen);

            SetWindowPos(
                hwnd,
                HWND_TOP,
                left,
                top,
                right - left,
                bottom - top,
                SWP_SHOWWINDOW
                );

            GetClientRect (hwnd, &rect);

            SendMessage(
                hwnd,
                WM_SIZE,
                0,
                MAKELONG((rect.right-rect.left),(rect.bottom-rect.top))
                );

            ShowWindow (hwnd, SW_SHOW);
        }


        //
        // Start the service thread
        //

        {
            DWORD   dwThreadID;
            HANDLE  hThread;


            hThread = CreateThread(
                (LPSECURITY_ATTRIBUTES) NULL,
                0,
                (LPTHREAD_START_ROUTINE) ESPServiceThread,
                NULL,
                0,
                &dwThreadID
                );

            SetThreadPriority (hThread, THREAD_PRIORITY_ABOVE_NORMAL);

            CloseHandle (hThread);
        }

        break;
    }
    case WM_COMMAND:
    {
        UINT uiCtrlID = (UINT) LOWORD(wParam);


        switch (uiCtrlID)
        {
        case IDM_INSTALL:
        case IDM_UNINSTALL:
        {
            BOOL                bESPInstalled = FALSE;
            LONG                lResult;
            DWORD               i;
            TAPIPROC            pfnLineGetProviderList, pfnLineAddProvider,
                                pfnLineRemoveProvider;
            HINSTANCE           hTapi32;
            LINEPROVIDERLIST    providerList, *pProviderList;
            LPLINEPROVIDERENTRY pProviderEntry;


            if (!(hTapi32 = LoadLibrary ("tapi32.dll")))
            {
                ShowStr(
                    "LoadLibrary(tapi32.dll) failed, err=%d",
                    GetLastError()
                    );

                break;
            }

            if (!(pfnLineAddProvider = (TAPIPROC) GetProcAddress(
                    hTapi32,
                    "lineAddProvider"
                    )) ||

                !(pfnLineGetProviderList = (TAPIPROC) GetProcAddress(
                    hTapi32,
                    "lineGetProviderList"
                    )) ||

                !(pfnLineRemoveProvider = (TAPIPROC) GetProcAddress(
                    hTapi32,
                    "lineRemoveProvider"
                    )))
            {
                ShowStr(
                    "GetProcAddr(tapi32,lineAddProvider) failed, err=%d",
                    GetLastError()
                    );

                goto install_free_tapi32;
            }

            providerList.dwTotalSize = sizeof (LINEPROVIDERLIST);

            if ((lResult = (*pfnLineGetProviderList)(0x20000, &providerList)))
            {
                ShowStr(
                    "ESP (Un)Install: error, lineGetProviderList returned x%x",
                    lResult
                    );

                goto install_free_tapi32;
            }

            pProviderList = MyAlloc (providerList.dwNeededSize);

            pProviderList->dwTotalSize = providerList.dwNeededSize;

            if ((lResult = (*pfnLineGetProviderList)(0x20000, pProviderList)))
            {
                ShowStr(
                    "ESP (Un)Install: error, lineGetProviderList returned x%x",
                    lResult
                    );

                goto install_free_provider_list;
            }

            pProviderEntry = (LPLINEPROVIDERENTRY) (((LPBYTE) pProviderList) +
                pProviderList->dwProviderListOffset);

            for (i = 0; i < pProviderList->dwNumProviders; i++)
            {
                int     j;
                char   *pszProviderName = (char *) (((LPBYTE) pProviderList) +
                            pProviderEntry->dwProviderFilenameOffset);


                //
                // Convert the string to lower case, then see if it
                // contains "esp32.tsp"
                //

                for (j = 0; pszProviderName[j]; j++)
                {
                    pszProviderName[j] |= 0x20;
                }

                if (strstr (pszProviderName, "esp32.tsp"))
                {
                    bESPInstalled = TRUE;
                    break;
                }

                pProviderEntry++;
            }

            if (uiCtrlID == IDM_INSTALL)
            {
                if (bESPInstalled)
                {
                    ShowStr ("ESP Install: already installed");
                }
                else
                {
                    DWORD dwPermanentProviderID;


                    if ((lResult = (*pfnLineAddProvider)(
                            "esp32.tsp",
                            hwnd,
                            &dwPermanentProviderID

                            )) == 0)
                    {
                        ShowStr(
                            "ESP Install: success, ProviderID=%d",
                            dwPermanentProviderID
                            );
                    }
                    else
                    {
                        ShowStr(
                            "ESP Install: error, lineAddProvider returned x%x",
                            lResult
                            );
                    }
                }
            }
            else // IDM_UNINSTALL
            {
                if (bESPInstalled)
                {
                    if ((lResult = (*pfnLineRemoveProvider)(
                            pProviderEntry->dwPermanentProviderID,
                            hwnd

                            )) == 0)
                    {
                        ShowStr ("ESP Uninstall: success");
                    }
                    else
                    {
                        ShowStr(
                            "ESP Uninstall: error, lineRemoveProvider " \
                                "returned x%x",
                            lResult
                            );
                    }
                }
                else
                {
                    ShowStr ("ESP Uninstall: not installed");
                }
            }

install_free_provider_list:

            MyFree (pProviderList);

install_free_tapi32:

            FreeLibrary (hTapi32);

            break;
        }
        case IDM_AUTOCLOSE:
        {
            gbAutoClose = (gbAutoClose ? FALSE : TRUE);

            CheckMenuItem(
                ghMenu,
                IDM_AUTOCLOSE,
                MF_BYCOMMAND | (gbAutoClose ? MF_CHECKED : MF_UNCHECKED)
                );

            SaveIniFileSettings();
            break;
        }
        case IDM_AUTOGATHERGENERATEMSGS:
        {
            gbAutoGatherGenerateMsgs =
                (gbAutoGatherGenerateMsgs ? FALSE : TRUE);

            CheckMenuItem(
                ghMenu,
                IDM_AUTOGATHERGENERATEMSGS,
                MF_BYCOMMAND |
                    (gbAutoGatherGenerateMsgs ? MF_CHECKED : MF_UNCHECKED)
                );

            SaveIniFileSettings();
            break;
        }
        case IDM_DISABLEUI:
        {
            gbDisableUI = (gbDisableUI ? FALSE : TRUE);

            CheckMenuItem(
                ghMenu,
                IDM_DISABLEUI,
                MF_BYCOMMAND | (gbDisableUI ? MF_CHECKED : MF_UNCHECKED)
                );

            SaveIniFileSettings();
            break;
        }
        case IDM_DEFAULTS:
        {
            EVENT_PARAM params[] =
            {
                { "TSPI Version",       PT_ORDINAL,   gdwTSPIVersion, aVersions },
                { "Num lines",          PT_DWORD,     gdwNumLines, 0 },
                { "Num addrs per line", PT_DWORD,     gdwNumAddrsPerLine, 0 },
                { "Num calls per addr", PT_DWORD,     gdwNumCallsPerAddr, 0 },
                { "Num phones",         PT_DWORD,     gdwNumPhones, 0 },
            };
            EVENT_PARAM_HEADER paramsHeader =
                { 5, "Default values", 0, params };


            if (DialogBoxParam(
                    ghInstance,
                    (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                    hwnd,
                    ValuesDlgProc,
                    (LPARAM) &paramsHeader

                    ) == IDOK)
            {
                char *aszValueNames[] =
                {
                    "TSPIVersion",
                    "NumLines",
                    "NumAddrsPerLine",
                    "NumCallsPerAddr",
                    "NumPhones",
                    NULL
                };
                LPDWORD lpdwValues[] =
                {
                    &gdwTSPIVersion,
                    &gdwNumLines,
                    &gdwNumAddrsPerLine,
                    &gdwNumCallsPerAddr,
                    &gdwNumPhones
                };
                int i;
                BOOL bValuesChanged = FALSE;


                for (i = 0; aszValueNames[i]; i++)
                {
                    char buf[16];

                    if (*(lpdwValues[i]) != params[i].dwValue)
                    {
                        *(lpdwValues[i]) = (DWORD) params[i].dwValue;

                        wsprintf (buf, "%d", params[i].dwValue);

                        WriteProfileString(
                            szMySection,
                            aszValueNames[i],
                            buf
                            );

                        bValuesChanged = TRUE;
                    }
                }

                if (bValuesChanged && gbESPLoaded)
                {
                    MessageBox(
                        hwnd,
                        "New values will not take effect until provider is" \
                            " shutdown and reinitialized",
                        "ESP Defaults",
                        MB_OK
                        );
                }
            }

            break;
        }
        case IDC_BUTTON1:
        {
            LRESULT lSel;
            EVENT_PARAM params[] =
            {
                { "htLine",   PT_DWORD,   0, 0 },
                { "htCall",   PT_DWORD,   0, 0 },
                { "dwMsg",    PT_ORDINAL, 0, aLineMsgs },
                { "dwParam1", PT_DWORD,   0, 0 },
                { "dwParam2", PT_DWORD,   0, 0 },
                { "dwParam3", PT_DWORD,   0, 0 },
            };
            EVENT_PARAM_HEADER paramsHeader =
                { 6, "Line event", 0, params };


            lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);

            if (lSel != LB_ERR)
            {
                PMYWIDGET pWidget;


                pWidget = (PMYWIDGET) SendMessage(
                    ghwndList1,
                    LB_GETITEMDATA,
                    lSel,
                    0
                    );

                if (pWidget->dwWidgetType == WIDGETTYPE_LINE)
                {
                    params[0].dwValue =
                    params[0].dwDefValue = pWidget->htXxx;
                }
                else if (pWidget->dwWidgetType == WIDGETTYPE_CALL)
                {
                    params[1].dwValue =
                    params[1].dwDefValue = pWidget->htXxx;

                    do
                    {
                        pWidget = pWidget->pPrev;
                    }
                    while (pWidget->dwWidgetType != WIDGETTYPE_LINE);

                    params[0].dwValue =
                    params[0].dwDefValue = pWidget->htXxx;
                }
            }

            if (DialogBoxParam(
                    ghInstance,
                    (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                    hwnd,
                    ValuesDlgProc,
                    (LPARAM) &paramsHeader

                    ) == IDOK)
            {
                ESPEvent(
                    params[0].dwValue,
                    params[1].dwValue,
                    params[2].dwValue,
                    params[3].dwValue,
                    params[4].dwValue,
                    params[5].dwValue
                    );
            }

            break;
        }
        case IDC_BUTTON2:
        {
            LRESULT lSel;
            EVENT_PARAM params[] =
            {
                { "htPhone",  PT_DWORD,   0, 0 },
                { "dwMsg",    PT_ORDINAL, 0, aPhoneMsgs },
                { "dwParam1", PT_DWORD,   0, 0 },
                { "dwParam2", PT_DWORD,   0, 0 },
                { "dwParam3", PT_DWORD,   0, 0 },
            };
            EVENT_PARAM_HEADER paramsHeader =
                { 5, "Phone event", 0, params };


            lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);

            if (lSel != LB_ERR)
            {
                PMYWIDGET pWidget;


                pWidget = (PMYWIDGET) SendMessage(
                    ghwndList1,
                    LB_GETITEMDATA,
                    lSel,
                    0
                    );

                if (pWidget->dwWidgetType == WIDGETTYPE_PHONE)
                {
                    params[0].dwValue =
                    params[0].dwDefValue = pWidget->htXxx;
                }
            }

            if (DialogBoxParam(
                    ghInstance,
                    (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                    hwnd,
                    ValuesDlgProc,
                    (LPARAM) &paramsHeader

                    ) == IDOK)
            {
                ESPEvent(
                    params[0].dwValue,
                    0,
                    params[1].dwValue,
                    params[2].dwValue,
                    params[3].dwValue,
                    params[4].dwValue
                    );
            }

            break;
        }
        case IDC_ENTER:
        {
            HWND hwndFocus = GetFocus();


            if (hwndFocus == ghwndList1)
            {
                goto show_widget_dialog;
            }
            else if (hwndFocus == ghwndList2)
            {
                goto complete_pending_request;
            }

            break;
        }
        case IDC_LIST1:
        {
            if (HIWORD(wParam) == LBN_DBLCLK)
            {
                LRESULT lSel;

show_widget_dialog:

                lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);

                if (lSel != LB_ERR)
                {
                    //
                    // Determine the widget type, & put up the
                    // appropriate properties dlg
                    //

                    PMYWIDGET pWidget;


                    pWidget = (PMYWIDGET) SendMessage(
                        ghwndList1,
                        LB_GETITEMDATA,
                        lSel,
                        0
                        );

                    switch (pWidget->dwWidgetType)
                    {
                    case WIDGETTYPE_LINE:
                    {
                        char szTitle[32];
                        EVENT_PARAM params[] =
                        {
                            { "<under construction>", PT_DWORD, 0, 0 }
                        };
                        EVENT_PARAM_HEADER paramsHeader =
                            { 1, szTitle, 0, params };


                        wsprintf(
                            szTitle,
                            "Line%d properties",
                            pWidget->dwWidgetID
                            );

                        if (DialogBoxParam(
                                ghInstance,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                                hwnd,
                                ValuesDlgProc,
                                (LPARAM) &paramsHeader

                                ) == IDOK)
                        {
                        }

                        break;
                    }
                    case WIDGETTYPE_CALL:
                    {
                        char szTitle[32];
                        EVENT_PARAM params[] =
                        {
                            { "Call state", PT_ORDINAL, pWidget->dwCallState, aCallStates },
                            { "Call state mode", PT_DWORD, 0, 0 }
                        };
                        EVENT_PARAM_HEADER paramsHeader =
                            { 2, szTitle, 0, params };


                        wsprintf(
                            szTitle,
                            "Call x%x properties",
                            pWidget->hdXxx
                            );

                        if (DialogBoxParam(
                                ghInstance,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                                hwnd,
                                ValuesDlgProc,
                                (LPARAM) &paramsHeader

                                ) == IDOK)
                        {
                            if (params[0].dwValue != pWidget->dwCallState)
                            {
                                ESPEvent(
                                    0,
                                    pWidget->hdXxx,
                                    LINE_CALLSTATE,
                                    params[0].dwValue,
                                    params[1].dwValue,
                                    0
                                    );
                            }
                        }

                        break;
                    }
                    case WIDGETTYPE_PHONE:
                    {
                        char szTitle[32];
                        EVENT_PARAM params[] =
                        {
                            { "<under construction>", PT_DWORD, 0, 0 }
                        };
                        EVENT_PARAM_HEADER paramsHeader =
                            { 1, szTitle, 0, params };


                        wsprintf(
                            szTitle,
                            "Phone%d properties",
                            pWidget->dwWidgetID
                            );

                        if (DialogBoxParam(
                                ghInstance,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                                hwnd,
                                ValuesDlgProc,
                                (LPARAM) &paramsHeader

                                ) == IDOK)
                        {
                        }

                        break;
                    }
                    }
                }
            }

            break;
        }
        case IDC_LIST2:
        {
            if (HIWORD(wParam) == LBN_DBLCLK)
            {
                LRESULT lSel;

complete_pending_request:

                lSel = SendMessage (ghwndList2, LB_GETCURSEL, 0, 0);

                if (lSel != LB_ERR)
                {
                    LONG        lResult = 0;
                    ULONG_PTR   pAsyncReqInfo;


                    if (gdwDebugOptions & MANUAL_RESULTS)
                    {
                        EVENT_PARAM params[] =
                        {
                            { "lResult", PT_ORDINAL, 0, aLineErrs }
                        };
                        EVENT_PARAM_HEADER paramsHeader =
                            { 1, "Completing request", 0, params };


                        if (DialogBoxParam(
                                ghInstance,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                                hwnd,
                                ValuesDlgProc,
                                (LPARAM) &paramsHeader

                                ) != IDOK)
                        {
                            break;
                        }

                        lResult = (LONG) params[0].dwValue;
                    }

                    pAsyncReqInfo = SendMessage(
                        ghwndList2,
                        LB_GETITEMDATA,
                        (WPARAM) lSel,
                        0
                        );

                    SendMessage(
                        ghwndList2,
                        LB_DELETESTRING,
                        (WPARAM) lSel,
                        0
                        );

                    ESPCompleteRequest (pAsyncReqInfo, lResult);
                }
            }

            break;
        }
        case IDC_PREVCTRL:
        {
            HWND hwndPrev = GetNextWindow (GetFocus (), GW_HWNDPREV);


            if (!hwndPrev)
            {
                hwndPrev = GetDlgItem (hwnd, IDC_LIST2);
            }

            SetFocus (hwndPrev);
            break;
        }
        case IDC_NEXTCTRL:
        {
            HWND hwndNext = GetNextWindow (GetFocus (), GW_HWNDNEXT);


            if (!hwndNext)
            {
                hwndNext = GetDlgItem (hwnd, IDC_BUTTON1);
            }

            SetFocus (hwndNext);
            break;
        }
        case IDC_BUTTON4: // "Clear"

            SetWindowText (ghwndEdit, "");
            break;

        case IDM_PBXCONFIG:

            DialogBox(
                ghInstance,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG4),
                hwnd,
                PBXConfigDlgProc
                );

            break;

        case IDM_PBXSTART:
        {
            DWORD dwTID, aPBXSettings[2];


            aPBXSettings[0] = (gPBXSettings[0].dwNumber ?
                gPBXSettings[0].dwTime / gPBXSettings[0].dwNumber : 0);

            aPBXSettings[1] = (gPBXSettings[1].dwNumber ?
                gPBXSettings[1].dwTime / gPBXSettings[1].dwNumber : 0);

            if (ESPStartPBXThread ((char *) aPBXSettings, 2 * sizeof(DWORD))
                    == 0)
            {
                gbPBXThreadRunning = TRUE;

                EnableMenuItem(
                    ghMenu,
                    IDM_PBXSTART,
                    MF_BYCOMMAND | MF_GRAYED
                    );

                EnableMenuItem(
                    ghMenu,
                    IDM_PBXSTOP,
                    MF_BYCOMMAND | MF_ENABLED
                    );
            }

            break;
        }
        case IDM_PBXSTOP:

            if (ESPStopPBXThread (0) == 0)
            {
                gbPBXThreadRunning = FALSE;

                EnableMenuItem(
                    ghMenu,
                    IDM_PBXSTOP,
                    MF_BYCOMMAND | MF_GRAYED
                    );

                EnableMenuItem(
                    ghMenu,
                    IDM_PBXSTART,
                    MF_BYCOMMAND | MF_ENABLED
                    );
            }
            break;

        case IDM_USAGE:

            DialogBox(
                ghInstance,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG5),
                (HWND) hwnd,
                HelpDlgProc
                );

            break;

        case IDM_ABOUT:

            DialogBox(
                ghInstance,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
                (HWND) hwnd,
                AboutDlgProc
                );

            break;

        case IDC_EDIT1:

            if (HIWORD(wParam) == EN_CHANGE)
            {
                //
                // Watch to see if the edit control is full, & if so
                // purge the top half of the text to make room for more
                //

                int length = GetWindowTextLength (ghwndEdit);


                if (length > 20000)
                {
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)0 ,
                        (LPARAM) 10000
                        );

                    SendMessage(
                        ghwndEdit,
                        EM_REPLACESEL,
                        0,
                        (LPARAM) (char far *) ""
                        );

                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)0xfffffffd,
                        (LPARAM)0xfffffffe
                        );
                }

                UpdateESPOptions();
            }
            break;

        case IDM_SYNCCOMPL:
        case IDM_ASYNCCOMPL:
        case IDM_SYNCASYNCCOMPL:
        case IDM_MANUALCOMPL:

            if ((uiCtrlID - IDM_SYNCCOMPL) != gdwCompletionMode)
            {
                CheckMenuItem(
                    ghMenu,
                    IDM_SYNCCOMPL + gdwCompletionMode,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );

                gdwCompletionMode = uiCtrlID - IDM_SYNCCOMPL;

                CheckMenuItem(
                    ghMenu,
                    uiCtrlID,
                    MF_BYCOMMAND | MF_CHECKED
                    );

                UpdateESPOptions();
            }

            break;

        case IDM_SHOWFUNCENTRY:
        case IDM_SHOWFUNCPARAMS:
        case IDM_SHOWFUNCEXIT:
        case IDM_SHOWEVENTS:
        case IDM_SHOWCOMPLETIONS:
        case IDM_MANUALRESULTS:
        {
            DWORD   dwBitField = 0x1 << (uiCtrlID - IDM_SHOWFUNCENTRY);

            gdwDebugOptions ^= dwBitField;

            CheckMenuItem(
                ghMenu,
                uiCtrlID,
                MF_BYCOMMAND | (gdwDebugOptions & dwBitField ?
                    MF_CHECKED : MF_UNCHECKED)
                );

            UpdateESPOptions();

            break;
        }
        case IDM_SHOWALL:
        case IDM_SHOWNONE:
        {
            int i;

            gdwDebugOptions = (uiCtrlID == IDM_SHOWALL ? 0xffffffff : 0);

            for (i = 0; i < 5; i++)
            {
                CheckMenuItem(
                    ghMenu,
                    IDM_SHOWFUNCENTRY + i,
                    MF_BYCOMMAND | (uiCtrlID == IDM_SHOWALL ?
                        MF_CHECKED : MF_UNCHECKED)
                    );

                UpdateESPOptions();
            }

            break;
        }
        case IDM_EXIT:

            goto do_wm_close;
            break;

        } // switch (LOWORD(wParam))

        break;
    }
    case WM_PAINT:
    {
        PAINTSTRUCT ps;


        BeginPaint (hwnd, &ps);

        if (IsIconic (hwnd))
        {
            DrawIcon (ps.hdc, 0, 0, hIcon);
        }
        else
        {
            FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
#ifdef WIN32
            MoveToEx (ps.hdc, 0, 0, NULL);
#else
            MoveTo (ps.hdc, 0, 0);
#endif
            LineTo (ps.hdc, 5000, 0);

#ifdef WIN32
            MoveToEx (ps.hdc, 0, icyButton - 4, NULL);
#else
            MoveTo (ps.hdc, 0, icyButton - 4);
#endif
            LineTo (ps.hdc, 5000, icyButton - 4);
        }

        EndPaint (hwnd, &ps);

        break;
    }
    case WM_SIZE:
    {
        if (wParam != SIZE_MINIMIZED)
        {
            LONG width = (LONG)LOWORD(lParam);


            //
            // Adjust globals based on new size
            //

            cxWnd = (cxWnd ? cxWnd : 1);    // avoid div by 0

            cxList1 = (cxList1 * width) / cxWnd;
            cxWnd = width;
            cyWnd = ((int)HIWORD(lParam)) - icyButton;


            //
            // Now reposition the child windows
            //

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                0,
                icyButton,
                (int) cxList1,
                2*cyWnd/3,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton + 2*cyWnd/3 + icyBorder,
                (int) cxList1,
                cyWnd/3 - icyBorder,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) cxList1 + icyBorder,
                icyButton,
                (int)width - ((int)cxList1 + icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );

            InvalidateRect (hwnd, NULL, TRUE);
        }
        break;
    }
    case WM_MOUSEMOVE:
    {
        LONG x = (LONG)((short)LOWORD(lParam));
        int y = (int)((short)HIWORD(lParam));
        int cxList1New;


        if (((y > icyButton) && (x > cxList1)) || bCaptured)
        {
            SetCursor(
                LoadCursor ((HINSTANCE) NULL, MAKEINTRESOURCE(IDC_SIZEWE))
                );
        }

        if (bCaptured)
        {
            x = (x < cxVScroll ?  cxVScroll : x);
            x = (x > (cxWnd - cxVScroll) ?  (cxWnd - cxVScroll) : x);

            cxList1New = (int) (cxList1 + x - xCapture);

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                0,
                icyButton,
                cxList1New,
                2*cyWnd/3,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton + 2*cyWnd/3 + icyBorder,
                cxList1New,
                cyWnd/3 - icyBorder,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) cxList1New + icyBorder,
                icyButton,
                (int)cxWnd - (cxList1New + icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );
        }

        break;
    }
    case WM_LBUTTONDOWN:
    {
        if (((int)((short)HIWORD(lParam)) > icyButton) &&
             ((int)((short)LOWORD(lParam)) > cxList1))
        {
            xCapture = (LONG)LOWORD(lParam);

            SetCapture (hwnd);

            bCaptured = TRUE;
        }

        break;
    }
    case WM_LBUTTONUP:
    {
        if (bCaptured)
        {
            POINT p;
            LONG  x;

            GetCursorPos (&p);
            MapWindowPoints (HWND_DESKTOP, hwnd, &p, 1);
            x = (LONG) p.x;

            ReleaseCapture();

            x = (x < cxVScroll ? cxVScroll : x);
            x = (x > (cxWnd - cxVScroll) ? (cxWnd - cxVScroll) : x);

            cxList1 = cxList1 + (x - xCapture);

            bCaptured = FALSE;

            InvalidateRect (hwnd, NULL, TRUE);
        }

        break;
    }
    case WM_CLOSE:

do_wm_close:

        if (!gbESPLoaded)
        {
            SaveIniFileSettings();
            DestroyIcon (hIcon);
            DeleteObject (hFont);
            PostQuitMessage (0);
        }

        break;

    } // switch (msg)

    return 0;
}


void
UpdateSummary(
    HWND hwnd,
    PPBXSETTING pPBXSettings
    )
{
    int i, j;


    SendDlgItemMessage (hwnd, IDC_LIST4, LB_RESETCONTENT, 0, 0);

    for (i = 0, j= 0; i < NUM_PBXSETTINGS; i++)
    {
        if (pPBXSettings[i].dwNumber)
        {
            char buf[64];


            wsprintf(
                buf, "%s %s per %s",
                aPBXNumbers[pPBXSettings[i].dwNumber].pszVal,
                pPBXSettings[i].pszEvent,
                aPBXTimes[pPBXSettings[i].dwTime].pszVal
                );

            SendDlgItemMessage(
                hwnd,
                IDC_LIST4,
                LB_ADDSTRING,
                0,
                (LPARAM) buf
                );

            SendDlgItemMessage (hwnd, IDC_LIST4, LB_SETITEMDATA, j, i);

            j++;
        }
    }
}


INT_PTR
CALLBACK
PBXConfigDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PBXSETTING pbxSettings[NUM_PBXSETTINGS];

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        int i, j;


        //
        // Mkae a local copy of the global PBX settings
        //

        for (i = 0; i < NUM_PBXSETTINGS; i++)
        {

            pbxSettings[i].pszEvent = gPBXSettings[i].pszEvent;

            //
            // For Number & time fields convert from values to indexes
            //

            for (j = 0; aPBXNumbers[j].pszVal; j++)
            {
                if (gPBXSettings[i].dwNumber == aPBXNumbers[j].dwVal)
                {
                    pbxSettings[i].dwNumber = j;
                }
            }

            for (j = 0; aPBXTimes[j].pszVal; j++)
            {
                if (gPBXSettings[i].dwTime == aPBXTimes[j].dwVal)
                {
                    pbxSettings[i].dwTime = j;
                }
            }
        }

        if (gbPBXThreadRunning)
        {
            EnableWindow (GetDlgItem (hwnd, IDC_RESET), FALSE);
        }
        else
        {
            for (i = 0; aPBXNumbers[i].pszVal; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) aPBXNumbers[i].pszVal
                    );
            }

            for (i = 0; i < NUM_PBXSETTINGS; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) pbxSettings[i].pszEvent
                    );
            }

            for (i = 0; aPBXTimes[i].pszVal; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST3,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) aPBXTimes[i].pszVal
                    );
            }
        }

        UpdateSummary (hwnd, pbxSettings);

        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDC_LIST1:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                LRESULT lSelSetting, lSelNumber;


                lSelSetting = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_GETCURSEL,
                    0,
                    0
                    );

                lSelNumber = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_GETCURSEL,
                    0,
                    0
                    );

                pbxSettings[lSelSetting].dwNumber = (DWORD) lSelNumber;

                UpdateSummary (hwnd, pbxSettings);
            }

            break;

        case IDC_LIST2:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                LRESULT lSelSetting;


                lSelSetting = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_GETCURSEL,
                    0,
                    0
                    );

               SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_SETCURSEL,
                    pbxSettings[lSelSetting].dwNumber,
                    0
                    );

               SendDlgItemMessage(
                    hwnd,
                    IDC_LIST3,
                    LB_SETCURSEL,
                    pbxSettings[lSelSetting].dwTime,
                    0
                    );

                UpdateSummary (hwnd, pbxSettings);
            }

            break;

        case IDC_LIST3:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                LRESULT lSelSetting, lSelTime;


                lSelSetting = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_GETCURSEL,
                    0,
                    0
                    );

                lSelTime = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST3,
                    LB_GETCURSEL,
                    0,
                    0
                    );

                pbxSettings[lSelSetting].dwTime = (DWORD) lSelTime;

                UpdateSummary (hwnd, pbxSettings);
            }

            break;

        case IDC_LIST4:

            if ((HIWORD(wParam) == LBN_SELCHANGE) && !gbPBXThreadRunning)
            {
                LRESULT lSel, lEntryToSel;


                lSel = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST4,
                    LB_GETCURSEL,
                    0,
                    0
                    );

                lEntryToSel = SendDlgItemMessage(
                    hwnd,
                    IDC_LIST4,
                    LB_GETITEMDATA,
                    lSel,
                    0
                    );

               SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_SETCURSEL,
                    pbxSettings[lEntryToSel].dwNumber,
                    0
                    );

               SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_SETCURSEL,
                    lEntryToSel,
                    0
                    );

               SendDlgItemMessage(
                    hwnd,
                    IDC_LIST3,
                    LB_SETCURSEL,
                    pbxSettings[lEntryToSel].dwTime,
                    0
                    );
            }

            break;

        case IDC_RESET:

            memset (pbxSettings, 0, NUM_PBXSETTINGS * sizeof(PBXSETTING));

            UpdateSummary (hwnd, pbxSettings);

            break;

        case IDOK:
        {
            int i;

            // convert from indexes to values

            for (i = 0; i < NUM_PBXSETTINGS; i++)
            {
                gPBXSettings[i].dwNumber =
                    aPBXNumbers[pbxSettings[i].dwNumber].dwVal;
                gPBXSettings[i].dwTime =
                    aPBXTimes[pbxSettings[i].dwTime].dwVal;
            }

            // drop thru to IDM_CANCEL code

        }
        case IDCANCEL:

            EndDialog (hwnd, 0);
            break;
        }

        break;

    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch (msg)

    return FALSE;
}


INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return FALSE;
}


INT_PTR
CALLBACK
HelpDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
    {
        static char szUsageText[] =

            "ABSTRACT:\r\n"                                               \
            "    ESP is a TAPI Service Provider that supports\r\n"        \
            "multiple virtual line and phone devices. It is\r\n"          \
            "configurable, requires no special hardware,\r\n"             \
            "and implements the entire Telephony Service\r\n"             \
            "Provider Interface (including Win95 TAPI\r\n"                \
            "extensions). ESP will work in both Windows 3.1/\r\n"         \
            "TAPI 1.0 and Windows95/TAPI 1.1 systems.\r\n"                \

            "\r\nGETTING STARTED:\r\n"                                    \
            "    1. Choose 'File/Install' to install ESP.\r\n"            \
            "    2. Start a TAPI application and try to make\r\n"         \
            "a call on one of ESP's line devices (watch for\r\n"          \
            "messages appearing in the ESP window).\r\n"                  \
            "    *. Choose 'File/Uninstall' to uninstall ESP.\r\n"        \

            "\r\nMORE INFO:\r\n"                                          \
            "    *  Double-click on a line, call, or phone\r\n"           \
            "widget (in upper-left listbox) to view/modify\r\n"           \
            "properties. The 'hd'widget field is the driver\r\n"          \
            "handle; the 'ht' field is the TAPI handle.\r\n"              \
            "    *  Press the 'LEvt' or 'PEvt' button to\r\n"             \
            "indicate a line or phone event to TAPI.DLL.\r\n"             \
            "Press the 'Call+' button to indicate an incoming\r\n"        \
            " call.\r\n"                                                  \
            "    *  Choose 'Options/Default values...' to\r\n"            \
            "modify provider paramters (SPI version, etc.)\r\n"           \
            "    *  All parameter values displayed in\r\n"                \
            "hexadecimal unless specified otherwise (strings\r\n"         \
            "displayed by contents).\r\n"                                 \
            "    *  Choose 'Options/Complete async requests/Xxx'\r\n"     \
            "to specify async requests completion behavior.\r\n"          \
            "Manually-completed requests appear in lower-left\r\n"        \
            "listbox.";

        SetDlgItemText (hwnd, IDC_EDIT1, szUsageText);

        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return 0;
}


void
ProcessWidgetEvent(
    PWIDGETEVENT    pEvent
    )
{
    char        buf[64];
    LRESULT     lIndex = (LRESULT) -2; // 0xfffffffe
    PMYWIDGET   pWidget = gpWidgets;


    switch (pEvent->dwWidgetType)
    {
    case WIDGETTYPE_ASYNCREQUEST:
    {
        wsprintf (buf, "ReqID=x%x", pEvent->dwWidgetID);

        // BUGBUG want to incl the req type at some point (str table lookup)

        lIndex = SendMessage (ghwndList2, LB_ADDSTRING, 0, (LPARAM) buf);

        SendMessage(
            ghwndList2,
            LB_SETITEMDATA,
            (WPARAM) lIndex,
            (LPARAM) pEvent->pAsyncReqInfo
            );

        return;
    }
    case WIDGETTYPE_LINE:
    {
        for (lIndex = 0; pWidget; lIndex++)
        {
            if ((pWidget->dwWidgetType == WIDGETTYPE_LINE) &&
                (pWidget->dwWidgetID == pEvent->dwWidgetID))
            {
                break;
            }

            pWidget = pWidget->pNext;
        }

        if (!pWidget)
        {
            //
            // This is a dynamically created device - add it to end of the list
            //

            pWidget = MyAlloc (sizeof (MYWIDGET));

            // fix for bug 49692
            if (!pWidget) break;

            pWidget->dwWidgetID   = (DWORD) pEvent->dwWidgetID;
            pWidget->dwWidgetType = WIDGETTYPE_LINE;

            if (!gpWidgets)
            {
                gpWidgets = pWidget;
            }
            else
            {
                PMYWIDGET pLastWidget = gpWidgets;


                while (pLastWidget->pNext)
                {
                    pLastWidget = pLastWidget->pNext;
                }

                pLastWidget->pNext = pWidget;
            }

            wsprintf (buf, "Line%d (CLOSED)", pWidget->dwWidgetID);

            SendMessage (ghwndList1, LB_ADDSTRING, 0, (LPARAM) buf);
            SendMessage (ghwndList1, LB_SETITEMDATA, lIndex, (LPARAM) pWidget);
        }
        else if (pEvent->htXxx == 0)
        {
            PMYWIDGET   pWidget2 = pWidget->pNext;


            // line closing so nuke all following calls (listbox & widg list)

            while (pWidget2 && pWidget2->dwWidgetType == WIDGETTYPE_CALL)
            {
                pWidget->pNext = pWidget2->pNext;

                MyFree (pWidget2);

                pWidget2 = pWidget->pNext;

                SendMessage(
                    ghwndList1,
                    LB_DELETESTRING,
                    (WPARAM) lIndex + 1,
                    (LPARAM) 0
                    );
            }

            if (pWidget2)
            {
                pWidget2->pPrev = pWidget;
            }

            wsprintf (buf, "Line%d (CLOSED)", pEvent->dwWidgetID);

        }
        else
        {
            wsprintf (buf, "Line%d, hd=x%x, ht=x%x",
                pEvent->dwWidgetID,
                pEvent->hdXxx,
                pEvent->htXxx
                );
        }

        pWidget->hdXxx = pEvent->hdXxx;
        pWidget->htXxx = pEvent->htXxx;

        break;
    }
    case WIDGETTYPE_CALL:
    {
        LRESULT     lIndexLine = 0;
        PMYWIDGET   pLine = NULL;


        for (lIndex = 0; pWidget; lIndex++)
        {
            if ((pWidget->dwWidgetType == WIDGETTYPE_LINE) &&
                (pWidget->dwWidgetID == pEvent->dwWidgetID))
            {
                pLine = pWidget;
                lIndexLine = lIndex;
            }

            if ((pWidget->dwWidgetType == WIDGETTYPE_CALL) &&
                (pWidget->hdXxx == pEvent->hdXxx))
            {
                break;
            }

            pWidget = pWidget->pNext;
        }

        if (pWidget)
        {
            //
            // Found call in list
            //

            if (pEvent->htXxx)
            {
                //
                // Update the call's listbox entry
                //

                int i;


                for (i = 0; pEvent->dwCallState != aCallStates[i].dwVal; i++);

                wsprintf(
                    buf,
                    "  hdCall=x%x, ht=x%x, %s Addr=%d",
                    pEvent->hdXxx,
                    pEvent->htXxx,
                    aCallStates[i].pszVal,
                    pEvent->dwCallAddressID
                    );

                pWidget->dwCallState = (DWORD) pEvent->dwCallState;
            }
            else
            {
                //
                // Call was destroyed, so remove it from the listbox &
                // widget lists and nuke the data structure
                //

                SendMessage(
                    ghwndList1,
                    LB_DELETESTRING,
                    (WPARAM) lIndex,
                    (LPARAM) 0
                    );

                pWidget->pPrev->pNext = pWidget->pNext;

                if (pWidget->pNext)
                {
                    pWidget->pNext->pPrev = pWidget->pPrev;
                }

                MyFree (pWidget);

                return;
            }
        }
        else if (pEvent->htXxx)
        {
            //
            // Call wasn't in the list, but it's valid so add it to
            // listbox & widget lists
            //

            int i;


            pWidget = MyAlloc (sizeof (MYWIDGET));

            // fix for bug 49693
            if (!pWidget) break;

            memcpy (pWidget, pEvent, sizeof (WIDGETEVENT));

            if ((pWidget->pNext = pLine->pNext))
            {
                pWidget->pNext->pPrev = pWidget;
            }

            pWidget->pPrev = pLine;
            pLine->pNext = pWidget;

            for (i = 0; pEvent->dwCallState != aCallStates[i].dwVal; i++);

            wsprintf(
                buf,
                "  hdCall=x%x, ht=x%x, %s Addr=%d",
                pEvent->hdXxx,
                pEvent->htXxx,
                aCallStates[i].pszVal,
                pEvent->dwCallAddressID
                );

            SendMessage(
                ghwndList1,
                LB_INSERTSTRING,
                (WPARAM) lIndexLine + 1,
                (LPARAM) buf
                );

            SendMessage(
                ghwndList1,
                LB_SETITEMDATA,
                (WPARAM) lIndexLine + 1,
                (LPARAM) pWidget
                );

            return;
        }

        break;
    }
    case WIDGETTYPE_PHONE:
    {
        for (lIndex = 0; pWidget; lIndex++)
        {
            if ((pWidget->dwWidgetType == WIDGETTYPE_PHONE) &&
                (pWidget->dwWidgetID == pEvent->dwWidgetID))
            {
                break;
            }

            pWidget = pWidget->pNext;
        }

        if (!pWidget)
        {
            //
            // This is a dynamically created device - add it to end of the list
            //

            pWidget = MyAlloc (sizeof (MYWIDGET));

            pWidget->dwWidgetID   = (DWORD) pEvent->dwWidgetID;
            pWidget->dwWidgetType = WIDGETTYPE_PHONE;

            if (!gpWidgets)
            {
                gpWidgets = pWidget;
            }
            else
            {
                PMYWIDGET pLastWidget = gpWidgets;


                while (pLastWidget->pNext)
                {
                    pLastWidget = pLastWidget->pNext;
                }

                pLastWidget->pNext = pWidget;
            }

            wsprintf (buf, "Phone%d (CLOSED)", pWidget->dwWidgetID);

            SendMessage (ghwndList1, LB_ADDSTRING, 0, (LPARAM) buf);
            SendMessage (ghwndList1, LB_SETITEMDATA, lIndex, (LPARAM) pWidget);
        }
        else if (pEvent->htXxx == 0)
        {
            wsprintf (buf, "Phone%d (CLOSED)", pEvent->dwWidgetID);
        }
        else
        {
            wsprintf (buf, "Phone%d, hd=x%x, ht=x%x",
                pEvent->dwWidgetID,
                pEvent->hdXxx,
                pEvent->htXxx
                );
        }

        pWidget->hdXxx = pEvent->hdXxx;
        pWidget->htXxx = pEvent->htXxx;

        break;
    }
    case WIDGETTYPE_STARTUP:
    {
        //
        // Build widget list for "static" devices
        //

        DWORD       i, j;
        PMYWIDGET   pWidget, pLastWidget = NULL;


        for (i = 0; i < pEvent->dwNumLines; i++)
        {
            pWidget = MyAlloc (sizeof (MYWIDGET));

            pWidget->dwWidgetID   = i + (DWORD) pEvent->dwLineDeviceIDBase;
            pWidget->dwWidgetType = WIDGETTYPE_LINE;

            if ((pWidget->pPrev = pLastWidget))
            {
                pLastWidget->pNext = pWidget;
            }
            else
            {
                gpWidgets = pWidget;
            }

            pLastWidget = pWidget;

            wsprintf (buf, "Line%d (CLOSED)", pWidget->dwWidgetID);

            SendMessage (ghwndList1, LB_ADDSTRING, 0, (LPARAM) buf);
            SendMessage (ghwndList1, LB_SETITEMDATA, i, (LPARAM) pWidget);
        }

        for (j = 0; j < pEvent->dwNumPhones; j++)
        {
            pWidget = MyAlloc (sizeof (MYWIDGET));

            pWidget->dwWidgetID   = j + (DWORD) pEvent->dwPhoneDeviceIDBase;
            pWidget->dwWidgetType = WIDGETTYPE_PHONE;

            if ((pWidget->pPrev = pLastWidget))
            {
                pLastWidget->pNext = pWidget;
            }
            else
            {
                gpWidgets = pWidget;
            }

            pLastWidget = pWidget;

            wsprintf (buf, "Phone%d (CLOSED)", pWidget->dwWidgetID);

            SendMessage (ghwndList1, LB_ADDSTRING, 0, (LPARAM) buf);
            SendMessage (ghwndList1, LB_SETITEMDATA, i + j, (LPARAM) pWidget);
        }

        return;
    }
    } // switch (pEvent->dwWidgetType)


    //
    // Update the widget's listbox entry given the index &
    // description filled in above
    //

    SendMessage (ghwndList1, LB_DELETESTRING, (WPARAM) lIndex, (LPARAM) 0);
    SendMessage (ghwndList1, LB_INSERTSTRING, (WPARAM) lIndex, (LPARAM) buf);
    SendMessage (ghwndList1, LB_SETITEMDATA, (WPARAM) lIndex, (LPARAM)pWidget);
}


void
UpdateESPOptions(
    void
    )
{
    if (gbESPLoaded)
    {
        RpcTryExcept
        {
            ESPSetOptions(
                (long) gdwDebugOptions,
                (long) gdwCompletionMode
                );
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
	   		ShowStr ("UpdateESPOptions: EXCEPTION while calling ESPSetOptions()");
        }
        RpcEndExcept
    }
}


void
SaveIniFileSettings(
    void
    )
{
    RECT rect;


    GetWindowRect (ghwndMain, &rect);

    {
        typedef struct _YYY
        {
            LPCSTR   pszValueName;

            DWORD    dwValue;

        } YYY, *PYYY;

        YYY ayyy[] =
        {
            { "Left",               (DWORD) rect.left             },
            { "Top",                (DWORD) rect.top              },
            { "Right",              (DWORD) rect.right            },
            { "Bottom",             (DWORD) rect.bottom           },
            { "cxWnd",              (DWORD) cxWnd                 },
            { "cxList1",            (DWORD) cxList1               },
            { "AutoClose",          (DWORD) gbAutoClose           },
            { "DebugOutput",        (DWORD) gdwDebugOptions       },
            { "Completion",         (DWORD) gdwCompletionMode     },
            { "TSPIVersion",        (DWORD) gdwTSPIVersion        },
            { "NumLines",           (DWORD) gdwNumLines           },
            { "NumAddrsPerLine",    (DWORD) gdwNumAddrsPerLine    },
            { "NumCallsPerAddr",    (DWORD) gdwNumCallsPerAddr    },
            { "NumPhones",          (DWORD) gdwNumPhones          },
            { "AutoGatherGenerateMsgs", (DWORD) gbAutoGatherGenerateMsgs },
            { "DisableUI",          (DWORD) gbDisableUI           },
            { NULL,                 (DWORD) 0                     }
        };
        DWORD   i = (IsIconic (ghwndMain) ? 6 : 0); // don't chg pos if iconic


        for (i = 0; ayyy[i].pszValueName; i++)
        {
            char buf[16];


            wsprintf (buf, "%d", ayyy[i].dwValue);

            WriteProfileString (szMySection, ayyy[i].pszValueName, buf);
        }
    }
}


void
xxxShowStr(
    char   *psz
    )
{
    SendMessage (ghwndEdit, EM_SETSEL, (WPARAM)0xfffffffd, (LPARAM)0xfffffffe);
    SendMessage (ghwndEdit, EM_REPLACESEL, 0, (LPARAM) psz);
    SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
}


void
ShowStr(
    char   *pszFormat,
    ...
    )
{
    char    buf[256];
    va_list ap;


    va_start(ap, pszFormat);

    wvsprintf (buf, pszFormat, ap);

    strcat (buf, "\r\n");

    xxxShowStr (buf);

    va_end(ap);
}


LPVOID
MyAlloc(
    size_t numBytes
    )
{
    LPVOID p = (LPVOID) LocalAlloc (LPTR, numBytes);


    if (!p)
    {
        ShowStr ("Error: MyAlloc () failed");
    }

    return p;
}


void
MyFree(
    LPVOID  p
    )
{
#if DBG

    //
    // Fill the buf to free with 0x5a's to facilitate debugging
    //

    memset (p, 0x5a, (size_t) LocalSize (LocalHandle (p)));

#endif

    LocalFree (p);
}


void
__RPC_FAR *
__RPC_API
midl_user_allocate(
    size_t len
    )
{
    return NULL;
}


void
__RPC_API
midl_user_free(
    void __RPC_FAR * ptr
    )
{
}


BOOL
ScanForDWORD(
   char far     *pBuf,
   ULONG_PTR    *lpdw
   )
{
    char        c;
    BOOL        bValid = FALSE;
    ULONG_PTR   d = 0;


    while ((c = *pBuf))
    {
        if ((c >= '0') && (c <= '9'))
        {
            c -= '0';
        }
        else if ((c >= 'a') && (c <= 'f'))
        {
            c -= ('a' - 10);
        }
        else if ((c >= 'A') && (c <= 'F'))
        {
            c -= ('A' - 10);
        }
        else
        {
            break;
        }

        bValid = TRUE;

        d *= 16;

        d += (ULONG_PTR) c;

        pBuf++;
    }

    if (bValid)
    {
        *lpdw = d;
    }

    return bValid;
}


INT_PTR
CALLBACK
ValuesDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD   i;

    static  HWND                hwndCombo, hwndList1, hwndList2;
    static  LRESULT             lLastSel;
    static  char                szComboText[MAX_STRING_PARAM_SIZE];
    static  PEVENT_PARAM_HEADER pParamsHeader;


    switch (msg)
    {
    case WM_INITDIALOG:
    {
        hwndList1 = GetDlgItem (hwnd, IDC_LIST1);
        hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
        hwndCombo = GetDlgItem (hwnd, IDC_COMBO1);

        lLastSel = -1;
        pParamsHeader = (PEVENT_PARAM_HEADER) lParam;


        //
        // Limit the max text length for the combobox's edit field
        // (NOTE: A combobox ctrl actually has two child windows: a
        // edit ctrl & a listbox.  We need to get the hwnd of the
        // child edit ctrl & send it the LIMITTEXT msg.)
        //

        {
            HWND hwndChild = GetWindow (hwndCombo, GW_CHILD);


            while (hwndChild)
            {
                char buf[8];


                GetClassName (hwndChild, buf, 7);

                if (_stricmp (buf, "edit") == 0)
                {
                    break;
                }

                hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
            }

            SendMessage(
                hwndChild,
                EM_LIMITTEXT,
                (WPARAM) MAX_STRING_PARAM_SIZE - 1,
                0
                );
        }


        //
        // Misc other init
        //

        SetWindowText (hwnd, pParamsHeader->pszDlgTitle);

        for (i = 0; i < pParamsHeader->dwNumParams; i++)
        {
            SendMessage(
                hwndList1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) pParamsHeader->aParams[i].szName
                );
        }

        break;
    }
    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDOK:

            if (lLastSel != -1)
            {
                char buf[MAX_STRING_PARAM_SIZE];


                //
                // Save val of currently selected param
                //

                i = GetDlgItemText(
                    hwnd,
                    IDC_COMBO1,
                    buf,
                    MAX_STRING_PARAM_SIZE - 1
                    );

                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_STRING:
                {
                    LRESULT lComboSel;


                    lComboSel = SendMessage (hwndCombo, CB_GETCURSEL, 0, 0);

                    if (lComboSel == 0) // "NULL string (dwXxxSize = 0)"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }
                    else // "Valid string"
                    {
                        strncpy(
                            pParamsHeader->aParams[lLastSel].buf,
                            buf,
                            MAX_STRING_PARAM_SIZE - 1
                            );

                        pParamsHeader->aParams[lLastSel].buf
                            [MAX_STRING_PARAM_SIZE-1] = 0;

                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            pParamsHeader->aParams[lLastSel].buf;
                    }

                    break;
                }
                case PT_DWORD:
                case PT_FLAGS:
                case PT_ORDINAL:
                {
                    if (!ScanForDWORD(
                            buf,
                            &pParamsHeader->aParams[lLastSel].dwValue
                            ))
                    {
                        //
                        // Default to 0
                        //

                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }

                    break;
                }
                } // switch
            }

            // Drop thru to IDCANCEL cleanup code

        case IDCANCEL:

            EndDialog (hwnd, (int)LOWORD(wParam));
            break;

        case IDC_LIST1:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                char    buf[MAX_STRING_PARAM_SIZE] = "";
                LPCSTR  lpstr = buf;
                LRESULT lSel = SendMessage (hwndList1, LB_GETCURSEL, 0, 0);


                if (lLastSel != -1)
                {
                    //
                    // Save the old param value
                    //

                    i = GetWindowText(
                        hwndCombo,
                        buf,
                        MAX_STRING_PARAM_SIZE - 1
                        );

                    switch (pParamsHeader->aParams[lLastSel].dwType)
                    {
                    case PT_STRING:
                    {
                        LRESULT lComboSel;


                        lComboSel = SendMessage (hwndCombo, CB_GETCURSEL, 0,0);

                        if (lComboSel == 0) // "NULL string (dwXxxSize = 0)"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }
                        else // "Valid string" or no sel
                        {
                            strncpy(
                                pParamsHeader->aParams[lLastSel].buf,
                                buf,
                                MAX_STRING_PARAM_SIZE - 1
                                );

                            pParamsHeader->aParams[lLastSel].buf[MAX_STRING_PARAM_SIZE - 1] = 0;

                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR)
                                    pParamsHeader->aParams[lLastSel].buf;
                        }

                        break;
                    }
                    case PT_DWORD:
                    case PT_FLAGS:
                    case PT_ORDINAL:
                    {
                        if (!ScanForDWORD(
                                buf,
                                &pParamsHeader->aParams[lLastSel].dwValue
                                ))
                        {
                            //
                            // Default to 0
                            //

                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }

                        break;
                    }
                    } // switch
                }


                SendMessage (hwndList2, LB_RESETCONTENT, 0, 0);
                SendMessage (hwndCombo, CB_RESETCONTENT, 0, 0);

                switch (pParamsHeader->aParams[lSel].dwType)
                {
                case PT_STRING:
                {
                    char * aszOptions[] =
                    {
                        "NUL (dwXxxSize=0)",
                        "Valid string"
                    };


                    for (i = 0; i < 2; i++)
                    {
                        SendMessage(
                            hwndCombo,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) aszOptions[i]
                            );
                    }

                    if (pParamsHeader->aParams[lSel].dwValue == 0)
                    {
                        i = 0;
                        buf[0] = 0;
                    }
                    else
                    {
                        i = 1;
                        lpstr = (LPCSTR) pParamsHeader->aParams[lSel].dwValue;
                    }

                    SendMessage (hwndCombo, CB_SETCURSEL, (WPARAM) i, 0);

                    break;
                }
                case PT_DWORD:
                {
                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "0000000"
                        );

                    if (pParamsHeader->aParams[lSel].dwDefValue)
                    {
                        //
                        // Add the default val string to the combo
                        //

                        wsprintf(
                            buf,
                            "%08lx",
                            pParamsHeader->aParams[lSel].dwDefValue
                            );

                        SendMessage(
                            hwndCombo,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) buf
                            );
                    }

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "ffffffff"
                        );

                    wsprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_ORDINAL:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].pszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue ==
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    wsprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_FLAGS:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    HWND hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].pszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue &
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select all"
                        );

                    wsprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                } //switch

                SetWindowText (hwndCombo, lpstr);

                lLastSel = lSel;
            }
            break;

        case IDC_LIST2:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                //
                // BUGBUG in the PT_ORDINAL case we should compare the
                // currently selected item(s) against the previous DWORD
                // val and figure out which item we need to deselect,
                // if any, in order to maintain a mutex of values
                //

                char        buf[16];
                LONG        i;
                int far    *ai;
                LRESULT     lSelCount =
                                SendMessage (hwndList2, LB_GETSELCOUNT, 0, 0);
                PLOOKUP     pLookup = (PLOOKUP)
                                pParamsHeader->aParams[lLastSel].pLookup;
                ULONG_PTR   dwValue = 0;


                ai = (int far *) MyAlloc ((size_t)lSelCount * sizeof(int));

                SendMessage(
                    hwndList2,
                    LB_GETSELITEMS,
                    (WPARAM) lSelCount,
                    (LPARAM) ai
                    );

                if (pParamsHeader->aParams[lLastSel].dwType == PT_FLAGS)
                {
                    for (i = 0; i < lSelCount; i++)
                    {
                        dwValue |= pLookup[ai[i]].dwVal;
                    }
                }
                else // if (.dwType == PT_ORDINAL)
                {
                    if (lSelCount == 1)
                    {
                        dwValue = pLookup[ai[0]].dwVal;
                    }
                    else if (lSelCount == 2)
                    {
                        //
                        // Figure out which item we need to de-select, since
                        // we're doing ordinals & only want 1 item selected
                        // at a time
                        //

                        GetWindowText (hwndCombo, buf, 16);

                        if (ScanForDWORD (buf, &dwValue))
                        {
                            if (pLookup[ai[0]].dwVal == dwValue)
                            {
                                SendMessage(
                                    hwndList2,
                                    LB_SETSEL,
                                    0,
                                    (LPARAM) ai[0]
                                    );

                                dwValue = pLookup[ai[1]].dwVal;
                            }
                            else
                            {
                                SendMessage(
                                    hwndList2,
                                    LB_SETSEL,
                                    0,
                                    (LPARAM) ai[1]
                                    );

                                dwValue = pLookup[ai[0]].dwVal;
                            }
                        }
                        else
                        {
                            // BUGBUG de-select items???

                            dwValue = 0;
                        }
                    }
                    else if (lSelCount > 2)
                    {
                        //
                        // Determine previous selection & de-select all the
                        // latest selections
                        //

                        GetDlgItemText (hwnd, IDC_COMBO1, buf, 16);

                        if (ScanForDWORD (buf, &dwValue))
                        {
                            for (i = 0; i < lSelCount; i++)
                            {
                                if (pLookup[ai[i]].dwVal != dwValue)
                                {
                                    SendMessage(
                                        hwndList2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[i]
                                        );
                                }
                            }
                        }
                        else
                        {
                            // BUGBUG de-select items???

                            dwValue = 0;
                        }
                    }
                }

                MyFree (ai);
                wsprintf (buf, "%08lx", dwValue);
                SetWindowText (hwndCombo, buf);
            }
            break;

        case IDC_COMBO1:

            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
            {
                LRESULT lSel =  SendMessage (hwndCombo, CB_GETCURSEL, 0, 0);


                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_ORDINAL:

                    //
                    // The only option here is "select none"
                    //

                    strcpy (szComboText, "00000000");
                    PostMessage (hwnd, WM_USER+55, 0, 0);
                    break;

                case PT_FLAGS:
                {
                    BOOL bSelect = (lSel ? TRUE : FALSE);

                    SendMessage(
                        hwndList2,
                        LB_SETSEL,
                        (WPARAM) bSelect,
                        (LPARAM) -1
                        );

                    if (bSelect)
                    {
                        PLOOKUP pLookup = (PLOOKUP)
                            pParamsHeader->aParams[lLastSel].pLookup;
                        DWORD dwValue = 0;
                        int far *ai;
                        LONG    i;
                        LRESULT lSelCount =
                            SendMessage (hwndList2, LB_GETSELCOUNT, 0, 0);


                        ai = (int far *) MyAlloc(
                            (size_t)lSelCount * sizeof(int)
                            );

                        SendMessage(
                            hwndList2,
                            LB_GETSELITEMS,
                            (WPARAM) lSelCount,
                            (LPARAM) ai
                            );

                        for (i = 0; i < lSelCount; i++)
                        {
                            dwValue |= pLookup[ai[i]].dwVal;
                        }

                        MyFree (ai);
                        wsprintf (szComboText, "%08lx", dwValue);

                    }
                    else
                    {
                        strcpy (szComboText, "00000000");
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;
                }
                case PT_STRING:

                    if (lSel == 1)
                    {
                        strncpy(
                            szComboText,
                            pParamsHeader->aParams[lLastSel].buf,
                            MAX_STRING_PARAM_SIZE
                            );

                        szComboText[MAX_STRING_PARAM_SIZE-1] = 0;
                    }
                    else
                    {
                        szComboText[0] = 0;
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;

                case PT_DWORD:

                    break;

                } // switch
                break;
            }
            case CBN_EDITCHANGE:
            {
                //
                // If user entered text in the edit field then copy the
                // text to our buffer
                //

                if (pParamsHeader->aParams[lLastSel].dwType == PT_STRING)
                {
                    char buf[MAX_STRING_PARAM_SIZE];


                    GetWindowText (hwndCombo, buf, MAX_STRING_PARAM_SIZE);

                    strncpy(
                        pParamsHeader->aParams[lLastSel].buf,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    pParamsHeader->aParams[lLastSel].buf
                        [MAX_STRING_PARAM_SIZE-1] = 0;
                }
                break;
            }
            } // switch

        } // switch

        break;
    }
    case WM_USER+55:

        SetWindowText (hwndCombo, szComboText);
        break;

    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\idl\makefile.inc ===
#
# this is the midl compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#


!if "$(OS)" == "Windows_NT"

!INCLUDE $(NTMAKEENV)\makefile.plt

INCS  = -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH)

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES) $(MIDL_OPTIMIZATION)

!else

FLAGS = -D_X86_ -Di386 -D_WCHAR_T_DEFINED
CPP = -cpp_cmd "cl" -cpp_opt "-E $(FLAGS) $(INCS) $(C_DEFINES)"

HEADER_TARGETS =

!endif



IDL_NAME       = espidl
CLIENT_TARGETS = $(O)\$(IDL_NAME)_c.c
SERVER_TARGETS = $(O)\$(IDL_NAME)_s.c
EXTRN_DEPENDS  =


#
# Define Products and Dependencies
#

all:    $(CLIENT_TARGETS) $(SERVER_TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delete_source all

delete_source:
    -erase $(CLIENT_TARGETS) $(SERVER_TARGETS)

#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : $(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -server none -oldnames -error allocation -error ref -out .\$(O) -ms_ext -c_ext $(CPP) $(IDL_NAME).idl $(INCS)


$(SERVER_TARGETS) : $(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -client none -oldnames -error stub_data -error allocation -error ref -out .\$(O) -ms_ext -c_ext $(CPP) $(IDL_NAME).idl $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by ESP.RC
//
#define IDR_MENU1                       101
#define IDD_DIALOG1                     102
#define IDD_DIALOG2                     103
#define IDI_ICON1                       104
#define IDD_DIALOG3                     105
#define IDD_DIALOG4                     106
#define IDD_DIALOG5                     107
#define IDR_ACCELERATOR1                108
#define IDC_LIST1                       1000
#define IDC_LIST2                       1001
#define IDC_LIST3                       1002
#define IDC_EDIT1                       1003
#define IDC_STATIC1                     1004
#define IDC_BUTTON1                     1005
#define IDC_BUTTON2                     1006
#define IDC_BUTTON3                     1007
#define IDC_BUTTON4                     1009
#define IDC_COMBO1                      1010
#define IDC_F1HELP                      1011
#define IDC_PREVCTRL                    1012
#define IDC_NEXTCTRL                    1013
#define IDC_ENTER                       1014
#define IDC_LIST4                       1015
#define IDC_RESET                       1016
#define IDM_ABOUT                       40000
#define IDM_EXIT                        40001
#define IDM_SHOWFUNCENTRY               40002
#define IDM_SHOWFUNCPARAMS              40003
#define IDM_SHOWFUNCEXIT                40004
#define IDM_SHOWEVENTS                  40005
#define IDM_SHOWCOMPLETIONS             40006
#define IDM_MANUALRESULTS               40007
#define IDM_DEBUGBREAK                  40008
#define IDM_SHOWALL                     40009
#define IDM_SHOWNONE                    40010
#define IDM_OUTCALLSTATEPROG            40011
#define IDM_AUTOCLOSE                   40012
#define IDM_INSTALL                     40013
#define IDM_UNINSTALL                   40014
#define IDM_USAGE                       40015
#define IDM_DUMPGLOBALS                 40016
#define IDM_SYNCCOMPL                   40017
#define IDM_ASYNCCOMPL                  40018
#define IDM_SYNCASYNCCOMPL              40019
#define IDM_MANUALCOMPL                 40020
#define IDM_DEFAULTS                    40021
#define IDM_DISABLEUI                   40022
#define IDM_PBXCONFIG                   40023
#define IDM_PBXSTART                    40024
#define IDM_PBXSTOP                     40025
#define IDM_AUTOGATHERGENERATEMSGS      40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\esp.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    esp.h

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    18-Sep-1995

Revision History:


Notes:


--*/


#include "windows.h"
#include "intrface.h"
#include "tapi.h"
#include "tspi.h"
#include "espidl.h"


#define DRVLINE_KEY                             ((DWORD) 'LPSE')
#define DRVPHONE_KEY                            ((DWORD) 'PPSE')
#define DRVCALL_KEY                             ((DWORD) 'CPSE')
#define INVAL_KEY                               ((DWORD) 'XPSE')

#define SYNC                                    0
#define ASYNC                                   1

#define LINE_ICON                               1
#define PHONE_ICON                              2
#define IDD_DIALOG1                             3

#define IDC_LIST1                               1001
#define IDC_COMBO1                              1002
#define IDC_LIST2                               1003

#define MAX_STRING_PARAM_SIZE                   32

#define PT_DWORD                                1
#define PT_FLAGS                                2
#define PT_STRING                               3
#define PT_ORDINAL                              4

#define DEF_NUM_ASYNC_REQUESTS_IN_QUEUE         256
#define DEF_NUM_EXTRA_LOOKUP_ENTRIES            32

#define MAX_VAR_DATA_SIZE                       1024

#define MAX_NUM_COMPLETION_MESSAGES             100

#define PHONE_DISPLAY_SIZE_IN_CHARS             32
#define PHONE_DISPLAY_SIZE_IN_BYTES             (PHONE_DISPLAY_SIZE_IN_CHARS * sizeof (WCHAR))

#define SANITYCHECKKEYWORD		0x11223344


#define AllAddrCaps1_0                            \
        (LINEADDRCAPFLAGS_FWDNUMRINGS           | \
        LINEADDRCAPFLAGS_PICKUPGROUPID          | \
        LINEADDRCAPFLAGS_SECURE                 | \
        LINEADDRCAPFLAGS_BLOCKIDDEFAULT         | \
        LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        | \
        LINEADDRCAPFLAGS_DIALED                 | \
        LINEADDRCAPFLAGS_ORIGOFFHOOK            | \
        LINEADDRCAPFLAGS_DESTOFFHOOK            | \
        LINEADDRCAPFLAGS_FWDCONSULT             | \
        LINEADDRCAPFLAGS_SETUPCONFNULL          | \
        LINEADDRCAPFLAGS_AUTORECONNECT          | \
        LINEADDRCAPFLAGS_COMPLETIONID           | \
        LINEADDRCAPFLAGS_TRANSFERHELD           | \
        LINEADDRCAPFLAGS_TRANSFERMAKE           | \
        LINEADDRCAPFLAGS_CONFERENCEHELD         | \
        LINEADDRCAPFLAGS_CONFERENCEMAKE         | \
        LINEADDRCAPFLAGS_PARTIALDIAL            | \
        LINEADDRCAPFLAGS_FWDSTATUSVALID         | \
        LINEADDRCAPFLAGS_FWDINTEXTADDR          | \
        LINEADDRCAPFLAGS_FWDBUSYNAADDR          | \
        LINEADDRCAPFLAGS_ACCEPTTOALERT          | \
        LINEADDRCAPFLAGS_CONFDROP               | \
        LINEADDRCAPFLAGS_PICKUPCALLWAIT)

#define AllAddrCaps2_0                            \
        (AllAddrCaps1_0                         | \
        LINEADDRCAPFLAGS_PREDICTIVEDIALER       | \
        LINEADDRCAPFLAGS_QUEUE                  | \
        LINEADDRCAPFLAGS_ROUTEPOINT             | \
        LINEADDRCAPFLAGS_HOLDMAKESNEW           | \
        LINEADDRCAPFLAGS_NOINTERNALCALLS        | \
        LINEADDRCAPFLAGS_NOEXTERNALCALLS        | \
        LINEADDRCAPFLAGS_SETCALLINGID)

#define AllAddrFeatures1_0                        \
        (LINEADDRFEATURE_FORWARD                | \
        LINEADDRFEATURE_MAKECALL                | \
        LINEADDRFEATURE_PICKUP                  | \
        LINEADDRFEATURE_SETMEDIACONTROL         | \
        LINEADDRFEATURE_SETTERMINAL             | \
        LINEADDRFEATURE_SETUPCONF               | \
        LINEADDRFEATURE_UNCOMPLETECALL          | \
        LINEADDRFEATURE_UNPARK)

#define AllAddrFeatures2_0                        \
        (AllAddrFeatures1_0                     | \
        LINEADDRFEATURE_PICKUPHELD              | \
        LINEADDRFEATURE_PICKUPGROUP             | \
        LINEADDRFEATURE_PICKUPDIRECT            | \
        LINEADDRFEATURE_PICKUPWAITING           | \
        LINEADDRFEATURE_FORWARDFWD              | \
        LINEADDRFEATURE_FORWARDDND)

#define AllBearerModes1_0                         \
        (LINEBEARERMODE_VOICE                   | \
        LINEBEARERMODE_SPEECH                   | \
        LINEBEARERMODE_MULTIUSE                 | \
        LINEBEARERMODE_DATA                     | \
        LINEBEARERMODE_ALTSPEECHDATA            | \
        LINEBEARERMODE_NONCALLSIGNALING)

#define AllBearerModes1_4                         \
        (AllBearerModes1_0                      | \
        LINEBEARERMODE_PASSTHROUGH)

#define AllBearerModes2_0                         \
        (AllBearerModes1_4                      | \
        LINEBEARERMODE_RESTRICTEDDATA)

#define AllCallFeatures1_0                        \
        (LINECALLFEATURE_ACCEPT                 | \
        LINECALLFEATURE_ADDTOCONF               | \
        LINECALLFEATURE_ANSWER                  | \
        LINECALLFEATURE_BLINDTRANSFER           | \
        LINECALLFEATURE_COMPLETECALL            | \
        LINECALLFEATURE_COMPLETETRANSF          | \
        LINECALLFEATURE_DIAL                    | \
        LINECALLFEATURE_DROP                    | \
        LINECALLFEATURE_GATHERDIGITS            | \
        LINECALLFEATURE_GENERATEDIGITS          | \
        LINECALLFEATURE_GENERATETONE            | \
        LINECALLFEATURE_HOLD                    | \
        LINECALLFEATURE_MONITORDIGITS           | \
        LINECALLFEATURE_MONITORMEDIA            | \
        LINECALLFEATURE_MONITORTONES            | \
        LINECALLFEATURE_PARK                    | \
        LINECALLFEATURE_PREPAREADDCONF          | \
        LINECALLFEATURE_REDIRECT                | \
        LINECALLFEATURE_REMOVEFROMCONF          | \
        LINECALLFEATURE_SECURECALL              | \
        LINECALLFEATURE_SENDUSERUSER            | \
        LINECALLFEATURE_SETCALLPARAMS           | \
        LINECALLFEATURE_SETMEDIACONTROL         | \
        LINECALLFEATURE_SETTERMINAL             | \
        LINECALLFEATURE_SETUPCONF               | \
        LINECALLFEATURE_SETUPTRANSFER           | \
        LINECALLFEATURE_SWAPHOLD                | \
        LINECALLFEATURE_UNHOLD)

#define AllCallFeatures1_4                        \
        (AllCallFeatures1_0                     | \
        LINECALLFEATURE_RELEASEUSERUSERINFO)

#define AllCallFeatures2_0                        \
        (AllCallFeatures1_4                     | \
        LINECALLFEATURE_SETTREATMENT            | \
        LINECALLFEATURE_SETQOS                  | \
        LINECALLFEATURE_SETCALLDATA)

#define AllCallFeaturesTwo                        \
        (LINECALLFEATURE2_NOHOLDCONFERENCE      | \
        LINECALLFEATURE2_COMPLCAMPON            | \
        LINECALLFEATURE2_COMPLCALLBACK          | \
        LINECALLFEATURE2_COMPLINTRUDE           | \
        LINECALLFEATURE2_COMPLMESSAGE           | \
        LINECALLFEATURE2_TRANSFERNORM           | \
        LINECALLFEATURE2_TRANSFERCONF           | \
        LINECALLFEATURE2_PARKDIRECT             | \
        LINECALLFEATURE2_PARKNONDIRECT)

//        LINECALLFEATURE2_ONESTEPTRANSFER        | \

#define AllLineFeatures1_0                        \
        (LINEFEATURE_DEVSPECIFIC                | \
        LINEFEATURE_DEVSPECIFICFEAT             | \
        LINEFEATURE_FORWARD                     | \
        LINEFEATURE_MAKECALL                    | \
        LINEFEATURE_SETMEDIACONTROL             | \
        LINEFEATURE_SETTERMINAL)

#define AllLineFeatures2_0                        \
        (AllLineFeatures1_0                     | \
        LINEFEATURE_SETDEVSTATUS                | \
        LINEFEATURE_FORWARDFWD                  | \
        LINEFEATURE_FORWARDDND)

#define AllMediaModes1_0                          \
        (LINEMEDIAMODE_UNKNOWN                  | \
        LINEMEDIAMODE_INTERACTIVEVOICE          | \
        LINEMEDIAMODE_AUTOMATEDVOICE            | \
        LINEMEDIAMODE_DATAMODEM                 | \
        LINEMEDIAMODE_G3FAX                     | \
        LINEMEDIAMODE_TDD                       | \
        LINEMEDIAMODE_G4FAX                     | \
        LINEMEDIAMODE_DIGITALDATA               | \
        LINEMEDIAMODE_TELETEX                   | \
        LINEMEDIAMODE_VIDEOTEX                  | \
        LINEMEDIAMODE_TELEX                     | \
        LINEMEDIAMODE_MIXED                     | \
        LINEMEDIAMODE_ADSI)

#define AllMediaModes1_4                          \
        (AllMediaModes1_0                       | \
        LINEMEDIAMODE_VOICEVIEW)

#define AllMediaModes2_1                          \
        (AllMediaModes1_4                       | \
        LINEMEDIAMODE_VIDEO)

#define AllHookSwitchDevs                         \
        (PHONEHOOKSWITCHDEV_HANDSET             | \
        PHONEHOOKSWITCHDEV_SPEAKER              | \
        PHONEHOOKSWITCHDEV_HEADSET)

#define AllHookSwitchModes                        \
        (PHONEHOOKSWITCHMODE_ONHOOK             | \
        PHONEHOOKSWITCHMODE_MIC                 | \
        PHONEHOOKSWITCHMODE_SPEAKER             | \
        PHONEHOOKSWITCHMODE_MICSPEAKER          | \
        PHONEHOOKSWITCHMODE_UNKNOWN)

#define AllPhoneFeatures                          \
        (PHONEFEATURE_GETBUTTONINFO             | \
        PHONEFEATURE_GETDATA                    | \
        PHONEFEATURE_GETDISPLAY                 | \
        PHONEFEATURE_GETGAINHANDSET             | \
        PHONEFEATURE_GETGAINSPEAKER             | \
        PHONEFEATURE_GETGAINHEADSET             | \
        PHONEFEATURE_GETHOOKSWITCHHANDSET       | \
        PHONEFEATURE_GETHOOKSWITCHSPEAKER       | \
        PHONEFEATURE_GETHOOKSWITCHHEADSET       | \
        PHONEFEATURE_GETLAMP                    | \
        PHONEFEATURE_GETRING                    | \
        PHONEFEATURE_GETVOLUMEHANDSET           | \
        PHONEFEATURE_GETVOLUMESPEAKER           | \
        PHONEFEATURE_GETVOLUMEHEADSET           | \
        PHONEFEATURE_SETBUTTONINFO              | \
        PHONEFEATURE_SETDATA                    | \
        PHONEFEATURE_SETDISPLAY                 | \
        PHONEFEATURE_SETGAINHANDSET             | \
        PHONEFEATURE_SETGAINSPEAKER             | \
        PHONEFEATURE_SETGAINHEADSET             | \
        PHONEFEATURE_SETHOOKSWITCHHANDSET       | \
        PHONEFEATURE_SETHOOKSWITCHSPEAKER       | \
        PHONEFEATURE_SETHOOKSWITCHHEADSET       | \
        PHONEFEATURE_SETLAMP                    | \
        PHONEFEATURE_SETRING                    | \
        PHONEFEATURE_SETVOLUMEHANDSET           | \
        PHONEFEATURE_SETVOLUMESPEAKER           | \
        PHONEFEATURE_SETVOLUMEHEADSET)

typedef struct _DRVCALL
{
    DWORD                   dwKey;
    LPVOID                  pLine;
    HTAPICALL               htCall;
    DWORD                   dwAddressID;

    DWORD                   dwMediaMode;
    DWORD                   dwBearerMode;
    DWORD                   dwMinRate;
    DWORD                   dwMaxRate;

    LINEDIALPARAMS          DialParams;

    DWORD                   dwTreatment;
    DWORD                   dwCallState;
    DWORD                   dwCallStateMode;
    DWORD                   dwAppSpecific;

    DWORD                   dwSendingFlowspecSize;
    LPVOID                  pSendingFlowspec;
    DWORD                   dwReceivingFlowspecSize;
    LPVOID                  pReceivingFlowspec;

    DWORD                   dwCallDataSize;
    LPVOID                  pCallData;
    struct _DRVCALL        *pPrev;
    struct _DRVCALL        *pNext;

    struct _DRVCALL        *pConfParent;
    struct _DRVCALL        *pNextConfChild;
    struct _DRVCALL        *pDestCall;
    DWORD                   bConnectedToDestCall;

    DWORD                   dwCallInstance;
    DWORD                   dwGatherDigitsEndToEndID;
    DWORD                   dwGenerateDigitsEndToEndID;
    DWORD                   dwGenerateToneEndToEndID;

    DWORD                   dwMonitorToneListID;
    DWORD                   dwCallID;
    DWORD                   dwRelatedCallID;
    DWORD                   dwAddressType;

} DRVCALL, *PDRVCALL;


typedef struct _DRVADDRESS
{
    DWORD                   dwNumCalls;
    PDRVCALL                pCalls;

} DRVADDRESS, *PDRVADDRESS;


typedef struct _DRVLINE
{
    DWORD                   dwDeviceID;
    HTAPILINE               htLine;
    DWORD                   dwMediaModes;
     DRVADDRESS             aAddrs[1];
    DWORD                   dwMSGWAITFlag;      //smarandb added this field to test winseqfe bug #23974

} DRVLINE, *PDRVLINE;


typedef struct _DRVLINETABLE
{
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _DRVLINETABLE   *pNext;
    DRVLINE                 aLines[1];

} DRVLINETABLE, *PDRVLINETABLE;


typedef struct _DRVPHONE
{
    DWORD                   dwDeviceID;
    HTAPIPHONE              htPhone;
    DWORD                   dwHandsetGain;
    DWORD                   dwSpeakerGain;

    DWORD                   dwHeadsetGain;
    DWORD                   dwHandsetHookSwitchMode;
    DWORD                   dwSpeakerHookSwitchMode;
    DWORD                   dwHeadsetHookSwitchMode;

    DWORD                   dwHandsetVolume;
    DWORD                   dwSpeakerVolume;
    DWORD                   dwHeadsetVolume;
    DWORD                   dwRingMode;

    DWORD                   dwRingVolume;
    DWORD                   dwLampMode;
    DWORD                   dwDataSize;
    LPVOID                  pData;

    LPPHONEBUTTONINFO       pButtonInfo;
    WCHAR                  *pDisplay;

} DRVPHONE, *PDRVPHONE;


typedef struct _DRVPHONETABLE
{
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _DRVPHONETABLE  *pNext;
    DRVPHONE                aPhones[1];

} DRVPHONETABLE, *PDRVPHONETABLE;


typedef struct _ASYNC_REQUEST_INFO
{
    FARPROC                 pfnPostProcessProc;
    DWORD                   dwRequestID;
    LONG                    lResult;
    ULONG_PTR               dwParam1;

    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;
    ULONG_PTR               dwParam4;
    ULONG_PTR               dwParam5;

    ULONG_PTR               dwParam6;
    ULONG_PTR               dwParam7;
    ULONG_PTR               dwParam8;
    char                   *pszFuncName;

} ASYNC_REQUEST_INFO, far *PASYNC_REQUEST_INFO;


typedef struct _ESPGLOBALS
{
    DWORD			dwSanityCheckKeyword0;

    DWORD                   dwDebugOptions;
    DWORD                   dwCompletionMode;
    DWORD                   dwNumLines;
    DWORD                   dwNumAddressesPerLine;

    DWORD                   dwNumCallsPerAddress;
    DWORD                   dwNumPhones;
    DWORD                   dwSPIVersion;
    CRITICAL_SECTION        CallListCritSec;

    CRITICAL_SECTION        PhoneCritSec;
    HICON                   hIconLine;
    HICON                   hIconPhone;
    LINEEVENT               pfnLineEvent;

    PHONEEVENT              pfnPhoneEvent;
    ASYNC_COMPLETION        pfnCompletion;
    HPROVIDER               hProvider;
    DWORD                   dwPermanentProviderID;

    DWORD                   dwLineDeviceIDBase;
    DWORD                   dwPhoneDeviceIDBase;
    DWORD                   dwInitialNumLines;
    DWORD                   dwInitialNumPhones;

    DWORD			dwSanityCheckKeyword1;

    PDRVLINETABLE           pLines;
    PDRVPHONETABLE          pPhones;

    DWORD			dwSanityCheckKeyword2;

    BOOL                    bProviderShutdown;
    HANDLE                  hAsyncEventQueueServiceThread;

    HANDLE                  hAsyncEventsPendingEvent;
    CRITICAL_SECTION        AsyncEventQueueCritSec;
    DWORD                   dwNumTotalQueueEntries;
    DWORD                   dwNumUsedQueueEntries;

    PASYNC_REQUEST_INFO    *pAsyncRequestQueue;
    PASYNC_REQUEST_INFO    *pAsyncRequestQueueIn;
    PASYNC_REQUEST_INFO    *pAsyncRequestQueueOut;
    CRITICAL_SECTION        DebugBufferCritSec;

    DWORD                   dwDebugBufferTotalSize;
    DWORD                   dwDebugBufferUsedSize;
    char                   *pDebugBuffer;
    char                   *pDebugBufferIn;

    char                   *pDebugBufferOut;
    CRITICAL_SECTION        EventBufferCritSec;
    DWORD                   dwEventBufferTotalSize;
    DWORD                   dwEventBufferUsedSize;

    char                   *pEventBuffer;
    char                   *pEventBufferIn;
    char                   *pEventBufferOut;

    DWORD			dwSanityCheckKeyword3;
} ESPGLOBALS, *PESPGLOBALS;


typedef struct _LOOKUP
{
    DWORD                   dwVal;
    char                   *lpszVal;

} LOOKUP, *PLOOKUP;


typedef void (FAR PASCAL *POSTPROCESSPROC)(PASYNC_REQUEST_INFO, BOOL);


typedef struct _FUNC_PARAM
{
    char                   *lpszVal;
    ULONG_PTR               dwVal;
    PLOOKUP                 pLookup;

} FUNC_PARAM, *PFUNC_PARAM;


typedef struct _FUNC_INFO
{
    char                   *pszFuncName;
    DWORD                   bAsync;
    DWORD                   dwNumParams;
    PFUNC_PARAM             aParams;

    POSTPROCESSPROC         pfnPostProcessProc;
    PASYNC_REQUEST_INFO     pAsyncReqInfo;
    LONG                    lResult;

} FUNC_INFO, *PFUNC_INFO;

typedef struct _EVENT_PARAM
{
    char far           *szName;

    DWORD               dwType;

    ULONG_PTR           dwValue;

    union
    {
        PLOOKUP         pLookup;

        char far       *buf;

        LPVOID          ptr;

        ULONG_PTR       dwDefValue;

    };

} EVENT_PARAM, far *PEVENT_PARAM;


typedef struct _EVENT_PARAM_HEADER
{
    DWORD               dwNumParams;

    LPSTR               pszDlgTitle;

    DWORD               dwEventType;

    PEVENT_PARAM        aParams;

} EVENT_PARAM_HEADER, far *PEVENT_PARAM_HEADER;




#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

DWORD   gdwDebugLevel;

#else

#define DBGOUT(arg)

#endif


BOOL
Prolog(
    PFUNC_INFO pInfo
    );

LONG
Epilog(
    PFUNC_INFO pInfo
    );

void
PASCAL
DoCompletion(
    PASYNC_REQUEST_INFO pAsyncRequestInfo,
    BOOL                bAsync
    );

LONG
PASCAL
SetCallState(
    PDRVCALL    pCall,
    DWORD       dwExpectedCallInstance,
    DWORD       dwValidCurrentStates,
    DWORD       dwNewCallState,
    ULONG_PTR   dwNewCallStateMode,
    BOOL        bSendStateMsgToExe
    );

void
PASCAL
WriteEventBuffer(
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3,
    ULONG_PTR   Param4,
    ULONG_PTR   Param5,
    ULONG_PTR   Param6
    );

LPVOID
DrvAlloc(
    size_t numBytes
    );

void
DrvFree(
    LPVOID  p
    );

LONG
PASCAL
AllocCall(
    PDRVLINE            pLine,
    HTAPICALL           htCall,
    LPLINECALLPARAMS    pCallParams,
    PDRVCALL           *ppCall
    );

void
PASCAL
FreeCall(
    PDRVCALL    pCall,
    DWORD       dwExpectedCallInstance
    );

PDRVLINE
PASCAL
GetLineFromID(
    DWORD   dwDeviceID
    );

PDRVPHONE
PASCAL
GetPhoneFromID(
    DWORD   dwDeviceID
    );

BOOL
WINAPI
_CRT_INIT(
    HINSTANCE   hDLL,
    DWORD       dwReason,
    LPVOID      lpReserved
    );

VOID
ShowStr(
    BOOL    bAlertApp,
    char   *format,
    ...
    );

void
PASCAL
SendLineEvent(
    PDRVLINE    pLine,
    PDRVCALL    pCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

void
PASCAL
SendPhoneEvent(
    PDRVPHONE   pPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\devspec.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devspec.h

Abstract:

    This module contains the line/phoneDevSpecific interface
    definitions for tapi apps to pass data to esp32.tsp,
    i.e. msgs the app wants esp32.tsp to indicate

Author:

    Dan Knudson (DanKn)    25-Apr-1996

Revision History:


Notes:


--*/


#define ESPDEVSPECIFIC_KEY  ((DWORD) 'DPSE')

#define ESP_DEVSPEC_MSG     1
#define ESP_DEVSPEC_RESULT  2


//
// The following structure is used when an app wants to tell esp to
// indicate a certain message, i.e. LINE_ADDRESSSTATE.  Note that
// the fields must be filled in with values that are valid at the
// SPI level, which are not necessarily the same as those at the
// API level. (Consult the win32 sdk for more info.)  For example,
// there is no LINE_CALLDEVSPECIFIC message defined a the API level,
// but it is used at the SPI level to denote that TAPI should pass
// the corresponding call handle (rather than the line handle) to
// apps in the hDevice parameter of the LINE_DEVSPECIFIC message
//

typedef struct _ESPDEVSPECMSG
{
    DWORD           dwMsg;
    DWORD           dwParam1;
    DWORD           dwParam2;
    DWORD           dwParam3;

} ESPDEVSPECMSG, *PESPDEVSPECMSG;


//
// The following structure is used when an app wants to tell esp how
// to complete next request.  (Bear in mind that esp may override the
// app's request if it encounters an "internal" error somewhere along
// the way.)  Valid values for the "lResult" field are 0 or any of
// the LINEERR_XXX / PHONEERR_XXX constants defined in tapi.h.  Valid
// values for the "dwCompletionType" field are any of the ESP_RESULT_XXX
// values defined below.
//
// This operation allows for testing the following scenarios for
// synchronous telephony APIs:
//
//      1.  Service provider's TSPI_xxx function returns success.
//          App recives success result
//
//      2.  Service provider's TSPI_xxx function returns error.
//          App recives error result
//
// This operation allows for testing the following scenarios for
// ASYNCHRONOUS telephony APIs (in each case, app recieves a request
// id from the API, then later a LINE/PHONE_REPLY msg with a matching
// request id (dwParam1) and result (dwParam2)):
//
//      1.  Service provider's TSPI_xxx func calls tapi's completion proc
//          with success result
//
//      2.  Service provider's worker thread calls tapi's completion proc
//          with success result
//
//      3.  Service provider's TSPI_xxx function returns error
//
//      4.  Service provider's TSPI_xxx func calls tapi's completion proc
//          with error result
//
//      5.  Service provider's worker thread calls tapi's completion proc
//          with error result
//

typedef struct _ESPDEVSPECRESULT
{
    LONG            lResult;            // 0, LINEERR_XXX, PHONEERR_XXX
    DWORD           dwCompletionType;   // ESP_RESULT_XXX

} ESPDEVSPECRESULT, *PESPDEVSPECRESULT;

#define ESP_RESULT_RETURNRESULT         0
#define ESP_RESULT_CALLCOMPLPROCSYNC    1
#define ESP_RESULT_CALLCOMPLPROCASYNC   2


//
// The following structure is the device specific information
// "wrapper".  The app must initialize the dwKey & dwType fields
// to create a valid header and fill in the appropriate
// union substructure before passing the info to esp32.tsp via
// line/phoneDevSpecific.
//
// If esp32.tsp detects an invalid parameter(s) it will return an
// OPERATIONFAILED error, and spit out relevant debug information
// in the espexe.exe window.
//

typedef struct _ESPDEVSPECIFICINFO
{
    DWORD           dwKey;      // App must init this to ESPDEVSPECIFIC_KEY
    DWORD           dwType;     // App must init this to ESP_DEVSPEC_MSG, ...

    union
    {

    ESPDEVSPECMSG       EspMsg;
    ESPDEVSPECRESULT    EspResult;

    } u;

} ESPDEVSPECIFICINFO, *PESPDEVSPECIFICINFO;


/*

//
// Example: if an app wanted esp32.tsp to indicate a
//          LINE_LINEDEVSTATE\RENINIT msg it would do
//          the following
//

{
    LONG                 lResult;
    HLINE                hLine;
    ESPDEVSPECIFICINFO   info;


    // do a lineInitialize, lineNegotiateAPIVersion, lineOpen, etc...

    info.dwKey  = ESPDEVSPECIFIC_KEY;
    info.dwType = ESP_DEVSPEC_MSG;

    // make sure to use the SPI (not API) msg params here (not
    // necessarily the same)

    info.u.EspMsg.dwMsg    = LINE_LINEDEVSTATE;
    info.u.EspMsg.dwParam1 = LINEDEVSTATE_REINIT;
    info.u.EspMsg.dwParam2 = 0;
    info.u.EspMsg.dwParam3 = 0;

    lResult = lineDevSpecific (hLine, 0, NULL, &info, sizeof (info));

    // some time later a LINE_LINEDEVSTATE\REINIT msg will show up
}


//
// Example: if an app wanted esp32.tsp to fail a request
//          to lineMakeCall asynchronously with the error
//          LINEERR_CALLUNAVAIL it would do the following
//          (ESP's worker thread would complete the request
//          in this case)
//

{
    LONG                 lResult, lResult2;
    HCALL                hCall;
    HLINE                hLine;
    ESPDEVSPECIFICINFO   info;


    // do a lineInitialize, lineNegotiateAPIVersion, lineOpen, etc...

    info.dwKey  = ESPDEVSPECIFIC_KEY;
    info.dwType = ESP_DEVSPEC_RESULT;

    info.u.EspResult.lResult          = LINEERR_CALLUNAVAIL;
    info.u.EspResult.dwCompletionType = ESP_RESULT_CALLCOMPLPROCASYNC;

    lResult = lineDevSpecific (hLine, 0, NULL, &info, sizeof (info));

    lResult2 = lineMakeCall (hLine, &hCall, "555-1212", 1, NULL);

    // some time later a LINE_REPLY will show for for both the DevSpecific
    // & MakeCall requests.  the LINE_REPLY for the MakeCall will have
    // dwParam1 = lResult2, and dwParam2 = LINEERR_CALLUNAVAIL
}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\esp.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    esp.c

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    18-Sep-1995

Revision History:


Notes:

    1. Regarding the SP filling in structures with variable length fields
       (dwXxxSize/dwXxxOffset) : "The SP's variable size fields start
       immediately after the fixed part of the data structure.  The order
       of filling of the variable size fields owned by the SP is not
       specified.  The SP can fill them in any order it desires.  Filling
       should be contiguous, starting at the beginning of the variable
       part." (Taken from Chapter 2 of the SPI Programmer's Guide.)

--*/


#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
//#include "malloc.h"
#include "string.h"
#include "esp.h"
#include "devspec.h"
#include "vars.h"

#include <crtdbg.h>

#define ASSERT_SANITYCHECK _ASSERT( \
	(*gpdwSanityCheckKeyword == SANITYCHECKKEYWORD) &&\
	(gESPGlobals.dwSanityCheckKeyword0 == SANITYCHECKKEYWORD) &&\
	(gESPGlobals.dwSanityCheckKeyword1 == SANITYCHECKKEYWORD) &&\
	(gESPGlobals.dwSanityCheckKeyword2 == SANITYCHECKKEYWORD) &&\
	(gESPGlobals.dwSanityCheckKeyword3 == SANITYCHECKKEYWORD) &&\
	(gESPGlobals.pLines ? (gESPGlobals.pLines->dwNumTotalEntries == gESPGlobals.dwInitialNumLines + DEF_NUM_EXTRA_LOOKUP_ENTRIES) :1)&&\
	(gESPGlobals.pPhones ? (gESPGlobals.pPhones->dwNumTotalEntries == gESPGlobals.dwInitialNumPhones + DEF_NUM_EXTRA_LOOKUP_ENTRIES) :1)\
	)


#define MAX_NUM_PARKED_CALLS 16

LONG        glNextRequestResult = 0;
DWORD       gdwNextRequestCompletionType;
DWORD       gdwDevSpecificRequestID;
DWORD       gdwCallID = 0;
BOOL        gbExitPBXThread;
BOOL        gbDisableUI;
BOOL        gbAutoGatherGenerateMsgs;
BOOL        gbManualResults = FALSE;
BOOL        gbInteractWithDesktop = FALSE;
DWORD       gdwCallInstance = 0;
DWORD       gdwDrvLineSize;
WCHAR       gszProviderInfo[] = L"ESP v2.0";
HANDLE      ghPBXThread = NULL;
PDRVCALL    gaParkedCalls[MAX_NUM_PARKED_CALLS];
HANDLE      ghESPHeap;
DWORD 	*gpdwSanityCheckKeyword;

static WCHAR *aszDeviceClasses[] =
{
    L"tapi/line",
    L"tapi/phone",
    L"wave",
    L"wave/in",
    L"wave/out",
    L"comm",
    L"comm/datamodem",
    (WCHAR *) NULL
};


BOOL
PASCAL
IsValidDrvCall(
    PDRVCALL    pCall,
    LPDWORD     pdwCallInstance
    );

INT_PTR
CALLBACK
ValuesDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG
PASCAL
CreateIncomingCall(
    LPCWSTR             lpszDestAddress,
    LPLINECALLPARAMS    lpCallParams,
    PDRVCALL            pOutgoingCall,
    BOOL               *pbValidESPAddress,
    PDRVLINE           *ppIncomingLine,
    PDRVCALL           *ppIncomingCall
    );

LONG
PASCAL
TransferCall(
    PFUNC_INFO  pInfo,
    PDRVCALL    pCall,
    DWORD       dwValidCurrentCallStates,
    DWORD       dwNewCallState,
    LPCWSTR     lpszDestAddress
    );


int
PASCAL
My_lstrcmpiW(
    WCHAR   *pwsz1,
    WCHAR   *pwsz2
    )
{
    if (!pwsz1  ||  !pwsz2)
    {
        return 1;
    }

    for(
        ;
        *pwsz1  &&  (*pwsz1 == *pwsz2  ||  *pwsz1 == (*pwsz2 ^ 0x0020));
        pwsz1++, pwsz2++
        );

    return (*pwsz1 == *pwsz2 ? 0 : 1);
}


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    static BOOL   bLoadedByTapisrv;
    static HANDLE hInitEvent;


    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        UINT uiResult;

/* looks like this is not needed
        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            OutputDebugString ("ESP: DllMain: _CRT_INIT() failed\n\r");
        }
*/
        ghInstance = hDLL;


        //
        // Allocate a private heap (use process heap if that fails)
        //

        if (!(ghESPHeap = HeapCreate(
                0,      // return NULL on failure, serialize access
                0x1000, // initial heap size
                0       // max heap size (0 == growable)
                )))
        {
            ghESPHeap = GetProcessHeap();
        }

    // setup the sanity check keywords in gESPGlobals
    gESPGlobals.pLines = 0;
    gESPGlobals.pPhones = 0;
    gESPGlobals.dwSanityCheckKeyword0 = SANITYCHECKKEYWORD;
    gESPGlobals.dwSanityCheckKeyword1 = SANITYCHECKKEYWORD;
    gESPGlobals.dwSanityCheckKeyword2 = SANITYCHECKKEYWORD;
    gESPGlobals.dwSanityCheckKeyword3 = SANITYCHECKKEYWORD;

   // And setup the sanity check keywords at the start of the heap
   if (gpdwSanityCheckKeyword = DrvAlloc(sizeof(DWORD)) )
   	*gpdwSanityCheckKeyword = SANITYCHECKKEYWORD;
   else // no memory
   	return FALSE;

        //
        // Grab ini file settings
        //
#if DBG

        {
        HKEY    hKey;
        DWORD   dwDataSize, dwDataType;
        TCHAR   szTelephonyKey[] =
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony",
                szEsp32DebugLevel[] = "Esp32DebugLevel";


        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szTelephonyKey,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );

        dwDataSize = sizeof (DWORD);
        gdwDebugLevel=0;

        RegQueryValueEx(
            hKey,
            szEsp32DebugLevel,
            0,
            &dwDataType,
            (LPBYTE) &gdwDebugLevel,
            &dwDataSize
            );

        RegCloseKey (hKey);
        }

#endif
        //
        // Determine whether we're being loaded by tapisrv or some
        // other process (i.e. telephony ctrl panel)- this will tell
        // us whether we need to go thru all the necessary init or not
        //

        if (!(GetVersion() & 0x80000000)) // Win NT
        {
            char           *pszProcessName;
            STARTUPINFO     si;


            GetStartupInfoA (&si);

            pszProcessName = si.lpTitle + (lstrlenA (si.lpTitle) - 1);

            for (; pszProcessName != si.lpTitle; pszProcessName--)
            {
                if (*pszProcessName == '\\')
                {
                    pszProcessName++;
                    break;
                }
            }

            if (lstrcmpiA (pszProcessName, "tapisrv.exe") == 0  ||
                lstrcmpiA (pszProcessName, "svchost.exe") == 0)
            {
                bLoadedByTapisrv = TRUE;
            }
            else
            {
                bLoadedByTapisrv = FALSE;
            }
        }
        else
        {
            // For some reason the above blows up on Win9x

            char    buf[MAX_PATH] = "";
            DWORD   i;


            GetModuleFileName (NULL, buf, MAX_PATH);

            for (i = 0; buf[i]; i++)
            {
                if (isalpha (buf[i]))
                {
                    buf[i] |= 0x20;
                }
            }

            bLoadedByTapisrv = (strstr (buf, "tapisrv.exe") ? TRUE : FALSE);
        }

        if (bLoadedByTapisrv)
        {
            {
                typedef struct _XXX
                {
                    DWORD    dwDefValue;

                    LPCSTR   pszValueName;

                    LPDWORD  pdwValue;

                } XXX, *PXXX;

                XXX axxx[] =
                {
                    {   DEF_SPI_VERSION,
                        "TSPIVersion",
                        &gESPGlobals.dwSPIVersion },
                    {   DEF_NUM_LINES,
                        "NumLines",
                        &gESPGlobals.dwNumLines },
                    {   DEF_NUM_ADDRS_PER_LINE,
                        "NumAddrsPerLine",
                        &gESPGlobals.dwNumAddressesPerLine },
                    {   DEF_NUM_CALLS_PER_ADDR,
                        "NumCallsPerAddr",
                        &gESPGlobals.dwNumCallsPerAddress },
                    {   DEF_NUM_PHONES,
                        "NumPhones",
                        &gESPGlobals.dwNumPhones },
                    {   DEF_DEBUG_OPTIONS,
                        "DebugOutput",
                        &gESPGlobals.dwDebugOptions },
                    {   DEF_COMPLETION_MODE,
                        "Completion",
                        &gESPGlobals.dwCompletionMode },
                    {   0,
                        "DisableUI",
                        &gbDisableUI },
                    {   1,
                        "AutoGatherGenerateMsgs",
                        &gbAutoGatherGenerateMsgs },
                    {   0,
                        NULL,
                        NULL },
                };
                DWORD   i;


                for (i = 0; axxx[i].pszValueName; i++)
                {
                    *(axxx[i].pdwValue) = (DWORD) GetProfileInt(
                        "ESP32",
                        axxx[i].pszValueName,
                        (int) axxx[i].dwDefValue
                        );

                }
            }


            //
            //
            //

            InitializeCriticalSection (&gESPGlobals.CallListCritSec);
            InitializeCriticalSection (&gESPGlobals.PhoneCritSec);
            InitializeCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);

            if (gbDisableUI)
            {
                //
                // Don't bother doing all the stuff to sync/start up espexe.
                // However, we do want to make sure that we're not wasting
                // time spewing dbg output nor completing async requests in
                // any way other than inline (synchronously), since we're
                // not real smart about cleaning up pending async requests
                // when a call or line is closed/destroyed.
                //

                gESPGlobals.dwDebugOptions = 0;
                gESPGlobals.dwCompletionMode =
                    COMPLETE_ASYNC_EVENTS_SYNCHRONOUSLY;
                gbAutoGatherGenerateMsgs = FALSE; //TRUE;
            }
            else
            {
                //
                // Check to see if tapisrv has the "interact with
                // desktop" privilege enabled
                //

                {
                    SC_HANDLE hSCManager, hTapisrvSvc;


                    if ((hSCManager = OpenSCManager(
                            NULL,
                            NULL,
                            GENERIC_READ
                            )))
                    {
                        if ((hTapisrvSvc = OpenService(
                                hSCManager,
                                "tapisrv",
                                SERVICE_QUERY_CONFIG
                                )))
                        {
                            DWORD                   dwNeededSize;
                            QUERY_SERVICE_CONFIG    config;


                            if (!QueryServiceConfig(
                                    hTapisrvSvc,
                                    &config,
                                    sizeof (QUERY_SERVICE_CONFIG),
                                    &dwNeededSize
                                    ))
                            {
                                QUERY_SERVICE_CONFIG   *pConfig;


                                config.dwServiceType = 0;

                                if (GetLastError() ==
                                        ERROR_INSUFFICIENT_BUFFER)
                                {
                                    if ((pConfig = DrvAlloc (dwNeededSize)))
                                    {
                                        if (QueryServiceConfig(
                                                hTapisrvSvc,
                                                pConfig,
                                                dwNeededSize,
                                                &dwNeededSize
                                                ))
                                        {
                                            config.dwServiceType =
                                                pConfig->dwServiceType;
                                        }

                                        DrvFree (pConfig);
                                    }
                                }
                            }

                            gbInteractWithDesktop = (BOOL)
                                (config.dwServiceType &
                                SERVICE_INTERACTIVE_PROCESS);

                            CloseServiceHandle (hTapisrvSvc);
                        }

                        CloseServiceHandle (hSCManager);
                    }
                }

                if (!gbInteractWithDesktop)
                {
                    gESPGlobals.dwDebugOptions &= ~MANUAL_RESULTS;
                }


                //
                //
                //

                InitializeCriticalSection (&gESPGlobals.DebugBufferCritSec);
                InitializeCriticalSection (&gESPGlobals.EventBufferCritSec);

                gESPGlobals.dwDebugBufferTotalSize = 2048;
                gESPGlobals.dwDebugBufferUsedSize  = 0;

                gESPGlobals.pDebugBuffer =
                gESPGlobals.pDebugBufferIn =
                gESPGlobals.pDebugBufferOut = DrvAlloc(
                    gESPGlobals.dwDebugBufferTotalSize
                    );

                gESPGlobals.dwEventBufferTotalSize = 40 * sizeof (WIDGETEVENT);
                gESPGlobals.dwEventBufferUsedSize  = 0;

                gESPGlobals.pEventBuffer =
                gESPGlobals.pEventBufferIn =
                gESPGlobals.pEventBufferOut = DrvAlloc(
                    gESPGlobals.dwEventBufferTotalSize
                    );


                //
                // Create the events used to sync up w/ espexe, and
                // start espexe if it's not already running
                //

                ghDebugOutputEvent = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    TRUE,           // manual reset
                    FALSE,          // non-signaled
                    NULL            // unnamed
                    );

                ghWidgetEventsEvent = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    TRUE,           // manual reset
                    FALSE,          // non-signaled
                    NULL            // unnamed
                    );

                ghShutdownEvent = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    FALSE,          // auto reset
                    FALSE,          // non-signaled
                    NULL            // unnamed
                    );


                //
                // Enable rpc server interface
                //

                {
                    RPC_STATUS  status;
                    unsigned char * pszSecurity         = NULL;
                    unsigned int    cMaxCalls           = 20;


                    status = RpcServerUseProtseqEp(
                        "ncalrpc",
                        cMaxCalls,
                        "esplpc",
                        pszSecurity             // Security descriptor
                        );

                    DBGOUT((3, "RpcServerUseProtseqEp(lrpc) ret'd %d", status));

                    if (status)
                    {
                    }

                    status = RpcServerRegisterIf(
                        esp_ServerIfHandle,     // interface to register
                        NULL,                   // MgrTypeUuid
                        NULL                    // MgrEpv; null means use default
                        );

                    DBGOUT((3, "RpcServerRegisterIf ret'd %d", status));

                    if (status)
                    {
                    }
                }


                if ((hInitEvent = OpenEvent(
                        EVENT_ALL_ACCESS,
                        FALSE, "ESPevent"
                        )))
                {
                    SetEvent (hInitEvent);
                }
                else
                {
                    hInitEvent = CreateEvent(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        FALSE,      // auto reset
                        TRUE,       // signaled
                        "ESPevent"
                        );

                    DBGOUT((3, "Starting espexe..."));

                    if ((uiResult = WinExec ("espexe.exe", SW_SHOW)) < 32)
                    {
                        DBGOUT((
                            1,
                            "WinExec(espexe.exe) failed, err=%d",
                            uiResult
                            ));

                        gESPGlobals.dwDebugOptions = 0;
                        gESPGlobals.dwCompletionMode =
                            COMPLETE_ASYNC_EVENTS_SYNCHRONOUSLY;
                    }
#if DBG
                    else
                    {
                        DBGOUT((3, "started espexe"));
                    }
#endif
                }
            }
        }

      ASSERT_SANITYCHECK;

      break;
    }
    case DLL_PROCESS_DETACH:

    ASSERT_SANITYCHECK;

        if (bLoadedByTapisrv)
        {
            if (gbDisableUI == FALSE)
            {
                SetEvent (ghShutdownEvent);

                //
                // Unregister out rpc server interface
                //

                {
                    RPC_STATUS  status;


                    status = RpcServerUnregisterIf(
                        esp_ServerIfHandle,         // interface to register
                        NULL,                       // MgrTypeUuid
                        0                           // wait for calls to complete
                        );

                    DBGOUT((3, "RpcServerUntegisterIf ret'd %d", status));
                }

                CloseHandle (ghDebugOutputEvent);
                CloseHandle (ghWidgetEventsEvent);
                CloseHandle (ghShutdownEvent);
                CloseHandle (hInitEvent);

                DeleteCriticalSection (&gESPGlobals.DebugBufferCritSec);
                DeleteCriticalSection (&gESPGlobals.EventBufferCritSec);

                DrvFree (gESPGlobals.pDebugBuffer);
                DrvFree (gESPGlobals.pEventBuffer);
            }

            DeleteCriticalSection (&gESPGlobals.CallListCritSec);
            DeleteCriticalSection (&gESPGlobals.PhoneCritSec);
            DeleteCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);
        }

/* looks like this is not needed

        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            OutputDebugString ("ESP: DllMain: _CRT_INIT() failed\n\r");
        }
*/
        if (ghESPHeap != GetProcessHeap())
        {
            HeapDestroy (ghESPHeap);
        }

        break;

    default:

/* looks like this is not needed

        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            OutputDebugString ("ESP: DllMain: _CRT_INIT() failed\n\r");
        }
*/
        break;
    }

    return TRUE;
}


void
AsyncEventQueueServiceThread(
    LPVOID  pParams
    )
{
    while (1)
    {
        WaitForSingleObject (gESPGlobals.hAsyncEventsPendingEvent, INFINITE);

        while (1)
        {
            PASYNC_REQUEST_INFO pAsyncReqInfo;


            EnterCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);

            if (gESPGlobals.dwNumUsedQueueEntries == 0)
            {
                ResetEvent (gESPGlobals.hAsyncEventsPendingEvent);
                LeaveCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);
                break;
            }

            pAsyncReqInfo = *gESPGlobals.pAsyncRequestQueueOut;

            gESPGlobals.pAsyncRequestQueueOut++;

            if (gESPGlobals.pAsyncRequestQueueOut ==
                    (gESPGlobals.pAsyncRequestQueue +
                        gESPGlobals.dwNumTotalQueueEntries))
            {
                gESPGlobals.pAsyncRequestQueueOut =
                    gESPGlobals.pAsyncRequestQueue;
            }

            gESPGlobals.dwNumUsedQueueEntries--;

            LeaveCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);

            if (pAsyncReqInfo->pfnPostProcessProc)
            {
                (*(pAsyncReqInfo->pfnPostProcessProc))(
                    pAsyncReqInfo,
                    ASYNC
                    );
            }
            else
            {
                DoCompletion (pAsyncReqInfo, ASYNC);
            }

            DrvFree (pAsyncReqInfo);
        }

        if (gESPGlobals.bProviderShutdown)
        {
            break;
        }
    }

    ExitThread (0);
}


void
PBXThread(
    LPVOID  pParams
    )
{
    DWORD  *pPBXSettings = (LPDWORD) pParams,
            dwTickCount, dwElapsedTime,
            dwTimePerNewCall = pPBXSettings[0], dwLastNewCallTickCount,
            dwTimePerDisconnect = pPBXSettings[1], dwLastDisconnectTickCount;

/*
    DWORD   dwTickCount, dwElapsedTime,
            dwLastNewCallTickCount, dwLastDisconnectTickCount,
            dwTimePerNewCall = (gPBXSettings[0].dwNumber ?
                gPBXSettings[0].dwTime / gPBXSettings[0].dwNumber : 0),
            dwTimePerDisconnect = (gPBXSettings[1].dwNumber ?
                gPBXSettings[1].dwTime / gPBXSettings[1].dwNumber : 0);
*/

    ShowStr (TRUE, "PBXThread: enter");

    dwTickCount =
    dwLastNewCallTickCount =
    dwLastDisconnectTickCount = GetTickCount();

    ShowStr(
        TRUE,
        "dwTimePerNewCall = %d, dwTimePerDisconnect = %d",
        dwTimePerNewCall,
        dwTimePerDisconnect
        );

    while (1)
    {
        Sleep (1000);

        if (gbExitPBXThread)
        {
            break;
        }

        dwTickCount += 1000; // will automatically wrap around to 0 after it reaches 0xffffffff

        if (dwTimePerNewCall)
        {
            dwElapsedTime = (dwLastNewCallTickCount<=dwTickCount) ? (dwTickCount-dwLastNewCallTickCount) : (dwTickCount+(MAXDWORD-dwLastNewCallTickCount));

            while (dwElapsedTime >= dwTimePerNewCall)
            {
                //
                // Generate new call (random line, random media mode)
                //

                DWORD   i = rand(), j;


                for (j = 0; j < gESPGlobals.dwInitialNumLines; j++)
                {
                    PDRVLINE    pLine = GetLineFromID(
                                    i % gESPGlobals.dwInitialNumLines +
                                    gESPGlobals.dwLineDeviceIDBase
                                    );

                    if (pLine && pLine->dwMediaModes)
                    {
                        DWORD       dwMediaMode;
                        PDRVCALL    pCall;


                        for(
                            dwMediaMode =
                                (LINEMEDIAMODE_INTERACTIVEVOICE << i % 13);
                            dwMediaMode <= LAST_LINEMEDIAMODE;
                            dwMediaMode <<= 1
                            )
                        {
                            if (pLine->dwMediaModes & dwMediaMode)
                            {
                                goto PBXThread_allocCall;
                            }
                        }

                        for(
                            dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
                            dwMediaMode <= LAST_LINEMEDIAMODE;
                            dwMediaMode <<= 1
                            )
                        {
                            if (pLine->dwMediaModes & dwMediaMode)
                            {
                                break;
                            }
                        }

PBXThread_allocCall:
                        if (AllocCall (pLine, NULL, NULL, &pCall) == 0)
                        {
                            pCall->dwMediaMode = dwMediaMode;

                            SendLineEvent(
                                pLine,
                                NULL,
                                LINE_NEWCALL,
                                (ULONG_PTR) pCall,
                                (ULONG_PTR) &pCall->htCall,
                                0
                                );

                            if (!pCall->htCall)
                            {
                                FreeCall (pCall, pCall->dwCallInstance);
                                continue;
                            }

                            SetCallState(
                                pCall,
                                pCall->dwCallInstance,
                                0xffffffff,
                                LINECALLSTATE_OFFERING,
                                0,
                                FALSE
                                );

                            break;
                        }

                    }

                    i++;
                }

                dwElapsedTime -= dwTimePerNewCall;

                dwLastNewCallTickCount = dwTickCount;
            }
        }

        if (dwTimePerDisconnect)
        {
            dwElapsedTime = (dwLastDisconnectTickCount<=dwTickCount) ? (dwTickCount-dwLastDisconnectTickCount) : (dwTickCount+(MAXDWORD-dwLastDisconnectTickCount));

            while (dwElapsedTime >= dwTimePerDisconnect)
            {
                //
                // Disconnect a random (non-idle) call (random disconnect mode)
                //

                DWORD   i = rand(), j, k;


                for (j = 0; j < gESPGlobals.dwInitialNumLines; j++)
                {
                    DWORD       dwInitialAddrID =
                                    i % gESPGlobals.dwNumAddressesPerLine,
                                dwLastAddrID =
                                    gESPGlobals.dwNumAddressesPerLine;
                    PDRVLINE    pLine = GetLineFromID(
                                    i % gESPGlobals.dwInitialNumLines +
                                    gESPGlobals.dwLineDeviceIDBase
                                    );

PBXThread_findCallToDisconnect:

                    for (
                        k = dwInitialAddrID;
                        k < dwLastAddrID;
                        k++
                        )
                    {
                        EnterCriticalSection (&gESPGlobals.CallListCritSec);

                        if (pLine->aAddrs[k].dwNumCalls)
                        {
                            PDRVCALL pCall = pLine->aAddrs[k].pCalls;

                            while (pCall &&
                                   pCall->dwCallState == LINECALLSTATE_IDLE)
                            {
                                pCall = pCall->pNext;
                            }

                            if (pCall)
                            {
                                DWORD   dwDisconnectMode =
                                          LINEDISCONNECTMODE_NORMAL;


                                // BUGBUG disconnectMode depends on curr state

                                SetCallState(
                                    pCall,
                                    pCall->dwCallInstance,
                                    0xffffffff,
                                    LINECALLSTATE_DISCONNECTED,
                                    dwDisconnectMode,
                                    FALSE
                                    );

                                SetCallState(
                                    pCall,
                                    pCall->dwCallInstance,
                                    0xffffffff,
                                    LINECALLSTATE_IDLE,
                                    0,
                                    FALSE
                                    );

                                LeaveCriticalSection(
                                    &gESPGlobals.CallListCritSec
                                    );

                                goto PBXThread_droppedCall;
                            }
                        }

                        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
                    }

                    if (dwInitialAddrID != 0)
                    {
                        dwLastAddrID = dwInitialAddrID;
                        dwInitialAddrID = 0;
                        goto PBXThread_findCallToDisconnect;
                    }

                    i++;
                }

PBXThread_droppedCall:

                dwElapsedTime -= dwTimePerDisconnect;

                dwLastDisconnectTickCount = dwTickCount;
            }
        }
    }

    DrvFree (pPBXSettings);

    ShowStr (TRUE, "PBXThread: exit");

    ExitThread (0);
}


void
PASCAL
InsertVarData(
    LPVOID      lpXxx,
    LPDWORD     pdwXxxSize,
    LPVOID      pData,
    DWORD       dwDataSize
    )
{
    DWORD       dwAlignedSize, dwUsedSize;
    LPVARSTRING lpVarString = (LPVARSTRING) lpXxx;


    if (dwDataSize != 0)
    {
        //
        // Align var data on 64-bit boundaries
        //

        if ((dwAlignedSize = dwDataSize) & 7)
        {
            dwAlignedSize += 8;
            dwAlignedSize &= 0xfffffff8;

        }


        //
        // The following if statement should only be TRUE the first time
        // we're inserting data into a given structure that does not have
        // an even number of DWORD fields
        //

        if ((dwUsedSize = lpVarString->dwUsedSize) & 7)
        {
            dwUsedSize += 8;
            dwUsedSize &= 0xfffffff8;

            lpVarString->dwNeededSize += dwUsedSize - lpVarString->dwUsedSize;
        }

        lpVarString->dwNeededSize += dwAlignedSize;

        if ((dwUsedSize + dwAlignedSize) <= lpVarString->dwTotalSize)
        {
            CopyMemory(
                ((LPBYTE) lpVarString) + dwUsedSize,
                pData,
                dwDataSize
                );

            *pdwXxxSize = dwDataSize;
            pdwXxxSize++;             // pdwXxxSize = pdwXxxOffset
            *pdwXxxSize = dwUsedSize;

            lpVarString->dwUsedSize = dwUsedSize + dwAlignedSize;
        }

    }
}


void
PASCAL
InsertVarDataString(
    LPVOID      lpXxx,
    LPDWORD     pdwXxxSize,
    WCHAR      *psz
    )
{
    DWORD       dwRealSize = (lstrlenW (psz) + 1) * sizeof (WCHAR),
                dwAlignedSize;
    LPVARSTRING lpVarString = (LPVARSTRING) lpXxx;


    if (dwRealSize % 4)
    {
        dwAlignedSize = dwRealSize - (dwRealSize % 4) + 4;
    }
    else
    {
        dwAlignedSize = dwRealSize;
    }

    lpVarString->dwNeededSize += dwAlignedSize;

    if ((lpVarString->dwUsedSize + dwAlignedSize) <= lpVarString->dwTotalSize)
    {
        CopyMemory(
            ((LPBYTE) lpVarString) + lpVarString->dwUsedSize,
            psz,
            dwRealSize
            );

        *pdwXxxSize = dwRealSize;
        pdwXxxSize++;
        *pdwXxxSize = lpVarString->dwUsedSize;

        lpVarString->dwUsedSize += dwAlignedSize;
    }
}


//
// We get a slough of C4047 (different levels of indrection) warnings down
// below in the initialization of FUNC_PARAM structs as a result of the
// real func prototypes having params that are types other than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4047)


//
// --------------------------- TSPI_lineXxx funcs -----------------------------
//

void
FAR
PASCAL
TSPI_lineAccept_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD      dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
        PDRVCALL   pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


        pAsyncReqInfo->lResult = SetCallState(
            pCall,
            dwCallInstThen,
            LINECALLSTATE_OFFERING,
            LINECALLSTATE_ACCEPTED,
            0,
            TRUE
            );
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "lineAccept";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpsUserUserInfo",    lpsUserUserInfo },
        { szdwSize,             dwSize          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_lineAccept_postProcess
    };


    if (Prolog (&info))
    {
        DWORD dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam2 = dwCallInstance;

            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdCall;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineAddToConference_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD      dwConfCallInstThen = (DWORD) pAsyncReqInfo->dwParam3,
                   dwConsultCallInstThen = (DWORD) pAsyncReqInfo->dwParam4,
                   dwConfCallInstNow;
        PDRVCALL   pConfCall = (PDRVCALL) pAsyncReqInfo->dwParam1;
        PDRVCALL   pConsultCall = (PDRVCALL) pAsyncReqInfo->dwParam2;



        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pConfCall, &dwConfCallInstNow)  &&
            dwConfCallInstNow == dwConfCallInstThen)
        {
        	// 
            // Note - indecision on the validity of ONHOLD -> CONNECTED transition
            //        SDK allows it, internal TAPI documents by NoelA do not.
            //
            if (SetCallState(
                    pConfCall,
                    dwConfCallInstThen,
                    LINECALLSTATE_ONHOLDPENDCONF | LINECALLSTATE_ONHOLD,
                    LINECALLSTATE_CONNECTED,
                    0,
                    TRUE
    
                    ) == 0)
            {
                if ((pAsyncReqInfo->lResult = SetCallState(
                        pConsultCall,
                        dwConsultCallInstThen,
                        LINECALLSTATE_PROCEEDING | LINECALLSTATE_RINGBACK | LINECALLSTATE_ONHOLD | LINECALLSTATE_CONNECTED,
                        LINECALLSTATE_CONFERENCED,
                        pConfCall->htCall,
                        TRUE
    
                        )) == 0)
                {
                    pConsultCall->pConfParent = pConfCall;
                    pConsultCall->pNextConfChild = pConfCall->pNextConfChild;
    
                    pConfCall->pNextConfChild = pConsultCall;
    
                    /*
                    pConsultCall->dwRelatedCallID = pConfCall->dwRelatedCallID;
    
                    SendLineEvent(
                        pConsultCall->pLine,
                        pConsultCall,
                        LINE_CALLINFO,
                        LINECALLINFOSTATE_RELATEDCALLID,
                        0,
                        0
                        );
                    */
                    
                    // give the consult call the same callid as the conf controller
                    // this puts it into the same call hub
                    pConsultCall->dwCallID = pConfCall->dwCallID;
                    SendLineEvent(
                            pConsultCall->pLine,
                            pConsultCall,
                            LINE_CALLINFO,
                            LINECALLINFOSTATE_CALLID,
                            0,
                            0
                            );
    
    
                    if (pConsultCall->pDestCall)
                    {
                        // BUGBUG  chg buddy's call hub id, and check to see if
                        //         buddy is in a conf (if so will need to munge
                        //         the conf too (?)
    
                        // give the consult call's buddy the same callid as the conf 
                        // controller, this puts it into the same call hub
                        pConsultCall->pDestCall->dwCallID = pConfCall->dwCallID;
                        SendLineEvent(
                                pConsultCall->pDestCall->pLine,
                                pConsultCall->pDestCall,
                                LINE_CALLINFO,
                                LINECALLINFOSTATE_CALLID,
                                0,
                                0
                                );
                    }
                }
            }
        }
        else
        {
            pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdConfCall,
    HDRVCALL        hdConsultCall
    )
{
    static char szFuncName[] = "lineAddToConference";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { "hdConfCall",     hdConfCall      },
        { "hdConsultCall",  hdConsultCall   }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        3,
        params,
        TSPI_lineAddToConference_postProcess
    };
    PDRVCALL pConfCall = (PDRVCALL) hdConfCall;
    PDRVCALL pConsultCall = (PDRVCALL) hdConsultCall;


    if (Prolog (&info))
    {
        DWORD dwConfCallInstance, dwConsultCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdConfCall, &dwConfCallInstance)  &&
            IsValidDrvCall ((PDRVCALL) hdConsultCall, &dwConsultCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdConfCall;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdConsultCall;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) dwConfCallInstance;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) dwConsultCallInstance;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineAnswer_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD      dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
        PDRVCALL   pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


        pAsyncReqInfo->lResult = SetCallState(
            pCall,
            dwCallInstThen,
            LINECALLSTATE_OFFERING | LINECALLSTATE_ACCEPTED,
            LINECALLSTATE_CONNECTED,
            0,
            TRUE
            );
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "lineAnswer";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpsUserUserInfo",    lpsUserUserInfo },
        { szdwSize,             dwSize          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_lineAnswer_postProcess
    };


    if (Prolog (&info))
    {
        DWORD  dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam2 = dwCallInstance;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineBlindTransfer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static char szFuncName[] = "lineBlindTransfer";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpszDestAddress",    lpszDestAddress },
        { "dwCountryCode",      dwCountryCode   }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 4, params, NULL };


    if (Prolog (&info))
    {
        info.lResult = TransferCall(
            &info,
            (PDRVCALL) hdCall,
            LINECALLSTATE_CONNECTED,
            LINECALLSTATE_OFFERING,
            lpszDestAddress
            );
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
    )
{
    static char szFuncName[] = "lineClose";
    FUNC_PARAM params[] =
    {
        { szhdLine, hdLine  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 1, params };
    PDRVLINE pLine = (PDRVLINE) hdLine;


    //
    // This is more of a "command" than a request, in that TAPI.DLL is
    // going to consider the line closed whether we like it or not.
    // Therefore we want to free up the line even if the user chooses
    // to return an error.
    //

    Prolog (&info);

    pLine->htLine = (HTAPILINE) NULL;
    pLine->dwMediaModes = 0;
//    pLine->dwMSGWAITFlag = 0; //smarandb #23974 winseqfe: don't reset this on lineClose!! 
                                //this value should not be reset on lineClose, 
                                //instead it should reflect the hardware status (should be dictated by the switch).

    WriteEventBuffer (pLine->dwDeviceID,  WIDGETTYPE_LINE, 0, 0, 0, 0);

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
    )
{
    DWORD       dwCallInst;
    static char szFuncName[] = "lineCloseCall";
    FUNC_PARAM params[] =
    {
        { szhdCall, hdCall  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 1, params };
    PDRVCALL pCall = (PDRVCALL) hdCall;


    //
    // This is more of a "command" than a request, in that TAPI.DLL is
    // going to consider the call closed whether we like it or not.
    // Therefore we want to free up the call even if the user chooses
    // to return an error.
    //

    Prolog (&info);

    if (IsValidDrvCall (pCall, &dwCallInst))
    {
        if (pCall && pCall->pLine)          
            WriteEventBuffer(
                ((PDRVLINE) pCall->pLine)->dwDeviceID,
                WIDGETTYPE_CALL,
                (ULONG_PTR) pCall,
                0,
                0,
                0
                );
        
        FreeCall (pCall, dwCallInst);
    }   
    
    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineCompleteCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPDWORD         lpdwCompletionID,
    DWORD           dwCompletionMode,
    DWORD           dwMessageID
    )
{
    static char szFuncName[] = "lineCompleteCall";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID         },
        { szhdCall,             hdCall              },
        { "lpdwCompletionID",   lpdwCompletionID    },
        { "dwCompletionMode",   dwCompletionMode    },
        { "dwMessageID",        dwMessageID         }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 5, params, NULL };


    if (Prolog (&info))
    {
        if (dwMessageID >= MAX_NUM_COMPLETION_MESSAGES)
        {
            info.lResult = LINEERR_INVALMESSAGEID;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineCompleteTransfer_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD      dwCallInstThen        = (DWORD) pAsyncReqInfo->dwParam1,
               dwConsultCallInstThen = (DWORD) pAsyncReqInfo->dwParam2,
               dwConfCallInstThen    = (DWORD) pAsyncReqInfo->dwParam6,
               dwCallInstNow, dwConsultCallInstNow, dwConfCallInstNow;
    PDRVCALL   pCall        = (PDRVCALL) pAsyncReqInfo->dwParam3,
               pConsultCall = (PDRVCALL) pAsyncReqInfo->dwParam4,
               pConfCall    = (PDRVCALL) pAsyncReqInfo->dwParam5;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, &dwCallInstNow)  &&
            dwCallInstNow == dwCallInstThen  &&
            IsValidDrvCall (pConsultCall, &dwConsultCallInstNow)  &&
            dwConsultCallInstNow == dwConsultCallInstThen)
        {
            if (pConfCall)
            {
                if (IsValidDrvCall (pConfCall, &dwConfCallInstNow)  &&
                    dwConfCallInstNow == dwConfCallInstThen)
                {
                    pConfCall->pNextConfChild = pCall;
                    pCall->pNextConfChild     = pConsultCall;
                    pCall->pConfParent        = pConfCall;
                    pConsultCall->pConfParent = pConfCall;
                }
                else
                {
                    pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;
                }
            }
        }
        else
        {
            pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;

            if (pConfCall)
            {
                FreeCall (pConfCall, dwConfCallInstThen);
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        if (pConfCall)
        {

           if (SetCallState(
                    pConfCall,
                    dwConfCallInstNow,
                    0xffffffff, // we just created this conf call, any state is fine
                    LINECALLSTATE_CONNECTED,
                    0,
                    TRUE

                    ) == 0)
            {
         	// 
            // Note - indecision on the validity of ONHOLD -> CONFERENCED transition
            //        SDK allows it, internal TAPI documents by NoelA do not.
            //
                SetCallState(
                    pCall,
                    dwCallInstNow,
                    LINECALLSTATE_ONHOLDPENDTRANSFER | LINECALLSTATE_ONHOLD,
                    LINECALLSTATE_CONFERENCED,
                    0,
                    TRUE
                    );

         	// 
            // Note - indecision on the validity of these transitions
            //        SDK allows them, internal TAPI documents by NoelA do not.
            //
                SetCallState(
                    pConsultCall,
                    dwConsultCallInstNow,
                    LINECALLSTATE_PROCEEDING | LINECALLSTATE_RINGBACK | LINECALLSTATE_BUSY | LINECALLSTATE_CONNECTED,
                    LINECALLSTATE_CONFERENCED,
                    0,
                    TRUE
                    );
            }

            pConsultCall->dwCallID = pConfCall->dwCallID;
            SendLineEvent(
                    pConsultCall->pLine,
                    pConsultCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );
            if (pConsultCall->pDestCall)
            {
                pConsultCall->pDestCall->dwCallID = pConfCall->dwCallID;
                SendLineEvent(
                    pConsultCall->pDestCall->pLine,
                    pConsultCall->pDestCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );
            }
        }
        else
        {
            PDRVCALL pCallOtherEnd = pCall->pDestCall;
            PDRVCALL pConsultCallOtherEnd = pConsultCall->pDestCall;

            pCall->pDestCall        = NULL;
            pConsultCall->pDestCall = NULL;


            // create a new callid for the transfered call
            // this create a new call hub
            if (pConsultCallOtherEnd)
            {
                pConsultCallOtherEnd->pDestCall = pCallOtherEnd;
                pConsultCallOtherEnd->dwCallID =  (++gdwCallID ? gdwCallID : ++gdwCallID);
                SendLineEvent(
                    pConsultCallOtherEnd->pLine,
                    pConsultCallOtherEnd,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );
            }
            if (pCallOtherEnd)
            {
                pCallOtherEnd->pDestCall        = pConsultCallOtherEnd;
                pCallOtherEnd->dwCallID = pConsultCallOtherEnd->dwCallID;
                SendLineEvent(
                    pCallOtherEnd->pLine,
                    pCallOtherEnd,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );
            }
        

            SetCallState(
                pCall,
                dwCallInstNow,
                LINECALLSTATE_ONHOLDPENDTRANSFER | LINECALLSTATE_ONHOLD,
                LINECALLSTATE_IDLE,
                0,
                TRUE
                );

        	// 
            // Note - indecision on the validity of BUSY->IDLE transition
            //        SDK allows it, internal TAPI documents by NoelA do not.
            //
            SetCallState(
                pConsultCall,
	            dwConsultCallInstNow,
                LINECALLSTATE_RINGBACK | LINECALLSTATE_PROCEEDING | LINECALLSTATE_CONNECTED | LINECALLSTATE_BUSY,
                LINECALLSTATE_IDLE,
                0,
                TRUE
                );
        }
    }
}


LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    HDRVCALL        hdConsultCall,
    HTAPICALL       htConfCall,
    LPHDRVCALL      lphdConfCall,
    DWORD           dwTransferMode
    )
{
    static char szFuncName[] = "lineCompleteTransfer";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdCall,         hdCall          },
        { "hdConsultCall",  hdConsultCall   },
        { "htConfCall",     htConfCall      },
        { "lphdConfCall",   lphdConfCall    },
        { "dwTransferMode", dwTransferMode, aTransferModes  }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        6,
        params,
        TSPI_lineCompleteTransfer_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance, dwConsultCallInstance;

        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance) &&
            IsValidDrvCall((PDRVCALL) hdConsultCall, &dwConsultCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = dwConsultCallInstance;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) hdConsultCall;

            if (dwTransferMode == LINETRANSFERMODE_CONFERENCE)
            {
                LONG        lResult;
                PDRVCALL    pConfCall;
                PDRVLINE    pLine = ((PDRVCALL) hdCall)->pLine; 

                if ((lResult = AllocCall(
                        pLine,
                        htConfCall,
                        NULL,
                        &pConfCall

                        )) == 0)
                {
                    *lphdConfCall = (HDRVCALL) pConfCall;
                    pConfCall->dwCallID = ((PDRVCALL) hdCall)->dwCallID;
                    info.pAsyncReqInfo->dwParam5 = (ULONG_PTR) pConfCall;
                    info.pAsyncReqInfo->dwParam6 = pConfCall->dwCallInstance;
                }
                else
                {
                    info.lResult = lResult;
                }
            }
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,                                                                       
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static char szFuncName[] = "lineConditionalMediaDetection";
    FUNC_PARAM params[] =
    {
        { szhdLine,         hdLine                      },
        { "dwMediaModes",   dwMediaModes,   aMediaModes },
        { szlpCallParams,   lpCallParams                }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };
    PDRVLINE pLine = (PDRVLINE) hdLine;


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineDevSpecific_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    LPBYTE lpParams = pAsyncReqInfo->dwParam1;
    DWORD  dwSize   = (DWORD) pAsyncReqInfo->dwParam2, i;


    if (pAsyncReqInfo->lResult == 0)
    {
        for (i = 0; i < dwSize; i++)
        {
            *lpParams++ = (BYTE) i;
        }
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "lineDevSpecific";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdLine,         hdLine          },
        { "dwAddressID",    dwAddressID     },
        { szhdCall,         hdCall          },
        { "lpParams",       lpParams        },
        { szdwSize,         dwSize          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        6,
        params
    };
    PESPDEVSPECIFICINFO pInfo = (PESPDEVSPECIFICINFO) lpParams;


    if (Prolog (&info))
    {
        if (dwSize >= sizeof (ESPDEVSPECIFICINFO)  &&
            pInfo->dwKey == ESPDEVSPECIFIC_KEY)
        {
            switch (pInfo->dwType)
            {
            case ESP_DEVSPEC_MSG:

                switch (pInfo->u.EspMsg.dwMsg)
                {
                case LINE_ADDRESSSTATE:
                case LINE_CLOSE:
                case LINE_DEVSPECIFIC:
                case LINE_DEVSPECIFICFEATURE:
                case LINE_LINEDEVSTATE:

                    SendLineEvent(
                        (PDRVLINE) hdLine,
                        NULL,
                        pInfo->u.EspMsg.dwMsg,
                        pInfo->u.EspMsg.dwParam1,
                        pInfo->u.EspMsg.dwParam2,
                        pInfo->u.EspMsg.dwParam3
                        );

                    break;

                case LINE_CALLDEVSPECIFIC:
                case LINE_CALLDEVSPECIFICFEATURE:
                case LINE_CALLINFO:
                case LINE_MONITORDIGITS:
                case LINE_MONITORMEDIA:

                    if (hdCall)
                    {
                        SendLineEvent(
                            (PDRVLINE) hdLine,
                            (PDRVCALL) hdCall,
                            pInfo->u.EspMsg.dwMsg,
                            pInfo->u.EspMsg.dwParam1,
                            pInfo->u.EspMsg.dwParam2,
                            pInfo->u.EspMsg.dwParam3
                            );
                    }
                    else
                    {
                        info.lResult = LINEERR_OPERATIONFAILED;
                    }

                    break;

                case LINE_GATHERDIGITS:

                    if (hdCall)
                    {
                        DWORD       dwEndToEndID = 0;
                        PDRVCALL    pCall = (PDRVCALL) hdCall;


                        EnterCriticalSection (&gESPGlobals.CallListCritSec);

                        if (IsValidDrvCall (pCall, NULL))
                        {
                            if ((dwEndToEndID =
                                    pCall->dwGatherDigitsEndToEndID))
                            {
                                pCall->dwGatherDigitsEndToEndID = 0;
                            }
                            else
                            {
                                info.lResult = LINEERR_OPERATIONFAILED;
                            }
                        }
                        else
                        {
                            info.lResult = LINEERR_INVALCALLHANDLE;
                        }

                        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

                        if (dwEndToEndID)
                        {
                            SendLineEvent(
                                (PDRVLINE) hdLine,
                                (PDRVCALL) hdCall,
                                LINE_GATHERDIGITS,
                                pInfo->u.EspMsg.dwParam1,
                                dwEndToEndID,
                                0
                                );
                        }
                        else if (info.lResult == LINEERR_OPERATIONFAILED)
                        {
                            ShowStr(
                                TRUE,
                                "ERROR: TSPI_lineDevSpecific: attempt to " \
                                "send GATHERDIGITS msg with no " \
                                "lineGatherDigits request pending"
                                );
                        }
                    }
                    else
                    {
                        info.lResult = LINEERR_OPERATIONFAILED;
                    }

                    break;

                case LINE_GENERATE:

                    if (hdCall)
                    {
                        DWORD       dwEndToEndID = 0, *pdwXxxEndToEndID;
                        PDRVCALL    pCall = (PDRVCALL) hdCall;


                        EnterCriticalSection (&gESPGlobals.CallListCritSec);

                        if (IsValidDrvCall (pCall, NULL))
                        {
                            pdwXxxEndToEndID = (pInfo->u.EspMsg.dwParam3 ?
                                &pCall->dwGenerateToneEndToEndID :
                                &pCall->dwGenerateDigitsEndToEndID
                                );

                            if ((dwEndToEndID = *pdwXxxEndToEndID))
                            {
                                *pdwXxxEndToEndID = 0;
                            }
                            else
                            {
                                info.lResult = LINEERR_OPERATIONFAILED;
                            }
                        }

                        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

                        if (dwEndToEndID)
                        {
                            SendLineEvent(
                                (PDRVLINE) hdLine,
                                (PDRVCALL) hdCall,
                                LINE_GENERATE,
                                pInfo->u.EspMsg.dwParam1,
                                dwEndToEndID,
                                0
                                );
                        }
                        else if (info.lResult == LINEERR_OPERATIONFAILED)
                        {
                            ShowStr(
                                TRUE,
                                "ERROR: TSPI_lineDevSpecific: attempt to " \
                                "send GENERATE msg with no " \
                                "lineGenerateXxx request pending"
                                );
                        }
                    }
                    else
                    {
                        info.lResult = LINEERR_OPERATIONFAILED;
                    }

                    break;

                case LINE_MONITORTONE:

                    if (hdCall)
                    {
                        DWORD       dwToneListID = 0;
                        PDRVCALL    pCall = (PDRVCALL) hdCall;


                        EnterCriticalSection (&gESPGlobals.CallListCritSec);

                        if (IsValidDrvCall (pCall, NULL))
                        {
                            if ((dwToneListID =
                                    pCall->dwMonitorToneListID))
                            {
                                pCall->dwMonitorToneListID = 0;
                            }
                            else
                            {
                                info.lResult = LINEERR_OPERATIONFAILED;
                            }
                        }
                        else
                        {
                            info.lResult = LINEERR_INVALCALLHANDLE;
                        }

                        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

                        if (dwToneListID)
                        {
                            SendLineEvent(
                                (PDRVLINE) hdLine,
                                (PDRVCALL) hdCall,
                                LINE_MONITORTONE,
                                pInfo->u.EspMsg.dwParam1,
                                dwToneListID,
                                0
                                );
                        }
                        else if (info.lResult == LINEERR_OPERATIONFAILED)
                        {
                            ShowStr(
                                TRUE,
                                "ERROR: TSPI_lineDevSpecific: attempt to " \
                                "send MONITORTONE msg with no " \
                                "lineMonitorTone request pending"
                                );
                        }
                    }
                    else
                    {
                        info.lResult = LINEERR_OPERATIONFAILED;
                    }

                    break;

                case LINE_CALLSTATE:
                {
                    DWORD   dwCallInst;


                    if (hdCall  &&
                        IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInst))
                    {
                        LONG        lResult;
                        ULONG_PTR   param2 = pInfo->u.EspMsg.dwParam2;


                        // BUGBUG changing to/from conf state cause ptr probs?
                        // BUGBUG check for bad call state vals

                        if (pInfo->u.EspMsg.dwParam1 ==
                                LINECALLSTATE_CONFERENCED  &&
                            pInfo->u.EspMsg.dwParam2 != 0)
                        {
                            //
                            // App wants us to do a provider-initiated
                            // conference.
                            //
                            // Try to find the call on this line whose
                            // dwAppSpecific field matches the value in
                            // pInfo->u.EspMsg.dwParam2.  This will be
                            // the conference parent.
                            //

                            DWORD       i;
                            PDRVLINE    pLine;
                            PDRVCALL    pConfCall = NULL, pCall;


                            EnterCriticalSection(
                                &gESPGlobals.CallListCritSec
                                );

                            if (IsValidDrvCall ((PDRVCALL)hdCall, &dwCallInst))
                            {
                                pLine = (PDRVLINE) ((PDRVCALL) hdCall)->pLine;

                                for(
                                    i = 0;
                                    i < gESPGlobals.dwNumAddressesPerLine  &&
                                        pConfCall == NULL;
                                    i++
                                    )
                                {
                                    pCall = pLine->aAddrs[i].pCalls;

                                    while (pCall)
                                    {
                                        if (pCall->dwAppSpecific ==
                                                pInfo->u.EspMsg.dwParam2)
                                        {
                                            pConfCall = pCall;
                                            break;
                                        }

                                        pCall = pCall->pNext;
                                    }
                                }

                                if (pConfCall)
                                {
                                    if (pConfCall->pConfParent == NULL)
                                    {
                                        pCall = (PDRVCALL) hdCall;
                                        pCall->pConfParent = pConfCall;
                                        pCall->pNextConfChild =
                                            pConfCall->pNextConfChild;
                                        pConfCall->pNextConfChild = pCall;

                                        param2 = (ULONG_PTR) pConfCall->htCall;
                                    }
                                    else
                                    {
                                        ShowStr(
                                            TRUE,
                                            "ERROR: TSPI_lineDevSpecific: " \
                                            "attempt to initiate conference " \
                                            "when specifed conf parent " \
                                            "already a conf child."
                                            );
                                    }
                                }
                                else
                                {
                                    ShowStr(
                                        TRUE,
                                        "ERROR: TSPI_lineDevSpecific: " \
                                        "attempted to initiate conference " \
                                        "but could not find conf parent " \
                                        "with specified dwAppSpecific value."
                                        );
                                }
                            }

                            LeaveCriticalSection(
                                &gESPGlobals.CallListCritSec
                                );
                        }

                        if ((lResult = SetCallState(
                                (PDRVCALL) hdCall,
                                dwCallInst,
                                0xffffffff,
                                pInfo->u.EspMsg.dwParam1, //LINECALLSTATE_CONFERENCED
                                param2,
                                TRUE

                                )) != 0)
                        {
                            info.lResult = lResult;
                        }
                    }
                    else
                    {
                        info.lResult = LINEERR_OPERATIONFAILED;
                    }

                    break;
                }
                case LINE_CREATE:

                    if (gESPGlobals.pLines->dwNumUsedEntries <
                            gESPGlobals.pLines->dwNumTotalEntries)
                    {
                        (*gESPGlobals.pfnLineEvent)(
                            (HTAPILINE) NULL,
                            (HTAPICALL) NULL,
                            LINE_CREATE,
                            (ULONG_PTR) gESPGlobals.hProvider,
                            gESPGlobals.pLines->dwNumUsedEntries++,
                            0
                            );
                    }
                    else
                    {
                         ShowStr(
                             TRUE,
                             "ERROR: TSPI_lineDevSpecific: attempt " \
                                 "to send LINE_CREATE - can't create " \
                                 "any more devices on the fly"
                             );

                        info.lResult = LINEERR_OPERATIONFAILED;
                    }

                    break;

                case LINE_NEWCALL: // BUGBUG

                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_lineDevSpecific: no support " \
                            "for indicating LINE_NEWCALL yet"
                        );

                    info.lResult = LINEERR_OPERATIONFAILED;
                    break;

                default:

                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_lineDevSpecific: unrecognized " \
                            "ESPDEVSPECIFICINFO.u.EspMsg.dwMsg (=x%x)",
                        pInfo->u.EspMsg.dwMsg
                        );

                    info.lResult = LINEERR_OPERATIONFAILED;
                    break;
                }

                break;

            case ESP_DEVSPEC_RESULT:
            {
                DWORD   dwResult = pInfo->u.EspResult.lResult;


                if (dwResult != 0  &&
                    (dwResult < LINEERR_ALLOCATED ||
                    dwResult > PHONEERR_REINIT ||
                    (dwResult > LINEERR_DIALVOICEDETECT &&
                    dwResult < PHONEERR_ALLOCATED)))
                {
                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_lineDevSpecific: invalid request" \
                            "result value (x%x)",
                        dwResult
                        );

                    info.lResult = LINEERR_OPERATIONFAILED;
                }
                else if (pInfo->u.EspResult.dwCompletionType >
                            ESP_RESULT_CALLCOMPLPROCASYNC)
                {
                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_lineDevSpecific: invalid request" \
                            "completion type (x%x)",
                        pInfo->u.EspResult.dwCompletionType
                        );

                    info.lResult = LINEERR_OPERATIONFAILED;
                }
                else
                {
                    glNextRequestResult = (LONG) dwResult;
                    gdwNextRequestCompletionType =
                        pInfo->u.EspResult.dwCompletionType;
                    gdwDevSpecificRequestID = dwRequestID;
                }

                break;
            }
            default:

                ShowStr(
                    TRUE,
                    "ERROR: TSPI_lineDevSpecific: unrecognized " \
                        "ESPDEVSPECIFICINFO.dwType (=x%x)",
                    pInfo->dwType
                    );

                info.lResult = LINEERR_OPERATIONFAILED;
                break;
            }
        }
        else
        {
            info.pAsyncReqInfo->dwParam1 = lpParams;
            info.pAsyncReqInfo->dwParam2 = dwSize;

            info.pAsyncReqInfo->pfnPostProcessProc = (FARPROC)
                TSPI_lineDevSpecific_postProcess;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineDevSpecificFeature(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwFeature,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "lineDevSpecificFeature";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdLine,         hdLine          },
        { "dwFeature",      dwFeature       },
        { "lpParams",       lpParams        },
        { szdwSize,         dwSize          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        5,
        params,
        TSPI_lineDevSpecific_postProcess
    };


    if (Prolog (&info))
    {
        info.pAsyncReqInfo->dwParam1 = lpParams;
        info.pAsyncReqInfo->dwParam2 = dwSize;
    }

    return (Epilog (&info));
}

void
FAR
PASCAL
TSPI_lineDial_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       bDestAddress   = (DWORD) pAsyncReqInfo->dwParam3,
                bValidLineID   = (DWORD) pAsyncReqInfo->dwParam4,
                dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam6,
                dwCallInstNow;

    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam1,
                pDestCall = (PDRVCALL) pAsyncReqInfo->dwParam2;
    PDRVLINE    pDestLine = (PDRVLINE) pAsyncReqInfo->dwParam5;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        if (bDestAddress)
        {
            if (bValidLineID && !pDestCall)
            {
                SetCallState(
                    pCall,
                    dwCallInstThen,
                    0xffffffff,
                    LINECALLSTATE_BUSY,
                    LINEBUSYMODE_UNAVAIL,
                    TRUE
                    );
            }
            else
            {

                SetCallState(
                    pCall,
                    dwCallInstThen,
                    LINECALLSTATE_DIALTONE,
                    LINECALLSTATE_DIALING,
                    0,
                    FALSE
                    );

                SetCallState(
                    pCall,
                    dwCallInstThen,
                    0xffffffff,
                    LINECALLSTATE_RINGBACK,
                    0,
                    TRUE
                    );
            }

            if (pDestCall)
            {
                EnterCriticalSection (&gESPGlobals.CallListCritSec);

                if (IsValidDrvCall (pCall, &dwCallInstNow) &&
                    dwCallInstNow == dwCallInstThen)
                {
                    SendLineEvent(
                        pDestLine,
                        NULL,
                        LINE_NEWCALL,
                        (ULONG_PTR) pDestCall,
                        (ULONG_PTR) &pDestCall->htCall,
                        0
                        );

                    if (pDestCall->htCall != NULL)
                    {
                        SetCallState(
                            pDestCall,
                            pDestCall->dwCallInstance,
                            0xffffffff,
                            LINECALLSTATE_OFFERING,
                            0,
                            TRUE
                            );
                    }
                    else
                    {
                        FreeCall (pDestCall, pDestCall->dwCallInstance);
                    }
                }
                else
                {
                    FreeCall (pDestCall, pDestCall->dwCallInstance);
                }

                LeaveCriticalSection (&gESPGlobals.CallListCritSec);
            }
        }
        else
        {
            SetCallState(
                pCall,
                dwCallInstThen,
                0xffffffff,
                LINECALLSTATE_DIALTONE,
                0,
                TRUE
                );
        }
    }
    else
    {
        FreeCall (pCall, dwCallInstThen);

        if (pDestCall)
        {
            FreeCall (pDestCall, pDestCall->dwCallInstance);
        }
    }
}

LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static char szFuncName[] = "lineDial";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpszDestAddress",    lpszDestAddress },
        { "dwCountryCode",      dwCountryCode   }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 4, params, TSPI_lineDial_postProcess };


    if (Prolog (&info))
    {
        BOOL        bValidLineID = FALSE;
        LONG        lResult;
        PDRVCALL    pCall = (PDRVCALL) hdCall, pDestCall;
        PDRVLINE    pDestLine;
        LPLINECALLPARAMS const lpCallParams = NULL;
        DWORD       dwCallInstance;


        if (IsValidDrvCall (pCall, &dwCallInstance))
        {
            
            CreateIncomingCall(
                lpszDestAddress,
                lpCallParams,
                pCall,
                &bValidLineID,
                &pDestLine,
                &pDestCall
                );

            info.pAsyncReqInfo->dwParam1 = pCall;
            info.pAsyncReqInfo->dwParam2 = pDestCall;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) lpszDestAddress;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) bValidLineID;
            info.pAsyncReqInfo->dwParam5 = pDestLine;
            info.pAsyncReqInfo->dwParam6 = pCall->dwCallInstance;
    
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}





void
FAR
PASCAL
TSPI_lineDrop_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    if ((pAsyncReqInfo->lResult == 0))
    {
        DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
        PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


        //
        // We need to make sure pCall is pointing at a valid call
        // structure because it's possible that tapi immediately
        // followed the drop request with a closeCall request
        // (without waiting for the result from the drop)
        //

        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (SetCallState(
                pCall,
                dwCallInstThen,
                0xffffffff,
                LINECALLSTATE_IDLE,
                0,
                TRUE

                ) == 0)
        {
            if (pCall->pConfParent)
            {
                //
                // Call is a conf child, so remove from conf list
                //

                PDRVCALL    pCall2 = pCall->pConfParent;


                while (pCall2 && (pCall2->pNextConfChild != pCall))
                {
                    pCall2 = pCall2->pNextConfChild;
                }

                if (pCall2)
                {
                    pCall2->pNextConfChild = pCall->pNextConfChild;
                }

                pCall->pConfParent = NULL;
            }
            else if (pCall->pNextConfChild)
            {
                //
                // Call is a conf parent, so IDLE-ize all children &
                // remove them from list
                //

                PDRVCALL    pConfChild = pCall->pNextConfChild;


                pCall->pNextConfChild = NULL;

                while (pConfChild)
                {
                    PDRVCALL    pNextConfChild = pConfChild->pNextConfChild;


                    pConfChild->pConfParent =
                    pConfChild->pNextConfChild = NULL;

                    SetCallState(
                        pConfChild,
                        pConfChild->dwCallInstance,
                        0xffffffff,
                        LINECALLSTATE_IDLE,
                        0,
                        TRUE
                        );

                    pConfChild = pNextConfChild;
                }
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "lineDrop";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpsUserUserInfo",    lpsUserUserInfo },
        { szdwSize,             dwSize          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_lineDrop_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam2 = dwCallInstance;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineForward_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwConsultCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
    PDRVCALL    pConsultCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        SetCallState(
            pConsultCall,
            dwConsultCallInstThen,
            0xffffffff, // BUGBUG specify valid call states
            LINECALLSTATE_CONNECTED,
            0,
            TRUE
            );
    }
    else
    {
        FreeCall (pConsultCall, dwConsultCallInstThen);
    }
}


LONG
TSPIAPI
TSPI_lineForward(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static char szFuncName[] = "lineForward";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID         },
        { szhdLine,             hdLine              },
        { "bAllAddresses",      bAllAddresses       },
        { "dwAddressID",        dwAddressID         },
        { "lpForwardList",      lpForwardList       },
        { "dwNumRingsNoAnswer", dwNumRingsNoAnswer  },
        { "htConsultCall",      htConsultCall       },
        { "lphdConsultCall",    lphdConsultCall     },
        { szlpCallParams,       lpCallParams        }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        9,
        params,
        TSPI_lineForward_postProcess
    };


    if (Prolog (&info))
    {
        if (bAllAddresses  ||
            dwAddressID < gESPGlobals.dwNumAddressesPerLine)
        {
            if (lpForwardList)
            {
                LONG        lResult;
                PDRVCALL    pConsultCall;


                if ((lResult = AllocCall(
                        (PDRVLINE) hdLine,
                        htConsultCall,
                        lpCallParams,
                        &pConsultCall

                        )) == 0)
                {
                    info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) pConsultCall;
                    info.pAsyncReqInfo->dwParam2 = pConsultCall->dwCallInstance;

                    *lphdConsultCall = (HDRVCALL) pConsultCall;
                }
                else
                {
                    info.lResult = lResult;
                }
            }
            else
            {
                info.pAsyncReqInfo->pfnPostProcessProc = NULL;
                *lphdConsultCall = (HDRVCALL) NULL;
            }
        }
        else
        {
            info.lResult = LINEERR_INVALADDRESSID;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGatherDigits(
    HDRVCALL    hdCall,
    DWORD       dwEndToEndID,
    DWORD       dwDigitModes,
    LPWSTR      lpsDigits,
    DWORD       dwNumDigits,
    LPCWSTR     lpszTerminationDigits,
    DWORD       dwFirstDigitTimeout,
    DWORD       dwInterDigitTimeout
    )
{
    static char szFuncName[] = "lineGatherDigits";
    FUNC_PARAM params[] =
    {
        { szhdCall,                 hdCall                  },
        { "dwEndToEndID",           dwEndToEndID            },
        { "dwDigitModes",           dwDigitModes,   aDigitModes },
        { "lpsDigits",              lpsDigits               },
        { "dwNumDigits",            dwNumDigits             },
        { "lpszTerminationDigits",  lpszTerminationDigits   },
        { "dwFirstDigitTimeout",    dwFirstDigitTimeout     },
        { "dwInterDigitTimeout",    dwInterDigitTimeout     }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 8, params };
    PDRVCALL    pCall = (PDRVCALL) hdCall;
    DWORD       dwReason = 0;
    HTAPILINE   htLine;
    HTAPICALL   htCall;


    if (Prolog (&info))
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            htLine = ((PDRVLINE) pCall->pLine)->htLine;
            htCall = pCall->htCall;

            if (lpsDigits)
            {
                lstrcpynW (lpsDigits, L"1234567890", dwNumDigits);

                if (dwNumDigits > 0 && dwNumDigits <= 10)
                {
                    lpsDigits[dwNumDigits] = L'0';
                }
            }

            if (gbAutoGatherGenerateMsgs)
            {
                if (lpsDigits)
                {
                    dwReason = (dwNumDigits > 10 ? LINEGATHERTERM_INTERTIMEOUT
                        : LINEGATHERTERM_BUFFERFULL);
                }
            }
            else
            {
                DWORD dwEndToEndIDTmp = dwEndToEndID;


                if ((dwEndToEndID = pCall->dwGatherDigitsEndToEndID))
                {
                    dwReason = LINEGATHERTERM_CANCEL;
                }

                pCall->dwGatherDigitsEndToEndID = (lpsDigits ?
                    dwEndToEndIDTmp : 0);
            }
        }
        else
        {
            htLine = (HTAPILINE) (htCall = (HTAPICALL) NULL);
            dwReason = (lpsDigits ? LINEGATHERTERM_CANCEL : 0);
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

        if (dwReason)
        {
            (gESPGlobals.pfnLineEvent)(
                htLine,
                htCall,
                LINE_GATHERDIGITS,
                dwReason,
                dwEndToEndID,
                0
                );
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL    hdCall,
    DWORD       dwEndToEndID,
    DWORD       dwDigitMode,
    LPCWSTR     lpszDigits,
    DWORD       dwDuration
    )
{
    static char szFuncName[] = "lineGenerateDigits";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "dwEndToEndID",   dwEndToEndID    },
        { "dwDigitMode",    dwDigitMode,    aDigitModes },
        { "lpszDigits",     lpszDigits      },
        { "dwDuration",     dwDuration      }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 5, params };
    PDRVCALL    pCall = (PDRVCALL) hdCall;
    HTAPILINE   htLine, htDestLine = NULL;
    HTAPICALL   htCall, htDestCall;
    DWORD       dwReason = 0, i;


    if (Prolog (&info))
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            htLine = ((PDRVLINE) pCall->pLine)->htLine;
            htCall = pCall->htCall;

            if (gbAutoGatherGenerateMsgs)
            {
                dwReason = (lpszDigits ? LINEGENERATETERM_DONE : 0);
            }
            else
            {
                DWORD dwEndToEndIDTmp = dwEndToEndID;


                if ((dwEndToEndID = pCall->dwGenerateDigitsEndToEndID))
                {
                    dwReason = LINEGENERATETERM_CANCEL;
                }

                pCall->dwGenerateDigitsEndToEndID = (lpszDigits ?
                    dwEndToEndIDTmp : 0);
            }

            if (lpszDigits  &&  IsValidDrvCall (pCall->pDestCall, NULL))
            {
                htDestCall = pCall->pDestCall->htCall;
                htDestLine = ((PDRVLINE) pCall->pDestCall->pLine)->htLine;
            }
        }
        else
        {
            htLine = (HTAPILINE) (htCall = (HTAPICALL) NULL);
            dwReason = (lpszDigits ? LINEGENERATETERM_CANCEL : 0);
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

        if (dwReason)
        {
            (gESPGlobals.pfnLineEvent)(
                htLine,
                htCall,
                LINE_GENERATE,
                dwReason,
                dwEndToEndID,
                0
                );
        }

        if (htDestLine)
        {
            DWORD dwTickCount = GetTickCount();

            for (i = 0; lpszDigits[i]; i++)
            {
                (gESPGlobals.pfnLineEvent)(
                    htDestLine,
                    htDestCall,
                    LINE_MONITORDIGITS,
                    lpszDigits[i],
                    dwDigitMode,
                    dwTickCount + (2 * i * dwDuration)
                    );

                if (dwDigitMode == LINEDIGITMODE_DTMF)
                {
                    (gESPGlobals.pfnLineEvent)(
                        htDestLine,
                        htDestCall,
                        LINE_MONITORDIGITS,
                        lpszDigits[i],
                        LINEDIGITMODE_DTMFEND,
                        dwTickCount + (((2 * i) + 1) * dwDuration)
                        );
                }
            }
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGenerateTone(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    )
{
    static char szFuncName[] = "lineGenerateTone";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "dwEndToEndID",   dwEndToEndID    },
        { "dwToneMode",     dwToneMode, aToneModes  },
        { "dwDuration",     dwDuration      },
        { "dwNumTones",     dwNumTones      },
        { "lpTones",        lpTones         }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 6, params };
    PDRVCALL    pCall = (PDRVCALL) hdCall;
    HTAPILINE   htLine;
    HTAPICALL   htCall;
    DWORD       dwReason = 0;


    if (Prolog (&info))
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            htLine = ((PDRVLINE) pCall->pLine)->htLine;
            htCall = pCall->htCall;

            if (gbAutoGatherGenerateMsgs)
            {
                dwReason = (dwToneMode ? LINEGENERATETERM_DONE : 0);
            }
            else
            {
                DWORD dwEndToEndIDTmp = dwEndToEndID;


                if ((dwEndToEndID = pCall->dwGenerateToneEndToEndID))
                {
                    dwReason = LINEGENERATETERM_CANCEL;
                }

                pCall->dwGenerateToneEndToEndID = (dwToneMode ?
                    dwEndToEndIDTmp : 0);
            }
        }
        else
        {
            htLine = (HTAPILINE) (htCall = (HTAPICALL) NULL);
            dwReason = (dwToneMode ? LINEGENERATETERM_CANCEL : 0);
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

        if (dwReason)
        {
            (gESPGlobals.pfnLineEvent)(
                htLine,
                htCall,
                LINE_GENERATE,
                dwReason,
                dwEndToEndID,
                0
                );
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
    )
{
    static char szFuncName[] = "lineGetAddressCaps";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwAddressID",    dwAddressID     },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwExtVersion",   dwExtVersion    },
        { "lpAddressCaps",  lpAddressCaps   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 5, params };
    DWORD dwUsedSize;
    PDRVLINE pLine = GetLineFromID (dwDeviceID);


    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    if (dwAddressID >= gESPGlobals.dwNumAddressesPerLine)
    {
        info.lResult = LINEERR_INVALADDRESSID;
        return (Epilog (&info));
    }

    //lpAddressCaps->dwTotalSize
    //lpAddressCaps->dwNeededSize
    //lpAddressCaps->dwUsedSize
    //lpAddressCaps->dwLineDeviceID
    //
    //lpAddressCaps->dwAddressOffset

    {
        char  buf[20];
        WCHAR wbuf[20];


        // NOTE: win9x doesn't support wsprintfW

        wsprintfA (buf, "%d#%d", dwDeviceID, dwAddressID);

        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            buf,
            lstrlen (buf) + 1,
            wbuf,
            20
            );

        InsertVarDataString(
            lpAddressCaps,
            &lpAddressCaps->dwAddressSize,
            wbuf
            );
    }

    //lpAddressCaps->dwDevSpecificSize
    //lpAddressCaps->dwDevSpecificOffset
    //lpAddressCaps->dwAddressSharing
    //lpAddressCaps->dwAddressStates
    //lpAddressCaps->dwCallInfoStates
    //lpAddressCaps->dwCallerIDFlags
    //lpAddressCaps->dwCalledIDFlags
    //lpAddressCaps->dwConnectedIDFlags
    //lpAddressCaps->dwRedirectionIDFlags
    //lpAddressCaps->dwRedirectingIDFlags
    //lpAddressCaps->dwCallStates
    //lpAddressCaps->dwDialToneModes
    //lpAddressCaps->dwBusyModes
    //lpAddressCaps->dwSpecialInfo
    //lpAddressCaps->dwDisconnectModes
    lpAddressCaps->dwMaxNumActiveCalls = gESPGlobals.dwNumCallsPerAddress;
    //lpAddressCaps->dwMaxNumOnHoldCalls
    //lpAddressCaps->dwMaxNumOnHoldPendingCalls
    //lpAddressCaps->dwMaxNumConference
    //lpAddressCaps->dwMaxNumTransConf
    lpAddressCaps->dwAddrCapFlags = AllAddrCaps1_0;
    lpAddressCaps->dwCallFeatures = AllCallFeatures1_0;
    //lpAddressCaps->dwRemoveFromConfCaps
    //lpAddressCaps->dwRemoveFromConfState
    //lpAddressCaps->dwTransferModes
    //lpAddressCaps->dwParkModes
    //lpAddressCaps->dwForwardModes
    //lpAddressCaps->dwMaxForwardEntries
    //lpAddressCaps->dwMaxSpecificEntries
    //lpAddressCaps->dwMinFwdNumRings
    //lpAddressCaps->dwMaxFwdNumRings
    //lpAddressCaps->dwMaxCallCompletions
    //lpAddressCaps->dwCallCompletionConds
    //lpAddressCaps->dwCallCompletionModes
    lpAddressCaps->dwNumCompletionMessages = MAX_NUM_COMPLETION_MESSAGES;
    //lpAddressCaps->dwCompletionMsgTextEntrySize
    //lpAddressCaps->dwCompletionMsgTextSize
    //lpAddressCaps->dwCompletionMsgTextOffset

    if (dwTSPIVersion >= 0x00010004)
    {
        lpAddressCaps->dwCallFeatures = AllCallFeatures1_4;

        lpAddressCaps->dwAddressFeatures = AllAddrFeatures1_0;

        if (dwTSPIVersion >= 0x00020000)
        {
            lpAddressCaps->dwAddrCapFlags = AllAddrCaps2_0;
            lpAddressCaps->dwCallFeatures = AllCallFeatures2_0;
            lpAddressCaps->dwAddressFeatures = AllAddrFeatures2_0;

            //lpAddressCaps->dwPredictiveAutoTransferStates
            //lpAddressCaps->dwNumCallTreatments
            //lpAddressCaps->dwCallTreatmentListSize
            //lpAddressCaps->dwCallTreatmentListOffset
            //lpAddressCaps->dwDeviceClassesSize
            //lpAddressCaps->dwDeviceClassesOffset
            //lpAddressCaps->dwMaxCallDataSize
            lpAddressCaps->dwCallFeatures2 = AllCallFeaturesTwo;
            //lpAddressCaps->dwMaxNoAnswerTimeout
            //lpAddressCaps->dwConnectedModes
            //lpAddressCaps->dwOfferingModes
            lpAddressCaps->dwAvailableMediaModes = AllMediaModes1_4;

            if (dwTSPIVersion >= 0x00020001)
            {
                lpAddressCaps->dwAvailableMediaModes = AllMediaModes2_1;
            }
        }
    }


    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
    )
{
    static char szFuncName[] = "lineGetAddressID";
    FUNC_PARAM params[] =
    {
        { szhdLine,         hdLine          },
        { "lpdwAddressID",  lpdwAddressID   },
        { "dwAddressMode",  dwAddressMode   },
        { "lpsAddress",     lpsAddress      },
        { szdwSize,         dwSize          }
    };
    FUNC_INFO info = { szFuncName, SYNC, 5, params };
    PDRVLINE pLine = (PDRVLINE) hdLine;


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    static char szFuncName[] = "lineGetAddressStatus";
    FUNC_PARAM params[] =
    {
        { szhdLine,             hdLine          },
        { "dwAddressID",        dwAddressID     },
        { "lpAddressStatus",    lpAddressStatus }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };
    PDRVLINE pLine = (PDRVLINE) hdLine;


    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    if (dwAddressID >= gESPGlobals.dwNumAddressesPerLine)
    {
        info.lResult = LINEERR_INVALADDRESSID;
        return (Epilog (&info));
    }

    //lpAddressStatus->dwNeededSize
    //lpAddressStatus->dwUsedSize
    //lpAddressStatus->dwNumInUse

    if (pLine->aAddrs[dwAddressID].dwNumCalls != 0)
    {
        PDRVCALL    pCall;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        for(
            pCall = pLine->aAddrs[dwAddressID].pCalls;
            pCall != NULL;
            pCall = pCall->pNext
            )
        {
            switch (pCall->dwCallState)
            {
            case LINECALLSTATE_IDLE:

                continue;

            case LINECALLSTATE_ONHOLD:

                lpAddressStatus->dwNumOnHoldCalls++;
                continue;

            case LINECALLSTATE_ONHOLDPENDCONF:
            case LINECALLSTATE_ONHOLDPENDTRANSFER:

                lpAddressStatus->dwNumOnHoldPendCalls++;
                continue;

            default:

                lpAddressStatus->dwNumActiveCalls++;
                continue;
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    lpAddressStatus->dwAddressFeatures = (gESPGlobals.dwSPIVersion > 0x10004 ?
        AllAddrFeatures1_0 : AllAddrFeatures2_0);
    //lpAddressStatus->dwNumRingsNoAnswer
    //lpAddressStatus->dwForwardNumEntries
    //lpAddressStatus->dwForwardSize
    //lpAddressStatus->dwForwardOffset
    //lpAddressStatus->dwTerminalModesSize
    //lpAddressStatus->dwTerminalModesOffset
    //lpAddressStatus->dwDevSpecificSize
    //lpAddressStatus->dwDevSpecificOffset

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
    )
{
    static char szFuncName[] = "lineGetCallAddressID";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "lpdwAddressID",  lpdwAddressID   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
        *lpdwAddressID = ((PDRVCALL) hdCall)->dwAddressID;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetCallHubTracking(
    HDRVLINE                    hdLine,
    LPLINECALLHUBTRACKINGINFO   lpTrackingInfo
    )
{
    static char szFuncName[] = "lineGetCallHubTracking";
    FUNC_PARAM params[] =
    {
        { szhdLine,         hdLine         },
        { "lpTrackingInfo", lpTrackingInfo }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params, NULL };


    if (Prolog (&info))
    {
        lpTrackingInfo->dwAvailableTracking =
            LINECALLHUBTRACKING_PROVIDERLEVEL | LINECALLHUBTRACKING_ALLCALLS;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetCallIDs(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID,
    LPDWORD     lpdwCallID,
    LPDWORD     lpdwRelatedCallID
    )
{
    static char szFuncName[] = "lineGetCallIDs";
    FUNC_PARAM params[] =
    {
        { szhdCall,             hdCall            },
        { "lpdwAddressID",      lpdwAddressID     },
        { "lpdwCallID",         lpdwCallID        },
        { "lpdwRelatedCallID",  lpdwRelatedCallID }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };


    if (Prolog (&info))
    {
        try
        {
            *lpdwAddressID     = ((PDRVCALL) hdCall)->dwAddressID;
            *lpdwCallID        = ((PDRVCALL) hdCall)->dwCallID;
            *lpdwRelatedCallID = ((PDRVCALL) hdCall)->dwRelatedCallID;

            if (((PDRVCALL) hdCall)->dwKey != DRVCALL_KEY)
            {
                info.lResult = LINEERR_INVALCALLHANDLE;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    static char szFuncName[] = "lineGetCallInfo";
    FUNC_PARAM params[] =
    {
        { szhdCall,     hdCall      },
        { "lpCallInfo", lpCallInfo  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };
    PDRVCALL  pCall = (PDRVCALL) hdCall;
    DWORD     dwUsedSize;


    if (Prolog (&info))
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            //lpCallInfo->dwNeededSize
            //lpCallInfo->dwUsedSize
            lpCallInfo->dwLineDeviceID  = ((PDRVLINE)pCall->pLine)->dwDeviceID;
            lpCallInfo->dwAddressID     = pCall->dwAddressID;
            lpCallInfo->dwBearerMode    = pCall->dwBearerMode;
            //lpCallInfo->dwRate
            lpCallInfo->dwMediaMode     = pCall->dwMediaMode;
            lpCallInfo->dwAppSpecific   = pCall->dwAppSpecific;
            lpCallInfo->dwCallID        = pCall->dwCallID;
            lpCallInfo->dwRelatedCallID = pCall->dwRelatedCallID;
            //lpCallInfo->dwCallParamFlags
            //lpCallInfo->dwCallStates

            CopyMemory(
                &lpCallInfo->DialParams,
                &pCall->DialParams,
                sizeof(LINEDIALPARAMS)
                );

            //lpCallInfo->dwOrigin
            //lpCallInfo->dwReason
            //lpCallInfo->dwCompletionID
            //lpCallInfo->dwCountryCode
            //lpCallInfo->dwTrunk
            //lpCallInfo->dwCallerIDFlags
            //lpCallInfo->dwCallerIDSize
            //lpCallInfo->dwCallerIDOffset
            //lpCallInfo->dwCallerIDNameSize
            //lpCallInfo->dwCallerIDNameOffset
            //lpCallInfo->dwCalledIDFlags
            //lpCallInfo->dwCalledIDSize
            //lpCallInfo->dwCalledIDOffset
            //lpCallInfo->dwCalledIDNameSize
            //lpCallInfo->dwCalledIDNameOffset
            //lpCallInfo->dwConnectedIDFlags
            //lpCallInfo->dwConnectedIDSize
            //lpCallInfo->dwConnectedIDOffset
            //lpCallInfo->dwConnectedIDNameSize
            //lpCallInfo->dwConnectedIDNameOffset
            //lpCallInfo->dwRedirectionIDFlags
            //lpCallInfo->dwRedirectionIDSize
            //lpCallInfo->dwRedirectionIDOffset
            //lpCallInfo->dwRedirectionIDNameSize
            //lpCallInfo->dwRedirectionIDNameOffset
            //lpCallInfo->dwRedirectingIDFlags
            //lpCallInfo->dwRedirectingIDSize
            //lpCallInfo->dwRedirectingIDOffset
            //lpCallInfo->dwRedirectingIDNameSize
            //lpCallInfo->dwRedirectingIDNameOffset
            //lpCallInfo->dwDisplaySize
            //lpCallInfo->dwDisplayOffset
            //lpCallInfo->dwUserUserInfoSize
            //lpCallInfo->dwUserUserInfoOffset
            //lpCallInfo->dwHighLevelCompSize
            //lpCallInfo->dwHighLevelCompOffset
            //lpCallInfo->dwLowLevelCompSize
            //lpCallInfo->dwLowLevelCompOffset
            //lpCallInfo->dwChargingInfoSize
            //lpCallInfo->dwChargingInfoOffset
            //lpCallInfo->dwTerminalModesSize
            //lpCallInfo->dwTerminalModesOffset
            //lpCallInfo->dwDevSpecificSize
            //lpCallInfo->dwDevSpecificOffset

            if (gESPGlobals.dwSPIVersion >= 0x00020000)
            {
                lpCallInfo->dwCallTreatment = pCall->dwTreatment;

                InsertVarData(
                    lpCallInfo,
                    &lpCallInfo->dwCallDataSize,
                    pCall->pCallData,
                    pCall->dwCallDataSize
                    );

                InsertVarData(
                    lpCallInfo,
                    &lpCallInfo->dwSendingFlowspecSize,
                    pCall->pSendingFlowspec,
                    pCall->dwSendingFlowspecSize
                    );

                InsertVarData(
                    lpCallInfo,
                    &lpCallInfo->dwReceivingFlowspecSize,
                    pCall->pReceivingFlowspec,
                    pCall->dwReceivingFlowspecSize
                    );

                if (gESPGlobals.dwSPIVersion >= 0x00030000)
                {
                    // no addresstypes now
                }
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    DWORD   dwCallState, dwCallStateMode;
    static char szFuncName[] = "lineGetCallStatus";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "lpCallStatus",   lpCallStatus    }
    };
    PDRVCALL  pCall = (PDRVCALL) hdCall;
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    EnterCriticalSection (&gESPGlobals.CallListCritSec);

    if (IsValidDrvCall (pCall, NULL))
    {
        dwCallState     = pCall->dwCallState;
        dwCallStateMode = pCall->dwCallStateMode;

    }
    else
    {
        info.lResult = LINEERR_INVALCALLHANDLE;
    }

    LeaveCriticalSection (&gESPGlobals.CallListCritSec);

    if (info.lResult == 0)
    {
        //lpCallStatus->dwNeededSize
        //lpCallStatus->dwUsedSize
        lpCallStatus->dwCallState     = dwCallState;
        lpCallStatus->dwCallStateMode = dwCallStateMode;


        //
        // If the call is IDLE we won't let apps do anything with it,
        // otherwise they can do anything they want to (all valid
        // 1.0/1.4 LINECALLFEATURE_XXX flags)
        //

        switch (dwCallState)
        {
        case LINECALLSTATE_IDLE:

            lpCallStatus->dwCallFeatures = 0;
            break;

        default:

            lpCallStatus->dwCallFeatures =
                (gESPGlobals.dwSPIVersion == 0x10003 ?
                AllCallFeatures1_0 : AllCallFeatures1_4);
            break;
        }

        //lpCallStatus->dwDevSpecificSize
        //lpCallStatus->dwDevSpecificOffset

        if (gESPGlobals.dwSPIVersion >= 0x00020000)
        {
            switch (dwCallState)
            {
            case LINECALLSTATE_IDLE:

                lpCallStatus->dwCallFeatures = LINECALLFEATURE_SETCALLDATA;
                break;

            default:

                lpCallStatus->dwCallFeatures  = AllCallFeatures2_0;
                lpCallStatus->dwCallFeatures2 = AllCallFeaturesTwo;
                break;
            }

            //lpCallStatus->dwCallFeatures2
            //lpCallStatus->tStateEntryTime
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    static char szFuncName[] = "lineGetDevCaps";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwExtVersion",   dwExtVersion    },
        { "lpLineDevCaps",  lpLineDevCaps   }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 4, params };
    PDRVLINE    pLine = GetLineFromID (dwDeviceID);
    char        buf[32];
    WCHAR       wbuf[32];

    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    InsertVarDataString(
        lpLineDevCaps,
        &lpLineDevCaps->dwProviderInfoSize,
        gszProviderInfo
        );

    InsertVarDataString(
        lpLineDevCaps,
        &lpLineDevCaps->dwSwitchInfoSize,
        L"ESP switch info"
        );

//smarandb - adding "linedevice specific info", as a Null terminated string ----------
    InsertVarDataString(
        lpLineDevCaps,
        &lpLineDevCaps->dwDevSpecificSize,
        L"123"
        );
//------------------------------------------------------------------------------------
    
    lpLineDevCaps->dwPermanentLineID =
        (gESPGlobals.dwPermanentProviderID << 16) |
            (dwDeviceID - gESPGlobals.dwLineDeviceIDBase);

    // NOTE: win9x doesn't support wsprintfW

    wsprintfA (buf, "ESP Line %d", dwDeviceID);

    MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        buf,
        lstrlen (buf) + 1,
        wbuf,
        20
        );

    InsertVarDataString(
        lpLineDevCaps,
        &lpLineDevCaps->dwLineNameSize,
        wbuf
        );

    lpLineDevCaps->dwStringFormat = STRINGFORMAT_ASCII;
    lpLineDevCaps->dwAddressModes = LINEADDRESSMODE_ADDRESSID |
                                    LINEADDRESSMODE_DIALABLEADDR;
    lpLineDevCaps->dwNumAddresses = gESPGlobals.dwNumAddressesPerLine;
    lpLineDevCaps->dwBearerModes  = AllBearerModes1_0;
    lpLineDevCaps->dwMaxRate      = 0x00100000;
    lpLineDevCaps->dwMediaModes   = AllMediaModes1_0;
    //lpLineDevCaps->dwGenerateToneModes
    //lpLineDevCaps->dwGenerateToneMaxNumFreq
    //lpLineDevCaps->dwGenerateDigitModes
    //lpLineDevCaps->dwMonitorToneMaxNumFreq
    //lpLineDevCaps->dwMonitorToneMaxNumEntries
    //lpLineDevCaps->dwMonitorDigitModes
    //lpLineDevCaps->dwGatherDigitsMinTimeout
    //lpLineDevCaps->dwGatherDigitsMaxTimeout
    //lpLineDevCaps->dwMedCtlDigitMaxListSize
    //lpLineDevCaps->dwMedCtlMediaMaxListSize
    //lpLineDevCaps->dwMedCtlToneMaxListSize;
    //lpLineDevCaps->dwMedCtlCallStateMaxListSize
    //lpLineDevCaps->dwDevCapFlags
    lpLineDevCaps->dwMaxNumActiveCalls = gESPGlobals.dwNumAddressesPerLine *
                                         gESPGlobals.dwNumCallsPerAddress;
    //lpLineDevCaps->dwAnswerMode
    //lpLineDevCaps->dwRingModes
    //lpLineDevCaps->dwLineStates
    //lpLineDevCaps->dwUUIAcceptSize
    //lpLineDevCaps->dwUUIAnswerSize
    //lpLineDevCaps->dwUUIMakeCallSize
    //lpLineDevCaps->dwUUIDropSize
    //lpLineDevCaps->dwUUISendUserUserInfoSize
    //lpLineDevCaps->dwUUICallInfoSize
    //lpLineDevCaps->MinDialParams
    //lpLineDevCaps->MaxDialParams
    //lpLineDevCaps->DefaultDialParams
    //lpLineDevCaps->dwNumTerminals
    //lpLineDevCaps->dwTerminalCapsSize
    //lpLineDevCaps->dwTerminalCapsOffset
    //lpLineDevCaps->dwTerminalTextEntrySize
    //lpLineDevCaps->dwTerminalTextSize;
    //lpLineDevCaps->dwTerminalTextOffset
    //lpLineDevCaps->dwDevSpecificSize
    //lpLineDevCaps->dwDevSpecificOffset

    if (dwTSPIVersion >= 0x00010004)
    {
        lpLineDevCaps->dwBearerModes = AllBearerModes1_4;
        lpLineDevCaps->dwMediaModes  = AllMediaModes1_4;

        lpLineDevCaps->dwLineFeatures = AllLineFeatures1_0;

        if (dwTSPIVersion >= 0x00020000)
        {
            lpLineDevCaps->dwBearerModes  = AllBearerModes2_0;

            lpLineDevCaps->dwLineFeatures = AllLineFeatures2_0;

            //lpLineDevCaps->dwSettableDevStatus
            //lpLineDevCaps->dwDeviceClassesSize
            //lpLineDevCaps->dwDeviceClassesOffset

            if (dwTSPIVersion >= 0x00020001)
            {
                lpLineDevCaps->dwMediaModes = AllMediaModes2_1;

                if (dwTSPIVersion >= 0x00020002)
                {
                    *((LPDWORD) &lpLineDevCaps->PermanentLineGuid.Data2) =
                    *((LPDWORD) &lpLineDevCaps->PermanentLineGuid.Data4[0]) =
                    *((LPDWORD) &lpLineDevCaps->PermanentLineGuid.Data4[4]) =
                        DRVLINE_KEY;

                    if (dwTSPIVersion >= 0x00030000)
                    {
                        lpLineDevCaps->dwAddressTypes =
                            LINEADDRESSTYPE_PHONENUMBER    |
                            LINEADDRESSTYPE_SDP            |
                            LINEADDRESSTYPE_EMAILNAME      |
                            LINEADDRESSTYPE_DOMAINNAME     |
                            LINEADDRESSTYPE_IPADDRESS;
                        lpLineDevCaps->dwAvailableTracking =
                              LINECALLHUBTRACKING_ALLCALLS;

                        lpLineDevCaps->PermanentLineGuid.Data1 = (long)
                            (dwDeviceID - gESPGlobals.dwLineDeviceIDBase);
                    }
                }
            }
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD       dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR     lpszDeviceClass
    )
{
    static char szFuncName[] = "lineGetDevConfig";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,         dwDeviceID      },
        { "lpDeviceConfig",     lpDeviceConfig  },
        { "lpszDeviceClass",    lpszDeviceClass }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
        // BUGBUG TSPI_lineGetDevConfig: fill in dev config
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    static char szFuncName[] = "lineGetExtensionID";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "lpExtensionID",  lpExtensionID   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
        // BUGBUG TSPI_lineGetExtensionID: fill in ext id
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetIcon(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    static char szFuncName[] = "lineGetIcon";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,         dwDeviceID      },
        { "lpszDeviceClass",    lpszDeviceClass },
        { "lphIcon",            lphIcon         }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
        if (lpszDeviceClass  &&

            My_lstrcmpiW (
                (WCHAR *) lpszDeviceClass,
                (WCHAR *) (L"tapi/InvalidDeviceClass")

                ) == 0)
        {
            info.lResult = LINEERR_INVALDEVICECLASS;
        }
        else
        {
            *lphIcon = gESPGlobals.hIconLine;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    static char szFuncName[] = "lineGetID";
    FUNC_PARAM params[] =
    {
        { szhdLine,             hdLine          },
        { "dwAddressID",        dwAddressID     },
        { szhdCall,             hdCall          },
        { "dwSelect",           dwSelect,   aCallSelects    },
        { "lpDeviceID",         lpDeviceID      },
        { "lpszDeviceClass",    lpszDeviceClass },
        { "hTargetProcess",     hTargetProcess }
    };
    FUNC_INFO info = { szFuncName, SYNC, 7, params };
    PDRVLINE pLine = (PDRVLINE) hdLine;
    PDRVCALL pCall = (PDRVCALL) hdCall;
    DWORD    i, dwDeviceID, dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);


    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    for (i = 0; aszDeviceClasses[i]; i++)
    {
        if (My_lstrcmpiW(
                (WCHAR *) lpszDeviceClass,
                (WCHAR *) aszDeviceClasses[i]

                ) == 0)
        {
            break;
        }
    }

    if (!aszDeviceClasses[i])
    {
        info.lResult = LINEERR_NODEVICE;
        return (Epilog (&info));
    }

    if (dwSelect == LINECALLSELECT_ADDRESS  &&
        dwAddressID >= gESPGlobals.dwNumAddressesPerLine)
    {
        info.lResult = LINEERR_INVALADDRESSID;
        return (Epilog (&info));
    }

    if (lpDeviceID->dwTotalSize < dwNeededSize)
    {
        lpDeviceID->dwNeededSize = dwNeededSize;
        lpDeviceID->dwUsedSize = 3 * sizeof(DWORD);

        return (Epilog (&info));
    }

    switch (i)
    {
        case 0:
            // tapi/line

            if (dwSelect == LINECALLSELECT_CALL)
            {
                dwDeviceID = ((PDRVLINE) pCall->pLine)->dwDeviceID;
            }
            else
            {
                dwDeviceID = pLine->dwDeviceID;
            }

            break;

        case 1:

            // tapi/phone

            dwDeviceID = gESPGlobals.dwPhoneDeviceIDBase;

            break;

        default:

            dwDeviceID = 0;

            break;
    }

    lpDeviceID->dwNeededSize   =
    lpDeviceID->dwUsedSize     = dwNeededSize;
    lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
    lpDeviceID->dwStringSize   = sizeof(DWORD);
    lpDeviceID->dwStringOffset = sizeof(VARSTRING);

    *((LPDWORD)(lpDeviceID + 1)) = dwDeviceID;

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    static char szFuncName[] = "lineGetLineDevStatus";
    FUNC_PARAM params[] =
    {
        { szhdLine,             hdLine          },
        { "lpLineDevStatus",    lpLineDevStatus }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 2, params };
    PDRVLINE    pLine = (PDRVLINE) hdLine;
    DWORD       dwTotalSize, dwNeededSize;


    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    //lpLineDevStatus->dwNeededSize
    //lpLineDevStatus->dwUsedSize
    //lpLineDevStatus->dwNumOpens             tapi fills this in
    //lpLineDevStatus->dwOpenMediaModes       tapi fills this in


    //
    // Safely determine the # of active, on hold, & onhold pending
    // conference/transfer calls on this line
    //

    {
        DWORD       i;
        PDRVCALL    pCall;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        for (i = 0; i < gESPGlobals.dwNumAddressesPerLine; i++)
        {
            for(
                pCall = pLine->aAddrs[i].pCalls;
                pCall != NULL;
                pCall = pCall->pNext
                )
            {
                switch (pCall->dwCallState)
                {
                case LINECALLSTATE_IDLE:

                    continue;

                case LINECALLSTATE_ONHOLD:

                    lpLineDevStatus->dwNumOnHoldCalls++;
                    continue;

                case LINECALLSTATE_ONHOLDPENDCONF:
                case LINECALLSTATE_ONHOLDPENDTRANSFER:

                    lpLineDevStatus->dwNumOnHoldPendCalls++;
                    continue;

                default:

                    lpLineDevStatus->dwNumActiveCalls++;
                    continue;
                }
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    lpLineDevStatus->dwLineFeatures = AllLineFeatures1_0;
    //lpLineDevStatus->dwNumCallCompletions
    //lpLineDevStatus->dwRingMode
    //lpLineDevStatus->dwSignalLevel
    //lpLineDevStatus->dwBatteryLevel
    //lpLineDevStatus->dwRoamMode
    lpLineDevStatus->dwDevStatusFlags = LINEDEVSTATUSFLAGS_CONNECTED |
                                        LINEDEVSTATUSFLAGS_INSERVICE |
                                        pLine->dwMSGWAITFlag;               //smarandb #23974 winseqfe
    //lpLineDevStatus->dwTerminalModesSize
    //lpLineDevStatus->dwTerminalModesOffset
    //lpLineDevStatus->dwDevSpecificSize
    //lpLineDevStatus->dwDevSpecificOffset

    if (gESPGlobals.dwSPIVersion >= 0x20000)
    {
        lpLineDevStatus->dwLineFeatures = AllLineFeatures2_0;

        lpLineDevStatus->dwAvailableMediaModes = AllMediaModes1_4;

        //lpLineDevStatus->dwAppInfoSize;     tapi fills this in
        //lpLineDevStatus->dwAppInfoOffset;   tapi fills this in

        if (gESPGlobals.dwSPIVersion >= 0x20001)
        {
            lpLineDevStatus->dwAvailableMediaModes = AllMediaModes2_1;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
    )
{
    static char szFuncName[] = "lineGetNumAddressIDs";
    FUNC_PARAM params[] =
    {
        { szhdLine,             hdLine              },
        { "lpdwNumAddressIDs",  lpdwNumAddressIDs   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };
    PDRVLINE pLine = (PDRVLINE) hdLine;


    if (Prolog (&info))
    {
        *lpdwNumAddressIDs = gESPGlobals.dwNumAddressesPerLine;
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineHold_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


    if (pAsyncReqInfo->lResult == 0)
    {
        pAsyncReqInfo->lResult = SetCallState(
            pCall,
            dwCallInstThen,
            LINECALLSTATE_CONNECTED,
            LINECALLSTATE_ONHOLD,
            0,
            TRUE
            );
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineHold(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static char szFuncName[] = "lineHold";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        2,
        params,
        TSPI_lineHold_postProcess

    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam2 = dwCallInstance;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineMakeCall_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       bDestAddress   = (DWORD) pAsyncReqInfo->dwParam3,
                bValidLineID   = (DWORD) pAsyncReqInfo->dwParam4,
                dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam6,
                dwCallInstNow;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam1,
                pDestCall = (PDRVCALL) pAsyncReqInfo->dwParam2;
    PDRVLINE    pDestLine = (PDRVLINE) pAsyncReqInfo->dwParam5;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        if (bDestAddress)
        {
            if (bValidLineID && !pDestCall)
            {
                SetCallState(
                    pCall,
                    dwCallInstThen,
                    0xffffffff,
                    LINECALLSTATE_BUSY,
                    LINEBUSYMODE_UNAVAIL,
                    TRUE
                    );
            }
            else
            {
                SetCallState(
                    pCall,
                    dwCallInstThen,
                    0xffffffff,
                    LINECALLSTATE_DIALING,
                    0,
                    FALSE
                    );

                SetCallState(
                    pCall,
                    dwCallInstThen,
                    0xffffffff,
                    LINECALLSTATE_RINGBACK,
                    0,
                    TRUE
                    );
            }

            if (pDestCall)
            {
                EnterCriticalSection (&gESPGlobals.CallListCritSec);

                if (IsValidDrvCall (pCall, &dwCallInstNow) &&
                    dwCallInstNow == dwCallInstThen)
                {
                    SendLineEvent(
                        pDestLine,
                        NULL,
                        LINE_NEWCALL,
                        (ULONG_PTR) pDestCall,
                        (ULONG_PTR) &pDestCall->htCall,
                        0
                        );

                    if (pDestCall->htCall != NULL)
                    {
                        SetCallState(
                            pDestCall,
                            pDestCall->dwCallInstance,
                            0xffffffff,
                            LINECALLSTATE_OFFERING,
                            0,
                            TRUE
                            );
                    }
                    else
                    {
                        FreeCall (pDestCall, pDestCall->dwCallInstance);
                    }
                }
                else
                {
                    FreeCall (pDestCall, pDestCall->dwCallInstance);
                }

                LeaveCriticalSection (&gESPGlobals.CallListCritSec);
            }
        }
        else
        {
            SetCallState(
                pCall,
                dwCallInstThen,
                0xffffffff,
                LINECALLSTATE_DIALTONE,
                0,
                TRUE
                );
        }
    }
    else
    {
        FreeCall (pCall, dwCallInstThen);

        if (pDestCall)
        {
            FreeCall (pDestCall, pDestCall->dwCallInstance);
        }
    }
}


LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static char szFuncName[] = "lineMakeCall";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdLine,             hdLine          },
        { "htCall",             htCall          },
        { "lphdCall",           lphdCall        },
        { "lpszDestAddress",    lpszDestAddress },
        { "dwCountryCode",      dwCountryCode   },
        { szlpCallParams,       lpCallParams    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        7,
        params,
        TSPI_lineMakeCall_postProcess

    };

    if (Prolog (&info))
    {
        BOOL        bValidLineID = FALSE;
        LONG        lResult;
        PDRVCALL    pCall, pDestCall;
        PDRVLINE    pLine = (PDRVLINE) hdLine, pDestLine;


        if ((lResult = AllocCall (pLine, htCall, lpCallParams, &pCall)) == 0)
        {
            *lphdCall = (HDRVCALL) pCall;

            CreateIncomingCall(
                lpszDestAddress,
                lpCallParams,
                pCall,
                &bValidLineID,
                &pDestLine,
                &pDestCall
                );

            info.pAsyncReqInfo->dwParam1 = pCall;
            info.pAsyncReqInfo->dwParam2 = pDestCall;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) lpszDestAddress;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) bValidLineID;
            info.pAsyncReqInfo->dwParam5 = pDestLine;
            info.pAsyncReqInfo->dwParam6 = pCall->dwCallInstance;
        }
        else
        {
            info.lResult = lResult;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL    hdCall,
    DWORD       dwDigitModes
    )
{
    static char szFuncName[] = "lineMonitorDigits";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "dwDigitModes",   dwDigitModes,   aDigitModes }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };
    PDRVCALL pCall = (PDRVCALL) hdCall;


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineMonitorMedia(
    HDRVCALL    hdCall,
    DWORD       dwMediaModes
    )
{
    static char szFuncName[] = "lineMonitorMedia";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall                      },
        { "dwMediaModes",   dwMediaModes,   aMediaModes }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };
    PDRVCALL pCall = (PDRVCALL) hdCall;


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineMonitorTones(
    HDRVCALL            hdCall,
    DWORD               dwToneListID,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    )
{
    static char szFuncName[] = "lineMonitorTones";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "dwToneListID",   dwToneListID    },
        { "lpToneList",     lpToneList      },
        { "dwNumEntries",   dwNumEntries    }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };
    PDRVCALL pCall = (PDRVCALL) hdCall;


    if (Prolog (&info))
    {
        DWORD       dwLastToneListID = 0;
        HTAPICALL   htCall;
        HTAPILINE   htLine;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            htLine = ((PDRVLINE) pCall->pLine)->htLine;
            htCall = pCall->htCall;

            if (gbAutoGatherGenerateMsgs)
            {
                dwLastToneListID = dwToneListID;
            }
            else
            {
                dwLastToneListID = pCall->dwMonitorToneListID;
                pCall->dwMonitorToneListID = dwToneListID;
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

        if (dwLastToneListID)
        {
            (gESPGlobals.pfnLineEvent)(
                htLine,
                htCall,
                LINE_MONITORTONE,
                0,
                dwLastToneListID,
                0
                );
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static char szFuncName[] = "lineNegotiateExtVersion";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwLowVersion",   dwLowVersion    },
        { "dwHighVersion",  dwHighVersion   },
        { "lpdwExtVersion", lpdwExtVersion  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 5, params };


    if (Prolog (&info))
    {
        if (dwLowVersion == 0 ||
            dwHighVersion == 0xffffffff ||
            dwLowVersion > dwHighVersion)
        {
            info.lResult = LINEERR_INCOMPATIBLEEXTVERSION;
        }
        else
        {
            *lpdwExtVersion = dwHighVersion;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    static char szFuncName[] = "lineNegotiateTSPIVersion";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,         dwDeviceID      },
        { "dwLowVersion",       dwLowVersion    },
        { "dwHighVersion",      dwHighVersion   },
        { "lpdwTSPIVersion",    lpdwTSPIVersion }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };


    if (Prolog (&info))
    {
        *lpdwTSPIVersion = gESPGlobals.dwSPIVersion;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
    )
{
    static char szFuncName[] = "lineOpen";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "htLine",         htLine          },
        { "lphdLine",       lphdLine        },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "lpfnEventProc",  lpfnEventProc   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 5, params };
    PDRVLINE pLine;


    if (Prolog (&info))
    {
        if ((pLine = GetLineFromID (dwDeviceID)))
        {
            pLine->htLine = htLine;

            *lphdLine = (HDRVLINE) pLine;

            WriteEventBuffer(
                pLine->dwDeviceID,
                WIDGETTYPE_LINE,
                (ULONG_PTR) pLine,
                (ULONG_PTR) htLine,
                0,
                0
                );
        }
        else
        {
            info.lResult = LINEERR_OPERATIONFAILED;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_linePark_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2,
                dwParkIndex = (DWORD) pAsyncReqInfo->dwParam4;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam1,
                pParkedCall = (PDRVCALL) pAsyncReqInfo->dwParam3,
                pDestCall;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        pDestCall = pCall->pDestCall;
        pCall->pDestCall = NULL;

        pParkedCall->bConnectedToDestCall =
            pCall->bConnectedToDestCall;

        pAsyncReqInfo->lResult = SetCallState(
            pCall,
            dwCallInstThen,
            LINECALLSTATE_CONNECTED,
            LINECALLSTATE_IDLE,
            0,
            TRUE
            );

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pDestCall, NULL))
        {
            pDestCall->pDestCall = pParkedCall;
            pParkedCall->pDestCall = pDestCall;
        }

// BUGBUG TSPI_linePark: what if dest call state chg while buddy parked???

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }
    else
    {
        //
        // Clean up parked call
        //

        if (pParkedCall->pSendingFlowspec)
        {
            DrvFree (pParkedCall->pSendingFlowspec);
        }

        if (pParkedCall->pReceivingFlowspec)
        {
            DrvFree (pParkedCall->pReceivingFlowspec);
        }

        if (pParkedCall->pCallData)
        {
            DrvFree (pParkedCall->pCallData);
        }

        DrvFree (pParkedCall);

        gaParkedCalls[dwParkIndex] = NULL;
    }
}


LONG
TSPIAPI
TSPI_linePark(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    DWORD           dwParkMode,
    LPCWSTR         lpszDirAddress,
    LPVARSTRING     lpNonDirAddress
    )
{
    static char szFuncName[] = "linePark";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "dwParkMode",         dwParkMode      },
        { "lpszDirAddress",     lpszDirAddress  },
        { "lpNonDirAddress",    lpNonDirAddress }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 5, params, NULL };
    PDRVCALL pCall = (PDRVCALL) hdCall;


    if (Prolog (&info))
    {
        if (dwParkMode == LINEPARKMODE_DIRECTED)
        {
            info.lResult = TransferCall(
                &info,
                pCall,
                LINECALLSTATE_CONNECTED | LINECALLSTATE_ONHOLD,
                LINECALLSTATE_ONHOLD,
                lpszDirAddress
                );
        }
        else
        {
            //
            // First check to see if buf is big enough to return parked addr
            //

            if (lpNonDirAddress->dwTotalSize <
                    (sizeof (VARSTRING) + 9 * sizeof(WCHAR))) // L"9999#123"
            {
                lpNonDirAddress->dwNeededSize = sizeof (VARSTRING) +
                    9 * sizeof(WCHAR);

                info.lResult = LINEERR_STRUCTURETOOSMALL;

                return (Epilog (&info));
            }

            EnterCriticalSection (&gESPGlobals.CallListCritSec);

            if (IsValidDrvCall (pCall, NULL) == FALSE)
            {
                info.lResult = LINEERR_INVALCALLHANDLE;
            }
            else if (pCall->dwCallState != LINECALLSTATE_CONNECTED  &&
                     pCall->dwCallState != LINECALLSTATE_ONHOLD)
            {
                info.lResult = LINEERR_INVALCALLSTATE;
            }
            else
            {
                DWORD i;


                for (i = 0; i < MAX_NUM_PARKED_CALLS; i++)
                {
                    if (gaParkedCalls[i] == NULL)
                    {
                        break;
                    }
                }

                if (i < MAX_NUM_PARKED_CALLS)
                {
                    //
                    // Create a new call struct, dup-ing all the info of
                    // the existing call, & stick it in the parking place
                    //

                    DWORD       dwStringSize;
                    PDRVCALL    pParkedCall;


                    if ((pParkedCall = DrvAlloc (sizeof (DRVCALL))))
                    {
                        char buf[16];


                        CopyMemory(
                            &pParkedCall->dwMediaMode,
                            &pCall->dwMediaMode,
                            8 * sizeof (DWORD) + sizeof (LINEDIALPARAMS)
                            );

                        if (pCall->pSendingFlowspec  &&
                            (pParkedCall->pSendingFlowspec =
                                DrvAlloc (pCall->dwSendingFlowspecSize)))

                        {
                            pParkedCall->dwSendingFlowspecSize =
                                pCall->dwSendingFlowspecSize;
                        }

                        if (pCall->pReceivingFlowspec  &&
                            (pParkedCall->pReceivingFlowspec =
                                DrvAlloc (pCall->dwReceivingFlowspecSize)))

                        {
                            pParkedCall->dwReceivingFlowspecSize =
                                pCall->dwReceivingFlowspecSize;
                        }

                        if (pCall->pCallData  &&
                            (pParkedCall->pCallData =
                                DrvAlloc (pCall->dwCallDataSize)))
                        {
                            pParkedCall->dwCallDataSize =
                                pCall->dwCallDataSize;
                        }

                        pParkedCall->dwCallInstance  = gdwCallInstance++;
                        pParkedCall->dwCallID        = pCall->dwCallID;
                        pParkedCall->dwRelatedCallID = pCall->dwRelatedCallID;
                        pParkedCall->dwAddressType   = pCall->dwAddressType;

                        gaParkedCalls[i] = pParkedCall;

                        wsprintfA (buf, "9999#%d", i);

                        dwStringSize = (DWORD) MultiByteToWideChar(
                           GetACP(),
                           MB_PRECOMPOSED,
                           (LPCSTR) buf,
                           lstrlenA (buf) + 1,
                           (LPWSTR) (lpNonDirAddress + 1),
                           9
                           ) * sizeof (WCHAR);

                        lpNonDirAddress->dwNeededSize += dwStringSize;
                        lpNonDirAddress->dwUsedSize   += dwStringSize;

                        lpNonDirAddress->dwStringFormat = STRINGFORMAT_UNICODE;
                        lpNonDirAddress->dwStringSize   = dwStringSize;
                        lpNonDirAddress->dwStringOffset = sizeof (VARSTRING);

                        info.pAsyncReqInfo->pfnPostProcessProc = (FARPROC)
                            TSPI_linePark_postProcess;

                        info.pAsyncReqInfo->dwParam1 = pCall;
                        info.pAsyncReqInfo->dwParam2 = pCall->dwCallInstance;
                        info.pAsyncReqInfo->dwParam3 = pParkedCall;
                        info.pAsyncReqInfo->dwParam4 = i;
                    }
                    else
                    {
                        info.lResult = LINEERR_NOMEM;
                    }
                }
                else
                {
                    ShowStr(
                        TRUE,
                        "TSPI_linePark (undirected): no available " \
                            "parking spaces"
                        );

                    info.lResult = LINEERR_OPERATIONFAILED;
                }
            }

            LeaveCriticalSection (&gESPGlobals.CallListCritSec);
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_linePickup_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD      dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
    PDRVCALL   pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        SetCallState(
            pCall,
            dwCallInstThen,
            0xffffffff,
            LINECALLSTATE_OFFERING,
            0,
            TRUE
            );
    }
    else
    {
        FreeCall (pCall, dwCallInstThen);
    }
}


LONG
TSPIAPI
TSPI_linePickup(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPICALL       htCall,
    LPHDRVCALL      lphdCall,
    LPCWSTR         lpszDestAddress,
    LPCWSTR         lpszGroupID
    )
{
    static char szFuncName[] = "linePickup";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdLine,             hdLine          },
        { "dwAddressID",        dwAddressID     },
        { "htCall",             htCall          },
        { "lphdCall",           lphdCall        },
        { "lpszDestAddress",    lpszDestAddress },
        { "lpszGroupID",        lpszGroupID     }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        7,
        params,
        TSPI_linePickup_postProcess
    };


    if (Prolog (&info))
    {
        LONG        lResult;
        PDRVCALL    pCall;


        if ((lResult = AllocCall(
                (PDRVLINE) hdLine,
                htCall,
                NULL,
                &pCall

                )) == 0)
        {
            // BUGBUG deal w/ addr id

            *lphdCall = (HDRVCALL) pCall;

            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) pCall;
            info.pAsyncReqInfo->dwParam2 = pCall->dwCallInstance;
        }
        else
        {
            info.lResult = lResult;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_linePrepareAddToConference_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwConfCallInstThen    = (DWORD) pAsyncReqInfo->dwParam1,
                dwConsultCallInstThen = (DWORD) pAsyncReqInfo->dwParam4;
    PDRVCALL    pConfCall    = (PDRVCALL) pAsyncReqInfo->dwParam2,
                pConsultCall = (PDRVCALL) pAsyncReqInfo->dwParam3;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        SetCallState(
            pConfCall,
            dwConfCallInstThen,
            LINECALLSTATE_CONNECTED,
            LINECALLSTATE_ONHOLDPENDCONF,
            0,
            TRUE
            );

        SetCallState(
            pConsultCall,
            dwConsultCallInstThen,
            0xffffffff,
            LINECALLSTATE_DIALTONE,
            0,
            TRUE
            );
    }
    else
    {
        FreeCall (pConsultCall, dwConsultCallInstThen);
    }
}


LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    LONG        lResult;
    PDRVCALL    pConsultCall;
    static char szFuncName[] = "linePrepareAddToConference";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID         },
        { "hdConfCall",         hdConfCall          },
        { "htConsultCall",      htConsultCall       },
        { "lphdConsultCall",    lphdConsultCall     },
        { szlpCallParams,       lpCallParams        }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        5,
        params,
        TSPI_linePrepareAddToConference_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdConfCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdConfCall;

            if ((lResult = AllocCall(
                    ((PDRVCALL) hdConfCall)->pLine,
                    htConsultCall,
                    lpCallParams,
                    &pConsultCall

                    )) == 0)
            {
                info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) pConsultCall;
                info.pAsyncReqInfo->dwParam4 = pConsultCall->dwCallInstance;

                *lphdConsultCall = (HDRVCALL) pConsultCall;
            }
            else
            {
                info.lResult = lResult;
            }
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineRedirect(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static char szFuncName[] = "lineRedirect";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpszDestAddress",    lpszDestAddress },
        { "dwCountryCode",      dwCountryCode   }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 4, params, NULL };
    PDRVCALL pCall = (PDRVCALL) hdCall;


    if (Prolog (&info))
    {
        info.lResult = TransferCall(
            &info,
            (PDRVCALL) hdCall,
            LINECALLSTATE_OFFERING,
            LINECALLSTATE_OFFERING,
            lpszDestAddress
            );
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static char szFuncName[] = "lineReleaseUserUserInfo";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 2, params, NULL };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineRemoveFromConference_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    if (pAsyncReqInfo->lResult == 0)
    {

        DWORD      dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2;
        PDRVCALL   pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if ((pAsyncReqInfo->lResult = SetCallState(
                pCall,
                dwCallInstThen,
                LINECALLSTATE_CONFERENCED,
                LINECALLSTATE_CONNECTED,
                0,
                TRUE

                )) == 0)
        {
            PDRVCALL   pCall2 = (PDRVCALL) pCall->pConfParent;


            while (pCall2 && (pCall2->pNextConfChild != pCall))
            {
                pCall2 = pCall2->pNextConfChild;
            }

            if (pCall2)
            {
                pCall2->pNextConfChild = pCall->pNextConfChild;
            }

            pCall->pConfParent = NULL;

            /*
            pCall->dwRelatedCallID = 0;

            SendLineEvent(
                pCall->pLine,
                pCall,
                LINE_CALLINFO,
                LINECALLINFOSTATE_RELATEDCALLID,
                0,
                0
                );
            */

            // create a new callid for the break away conf leg
            // this create a new call hub
            pCall->dwCallID =  (++gdwCallID ? gdwCallID : ++gdwCallID);
            SendLineEvent(
                    pCall->pLine,
                    pCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );

            if (pCall->pDestCall)
            {
                // BUGBUG  chg buddy's call hub id, and check to see if
                //         buddy is in a conf (if so will need to munge
                //         the conf too (?)
                                         
                // give the call's buddy the same callid, this puts it 
                // into the same call hub
                pCall->pDestCall->dwCallID = pCall->dwCallID;
                SendLineEvent(
                        pCall->pDestCall->pLine,
                        pCall->pDestCall,
                        LINE_CALLINFO,
                        LINECALLINFOSTATE_CALLID,
                        0,
                        0
                        );
                
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static char szFuncName[] = "lineRemoveFromConference";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        2,
        params,
        TSPI_lineRemoveFromConference_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam2 = dwCallInstance;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static char szFuncName[] = "lineSecureCall";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 2, params, NULL };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE    hdLine,
    DWORD       dwExtVersion
    )
{
    static char szFuncName[] = "lineSelectExtVersion";
    FUNC_PARAM params[] =
    {
        { szhdLine,         hdLine          },
        { "dwExtVersion",   dwExtVersion    }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "lineSendUserUserInfo";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "lpsUserUserInfo",    lpsUserUserInfo },
        { szdwSize,             dwSize          }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 4, params, NULL };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL    hdCall,
    DWORD       dwAppSpecific
    )
{
    static char szFuncName[] = "lineSetAppSpecific";
    FUNC_PARAM params[] =
    {
        { szhdCall,         hdCall          },
        { "dwAppSpecific",  dwAppSpecific   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
        PDRVCALL pCall = (PDRVCALL) hdCall;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            if (pCall->dwAppSpecific != dwAppSpecific)
            {
                pCall->dwAppSpecific = dwAppSpecific;

                SendLineEvent(
                    pCall->pLine,
                    pCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_APPSPECIFIC,
                    0,
                    0
                    );
            }
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSetCallData_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                dwCallInstNow,
                dwCallDataSize = (DWORD) pAsyncReqInfo->dwParam4;
    LPVOID      pCallData = (LPVOID) pAsyncReqInfo->dwParam3, pToFree;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam2;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, &dwCallInstNow) &&
            dwCallInstNow == dwCallInstThen)
        {
            pToFree               = pCall->pCallData;
            pCall->pCallData      = pCallData;
            pCall->dwCallDataSize = dwCallDataSize;

            SendLineEvent(
                pCall->pLine,
                pCall,
                LINE_CALLINFO,
                LINECALLINFOSTATE_CALLDATA,
                0,
                0
                );
        }
        else
        {
            pToFree = NULL;
            pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

        DrvFree (pToFree);
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult != 0)
    {
        DrvFree (pCallData);
    }
}


LONG
TSPIAPI
TSPI_lineSetCallData(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    )
{
    static char szFuncName[] = "lineSetCallData";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      },
        { "lpCallData",     lpCallData  },
        { szdwSize,         dwSize      }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_lineSetCallData_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            LPVOID  pCallData;


            if (dwSize)
            {
                if ((pCallData = DrvAlloc (dwSize)))
                {
                    CopyMemory (pCallData, lpCallData, dwSize);
                }
                else
                {
                    info.lResult = LINEERR_NOMEM;
                }
            }
            else
            {
                pCallData = NULL;
            }

            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) pCallData;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) dwSize;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetCallHubTracking(
    HDRVLINE                    hdLine,
    LPLINECALLHUBTRACKINGINFO   lpTrackingInfo
    )
{
    static char szFuncName[] = "lineSetCallHubTracking";
    FUNC_PARAM params[] =
    {
        { szhdLine,         hdLine         },
        { "lpTrackingInfo", lpTrackingInfo }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params, NULL };


    if (Prolog (&info))
    {
        // BUGBUG
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSetCallParams_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD               dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                        dwCallInstNow,
                        dwBearerMode = (DWORD) pAsyncReqInfo->dwParam3,
                        dwMinRate = (DWORD) pAsyncReqInfo->dwParam4,
                        dwMaxRate = (DWORD) pAsyncReqInfo->dwParam5;
    PDRVCALL            pCall = pAsyncReqInfo->dwParam2;
    LPLINEDIALPARAMS    pDialParams = pAsyncReqInfo->dwParam6;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, &dwCallInstNow)  &&
            dwCallInstNow == dwCallInstThen)
        {
            DWORD   dwCallInfoStates = 0;


            if (pCall->dwBearerMode != dwBearerMode)
            {
                pCall->dwBearerMode = dwBearerMode;
                dwCallInfoStates |= LINECALLINFOSTATE_BEARERMODE;
            }

            if (pCall->dwMinRate != dwMinRate ||
                pCall->dwMaxRate != dwMaxRate)
            {
                pCall->dwMinRate = dwMinRate;
                pCall->dwMaxRate = dwMaxRate;
                dwCallInfoStates |= LINECALLINFOSTATE_RATE;
            }

            if (pDialParams &&
                (pCall->DialParams.dwDialPause != pDialParams->dwDialPause ||
                pCall->DialParams.dwDialSpeed  != pDialParams->dwDialSpeed ||
                pCall->DialParams.dwDigitDuration !=
                    pDialParams->dwDigitDuration ||
                pCall->DialParams.dwWaitForDialtone !=
                    pDialParams->dwWaitForDialtone))
            {
                pCall->DialParams.dwDialPause       = pDialParams->dwDialPause;
                pCall->DialParams.dwDialSpeed       = pDialParams->dwDialSpeed;
                pCall->DialParams.dwDigitDuration   =
                    pDialParams->dwDigitDuration;
                pCall->DialParams.dwWaitForDialtone =
                    pDialParams->dwWaitForDialtone;

                dwCallInfoStates |= LINECALLINFOSTATE_DIALPARAMS;
            }

            if (dwCallInfoStates)
            {
                SendLineEvent(
                    pCall->pLine,
                    pCall,
                    LINE_CALLINFO,
                    dwCallInfoStates,
                    0,
                    0
                    );
            }
        }
        else
        {
            pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    if (pDialParams)
    {
        DrvFree (pDialParams);
    }
}


LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
    static char szFuncName[] = "lineSetCallParams";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID                     },
        { szhdCall,         hdCall                          },
        { "dwBearerMode",   dwBearerMode,   aBearerModes    },
        { "dwMinRate",      dwMinRate                       },
        { "dwMaxRate",      dwMaxRate                       },
        { "lpDialParams",   lpDialParams                    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        6,
        params,
        TSPI_lineSetCallParams_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam3 = dwBearerMode;
            info.pAsyncReqInfo->dwParam4 = dwMinRate;
            info.pAsyncReqInfo->dwParam5 = dwMaxRate;

            if (lpDialParams)
            {
                LPLINEDIALPARAMS pDialParams;


                if ((pDialParams = DrvAlloc (sizeof (LINEDIALPARAMS))))
                {
                    CopyMemory(
                        pDialParams,
                        lpDialParams,
                        sizeof (LINEDIALPARAMS)
                        );

                    info.pAsyncReqInfo->dwParam8 = (ULONG_PTR) pDialParams;
                }
                else
                {
                    info.lResult = LINEERR_NOMEM;
                }
            }
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSetCallQualityOfService_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                dwCallInstNow,
                dwSendingFlowspecSize = (DWORD) pAsyncReqInfo->dwParam4,
                dwReceivingFlowspecSize = (DWORD) pAsyncReqInfo->dwParam6;
    LPVOID      pSendingFlowspec = (LPVOID) pAsyncReqInfo->dwParam3,
                pReceivingFlowspec = (LPVOID) pAsyncReqInfo->dwParam5,
                pToFree, pToFree2;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam2;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, &dwCallInstNow)  &&
            dwCallInstNow == dwCallInstThen)
        {
            pToFree                      = pCall->pSendingFlowspec;
            pCall->pSendingFlowspec      = pSendingFlowspec;
            pCall->dwSendingFlowspecSize = dwSendingFlowspecSize;

            pToFree2                       = pCall->pReceivingFlowspec;
            pCall->pReceivingFlowspec      = pReceivingFlowspec;
            pCall->dwReceivingFlowspecSize = dwReceivingFlowspecSize;

            SendLineEvent(
                pCall->pLine,
                pCall,
                LINE_CALLINFO,
                LINECALLINFOSTATE_QOS,
                0,
                0
                );
        }
        else
        {
            pToFree = pToFree2 = NULL;
            pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);

        DrvFree (pToFree);
        DrvFree (pToFree2);
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult != 0)
    {
        DrvFree (pSendingFlowspec);
        DrvFree (pReceivingFlowspec);
    }

}


LONG
TSPIAPI
TSPI_lineSetCallQualityOfService(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    )
{
    static char szFuncName[] = "lineSetCallQualityOfService";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,                dwRequestID             },
        { szhdCall,                     hdCall                  },
        { "lpSendingFlowspec",          lpSendingFlowspec       },
        { "dwSendingFlowspecSize",      dwSendingFlowspecSize   },
        { "lpReceivingFlowspec",        lpReceivingFlowspec     },
        { "dwReceivingFlowspecSize",    dwReceivingFlowspecSize }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        6,
        params,
        TSPI_lineSetCallQualityOfService_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            LPVOID  pSendingFlowspec, pReceivingFlowspec;


            if (dwSendingFlowspecSize)
            {
                if ((pSendingFlowspec = DrvAlloc (dwSendingFlowspecSize)))
                {
                    CopyMemory(
                        pSendingFlowspec,
                        lpSendingFlowspec,
                        dwSendingFlowspecSize
                        );
                }
                else
                {
                    info.lResult = LINEERR_NOMEM;
                    goto TSPI_lineSetCallQualityOfService_epilog;
                }
            }
            else
            {
                pSendingFlowspec = NULL;
            }

            if (dwReceivingFlowspecSize)
            {
                if ((pReceivingFlowspec = DrvAlloc (dwReceivingFlowspecSize)))
                {
                    CopyMemory(
                        pReceivingFlowspec,
                        lpReceivingFlowspec,
                        dwReceivingFlowspecSize
                        );
                }
                else
                {
                    info.lResult = LINEERR_NOMEM;

                    if (pSendingFlowspec)
                    {
                        DrvFree (pSendingFlowspec);

                    }

                    goto TSPI_lineSetCallQualityOfService_epilog;
                }
            }
            else
            {
                pReceivingFlowspec = NULL;
            }

            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) pSendingFlowspec;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) dwSendingFlowspecSize;
            info.pAsyncReqInfo->dwParam5 = (ULONG_PTR) pReceivingFlowspec;
            info.pAsyncReqInfo->dwParam6 = (ULONG_PTR) dwReceivingFlowspecSize;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

TSPI_lineSetCallQualityOfService_epilog:

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSetCallTreatment_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                dwCallInstNow,
                dwTreatment = (DWORD) pAsyncReqInfo->dwParam3;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam2;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, &dwCallInstNow) &&
            dwCallInstNow == dwCallInstThen)
        {
            if (pCall->dwTreatment != dwTreatment)
            {
                pCall->dwTreatment = dwTreatment;

                SendLineEvent(
                    pCall->pLine,
                    pCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_TREATMENT,
                    0,
                    0
                    );
            }
        }
        else
        {
            pAsyncReqInfo->lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineSetCallTreatment(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwTreatment
    )
{
    static char szFuncName[] = "lineSetCallTreatment";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      },
        { "dwTreatment",    dwTreatment }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        3,
        params,
        TSPI_lineSetCallTreatment_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
            info.pAsyncReqInfo->dwParam3 = dwTreatment;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetCurrentLocation(
    DWORD   dwLocation
    )
{
    static char szFuncName[] = "lineSetCurrentLocation";
    FUNC_PARAM params[] =
    {
        { "dwLocation", dwLocation }
    };
    FUNC_INFO info = { szFuncName, SYNC, 1, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    static char szFuncName[] = "lineSetDefaultMediaDetection";
    FUNC_PARAM params[] =
    {
        { szhdLine,         hdLine                      },
        { "dwMediaModes",   dwMediaModes,   aMediaModes }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 2, params };
    PDRVLINE    pLine = (PDRVLINE) hdLine;


    if (Prolog (&info))
    {
        pLine->dwMediaModes = dwMediaModes;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    static char szFuncName[] = "lineSetDevConfig";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,         dwDeviceID      },
        { "lpDeviceConfig",     lpDeviceConfig  },
        { szdwSize,             dwSize          },
        { "lpszDeviceClass",    lpszDeviceClass }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetLineDevStatus(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    )
{
    static char szFuncName[] = "lineSetLineDevStatus";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID      },
        { szhdLine,             hdLine           },
        { "dwStatusToChange",   dwStatusToChange },
        { "fStatus",            fStatus          }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 4, params, NULL };
    PDRVLINE  pLine = (PDRVLINE) hdLine;


    if (Prolog (&info))
    {
        //
        // smarandb #23974 winseqfe: 
        //

        if (dwStatusToChange == LINEDEVSTATUSFLAGS_MSGWAIT)
        {

            // save new MSGWAIT value 
            pLine->dwMSGWAITFlag = fStatus?LINEDEVSTATUSFLAGS_MSGWAIT:0;

            // send event to notify that value has changed; 
            // Note: real TSP-s should send the event only if the MSGWAIT value has really changed 
            // (in other words don't send the event if the same MSGWAIT value is set twice in a row)

            // Here, we will send the event even if the value didn't change, 
            // because we want to help testing winseqfe bug #23974 (tapi3.dll possible infinite loop)

            SendLineEvent(
                pLine,
                NULL,
                LINE_LINEDEVSTATE,
                fStatus?LINEDEVSTATE_MSGWAITON:LINEDEVSTATE_MSGWAITOFF,
                0,
                0
                );
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetMediaControl(
    HDRVLINE                    hdLine,
    DWORD                       dwAddressID,
    HDRVCALL                    hdCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD                       dwCallStateNumEntries
    )
{
    static char szFuncName[] = "lineSetMediaControl";
    FUNC_PARAM params[] =
    {
        { szhdLine,                 hdLine                  },
        { "dwAddressID",            dwAddressID             },
        { szhdCall,                 hdCall                  },
        { "dwSelect",               dwSelect,   aCallSelects    },
        { "lpDigitList",            lpDigitList             },
        { "dwDigitNumEntries",      dwDigitNumEntries       },
        { "lpMediaList",            lpMediaList             },
        { "dwMediaNumEntries",      dwMediaNumEntries       },
        { "lpToneList",             lpToneList              },
        { "dwToneNumEntries",       dwToneNumEntries        },
        { "lpCallStateList",        lpCallStateList         },
        { "dwCallStateNumEntries",  dwCallStateNumEntries   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 12, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
    )
{
    static char szFuncName[] = "lineSetMediaMode";
    FUNC_PARAM params[] =
    {
        { szhdCall,         szhdCall                  },
        { "dwMediaMode",    dwMediaMode,  aMediaModes }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
        PDRVCALL pCall = (PDRVCALL) hdCall;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall (pCall, NULL))
        {
            if (pCall->dwMediaMode != dwMediaMode)
            {
                pCall->dwMediaMode = dwMediaMode;

                SendLineEvent(
                    pCall->pLine,
                    pCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_MEDIAMODE,
                    0,
                    0
                    );
            }
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE    hdLine,
    DWORD       dwLineStates,
    DWORD       dwAddressStates
    )
{
    static char szFuncName[] = "lineSetStatusMessages";
    FUNC_PARAM params[] =
    {
        { szhdLine,             hdLine          },
        { "dwLineStates",       dwLineStates,   aLineStates },
        { "dwAddressStates",    dwAddressStates,    aAddressStates  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineSetTerminal(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    DWORD           dwSelect,
    DWORD           dwTerminalModes,
    DWORD           dwTerminalID,
    DWORD           bEnable
    )
{
    static char szFuncName[] = "lineSetTerminal";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdLine,             hdLine          },
        { "dwAddressID",        dwAddressID     },
        { szhdCall,             hdCall          },
        { "dwSelect",           dwSelect,   aCallSelects    },
        { "dwTerminalModes",    dwTerminalModes,    aTerminalModes  },
        { "dwTerminalID",       dwTerminalID    },
        { "bEnable",            bEnable         }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 8, params, NULL };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSetupConference_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                dwConfCallInstThen = (DWORD) pAsyncReqInfo->dwParam4,
                dwConsultCallInstThen = (DWORD) pAsyncReqInfo->dwParam6;
    PDRVCALL    pCall        = (PDRVCALL) pAsyncReqInfo->dwParam2,
                pConfCall    = (PDRVCALL) pAsyncReqInfo->dwParam3,
                pConsultCall = (PDRVCALL) pAsyncReqInfo->dwParam5;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (SetCallState(
                pConfCall,
                dwConfCallInstThen,
                0xffffffff, // we created this call right now - no initial state reqs.
                LINECALLSTATE_ONHOLDPENDCONF,
                0,
                TRUE

                ) == 0)
        {
         
            /*
            pConfCall->dwCallID = pCall->dwCallID;
            SendLineEvent(
                    pConfCall->pLine,
                    pConfCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );
            */

            if (pCall  &&
                SetCallState(
                    pCall,
                    dwCallInstThen,
                    LINECALLSTATE_CONNECTED,
                    LINECALLSTATE_CONFERENCED,
                    pConfCall->htCall,
                    TRUE

                    ) == 0)
            {
                pCall->pConfParent = pConfCall;
                pConfCall->pNextConfChild = pCall;
            }

            // The consult call isn't in the conf initially

         	// 
            // Note - indecision on the validity of this transition
            //        SDK allows it, internal TAPI documents by NoelA do not.
            //

            SetCallState(
                pConsultCall,
                dwConsultCallInstThen,
                0xffffffff, // we created this call right now - no initial state reqs.
                LINECALLSTATE_DIALTONE,
                0,
                TRUE
                );
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }
    else
    {
        FreeCall (pConfCall, dwConfCallInstThen);
        FreeCall (pConsultCall, dwConsultCallInstThen);
    }
}


LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HDRVLINE            hdLine,
    HTAPICALL           htConfCall,
    LPHDRVCALL          lphdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static char szFuncName[] = "lineSetupConference";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { szhdLine,             hdLine          },
        { "htConfCall",         htConfCall      },
        { "lphdConfCall",       lphdConfCall    },
        { "htConsultCall",      htConsultCall   },
        { "lphdConsultCall",    lphdConsultCall },
        { "dwNumParties",       dwNumParties    },
        { szlpCallParams,       lpCallParams    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        9,
        params,
        TSPI_lineSetupConference_postProcess
    };


    if (Prolog (&info))
    {
        LONG        lResult;
        DWORD       dwCallInstance;
        PDRVCALL    pConfCall, pConsultCall;
        PDRVLINE    pLine;


        //info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdCall;

        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (hdCall  &&  !IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
            goto TSPI_lineSetupConference_leaveCritSec;
        }

        pLine = (hdCall ? (PDRVLINE) ((PDRVCALL) hdCall)->pLine :
            (PDRVLINE) hdLine);

        if ((lResult = AllocCall(
                pLine,
                htConfCall,
                lpCallParams,
                &pConfCall

                )) == 0)
        {

            if (hdCall)
            {
                pConfCall->dwCallID = ((PDRVCALL) hdCall)->dwCallID;
            }
        
            if ((lResult = AllocCall(
                    pLine,
                    htConsultCall,
                    lpCallParams,
                    &pConsultCall

                    )) == 0)
            {
                info.pAsyncReqInfo->dwParam1 = dwCallInstance;
                info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
                info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) pConfCall;
                info.pAsyncReqInfo->dwParam4 = pConfCall->dwCallInstance;
                info.pAsyncReqInfo->dwParam5 = (ULONG_PTR) pConsultCall;
                info.pAsyncReqInfo->dwParam6 = pConsultCall->dwCallInstance;

                *lphdConfCall = (HDRVCALL) pConfCall;
                *lphdConsultCall = (HDRVCALL) pConsultCall;
            }
            else
            {
                FreeCall (pConfCall, pConfCall->dwCallInstance);
                info.lResult = lResult;
            }
        }
        else
        {
            info.lResult = lResult;
        }

TSPI_lineSetupConference_leaveCritSec:

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSetupTransfer_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                dwConsultCallInstThen = (DWORD) pAsyncReqInfo->dwParam4;
    PDRVCALL    pCall        = (PDRVCALL) pAsyncReqInfo->dwParam2,
                pConsultCall = (PDRVCALL) pAsyncReqInfo->dwParam3;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        if (SetCallState(
                pConsultCall,
                dwConsultCallInstThen,
                0xffffffff, // we created this call right now - no initial state reqs.
                LINECALLSTATE_DIALTONE,
                0,
                TRUE

                )  == 0)
        {
            SetCallState(
                pCall,
                dwCallInstThen,
                LINECALLSTATE_CONNECTED,
                LINECALLSTATE_ONHOLDPENDTRANSFER,
                0,
                TRUE
                );
        }
    }
    else
    {
        FreeCall (pConsultCall, dwConsultCallInstThen);
    }
}


LONG
TSPIAPI
TSPI_lineSetupTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static char szFuncName[] = "lineSetupTransfer";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdCall,             hdCall          },
        { "htConsultCall",      htConsultCall   },
        { "lphdConsultCall",    lphdConsultCall },
        { szlpCallParams,       lpCallParams    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        5,
        params,
        TSPI_lineSetupTransfer_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwCallInstance;


        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            LONG        lResult;
            PDRVCALL    pConsultCall;


            if ((lResult = AllocCall(
                    ((PDRVCALL) hdCall)->pLine,
                    htConsultCall,
                    lpCallParams,
                    &pConsultCall

                    )) == 0)
            {
                *lphdConsultCall = (HDRVCALL) pConsultCall;

                info.pAsyncReqInfo->dwParam1 = dwCallInstance;
                info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
                info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) pConsultCall;
                info.pAsyncReqInfo->dwParam4 = pConsultCall->dwCallInstance;
            }
            else
            {
                info.lResult = lResult;
            }
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineSwapHold_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwActiveCallInstThen = (DWORD) pAsyncReqInfo->dwParam1,
                dwHeldCallInstThen   = (DWORD) pAsyncReqInfo->dwParam2,
                dwActiveCallInstNow, dwHeldCallInstNow;
    PDRVCALL    pActiveCall = (PDRVCALL) pAsyncReqInfo->dwParam3,
                pHeldCall = (PDRVCALL) pAsyncReqInfo->dwParam4;


    if ((pAsyncReqInfo->lResult == 0))
    {
    // 
    // Note - indecision on the final state of the ActiveCall after lineSwapHold()
    //        SDK says ONHOLD, internal TAPI documents by NoelA allow several other.
    //
      if (SetCallState(
                pActiveCall,
                dwActiveCallInstThen,
                LINECALLSTATE_CONNECTED,
                LINECALLSTATE_ONHOLD,
                0,
                TRUE

                ) == 0)
        {
          	// 
            // Note - indecision on the validity of ONHOLD->CONNECTED transition
            //        SDK allows it, internal TAPI documents by NoelA do not.
            //
           SetCallState(
                pHeldCall,
                dwHeldCallInstThen,
                LINECALLSTATE_ONHOLD | LINECALLSTATE_ONHOLDPENDTRANSFER | LINECALLSTATE_ONHOLDPENDCONF,
                LINECALLSTATE_CONNECTED,
                0,
                TRUE
                );
        }
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineSwapHold(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdActiveCall,
    HDRVCALL        hdHeldCall
    )
{
    static char szFuncName[] = "lineSwapHold";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { "hdActiveCall",   hdActiveCall    },
        { "hdHeldCall",     hdHeldCall      }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        3,
        params,
        TSPI_lineSwapHold_postProcess
    };


    if (Prolog (&info))
    {
        DWORD   dwActiveCallInstance, dwHeldCallInstance;


        if (IsValidDrvCall(
                (PDRVCALL) hdActiveCall,
                &dwActiveCallInstance
                ) &&

            IsValidDrvCall(
                (PDRVCALL) hdHeldCall,
                &dwHeldCallInstance
                ))
        {
            info.pAsyncReqInfo->dwParam1 = dwActiveCallInstance;
            info.pAsyncReqInfo->dwParam2 = dwHeldCallInstance;
            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) hdActiveCall;
            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) hdHeldCall;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_lineUncompleteCall(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwCompletionID
    )
{
    static char szFuncName[] = "lineUncompleteCall";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdLine,         hdLine          },
        { "dwCompletionID", dwCompletionID  }
    };
    FUNC_INFO info = { szFuncName, ASYNC, 3, params, NULL };


    if (Prolog (&info))
    {
        if (dwCompletionID == 0xffffffff)
        {
            info.lResult = LINEERR_INVALCOMPLETIONID;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineUnhold_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD      dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam1;
        PDRVCALL   pCall = (PDRVCALL) pAsyncReqInfo->dwParam2;


        pAsyncReqInfo->lResult = SetCallState(
            pCall,
            dwCallInstThen,
            LINECALLSTATE_ONHOLD,
            LINECALLSTATE_CONNECTED,
            0,
            TRUE
            );
    }

    DoCompletion (pAsyncReqInfo, bAsync);
}


LONG
TSPIAPI
TSPI_lineUnhold(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static char szFuncName[] = "lineUnhold";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdCall,         hdCall      },
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        2,
        params,
        TSPI_lineUnhold_postProcess
    };


    if (Prolog (&info))
    {
        DWORD dwCallInstance;


        if (IsValidDrvCall ((PDRVCALL) hdCall, &dwCallInstance))
        {
            info.pAsyncReqInfo->dwParam1 = dwCallInstance;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) hdCall;
        }
        else
        {
            info.lResult = LINEERR_INVALCALLHANDLE;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_lineUnpark_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD      dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2,
               dwParkIndex = (DWORD) pAsyncReqInfo->dwParam3,
               dwCallInstNow;
    PDRVCALL   pCall = (PDRVCALL) pAsyncReqInfo->dwParam1;


    if (pAsyncReqInfo->lResult == 0)
    {
        //
        // Make sure there's still a call there to unpark
        //

        if (gaParkedCalls[dwParkIndex] == NULL)
        {
            pAsyncReqInfo->lResult = LINEERR_OPERATIONFAILED;
        }
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.CallListCritSec);

        if (gaParkedCalls[dwParkIndex] != NULL  &&
            IsValidDrvCall (pCall, &dwCallInstNow)  &&
            dwCallInstNow == dwCallInstThen)
        {
            //
            // Copy all the data from the parked call to the new call,
            // then free the parked call
            //

            PDRVCALL    pParkedCall = gaParkedCalls[dwParkIndex];


            gaParkedCalls[dwParkIndex] = NULL;

            CopyMemory(
                &pCall->dwMediaMode,
                &pParkedCall->dwMediaMode,
                14 * sizeof (DWORD) + sizeof (LINEDIALPARAMS)
                );

            if ((pCall->pDestCall = pParkedCall->pDestCall))
            {
                pCall->pDestCall->pDestCall = pCall;
                pCall->bConnectedToDestCall =
                    pParkedCall->bConnectedToDestCall;
            }

            CopyMemory(
                &pCall->dwGatherDigitsEndToEndID,
                &pParkedCall->dwGatherDigitsEndToEndID,
                5 * sizeof (DWORD)
                );


            pCall->dwCallID = pParkedCall->dwCallID;
            //
            // Reset call state to 0 so SetCallState will do the indication
            //

            {
                DWORD   dwCallState = pCall->dwCallState;


                pCall->dwCallState = 0;

                SetCallState(
                    pCall,
                    dwCallInstThen,
                    0xffffffff, // no reqs. we set the current state to 0 just above!
                    dwCallState,
                    0,
                    TRUE
                    );
            }

            SendLineEvent(
                    pCall->pLine,
                    pCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_CALLID,
                    0,
                    0
                    );
    

            pParkedCall->dwKey = INVAL_KEY;
            DrvFree (pParkedCall);
        }
        else
        {
            SetCallState(
                pCall,
                dwCallInstThen,
                0xffffffff, // all states are valid
                LINECALLSTATE_IDLE,
                0,
                TRUE
                );
        }

        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
    }
    else
    {
        FreeCall (pCall, dwCallInstThen);
    }
}


LONG
TSPIAPI
TSPI_lineUnpark(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPICALL       htCall,
    LPHDRVCALL      lphdCall,
    LPCWSTR         lpszDestAddress
    )
{
    static char szFuncName[] = "lineUnpark";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdLine,             hdLine          },
        { "dwAddressID",        dwAddressID     },
        { "htCall",             htCall          },
        { "lphdCall",           lphdCall        },
        { "lpszDestAddress",    lpszDestAddress }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        6,
        params,
        NULL
    };


    if (Prolog (&info))
    {
        //
        // See if the park addr is valid, & if there's actually a
        // call parked there now
        //

        char   *pszDestAddress, *p, c;
        DWORD   length, dwParkIndex;


        //
        // Convert dest addr from unicode to ascii
        //

        length = (lstrlenW (lpszDestAddress) + 1) * sizeof (WCHAR);

        if (!(pszDestAddress = DrvAlloc (length)))
        {
            info.lResult = LINEERR_NOMEM;
            return (Epilog (&info));
        }

        WideCharToMultiByte(
            CP_ACP,
            0,
            lpszDestAddress,
            -1,
            pszDestAddress,
            length,
            NULL,
            NULL
            );

        p = pszDestAddress;


        //
        // See if destination address is in the format of "9999#<addr id>"
        //

        if (*p++ != '9'  ||
            *p++ != '9'  ||
            *p++ != '9'  ||
            *p++ != '9'  ||
            *p++ != '#'  ||
            *p < '0'     ||
            *p > '9')
        {
            info.lResult = LINEERR_INVALADDRESS;
            goto TSPI_lineUnpark_freeDestAddress;
        }

        for (dwParkIndex = 0; (c = *p); p++)
        {
            if (c >= '0' && c <= '9')
            {
                dwParkIndex *= 10;
                dwParkIndex += ((DWORD)(c - '0'));
            }
            else
            {
                break;
            }
        }

        if (c != '\0'  ||  dwParkIndex >= MAX_NUM_PARKED_CALLS)
        {
            info.lResult = LINEERR_INVALADDRESS;
            goto TSPI_lineUnpark_freeDestAddress;
        }

        if (gaParkedCalls[dwParkIndex] != NULL)
        {
            PDRVCALL        pCall;
            LINECALLPARAMS  callParams;


            ZeroMemory (&callParams, sizeof (LINECALLPARAMS));

            callParams.dwTotalSize = sizeof (LINECALLPARAMS);

            callParams.dwAddressID = dwAddressID;
            callParams.dwAddressMode = LINEADDRESSMODE_ADDRESSID;

            if ((info.lResult = AllocCall(
                    (PDRVLINE) hdLine,
                    htCall,
                    &callParams,
                    &pCall

                    )) == 0)
            {
                pCall->dwCallID = gaParkedCalls[dwParkIndex]->dwCallID;
                pCall->dwRelatedCallID = gaParkedCalls[dwParkIndex]->dwRelatedCallID;
                pCall->dwAddressType = gaParkedCalls[dwParkIndex]->dwAddressType;

                info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) pCall;
                info.pAsyncReqInfo->dwParam2 = pCall->dwCallInstance;
                info.pAsyncReqInfo->dwParam3 = dwParkIndex;

                *lphdCall = (HDRVCALL) pCall;

                info.pAsyncReqInfo->pfnPostProcessProc = (FARPROC)
                    TSPI_lineUnpark_postProcess;
            }
        }
        else
        {
            info.lResult = LINEERR_OPERATIONFAILED;
        }

TSPI_lineUnpark_freeDestAddress:

        DrvFree (pszDestAddress);
    }

    return (Epilog (&info));
}



//
// -------------------------- TSPI_phoneXxx funcs -----------------------------
//

LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE   hdPhone
    )
{
    static char szFuncName[] = "phoneClose";
    FUNC_PARAM params[] =
    {
        { szhdPhone,    hdPhone }
    };
    FUNC_INFO info = { szFuncName, SYNC, 1, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    //
    // This is more of a "command" than a request, in that TAPI.DLL is
    // going to consider the phone closed whether we like it or not.
    // Therefore we want to free up the phone even if the user chooses
    // to return an error.
    //

    Prolog (&info);

    pPhone->htPhone = (HTAPIPHONE) NULL;

    WriteEventBuffer (pPhone->dwDeviceID,  WIDGETTYPE_PHONE, 0, 0, 0, 0);

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "phoneDevSpecific";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdPhone,        hdPhone     },
        { "lpParams",       lpParams    },
        { szdwSize,         dwSize      }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params
    };


    if (Prolog (&info))
    {
        PESPDEVSPECIFICINFO pInfo = (PESPDEVSPECIFICINFO) lpParams;


        if (dwSize >= sizeof (ESPDEVSPECIFICINFO)  &&
            pInfo->dwKey == ESPDEVSPECIFIC_KEY)
        {
            switch (pInfo->dwType)
            {
            case ESP_DEVSPEC_MSG:

                switch (pInfo->u.EspMsg.dwMsg)
                {
                case PHONE_BUTTON:
                case PHONE_CLOSE:
                case PHONE_DEVSPECIFIC:
                case PHONE_STATE:

                    SendPhoneEvent(
                        (PDRVPHONE) hdPhone,
                        pInfo->u.EspMsg.dwMsg,
                        pInfo->u.EspMsg.dwParam1,
                        pInfo->u.EspMsg.dwParam2,
                        pInfo->u.EspMsg.dwParam3
                        );

                    break;

                case PHONE_CREATE:

                    if (gESPGlobals.pPhones->dwNumUsedEntries <
                            gESPGlobals.pPhones->dwNumTotalEntries)
                    {
                        (*gESPGlobals.pfnPhoneEvent)(
                            (HTAPIPHONE) NULL,
                            PHONE_CREATE,
                            (ULONG_PTR) gESPGlobals.hProvider,
                            gESPGlobals.pPhones->dwNumUsedEntries++,
                            0
                            );
                    }
                    else
                    {
                         ShowStr(
                             TRUE,
                             "ERROR: TSPI_phoneDevSpecific: attempt " \
                                 "to send PHONE_CREATE - can't create " \
                                 "any more devices on the fly"
                             );

                        info.lResult = PHONEERR_OPERATIONFAILED;
                    }

                    break;

                default:

                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_phoneDevSpecific: unrecognized " \
                            "ESPDEVSPECIFICINFO.u.EspMsg.dwMsg (=x%x)",
                        pInfo->u.EspMsg.dwMsg
                        );

                    info.lResult = PHONEERR_OPERATIONFAILED;
                    break;
                }

                break;

            case ESP_DEVSPEC_RESULT:
            {
                DWORD   dwResult = pInfo->u.EspResult.lResult;


                if (dwResult != 0  &&
                    (dwResult < LINEERR_ALLOCATED ||
                    dwResult > PHONEERR_REINIT ||
                    (dwResult > LINEERR_DIALVOICEDETECT &&
                    dwResult < PHONEERR_ALLOCATED)))
                {
                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_phoneDevSpecific: invalid request" \
                            "result value (x%x)",
                        dwResult
                        );

                    info.lResult = PHONEERR_OPERATIONFAILED;
                }
                else if (pInfo->u.EspResult.dwCompletionType >
                            ESP_RESULT_CALLCOMPLPROCASYNC)
                {
                    ShowStr(
                        TRUE,
                        "ERROR: TSPI_phoneDevSpecific: invalid request" \
                            "completion type (x%x)",
                        pInfo->u.EspResult.dwCompletionType
                        );

                    info.lResult = PHONEERR_OPERATIONFAILED;
                }
                else
                {
                    glNextRequestResult = (LONG) dwResult;
                    gdwNextRequestCompletionType =
                        pInfo->u.EspResult.dwCompletionType;
                    gdwDevSpecificRequestID = dwRequestID;
                }

                break;
            }
            default:

                ShowStr(
                    TRUE,
                    "ERROR: TSPI_phoneDevSpecific: unrecognized " \
                        "ESPDEVSPECIFICINFO.dwType (=x%x)",
                    pInfo->dwType
                    );

                info.lResult = PHONEERR_OPERATIONFAILED;
                break;
            }
        }
        else
        {
            info.pAsyncReqInfo->dwParam1 = lpParams;
            info.pAsyncReqInfo->dwParam2 = dwSize;

            info.pAsyncReqInfo->pfnPostProcessProc = (FARPROC)
                TSPI_lineDevSpecific_postProcess;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    static char szFuncName[] = "phoneGetButtonInfo";
    FUNC_PARAM params[] =
    {
        { szhdPhone,        hdPhone         },
        { "dwButtonLampID", dwButtonLampID  },
        { "lpButtonInfo",   lpButtonInfo    }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 3, params };
    PDRVPHONE   pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        if (dwButtonLampID == 0)
        {
            if (pPhone->pButtonInfo)
            {
                if (pPhone->pButtonInfo->dwUsedSize <=
                        lpButtonInfo->dwTotalSize)
                {
                    CopyMemory(
                        (LPBYTE) &lpButtonInfo->dwNeededSize,
                        (LPBYTE) &pPhone->pButtonInfo->dwNeededSize,
                        pPhone->pButtonInfo->dwUsedSize - sizeof (DWORD)
                        );
                }
                else
                {
                    lpButtonInfo->dwNeededSize =
                        pPhone->pButtonInfo->dwUsedSize;
                }
            }
        }
        else
        {
            info.lResult = PHONEERR_INVALBUTTONLAMPID;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetData(
    HDRVPHONE   hdPhone,
    DWORD       dwDataID,
    LPVOID      lpData,
    DWORD       dwSize
    )
{
    static char szFuncName[] = "phoneGetData";
    FUNC_PARAM params[] =
    {
        { szhdPhone,    hdPhone     },
        { "dwDataID",   dwDataID    },
        { "lpData",     lpData      },
        { szdwSize,     dwSize      }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        if (dwDataID != 0)
        {
            info.lResult = PHONEERR_INVALDATAID;
        }
        else if (pPhone->pData)
        {
            CopyMemory(
                lpData,
                pPhone->pData,
                (dwSize > pPhone->dwDataSize ? pPhone->dwDataSize : dwSize)
                );
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD       dwDeviceID,
    DWORD       dwTSPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    static char szFuncName[] = "phoneGetDevCaps";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwExtVersion",   dwExtVersion    },
        { "lpPhoneCaps",    lpPhoneCaps     }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 4, params };
    char        buf[32];
    WCHAR       wbuf[32];
    DWORD       dwDummy;
    PDRVPHONE   pPhone = GetPhoneFromID (dwDeviceID);


    if (Prolog (&info))
    {
        //lpPhoneCaps->dwNeededSize
        //lpPhoneCaps->dwUsedSize

        InsertVarDataString(
            lpPhoneCaps,
            &lpPhoneCaps->dwProviderInfoSize,
            gszProviderInfo
            );

        //lpPhoneCaps->dwPhoneInfoSize
        //lpPhoneCaps->dwPhoneInfoOffset

        lpPhoneCaps->dwPermanentPhoneID =
            (gESPGlobals.dwPermanentProviderID << 16) |
                (dwDeviceID - gESPGlobals.dwPhoneDeviceIDBase);

        // NOTE: win9x doesn't support wsprintfW

        wsprintfA (buf, "ESP Phone %d", dwDeviceID);

        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            buf,
            lstrlen (buf) + 1,
            wbuf,
            20
            );

        InsertVarDataString(
            lpPhoneCaps,
            &lpPhoneCaps->dwPhoneNameSize,
            wbuf
            );

        lpPhoneCaps->dwStringFormat = STRINGFORMAT_ASCII;
        //lpPhoneCaps->dwPhoneStates
        lpPhoneCaps->dwHookSwitchDevs = AllHookSwitchDevs;
        lpPhoneCaps->dwHandsetHookSwitchModes =
        lpPhoneCaps->dwSpeakerHookSwitchModes =
        lpPhoneCaps->dwHeadsetHookSwitchModes = AllHookSwitchModes;
        lpPhoneCaps->dwVolumeFlags = AllHookSwitchDevs;
        lpPhoneCaps->dwGainFlags = AllHookSwitchDevs;
        lpPhoneCaps->dwDisplayNumRows = 1;
        lpPhoneCaps->dwDisplayNumColumns = PHONE_DISPLAY_SIZE_IN_CHARS;
        lpPhoneCaps->dwNumRingModes = 0xffffffff;

        lpPhoneCaps->dwNumButtonLamps = 1;

        dwDummy = PHONEBUTTONMODE_FEATURE;

        InsertVarData(
            lpPhoneCaps,
            &lpPhoneCaps->dwButtonModesSize,
            (LPVOID) &dwDummy,
            sizeof (DWORD)
            );

        dwDummy = PHONEBUTTONFUNCTION_UNKNOWN;

        InsertVarData(
            lpPhoneCaps,
            &lpPhoneCaps->dwButtonFunctionsSize,
            (LPVOID) &dwDummy,
            sizeof (DWORD)
            );

        dwDummy = PHONELAMPMODE_OFF;

        InsertVarData(
            lpPhoneCaps,
            &lpPhoneCaps->dwLampModesSize,
            (LPVOID) &dwDummy,
            sizeof (DWORD)
            );


        lpPhoneCaps->dwNumSetData = 1;

        dwDummy = MAX_VAR_DATA_SIZE;

        InsertVarData(
            lpPhoneCaps,
            &lpPhoneCaps->dwSetDataSize,
            (LPVOID) &dwDummy,
            sizeof (DWORD)
            );

        lpPhoneCaps->dwNumGetData = 1;

        InsertVarData(
            lpPhoneCaps,
            &lpPhoneCaps->dwGetDataSize,
            (LPVOID) &dwDummy,
            sizeof (DWORD)
            );

        //lpPhoneCaps->dwDevSpecificSize
        //lpPhoneCaps->dwDevSpecificOffset

        if (gESPGlobals.dwSPIVersion >= 0x00020000)
        {
            //lpPhoneCaps->dwDeviceClassesSize
            //lpPhoneCaps->dwDeviceClassesOffset
            lpPhoneCaps->dwPhoneFeatures = AllPhoneFeatures;
            lpPhoneCaps->dwSettableHandsetHookSwitchModes =
            lpPhoneCaps->dwSettableSpeakerHookSwitchModes =
            lpPhoneCaps->dwSettableHeadsetHookSwitchModes = AllHookSwitchModes;
            //lpPhoneCaps->dwMonitoredHandsetHookSwitchModes
            //lpPhoneCaps->dwMonitoredSpeakerHookSwitchModes
            //lpPhoneCaps->dwMonitoredHeadsetHookSwitchModes

            if (gESPGlobals.dwSPIVersion >= 0x00020002)
            {
                lpPhoneCaps->PermanentPhoneGuid.Data1 = (long)
                    (dwDeviceID - gESPGlobals.dwPhoneDeviceIDBase);

                *((LPDWORD) &lpPhoneCaps->PermanentPhoneGuid.Data2) =
                *((LPDWORD) &lpPhoneCaps->PermanentPhoneGuid.Data4[0]) =
                *((LPDWORD) &lpPhoneCaps->PermanentPhoneGuid.Data4[4]) =
                    DRVPHONE_KEY;
            }
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDisplay
    )
{
    static char szFuncName[] = "phoneGetDisplay";
    FUNC_PARAM params[] =
    {
        { szhdPhone,    hdPhone     },
        { "lpDisplay",  lpDisplay   }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 2, params };
    PDRVPHONE   pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        static DWORD    dwNeededSize = sizeof(VARSTRING) +
                            PHONE_DISPLAY_SIZE_IN_BYTES;


        if (lpDisplay->dwTotalSize >= dwNeededSize)
        {
            if (pPhone->pDisplay)
            {
                CopyMemory(
                    lpDisplay + 1,
                    pPhone->pDisplay,
                    PHONE_DISPLAY_SIZE_IN_BYTES
                    );
            }
            else
            {
                ZeroMemory (lpDisplay + 1, PHONE_DISPLAY_SIZE_IN_BYTES);
            }

            lpDisplay->dwUsedSize     = dwNeededSize;
            lpDisplay->dwStringFormat = STRINGFORMAT_ASCII;
            lpDisplay->dwStringSize   = PHONE_DISPLAY_SIZE_IN_BYTES;
            lpDisplay->dwStringOffset = sizeof (VARSTRING);
        }

        lpDisplay->dwNeededSize = dwNeededSize;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
    static char szFuncName[] = "phoneGetExtensionID";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "lpExtensionID",  lpExtensionID   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
        // BUGBUG TSPI_phoneGetExtensionID:
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetGain(
    HDRVPHONE   hdPhone,
    DWORD       dwHookSwitchDev,
    LPDWORD     lpdwGain
    )
{
    static char szFuncName[] = "phoneGetGain";
    FUNC_PARAM params[] =
    {
        { szhdPhone,            hdPhone         },
        { "dwHookSwitchDev",    dwHookSwitchDev },
        { "lpdwGain",           lpdwGain        }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        switch (dwHookSwitchDev)
        {
        case PHONEHOOKSWITCHDEV_HANDSET:

            *lpdwGain = pPhone->dwHandsetGain;
            break;

        case PHONEHOOKSWITCHDEV_SPEAKER:

            *lpdwGain = pPhone->dwSpeakerGain;
            break;

        case PHONEHOOKSWITCHDEV_HEADSET:

            *lpdwGain = pPhone->dwHeadsetGain;
            break;

        }
    }

    return (Epilog (&info));
}



LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwHookSwitchDevs
    )
{
    static char szFuncName[] = "phoneGetHookSwitch";
    FUNC_PARAM params[] =
    {
        { szhdPhone,            hdPhone             },
        { "lpdwHookSwitchDevs", lpdwHookSwitchDevs  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        *lpdwHookSwitchDevs = 0;

        if (!(pPhone->dwHandsetHookSwitchMode & PHONEHOOKSWITCHMODE_ONHOOK))
        {
            *lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_HANDSET;
        }

        if (!(pPhone->dwSpeakerHookSwitchMode & PHONEHOOKSWITCHMODE_ONHOOK))
        {
            *lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;
        }

        if (!(pPhone->dwHeadsetHookSwitchMode & PHONEHOOKSWITCHMODE_ONHOOK))
        {
            *lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_HEADSET;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetIcon(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    static char szFuncName[] = "phoneGetIcon";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,         dwDeviceID      },
        { "lpszDeviceClass",    lpszDeviceClass },
        { "lphIcon",            lphIcon         }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
        if (lpszDeviceClass  &&

            My_lstrcmpiW(
                (WCHAR *) lpszDeviceClass,
                (WCHAR *) (L"tapi/InvalidDeviceClass")

                ) == 0)
        {
            info.lResult = PHONEERR_INVALDEVICECLASS;
        }
        else
        {
            *lphIcon = gESPGlobals.hIconPhone;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    static char szFuncName[] = "phoneGetID";
    FUNC_PARAM params[] =
    {
        { szhdPhone,            hdPhone         },
        { "lpDeviceID",         lpDeviceID      },
        { "lpszDeviceClass",    lpszDeviceClass }
        ,{ "hTargetProcess",     hTargetProcess }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;
    DWORD    i, j, dwDeviceID, dwNeededSize, dwNumDeviceIDs = 1;
    DWORD *lpdwDeviceIDs;

    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }

    for (i = 0; aszDeviceClasses[i]; i++)
    {
        if (My_lstrcmpiW(
                (WCHAR *) lpszDeviceClass,
                (WCHAR *) aszDeviceClasses[i]

                ) == 0)
        {
            break;
        }
    }

    if (!aszDeviceClasses[i])
    {
        info.lResult = PHONEERR_NODEVICE;
        return (Epilog (&info));
    }

    if (i == 1)             //tapi/phone
    {
    	dwNumDeviceIDs = 1;
	    dwNeededSize = sizeof(VARSTRING) + (dwNumDeviceIDs * sizeof(DWORD));

	    if (lpDeviceID->dwTotalSize < dwNeededSize)
    	{
        	lpDeviceID->dwNeededSize = dwNeededSize;
	        lpDeviceID->dwUsedSize = 3 * sizeof(DWORD);

	   	    return (Epilog (&info));
	    }

		if (! (lpdwDeviceIDs = DrvAlloc(dwNumDeviceIDs * sizeof(DWORD)) ) )
		{
    	    info.lResult = PHONEERR_NOMEM;
			return (Epilog (&info));
		}

        lpdwDeviceIDs[0] = pPhone->dwDeviceID;
    }
    else if (i == 0)        //tapi/line
    {      
	    PDRVLINE    pLine;

  	    // create a list of all the ESP deviceIDs        

    	dwNumDeviceIDs = gESPGlobals.pLines->dwNumUsedEntries;
	    dwNeededSize = sizeof(VARSTRING) + (dwNumDeviceIDs * sizeof(DWORD));

	    if (lpDeviceID->dwTotalSize < dwNeededSize)
    	{
        	lpDeviceID->dwNeededSize = dwNeededSize;
	        lpDeviceID->dwUsedSize = 3 * sizeof(DWORD);
	
    	    return (Epilog (&info));
	    }

		if (! (lpdwDeviceIDs = DrvAlloc(dwNumDeviceIDs * sizeof(DWORD))))
		{
    	    info.lResult = PHONEERR_NOMEM;
			return (Epilog (&info));
		}
			
	    for (j = 0; 
    		j < gESPGlobals.dwInitialNumLines; 
	    	j++)
	    {
    	    lpdwDeviceIDs[j] = gESPGlobals.dwLineDeviceIDBase + j;
	    }

    	pLine = (PDRVLINE) (((LPBYTE) gESPGlobals.pLines->aLines) +
        	    (gESPGlobals.dwInitialNumLines * gdwDrvLineSize));

	    for( j = gESPGlobals.dwInitialNumLines;
    	     j < gESPGlobals.pLines->dwNumUsedEntries;
        	 j++
	       )
    	{
	       lpdwDeviceIDs[j] = pLine->dwDeviceID;
    	   pLine = (PDRVLINE) (((LPBYTE) pLine) + gdwDrvLineSize);
	    }

    }
    else
    {
 
    	dwNumDeviceIDs = 1;
	    dwNeededSize = sizeof(VARSTRING) + (dwNumDeviceIDs * sizeof(DWORD));

	    if (lpDeviceID->dwTotalSize < dwNeededSize)
    	{
        	lpDeviceID->dwNeededSize = dwNeededSize;
	        lpDeviceID->dwUsedSize = 3 * sizeof(DWORD);
	
    	    return (Epilog (&info));
	    }

		if (! (lpdwDeviceIDs = DrvAlloc(dwNumDeviceIDs * sizeof(DWORD))))
		{
    	    info.lResult = PHONEERR_NOMEM;
			return (Epilog (&info));
		}

        lpdwDeviceIDs[0] = 0;

// needs to be modified according to the previous two cases before uncommenting

/*  BUGBUG TSPI_phoneGetID:    if (gbShowLineGetIDDlg)
        {
            char szDlgTitle[64];
            EVENT_PARAM params[] =
            {
                { "dwDeviceID", PT_DWORD, gdwDefLineGetIDID, 0 }
            };
            EVENT_PARAM_HEADER paramsHeader =
                { 1, szDlgTitle, 0, params };
            HWND hwnd;


            if (strlen (lpszDeviceClass) > 20)
            {
                ((char far *)lpszDeviceClass)[19] = 0;
            }

            wsprintfA(
                szDlgTitle,
                "TSPI_phoneGetID: select ID for class '%s'",
                lpszDeviceClass
                );

            hwnd = CreateDialogParam(
                ghInstance,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                (HWND) NULL,
                CallDlgProc,
                (LPARAM) &paramsHeader
                );

            MsgLoopInTAPIClientContext (hwnd);

            dwDeviceID = params[0].dwValue;
        }
        else
        {

            dwDeviceID = 0;
        }
        */
     }
     

    lpDeviceID->dwNeededSize   =
    lpDeviceID->dwUsedSize     = dwNeededSize;
    lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
    lpDeviceID->dwStringSize   = sizeof(DWORD) * dwNumDeviceIDs;
    lpDeviceID->dwStringOffset = sizeof(VARSTRING);

	for (j = 0; j < dwNumDeviceIDs; j++)
	{
	    *( ((LPDWORD)(lpDeviceID + 1)) + j) = lpdwDeviceIDs[j];
	}

    DrvFree(lpdwDeviceIDs);
    
    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE   hdPhone,
    DWORD       dwButtonLampID,
    LPDWORD     lpdwLampMode
    )
{
    static char szFuncName[] = "phoneGetLamp";
    FUNC_PARAM params[] =
    {
        { szhdPhone,        hdPhone         },
        { "dwButtonLampID", dwButtonLampID  },
        { "lpdwLampMode",   lpdwLampMode    }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };


    if (Prolog (&info))
    {
        *lpdwLampMode = ((PDRVPHONE) hdPhone)->dwLampMode;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwRingMode,
    LPDWORD     lpdwVolume
    )
{
    static char szFuncName[] = "phoneGetRing";
    FUNC_PARAM params[] =
    {
        { szhdPhone,        hdPhone         },
        { "lpdwRingMode",   lpdwRingMode    },
        { "lpdwVolume",     lpdwVolume      }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        *lpdwRingMode = pPhone->dwRingMode;
        *lpdwVolume   = pPhone->dwRingVolume;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE       hdPhone,
    LPPHONESTATUS   lpPhoneStatus
    )
{
    static char szFuncName[] = "phoneGetStatus";
    FUNC_PARAM params[] =
    {
        { szhdPhone,        hdPhone         },
        { "lpPhoneStatus",  lpPhoneStatus   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        //lpPhoneStatus->dwStatusFlags;
        lpPhoneStatus->dwRingMode      = pPhone->dwRingMode;
        lpPhoneStatus->dwRingVolume    = pPhone->dwRingVolume;
        lpPhoneStatus->dwHandsetHookSwitchMode =
            pPhone->dwHandsetHookSwitchMode;
        lpPhoneStatus->dwHandsetVolume = pPhone->dwHandsetVolume;
        lpPhoneStatus->dwHandsetGain   = pPhone->dwHandsetGain;
        lpPhoneStatus->dwSpeakerHookSwitchMode =
            pPhone->dwSpeakerHookSwitchMode;
        lpPhoneStatus->dwSpeakerVolume = pPhone->dwSpeakerVolume;
        lpPhoneStatus->dwSpeakerGain   = pPhone->dwSpeakerGain;
        lpPhoneStatus->dwHeadsetHookSwitchMode =
            pPhone->dwHeadsetHookSwitchMode;
        lpPhoneStatus->dwHeadsetVolume = pPhone->dwHeadsetVolume;
        lpPhoneStatus->dwHeadsetGain   = pPhone->dwHeadsetGain;

        // BUGBUG TSPI_phoneGetStatus: copy 0's to display buf if !pDisplay

        InsertVarData(
            lpPhoneStatus,
            &lpPhoneStatus->dwDisplaySize,
            (LPVOID) pPhone->pDisplay,
            (pPhone->pDisplay ? PHONE_DISPLAY_SIZE_IN_BYTES : 0)
            );

        InsertVarData(
            lpPhoneStatus,
            &lpPhoneStatus->dwLampModesSize,
            (LPVOID) &pPhone->dwLampMode,
            sizeof (DWORD)
            );

        //lpPhoneStatus->dwDevSpecificSize;
        //lpPhoneStatus->dwDevSpecificOffset;

        if (gESPGlobals.dwSPIVersion >= 0x00020000)
        {
            //lpPhoneStatus->
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneGetVolume(
    HDRVPHONE   hdPhone,
    DWORD       dwHookSwitchDev,
    LPDWORD     lpdwVolume
    )
{
    static char szFuncName[] = "phoneGetVolume";
    FUNC_PARAM params[] =
    {
        { szhdPhone,            hdPhone         },
        { "dwHookSwitchDev",    dwHookSwitchDev,    aHookSwitchDevs },
        { "lpdwVolume",         lpdwVolume      }
    };
    FUNC_INFO info = { szFuncName, SYNC, 3, params };
    PDRVPHONE pPhone = (PDRVPHONE) hdPhone;


    if (Prolog (&info))
    {
        switch (dwHookSwitchDev)
        {
        case PHONEHOOKSWITCHDEV_HANDSET:

            *lpdwVolume = pPhone->dwHandsetVolume;
            break;

        case PHONEHOOKSWITCHDEV_SPEAKER:

            *lpdwVolume = pPhone->dwSpeakerVolume;
            break;

        case PHONEHOOKSWITCHDEV_HEADSET:

            *lpdwVolume = pPhone->dwHeadsetVolume;
            break;

        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static char szFuncName[] = "phoneNegotiateExtVersion";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "dwLowVersion",   dwLowVersion    },
        { "dwHighVersion",  dwHighVersion   },
        { "lpdwExtVersion", lpdwExtVersion  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 5, params };


    if (Prolog (&info))
    {
        if (dwLowVersion == 0 ||
            dwHighVersion == 0xffffffff ||
            dwLowVersion > dwHighVersion)
        {
            info.lResult = PHONEERR_INCOMPATIBLEEXTVERSION;
        }
        else
        {
            *lpdwExtVersion = dwHighVersion;
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    static char szFuncName[] = "phoneNegotiateTSPIVersion";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,         dwDeviceID      },
        { "dwLowVersion",       dwLowVersion    },
        { "dwHighVersion",      dwHighVersion   },
        { "lpdwTSPIVersion",    lpdwTSPIVersion }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };


    if (Prolog (&info))
    {
        *lpdwTSPIVersion = gESPGlobals.dwSPIVersion;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD       dwDeviceID,
    HTAPIPHONE  htPhone,
    LPHDRVPHONE lphdPhone,
    DWORD       dwTSPIVersion,
    PHONEEVENT  lpfnEventProc
    )
{
    static char szFuncName[] = "phoneOpen";
    FUNC_PARAM params[] =
    {
        { szdwDeviceID,     dwDeviceID      },
        { "htPhone",        htPhone         },
        { "lphdPhone",      lphdPhone       },
        { "dwTSPIVersion",  dwTSPIVersion   },
        { "lpfnEventProc",  lpfnEventProc   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 5, params };


    if (Prolog (&info))
    {
        PDRVPHONE pPhone;


        if (pPhone = GetPhoneFromID (dwDeviceID))
        {

	        pPhone->htPhone = htPhone;

    	    *lphdPhone = (HDRVPHONE) pPhone;

        	WriteEventBuffer(
            	pPhone->dwDeviceID,
	            WIDGETTYPE_PHONE,
    	        (ULONG_PTR) pPhone,
        	    (ULONG_PTR) htPhone,
            	0,
	            0
    	        );
    	}
		else 
		{
        	info.lResult = PHONEERR_BADDEVICEID;
        }

    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE   hdPhone,
    DWORD       dwExtVersion
    )
{
    static char szFuncName[] = "phoneSelectExtVersion";
    FUNC_PARAM params[] =
    {
        { szhdPhone,        hdPhone         },
        { "dwExtVersion",   dwExtVersion    }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetButtonInfo_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    PDRVPHONE           pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;
    LPPHONEBUTTONINFO   pButtonInfo = (LPPHONEBUTTONINFO)
                            pAsyncReqInfo->dwParam2, pToFree;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.PhoneCritSec);

        pToFree = pPhone->pButtonInfo;
        pPhone->pButtonInfo = pButtonInfo;

        LeaveCriticalSection (&gESPGlobals.PhoneCritSec);

        DrvFree (pToFree);

        // no msg to send for this one?
    }
    else
    {
        DrvFree (pButtonInfo);
    }
}


LONG
TSPIAPI
TSPI_phoneSetButtonInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    static char szFuncName[] = "phoneSetButtonInfo";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdPhone,        hdPhone         },
        { "dwButtonLampID", dwButtonLampID  },
        { "lpButtonInfo",   lpButtonInfo    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_phoneSetButtonInfo_postProcess
    };


    if (Prolog (&info))
    {
        if (dwButtonLampID == 0)
        {
            DWORD               dwNeededSize;
            LPPHONEBUTTONINFO   pMyButtonInfo;


            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;

            dwNeededSize = sizeof (PHONEBUTTONINFO) +
                lpButtonInfo->dwButtonTextSize +
                lpButtonInfo->dwDevSpecificSize +
                16;                             // 64-bit align var fields

            if ((pMyButtonInfo = (LPPHONEBUTTONINFO) DrvAlloc (dwNeededSize)))
            {
                info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) pMyButtonInfo;

                CopyMemory(
                    pMyButtonInfo,
                    lpButtonInfo,
                    (gESPGlobals.dwSPIVersion > 0x00010003 ?
                        sizeof (PHONEBUTTONINFO) : 9 * sizeof (DWORD))
                    );

                pMyButtonInfo->dwTotalSize  = dwNeededSize;
                pMyButtonInfo->dwNeededSize =
                pMyButtonInfo->dwUsedSize   = sizeof (PHONEBUTTONINFO);

                InsertVarData(
                    pMyButtonInfo,
                    &pMyButtonInfo->dwButtonTextSize,
                    ((LPBYTE) lpButtonInfo) +
                        lpButtonInfo->dwButtonTextOffset,
                    lpButtonInfo->dwButtonTextSize
                    );

                InsertVarData(
                    pMyButtonInfo,
                    &pMyButtonInfo->dwDevSpecificSize,
                    ((LPBYTE) lpButtonInfo) +
                        lpButtonInfo->dwDevSpecificOffset,
                    lpButtonInfo->dwDevSpecificSize
                    );
            }
            else
            {
                info.lResult = PHONEERR_NOMEM;
            }
        }
        else
        {
            info.lResult = PHONEERR_INVALBUTTONLAMPID;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetData_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwNewDataSize = (DWORD) pAsyncReqInfo->dwParam3;
    LPVOID      pNewData = (LPVOID) pAsyncReqInfo->dwParam2, pToFree;
    PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.PhoneCritSec);

        pToFree            = pPhone->pData;
        pPhone->pData      = pNewData;
        pPhone->dwDataSize = dwNewDataSize;

        LeaveCriticalSection (&gESPGlobals.PhoneCritSec);

        DrvFree (pToFree);

        // no msg to send for this one?
    }
    else
    {
        DrvFree (pNewData);
    }
}


LONG
TSPIAPI
TSPI_phoneSetData(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwDataID,
    LPVOID          const lpData,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "phoneSetData";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdPhone,        hdPhone         },
        { "dwDataID",       dwDataID        },
        { "lpData",         lpData          },
        { szdwSize,         dwSize          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        5,
        params,
        TSPI_phoneSetData_postProcess
    };


    if (Prolog (&info))
    {
        if (dwDataID != 0)
        {
            info.lResult = PHONEERR_INVALDATAID;
        }
        else
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;

            if (dwSize)
            {
                info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) DrvAlloc (dwSize);

                if (info.pAsyncReqInfo->dwParam2 == 0)
                {
                    info.lResult = PHONEERR_NOMEM;
                    return (Epilog (&info));
                }

                CopyMemory(
                    (LPVOID) info.pAsyncReqInfo->dwParam2,
                    lpData,
                    dwSize
                    );
            }
            else
            {
                info.pAsyncReqInfo->dwParam2 = 0;
            }

            info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) dwSize;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetDisplay_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwColumn = (DWORD) pAsyncReqInfo->dwParam2,
                dwSize = (DWORD) pAsyncReqInfo->dwParam4;
    WCHAR      *pDisplay = (LPVOID) pAsyncReqInfo->dwParam3;
    PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


    if (pAsyncReqInfo->lResult == 0)
    {
        EnterCriticalSection (&gESPGlobals.PhoneCritSec);

        if (pPhone->pDisplay ||
            (pPhone->pDisplay = DrvAlloc (PHONE_DISPLAY_SIZE_IN_BYTES)))
        {
            CopyMemory(
                pPhone->pDisplay + dwColumn,
                pDisplay,
                dwSize
                );

            SendPhoneEvent (pPhone, PHONE_STATE, PHONESTATE_DISPLAY, 0, 0);
        }
        else
        {
            pAsyncReqInfo->lResult = PHONEERR_NOMEM;
        }

        LeaveCriticalSection (&gESPGlobals.PhoneCritSec);
    }

    DoCompletion (pAsyncReqInfo, bAsync);

    DrvFree (pDisplay);
}


LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRow,
    DWORD           dwColumn,
    LPCWSTR         lpsDisplay,
    DWORD           dwSize
    )
{
    static char szFuncName[] = "phoneSetDisplay";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdPhone,        hdPhone     },
        { "dwRow",          dwRow       },
        { "dwColumn",       dwColumn    },
        { "lpsDisplay",     lpsDisplay  },
        { szdwSize,         dwSize      }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        6,
        params,
        TSPI_phoneSetDisplay_postProcess
    };


    if (Prolog (&info))
    {
        if (dwRow == 0 &&
            dwColumn < PHONE_DISPLAY_SIZE_IN_CHARS &&
            dwSize <= PHONE_DISPLAY_SIZE_IN_BYTES &&
            (dwColumn * sizeof (WCHAR) + dwSize - sizeof (WCHAR)) <
                PHONE_DISPLAY_SIZE_IN_BYTES)
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) dwColumn;

            if (dwSize)
            {
                info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) DrvAlloc (dwSize);

                if (info.pAsyncReqInfo->dwParam3 == 0)
                {
                    info.lResult = PHONEERR_NOMEM;
                    return (Epilog (&info));
                }

                CopyMemory(
                    (LPVOID) info.pAsyncReqInfo->dwParam3,
                    lpsDisplay,
                    dwSize
                    );
            }
            else
            {
                info.pAsyncReqInfo->dwParam3 = 0;
            }

            info.pAsyncReqInfo->dwParam4 = (ULONG_PTR) dwSize;

        }
        else
        {
            info.lResult = PHONEERR_INVALPARAM;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetGain_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD       dwHookSwitchDev = (DWORD) pAsyncReqInfo->dwParam2,
                    dwGain = (DWORD) pAsyncReqInfo->dwParam3,
                   *pdwXxxGain, dwPhoneState;
        PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


        switch (dwHookSwitchDev)
        {
        case PHONEHOOKSWITCHDEV_HANDSET:

            pdwXxxGain = &pPhone->dwHandsetGain;
            dwPhoneState = PHONESTATE_HANDSETGAIN;
            break;

        case PHONEHOOKSWITCHDEV_SPEAKER:

            pdwXxxGain = &pPhone->dwSpeakerGain;
            dwPhoneState = PHONESTATE_SPEAKERGAIN;
            break;

        default: // case PHONEHOOKSWITCHDEV_HEADSET:

            pdwXxxGain = &pPhone->dwHeadsetGain;
            dwPhoneState = PHONESTATE_HEADSETGAIN;
            break;
        }

        if (*pdwXxxGain != dwGain)
        {
            *pdwXxxGain = dwGain;
            SendPhoneEvent (pPhone, PHONE_STATE, dwPhoneState, 0, 0);
        }
    }
}


LONG
TSPIAPI
TSPI_phoneSetGain(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDev,
    DWORD           dwGain
    )
{
    static char szFuncName[] = "phoneSetGain";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdPhone,            hdPhone         },
        { "dwHookSwitchDev",    dwHookSwitchDev,    aHookSwitchDevs },
        { "dwGain",             dwGain          }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_phoneSetGain_postProcess
    };


    if (Prolog (&info))
    {
        info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;
        info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) dwHookSwitchDev;
        info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) dwGain;
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetHookSwitch_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD       dwHookSwitchDevs = (DWORD) pAsyncReqInfo->dwParam2,
                    dwHookSwitchMode = (DWORD) pAsyncReqInfo->dwParam3,
                    dwPhoneStates = 0;
        PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


        if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HANDSET &&
            pPhone->dwHandsetHookSwitchMode != dwHookSwitchMode)
        {
            pPhone->dwHandsetHookSwitchMode = dwHookSwitchMode;
            dwPhoneStates |= PHONESTATE_HANDSETHOOKSWITCH;
        }

        if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER &&
            pPhone->dwSpeakerHookSwitchMode != dwHookSwitchMode)
        {
            pPhone->dwSpeakerHookSwitchMode = dwHookSwitchMode;
            dwPhoneStates |= PHONESTATE_SPEAKERHOOKSWITCH;
        }

        if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HEADSET &&
            pPhone->dwHeadsetHookSwitchMode != dwHookSwitchMode)
        {
            pPhone->dwHeadsetHookSwitchMode = dwHookSwitchMode;
            dwPhoneStates |= PHONESTATE_HEADSETHOOKSWITCH;
        }

        if (dwPhoneStates)
        {
            SendPhoneEvent(
                pPhone,
                PHONE_STATE,
                dwPhoneStates,
                dwHookSwitchMode,
                0
                );
        }
    }
}


LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDevs,
    DWORD           dwHookSwitchMode
    )
{
    static char szFuncName[] = "phoneSetHookSwitch";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID         },
        { szhdPhone,            hdPhone             },
        { "dwHookSwitchDevs",   dwHookSwitchDevs,   aHookSwitchDevs },
        { "dwHookSwitchMode",   dwHookSwitchMode,   aHookSwitchModes    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_phoneSetHookSwitch_postProcess
    };


    if (Prolog (&info))
    {
        info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;
        info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) dwHookSwitchDevs;
        info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) dwHookSwitchMode;
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetLamp_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD       dwLampMode = (DWORD) pAsyncReqInfo->dwParam2;
        PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


        if (pPhone->dwLampMode != dwLampMode)
        {
            pPhone->dwLampMode = dwLampMode;
            SendPhoneEvent (pPhone, PHONE_STATE, PHONESTATE_LAMP, 0, 0);
        }
    }
}


LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwButtonLampID,
    DWORD           dwLampMode
    )
{
    static char szFuncName[] = "phoneSetLamp";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID     },
        { szhdPhone,        hdPhone         },
        { "dwButtonLampID", dwButtonLampID  },
        { "dwLampMode",     dwLampMode, aLampModes   }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_phoneSetLamp_postProcess
    };


    if (Prolog (&info))
    {
        if (dwButtonLampID == 0)
        {
            info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;
            info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) dwLampMode;
        }
        else
        {
            info.lResult = PHONEERR_INVALBUTTONLAMPID;
        }
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetRing_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD       dwRingMode = (DWORD) pAsyncReqInfo->dwParam2,
                    dwRingVolume = (DWORD) pAsyncReqInfo->dwParam3,
                    dwPhoneStates = 0;
        PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


        if (pPhone->dwRingMode != dwRingMode)
        {
            pPhone->dwRingMode = dwRingMode;
            dwPhoneStates |= PHONESTATE_RINGMODE;
        }

        if (pPhone->dwRingVolume != dwRingVolume)
        {
            pPhone->dwRingVolume = dwRingVolume;
            dwPhoneStates |= PHONESTATE_RINGVOLUME;
        }

        if (dwPhoneStates)
        {
            SendPhoneEvent(
                pPhone,
                PHONE_STATE,
                dwPhoneStates,
                (dwPhoneStates & PHONESTATE_RINGMODE) ? dwRingMode : 0,
                0
                );
        }
    }
}


LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRingMode,
    DWORD           dwVolume
    )
{
    static char szFuncName[] = "phoneSetRing";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,    dwRequestID },
        { szhdPhone,        hdPhone     },
        { "dwRingMode",     dwRingMode  },
        { "dwVolume",       dwVolume    }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_phoneSetRing_postProcess
    };


    if (Prolog (&info))
    {
        info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;
        info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) dwRingMode;
        info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) dwVolume;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE   hdPhone,
    DWORD       dwPhoneStates,
    DWORD       dwButtonModes,
    DWORD       dwButtonStates
    )
{
    static char szFuncName[] = "phoneSetStatusMessages";
    FUNC_PARAM params[] =
    {
        { szhdPhone,        hdPhone         },
        { "dwPhoneStates",  dwPhoneStates,  aPhoneStates    },
        { "dwButtonModes",  dwButtonModes,  aButtonModes    },
        { "dwButtonStates", dwButtonStates, aButtonStates   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };


    if (Prolog (&info))
    {
    }

    return (Epilog (&info));
}


void
FAR
PASCAL
TSPI_phoneSetVolume_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        DWORD       dwHookSwitchDev = (DWORD) pAsyncReqInfo->dwParam2,
                    dwVolume = (DWORD) pAsyncReqInfo->dwParam3,
                   *pdwXxxVolume, dwPhoneState;
        PDRVPHONE   pPhone = (PDRVPHONE) pAsyncReqInfo->dwParam1;


        switch (dwHookSwitchDev)
        {
        case PHONEHOOKSWITCHDEV_HANDSET:

            pdwXxxVolume = &pPhone->dwHandsetVolume;
            dwPhoneState = PHONESTATE_HANDSETVOLUME;
            break;

        case PHONEHOOKSWITCHDEV_SPEAKER:

            pdwXxxVolume = &pPhone->dwSpeakerVolume;
            dwPhoneState = PHONESTATE_SPEAKERVOLUME;
            break;

        default: // case PHONEHOOKSWITCHDEV_HEADSET:

            pdwXxxVolume = &pPhone->dwHeadsetVolume;
            dwPhoneState = PHONESTATE_HEADSETVOLUME;
            break;
        }

        if (*pdwXxxVolume != dwVolume)
        {
            *pdwXxxVolume = dwVolume;
            SendPhoneEvent (pPhone, PHONE_STATE, dwPhoneState, 0, 0);
        }
    }
}


LONG
TSPIAPI
TSPI_phoneSetVolume(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDev,
    DWORD           dwVolume
    )
{
    static char szFuncName[] = "phoneSetVolume";
    FUNC_PARAM params[] =
    {
        { szdwRequestID,        dwRequestID     },
        { szhdPhone,            hdPhone         },
        { "dwHookSwitchDev",    dwHookSwitchDev }, // BUGBUG lookup
        { "dwVolume",           dwVolume        }
    };
    FUNC_INFO info =
    {
        szFuncName,
        ASYNC,
        4,
        params,
        TSPI_phoneSetVolume_postProcess
    };


    if (Prolog (&info))
    {
        info.pAsyncReqInfo->dwParam1 = (ULONG_PTR) hdPhone;
        info.pAsyncReqInfo->dwParam2 = (ULONG_PTR) dwHookSwitchDev;
        info.pAsyncReqInfo->dwParam3 = (ULONG_PTR) dwVolume;
    }

    return (Epilog (&info));
}



//
// ------------------------- TSPI_providerXxx funcs ---------------------------
//

LONG
TSPIAPI
TSPI_providerConfig(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    //
    // 32-bit TAPI never actually calls this function (the corresponding
    // TUISPI_ func has taken it's place), but the Telephony control
    // panel applet does look to see if this function is exported to
    // determine whether or not the provider is configurable
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    ULONG_PTR   dwTempID,
    DWORD       dwDeviceID
    )
{
    static char szFuncName[] = "providerCreateLineDevice";
    FUNC_PARAM params[] =
    {
        { "dwTempID",   dwTempID    },
        { szdwDeviceID, dwDeviceID  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
        PDRVLINE    pLine = (PDRVLINE) (((LPBYTE) gESPGlobals.pLines->aLines) +
                        (dwTempID * gdwDrvLineSize));


        pLine->dwDeviceID = dwDeviceID;

        WriteEventBuffer (pLine->dwDeviceID, WIDGETTYPE_LINE, 0, 0, 0, 0);
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(
    ULONG_PTR   dwTempID,
    DWORD       dwDeviceID
    )
{
    static char szFuncName[] = "providerCreatePhoneDevice";
    FUNC_PARAM params[] =
    {
        { "dwTempID",   dwTempID    },
        { szdwDeviceID, dwDeviceID  }
    };
    FUNC_INFO info = { szFuncName, SYNC, 2, params };


    if (Prolog (&info))
    {
        PDRVPHONE   pPhone = gESPGlobals.pPhones->aPhones + dwTempID;


        pPhone->dwDeviceID = dwDeviceID;

        WriteEventBuffer (pPhone->dwDeviceID, WIDGETTYPE_PHONE, 0, 0, 0, 0);
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    static char szFuncName[] = "providerEnumDevices";
    FUNC_PARAM params[] =
    {
        { szdwPermanentProviderID,  dwPermanentProviderID   },
        { "lpdwNumLines",           lpdwNumLines            },
        { "lpdwNumPhones",          lpdwNumPhones           },
        { "hProvider",              hProvider               },
        { "lpfnLineCreateProc",     lpfnLineCreateProc      },
        { "lpfnPhoneCreateProc",    lpfnPhoneCreateProc     }
    };
    FUNC_INFO info = { szFuncName, SYNC, 6, params };


    if (Prolog (&info))
    {
        *lpdwNumLines  = gESPGlobals.dwNumLines;
        *lpdwNumPhones = gESPGlobals.dwNumPhones;

        gESPGlobals.pfnLineEvent  = lpfnLineCreateProc;
        gESPGlobals.pfnPhoneEvent = lpfnPhoneCreateProc;

        gESPGlobals.hProvider = hProvider;
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_providerFreeDialogInstance(
    HDRVDIALOGINSTANCE  hdDlgInst
    )
{
    static char szFuncName[] = "providerFreeDialogInstance";
    FUNC_PARAM params[] =
    {
        { "hdDlgInst",  hdDlgInst   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 1, params };


    Prolog (&info);

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_providerGenericDialogData(
    ULONG_PTR   dwObjectID,
    DWORD       dwObjectType,
    LPVOID      lpParams,
    DWORD       dwSize
    )
{
    static char szFuncName[] = "providerGenericDialogData";
    FUNC_PARAM params[] =
    {
        { "dwObjectID",     dwObjectID      },
        { "dwObjectType",   dwObjectType    },
        { "lpszParams",      lpParams       },
        { "dwSize",         dwSize          }
    };
    FUNC_INFO info = { szFuncName, SYNC, 4, params };


    Prolog (&info);

    lstrcpyA (lpParams, "espDlgData");

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    static char szFuncName[] = "providerInit";
    FUNC_PARAM params[] =
    {
        { "dwTSPIVersion",          dwTSPIVersion           },
        { szdwPermanentProviderID,  dwPermanentProviderID   },
        { "dwLineDeviceIDBase",     dwLineDeviceIDBase      },
        { "dwPhoneDeviceIDBase",    dwPhoneDeviceIDBase     },
        { "dwNumLines",             dwNumLines              },
        { "dwNumPhones",            dwNumPhones             },
        { "lpfnCompletionProc",     lpfnCompletionProc      }
    };
    FUNC_INFO info = { szFuncName, SYNC, 7, params };
    DWORD       i, dwNumTotalEntries;
    PDRVLINE    pLine;
    PDRVPHONE   pPhone;

    if (!Prolog (&info))
    {
        return (Epilog (&info));
    }


    //
    //
    //

    // BUGBUG zero out he approp gESPGlobals stuff

    gESPGlobals.bProviderShutdown = FALSE;

    ZeroMemory (gaParkedCalls, MAX_NUM_PARKED_CALLS * sizeof (PDRVCALL));


    //
    // Alloc a queue for storing async requests for async completion,
    // and start a thread to service that queue
    //

//    if (gbDisableUI == FALSE) IF THIS IS UNCOMMENTED MUST MUNGE ERROR CLEANUP
    {
        gESPGlobals.dwNumTotalQueueEntries = DEF_NUM_ASYNC_REQUESTS_IN_QUEUE;

        if (!(gESPGlobals.pAsyncRequestQueue = DrvAlloc(
                gESPGlobals.dwNumTotalQueueEntries * sizeof (DWORD)

                )))
        {
            goto TSPI_providerInit_error0;
        }

        gESPGlobals.pAsyncRequestQueueIn =
        gESPGlobals.pAsyncRequestQueueOut = gESPGlobals.pAsyncRequestQueue;

        if (!(gESPGlobals.hAsyncEventsPendingEvent = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,
                TRUE,   // manual reset
                FALSE,  // non-signaled
                NULL    // unnamed
                )))
        {
            goto TSPI_providerInit_error1;
        }

        if (!(gESPGlobals.hAsyncEventQueueServiceThread = CreateThread(
                (LPSECURITY_ATTRIBUTES) NULL,
                0,      // def stack size
                (LPTHREAD_START_ROUTINE) AsyncEventQueueServiceThread,
                NULL,   // thread param
                0,      // creation flags
                &i      // &dwThreadID
                )))
        {
            goto TSPI_providerInit_error2;
        }
    }


    //
    // Init sundry globals
    //

    gESPGlobals.dwPermanentProviderID = dwPermanentProviderID;
    gESPGlobals.dwLineDeviceIDBase    = dwLineDeviceIDBase;
    gESPGlobals.dwPhoneDeviceIDBase   = dwPhoneDeviceIDBase;
    gESPGlobals.dwInitialNumLines     = (DWORD)dwNumLines;
    gESPGlobals.dwInitialNumPhones    = (DWORD)dwNumPhones;
    gESPGlobals.pfnCompletion         = lpfnCompletionProc;

    gESPGlobals.hIconLine = LoadIcon(
        ghInstance,
        (LPCSTR)MAKEINTRESOURCE(PHONE_ICON) // the id's are reversed
        );

    gESPGlobals.hIconPhone = LoadIcon(
        ghInstance,
        (LPCSTR)MAKEINTRESOURCE(LINE_ICON)
        );


    //
    // Init the line lookup table & crit sec for accessing call lists
    //

    dwNumTotalEntries = (DWORD)dwNumLines + DEF_NUM_EXTRA_LOOKUP_ENTRIES;

    gdwDrvLineSize = sizeof (DRVLINE) +
        ((gESPGlobals.dwNumAddressesPerLine - 1) * sizeof (DRVADDRESS));

    if (!(gESPGlobals.pLines = DrvAlloc(
            sizeof (DRVLINETABLE) +
            (dwNumTotalEntries * gdwDrvLineSize)
            )))
    {
        goto TSPI_providerInit_error3;
    }

    gESPGlobals.pLines->dwNumTotalEntries = dwNumTotalEntries;
    gESPGlobals.pLines->dwNumUsedEntries  = (DWORD)dwNumLines;

    for (
        i = dwLineDeviceIDBase, pLine = gESPGlobals.pLines->aLines;
        i < (dwLineDeviceIDBase + dwNumTotalEntries);
        i++
        )
    {
        pLine->dwDeviceID =
            (i < (dwLineDeviceIDBase + dwNumLines) ? i : 0xffffffff);

        pLine = (PDRVLINE) (((LPBYTE) pLine) + gdwDrvLineSize);
    }


    //
    // Init the phone lookup table
    //

    dwNumTotalEntries = (DWORD)dwNumPhones + DEF_NUM_EXTRA_LOOKUP_ENTRIES;

    if (!(gESPGlobals.pPhones = DrvAlloc(
            sizeof (DRVPHONETABLE) + dwNumTotalEntries * sizeof(DRVPHONE)
            )))
    {
        goto TSPI_providerInit_error4;
    }

    gESPGlobals.pPhones->dwNumTotalEntries = dwNumTotalEntries;
    gESPGlobals.pPhones->dwNumUsedEntries  = (DWORD)dwNumPhones;

    for (
        i = dwPhoneDeviceIDBase, pPhone = gESPGlobals.pPhones->aPhones;
        i < (dwPhoneDeviceIDBase + dwNumTotalEntries);
        i++, pPhone++
        )
    {
        pPhone->dwDeviceID =
            (i < (dwPhoneDeviceIDBase + dwNumPhones) ? i : 0xffffffff);
    }

    if (gbDisableUI == FALSE)
    {
        WriteEventBuffer(
            0,
            WIDGETTYPE_STARTUP,
            dwNumLines,
            dwNumPhones,
            dwLineDeviceIDBase,
            dwPhoneDeviceIDBase
            );
    }

    goto TSPI_providerInit_return;


TSPI_providerInit_error4:

    DrvFree (gESPGlobals.pLines);

TSPI_providerInit_error3:

    gESPGlobals.bProviderShutdown = TRUE;

    if (gESPGlobals.hAsyncEventQueueServiceThread)
    {
        // wait for the thread to terminate
        while (WaitForSingleObject(
            gESPGlobals.hAsyncEventQueueServiceThread,
            0
            ) != WAIT_OBJECT_0)
        {
            SetEvent (gESPGlobals.hAsyncEventsPendingEvent);
            Sleep (0);
        }

        CloseHandle (gESPGlobals.hAsyncEventQueueServiceThread);
        gESPGlobals.hAsyncEventQueueServiceThread = 0;
    
    }

TSPI_providerInit_error2:

    CloseHandle (gESPGlobals.hAsyncEventsPendingEvent);
    gESPGlobals.hAsyncEventsPendingEvent = 0;

TSPI_providerInit_error1:

    DrvFree (gESPGlobals.pAsyncRequestQueue);

TSPI_providerInit_error0:

    info.lResult = LINEERR_NOMEM;

TSPI_providerInit_return:

    return (Epilog (&info)); // BUGBUG TSPI_providerInit: return 0 by default
}


LONG
TSPIAPI
TSPI_providerInstall(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    //
    // 32-bit TAPI never actually calls this function (the corresponding
    // TUISPI_ func has taken it's place), but the Telephony control
    // panel applet does look to see if this function is exported to
    // determine whether or not the provider is installable
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerRemove(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    //
    // 32-bit TAPI never actually calls this function (the corresponding
    // TUISPI_ func has taken it's place), but the Telephony control
    // panel applet does look to see if this function is exported to
    // determine whether or not the provider is removeable
    //

    return 0;
}


LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    static char szFuncName[] = "providerShutdown";
    FUNC_PARAM params[] =
    {
        { "dwTSPIVersion",  dwTSPIVersion },
        { szdwPermanentProviderID,  dwPermanentProviderID   }
    };
    FUNC_INFO   info = { szFuncName, SYNC, 2, params };
    LONG        lResult;
    DWORD       i;


    Prolog (&info);

    DestroyIcon (gESPGlobals.hIconLine);
    DestroyIcon (gESPGlobals.hIconPhone);


    //
    //
    //

//    if (gbDisableUI == FALSE)
//    {
        gESPGlobals.bProviderShutdown = TRUE;

        if (gESPGlobals.hAsyncEventQueueServiceThread)
        {
            // wait for the thread to terminate
            while (WaitForSingleObject(
                gESPGlobals.hAsyncEventQueueServiceThread,
                0
                ) != WAIT_OBJECT_0)
            {
                SetEvent (gESPGlobals.hAsyncEventsPendingEvent);
                Sleep (0);
            }

            CloseHandle (gESPGlobals.hAsyncEventQueueServiceThread);
            gESPGlobals.hAsyncEventQueueServiceThread = 0;
        }

        CloseHandle (gESPGlobals.hAsyncEventsPendingEvent);
        gESPGlobals.hAsyncEventsPendingEvent = 0;

        DrvFree (gESPGlobals.pAsyncRequestQueue);
//    }


    //
    // Free the device tables & call list crit sec
    //

    {
        PDRVLINETABLE   pTable = gESPGlobals.pLines;


        while (pTable)
        {
            PDRVLINETABLE   pNextTable = pTable->pNext;


            DrvFree (pTable);
            pTable = pNextTable;
        }
        gESPGlobals.pLines = 0;
}

    {
        PDRVPHONETABLE  pTable = gESPGlobals.pPhones;


        while (pTable)
        {
            PDRVPHONE       pPhone = pTable->aPhones;
            PDRVPHONETABLE  pNextTable = pTable->pNext;


            for (i = 0; i < pTable->dwNumUsedEntries; i++, pPhone++)
            {
                if (pPhone->pData)
                {
                    DrvFree (pPhone->pData);
                }

                if (pPhone->pButtonInfo)
                {
                    DrvFree (pPhone->pButtonInfo);
                }

                if (pPhone->pDisplay)
                {
                    DrvFree (pPhone->pDisplay);
                }
            }

            DrvFree (pTable);
            pTable = pNextTable;
        }
    gESPGlobals.pPhones = 0;
    }


    //
    //
    //

    if (ghPBXThread)
    {
        ESPStopPBXThread (0);
    }


    //
    // Clean up any parked calls
    //

    for (i = 0; i < MAX_NUM_PARKED_CALLS; i++)
    {
        if (gaParkedCalls[i])
        {
            if (gaParkedCalls[i]->pSendingFlowspec)
            {
                DrvFree (gaParkedCalls[i]->pSendingFlowspec);
            }

            if (gaParkedCalls[i]->pReceivingFlowspec)
            {
                DrvFree (gaParkedCalls[i]->pReceivingFlowspec);
            }

            if (gaParkedCalls[i]->pCallData)
            {
                DrvFree (gaParkedCalls[i]->pCallData);
            }

            DrvFree (gaParkedCalls[i]);
        }
    }

    return (Epilog (&info));
}


LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
    )
{
    static char szFuncName[] = "providerUIIdentify";
    FUNC_PARAM params[] =
    {
        { "pszUIDLLName",   lpszUIDLLName   }
    };
    FUNC_INFO info = { szFuncName, SYNC, 1, params };


    Prolog (&info);

    wcscpy (lpszUIDLLName, szESPUIDLL);

    return (Epilog (&info));
}

#pragma warning (default:4047)

//
// ------------------------ Private support routines --------------------------
//


BOOL
PASCAL
IsValidDrvCall(
    PDRVCALL    pCall,
    LPDWORD     pdwCallInstance
    )
{
    try
    {
        if (pdwCallInstance)
        {
            *pdwCallInstance = pCall->dwCallInstance;
        }

        if (pCall->dwKey != DRVCALL_KEY)
        {
            return FALSE;
        }
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return FALSE;
    }

    return TRUE;
}


VOID
ShowStr(
    BOOL    bAlertApp,
    char   *format,
    ...
    )
{
    char    buf[256];
    DWORD   dwTotalSize, dwMoveSize, dwMoveSizeWrapped = 0;
    va_list ap;


    if (gbDisableUI == TRUE)
    {
        return;
    }

    va_start(ap, format);

    dwTotalSize = wvsprintf (buf, format, ap);
    buf[dwTotalSize++] = '\r';
    buf[dwTotalSize++] = '\n';

    dwMoveSize = dwTotalSize;

    EnterCriticalSection (&gESPGlobals.DebugBufferCritSec);


    //
    // Check to see if there's enough room in the the buffer for the new
    // data, alloc more if not
    //

    if (dwMoveSize > (gESPGlobals.dwDebugBufferTotalSize -
            gESPGlobals.dwDebugBufferUsedSize))
    {
        char   *pNewDebugBuffer;
        DWORD   dwMoveSize2, dwMoveSizeWrapped2;


        if (!(pNewDebugBuffer = DrvAlloc(
                2 * gESPGlobals.dwDebugBufferTotalSize
                )))
        {
            LeaveCriticalSection (&gESPGlobals.DebugBufferCritSec);
            return;
        }

        if (gESPGlobals.pDebugBufferIn > gESPGlobals.pDebugBufferOut)
        {
            dwMoveSize2 = (DWORD) (gESPGlobals.pDebugBufferIn -
                gESPGlobals.pDebugBufferOut);

            dwMoveSizeWrapped2 = 0;
        }
        else
        {
            dwMoveSize2 = (DWORD) ((gESPGlobals.pDebugBuffer +
                gESPGlobals.dwDebugBufferTotalSize) -
                gESPGlobals.pDebugBufferOut);

            dwMoveSizeWrapped2 = (DWORD) (gESPGlobals.pDebugBufferIn -
                gESPGlobals.pDebugBuffer);
        }

        CopyMemory(
            pNewDebugBuffer,
            gESPGlobals.pDebugBufferOut,
            dwMoveSize2
            );

        if (dwMoveSizeWrapped2)
        {
            CopyMemory(
                pNewDebugBuffer + dwMoveSize2,
                gESPGlobals.pDebugBuffer,
                dwMoveSizeWrapped2
                );
        }

        DrvFree (gESPGlobals.pDebugBuffer);

        gESPGlobals.pDebugBufferIn = pNewDebugBuffer + dwMoveSize2 +
            dwMoveSizeWrapped2;

        gESPGlobals.pDebugBuffer =
        gESPGlobals.pDebugBufferOut = pNewDebugBuffer;

        gESPGlobals.dwDebugBufferTotalSize *= 2;
    }

    if (gESPGlobals.pDebugBufferIn >= gESPGlobals.pDebugBufferOut)
    {
        DWORD dwFreeSize = gESPGlobals.dwDebugBufferTotalSize -
                (DWORD)(gESPGlobals.pDebugBufferIn - gESPGlobals.pDebugBuffer);


        if (dwMoveSize > dwFreeSize)
        {
            dwMoveSizeWrapped = dwMoveSize - dwFreeSize;

            dwMoveSize = dwFreeSize;
        }
    }

    CopyMemory (gESPGlobals.pDebugBufferIn, buf, dwMoveSize);

    if (dwMoveSizeWrapped != 0)
    {
        CopyMemory(
            gESPGlobals.pDebugBuffer,
            buf + dwMoveSize,
            dwMoveSizeWrapped
            );

        gESPGlobals.pDebugBufferIn = gESPGlobals.pDebugBuffer +
            dwMoveSizeWrapped;
    }
    else
    {
        gESPGlobals.pDebugBufferIn += dwMoveSize;
    }

    gESPGlobals.dwDebugBufferUsedSize += dwTotalSize;

    LeaveCriticalSection (&gESPGlobals.DebugBufferCritSec);

    if (bAlertApp)
    {
        SetEvent (ghDebugOutputEvent);
    }

    va_end(ap);
}


char far *
GetFlags(
    ULONG_PTR   Flags,
    PLOOKUP     pLookup
    )
{
    int i = 0, dwbufLen = 0;
    static char buf[256] = {0};
    char far *p = (char far *) NULL;


    if (gbDisableUI == TRUE)
    {
        return NULL;
    }

    buf[0] = 0;

    for (i = 0; (Flags && (pLookup[i].dwVal != 0xffffffff)); i++)
    {
        if (Flags & pLookup[i].dwVal)
        {
            dwbufLen = lstrlenA(buf);
            lstrcpynA (buf+dwbufLen, pLookup[i].lpszVal, 256 - dwbufLen);
            dwbufLen = lstrlenA(buf);
            lstrcpynA (buf+dwbufLen, " ", 256 - dwbufLen);
            dwbufLen = lstrlenA(buf);

            Flags = Flags & (~ ((ULONG_PTR) pLookup[i].dwVal));
        }
    }

    if (buf[0])
    {
        if ((p = (char far *) DrvAlloc (lstrlenA (buf) + 1)))
        {
            lstrcpynA (p, buf, lstrlenA (buf));
        }
    }

    return p;
}


void
ShowLineEvent(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    if (gESPGlobals.dwDebugOptions & SHOW_EVENT_NOTIFICATIONS)
    {
        static DWORD adwLineMsgs[] =
        {
            LINE_ADDRESSSTATE,
            LINE_CALLINFO,
            LINE_CALLSTATE,
            LINE_CLOSE,
            LINE_DEVSPECIFIC,
            LINE_DEVSPECIFICFEATURE,
            LINE_GATHERDIGITS,
            LINE_GENERATE,
            LINE_LINEDEVSTATE,
            LINE_MONITORDIGITS,
            LINE_MONITORMEDIA,
            LINE_MONITORTONE,

            LINE_CREATE,

            LINE_NEWCALL,
            LINE_CALLDEVSPECIFIC,
            LINE_CALLDEVSPECIFICFEATURE,

            LINE_REMOVE,

            0xffffffff
        };

        static char *aszLineMsgs[] =
        {
            "LINE_ADDRESSSTATE",
            "LINE_CALLINFO",
            "LINE_CALLSTATE",
            "LINE_CLOSE",
            "LINE_DEVSPECIFIC",
            "LINE_DEVSPECIFICFEATURE",
            "LINE_GATHERDIGITS",
            "LINE_GENERATE",
            "LINE_LINEDEVSTATE",
            "LINE_MONITORDIGITS",
            "LINE_MONITORMEDIA",
            "LINE_MONITORTONE",

            "LINE_CREATE",

            "LINE_NEWCALL",
            "LINE_CALLDEVSPECIFIC",
            "LINE_CALLDEVSPECIFICFEATURE",

            "LINE_REMOVE"
        };

        int       i;
        char far *lpszParam1 = (char far *) NULL;
        char far *lpszParam2 = (char far *) NULL;
        char far *lpszParam3 = (char far *) NULL;


        for (i = 0; adwLineMsgs[i] != 0xffffffff; i++)
        {
            if (dwMsg == adwLineMsgs[i])
            {
                ShowStr(
                    FALSE,
                    "%ssent %s : htLine=x%x, htCall=x%x",
                    szCallUp,
                    aszLineMsgs[i],
                    htLine,
                    htCall
                    );

                break;
            }
        }

        if (adwLineMsgs[i] == 0xffffffff)
        {
            ShowStr(
                FALSE,
                "%ssent <unknown msg id, x%x> : htLine=x%x, htCall=x%x",
                szCallUp,
                dwMsg,
                htLine,
                htCall
                );
        }

        switch (dwMsg)
        {
        case LINE_ADDRESSSTATE:

            lpszParam2 = GetFlags (Param2, aAddressStates);
            break;

        case LINE_CALLINFO:

            lpszParam1 = GetFlags (Param1, aCallInfoStates);
            break;

        case LINE_CALLSTATE:

            lpszParam1 = GetFlags (Param1, aCallStates);
            break;

        case LINE_LINEDEVSTATE:

            lpszParam1 = GetFlags (Param1, aLineStates);
            break;

        } // switch

        ShowStr(
            FALSE,
            "%s%sParam1=x%x, %s",
            szCallUp,
            szTab,
            Param1,
            (lpszParam1 ? lpszParam1 : "")
            );

        ShowStr(
            FALSE,
            "%s%sParam2=x%x, %s",
            szCallUp,
            szTab,
            Param2,
            (lpszParam2 ? lpszParam2 : "")
            );

        ShowStr(
            TRUE,
            "%s%sParam3=x%x, %s",
            szCallUp,
            szTab,
            Param3,
            (lpszParam3 ? lpszParam3 : "")
            );

        if (lpszParam1)
        {
            DrvFree (lpszParam1);
        }

        if (lpszParam2)
        {
            DrvFree (lpszParam2);
        }

        if (lpszParam3)
        {
            DrvFree (lpszParam3);
        }
    }
}


void
ShowPhoneEvent(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    if (gESPGlobals.dwDebugOptions & SHOW_EVENT_NOTIFICATIONS)
    {
        static DWORD adwPhoneMsgs[] =
        {
            PHONE_BUTTON,
            PHONE_CLOSE,
            PHONE_DEVSPECIFIC,
            PHONE_STATE,
            PHONE_CREATE,
            PHONE_REMOVE,
            0xffffffff
        };

        static char *aszPhoneMsgs[] =
        {
            "PHONE_BUTTON",
            "PHONE_CLOSE",
            "PHONE_DEVSPECIFIC",
            "PHONE_STATE",
            "PHONE_CREATE",
            "PHONE_REMOVE"
        };
        char far *lpszParam1 = (char far *) NULL;
        char far *lpszParam2 = (char far *) NULL;
        char far *lpszParam3 = (char far *) NULL;
        DWORD   i;


        for (i = 0; adwPhoneMsgs[i] != 0xffffffff; i++)
        {
            if (dwMsg == adwPhoneMsgs[i])
            {
                ShowStr(
                    FALSE,
                    "%ssent %s : htPhone=x%x",
                    szCallUp,
                    aszPhoneMsgs[i],
                    htPhone
                    );

                break;
            }
        }

        if (adwPhoneMsgs[i] == 0xffffffff)
        {
            ShowStr(
                FALSE,
                "%ssent <unknown msg id, x%x> : htPhone=x%x",
                szCallUp,
                dwMsg,
                htPhone
                );
        }

        switch (dwMsg)
        {
        case PHONE_BUTTON:

            lpszParam2 = GetFlags (Param2, aButtonModes);
            lpszParam3 = GetFlags (Param3, aButtonStates);
            break;

        case PHONE_STATE:

            lpszParam1 = GetFlags (Param1, aPhoneStates);
            break;

        } // switch

        ShowStr(
            FALSE,
            "%s%sParam1=x%x, %s",
            szCallUp,
            szTab,
            Param1,
            (lpszParam1 ? lpszParam1 : "")
            );

        ShowStr(
            FALSE,
            "%s%sParam2=x%x, %s",
            szCallUp,
            szTab,
            Param2,
            (lpszParam2 ? lpszParam2 : "")
            );

        ShowStr(
            TRUE,
            "%s%sParam3=x%x, %s",
            szCallUp,
            szTab,
            Param3,
            (lpszParam3 ? lpszParam3 : "")
            );

        if (lpszParam1)
        {
            DrvFree (lpszParam1);
        }

        if (lpszParam2)
        {
            DrvFree (lpszParam2);
        }

        if (lpszParam3)
        {
            DrvFree (lpszParam3);
        }
    }
}


BOOL
Prolog(
    PFUNC_INFO pInfo
    )
{
    BOOL  bLineFunc = (pInfo->pszFuncName[1] != 'h');
    DWORD i, j;

    ASSERT_SANITYCHECK;

    if (gESPGlobals.dwDebugOptions & SHOW_FUNC_ENTRY)
    {
        ShowStr (FALSE, "TSPI_%s: enter", pInfo->pszFuncName);
    }

    if (gESPGlobals.dwDebugOptions & SHOW_PARAMETERS)
    {
        for (i = 0; i < pInfo->dwNumParams; i++)
        {
            if (pInfo->aParams[i].dwVal &&
                pInfo->aParams[i].lpszVal[3] == 'z') // "lpszXxx"
            {
                ShowStr(
                    FALSE,
                    "%s%s=x%x, '%ws'",
                    szTab,
                    pInfo->aParams[i].lpszVal,
                    pInfo->aParams[i].dwVal,
                    pInfo->aParams[i].dwVal
                    );
            }
            else if (pInfo->aParams[i].pLookup)
            {
                char buf[90];
                int dwbufLen = 0;
                PLOOKUP pLookup = pInfo->aParams[i].pLookup;


                wsprintfA(
                    buf,
                    "%s%s=x%x, ",
                    szTab,
                    pInfo->aParams[i].lpszVal,
                    pInfo->aParams[i].dwVal
                    );

	          dwbufLen = lstrlenA(buf);

                for (j = 0; pLookup[j].dwVal != 0xffffffff; j++)
                {
                    if (pInfo->aParams[i].dwVal & pLookup[j].dwVal)
                    {
		          dwbufLen = lstrlenA(buf);
                        lstrcpynA (buf+dwbufLen, pLookup[j].lpszVal, 90 - dwbufLen);
		          dwbufLen = lstrlenA(buf);
                        lstrcpynA (buf+dwbufLen, " ", 90 - dwbufLen);
		          dwbufLen = lstrlenA(buf);

                        if (lstrlenA (buf) > 60)
                        {
                            ShowStr (FALSE, buf);
                            wsprintfA (buf, "%s%s", szTab, szTab);
				dwbufLen = lstrlenA(buf);
                        }
                    }
                }

                ShowStr (FALSE, buf);
            }
            else
            {
                ShowStr(
                    FALSE,
                    "%s%s=x%x",
                    szTab,
                    pInfo->aParams[i].lpszVal,
                    pInfo->aParams[i].dwVal
                    );
            }
        }
    }

    if (gESPGlobals.dwDebugOptions & (SHOW_PARAMETERS | SHOW_FUNC_ENTRY))
    {
        SetEvent (ghDebugOutputEvent);
    }


    //
    //
    //

    if (gdwDevSpecificRequestID  &&
         glNextRequestResult != 0  &&
         (pInfo->bAsync == FALSE  ||
             gdwNextRequestCompletionType == ESP_RESULT_RETURNRESULT)
         )
    {
        gdwDevSpecificRequestID = 0;
        pInfo->lResult = glNextRequestResult;
        return FALSE;
    }


    if (gESPGlobals.dwDebugOptions & MANUAL_RESULTS)
    {
        char szDlgTitle[64];
        EVENT_PARAM params[] =
        {
            { "lResult", PT_ORDINAL, 0, (bLineFunc ? aLineErrs : aPhoneErrs) }
        };
        EVENT_PARAM_HEADER paramsHeader =
            { 1, szDlgTitle, 0, params };
        HWND hwnd;


        wsprintfA (szDlgTitle, "TSPI_%s request result", pInfo->pszFuncName);

        DialogBoxParamA(
            ghInstance,
            (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG1),
            (HWND) NULL,
            ValuesDlgProc,
            (LPARAM) &paramsHeader
            );


        //
        // If user selected to synchronously return an error we'll save
        // the error & return FALSE to indicate to caller that it should
        // return immediately.
        //

        if (params[0].dwValue)
        {
            pInfo->lResult = (LONG) params[0].dwValue;

            return FALSE;
        }
    }


    if (pInfo->bAsync)
    {
        //
        // Alloc & init an async request info structure
        //

        PASYNC_REQUEST_INFO pAsyncReqInfo = (PASYNC_REQUEST_INFO)
            DrvAlloc (sizeof(ASYNC_REQUEST_INFO));


        if ((pInfo->pAsyncReqInfo = pAsyncReqInfo))
        {
            pAsyncReqInfo->pfnPostProcessProc = (FARPROC)
                pInfo->pfnPostProcessProc;
            pAsyncReqInfo->dwRequestID        = (DWORD)pInfo->aParams[0].dwVal;

            pAsyncReqInfo->pszFuncName = pInfo->pszFuncName;
        }
        else
        {
            pInfo->lResult = (bLineFunc ?
                LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);

            return FALSE;
        }
    }

    ASSERT_SANITYCHECK;

    return TRUE;
}


LONG
Epilog(
    PFUNC_INFO pInfo
    )
{
    ASSERT_SANITYCHECK;

    if (pInfo->bAsync)
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo = pInfo->pAsyncReqInfo;


        if (pInfo->lResult == 0)
        {
            //
            //
            //

            if (gdwDevSpecificRequestID  &&
                pInfo->aParams[0].dwVal != gdwDevSpecificRequestID)
            {
                gdwDevSpecificRequestID = 0;

                if (glNextRequestResult != 0)
                {
                    pAsyncReqInfo->lResult = glNextRequestResult;
                }

                if (gdwNextRequestCompletionType ==
                        ESP_RESULT_CALLCOMPLPROCASYNC)
                {
                    goto complete_event_async;
                }
                else
                {
                    goto complete_event_sync;
                }
            }

            switch (gESPGlobals.dwCompletionMode)
            {
            case COMPLETE_ASYNC_EVENTS_SYNCHRONOUSLY:

                //
                // We're completing this async request synchronously, so call
                // the post processing proc (if there is one) or call the
                // completion routine directly
                //

complete_event_sync:

                if (pInfo->pAsyncReqInfo->pfnPostProcessProc)
                {
                    (*((POSTPROCESSPROC) pAsyncReqInfo->pfnPostProcessProc))(
                        pInfo->pAsyncReqInfo,
                        SYNC
                        );
                }
                else
                {
                    DoCompletion (pAsyncReqInfo, SYNC);
                }

                DrvFree (pAsyncReqInfo);

                break;

            case COMPLETE_ASYNC_EVENTS_ASYNCHRONOUSLY:

                //
                // Safely add the async request to the queue (careful to
                // reset pDataIn when we reach the end of the buffer)
                //

complete_event_async:

                EnterCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);

                if (gESPGlobals.dwNumUsedQueueEntries ==
                        gESPGlobals.dwNumTotalQueueEntries)
                {
                    //
                    // We've max'd out our ring buf, so try to grow it
                    //

                    DWORD                   dwMoveSize;
                    PASYNC_REQUEST_INFO     *pNewAsyncRequestQueue;


                    if (!(pNewAsyncRequestQueue = DrvAlloc(
                            2 * gESPGlobals.dwNumTotalQueueEntries *
                            sizeof (DWORD)
                            )))
                    {
                        LeaveCriticalSection(
                            &gESPGlobals.AsyncEventQueueCritSec
                            );

                        goto complete_event_sync;
                    }

                    dwMoveSize = (DWORD) ((gESPGlobals.pAsyncRequestQueue +
                        gESPGlobals.dwNumTotalQueueEntries) -
                        gESPGlobals.pAsyncRequestQueueOut) * sizeof (DWORD);

                    CopyMemory(
                        pNewAsyncRequestQueue,
                        gESPGlobals.pAsyncRequestQueueOut,
                        dwMoveSize
                        );

                    CopyMemory(
                        ((LPBYTE) pNewAsyncRequestQueue) + dwMoveSize,
                        gESPGlobals.pAsyncRequestQueue,
                        (gESPGlobals.pAsyncRequestQueueOut -
                            gESPGlobals.pAsyncRequestQueue) * sizeof (DWORD)
                        );

                    DrvFree (gESPGlobals.pAsyncRequestQueue);

                    gESPGlobals.pAsyncRequestQueue    =
                    gESPGlobals.pAsyncRequestQueueOut = pNewAsyncRequestQueue;

                    gESPGlobals.pAsyncRequestQueueIn = pNewAsyncRequestQueue +
                        gESPGlobals.dwNumTotalQueueEntries;

                    gESPGlobals.dwNumTotalQueueEntries *= 2;
                }

                *(gESPGlobals.pAsyncRequestQueueIn) = pAsyncReqInfo;

                gESPGlobals.pAsyncRequestQueueIn++;

                if (gESPGlobals.pAsyncRequestQueueIn ==
                        (gESPGlobals.pAsyncRequestQueue +
                            gESPGlobals.dwNumTotalQueueEntries))
                {
                    gESPGlobals.pAsyncRequestQueueIn =
                        gESPGlobals.pAsyncRequestQueue;
                }

                gESPGlobals.dwNumUsedQueueEntries++;

                if (gESPGlobals.dwNumUsedQueueEntries == 1)
                {
                    SetEvent (gESPGlobals.hAsyncEventsPendingEvent);
                }

                LeaveCriticalSection (&gESPGlobals.AsyncEventQueueCritSec);

                break;

            case COMPLETE_ASYNC_EVENTS_SYNC_AND_ASYNC:
            {
                //
                // Decide whether to complete this request sync or async,
                // then jump to the right place
                //

                static i = 0;


                if (i++ % 2)
                {
                    goto complete_event_sync;
                }
                else
                {
                    goto complete_event_async;
                }

                break;
            }
            case COMPLETE_ASYNC_EVENTS_MANUALLY:

                WriteEventBuffer(
                    (ULONG_PTR) pAsyncReqInfo->dwRequestID,
                    WIDGETTYPE_ASYNCREQUEST,
                    (ULONG_PTR) pAsyncReqInfo,
                    0,
                    0,
                    0
                    );

                break;
            }


            //
            // Finally, return the request ID
            //

            pInfo->lResult = (DWORD) pInfo->aParams[0].dwVal;
        }
        else if (pAsyncReqInfo)
        {
            DrvFree (pAsyncReqInfo);
        }
    }

    if (gESPGlobals.dwDebugOptions & SHOW_FUNC_EXIT)
    {
        ShowStr(
            TRUE,
            "TSPI_%s: exit, returning x%x",
            pInfo->pszFuncName,
            pInfo->lResult
            );
    }

    ASSERT_SANITYCHECK;

    return (pInfo->lResult);
}


void
PASCAL
SendLineEvent(
    PDRVLINE    pLine,
    PDRVCALL    pCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    //
    //
    //

    (*(gESPGlobals.pfnLineEvent))(
        pLine->htLine,
        (pCall ? pCall->htCall : (HTAPICALL) NULL),
        dwMsg,
        Param1,
        Param2,
        Param3
        );

    if (dwMsg == LINE_CALLSTATE)
    {
        //PostUpdateWidgetListMsg();
    }

    ShowLineEvent(
        pLine->htLine,
        (pCall ? pCall->htCall : (HTAPICALL) NULL),
        dwMsg,
        Param1,
        Param2,
        Param3
        );
}


void
PASCAL
SendPhoneEvent(
    PDRVPHONE   pPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    //
    //
    //

    (*(gESPGlobals.pfnPhoneEvent))(
        pPhone->htPhone,
        dwMsg,
        Param1,
        Param2,
        Param3
        );

    ShowPhoneEvent(
        pPhone->htPhone,
        dwMsg,
        Param1,
        Param2,
        Param3
        );
}


void
PASCAL
DoCompletion(
    PASYNC_REQUEST_INFO pAsyncRequestInfo,
    BOOL                bAsync
    )
{
    (*(gESPGlobals.pfnCompletion))(
        pAsyncRequestInfo->dwRequestID,
        pAsyncRequestInfo->lResult
        );

    if (gESPGlobals.dwDebugOptions & SHOW_COMPLETION_NOTIFICATIONS)
    {
        ShowStr(
            TRUE,
            "%sTSPI_%s: calling compl proc (%ssync), dwReqID=x%x, lResult = x%x",
            szCallUp,
            pAsyncRequestInfo->pszFuncName,
            (bAsync ? "a" : ""),
            pAsyncRequestInfo->dwRequestID,
            pAsyncRequestInfo->lResult
            );
    }
}


LONG
PASCAL
SetCallState(
    PDRVCALL    pCall,
    DWORD       dwExpectedCallInstance,
    DWORD       dwValidCurrentStates,
    DWORD       dwNewCallState,
    ULONG_PTR   dwNewCallStateMode,
    BOOL        bSendStateMsgToExe
    )
{
    LONG    lResult = 0;
    DWORD   dwActualCallInstance;


    EnterCriticalSection (&gESPGlobals.CallListCritSec);

    if (!IsValidDrvCall (pCall, &dwActualCallInstance)  ||
        dwActualCallInstance != dwExpectedCallInstance)
    {
        LeaveCriticalSection (&gESPGlobals.CallListCritSec);
        return LINEERR_INVALCALLHANDLE;
    }

    if (lResult == 0)
    {
        //
        // Check to see that the call is in a valid (expected) state.
        // If dwValidCurrentStates == 0xffffffff then we want to chg the
        // state regardless of the current state.
        //

        if ((dwValidCurrentStates != 0xffffffff) &&
            !(dwValidCurrentStates & pCall->dwCallState))
        {
            LeaveCriticalSection (&gESPGlobals.CallListCritSec);
            return LINEERR_INVALCALLSTATE;
        }


        //
        // Only chg the call state if it differs from the existing one
        //

        if (dwNewCallState != pCall->dwCallState)
        {
            pCall->dwCallState     = dwNewCallState;
            pCall->dwCallStateMode = (DWORD) dwNewCallStateMode;

            SendLineEvent(
                pCall->pLine,
                pCall,
                LINE_CALLSTATE,
                dwNewCallState,
                dwNewCallStateMode,
                pCall->dwMediaMode
                );

            if (bSendStateMsgToExe)
            {
                WriteEventBuffer(
                    ((PDRVLINE) pCall->pLine)->dwDeviceID,
                    WIDGETTYPE_CALL,
                    (ULONG_PTR) pCall,
                    (ULONG_PTR) pCall->htCall,
                    dwNewCallState,
                    pCall->dwAddressID
                    );
            }


            //
            // If this call has an associated call/endpoint then pass
            // connected (1st time only) or disconnected msgs to that
            // call so they know if we've answered or hung up
            //

            if (pCall->pDestCall)
            {
                if (dwNewCallState == LINECALLSTATE_CONNECTED)
                {
                    if (!pCall->bConnectedToDestCall)
                    {
                        if (IsValidDrvCall (pCall->pDestCall, NULL))
                        {
                            if (SetCallState(
                                    pCall->pDestCall,
                                    pCall->pDestCall->dwCallInstance,
                                    0xffffffff,
                                    LINECALLSTATE_CONNECTED,
                                    0,
                                    TRUE

                                    ) == 0)
                            {
                                // NOTE: use 0x55 to aid in debugging
                                //       wild writes

                                pCall->bConnectedToDestCall =
                                pCall->pDestCall->bConnectedToDestCall = 0x55;
                            }
                        }
                        else
                        {
                            pCall->pDestCall = NULL;
                        }
                    }
                }
                else if (dwNewCallState == LINECALLSTATE_IDLE ||
                         dwNewCallState == LINECALLSTATE_DISCONNECTED)
                {
                    pCall->pDestCall->pDestCall = NULL;

                    SetCallState(
                        pCall->pDestCall,
                        pCall->pDestCall->dwCallInstance,
                        0xffffffff,
                        LINECALLSTATE_DISCONNECTED,
                        (dwNewCallState == LINECALLSTATE_DISCONNECTED ?
                            dwNewCallStateMode : LINEDISCONNECTMODE_NORMAL),
                        TRUE
                        );

                    pCall->pDestCall = NULL;
                }
            }
        }
    }

    LeaveCriticalSection (&gESPGlobals.CallListCritSec);

    return lResult;
}


void
PASCAL
WriteEventBuffer(
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3,
    ULONG_PTR   Param4,
    ULONG_PTR   Param5,
    ULONG_PTR   Param6
    )
{
    WIDGETEVENT event ={ Param1, Param2, Param3, Param4, Param5, Param6 };


    if (gbDisableUI == TRUE)
    {
        return;
    }

    EnterCriticalSection (&gESPGlobals.EventBufferCritSec);

    if ((gESPGlobals.dwEventBufferUsedSize + sizeof (WIDGETEVENT)) >
            gESPGlobals.dwEventBufferTotalSize)
    {
        //
        // We've max'd out our ring buf, so try to grow it
        //

        char   *pNewEventBuffer;
        DWORD   dwMoveSize;


        if (!(pNewEventBuffer = DrvAlloc (
                2 * gESPGlobals.dwEventBufferTotalSize
                )))
        {
            LeaveCriticalSection (&gESPGlobals.EventBufferCritSec);

            // log some sort of error

            return;
        }

        dwMoveSize = (DWORD) (gESPGlobals.pEventBuffer +
            gESPGlobals.dwEventBufferTotalSize - gESPGlobals.pEventBufferOut);

        CopyMemory (pNewEventBuffer, gESPGlobals.pEventBufferOut, dwMoveSize);

        CopyMemory(
            pNewEventBuffer + dwMoveSize,
            gESPGlobals.pEventBuffer,
            gESPGlobals.pEventBufferOut - gESPGlobals.pEventBuffer
            );

        DrvFree (gESPGlobals.pEventBuffer);

        gESPGlobals.pEventBuffer    =
        gESPGlobals.pEventBufferOut = pNewEventBuffer;

        gESPGlobals.pEventBufferIn = pNewEventBuffer +
            gESPGlobals.dwEventBufferTotalSize;

        gESPGlobals.dwEventBufferTotalSize *= 2;
    }

    CopyMemory (gESPGlobals.pEventBufferIn, &event, sizeof (WIDGETEVENT));

    gESPGlobals.dwEventBufferUsedSize += sizeof (WIDGETEVENT);

    if ((gESPGlobals.pEventBufferIn +=  sizeof (WIDGETEVENT)) >=
            (gESPGlobals.pEventBuffer + gESPGlobals.dwEventBufferTotalSize))
    {
         gESPGlobals.pEventBufferIn = gESPGlobals.pEventBuffer;
    }

    SetEvent (ghWidgetEventsEvent);

    LeaveCriticalSection (&gESPGlobals.EventBufferCritSec);
}


LPVOID
DrvAlloc(
    size_t numBytes
    )
{
    LPVOID  p = HeapAlloc (ghESPHeap, HEAP_ZERO_MEMORY, numBytes);


    if (!p)
    {
        ShowStr (TRUE, "Error: DrvAlloc (x%x) failed", (DWORD) numBytes);
    }

    return p;
}


void
DrvFree(
    LPVOID  p
    )
{
    if (p)
    {
#if DBG
        //
        // Fill the buf to free with 0xa5's to facilitate debugging
        //

        FillMemory (p, HeapSize (ghESPHeap, 0, p), 0xa5);
#endif
        HeapFree (ghESPHeap, 0, p);
    }
}


PDRVADDRESS
PASCAL
FindFreeAddress(
    PDRVLINE    pLine
    )
{
    DWORD       i;
    PDRVADDRESS pAddr = pLine->aAddrs;


    for (i = 0; i < gESPGlobals.dwNumAddressesPerLine; i++)
    {
        if (pAddr->dwNumCalls < gESPGlobals.dwNumCallsPerAddress)
        {
            return pAddr;
        }

        pAddr++;
    }

    return NULL;
}


LONG
PASCAL
AllocCall(
    PDRVLINE            pLine,
    HTAPICALL           htCall,
    LPLINECALLPARAMS    pCallParams,
    PDRVCALL           *ppCall
    )
{
    LONG        lResult = 0;
    DWORD       i;
    PDRVCALL    pCall;
    PDRVADDRESS pAddr;


    if (!(pCall = (PDRVCALL) DrvAlloc (sizeof (DRVCALL))))
    {
        return LINEERR_NOMEM;
    }

    pCall->pLine = pLine;
    pCall->htCall = htCall;


    EnterCriticalSection (&gESPGlobals.CallListCritSec);

    if (!pCallParams)
    {
        if (!(pAddr = FindFreeAddress (pLine)))
        {
            lResult = LINEERR_CALLUNAVAIL;
            goto AllocCall_cleanup;
        }

        if (pLine->dwMediaModes)
        	pCall->dwMediaMode   = pLine->dwMediaModes;
        else
	        pCall->dwMediaMode   = LINEMEDIAMODE_INTERACTIVEVOICE;
        pCall->dwBearerMode  = LINEBEARERMODE_VOICE;
        pCall->dwAddressType = LINEADDRESSTYPE_PHONENUMBER;
    }
    else
    {

AllocCall_findTheAddr:

        if (pCallParams->dwAddressMode == LINEADDRESSMODE_ADDRESSID)
        {
            if (pCallParams->dwAddressID >= gESPGlobals.dwNumAddressesPerLine)
            {
                lResult = LINEERR_INVALADDRESSID;
                goto AllocCall_cleanup;
            }

            if (pCallParams->dwAddressID == 0)
            {
                //
                // App doesn't care which addr to make call on
                //

                if (!(pAddr = FindFreeAddress (pLine)))
                {
                    lResult = LINEERR_CALLUNAVAIL;
                    goto AllocCall_cleanup;
                }
            }
            else
            {
                //
                // App wants call on a particular addr
                //

                pAddr = pLine->aAddrs + pCallParams->dwAddressID;

                if (pAddr->dwNumCalls > gESPGlobals.dwNumCallsPerAddress)
                {
                    lResult = LINEERR_CALLUNAVAIL;
                    goto AllocCall_cleanup;
                }
            }
        }
        else // (pCallParams->dwAddressMode == LINEADDRESSMODE_DIALABLEADDR)
        {

// BUGBUG AllocCall: handle dialable addr

            pCallParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
            pCallParams->dwAddressID = 0;
            goto AllocCall_findTheAddr;
        }

        pCall->dwMediaMode  = pCallParams->dwMediaMode;
        pCall->dwBearerMode = pCallParams->dwBearerMode;

        if (gESPGlobals.dwSPIVersion >= 0x00020000)
        {
		// copy call data
       	 if (pCallParams->dwCallDataSize && (pCall->pCallData = DrvAlloc (pCallParams->dwCallDataSize)) )
	        {
       	     pCall->dwCallDataSize =  pCallParams->dwCallDataSize;
	            CopyMemory (pCall->pCallData, ((BYTE *)pCallParams) + pCallParams->dwCallDataOffset, pCallParams->dwCallDataSize);
       	 }
        }
        
        if (gESPGlobals.dwSPIVersion >= 0x00030000)
        {
            pCall->dwAddressType = pCallParams->dwAddressType;
        }
    }


    //
    // Call was successfully "made", so do all the common stuff like
    // adding it to the addr's list, setting the attributes, etc...
    //

    if ((pCall->pNext = pAddr->pCalls))
    {
        pCall->pNext->pPrev = pCall;
    }

    pAddr->pCalls = pCall;

    pAddr->dwNumCalls++;

    pCall->dwKey          = DRVCALL_KEY;
    pCall->pLine          = pLine;
    pCall->dwAddressID    = (DWORD) (pAddr - pLine->aAddrs);
    pCall->dwCallInstance = gdwCallInstance++;
    pCall->dwCallID       = (++gdwCallID ? gdwCallID : ++gdwCallID);

    pCall->dwRelatedCallID = 0;

AllocCall_cleanup:

    LeaveCriticalSection (&gESPGlobals.CallListCritSec);

    if (lResult == 0)
    {
        *ppCall = pCall;
    }
    else
    {
        DrvFree (pCall);
    }

    return lResult;
}


void
PASCAL
FreeCall(
    PDRVCALL    pCall,
    DWORD       dwExpectedCallInstance
    )
{
    DWORD   dwActualCallInstance;


    EnterCriticalSection (&gESPGlobals.CallListCritSec);

    if (IsValidDrvCall (pCall, &dwActualCallInstance)  &&
        dwActualCallInstance == dwExpectedCallInstance)
    {
        PDRVADDRESS pAddr;


        pCall->dwKey = INVAL_KEY;

        pAddr = ((PDRVLINE) pCall->pLine)->aAddrs + pCall->dwAddressID;
        if (pCall->pNext)
        {
            pCall->pNext->pPrev = pCall->pPrev;
        }

        if (pCall->pPrev)
        {
            pCall->pPrev->pNext = pCall->pNext;
        }
        else
        {
            pAddr->pCalls = pCall->pNext;
        }

        if (pCall->pDestCall)
        {
            pCall->pDestCall->pDestCall = NULL;

            SetCallState(
                pCall->pDestCall,
                pCall->pDestCall->dwCallInstance,
                0xffffffff,
                LINECALLSTATE_DISCONNECTED,
                LINEDISCONNECTMODE_NORMAL,
                TRUE
                );

            pCall->pDestCall = NULL;

        }

        pAddr->dwNumCalls--;
    }
    else
    {
        pCall = NULL;
    }

    LeaveCriticalSection (&gESPGlobals.CallListCritSec);

    if (pCall)
    {
        if (pCall->pSendingFlowspec)
        {
            DrvFree (pCall->pSendingFlowspec);
        }

        if (pCall->pReceivingFlowspec)
        {
            DrvFree (pCall->pReceivingFlowspec);
        }

        if (pCall->pCallData)
        {
            DrvFree (pCall->pCallData);
        }

        if (pCall->dwGatherDigitsEndToEndID)
        {
            (gESPGlobals.pfnLineEvent)(
                ((PDRVLINE) pCall->pLine)->htLine,
                pCall->htCall,
                LINE_GATHERDIGITS,
                LINEGATHERTERM_CANCEL,
                pCall->dwGatherDigitsEndToEndID,
                0
                );
        }

        if (pCall->dwGenerateDigitsEndToEndID)
        {
            (gESPGlobals.pfnLineEvent)(
                ((PDRVLINE) pCall->pLine)->htLine,
                pCall->htCall,
                LINE_GENERATE,
                LINEGENERATETERM_CANCEL,
                pCall->dwGenerateDigitsEndToEndID,
                0
                );
        }

        if (pCall->dwGenerateToneEndToEndID)
        {
            (gESPGlobals.pfnLineEvent)(
                ((PDRVLINE) pCall->pLine)->htLine,
                pCall->htCall,
                LINE_GENERATE,
                LINEGENERATETERM_CANCEL,
                pCall->dwGenerateToneEndToEndID,
                0
                );
        }

        if (pCall->dwMonitorToneListID)
        {
            (gESPGlobals.pfnLineEvent)(
                ((PDRVLINE) pCall->pLine)->htLine,
                pCall->htCall,
                LINE_MONITORTONE,
                0,
                pCall->dwMonitorToneListID,
                0
                );
        }

        DrvFree (pCall);
    }
}


PDRVLINE
PASCAL
GetLineFromID(
    DWORD   dwDeviceID
    )
{
    DWORD       i;
    PDRVLINE    pLine;


    if (dwDeviceID < gESPGlobals.dwLineDeviceIDBase)
    {
        pLine = (PDRVLINE) NULL;
    }
    else if (dwDeviceID < (gESPGlobals.dwLineDeviceIDBase +
                gESPGlobals.dwInitialNumLines))
    {
        pLine = (PDRVLINE) (((LPBYTE) gESPGlobals.pLines->aLines) +
            ((dwDeviceID - gESPGlobals.dwLineDeviceIDBase) * gdwDrvLineSize));
    }
    else
    {
        pLine = (PDRVLINE) (((LPBYTE) gESPGlobals.pLines->aLines) +
            (gESPGlobals.dwInitialNumLines * gdwDrvLineSize));

        for(
            i = gESPGlobals.dwInitialNumLines;
            i < gESPGlobals.pLines->dwNumUsedEntries;
            i++
            )
        {
            if (pLine->dwDeviceID == dwDeviceID)
            {
                return pLine;
            }

            pLine = (PDRVLINE) (((LPBYTE) pLine) + gdwDrvLineSize);
        }

        pLine = (PDRVLINE) NULL;
    }

    return pLine;
}


PDRVPHONE
PASCAL
GetPhoneFromID(
    DWORD   dwDeviceID
    )
{
    DWORD       i;
    PDRVPHONE   pPhone;


    if (dwDeviceID < gESPGlobals.dwPhoneDeviceIDBase)
    {
        pPhone = (PDRVPHONE) NULL;
    }
    else if (dwDeviceID < (gESPGlobals.dwPhoneDeviceIDBase +
                gESPGlobals.dwInitialNumPhones))
    {
        pPhone = gESPGlobals.pPhones->aPhones +
            (dwDeviceID - gESPGlobals.dwPhoneDeviceIDBase);
    }
    else
    {
        pPhone = gESPGlobals.pPhones->aPhones + gESPGlobals.dwInitialNumPhones;

        for(
            i = gESPGlobals.dwInitialNumPhones;
            i < gESPGlobals.pPhones->dwNumUsedEntries;
            i++, pPhone++
            )
        {
            if (pPhone->dwDeviceID == dwDeviceID)
            {
                return pPhone;
            }
        }

        pPhone = (PDRVPHONE) NULL;
    }

    return pPhone;
}


long
ESPAttach(
    long        lProcessID,
    ULONG_PTR  *phShutdownEvent,
    ULONG_PTR  *phDebugOutputEvent,
    ULONG_PTR  *phWidgetEventsEvent
    )
{
    HANDLE hMyProcess, hEspExeProcess;


    hMyProcess = GetCurrentProcess();

    hEspExeProcess = OpenProcess(
        PROCESS_DUP_HANDLE,
        TRUE,
        (DWORD) lProcessID
        );

    if (!DuplicateHandle(
            hMyProcess,
            ghDebugOutputEvent,
            hEspExeProcess,
            (HANDLE *) phDebugOutputEvent,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ||

        !DuplicateHandle(
            hMyProcess,
            ghShutdownEvent,
            hEspExeProcess,
            (HANDLE *) phShutdownEvent,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ) ||

        !DuplicateHandle(
            hMyProcess,
            ghWidgetEventsEvent,
            hEspExeProcess,
            (HANDLE *) phWidgetEventsEvent,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ))
    {
        DBGOUT((1, "ESPAttach: DupHandle failed, err=%d", GetLastError()));
        CloseHandle(hEspExeProcess); /* bug 49690 */
        return -1;
    }

    return 0;
}


void
ESPSetOptions(
    long    lDebugOptions,
    long    lCompletionMode
    )
{
    gESPGlobals.dwDebugOptions   = (DWORD) lDebugOptions;
    gESPGlobals.dwCompletionMode = (DWORD) lCompletionMode;

    if (!gbInteractWithDesktop)
    {
        gESPGlobals.dwDebugOptions &= ~MANUAL_RESULTS;
    }
}


void
ESPCompleteRequest(
    ULONG_PTR   lAsyncReqInfo,
    long        lResult
    )
{
    PASYNC_REQUEST_INFO pAsyncReqInfo = (PASYNC_REQUEST_INFO) lAsyncReqInfo;


    pAsyncReqInfo->lResult = lResult;

    if (pAsyncReqInfo->pfnPostProcessProc)
    {
        (*((POSTPROCESSPROC) pAsyncReqInfo->pfnPostProcessProc))(
            pAsyncReqInfo,
            ASYNC
            );
    }
    else
    {
        DoCompletion (pAsyncReqInfo, ASYNC);
    }

    DrvFree (pAsyncReqInfo);
}


long
ESPEvent(
    ULONG_PTR   htDevice,
    ULONG_PTR   htCall,
    ULONG_PTR   Msg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    switch (Msg)
    {
    case LINE_CALLSTATE:
    {
        DWORD   dwCallInst;

// BUGBUG when state == conf or prevState == conf need to add/rem conf list

        try
        {
            dwCallInst = ((PDRVCALL) htCall)->dwCallInstance;
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            break;
        }

        SetCallState(
            (PDRVCALL) htCall,
            dwCallInst,
            0xffffffff,
            (DWORD) Param1,
            (DWORD) Param2,
            TRUE
            );

        break;
    }
    case LINE_REMOVE:
        //
        //  Ignore invalid device ID
        //
        if (!GetLineFromID((DWORD)Param1))
            break;

    case LINE_ADDRESSSTATE:
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLDEVSPECIFICFEATURE:
    case LINE_CALLINFO:
    case LINE_CLOSE:
    case LINE_DEVSPECIFIC:
    case LINE_DEVSPECIFICFEATURE:
    case LINE_GATHERDIGITS:
    case LINE_GENERATE:
    case LINE_LINEDEVSTATE:
    case LINE_MONITORDIGITS:
    case LINE_MONITORMEDIA:
    case LINE_MONITORTONE:

        (*gESPGlobals.pfnLineEvent)(
            (HTAPILINE) htDevice,
            (HTAPICALL) htCall,
            (DWORD) Msg,
            Param1,
            Param2,
            Param3
            );

        ShowLineEvent(
            (HTAPILINE) htDevice,
            (HTAPICALL) htCall,
            (DWORD) Msg,
            Param1,
            Param2,
            Param3
            );

        break;

    case LINE_CREATEDIALOGINSTANCE:
    {
        TUISPICREATEDIALOGINSTANCEPARAMS createDlgParams;


        ZeroMemory(
            &createDlgParams,
            sizeof (TUISPICREATEDIALOGINSTANCEPARAMS)
            );

        createDlgParams.dwRequestID   = (DWORD) Param1;
        createDlgParams.hdDlgInst     = (HDRVDIALOGINSTANCE) 0x55;
        createDlgParams.lpszUIDLLName = szESPUIDLL;
        createDlgParams.lpParams      = "genDlg params";
        createDlgParams.dwSize        = 14;

        (*gESPGlobals.pfnLineEvent)(
            (HTAPILINE) gESPGlobals.hProvider,
            (HTAPICALL) NULL,
            LINE_CREATEDIALOGINSTANCE,
            (ULONG_PTR) &createDlgParams,
            0,
            0
            );

        ShowLineEvent(
            (HTAPILINE) gESPGlobals.hProvider,
            NULL,
            LINE_CREATEDIALOGINSTANCE,
            (ULONG_PTR) &createDlgParams,
            0,
            0
            );

            break;
    }
    case LINE_SENDDIALOGINSTANCEDATA:
    {
        char data[] = "dlgInstData";


        (*gESPGlobals.pfnLineEvent)(
            (HTAPILINE) Param1,
            (HTAPICALL) NULL,
            LINE_SENDDIALOGINSTANCEDATA,
            (ULONG_PTR) data,
            12,
            0
            );

        ShowLineEvent(
            (HTAPILINE) Param1,
            NULL,
            LINE_CREATEDIALOGINSTANCE,
            (ULONG_PTR) data,
            12,
            0
            );

            break;
    }
    case PHONE_BUTTON:
    case PHONE_CLOSE:
    case PHONE_DEVSPECIFIC:
    case PHONE_STATE:
    case PHONE_REMOVE:

        (*gESPGlobals.pfnPhoneEvent)(
            (HTAPIPHONE) htDevice,
            (DWORD) Msg,
            Param1,
            Param2,
            Param3
            );

        ShowPhoneEvent(
            (HTAPIPHONE) htDevice,
            (DWORD) Msg,
            Param1,
            Param2,
            Param3
            );

        break;

    case LINE_CREATE:

        if (gESPGlobals.pLines->dwNumUsedEntries <
                gESPGlobals.pLines->dwNumTotalEntries)
        {
            (*gESPGlobals.pfnLineEvent)(
                (HTAPILINE) NULL,
                (HTAPICALL) NULL,
                LINE_CREATE,
                (ULONG_PTR) gESPGlobals.hProvider,
                (ULONG_PTR) gESPGlobals.pLines->dwNumUsedEntries,
                (ULONG_PTR) 0
                );

            ShowLineEvent(
                (HTAPILINE) NULL,
                (HTAPICALL) NULL,
                LINE_CREATE,
                (ULONG_PTR) gESPGlobals.hProvider,
                gESPGlobals.pLines->dwNumUsedEntries++,
                (ULONG_PTR) 0
                );
        }
        else
        {
             ShowStr(
                 TRUE,
                 "ERROR: attempt to send LINE_CREATE - can't create " \
                     "any more devices on the fly"
                 );
        }

        break;

    case PHONE_CREATE:

        if (gESPGlobals.pPhones->dwNumUsedEntries <
                gESPGlobals.pPhones->dwNumTotalEntries)
        {
            (*gESPGlobals.pfnPhoneEvent)(
                (HTAPIPHONE) NULL,
                PHONE_CREATE,
                (ULONG_PTR) gESPGlobals.hProvider,
                (ULONG_PTR) gESPGlobals.pPhones->dwNumUsedEntries,
                (ULONG_PTR) 0
                );

            ShowPhoneEvent(
                (HTAPIPHONE) NULL,
                PHONE_CREATE,
                (ULONG_PTR) gESPGlobals.hProvider,
                gESPGlobals.pPhones->dwNumUsedEntries++,
                0
                );
        }
        else
        {
             ShowStr(
                 TRUE,
                 "ERROR: attempt to send PHONE_CREATE - can't create " \
                     "any more devices on the fly"
                 );
        }

        break;
    }

    return 0;
}


void
ESPGetDebugOutput(
    unsigned char  *pBuffer,
    long           *plSize
    )
{
    DWORD   dwTotalSize, dwMoveSize, dwMoveSizeWrapped;


    if (IsBadWritePtr (plSize, sizeof(long))  ||
        IsBadWritePtr (pBuffer, *plSize))
    {
        return;
    }

    EnterCriticalSection (&gESPGlobals.DebugBufferCritSec);

    dwMoveSize =
    dwTotalSize = ((DWORD) *plSize < gESPGlobals.dwDebugBufferUsedSize ?
        (DWORD)*plSize : gESPGlobals.dwDebugBufferUsedSize);

    if ((DWORD) (gESPGlobals.pDebugBuffer + gESPGlobals.dwDebugBufferTotalSize
            - gESPGlobals.pDebugBufferOut) > dwTotalSize)
    {
        dwMoveSizeWrapped = 0;
    }
    else
    {
        dwMoveSize = (DWORD) (gESPGlobals.pDebugBuffer +
            gESPGlobals.dwDebugBufferTotalSize - gESPGlobals.pDebugBufferOut);

        dwMoveSizeWrapped = dwTotalSize - dwMoveSize;
    }

    CopyMemory(
        pBuffer,
        gESPGlobals.pDebugBufferOut,
        dwMoveSize
        );

    if (dwMoveSizeWrapped)
    {
        CopyMemory(
            pBuffer + dwMoveSize,
            gESPGlobals.pDebugBuffer,
            dwMoveSizeWrapped
            );

        gESPGlobals.pDebugBufferOut = gESPGlobals.pDebugBuffer +
            dwMoveSizeWrapped;
    }
    else
    {
        gESPGlobals.pDebugBufferOut += dwTotalSize;
    }

    gESPGlobals.dwDebugBufferUsedSize -= dwTotalSize;

    LeaveCriticalSection (&gESPGlobals.DebugBufferCritSec);

    ResetEvent (ghDebugOutputEvent);

    *plSize = (long) dwTotalSize;
}


void
ESPGetWidgetEvents(
    unsigned char  *pBuffer,
    long           *plSize
    )
{
    DWORD   dwTotalSize, dwMoveSize, dwMoveSizeWrapped;


    if (IsBadWritePtr (plSize, sizeof(long))  ||
        IsBadWritePtr (pBuffer, *plSize))
    {
        return;
    }

    EnterCriticalSection (&gESPGlobals.EventBufferCritSec);

    dwMoveSize =
    dwTotalSize = ((DWORD) *plSize < gESPGlobals.dwEventBufferUsedSize ?
        (DWORD)*plSize : gESPGlobals.dwEventBufferUsedSize);

    if ((DWORD) (gESPGlobals.pEventBuffer + gESPGlobals.dwEventBufferTotalSize
            - gESPGlobals.pEventBufferOut) > dwTotalSize)
    {
        dwMoveSizeWrapped = 0;
    }
    else
    {
        dwMoveSize = (DWORD) (gESPGlobals.pEventBuffer +
            gESPGlobals.dwEventBufferTotalSize - gESPGlobals.pEventBufferOut);

        dwMoveSizeWrapped = dwTotalSize - dwMoveSize;
    }

    CopyMemory(
        pBuffer,
        gESPGlobals.pEventBufferOut,
        dwMoveSize
        );

    if (dwMoveSizeWrapped)
    {
        CopyMemory(
            pBuffer + dwMoveSize,
            gESPGlobals.pEventBuffer,
            dwMoveSizeWrapped
            );

        gESPGlobals.pEventBufferOut = gESPGlobals.pEventBuffer +
            dwMoveSizeWrapped;
    }
    else
    {
        gESPGlobals.pEventBufferOut += dwTotalSize;
    }

    gESPGlobals.dwEventBufferUsedSize -= dwTotalSize;

    LeaveCriticalSection (&gESPGlobals.EventBufferCritSec);

    ResetEvent (ghWidgetEventsEvent);

    *plSize = (long) dwTotalSize;
}


long
ESPStartPBXThread(
    unsigned char  *pBuffer,
    long            lSize
    )
{
    long   *pPBXSettings;
    DWORD   dwThreadID;

    if ((pPBXSettings = DrvAlloc (lSize)))
    {
        CopyMemory (pPBXSettings, pBuffer, lSize);

        gbExitPBXThread = FALSE;

        if ((ghPBXThread = CreateThread(
                (LPSECURITY_ATTRIBUTES) NULL,
                0,
                (LPTHREAD_START_ROUTINE) PBXThread,
                (LPVOID) pPBXSettings,
                0,
                &dwThreadID
                )))
        {
            return 0;
        }

        DrvFree (pPBXSettings);
    }

    return -1;
}


long
ESPStopPBXThread(
    long    lDummy
    )
{
    gbExitPBXThread = TRUE;

    WaitForSingleObject (ghPBXThread, INFINITE);

    CloseHandle (ghPBXThread);

    ghPBXThread = NULL;

    return 0;
}


void
__RPC_FAR *
__RPC_API
midl_user_allocate(
    size_t len
    )
{


    return (DrvAlloc (len));
}


void
__RPC_API
midl_user_free(
    void __RPC_FAR * ptr
    )
{
    DrvFree (ptr);
}


#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[128] = "ESP32: ";
        va_list ap;


        va_start(ap, lpszFormat);
        wvsprintf (&buf[7], lpszFormat, ap);
        lstrcatA (buf, "\n");
        OutputDebugStringA (buf);
        va_end(ap);
    }
}
#endif

BOOL
ScanForDWORD(
   char far    *pBuf,
   ULONG_PTR   *lpdw
   )
{
    char        c;
    BOOL        bValid = FALSE;
    ULONG_PTR   d = 0;


    while ((c = *pBuf))
    {
        if ((c >= '0') && (c <= '9'))
        {
            c -= '0';
        }
        else if ((c >= 'a') && (c <= 'f'))
        {
            c -= ('a' - 10);
        }
        else if ((c >= 'A') && (c <= 'F'))
        {
            c -= ('A' - 10);
        }
        else
        {
            break;
        }

        bValid = TRUE;

        d *= 16;

        d += (DWORD) c;

        pBuf++;
    }

    if (bValid)
    {
        *lpdw = d;
    }

    return bValid;
}


INT_PTR
CALLBACK
ValuesDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD   i;

    static  HWND                hwndCombo, hwndList1, hwndList2;
    static  LRESULT             lLastSel;
    static  char                szComboText[MAX_STRING_PARAM_SIZE];
    static  PEVENT_PARAM_HEADER pParamsHeader;


    switch (msg)
    {
    case WM_INITDIALOG:
    {
        hwndList1 = GetDlgItem (hwnd, IDC_LIST1);
        hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
        hwndCombo = GetDlgItem (hwnd, IDC_COMBO1);

        lLastSel = -1;
        pParamsHeader = (PEVENT_PARAM_HEADER) lParam;


        //
        // Limit the max text length for the combobox's edit field
        // (NOTE: A combobox ctrl actually has two child windows: a
        // edit ctrl & a listbox.  We need to get the hwnd of the
        // child edit ctrl & send it the LIMITTEXT msg.)
        //

        {
            HWND hwndChild = GetWindow (hwndCombo, GW_CHILD);


            while (hwndChild)
            {
                char buf[8];


                GetClassName (hwndChild, buf, 7);

                if (_stricmp (buf, "edit") == 0)
                {
                    break;
                }

                hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
            }

            SendMessage(
                hwndChild,
                EM_LIMITTEXT,
                (WPARAM) MAX_STRING_PARAM_SIZE - 1,
                0
                );
        }


        //
        // Misc other init
        //

        SetWindowText (hwnd, pParamsHeader->pszDlgTitle);

        for (i = 0; i < pParamsHeader->dwNumParams; i++)
        {
            SendMessage(
                hwndList1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) pParamsHeader->aParams[i].szName
                );
        }

        break;
    }
    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDOK:

            if (lLastSel != -1)
            {
                char buf[MAX_STRING_PARAM_SIZE];


                //
                // Save val of currently selected param
                //

                i = GetDlgItemText(
                    hwnd,
                    IDC_COMBO1,
                    buf,
                    MAX_STRING_PARAM_SIZE - 1
                    );

                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_STRING:
                {
                    LRESULT lComboSel;


                    lComboSel = SendMessage (hwndCombo, CB_GETCURSEL, 0, 0);

                    if (lComboSel == 0) // "NULL string (dwXxxSize = 0)"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }
                    else // "Valid string"
                    {
                        strncpy(
                            pParamsHeader->aParams[lLastSel].buf,
                            buf,
                            MAX_STRING_PARAM_SIZE - 1
                            );

                        pParamsHeader->aParams[lLastSel].buf[MAX_STRING_PARAM_SIZE-1] = 0;

                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            pParamsHeader->aParams[lLastSel].buf;
                    }

                    break;
                }
                case PT_DWORD:
                case PT_FLAGS:
                case PT_ORDINAL:
                {
                    if (!ScanForDWORD(
                            buf,
                            &pParamsHeader->aParams[lLastSel].dwValue
                            ))
                    {
                        //
                        // Default to 0
                        //

                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }

                    break;
                }
                } // switch
            }

            // Drop thru to IDCANCEL cleanup code

        case IDCANCEL:

            EndDialog (hwnd, (int)LOWORD(wParam));
            break;

        case IDC_LIST1:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                char    buf[MAX_STRING_PARAM_SIZE] = "";
                LPCSTR  lpstr = buf;
                LRESULT lSel = SendMessage (hwndList1, LB_GETCURSEL, 0, 0);


                if (lLastSel != -1)
                {
                    //
                    // Save the old param value
                    //

                    i = GetWindowText(
                        hwndCombo,
                        buf,
                        MAX_STRING_PARAM_SIZE - 1
                        );

                    switch (pParamsHeader->aParams[lLastSel].dwType)
                    {
                    case PT_STRING:
                    {
                        LRESULT lComboSel;


                        lComboSel = SendMessage (hwndCombo, CB_GETCURSEL, 0,0);

                        if (lComboSel == 0) // "NULL string (dwXxxSize = 0)"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }
                        else // "Valid string" or no sel
                        {
                            strncpy(
                                pParamsHeader->aParams[lLastSel].buf,
                                buf,
                                MAX_STRING_PARAM_SIZE - 1
                                );

                            pParamsHeader->aParams[lLastSel].buf
                                [MAX_STRING_PARAM_SIZE - 1] = 0;

                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR)
                                    pParamsHeader->aParams[lLastSel].buf;
                        }

                        break;
                    }
                    case PT_DWORD:
                    case PT_FLAGS:
                    case PT_ORDINAL:
                    {
                        if (!ScanForDWORD(
                                buf,
                                &pParamsHeader->aParams[lLastSel].dwValue
                                ))
                        {
                            //
                            // Default to 0
                            //

                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }

                        break;
                    }
                    } // switch
                }


                SendMessage (hwndList2, LB_RESETCONTENT, 0, 0);
                SendMessage (hwndCombo, CB_RESETCONTENT, 0, 0);

                switch (pParamsHeader->aParams[lSel].dwType)
                {
                case PT_STRING:
                {
                    char * aszOptions[] =
                    {
                        "NUL (dwXxxSize=0)",
                        "Valid string"
                    };


                    for (i = 0; i < 2; i++)
                    {
                        SendMessage(
                            hwndCombo,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) aszOptions[i]
                            );
                    }

                    if (pParamsHeader->aParams[lSel].dwValue == 0)
                    {
                        i = 0;
                        buf[0] = 0;
                    }
                    else
                    {
                        i = 1;
                        lpstr = (LPCSTR) pParamsHeader->aParams[lSel].dwValue;
                    }

                    SendMessage (hwndCombo, CB_SETCURSEL, (WPARAM) i, 0);

                    break;
                }
                case PT_DWORD:
                {
                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "0000000"
                        );

                    if (pParamsHeader->aParams[lSel].dwDefValue)
                    {
                        //
                        // Add the default val string to the combo
                        //

                        wsprintfA(
                            buf,
                            "%08lx",
                            pParamsHeader->aParams[lSel].dwDefValue
                            );

                        SendMessage(
                            hwndCombo,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) buf
                            );
                    }

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "ffffffff"
                        );

                    wsprintfA(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_ORDINAL:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue ==
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    wsprintfA(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_FLAGS:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    HWND hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue &
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    SendMessage(
                        hwndCombo,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select all"
                        );

                    wsprintfA(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                } //switch

                SetWindowText (hwndCombo, lpstr);

                lLastSel = lSel;
            }
            break;

        case IDC_LIST2:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                //
                // BUGBUG in the PT_ORDINAL case we should compare the
                // currently selected item(s) against the previous DWORD
                // val and figure out which item we need to deselect,
                // if any, in order to maintain a mutex of values
                //

                char        buf[16];
                LONG        i;
                int far    *ai;
                PLOOKUP     pLookup = (PLOOKUP)
                                pParamsHeader->aParams[lLastSel].pLookup;
                ULONG_PTR   dwValue = 0;
                LRESULT     lSelCount =
                                SendMessage (hwndList2, LB_GETSELCOUNT, 0, 0);


                ai = (int far *) DrvAlloc ((size_t)lSelCount * sizeof(int));

				// fix for bug 57371
                if (!ai) break;

                SendMessage(
                    hwndList2,
                    LB_GETSELITEMS,
                    (WPARAM) lSelCount,
                    (LPARAM) ai
                    );

                if (pParamsHeader->aParams[lLastSel].dwType == PT_FLAGS)
                {
                    for (i = 0; i < lSelCount; i++)
                    {
                        dwValue |= pLookup[ai[i]].dwVal;
                    }
                }
                else // if (.dwType == PT_ORDINAL)
                {
                    if (lSelCount == 1)
                    {
                        dwValue = pLookup[ai[0]].dwVal;
                    }
                    else if (lSelCount == 2)
                    {
                        //
                        // Figure out which item we need to de-select, since
                        // we're doing ordinals & only want 1 item selected
                        // at a time
                        //

                        GetWindowText (hwndCombo, buf, 16);

                        if (ScanForDWORD (buf, &dwValue))
                        {
                            if (pLookup[ai[0]].dwVal == dwValue)
                            {
                                SendMessage(
                                    hwndList2,
                                    LB_SETSEL,
                                    0,
                                    (LPARAM) ai[0]
                                    );

                                dwValue = pLookup[ai[1]].dwVal;
                            }
                            else
                            {
                                SendMessage(
                                    hwndList2,
                                    LB_SETSEL,
                                    0,
                                    (LPARAM) ai[1]
                                    );

                                dwValue = pLookup[ai[0]].dwVal;
                            }
                        }
                        else
                        {
                            // BUGBUG de-select items???

                            dwValue = 0;
                        }
                    }
                    else if (lSelCount > 2)
                    {
                        //
                        // Determine previous selection & de-select all the
                        // latest selections
                        //

                        GetDlgItemText (hwnd, IDC_COMBO1, buf, 16);

                        if (ScanForDWORD (buf, &dwValue))
                        {
                            for (i = 0; i < lSelCount; i++)
                            {
                                if (pLookup[ai[i]].dwVal != dwValue)
                                {
                                    SendMessage(
                                        hwndList2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[i]
                                        );
                                }
                            }
                        }
                        else
                        {
                            // BUGBUG de-select items???

                            dwValue = 0;
                        }
                    }
                }

                DrvFree (ai);
                wsprintfA (buf, "%08lx", dwValue);
                SetWindowText (hwndCombo, buf);
            }
            break;

        case IDC_COMBO1:

            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
            {
                LRESULT lSel =  SendMessage (hwndCombo, CB_GETCURSEL, 0, 0);


                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_ORDINAL:

                    //
                    // The only option here is "select none"
                    //

                    strcpy (szComboText, "00000000");
                    PostMessage (hwnd, WM_USER+55, 0, 0);
                    break;

                case PT_FLAGS:
                {
                    BOOL bSelect = (lSel ? TRUE : FALSE);

                    SendMessage(
                        hwndList2,
                        LB_SETSEL,
                        (WPARAM) bSelect,
                        (LPARAM) -1
                        );

                    if (bSelect)
                    {
                        PLOOKUP pLookup = (PLOOKUP)
                            pParamsHeader->aParams[lLastSel].pLookup;
                        DWORD dwValue = 0;
                        int far *ai;
                        LONG i;
                        LRESULT lSelCount =
                            SendMessage (hwndList2, LB_GETSELCOUNT, 0, 0);


                        ai = (int far *) DrvAlloc(
                            (size_t)lSelCount * sizeof(int)
                            );

                        SendMessage(
                            hwndList2,
                            LB_GETSELITEMS,
                            (WPARAM) lSelCount,
                            (LPARAM) ai
                            );

                        for (i = 0; i < lSelCount; i++)
                        {
                            dwValue |= pLookup[ai[i]].dwVal;
                        }

                        DrvFree (ai);
                        wsprintfA (szComboText, "%08lx", dwValue);

                    }
                    else
                    {
                        strcpy (szComboText, "00000000");
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;
                }
                case PT_STRING:

                    if (lSel == 1)
                    {
                        strncpy(
                            szComboText,
                            pParamsHeader->aParams[lLastSel].buf,
                            MAX_STRING_PARAM_SIZE
                            );

                        szComboText[MAX_STRING_PARAM_SIZE-1] = 0;
                    }
                    else
                    {
                        szComboText[0] = 0;
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;

                case PT_DWORD:

                    break;

                } // switch
                break;
            }
            case CBN_EDITCHANGE:
            {
                //
                // If user entered text in the edit field then copy the
                // text to our buffer
                //

                if (pParamsHeader->aParams[lLastSel].dwType == PT_STRING)
                {
                    char buf[MAX_STRING_PARAM_SIZE];


                    GetWindowText (hwndCombo, buf, MAX_STRING_PARAM_SIZE);

                    strncpy(
                        pParamsHeader->aParams[lLastSel].buf,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    pParamsHeader->aParams[lLastSel].buf
                        [MAX_STRING_PARAM_SIZE-1] = 0;
                }
                break;
            }
            } // switch

        } // switch

        break;
    }
    case WM_USER+55:

        SetWindowText (hwndCombo, szComboText);
        break;

    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return FALSE;
}


BOOL
PASCAL
IsValidESPAddress(
    LPCWSTR     lpszDestAddress,
    PDRVLINE   *ppLine,
    LPDWORD     pdwAddressID
    )
{
    char   *pszDestAddress, *p, c;
    BOOL    bResult = FALSE;
    DWORD   length, dwDestLineID, dwAddressID;


    if (!lpszDestAddress)
    {
        return FALSE;
    }


    //
    // Convert destination address from unicode to ascii
    //

    length = (lstrlenW (lpszDestAddress) + 1) * sizeof (WCHAR);

    if (!(pszDestAddress = DrvAlloc (length)))
    {
        return FALSE;
    }

    WideCharToMultiByte(
        CP_ACP,
        0,
        lpszDestAddress,
        -1,
        pszDestAddress,
        length,
        NULL,
        NULL
        );

    p = pszDestAddress;


    //
    // Skip valid junk we don't care about
    //

    while ((*p == 'T' || *p == 'P' || *p == ' ') && (*p != '\0'))
    {
       p++;
    }

    //
    // See if destination address is in the format of either
    // "<esp line id>" or "<esp line id>#<esp address id>"
    //
    if (*p < '0'  ||  *p > '9')
    {
        goto ISESPAddress_freeAddr;
    }

    for (dwDestLineID = 0; (c = *p); p++)
    {
        if (c >= '0' && c <= '9')
        {
            dwDestLineID *= 10;
            dwDestLineID += ((DWORD)(c - '0'));
        }
        else
        {
            break;
        }
    }

    if (c != '\0'  &&  c != '#')
    {
        goto ISESPAddress_freeAddr;
    }

    if (dwDestLineID < gESPGlobals.dwLineDeviceIDBase ||
        dwDestLineID >= (gESPGlobals.dwNumLines +
            gESPGlobals.dwLineDeviceIDBase))
    {
        goto ISESPAddress_freeAddr;
    }

    if (c == '\0')
    {
        *pdwAddressID = 0;
        goto ISESPAddress_success;
    }

    p++;

    if (*p < '0'  ||  *p > '9')
    {
        goto ISESPAddress_freeAddr;
    }

    for (dwAddressID = 0; (c = *p); p++)
    {
        if (c >= '0' && c <= '9')
        {
            dwAddressID *= 10;
            dwAddressID += ((DWORD)(c - '0'));
        }
        else
        {
            break;
        }
    }

    if (c != '\0'  ||  dwAddressID >= gESPGlobals.dwNumAddressesPerLine)
    {
        goto ISESPAddress_freeAddr;
    }

    *pdwAddressID = dwAddressID;

ISESPAddress_success:

    *ppLine = GetLineFromID (dwDestLineID);
    bResult = TRUE;

ISESPAddress_freeAddr:

    DrvFree (pszDestAddress);
    return bResult;
}


LONG
PASCAL
CreateIncomingCall(
    LPCWSTR             lpszDestAddress,
    LPLINECALLPARAMS    lpCallParams,
    PDRVCALL            pOutgoingCall,
    BOOL               *pbValidESPAddress,
    PDRVLINE           *ppIncomingLine,
    PDRVCALL           *ppIncomingCall
    )
{
    LONG                lResult;
    DWORD               dwIncomingAddressID;
    PDRVCALL            pIncomingCall;
    PDRVLINE            pIncomingLine;
    LINECALLPARAMS      callParams;


    *pbValidESPAddress = FALSE;
    *ppIncomingLine = NULL;
    *ppIncomingCall = NULL;

    if (!IsValidESPAddress(
            lpszDestAddress,
            &pIncomingLine,
            &dwIncomingAddressID
            ))
    {
        return LINEERR_INVALADDRESS;
    }

    *pbValidESPAddress = TRUE;

    if (pIncomingLine->htLine == NULL ||
        (pOutgoingCall &&
        !(pIncomingLine->dwMediaModes & pOutgoingCall->dwMediaMode)))
    {
        return LINEERR_INVALMEDIAMODE;
    }

    if (!lpCallParams)
    {
        lpCallParams = &callParams;

        ZeroMemory (&callParams, sizeof (LINECALLPARAMS));

        callParams.dwTotalSize = sizeof (LINECALLPARAMS);
        if (pIncomingLine->dwMediaModes)
	       callParams.dwMediaMode = pIncomingLine->dwMediaModes;
        else
       	callParams.dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
        callParams.dwBearerMode = LINEBEARERMODE_VOICE;
    }

    lpCallParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    lpCallParams->dwAddressID = dwIncomingAddressID;

    if ((lResult = AllocCall(
            pIncomingLine,
            0,
            lpCallParams,
            &pIncomingCall

            )) == 0)
    {
        if (pOutgoingCall)
        {
            pOutgoingCall->pDestCall = pIncomingCall;
            pIncomingCall->pDestCall = pOutgoingCall;

            pIncomingCall->dwCallID = pOutgoingCall->dwCallID;
            pIncomingCall->dwRelatedCallID = pOutgoingCall->dwRelatedCallID;
        }

        *ppIncomingLine = pIncomingLine;
        *ppIncomingCall = pIncomingCall;
    }
    else
    {
        ShowStr(
             TRUE,
             "lineMakeCall couldn't create incoming call on" \
                 "line/addr id %d/%d, exceeded max calls per line/addr",
             pIncomingLine->dwDeviceID,
             dwIncomingAddressID
             );
    }

    return lResult;
}


void
FAR
PASCAL
TransferCall_postProcess(
    PASYNC_REQUEST_INFO pAsyncReqInfo,
    BOOL                bAsync
    )
{
    DWORD       dwCallInstThen = (DWORD) pAsyncReqInfo->dwParam2,
                dwValidCurrentCallStates = (DWORD) pAsyncReqInfo->dwParam5,
                dwNewCallState = (DWORD) pAsyncReqInfo->dwParam6,
                dwCallInstNow;
    PDRVCALL    pCall = (PDRVCALL) pAsyncReqInfo->dwParam1,
                pDestCall = (PDRVCALL) pAsyncReqInfo->dwParam4;
    PDRVLINE    pDestLine = (PDRVLINE) pAsyncReqInfo->dwParam3;


    DoCompletion (pAsyncReqInfo, bAsync);

    if (pAsyncReqInfo->lResult == 0)
    {
        if ((pAsyncReqInfo->lResult = SetCallState(
                pCall,
                dwCallInstThen,
                dwValidCurrentCallStates,
                LINECALLSTATE_IDLE,
                0,
                TRUE

                )) != 0)
        {
            goto TSPI_lineBlindTransfer_postProcess_freeDestCall;
        }

        if (pDestCall)
        {
            EnterCriticalSection (&gESPGlobals.CallListCritSec);

            if (IsValidDrvCall (pCall, &dwCallInstNow) &&
                dwCallInstNow == dwCallInstThen)
            {
                SendLineEvent(
                    pDestLine,
                    NULL,
                    LINE_NEWCALL,
                    (ULONG_PTR) pDestCall,
                    (ULONG_PTR) &pDestCall->htCall,
                    0
                    );

                if (pDestCall->htCall)
                {
                    SetCallState(
                        pDestCall,
                        pDestCall->dwCallInstance,
                        0xffffffff,
                        dwNewCallState,
                        0,
                        TRUE
                        );
                }
                else
                {
                    FreeCall (pDestCall, pDestCall->dwCallInstance);
                }
            }
            else
            {
                FreeCall (pDestCall, pDestCall->dwCallInstance);
            }

            LeaveCriticalSection (&gESPGlobals.CallListCritSec);
        }

    }
    else
    {

TSPI_lineBlindTransfer_postProcess_freeDestCall:

        if (pDestCall)
        {
            FreeCall (pDestCall, pDestCall->dwCallInstance);
        }
    }
}




LONG
PASCAL
TransferCall(
    PFUNC_INFO  pInfo,
    PDRVCALL    pCall,
    DWORD       dwValidCurrentCallStates,
    DWORD       dwNewCallState, // initial call state of new incoming call
    LPCWSTR     lpszDestAddress
    )
{
    BOOL        bValidESPAddress;
    LONG        lResult = 0;
    PDRVLINE    pDestLine;
    PDRVCALL    pDestCall;


    EnterCriticalSection (&gESPGlobals.CallListCritSec);

    if (IsValidDrvCall (pCall, NULL) == FALSE)
    {
        lResult = LINEERR_INVALCALLHANDLE;
    }
    else if ((pCall->dwCallState & dwValidCurrentCallStates) == 0)
    {
        lResult = LINEERR_INVALCALLSTATE;
    }
    else
    {
        PDRVCALL        pDestCallOrig = pCall->pDestCall;
        LINECALLPARAMS  callParams;


        if (IsValidDrvCall (pDestCallOrig, NULL) == FALSE)
        {
            pDestCallOrig = NULL;
        }

        ZeroMemory (&callParams, sizeof (LINECALLPARAMS));

        callParams.dwTotalSize  = sizeof (LINECALLPARAMS);
        callParams.dwMediaMode  = pCall->dwMediaMode;
        callParams.dwBearerMode = pCall->dwBearerMode;
        callParams.dwMinRate    = pCall->dwMinRate;
        callParams.dwMaxRate    = pCall->dwMaxRate;

        if (CreateIncomingCall(
                lpszDestAddress,
                &callParams,
                pDestCallOrig,
                &bValidESPAddress,
                &pDestLine,
                &pDestCall

                ) == 0)
        {
            pCall->pDestCall           = NULL;

            if (pCall->dwCallDataSize  &&
                (pDestCall->pCallData = DrvAlloc (pCall->dwCallDataSize)))
            {
                CopyMemory(
                    pDestCall->pCallData,
                    pCall->pCallData,
                    (pDestCall->dwCallDataSize = pCall->dwCallDataSize)
                    );
            }
        }

        pInfo->pAsyncReqInfo->pfnPostProcessProc = (FARPROC)
            TransferCall_postProcess;

        pInfo->pAsyncReqInfo->dwParam1 = (ULONG_PTR) pCall;
        pInfo->pAsyncReqInfo->dwParam2 = (ULONG_PTR) pCall->dwCallInstance;
        pInfo->pAsyncReqInfo->dwParam3 = (ULONG_PTR) pDestLine;
        pInfo->pAsyncReqInfo->dwParam4 = (ULONG_PTR) pDestCall;
        pInfo->pAsyncReqInfo->dwParam5 = (ULONG_PTR) dwValidCurrentCallStates;
        pInfo->pAsyncReqInfo->dwParam6 = (ULONG_PTR) dwNewCallState;
    }

    LeaveCriticalSection (&gESPGlobals.CallListCritSec);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\espidl_s_stub.c ===
#include "espidl_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\intrface.h ===
#define SHOW_FUNC_ENTRY                         0x00000001
#define SHOW_PARAMETERS                         0x00000002
#define SHOW_FUNC_EXIT                          0x00000004
#define SHOW_EVENT_NOTIFICATIONS                0x00000008
#define SHOW_COMPLETION_NOTIFICATIONS           0x00000010
#define MANUAL_RESULTS                          0x00000020

#define DEF_DEBUG_OPTIONS                       SHOW_FUNC_ENTRY

#define COMPLETE_ASYNC_EVENTS_SYNCHRONOUSLY     0L
#define COMPLETE_ASYNC_EVENTS_ASYNCHRONOUSLY    1L
#define COMPLETE_ASYNC_EVENTS_SYNC_AND_ASYNC    2L
#define COMPLETE_ASYNC_EVENTS_MANUALLY          3L

#define DEF_COMPLETION_MODE                     2L

#define DEF_NUM_LINES                           3
#define DEF_NUM_ADDRS_PER_LINE                  2
#define DEF_NUM_CALLS_PER_ADDR                  1
#define DEF_NUM_PHONES                          2
#define DEF_SPI_VERSION                         0x20000

#define WIDGETTYPE_LINE                         0L
#define WIDGETTYPE_CALL                         1L
#define WIDGETTYPE_PHONE                        2L
#define WIDGETTYPE_ASYNCREQUEST                 3L
#define WIDGETTYPE_STARTUP                      4L

typedef struct _WIDGETEVENT
{
    ULONG_PTR               dwWidgetID;

    ULONG_PTR               dwWidgetType;       // WIDGETYPE_*

    union
    {
        ULONG_PTR           hdXxx;              // hdXxx (NULL for AsyncReq)

        ULONG_PTR           dwNumLines;

        ULONG_PTR           pAsyncReqInfo;
    };

    union
    {
        ULONG_PTR           htXxx;             // htXxx (NULL for AsyncReq)

        ULONG_PTR           dwNumPhones;
    };

    union
    {
        ULONG_PTR           dwCallState;

        ULONG_PTR           dwRequestType;      // func ord for lookup

        ULONG_PTR           dwLineDeviceIDBase;
    };

    union
    {
        ULONG_PTR           dwCallAddressID;

        ULONG_PTR           dwPhoneDeviceIDBase;
    };

} WIDGETEVENT, *PWIDGETEVENT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\vars.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    vars.h

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    18-Sep-1995

Revision History:


Notes:

--*/


extern char         szTab[];
extern char         szdwSize[];
extern char         szhdLine[];
extern char         szCallUp[];
extern char         szEspTsp[];
extern char         szhdCall[];
extern char         szhdPhone[];
extern char         szProvider[];
extern WCHAR        szESPUIDLL[];
extern char         szhwndOwner[];
extern char         szMySection[];
extern char         szProviders[];
extern char         szdwDeviceID[];
extern char         szProviderID[];
extern char         szdwRequestID[];
extern char         szTelephonIni[];
extern char         szlpCallParams[];
extern char         szNumProviders[];
extern char         szNextProviderID[];
extern char         szProviderFilename[];
extern char         szdwPermanentProviderID[];

#if DBG
extern DWORD        gdwDebugLevel;
#endif

extern HANDLE       ghInstance;
extern HANDLE       ghDebugOutputEvent;
extern HANDLE       ghShutdownEvent;
extern HANDLE       ghWidgetEventsEvent;

extern LOOKUP       aAddressStates[];
extern LOOKUP       aBearerModes[];
extern LOOKUP       aButtonModes[];
extern LOOKUP       aButtonStates[];
extern LOOKUP       aCallInfoStates[];
extern LOOKUP       aCallSelects[];
extern LOOKUP       aCallStates[];
extern LOOKUP       aDigitModes[];
extern LOOKUP       aHookSwitchDevs[];
extern LOOKUP       aHookSwitchModes[];
extern LOOKUP       aLampModes[];
extern LOOKUP       aLineStates[];
extern LOOKUP       aMediaModes[];
extern LOOKUP       aPhoneStates[];
extern LOOKUP       aTerminalModes[];
extern LOOKUP       aToneModes[];
extern LOOKUP       aTransferModes[];
extern LOOKUP       aLineErrs[];
extern LOOKUP       aPhoneErrs[];

extern ESPGLOBALS   gESPGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\tsp\vars.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    vars.c

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    18-Sep-1995

Revision History:


Notes:

--*/


#include "esp.h"


char        szTab[]          = "    ";
char        szhdLine[]       = "hdLine";
char        szhdCall[]       = "hdCall";
char        szdwSize[]       = "dwSize";
char        szCallUp[]       = "^^^^";
char        szEspTsp[]       = "esp.tsp";
char        szhdPhone[]      = "hdPhone";
char        szProvider[]     = "Provider";
WCHAR       szESPUIDLL[]     = L"espui.dll";
char        szhwndOwner[]    = "hwndOwner";
char        szMySection[]    = "ESP32";
char        szProviders[]    = "Providers";
char        szProviderID[]   = "ProviderID";
char        szdwDeviceID[]   = "dwDeviceID";
char        szdwRequestID[]  = "dwRequestID";
char        szTelephonIni[]  = "telephon.ini";
char        szlpCallParams[] = "lpCallParams";
char        szNumProviders[] = "NumProviders";
char        szNextProviderID[] = "NextProviderID";
char        szProviderFilename[] = "ProviderFileName";
char        szdwPermanentProviderID[] = "dwPermanentProviderID";

#if DBG
DWORD       gdwDebugLevel;
#endif

HANDLE      ghInstance;
HANDLE      ghDebugOutputEvent;
HANDLE      ghShutdownEvent;
HANDLE      ghWidgetEventsEvent;

ESPGLOBALS  gESPGlobals;

LOOKUP  aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER           ,"OTHER"              },
    { LINEADDRESSSTATE_DEVSPECIFIC     ,"DEVSPECIFIC"        },
    { LINEADDRESSSTATE_INUSEZERO       ,"INUSEZERO"          },
    { LINEADDRESSSTATE_INUSEONE        ,"INUSEONE"           },
    { LINEADDRESSSTATE_INUSEMANY       ,"INUSEMANY"          },
    { LINEADDRESSSTATE_NUMCALLS        ,"NUMCALLS"           },
    { LINEADDRESSSTATE_FORWARD         ,"FORWARD"            },
    { LINEADDRESSSTATE_TERMINALS       ,"TERMINALS"          },
    { LINEADDRESSSTATE_CAPSCHANGE      ,"CAPSCHANGE"         },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aBearerModes[] =
{
    { LINEBEARERMODE_VOICE             ,"VOICE"              },
    { LINEBEARERMODE_SPEECH            ,"SPEECH"             },
    { LINEBEARERMODE_MULTIUSE          ,"MULTIUSE"           },
    { LINEBEARERMODE_DATA              ,"DATA"               },
    { LINEBEARERMODE_ALTSPEECHDATA     ,"ALTSPEECHDATA"      },
    { LINEBEARERMODE_NONCALLSIGNALING  ,"NONCALLSIGNALING"   },
    { LINEBEARERMODE_PASSTHROUGH       ,"PASSTHROUGH"        },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY            ,"DUMMY"              },
    { PHONEBUTTONMODE_CALL             ,"CALL"               },
    { PHONEBUTTONMODE_FEATURE          ,"FEATURE"            },
    { PHONEBUTTONMODE_KEYPAD           ,"KEYPAD"             },
    { PHONEBUTTONMODE_LOCAL            ,"LOCAL"              },
    { PHONEBUTTONMODE_DISPLAY          ,"DISPLAY"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP              ,"UP"                 },
    { PHONEBUTTONSTATE_DOWN            ,"DOWN"               },
    { PHONEBUTTONSTATE_UNKNOWN         ,"UNKNOWN"            },
    { PHONEBUTTONSTATE_UNAVAIL         ,"UNAVAIL"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER          ,"OTHER"              },
    { LINECALLINFOSTATE_DEVSPECIFIC    ,"DEVSPECIFIC"        },
    { LINECALLINFOSTATE_BEARERMODE     ,"BEARERMODE"         },
    { LINECALLINFOSTATE_RATE           ,"RATE"               },
    { LINECALLINFOSTATE_MEDIAMODE      ,"MEDIAMODE"          },
    { LINECALLINFOSTATE_APPSPECIFIC    ,"APPSPECIFIC"        },
    { LINECALLINFOSTATE_CALLID         ,"CALLID"             },
    { LINECALLINFOSTATE_RELATEDCALLID  ,"RELATEDCALLID"      },
    { LINECALLINFOSTATE_ORIGIN         ,"ORIGIN"             },
    { LINECALLINFOSTATE_REASON         ,"REASON"             },
    { LINECALLINFOSTATE_COMPLETIONID   ,"COMPLETIONID"       },
    { LINECALLINFOSTATE_NUMOWNERINCR   ,"NUMOWNERINCR"       },
    { LINECALLINFOSTATE_NUMOWNERDECR   ,"NUMOWNERDECR"       },
    { LINECALLINFOSTATE_NUMMONITORS    ,"NUMMONITORS"        },
    { LINECALLINFOSTATE_TRUNK          ,"TRUNK"              },
    { LINECALLINFOSTATE_CALLERID       ,"CALLERID"           },
    { LINECALLINFOSTATE_CALLEDID       ,"CALLEDID"           },
    { LINECALLINFOSTATE_CONNECTEDID    ,"CONNECTEDID"        },
    { LINECALLINFOSTATE_REDIRECTIONID  ,"REDIRECTIONID"      },
    { LINECALLINFOSTATE_REDIRECTINGID  ,"REDIRECTINGID"      },
    { LINECALLINFOSTATE_DISPLAY        ,"DISPLAY"            },
    { LINECALLINFOSTATE_USERUSERINFO   ,"USERUSERINFO"       },
    { LINECALLINFOSTATE_HIGHLEVELCOMP  ,"HIGHLEVELCOMP"      },
    { LINECALLINFOSTATE_LOWLEVELCOMP   ,"LOWLEVELCOMP"       },
    { LINECALLINFOSTATE_CHARGINGINFO   ,"CHARGINGINFO"       },
    { LINECALLINFOSTATE_TERMINAL       ,"TERMINAL"           },
    { LINECALLINFOSTATE_DIALPARAMS     ,"DIALPARAMS"         },
    { LINECALLINFOSTATE_MONITORMODES   ,"MONITORMODES"       },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aCallSelects[] =
{
    { LINECALLSELECT_LINE              ,"LINE"               },
    { LINECALLSELECT_ADDRESS           ,"ADDRESS"            },
    { LINECALLSELECT_CALL              ,"CALL"               },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aCallStates[] =
{
    { LINECALLSTATE_IDLE               ,"IDLE"               },
    { LINECALLSTATE_OFFERING           ,"OFFERING"           },
    { LINECALLSTATE_ACCEPTED           ,"ACCEPTED"           },
    { LINECALLSTATE_DIALTONE           ,"DIALTONE"           },
    { LINECALLSTATE_DIALING            ,"DIALING"            },
    { LINECALLSTATE_RINGBACK           ,"RINGBACK"           },
    { LINECALLSTATE_BUSY               ,"BUSY"               },
    { LINECALLSTATE_SPECIALINFO        ,"SPECIALINFO"        },
    { LINECALLSTATE_CONNECTED          ,"CONNECTED"          },
    { LINECALLSTATE_PROCEEDING         ,"PROCEEDING"         },
    { LINECALLSTATE_ONHOLD             ,"ONHOLD"             },
    { LINECALLSTATE_CONFERENCED        ,"CONFERENCED"        },
    { LINECALLSTATE_ONHOLDPENDCONF     ,"ONHOLDPENDCONF"     },
    { LINECALLSTATE_ONHOLDPENDTRANSFER ,"ONHOLDPENDTRANSFER" },
    { LINECALLSTATE_DISCONNECTED       ,"DISCONNECTED"       },
    { LINECALLSTATE_UNKNOWN            ,"UNKNOWN"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aDigitModes[] =
{
    { LINEDIGITMODE_PULSE              ,"PULSE"              },
    { LINEDIGITMODE_DTMF               ,"DTMF"               },
    { LINEDIGITMODE_DTMFEND            ,"DTMFEND"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET       ,"HANDSET"            },
    { PHONEHOOKSWITCHDEV_SPEAKER       ,"SPEAKER"            },
    { PHONEHOOKSWITCHDEV_HEADSET       ,"HEADSET"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK       ,"ONHOOK"             },
    { PHONEHOOKSWITCHMODE_MIC          ,"MIC"                },
    { PHONEHOOKSWITCHMODE_SPEAKER      ,"SPEAKER"            },
    { PHONEHOOKSWITCHMODE_MICSPEAKER   ,"MICSPEAKER"         },
    { PHONEHOOKSWITCHMODE_UNKNOWN      ,"UNKNOWN"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aLampModes[] =
{
    { PHONELAMPMODE_DUMMY              ,"DUMMY"              },
    { PHONELAMPMODE_OFF                ,"OFF"                },
    { PHONELAMPMODE_STEADY             ,"STEADY"             },
    { PHONELAMPMODE_WINK               ,"WINK"               },
    { PHONELAMPMODE_FLASH              ,"FLASH"              },
    { PHONELAMPMODE_FLUTTER            ,"FLUTTER"            },
    { PHONELAMPMODE_BROKENFLUTTER      ,"BROKENFLUTTER"      },
    { PHONELAMPMODE_UNKNOWN            ,"UNKNOWN"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aLineStates[] =
{
    { LINEDEVSTATE_OTHER               ,"OTHER"              },
    { LINEDEVSTATE_RINGING             ,"RINGING"            },
    { LINEDEVSTATE_CONNECTED           ,"CONNECTED"          },
    { LINEDEVSTATE_DISCONNECTED        ,"DISCONNECTED"       },
    { LINEDEVSTATE_MSGWAITON           ,"MSGWAITON"          },
    { LINEDEVSTATE_MSGWAITOFF          ,"MSGWAITOFF"         },
    { LINEDEVSTATE_INSERVICE           ,"INSERVICE"          },
    { LINEDEVSTATE_OUTOFSERVICE        ,"OUTOFSERVICE"       },
    { LINEDEVSTATE_MAINTENANCE         ,"MAINTENANCE"        },
    { LINEDEVSTATE_OPEN                ,"OPEN"               },
    { LINEDEVSTATE_CLOSE               ,"CLOSE"              },
    { LINEDEVSTATE_NUMCALLS            ,"NUMCALLS"           },
    { LINEDEVSTATE_NUMCOMPLETIONS      ,"NUMCOMPLETIONS"     },
    { LINEDEVSTATE_TERMINALS           ,"TERMINALS"          },
    { LINEDEVSTATE_ROAMMODE            ,"ROAMMODE"           },
    { LINEDEVSTATE_BATTERY             ,"BATTERY"            },
    { LINEDEVSTATE_SIGNAL              ,"SIGNAL"             },
    { LINEDEVSTATE_DEVSPECIFIC         ,"DEVSPECIFIC"        },
    { LINEDEVSTATE_REINIT              ,"REINIT"             },
    { LINEDEVSTATE_LOCK                ,"LOCK"               },
    { LINEDEVSTATE_CAPSCHANGE          ,"CAPSCHANGE"         },
    { LINEDEVSTATE_CONFIGCHANGE        ,"CONFIGCHANGE"       },
    { LINEDEVSTATE_TRANSLATECHANGE     ,"TRANSLATECHANGE"    },
    { LINEDEVSTATE_COMPLCANCEL         ,"COMPLCANCEL"        },
    { LINEDEVSTATE_REMOVED             ,"REMOVED"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN            ,"UNKNOWN"            },
    { LINEMEDIAMODE_INTERACTIVEVOICE   ,"INTERACTIVEVOICE"   },
    { LINEMEDIAMODE_AUTOMATEDVOICE     ,"AUTOMATEDVOICE"     },
    { LINEMEDIAMODE_DATAMODEM          ,"DATAMODEM"          },
    { LINEMEDIAMODE_G3FAX              ,"G3FAX"              },
    { LINEMEDIAMODE_TDD                ,"TDD"                },
    { LINEMEDIAMODE_G4FAX              ,"G4FAX"              },
    { LINEMEDIAMODE_DIGITALDATA        ,"DIGITALDATA"        },
    { LINEMEDIAMODE_TELETEX            ,"TELETEX"            },
    { LINEMEDIAMODE_VIDEOTEX           ,"VIDEOTEX"           },
    { LINEMEDIAMODE_TELEX              ,"TELEX"              },
    { LINEMEDIAMODE_MIXED              ,"MIXED"              },
    { LINEMEDIAMODE_ADSI               ,"ADSI"               },
    { LINEMEDIAMODE_VOICEVIEW          ,"VOICEVIEW"          },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aPhoneStates[] =
{
    { PHONESTATE_OTHER                 ,"OTHER"              },
    { PHONESTATE_CONNECTED             ,"CONNECTED"          },
    { PHONESTATE_DISCONNECTED          ,"DISCONNECTED"       },
    { PHONESTATE_OWNER                 ,"OWNER"              },
    { PHONESTATE_MONITORS              ,"MONITORS"           },
    { PHONESTATE_DISPLAY               ,"DISPLAY"            },
    { PHONESTATE_LAMP                  ,"LAMP"               },
    { PHONESTATE_RINGMODE              ,"RINGMODE"           },
    { PHONESTATE_RINGVOLUME            ,"RINGVOLUME"         },
    { PHONESTATE_HANDSETHOOKSWITCH     ,"HANDSETHOOKSWITCH"  },
    { PHONESTATE_HANDSETVOLUME         ,"HANDSETVOLUME"      },
    { PHONESTATE_HANDSETGAIN           ,"HANDSETGAIN"        },
    { PHONESTATE_SPEAKERHOOKSWITCH     ,"SPEAKERHOOKSWITCH"  },
    { PHONESTATE_SPEAKERVOLUME         ,"SPEAKERVOLUME"      },
    { PHONESTATE_SPEAKERGAIN           ,"SPEAKERGAIN"        },
    { PHONESTATE_HEADSETHOOKSWITCH     ,"HEADSETHOOKSWITCH"  },
    { PHONESTATE_HEADSETVOLUME         ,"HEADSETVOLUME"      },
    { PHONESTATE_HEADSETGAIN           ,"HEADSETGAIN"        },
    { PHONESTATE_SUSPEND               ,"SUSPEND"            },
    { PHONESTATE_RESUME                ,"RESUME"             },
    { PHONESTATE_DEVSPECIFIC           ,"DEVSPECIFIC"        },
    { PHONESTATE_REINIT                ,"REINIT"             },
    { PHONESTATE_CAPSCHANGE            ,"CAPSCHANGE"         },
    { PHONESTATE_REMOVED               ,"REMOVED"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS             ,"BUTTONS"            },
    { LINETERMMODE_LAMPS               ,"LAMPS"              },
    { LINETERMMODE_DISPLAY             ,"DISPLAY"            },
    { LINETERMMODE_RINGER              ,"RINGER"             },
    { LINETERMMODE_HOOKSWITCH          ,"HOOKSWITCH"         },
    { LINETERMMODE_MEDIATOLINE         ,"MEDIATOLINE"        },
    { LINETERMMODE_MEDIAFROMLINE       ,"MEDIAFROMLINE"      },
    { LINETERMMODE_MEDIABIDIRECT       ,"MEDIABIDIRECT"      },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aToneModes[] =
{
    { LINETONEMODE_CUSTOM              ,"CUSTOM"             },
    { LINETONEMODE_RINGBACK            ,"RINGBACK"           },
    { LINETONEMODE_BUSY                ,"BUSY"               },
    { LINETONEMODE_BEEP                ,"BEEP"               },
    { LINETONEMODE_BILLING             ,"BILLING"            },
    { 0xffffffff                       ,""                   }
};

LOOKUP  aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER        ,"TRANSFER"           },
    { LINETRANSFERMODE_CONFERENCE      ,"CONFERENCE"         },
    { 0xffffffff                       ,""                   }
};

LOOKUP aLineErrs[] =
{
    { 0                                ,"<SUCCESS>"              },
    { LINEERR_ALLOCATED                ,"ALLOCATED"              },
    { LINEERR_BADDEVICEID              ,"BADDEVICEID"            },
    { LINEERR_BEARERMODEUNAVAIL        ,"BEARERMODEUNAVAIL"      },
    { LINEERR_CALLUNAVAIL              ,"CALLUNAVAIL"            },
    { LINEERR_COMPLETIONOVERRUN        ,"COMPLETIONOVERRUN"      },
    { LINEERR_CONFERENCEFULL           ,"CONFERENCEFULL"         },
    { LINEERR_DIALBILLING              ,"DIALBILLING"            },
    { LINEERR_DIALDIALTONE             ,"DIALDIALTONE"           },
    { LINEERR_DIALPROMPT               ,"DIALPROMPT"             },
    { LINEERR_DIALQUIET                ,"DIALQUIET"              },
    { LINEERR_INCOMPATIBLEAPIVERSION   ,"INCOMPATIBLEAPIVERSION" },
    { LINEERR_INCOMPATIBLEEXTVERSION   ,"INCOMPATIBLEEXTVERSION" },
    { LINEERR_INIFILECORRUPT           ,"INIFILECORRUPT"         },
    { LINEERR_INUSE                    ,"INUSE"                  },
    { LINEERR_INVALADDRESS             ,"INVALADDRESS"           },
    { LINEERR_INVALADDRESSID           ,"INVALADDRESSID"         },
    { LINEERR_INVALADDRESSMODE         ,"INVALADDRESSMODE"       },
    { LINEERR_INVALADDRESSSTATE        ,"INVALADDRESSSTATE"      },
    { LINEERR_INVALAPPHANDLE           ,"INVALAPPHANDLE"         },
    { LINEERR_INVALAPPNAME             ,"INVALAPPNAME"           },
    { LINEERR_INVALBEARERMODE          ,"INVALBEARERMODE"        },
    { LINEERR_INVALCALLCOMPLMODE       ,"INVALCALLCOMPLMODE"     },
    { LINEERR_INVALCALLHANDLE          ,"INVALCALLHANDLE"        },
    { LINEERR_INVALCALLPARAMS          ,"INVALCALLPARAMS"        },
    { LINEERR_INVALCALLPRIVILEGE       ,"INVALCALLPRIVILEGE"     },
    { LINEERR_INVALCALLSELECT          ,"INVALCALLSELECT"        },
    { LINEERR_INVALCALLSTATE           ,"INVALCALLSTATE"         },
    { LINEERR_INVALCALLSTATELIST       ,"INVALCALLSTATELIST"     },
    { LINEERR_INVALCARD                ,"INVALCARD"              },
    { LINEERR_INVALCOMPLETIONID        ,"INVALCOMPLETIONID"      },
    { LINEERR_INVALCONFCALLHANDLE      ,"INVALCONFCALLHANDLE"    },
    { LINEERR_INVALCONSULTCALLHANDLE   ,"INVALCONSULTCALLHANDLE" },
    { LINEERR_INVALCOUNTRYCODE         ,"INVALCOUNTRYCODE"       },
    { LINEERR_INVALDEVICECLASS         ,"INVALDEVICECLASS"       },
    { LINEERR_INVALDEVICEHANDLE        ,"INVALDEVICEHANDLE"      },
    { LINEERR_INVALDIALPARAMS          ,"INVALDIALPARAMS"        },
    { LINEERR_INVALDIGITLIST           ,"INVALDIGITLIST"         },
    { LINEERR_INVALDIGITMODE           ,"INVALDIGITMODE"         },
    { LINEERR_INVALDIGITS              ,"INVALDIGITS"            },
    { LINEERR_INVALEXTVERSION          ,"INVALEXTVERSION"        },
    { LINEERR_INVALGROUPID             ,"INVALGROUPID"           },
    { LINEERR_INVALLINEHANDLE          ,"INVALLINEHANDLE"        },
    { LINEERR_INVALLINESTATE           ,"INVALLINESTATE"         },
    { LINEERR_INVALLOCATION            ,"INVALLOCATION"          },
    { LINEERR_INVALMEDIALIST           ,"INVALMEDIALIST"         },
    { LINEERR_INVALMEDIAMODE           ,"INVALMEDIAMODE"         },
    { LINEERR_INVALMESSAGEID           ,"INVALMESSAGEID"         },
    { LINEERR_INVALPARAM               ,"INVALPARAM"             },
    { LINEERR_INVALPARKID              ,"INVALPARKID"            },
    { LINEERR_INVALPARKMODE            ,"INVALPARKMODE"          },
    { LINEERR_INVALPOINTER             ,"INVALPOINTER"           },
    { LINEERR_INVALPRIVSELECT          ,"INVALPRIVSELECT"        },
    { LINEERR_INVALRATE                ,"INVALRATE"              },
    { LINEERR_INVALREQUESTMODE         ,"INVALREQUESTMODE"       },
    { LINEERR_INVALTERMINALID          ,"INVALTERMINALID"        },
    { LINEERR_INVALTERMINALMODE        ,"INVALTERMINALMODE"      },
    { LINEERR_INVALTIMEOUT             ,"INVALTIMEOUT"           },
    { LINEERR_INVALTONE                ,"INVALTONE"              },
    { LINEERR_INVALTONELIST            ,"INVALTONELIST"          },
    { LINEERR_INVALTONEMODE            ,"INVALTONEMODE"          },
    { LINEERR_INVALTRANSFERMODE        ,"INVALTRANSFERMODE"      },
    { LINEERR_LINEMAPPERFAILED         ,"LINEMAPPERFAILED"       },
    { LINEERR_NOCONFERENCE             ,"NOCONFERENCE"           },
    { LINEERR_NODEVICE                 ,"NODEVICE"               },
    { LINEERR_NODRIVER                 ,"NODRIVER"               },
    { LINEERR_NOMEM                    ,"NOMEM"                  },
    { LINEERR_NOREQUEST                ,"NOREQUEST"              },
    { LINEERR_NOTOWNER                 ,"NOTOWNER"               },
    { LINEERR_NOTREGISTERED            ,"NOTREGISTERED"          },
    { LINEERR_OPERATIONFAILED          ,"OPERATIONFAILED"        },
    { LINEERR_OPERATIONUNAVAIL         ,"OPERATIONUNAVAIL"       },
    { LINEERR_RATEUNAVAIL              ,"RATEUNAVAIL"            },
    { LINEERR_RESOURCEUNAVAIL          ,"RESOURCEUNAVAIL"        },
    { LINEERR_REQUESTOVERRUN           ,"REQUESTOVERRUN"         },
    { LINEERR_STRUCTURETOOSMALL        ,"STRUCTURETOOSMALL"      },
    { LINEERR_TARGETNOTFOUND           ,"TARGETNOTFOUND"         },
    { LINEERR_TARGETSELF               ,"TARGETSELF"             },
    { LINEERR_UNINITIALIZED            ,"UNINITIALIZED"          },
    { LINEERR_USERUSERINFOTOOBIG       ,"USERUSERINFOTOOBIG"     },
    { LINEERR_REINIT                   ,"REINIT"                 },
    { LINEERR_ADDRESSBLOCKED           ,"ADDRESSBLOCKED"         },
    { LINEERR_BILLINGREJECTED          ,"BILLINGREJECTED"        },
    { LINEERR_INVALFEATURE             ,"INVALFEATURE"           },
    { LINEERR_NOMULTIPLEINSTANCE       ,"NOMULTIPLEINSTANCE"     },
    { 0xffffffff                       ,""                       }
};


LOOKUP aPhoneErrs[] =
{
    { 0                                ,"<SUCCESS>"              },
    { PHONEERR_ALLOCATED               ,"ALLOCATED"              },
    { PHONEERR_BADDEVICEID             ,"BADDEVICEID"            },
    { PHONEERR_INCOMPATIBLEAPIVERSION  ,"INCOMPATIBLEAPIVERSION" },
    { PHONEERR_INCOMPATIBLEEXTVERSION  ,"INCOMPATIBLEEXTVERSION" },
    { PHONEERR_INIFILECORRUPT          ,"INIFILECORRUPT"         },
    { PHONEERR_INUSE                   ,"INUSE"                  },
    { PHONEERR_INVALAPPHANDLE          ,"INVALAPPHANDLE"         },
    { PHONEERR_INVALAPPNAME            ,"INVALAPPNAME"           },
    { PHONEERR_INVALBUTTONLAMPID       ,"INVALBUTTONLAMPID"      },
    { PHONEERR_INVALBUTTONMODE         ,"INVALBUTTONMODE"        },
    { PHONEERR_INVALBUTTONSTATE        ,"INVALBUTTONSTATE"       },
    { PHONEERR_INVALDATAID             ,"INVALDATAID"            },
    { PHONEERR_INVALDEVICECLASS        ,"INVALDEVICECLASS"       },
    { PHONEERR_INVALEXTVERSION         ,"INVALEXTVERSION"        },
    { PHONEERR_INVALHOOKSWITCHDEV      ,"INVALHOOKSWITCHDEV"     },
    { PHONEERR_INVALHOOKSWITCHMODE     ,"INVALHOOKSWITCHMODE"    },
    { PHONEERR_INVALLAMPMODE           ,"INVALLAMPMODE"          },
    { PHONEERR_INVALPARAM              ,"INVALPARAM"             },
    { PHONEERR_INVALPHONEHANDLE        ,"INVALPHONEHANDLE"       },
    { PHONEERR_INVALPHONESTATE         ,"INVALPHONESTATE"        },
    { PHONEERR_INVALPOINTER            ,"INVALPOINTER"           },
    { PHONEERR_INVALPRIVILEGE          ,"INVALPRIVILEGE"         },
    { PHONEERR_INVALRINGMODE           ,"INVALRINGMODE"          },
    { PHONEERR_NODEVICE                ,"NODEVICE"               },
    { PHONEERR_NODRIVER                ,"NODRIVER"               },
    { PHONEERR_NOMEM                   ,"NOMEM"                  },
    { PHONEERR_NOTOWNER                ,"NOTOWNER"               },
    { PHONEERR_OPERATIONFAILED         ,"OPERATIONFAILED"        },
    { PHONEERR_OPERATIONUNAVAIL        ,"OPERATIONUNAVAIL"       },
    { PHONEERR_RESOURCEUNAVAIL         ,"RESOURCEUNAVAIL"        },
    { PHONEERR_REQUESTOVERRUN          ,"REQUESTOVERRUN"         },
    { PHONEERR_STRUCTURETOOSMALL       ,"STRUCTURETOOSMALL"      },
    { PHONEERR_UNINITIALIZED           ,"UNINITIALIZED"          },
    { PHONEERR_REINIT                  ,"REINIT"                 },
    { 0xffffffff                       ,""                       }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\kmddsp\kmddsp.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: kmddsp.c
//
// History:
//      Dan Knudson (DanKn)     11-Apr-1995     Created
//      Yi Sun (YiSun)          June-29-2000    Rewriten
//
// Abstract:
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "rtutils.h"
#include "winioctl.h"
#include "ntddndis.h"
#include "ndistapi.h"
#include "intrface.h"

//
// NOTE: the following are defined in both ndistapi.h & tapi.h (or tspi.h)
//       and cause (more or less non-interesting) build warnings, so we
//       undefine them after the first #include to do away with this
//

#undef LAST_LINEMEDIAMODE
#undef TSPI_MESSAGE_BASE
#undef LINE_NEWCALL
#undef LINE_CALLDEVSPECIFIC
#undef LINE_CREATE

#include "tapi.h"
#include "tspi.h"
#include "kmddsp.h"

#define OUTBOUND_CALL_KEY       ((DWORD) 'OCAL')
#define INBOUND_CALL_KEY        ((DWORD) 'ICAL')
#define LINE_KEY                ((DWORD) 'KLIN')
#define ASYNCREQWRAPPER_KEY     ((DWORD) 'ARWK')
#define INVALID_KEY             ((DWORD) 'XXXX')

#define EVENT_BUFFER_SIZE       1024

typedef LONG (*POSTPROCESSPROC)(PASYNC_REQUEST_WRAPPER, LONG, PDWORD_PTR);

typedef struct _ASYNC_REQUEST_WRAPPER
{
    // NOTE: overlapped must remain 1st field in this struct
    OVERLAPPED          Overlapped;
    DWORD               dwKey;
    DWORD               dwRequestID;
    POSTPROCESSPROC     pfnPostProcess;
    CRITICAL_SECTION    CritSec;
    ULONG               RefCount;
    DWORD_PTR           dwRequestSpecific;
    // NOTE: NdisTapiRequest must follow a ptr to avoid alignment problem
    NDISTAPI_REQUEST    NdisTapiRequest;
} ASYNC_REQUEST_WRAPPER, *PASYNC_REQUEST_WRAPPER;

#define REF_ASYNC_REQUEST_WRAPPER(_pAsyncReqWrapper)    \
{                                                       \
    EnterCriticalSection(&_pAsyncReqWrapper->CritSec);  \
    _pAsyncReqWrapper->RefCount++;                      \
    LeaveCriticalSection(&_pAsyncReqWrapper->CritSec);  \
}

#define DEREF_ASYNC_REQUEST_WRAPPER(_pAsyncReqWrapper)      \
{                                                           \
    EnterCriticalSection(&_pAsyncReqWrapper->CritSec);      \
    if (--(_pAsyncReqWrapper->RefCount) == 0) {             \
        LeaveCriticalSection(&_pAsyncReqWrapper->CritSec);  \
        DeleteCriticalSection(&_pAsyncReqWrapper->CritSec); \
        FreeRequest(_pAsyncReqWrapper);                     \
        _pAsyncReqWrapper = NULL;                           \
    } else {                                                \
        LeaveCriticalSection(&_pAsyncReqWrapper->CritSec);  \
    }                                                       \
}

typedef struct _ASYNC_EVENTS_THREAD_INFO
{
    HANDLE                  hThread;    // thread handle
    PNDISTAPI_EVENT_DATA    pBuf;       // ptr to a buf for async events
    DWORD                   dwBufSize;  // size of the previous buffer

} ASYNC_EVENTS_THREAD_INFO, *PASYNC_EVENTS_THREAD_INFO;


typedef struct _DRVCALL
{
    DWORD                   dwKey;
    DWORD                   dwDeviceID;
    HTAPICALL               htCall;                 // TAPI's handle to the call
    HDRVCALL                hdCall;                 // TSP's handle to the call
    HDRV_CALL               hd_Call;                // NDISTAPI's call handle
    HDRVLINE                hdLine;                 // TSP's handle to the line
    union
    {
        struct _DRVCALL    *pPrev;                  // for inbound calls only
        DWORD               dwPendingCallState;     // for outbound calls only
    };
    union
    {
        struct _DRVCALL    *pNext;                  // for inbound calls only
        DWORD               dwPendingCallStateMode; // for outbound calls only
    };
    union
    {
        HTAPI_CALL          ht_Call;                // for inbound calls only
        DWORD               dwPendingMediaMode;     // for outbound calls only
    };
    BOOL                    bIncomplete;
    BOOL                    bDropped;
    BOOL                    bIdle;
} DRVCALL, *PDRVCALL;


typedef struct _DRVLINE
{
    DWORD                   dwKey;
    DWORD                   dwDeviceID;
    HTAPILINE               htLine;                 // TAPI's line handle
    HDRV_LINE               hd_Line;                // NDISTAPI's line handle
    PDRVCALL                pInboundCalls;          // inbound call list

    // the following two related to PNP/POWER
    GUID                    Guid;
    NDIS_WAN_MEDIUM_SUBTYPE MediaType;
} DRVLINE, *PDRVLINE;

// globals
HANDLE                      ghDriverSync, ghDriverAsync, ghCompletionPort;
PASYNC_EVENTS_THREAD_INFO   gpAsyncEventsThreadInfo;
DWORD                       gdwRequestID;
ASYNC_COMPLETION            gpfnCompletionProc;
CRITICAL_SECTION            gRequestIDCritSec;
LINEEVENT                   gpfnLineEvent;
HPROVIDER                   ghProvider;
OVERLAPPED  gOverlappedTerminate; 
// Dummy structure . Used by provider shutdown to notify 
// AsyncEventsThread before closing completion port handle


//
// debug globals
//
#if DBG
DWORD                       gdwDebugLevel;
#endif // DBG 

DWORD                       gdwTraceID = INVALID_TRACEID;

//
// creates a log using the RAS tracing utility
// also prints it onto the attached debugger 
// if a debug build is running
//
VOID
TspLog(
    IN DWORD    dwDebugLevel,
    IN PCHAR    pchFormat,
    ...
    )
{
    va_list arglist;
    CHAR    chNewFmt[256];

    va_start(arglist, pchFormat);

    switch (dwDebugLevel)
    {
        case DL_ERROR:
            strcpy(chNewFmt, "!!! ");
            break;

        case DL_WARNING:
            strcpy(chNewFmt, "!!  ");
            break;

        case DL_INFO:
            strcpy(chNewFmt, "!   ");
            break;

        case DL_TRACE:
            strcpy(chNewFmt, "    ");
            break;
    }
    strcat(chNewFmt, pchFormat);

#if DBG
    if (dwDebugLevel <= gdwDebugLevel)
    {
#if 0
        DbgPrint("++KMDDSP++ ");
        DbgPrint(chNewFmt, arglist);
        DbgPrint("\n");
#else
        char szBuffer[256];
        OutputDebugString("++KMDDSP++ ");
        wvsprintf(szBuffer, chNewFmt, arglist);
        OutputDebugString(szBuffer);
        OutputDebugString("\n");
#endif
    }
#endif // DBG

    if (gdwTraceID != INVALID_TRACEID)
    {
        TraceVprintfEx(gdwTraceID,
                       (dwDebugLevel << 16) | TRACE_USE_MASK | TRACE_USE_MSEC,
                       chNewFmt,
                       arglist);
    }

    va_end(arglist);

#if DBG
    if (DL_ERROR == dwDebugLevel)
    {
        //DebugBreak();
    }
#endif // DBG
}

#if DBG

#define INSERTVARDATASTRING(a,b,c,d,e,f) InsertVarDataString(a,b,c,d,e,f)

void
PASCAL
InsertVarDataString(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize,
    char   *pszFieldName
    )

#else

#define INSERTVARDATASTRING(a,b,c,d,e,f) InsertVarDataString(a,b,c,d,e)

void
PASCAL
InsertVarDataString(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize
    )

#endif
{
    DWORD   dwXxxSize, dwTotalSize, dwXxxOffset;


    //
    // If the dwXxxSize field of the old struct is non-zero, then
    // we need to do a ascii->unicode conversion on it.  Check to
    // make sure that the size/offset are valid (if not set the
    // data size/offset in the new struct to 0) and then convert.
    //

    if ((dwXxxSize = *pdwXxxSize))
    {
        dwXxxOffset = *(pdwXxxSize + 1);

#if DBG
        dwTotalSize = ((LPVARSTRING) pStruct)->dwTotalSize;

        if (dwXxxSize > (dwTotalSize - dwFixedStructSize) ||
            dwXxxOffset < dwFixedStructSize ||
            dwXxxOffset >= dwTotalSize ||
            (dwXxxSize + dwXxxOffset) > dwTotalSize)
        {
            TspLog(DL_ERROR, 
                  "INSERTVARDATASTRING: bad %s values - size(x%x), "\
                  "offset(x%x)",
                   pszFieldName, dwXxxSize, dwXxxOffset);

            *pdwNewXxxSize = *(pdwNewXxxSize + 1) = 0;
            return;
        }
#endif

        // make sure the string is NULL terminated
        *(((LPBYTE)pStruct) + (dwXxxOffset + dwXxxSize - 1)) = '\0';

        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            ((LPBYTE) pStruct) + dwXxxOffset,
            dwXxxSize,
            (LPWSTR) (((LPBYTE) pNewStruct) +
                ((LPVARSTRING) pNewStruct)->dwUsedSize),
            dwXxxSize
            );

        *pdwNewXxxSize = dwXxxSize * sizeof (WCHAR);
        *(pdwNewXxxSize + 1) = ((LPVARSTRING) pNewStruct)->dwUsedSize; // offset
        ((LPVARSTRING) pNewStruct)->dwUsedSize += (dwXxxSize * sizeof (WCHAR));
    }
}


#if DBG

#define INSERTVARDATA(a,b,c,d,e,f) InsertVarData(a,b,c,d,e,f)

void
PASCAL
InsertVarData(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize,
    char   *pszFieldName
    )

#else

#define INSERTVARDATA(a,b,c,d,e,f) InsertVarData(a,b,c,d,e)

void
PASCAL
InsertVarData(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize
    )

#endif
{
    DWORD   dwTotalSize, dwXxxSize, dwXxxOffset;


    if ((dwXxxSize = *pdwXxxSize))
    {
        dwXxxOffset = *(pdwXxxSize + 1);

#if DBG
        dwTotalSize = ((LPVARSTRING) pStruct)->dwTotalSize;

        if (dwXxxSize > (dwTotalSize - dwFixedStructSize) ||
            dwXxxOffset < dwFixedStructSize ||
            dwXxxOffset >= dwTotalSize ||
            (dwXxxSize + dwXxxOffset) > dwTotalSize)
        {
            TspLog(DL_ERROR,
                   "INSERTVARDATA: bad %s values - size(x%x), offset(x%x)",
                   pszFieldName, dwXxxSize, dwXxxOffset);

            *pdwNewXxxSize = *(pdwNewXxxSize + 1) = 0;
            return;
        }
#endif
        CopyMemory(
            ((LPBYTE) pNewStruct) + ((LPVARSTRING) pNewStruct)->dwUsedSize,
            ((LPBYTE) pStruct) + dwXxxOffset,
            dwXxxSize
            );

        *pdwNewXxxSize = dwXxxSize;
        *(pdwNewXxxSize + 1) = ((LPVARSTRING) pNewStruct)->dwUsedSize; // offset
        ((LPVARSTRING) pNewStruct)->dwUsedSize += dwXxxSize;
    }
}

static char *pszOidNames[] =
{
    "Accept",
    "Answer",
    "Close",
    "CloseCall",
    "ConditionalMediaDetection",
    "ConfigDialog",
    "DevSpecific",
    "Dial",
    "Drop",
    "GetAddressCaps",
    "GetAddressID",
    "GetAddressStatus",
    "GetCallAddressID",
    "GetCallInfo",
    "GetCallStatus",
    "GetDevCaps",
    "GetDevConfig",
    "GetExtensionID",
    "GetID",
    "GetLineDevStatus",
    "MakeCall",
    "NegotiateExtVersion",
    "Open",
    "ProviderInitialize",
    "ProviderShutdown",
    "SecureCall",
    "SelectExtVersion",
    "SendUserUserInfo",
    "SetAppSpecific",
    "StCallParams",
    "StDefaultMediaDetection",
    "SetDevConfig",
    "SetMediaMode",
    "SetStatusMessages"
};

// used to print the NDIS TAPI requests properly         
typedef enum _TAPI_REQUEST_TYPE
{
    TAPI_REQUEST_UNKNOWN = 0,
    TAPI_REQUEST_NONE,
    TAPI_REQUEST_HDCALL,
    TAPI_REQUEST_HDLINE,
    TAPI_REQUEST_DEVICEID
} TAPI_REQUEST_TYPE;

static TAPI_REQUEST_TYPE OidTypes[] =
{
    TAPI_REQUEST_HDCALL,    // "Accept"
    TAPI_REQUEST_HDCALL,    // "Answer"
    TAPI_REQUEST_HDLINE,    // "Close"
    TAPI_REQUEST_HDCALL,    // "CloseCall"
    TAPI_REQUEST_HDLINE,    // "ConditionalMediaDetection"
    TAPI_REQUEST_DEVICEID,  // "ConfigDialog"
    TAPI_REQUEST_HDLINE,    // "DevSpecific"
    TAPI_REQUEST_HDCALL,    // "Dial"
    TAPI_REQUEST_HDCALL,    // "Drop"
    TAPI_REQUEST_DEVICEID,  // "GetAddressCaps"
    TAPI_REQUEST_HDLINE,    // "GetAddressID"
    TAPI_REQUEST_HDLINE,    // "GetAddressStatus"
    TAPI_REQUEST_HDCALL,    // "GetCallAddressID"
    TAPI_REQUEST_HDCALL,    // "GetCallInfo"
    TAPI_REQUEST_HDCALL,    // "GetCallStatus"
    TAPI_REQUEST_DEVICEID,  // "GetDevCaps"
    TAPI_REQUEST_DEVICEID,  // "GetDevConfig"
    TAPI_REQUEST_DEVICEID,  // "GetExtensionID"
    TAPI_REQUEST_HDLINE,    // "GetID"
    TAPI_REQUEST_HDLINE,    // "GetLineDevStatus"
    TAPI_REQUEST_HDLINE,    // "MakeCall"
    TAPI_REQUEST_DEVICEID,  // "NegotiateExtVersion"
    TAPI_REQUEST_DEVICEID,  // "Open"
    TAPI_REQUEST_DEVICEID,  // "ProviderInitialize"
    TAPI_REQUEST_NONE,      // "ProviderShutdown"
    TAPI_REQUEST_HDCALL,    // "SecureCall"
    TAPI_REQUEST_HDLINE,    // "SelectExtVersion"
    TAPI_REQUEST_HDCALL,    // "SendUserUserInfo"
    TAPI_REQUEST_HDCALL,    // "SetAppSpecific"
    TAPI_REQUEST_HDCALL,    // "StCallParams"
    TAPI_REQUEST_HDLINE,    // "StDefaultMediaDetection"
    TAPI_REQUEST_DEVICEID,  // "SetDevConfig"
    TAPI_REQUEST_HDCALL,    // "SetMediaMode"
    TAPI_REQUEST_HDLINE,    // "SetStatusMessages"
};


//
// translates NDIS TAPI status codes into LINEERR_XXX
//
LONG
WINAPI
TranslateDriverResult(
    ULONG   ulRes
    )
{
    typedef struct _RESULT_LOOKUP
    {
        ULONG   NdisTapiResult;
        LONG    TapiResult;
    } RESULT_LOOKUP, *PRESULT_LOOKUP;

    typedef ULONG NDIS_STATUS;
    #define NDIS_STATUS_SUCCESS     0x00000000L
    #define NDIS_STATUS_RESOURCES   0xC000009AL
    #define NDIS_STATUS_FAILURE     0xC0000001L
    #define NDIS_STATUS_INVALID_OID 0xC0010017L

    static RESULT_LOOKUP aResults[] =
    {

    //
    // Defined in NDIS.H
    //

    { NDIS_STATUS_SUCCESS                    ,0 },

    //
    // These errors are defined in NDISTAPI.H
    //

    { NDIS_STATUS_TAPI_ADDRESSBLOCKED        ,LINEERR_ADDRESSBLOCKED        },
    { NDIS_STATUS_TAPI_BEARERMODEUNAVAIL     ,LINEERR_BEARERMODEUNAVAIL     },
    { NDIS_STATUS_TAPI_CALLUNAVAIL           ,LINEERR_CALLUNAVAIL           },
    { NDIS_STATUS_TAPI_DIALBILLING           ,LINEERR_DIALBILLING           },
    { NDIS_STATUS_TAPI_DIALDIALTONE          ,LINEERR_DIALDIALTONE          },
    { NDIS_STATUS_TAPI_DIALPROMPT            ,LINEERR_DIALPROMPT            },
    { NDIS_STATUS_TAPI_DIALQUIET             ,LINEERR_DIALQUIET             },
    { NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION,LINEERR_INCOMPATIBLEEXTVERSION},
    { NDIS_STATUS_TAPI_INUSE                 ,LINEERR_INUSE                 },
    { NDIS_STATUS_TAPI_INVALADDRESS          ,LINEERR_INVALADDRESS          },
    { NDIS_STATUS_TAPI_INVALADDRESSID        ,LINEERR_INVALADDRESSID        },
    { NDIS_STATUS_TAPI_INVALADDRESSMODE      ,LINEERR_INVALADDRESSMODE      },
    { NDIS_STATUS_TAPI_INVALBEARERMODE       ,LINEERR_INVALBEARERMODE       },
    { NDIS_STATUS_TAPI_INVALCALLHANDLE       ,LINEERR_INVALCALLHANDLE       },
    { NDIS_STATUS_TAPI_INVALCALLPARAMS       ,LINEERR_INVALCALLPARAMS       },
    { NDIS_STATUS_TAPI_INVALCALLSTATE        ,LINEERR_INVALCALLSTATE        },
    { NDIS_STATUS_TAPI_INVALDEVICECLASS      ,LINEERR_INVALDEVICECLASS      },
    { NDIS_STATUS_TAPI_INVALLINEHANDLE       ,LINEERR_INVALLINEHANDLE       },
    { NDIS_STATUS_TAPI_INVALLINESTATE        ,LINEERR_INVALLINESTATE        },
    { NDIS_STATUS_TAPI_INVALMEDIAMODE        ,LINEERR_INVALMEDIAMODE        },
    { NDIS_STATUS_TAPI_INVALRATE             ,LINEERR_INVALRATE             },
    { NDIS_STATUS_TAPI_NODRIVER              ,LINEERR_NODRIVER              },
    { NDIS_STATUS_TAPI_OPERATIONUNAVAIL      ,LINEERR_OPERATIONUNAVAIL      },
    { NDIS_STATUS_TAPI_RATEUNAVAIL           ,LINEERR_RATEUNAVAIL           },
    { NDIS_STATUS_TAPI_RESOURCEUNAVAIL       ,LINEERR_RESOURCEUNAVAIL       },
    { NDIS_STATUS_TAPI_STRUCTURETOOSMALL     ,LINEERR_STRUCTURETOOSMALL     },
    { NDIS_STATUS_TAPI_USERUSERINFOTOOBIG    ,LINEERR_USERUSERINFOTOOBIG    },
    { NDIS_STATUS_TAPI_ALLOCATED             ,LINEERR_ALLOCATED             },
    { NDIS_STATUS_TAPI_INVALADDRESSSTATE     ,LINEERR_INVALADDRESSSTATE     },
    { NDIS_STATUS_TAPI_INVALPARAM            ,LINEERR_INVALPARAM            },
    { NDIS_STATUS_TAPI_NODEVICE              ,LINEERR_NODEVICE              },

    //
    // These errors are defined in NDIS.H
    //

    { NDIS_STATUS_RESOURCES                  ,LINEERR_NOMEM },
    { NDIS_STATUS_FAILURE                    ,LINEERR_OPERATIONFAILED },
    { NDIS_STATUS_INVALID_OID                ,LINEERR_OPERATIONFAILED },

    //
    //
    //

    { NDISTAPIERR_UNINITIALIZED              ,LINEERR_OPERATIONFAILED },
    { NDISTAPIERR_BADDEVICEID                ,LINEERR_OPERATIONFAILED },
    { NDISTAPIERR_DEVICEOFFLINE              ,LINEERR_OPERATIONFAILED },

    //
    // The terminating fields
    //

    { 0xffffffff, 0xffffffff }

    };

    int i;

    for (i = 0; aResults[i].NdisTapiResult != 0xffffffff; i++)
    {
        if (ulRes == aResults[i].NdisTapiResult)
        {
            return (aResults[i].TapiResult);
        }
    }

    TspLog(DL_WARNING, "TranslateDriverResult: unknown driver result(%x)",
           ulRes);

    return LINEERR_OPERATIONFAILED;
}

//
// NOTE: for functions that need to acquire (read, write) locks for both 
//       a line and a call, we enforce the order to be line first, call 
//       second to avoid potential DEADLOCK.
//

LONG
GetLineObjWithReadLock(
    IN HDRVLINE     hdLine,
    OUT PDRVLINE   *ppLine
    )
{
    LONG        lRes;
    PDRVLINE    pLine;

    lRes = GetObjWithReadLock((HANDLE)hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pLine != NULL);
    if (pLine->dwKey != LINE_KEY)
    {
        TspLog(DL_WARNING, "GetLineObjWithReadLock: obj(%p) has bad key(%x)", 
               hdLine, pLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppLine = pLine;
    return lRes;
}
    
LONG
GetLineObjWithWriteLock(
    IN HDRVLINE     hdLine,
    OUT PDRVLINE   *ppLine
    )
{
    LONG        lRes;
    PDRVLINE    pLine;

    lRes = GetObjWithWriteLock((HANDLE)hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pLine != NULL);
    if (pLine->dwKey != LINE_KEY)
    {
        TspLog(DL_WARNING, "GetLineObjWithWriteLock: obj(%p) has bad key(%x)",
               hdLine, pLine->dwKey);

        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppLine = pLine;
    return lRes;
}

LONG
GetCallObjWithReadLock(
    IN HDRVCALL     hdCall,
    OUT PDRVCALL   *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithReadLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, "GetCallObjWithReadLock: obj(%p) has bad key(%x)", 
               hdCall, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;
    return lRes;
}

LONG
GetCallObjWithWriteLock(
    IN HDRVCALL     hdCall,
    OUT PDRVCALL   *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithWriteLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, "GetCallObjWithWriteLock: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjWriteLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;
    return lRes;
}

LONG
GetLineHandleFromCallHandle(
    IN HDRVCALL     hdCall,
    OUT HDRVLINE   *phdLine
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithReadLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineHandleFromCallHandle: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *phdLine = pCall->hdLine;

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
GetLineAndCallObjWithReadLock(
    HTAPI_LINE ht_Line,
    HTAPI_CALL ht_Call,
    PDRVLINE  *ppLine,
    PDRVCALL  *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;
    PDRVLINE    pLine;

    lRes = GetLineObjWithReadLock((HDRVLINE)ht_Line, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    *ppLine = pLine;

    //
    // figure out whether this is an inbound call or
    // outbound call: for inbound calls, ht_Call is
    // generated by NDISTAPI and bit 0 is 1;
    // for outbound calls, ht_Call is a TSP handle
    // and we make sure that bit 0 is 0
    //
    if (ht_Call & 0x1)
    {
        // inbound call: we need to walk the list
        // of inbound calls on this line and
        // find the right one
        if ((pCall = pLine->pInboundCalls) != NULL)
        {
            while (pCall && (pCall->ht_Call != ht_Call))
            {
                pCall = pCall->pNext;
            }
        }

        if (NULL == pCall || pCall->dwKey != INBOUND_CALL_KEY)
        {
            TspLog(DL_WARNING,
                   "GetLineAndCallObjWithReadLock: "\
                   "inbound ht_call(%p) closed already",
                   ht_Call);

            ReleaseObjReadLock((HANDLE)ht_Line);
            return LINEERR_INVALCALLHANDLE;
        }

        // call the following to increase the ref count
        lRes = AcquireObjReadLock((HANDLE)pCall->hdCall);
        if (lRes != TAPI_SUCCESS)
        {
            ReleaseObjReadLock((HANDLE)ht_Line);
            return lRes;
        }

        *ppCall = pCall;

        return TAPI_SUCCESS;
    }

    // ht_Call is a TSP handle and the call is OUTBOUND
    lRes = GetObjWithReadLock((HANDLE)ht_Call, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)ht_Line);
        return lRes;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING,
               "GetLineAndCallObjWithReadLock: bad call handle(%p, %x)",
               ht_Call, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)ht_Call);
        ReleaseObjReadLock((HANDLE)ht_Line);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;

    return TAPI_SUCCESS;
}

//
// allocates mem for a NDISTAPI_REQUEST plus some initialization
//
LONG
WINAPI
PrepareSyncRequest(
    ULONG               Oid,
    ULONG               ulDeviceID,
    DWORD               dwDataSize,
    PNDISTAPI_REQUEST  *ppNdisTapiRequest
    )
{
    PNDISTAPI_REQUEST   pNdisTapiRequest =
        (PNDISTAPI_REQUEST)AllocRequest(dwDataSize + sizeof(NDISTAPI_REQUEST));
    if (NULL == pNdisTapiRequest)
    {
        TspLog(DL_ERROR, 
               "PrepareSyncRequest: failed to alloc sync req for oid(%x)", 
               Oid);
        return LINEERR_NOMEM;
    }

    pNdisTapiRequest->Oid = Oid;
    pNdisTapiRequest->ulDeviceID = ulDeviceID;
    pNdisTapiRequest->ulDataSize = dwDataSize;

    EnterCriticalSection(&gRequestIDCritSec);

    // setting ulRequestId of NDIS_TAPI_xxxx
    if ((*((ULONG *)pNdisTapiRequest->Data) = ++gdwRequestID) >= 0x7fffffff)
    {
        gdwRequestID = 1;
    }

    LeaveCriticalSection(&gRequestIDCritSec);

    *ppNdisTapiRequest = pNdisTapiRequest;

    return TAPI_SUCCESS;
}

//
// allocates mem for a ASYNC_REQUEST_WRAPPER plus some initialization
//
LONG
WINAPI
PrepareAsyncRequest(
    ULONG                   Oid,
    ULONG                   ulDeviceID,
    DWORD                   dwRequestID,
    DWORD                   dwDataSize,
    PASYNC_REQUEST_WRAPPER *ppAsyncReqWrapper
    )
{
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;

    // alloc & init an async request wrapper
    pAsyncReqWrapper = (PASYNC_REQUEST_WRAPPER)
        AllocRequest(dwDataSize + sizeof(ASYNC_REQUEST_WRAPPER));
    if (NULL == pAsyncReqWrapper)
    {
        TspLog(DL_ERROR, 
               "PrepareAsyncRequest: failed to alloc async req for oid(%x)", 
               Oid);
        return LINEERR_NOMEM;
    }

    // don't need to create an event when using completion ports
    pAsyncReqWrapper->Overlapped.hEvent = (HANDLE)NULL;

    pAsyncReqWrapper->dwKey          = ASYNCREQWRAPPER_KEY;
    pAsyncReqWrapper->dwRequestID    = dwRequestID;
    pAsyncReqWrapper->pfnPostProcess = (POSTPROCESSPROC)NULL;

    // initialize the critical section, ref the request wrapper. 
    // NOTE: this crit sec will be deleted by the last deref. 
    InitializeCriticalSection(&pAsyncReqWrapper->CritSec); 
    pAsyncReqWrapper->RefCount = 1;

    // safely initialize the driver request
    pNdisTapiRequest = &(pAsyncReqWrapper->NdisTapiRequest);

    pNdisTapiRequest->Oid = Oid;
    pNdisTapiRequest->ulDeviceID = ulDeviceID;
    pNdisTapiRequest->ulDataSize = dwDataSize;

    EnterCriticalSection(&gRequestIDCritSec);

    if ((*((ULONG *)pNdisTapiRequest->Data) = ++gdwRequestID) >= 0x7fffffff)
    {
        gdwRequestID = 1;
    }

    LeaveCriticalSection(&gRequestIDCritSec);

    *ppAsyncReqWrapper = pAsyncReqWrapper;

    return TAPI_SUCCESS;
}

//
// makes a non-overlapped request to ndistapi.sys
// so it doesn't return until the req is completed
//
LONG
WINAPI
SyncDriverRequest(
    DWORD               dwIoControlCode,
    PNDISTAPI_REQUEST   pNdisTapiRequest
    )
{
    BOOL    bRes;
    DWORD   cbReturned;

    switch(OidTypes[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT])
    {
        case TAPI_REQUEST_NONE: 
            TspLog(DL_INFO, 
                "SyncDriverRequest: oid(%s), devID(%x), reqID(%x)",
                pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT],
                pNdisTapiRequest->ulDeviceID,
                *((ULONG *)pNdisTapiRequest->Data));
            break;
            
        case TAPI_REQUEST_DEVICEID: 
            TspLog(DL_INFO, 
                "SyncDriverRequest: oid(%s), devID(%x), reqID(%x), deviceID(%x)",
                pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT],
                pNdisTapiRequest->ulDeviceID,
                *((ULONG *)pNdisTapiRequest->Data),
                *(((ULONG *)pNdisTapiRequest->Data) + 1));
            break;
            
        case TAPI_REQUEST_HDCALL: 
            TspLog(DL_INFO, 
                "SyncDriverRequest: oid(%s), devID(%x), reqID(%x), hdCall(%p)",
                pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT],
                pNdisTapiRequest->ulDeviceID,
                *((ULONG *)pNdisTapiRequest->Data),
                *((ULONG_PTR *)(pNdisTapiRequest->Data + sizeof(ULONG_PTR))));
        
            break;
            
        case TAPI_REQUEST_HDLINE: 
            TspLog(DL_INFO, 
                "SyncDriverRequest: oid(%s), devID(%x), reqID(%x), hdLine(%p)",
                pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT],
                pNdisTapiRequest->ulDeviceID,
                *((ULONG *)pNdisTapiRequest->Data),
                *((ULONG_PTR *)(pNdisTapiRequest->Data + sizeof(ULONG_PTR))));
            break;
            
        default:
            break;
    }
    

    // mark the request as being processed by the driver
    MarkRequest(pNdisTapiRequest);

    bRes = DeviceIoControl(ghDriverSync,
                              dwIoControlCode,
                              pNdisTapiRequest,
                              (DWORD)(sizeof(NDISTAPI_REQUEST) +
                                      pNdisTapiRequest->ulDataSize),
                              pNdisTapiRequest,
                              (DWORD)(sizeof(NDISTAPI_REQUEST) +
                                      pNdisTapiRequest->ulDataSize),
                              &cbReturned,
                              0);

    // unmark the request now that the ioctl is completed
    UnmarkRequest(pNdisTapiRequest);

    if (bRes != TRUE)
    {
        TspLog(DL_ERROR, "SyncDriverRequest: IoCtl(Oid %x) failed(%d)",
               pNdisTapiRequest->Oid, GetLastError());

        return (LINEERR_OPERATIONFAILED);
    }
    else
    {
        // the errors returned by ndistapi.sys don't match the TAPI
        // LINEERR_'s, so return the translated values (but preserve
        // the original driver return val so it's possible to distinguish
        // between  NDISTAPIERR_DEVICEOFFLINE & LINEERR_OPERATIONUNAVAIL,
        // etc.)
        if(pNdisTapiRequest->ulReturnValue != STATUS_SUCCESS)
        {
            TspLog(DL_WARNING, "SyncDriverRequest: (Oid %s) returns with NDIS status (%x)",
                   pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT], pNdisTapiRequest->ulReturnValue);
        }
        
        return (TranslateDriverResult(pNdisTapiRequest->ulReturnValue));
    }
}

//
// make an overlapped call
//
LONG
WINAPI
AsyncDriverRequest(
    DWORD                   dwIoControlCode,
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper
    )
{
    BOOL    bRes;
    LONG    lRes;
    DWORD   dwRequestSize, cbReturned, dwLastError;

    TspLog(DL_INFO,
           "AsyncDriverRequest: oid(%s), devID(%x), ReqID(%x), "
           "reqID(%x), hdCall(%x)",
           pszOidNames[pAsyncReqWrapper->NdisTapiRequest.Oid -
                       OID_TAPI_ACCEPT],
           pAsyncReqWrapper->NdisTapiRequest.ulDeviceID,
           pAsyncReqWrapper->dwRequestID,
           *((ULONG *)pAsyncReqWrapper->NdisTapiRequest.Data),
           *(((ULONG *)pAsyncReqWrapper->NdisTapiRequest.Data) + 1));

    lRes = (LONG)pAsyncReqWrapper->dwRequestID;

    dwRequestSize = sizeof(NDISTAPI_REQUEST) +
        (pAsyncReqWrapper->NdisTapiRequest.ulDataSize - 1);

    REF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

    // mark the request as being processed by the driver
    MarkRequest(pAsyncReqWrapper);

    bRes = DeviceIoControl(
        ghDriverAsync,
        dwIoControlCode,
        &pAsyncReqWrapper->NdisTapiRequest,
        dwRequestSize,
        &pAsyncReqWrapper->NdisTapiRequest,
        dwRequestSize,
        &cbReturned,
        &pAsyncReqWrapper->Overlapped
        );

    DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

    if (bRes != TRUE) {

        dwLastError = GetLastError();

        if (dwLastError != ERROR_IO_PENDING) {

            TspLog(DL_ERROR, "AsyncDriverRequest: IoCtl(oid %x) failed(%d)",
                   pAsyncReqWrapper->NdisTapiRequest.Oid, dwLastError);

            // the ioctl failed and was not pended
            // this does not trigger the completion port
            // so we have to cleanup here.
            (*gpfnCompletionProc)(pAsyncReqWrapper->dwRequestID,
                                  LINEERR_OPERATIONFAILED);

            DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);
        }
    }

    return lRes;
}

//
// reports to TAPI events that occur on the line or on calls on the line
//
VOID
WINAPI
ProcessEvent(
    PNDIS_TAPI_EVENT    pEvent
    )
{
    LONG        lRes;
    ULONG       ulMsg = pEvent->ulMsg;
    HTAPI_LINE  ht_Line = (HTAPI_LINE)pEvent->htLine;
    HTAPI_CALL  ht_Call = (HTAPI_CALL)pEvent->htCall;

    TspLog(DL_INFO, 
           "ProcessEvent: event(%p), msg(%x), ht_line(%p), ht_call(%p), "\
           "p1(%p), p2(%p), p3(%p)",
           pEvent, ulMsg, ht_Line, ht_Call, 
           pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

    switch (ulMsg)
    {
    case LINE_ADDRESSSTATE:
    case LINE_CLOSE:
    case LINE_DEVSPECIFIC:
    case LINE_LINEDEVSTATE:
    {
        PDRVLINE    pLine;

        lRes = GetLineObjWithReadLock((HDRVLINE)ht_Line, &pLine);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        TspLog(DL_INFO, 
            "PE::fnLineEvent: msg(%x), line(%p), p1(%p), p2(%p), p3(%p)",
            ulMsg, pLine->htLine, 
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         (HTAPICALL)NULL,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)ht_Line);

        break;
    }
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLINFO:
    {
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        TspLog(DL_INFO,
            "PE::fnLineEvent: msg(%x), htline(%p), htcall(%p), "\
            "p1(%p), p2(%p), p3(%p)",
            ulMsg, pLine->htLine, pCall->htCall, 
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine, 
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    case LINE_CALLSTATE:
    {
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        // we may still receive a few events
        // for calls that have been closed/dropped
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        //
        // for outbound calls there exists a race condition between
        // receiving the first call state msg(s) and receiving the
        // make call completion notification (if we pass a call state
        // msg on to tapi for a call that hasn't been completed yet
        // tapi will just discard the msg since the htCall really
        // isn't valid at that point).  So if htCall references a
        // valid outbound call which hasn't completed yet, we'll save
        // the call state params, and pass them on to tapi after we
        // get & indicate a (successful) completion notification.
        //

        if ((OUTBOUND_CALL_KEY == pCall->dwKey) &&
            (TRUE == pCall->bIncomplete))
        {
            TspLog(DL_INFO, 
                   "ProcessEvent: incomplete outbound call, saving state");

            pCall->dwPendingCallState     = (DWORD)pEvent->ulParam1;
            pCall->dwPendingCallStateMode = (DWORD)pEvent->ulParam2;
            pCall->dwPendingMediaMode     = (DWORD)pEvent->ulParam3;

            ReleaseObjReadLock((HANDLE)pCall->hdCall);
            ReleaseObjReadLock((HANDLE)hdLine);
            break;
        }

        if (pCall->bIdle)
        {
            ReleaseObjReadLock((HANDLE)pCall->hdCall);
            ReleaseObjReadLock((HANDLE)hdLine);
            break;
        }
        else if (LINECALLSTATE_DISCONNECTED == pEvent->ulParam1 ||
                 LINECALLSTATE_IDLE == pEvent->ulParam1)
        {
            HDRVCALL    hdCall = pCall->hdCall;

            // we need to acquire a write lock to update bIdle,
            // make sure releasing the read lock before doing so.
            ReleaseObjReadLock((HANDLE)hdCall);

            lRes = AcquireObjWriteLock((HANDLE)hdCall);
            if (lRes != TAPI_SUCCESS)
            {
                TspLog(DL_WARNING,
                      "ProcessEvent: failed to acquire write lock for call(%p)",
                       hdCall);

                ReleaseObjReadLock((HANDLE)hdLine);
                break;
            }
            pCall->bIdle = TRUE;

            ReleaseObjWriteLock((HANDLE)hdCall);

            // reacquire the read lock
            lRes = AcquireObjReadLock((HANDLE)hdCall);
            if (lRes != TAPI_SUCCESS)
            {
                TspLog(DL_WARNING,
                     "ProcessEvent: failed to reacquire read lock for call(%p)",
                       hdCall);

                ReleaseObjReadLock((HANDLE)hdLine);
                break;
            }
        }

        TspLog(DL_INFO, 
               "PE::fnLineEvent(CALLSTATE): htline(%p), htcall(%p), "\
               "p1(%p), p2(%p), p3(%p)",
               pLine->htLine, pCall->htCall, 
               pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        //
        // For old style miniports we want to indicate an IDLE
        // immediately following the disconnected (several of
        // the initial NDIS WAN miniports did not indicate an
        // IDLE call state due to doc confusion)
        //

        if (LINECALLSTATE_DISCONNECTED == pEvent->ulParam1)
        {
            TspLog(DL_INFO, 
              "PE::fnLineEvent(CALLSTATE_IDLE): htline(%p), htcall(%p), p3(%p)",
               pLine->htLine, pCall->htCall, pEvent->ulParam3);

            (*gpfnLineEvent)(pLine->htLine,
                             pCall->htCall,
                             ulMsg,
                             (DWORD_PTR)LINECALLSTATE_IDLE,
                             (DWORD_PTR)0,
                             (DWORD_PTR)pEvent->ulParam3);
        }

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        break;
    }
    case LINE_NEWCALL:
    {
        HDRVCALL    hdCall;
        PDRVCALL    pCall;
        PDRVLINE    pLine;

        lRes = GetLineObjWithWriteLock((HDRVLINE)ht_Line, &pLine);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        // alloc & initialize a new DRVCALL object
        if (pCall = AllocCallObj(sizeof(DRVCALL)))
        {
            pCall->dwKey        = INBOUND_CALL_KEY;
            pCall->hd_Call      = (HDRV_CALL)pEvent->ulParam1;
            pCall->ht_Call      = (HTAPI_CALL)pEvent->ulParam2;
            pCall->hdLine       = (HDRVLINE)ht_Line;
            pCall->bIncomplete  = FALSE;
        }

        //
        // if the new call object allocation failed above then we
        // want to tell the driver to drop & close the call,
        // then just break
        //

        if (NULL == pCall)
        {
            PNDISTAPI_REQUEST       pNdisTapiRequestDrop;
            PNDISTAPI_REQUEST       pNdisTapiRequestCloseCall;
            PNDIS_TAPI_DROP         pNdisTapiDrop;
            PNDIS_TAPI_CLOSE_CALL   pNdisTapiCloseCall;

            if ((lRes = PrepareSyncRequest(
                    OID_TAPI_DROP,                  // opcode
                    pLine->dwDeviceID,              // device id
                    sizeof(NDIS_TAPI_DROP),         // size of drve req data
                    &pNdisTapiRequestDrop           // ptr to ptr to request buf
                 )) != TAPI_SUCCESS)
            {
                ReleaseObjWriteLock((HANDLE)ht_Line);
                break;
            }

            pNdisTapiDrop = (PNDIS_TAPI_DROP)pNdisTapiRequestDrop->Data;

            pNdisTapiDrop->hdCall = (HDRV_CALL) pEvent->ulParam1;
            pNdisTapiDrop->ulUserUserInfoSize = 0;

            SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequestDrop);
            FreeRequest(pNdisTapiRequestDrop);

            if ((lRes = PrepareSyncRequest(
                    OID_TAPI_CLOSE_CALL,            // opcode
                    pLine->dwDeviceID,              // device id
                    sizeof(NDIS_TAPI_CLOSE_CALL),   // size of drve req data
                    &pNdisTapiRequestCloseCall      // ptr to ptr to request buf
                 )) != TAPI_SUCCESS)
            {
                ReleaseObjWriteLock((HANDLE)ht_Line);
                break;
            }

            pNdisTapiCloseCall =
                (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequestCloseCall->Data;

            pNdisTapiCloseCall->hdCall = (HDRV_CALL) pEvent->ulParam1;

            SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO,
                              pNdisTapiRequestCloseCall);

            FreeRequest(pNdisTapiRequestCloseCall);

            ReleaseObjWriteLock((HANDLE)ht_Line);
            break;
        }

        ASSERT(pCall != NULL);

        pCall->dwDeviceID = pLine->dwDeviceID;

        // make sure releasing write lock before calling OpenObjHandle()
        // to avoid deadlock on acquiring write lock for the global mapper
        ReleaseObjWriteLock((HANDLE)ht_Line);

        lRes = OpenObjHandle(pCall, FreeCallObj, (HANDLE *)&hdCall);
        if (lRes != TAPI_SUCCESS)
        {
            TspLog(DL_ERROR, 
                   "ProcessEvent: failed to map obj(%p) to handle",
                   pCall);

            FreeCallObj(pCall);
            break;
        }

        // reacquire the write lock
        lRes = AcquireObjWriteLock((HANDLE)ht_Line);
        if (lRes != TAPI_SUCCESS)
        {
            TspLog(DL_ERROR,
                   "ProcessEvent: failed to reacquire write lock for obj(%p)",
                   ht_Line);

            CloseObjHandle((HANDLE)hdCall);
            break;
        }

        // save the TSP handle
        pCall->hdCall = hdCall;

        // send the LINE_NEWCALL to TAPI, getting back the TAPI call handle
        TspLog(DL_INFO,
           "PE::fnLineEvent(NEWCALL): htline(%p), call(%p)",
           pLine->htLine, hdCall);

        (*gpfnLineEvent)(pLine->htLine,
                         (HTAPICALL) NULL,
                         LINE_NEWCALL,
                         (DWORD_PTR)hdCall,
                         (DWORD_PTR)&pCall->htCall,
                         0);

        //
        // insert the new call into the line's inbound calls list
        // regardless of the result of the LINE_NEWCALL
        // if it failed, we'll destroy the call next, and 
        // TSPI_lineCloseCall will expect the call to be
        // in the line's inbound call list
        //
        if ((pCall->pNext = pLine->pInboundCalls) != NULL)
        {
            pCall->pNext->pPrev = pCall;
        }
        pLine->pInboundCalls = pCall;

        ReleaseObjWriteLock((HANDLE)ht_Line);

        //
        // if TAPI didn't create it's own representation of this
        // cal (if pCall->htCall == NULL), then either:
        //
        //   1) the line is in the process of being closed, or
        //   2) TAPI was unable to allocate the necessary resources
        //
        // ...so we'll close the call
        //
        if (NULL == pCall->htCall)
        {
            TspLog(DL_WARNING, "ProcessEvent: TAPI failed to create "
                   "its own handle for the new call, so we close the call");
            TSPI_lineCloseCall(hdCall);
        }

        break;
    }

    case LINE_CREATE:

        TspLog(DL_INFO,
           "PE::fnLineEvent(CREATE): ghProvider(%p), p2(%p), p3(%p)",
           ghProvider, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)((HTAPILINE) NULL,
                         (HTAPICALL) NULL,
                         ulMsg,
                         (DWORD_PTR)ghProvider,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        break;

    default:

        TspLog(DL_ERROR, "ProcessEvent: unknown msg(%x)", ulMsg);

        break;

    } // switch
}

//
// thread proc that retrieves and processes completed requests 
// and async events
//
VOID
AsyncEventsThread(
    LPVOID  lpParams
    )
{
    OVERLAPPED  overlapped;
    DWORD       cbReturned;

    //
    // send an IOCTL to retrieve async events
    //
    overlapped.hEvent = NULL;   // don't need event when using completion ports

    gpAsyncEventsThreadInfo->pBuf->ulTotalSize = 
         gpAsyncEventsThreadInfo->dwBufSize - sizeof(NDISTAPI_EVENT_DATA) + 1;

    gpAsyncEventsThreadInfo->pBuf->ulUsedSize = 0;

    if (DeviceIoControl(
            ghDriverAsync,
            IOCTL_NDISTAPI_GET_LINE_EVENTS,
            gpAsyncEventsThreadInfo->pBuf,
            sizeof(NDISTAPI_EVENT_DATA),
            gpAsyncEventsThreadInfo->pBuf,
            gpAsyncEventsThreadInfo->dwBufSize,
            &cbReturned,
            &overlapped
            ) != TRUE)
    {
        DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_IO_PENDING)
        {
            TspLog(DL_ERROR,
                   "AsyncEventsThread: IoCtl(GetEvent) failed(%d)",
                   dwLastError);
        }
        ASSERT(ERROR_IO_PENDING == dwLastError);
    }

    // loop waiting for completed requests and retrieving async events
    while (1)
    {
        BOOL                bRes;
        LPOVERLAPPED        lpOverlapped;
        PNDIS_TAPI_EVENT    pEvent;

        // wait for a request to complete
        while (1) {
            DWORD       dwNumBytesTransferred;
            DWORD_PTR   dwCompletionKey;

            bRes = GetQueuedCompletionStatus(
                        ghCompletionPort,
                        &dwNumBytesTransferred,
                        &dwCompletionKey,
                        &lpOverlapped,
                        (DWORD)-1);              // infinite wait

            if (bRes)
                {
                //
                // GetQueuedCompletion returned success so if our
                // overlapped field is non-NULL then process the
                // event.  If the overlapped field is NULL try
                // to get another event.
                //


        if (&gOverlappedTerminate==lpOverlapped)
                    {
                        
                        TspLog(DL_WARNING, "AsyncEventsThread: Got "\
                            "exit message from TSPI_providerShutdown");
                        return;
                    }
                
                if (lpOverlapped != NULL) 
                    {
                        break;
                  }

                

                TspLog(DL_WARNING,
                      "AsyncEventsThread: GetQueuedCompletionStatus "\
                      "lpOverlapped == NULL!");

            } else 
            {

                DWORD dwErr = GetLastError();

                if(ERROR_INVALID_HANDLE != dwErr)
                {
                     
                         // Error returned from GetQueuedCompletionStatus 
                     
                     TspLog(DL_ERROR, 
                            "AsyncEventsThread: GetQueuedCompletionStatus "\
                            "failed(%d)", dwErr);

                         Sleep(1);
                    }
                  else
                    {
                         ExitThread(0);
                    }
             }
        }

        //
        // check the returned overlapped struct to determine if
        // we have some events to process or a completed request
        //
        if (lpOverlapped == &overlapped)
        {
            DWORD   i;

            TspLog(DL_INFO, "AsyncEventsThread: got a line event");

            // handle the events
            pEvent = (PNDIS_TAPI_EVENT)gpAsyncEventsThreadInfo->pBuf->Data;

            for (i = 0;
                i < (gpAsyncEventsThreadInfo->pBuf->ulUsedSize / 
                     sizeof(NDIS_TAPI_EVENT));
                i++
                )
            {
                ProcessEvent(pEvent);
                pEvent++;
            }

            //
            // send another IOCTL to retrieve new async events
            //
            overlapped.hEvent = NULL;

            gpAsyncEventsThreadInfo->pBuf->ulTotalSize =
                 gpAsyncEventsThreadInfo->dwBufSize - 
                 sizeof(NDISTAPI_EVENT_DATA) + 1;

            gpAsyncEventsThreadInfo->pBuf->ulUsedSize = 0;

            if (DeviceIoControl(
                    ghDriverAsync,
                    IOCTL_NDISTAPI_GET_LINE_EVENTS,
                    gpAsyncEventsThreadInfo->pBuf,
                    sizeof(NDISTAPI_EVENT_DATA),
                    gpAsyncEventsThreadInfo->pBuf,
                    gpAsyncEventsThreadInfo->dwBufSize,
                    &cbReturned,
                    &overlapped
                    ) != TRUE)
            {
                DWORD dwLastError = GetLastError();
                if (dwLastError != ERROR_IO_PENDING) {
                    TspLog(DL_ERROR,
                           "AsyncEventsThread: IoCtl(GetEvent) failed(%d)",
                           dwLastError);
            
                    ASSERT(ERROR_IO_PENDING == dwLastError);   
                Sleep(1);
                }
            }
        }
        else
        {
            LONG                    lRes;
            DWORD                   dwRequestID;
            DWORD_PTR               callStateMsgParams[5];
            PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper = 
                                        (PASYNC_REQUEST_WRAPPER)lpOverlapped;

            TspLog(DL_INFO, "AsyncEventsThread: got a completed req");

            // verify that pointer is valid
            if (pAsyncReqWrapper->dwKey != ASYNCREQWRAPPER_KEY) {
                TspLog(DL_WARNING, "AsyncEventsThread: got a bogus req");
                continue;
            }

            dwRequestID = pAsyncReqWrapper->dwRequestID;

            // unmark the request now that the ioctl is completed
            UnmarkRequest(pAsyncReqWrapper);

            lRes = TranslateDriverResult(
                pAsyncReqWrapper->NdisTapiRequest.ulReturnValue
                );

            TspLog(DL_INFO, 
                  "AsyncEventsThread: req(%p) with reqID(%x) returned lRes(%x)",
                   pAsyncReqWrapper, dwRequestID, lRes);

            // call the post processing proc if appropriate
            callStateMsgParams[0] = 0;
            if (pAsyncReqWrapper->pfnPostProcess)
            {
                (*pAsyncReqWrapper->pfnPostProcess)(
                    pAsyncReqWrapper,
                    lRes,
                    callStateMsgParams
                    );
            }

            // free the async request wrapper
            DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

            // call completion proc
            TspLog(DL_TRACE, 
                   "AsyncEventsThread: call compproc with ReqID(%x), lRes(%x)",
                   dwRequestID, lRes);

            (*gpfnCompletionProc)(dwRequestID, lRes);

            // when outbounding call completes, we need to 
            // report back the saved call state
            if (callStateMsgParams[0])
            {
                TspLog(DL_INFO, 
                       "AsyncEventsThread: report back the saved call state");

                TspLog(DL_INFO, 
                       "AET::fnLineEvent(CALLSTATE): htline(%p), htcall(%p), "\
                       "p1(%p), p2(%p), p3(%p)",
                       callStateMsgParams[0], callStateMsgParams[1],
                       callStateMsgParams[2], callStateMsgParams[3],
                       callStateMsgParams[4]);

                (*gpfnLineEvent)((HTAPILINE)(callStateMsgParams[0]),
                                 (HTAPICALL)(callStateMsgParams[1]),
                                 LINE_CALLSTATE,
                                 callStateMsgParams[2],
                                 callStateMsgParams[3],
                                 callStateMsgParams[4]);
            }
        }
    } // while
}

HDRV_CALL
GetNdisTapiHandle(
    PDRVCALL pCall,
    LONG *plRes
    )
{
    HDRVCALL hdCall;
    PDRVCALL pCallLocal = pCall;
    LONG lRes;
    
    ASSERT(pCallLocal != NULL);

    hdCall  = pCall->hdCall;

    if(plRes != NULL)
    {
        *plRes = TAPI_SUCCESS;
    }

    //
    // if the call is outbound, wait until the make call request
    // has completed so we don't send a bad NDISTAPI handle down
    // to the driver
    //
    if (OUTBOUND_CALL_KEY == pCallLocal->dwKey)
    {
        ASSERT(plRes != NULL);
        
        if (pCallLocal->bIncomplete)
        {
            TspLog(DL_INFO, 
                "GetNdisTapiHandle: wait for the outbound call to complete...");

            do
            {
                ASSERT(plRes != NULL);
                
                //
                // Release the lock before going to sleep.
                // otherwise we get into a deadlock.
                //
                ReleaseObjReadLock((HANDLE) hdCall);
                Sleep(250);
                
                //
                // ReAcquire Lock. break if we can't
                //
                lRes = GetCallObjWithReadLock(hdCall, &pCallLocal);
                if(lRes != TAPI_SUCCESS)
                {
                    *plRes = lRes;
                    break;
                }
                
            } while (pCallLocal->bIncomplete);
        }
    }

    return pCall->hd_Call;
}

DWORD
GetDestAddressLength(
    LPCWSTR             lpszDestAddress,
    DWORD               dwOrgDALength, 
    UINT                *pCodePage
    )
{
   DWORD dwLength;
   
   ASSERT(lpszDestAddress != NULL);
   ASSERT(pCodePage != NULL);

   if (*pCodePage == CP_ACP)
   {
      // If code page is CP_ACP, return the original length to
      // keep the old behavior.
      dwLength = dwOrgDALength; 
   }
   else
   {
      dwLength = WideCharToMultiByte(
                         *pCodePage,
                         0,
                         lpszDestAddress,
                         dwOrgDALength,
                         NULL,
                         0,
                         NULL,
                         NULL
                         );
                         
      if (dwLength == 0)                         
      {
         // WideCharToMultiByte() failed, use CP_ACP to show
         // the old behavior.
         *pCodePage = CP_ACP;

         dwLength = dwOrgDALength; 
      }
   }      

   return dwLength;
}

//
// TSPI_lineXXX functions
//
LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_ACCEPT       pNdisTapiAccept;

    TspLog(DL_TRACE, "lineAccept(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_ACCEPT,                   // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_ACCEPT) + dwSize, // size of drv request data
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiAccept =
        (PNDIS_TAPI_ACCEPT)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiAccept->hdCall = GetNdisTapiHandle(pCall, NULL);

    if ((pNdisTapiAccept->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiAccept->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_ANSWER       pNdisTapiAnswer;

    TspLog(DL_TRACE, "lineAnswer(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_ANSWER,                   // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_ANSWER) + dwSize, // size of drv request data
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiAnswer =
        (PNDIS_TAPI_ANSWER)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiAnswer->hdCall = GetNdisTapiHandle(pCall, NULL);

    if ((pNdisTapiAnswer->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiAnswer->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine;
    PNDISTAPI_REQUEST   pNdisTapiRequest;
    PNDIS_TAPI_CLOSE    pNdisTapiClose;

    TspLog(DL_TRACE, "lineClose(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_CLOSE,             // opcode
             pLine->dwDeviceID,          // device id
             sizeof(NDIS_TAPI_CLOSE),    // size of drve req data
             &pNdisTapiRequest           // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiClose = (PNDIS_TAPI_CLOSE)pNdisTapiRequest->Data;

    // mark line as invalid so any related events that show up
    // will be discarded.
    pLine->dwKey = INVALID_KEY;

    pNdisTapiClose->hdLine = pLine->hd_Line;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    FreeRequest(pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        lRes = DecommitNegotiatedTSPIVersion(pLine->dwDeviceID);
    }

    ReleaseObjWriteLock((HANDLE)hdLine);

    // release line resources
    CloseObjHandle((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    HDRVLINE                hdLine;
    PDRVLINE                pLine;
    PDRVCALL                pCall;
    PNDISTAPI_REQUEST       pNdisTapiRequestCloseCall;
    PNDIS_TAPI_CLOSE_CALL   pNdisTapiCloseCall;
    BOOL                    bInboundCall;
    HDRV_CALL               NdisTapiHandle;

    TspLog(DL_TRACE, "lineCloseCall(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    //
    // Initially we can't acquire the write lock directly
    // because we might spin-wait in GetNdisTapiHandle so
    // we grab the readlock instead.
    //
    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    bInboundCall = (INBOUND_CALL_KEY == pCall->dwKey);

    NdisTapiHandle = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE) hdLine);
        return lRes;
    }

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);

    //
    // Now acquire the write lock
    //
    lRes = AcquireObjWriteLock((HANDLE)hdLine);
    if (lRes != TAPI_SUCCESS) {
        return lRes;
    }

    lRes = AcquireObjWriteLock((HANDLE)hdCall);
    if (lRes != TAPI_SUCCESS) {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
            OID_TAPI_CLOSE_CALL,            // opcode
            pCall->dwDeviceID,              // device id
            sizeof(NDIS_TAPI_CLOSE_CALL),   // size of drve req data
            &pNdisTapiRequestCloseCall      // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    // @@@ for legacy NDISWAN ISDN miniports:
    // since there's no more "automatic" call dropping in
    // TAPI when an app has closed the line & there are
    // existing non-IDLE calls, legacy NDIS WAN ISDN miniports
    // rely on seeing an OID_TAPI_DROP, we need to synthesize
    // this behavior if the call has not previously be dropped.
    if (!pCall->bDropped)
    {
        PNDISTAPI_REQUEST  pNdisTapiRequestDrop;
        PNDIS_TAPI_DROP pNdisTapiDrop;

        TspLog(DL_INFO, "lineCloseCall: synthesize DROP req");

        if ((lRes = PrepareSyncRequest(
                OID_TAPI_DROP,                  // opcode
                pCall->dwDeviceID,              // device id
                sizeof(NDIS_TAPI_DROP),         // size of drve req data
                &pNdisTapiRequestDrop           // ptr to ptr to request buffer
             )) != TAPI_SUCCESS)
        {
            FreeRequest(pNdisTapiRequestCloseCall);

            ReleaseObjWriteLock((HANDLE)hdCall);
            ReleaseObjWriteLock((HANDLE)hdLine);
            return lRes;
        }

        pNdisTapiDrop = (PNDIS_TAPI_DROP)pNdisTapiRequestDrop->Data;

        pNdisTapiDrop->hdCall = NdisTapiHandle;

        lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequestDrop);
        // done with the drop sync req
        FreeRequest(pNdisTapiRequestDrop);

        if (lRes != TAPI_SUCCESS)
        {
            FreeRequest(pNdisTapiRequestCloseCall);

            ReleaseObjWriteLock((HANDLE)hdCall);
            ReleaseObjWriteLock((HANDLE)hdLine);
            return lRes;
        }
    }

    // mark the call as bad so any events get discarded
    pCall->dwKey = INVALID_KEY;

    // set up the params & call the driver
    pNdisTapiCloseCall = (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequestCloseCall->Data;
    pNdisTapiCloseCall->hdCall = NdisTapiHandle;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO,
                             pNdisTapiRequestCloseCall);
    FreeRequest(pNdisTapiRequestCloseCall);

    // if inbound call, remove it from the list
    if (bInboundCall)
    {
        if (pCall->pNext)
        {
            pCall->pNext->pPrev = pCall->pPrev;
        }
        if (pCall->pPrev)
        {
            pCall->pPrev->pNext = pCall->pNext;
        }
        else
        {
            pLine->pInboundCalls = pCall->pNext;
        }
    }

    ReleaseObjWriteLock((HANDLE)hdCall);
    ReleaseObjWriteLock((HANDLE)hdLine);

    // free the call struct now that the call is closed
    CloseObjHandle((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static DWORD                            dwSum = 0;
    LONG                                    lRes;
    PDRVLINE                                pLine;
    PNDISTAPI_REQUEST                       pNdisTapiRequest;
    PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION  pNdisTapiConditionalMediaDetection;

    TspLog(DL_TRACE, "lineConditionalMediaDetection(%d): line(%p), mode(%x)", 
           ++dwSum, hdLine, dwMediaModes);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_CONDITIONAL_MEDIA_DETECTION,      // opcode
             pLine->dwDeviceID,                         // device id
             sizeof(NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION) +
             (lpCallParams->dwTotalSize - sizeof(LINE_CALL_PARAMS)),
             &pNdisTapiRequest                          // ptr to ptr to 
                                                        // req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiConditionalMediaDetection =
        (PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION) pNdisTapiRequest->Data;

    pNdisTapiConditionalMediaDetection->hdLine = pLine->hd_Line;
    pNdisTapiConditionalMediaDetection->ulMediaModes = dwMediaModes;

    CopyMemory(
        &pNdisTapiConditionalMediaDetection->LineCallParams,
        lpCallParams,
        lpCallParams->dwTotalSize
        );

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
PASCAL
TSPI_lineDevSpecific_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    TspLog(DL_TRACE, "lineDevSpecific_post: lRes(%x)", lRes);

    if (TAPI_SUCCESS == lRes)
    {
        PNDIS_TAPI_DEV_SPECIFIC pNdisTapiDevSpecific =
            (PNDIS_TAPI_DEV_SPECIFIC)pAsyncReqWrapper->NdisTapiRequest.Data;

        CopyMemory(
            (LPVOID) pAsyncReqWrapper->dwRequestSpecific,
            pNdisTapiDevSpecific->Params,
            pNdisTapiDevSpecific->ulParamsSize
            );
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVLINE                pLine;
    PDRVCALL                pCall = NULL;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DEV_SPECIFIC pNdisTapiDevSpecific;

    TspLog(DL_TRACE, 
           "lineDevSpecific(%d): reqID(%x), line(%p), addressID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdLine, dwAddressID, hdCall);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DEV_SPECIFIC,             // opcode
             pLine->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DEV_SPECIFIC) +   // size of drv request data
             (dwSize - 1),
             &pAsyncReqWrapper                  // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiDevSpecific = 
        (PNDIS_TAPI_DEV_SPECIFIC)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDevSpecific->hdLine = pLine->hd_Line;
    pNdisTapiDevSpecific->ulAddressID = dwAddressID;

    if (hdCall)
    {
        lRes = GetCallObjWithReadLock(hdCall, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            FreeRequest(pAsyncReqWrapper);

            ReleaseObjReadLock((HANDLE)hdLine);
            return lRes;
        }
        pNdisTapiDevSpecific->hdCall = GetNdisTapiHandle(pCall, &lRes);
        if(lRes != TAPI_SUCCESS)
        {   
            FreeRequest(pAsyncReqWrapper);
            return lRes;
        }
    }
    else
    {
        pNdisTapiDevSpecific->hdCall = (HDRV_CALL)NULL;
    }

    pNdisTapiDevSpecific->ulParamsSize = dwSize;
    CopyMemory(pNdisTapiDevSpecific->Params, lpParams, dwSize);

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)lpParams;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineDevSpecific_postProcess;

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    if (pCall != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
    }
    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    DWORD                   dwLength = lstrlenW (lpszDestAddress) + 1;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DIAL         pNdisTapiDial;

    TspLog(DL_TRACE, "lineDial(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DIAL,                     // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DIAL) + dwLength, // size of driver req buffer
             &pAsyncReqWrapper                  // ptr to ptr to req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiDial =
        (PNDIS_TAPI_DIAL)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDial->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiDial->ulDestAddressSize = dwLength;

    WideCharToMultiByte(CP_ACP, 0, lpszDestAddress, 
                        -1, (LPSTR)pNdisTapiDial->szDestAddress,
                        dwLength, NULL, NULL);

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
PASCAL
TSPI_lineDrop_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    BOOL        bSendCallStateIdleMsg = FALSE;
    LONG        lSuc;
    HDRVLINE    hdLine;
    HDRVCALL    hdCall;
    PDRVLINE    pLine;
    PDRVCALL    pCall; 
    HTAPILINE   htLine;
    HTAPICALL   htCall;

    TspLog(DL_TRACE, "lineDrop_post: lRes(%x)", lRes);

    hdCall = (HDRVCALL)(pAsyncReqWrapper->dwRequestSpecific);

    lSuc = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetLineObjWithReadLock(hdLine, &pLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetCallObjWithWriteLock(hdCall, &pCall);
    if (lSuc != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lSuc;
    }

    //
    // @@@ Some old-style miniports, notably pcimac, don't indicate 
    // IDLE msgs when they get a drop request- so we synthesize this 
    // for them (only if and IDLE hasn't already been sent)
    //

    if (TAPI_SUCCESS == lRes)
    {
        ASSERT(INBOUND_CALL_KEY == pCall->dwKey ||
               OUTBOUND_CALL_KEY == pCall->dwKey);

        htCall = pCall->htCall;
        htLine = pLine->htLine;

        if (!pCall->bIdle)
        {
            pCall->bIdle = bSendCallStateIdleMsg = TRUE;
        }

        if (bSendCallStateIdleMsg)
        {
            TspLog(DL_INFO, 
                "postDrop::fnLineEvent(CALLSTATE_IDLE): htline(%p), htcall(%p)",
                   htLine, htCall);

            (*gpfnLineEvent)(htLine,
                             htCall,
                             LINE_CALLSTATE,
                             LINECALLSTATE_IDLE,
                             0,
                             0);
        }
    }

    ReleaseObjWriteLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DROP         pNdisTapiDrop;
    HDRV_CALL               NdisTapiHandle;

    TspLog(DL_TRACE, "lineDrop(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    NdisTapiHandle = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    ReleaseObjReadLock((HANDLE)hdCall);

    lRes = AcquireObjWriteLock((HANDLE)hdCall);
    if (lRes != TAPI_SUCCESS) {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DROP,                     // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DROP) + dwSize,   // size of driver req buffer
             &pAsyncReqWrapper                  // ptr to ptr to req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiDrop =
        (PNDIS_TAPI_DROP)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDrop->hdCall = NdisTapiHandle;

    //
    // @@@: the following is for legacy NDISWAN ISDN miniports
    //
    // Safely mark the call as dropped so the CloseCall code
    // won't follow up with another "automatic" drop
    //
    pCall->bDropped = TRUE;

    if ((pNdisTapiDrop->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiDrop->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)hdCall;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineDrop_postProcess;

    ReleaseObjWriteLock((HANDLE)hdCall);

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_ADDRESS_CAPS          pCaps;
    PNDIS_TAPI_GET_ADDRESS_CAPS pNdisTapiGetAddressCaps;

    TspLog(DL_TRACE, 
           "lineGetAddressCaps(%d): deviceID(%x), addressID(%x), "\
           "TSPIV(%x), ExtV(%x)",
           ++dwSum, dwDeviceID, dwAddressID);


    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_CAPS,             // opcode
             dwDeviceID,                            // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_CAPS) +   // size of req data
             (lpAddressCaps->dwTotalSize - sizeof(LINE_ADDRESS_CAPS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetAddressCaps =
        (PNDIS_TAPI_GET_ADDRESS_CAPS)pNdisTapiRequest->Data;

    pNdisTapiGetAddressCaps->ulDeviceID = dwDeviceID;
    pNdisTapiGetAddressCaps->ulAddressID = dwAddressID;
    pNdisTapiGetAddressCaps->ulExtVersion = dwExtVersion;

    pCaps = &pNdisTapiGetAddressCaps->LineAddressCaps;
    pCaps->ulTotalSize  = lpAddressCaps->dwTotalSize;
    pCaps->ulNeededSize = pCaps->ulUsedSize = sizeof (LINE_ADDRESS_CAPS);

    ZeroMemory(
        &pCaps->ulLineDeviceID, 
        sizeof(LINE_ADDRESS_CAPS) - 3 * sizeof(ULONG)
        );

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //

    lpAddressCaps->dwNeededSize =
        pCaps->ulNeededSize +
        (sizeof(LINEADDRESSCAPS) -         // v2.0 struct
            sizeof(LINE_ADDRESS_CAPS)) +   // v1.0 struct
        (pCaps->ulNeededSize - sizeof(LINE_ADDRESS_CAPS));


    //
    // Copy over the fixed fields that don't need changing, i.e.
    // everything from dwAddressSharing to dwCallCompletionModes
    //

    lpAddressCaps->dwLineDeviceID = dwDeviceID;

    CopyMemory(
        &lpAddressCaps->dwAddressSharing,
        &pCaps->ulAddressSharing,
        sizeof(LINE_ADDRESS_CAPS) - (12 * sizeof(DWORD))
        );

    if (lpAddressCaps->dwNeededSize > lpAddressCaps->dwTotalSize)
    {
        lpAddressCaps->dwUsedSize =
            (lpAddressCaps->dwTotalSize < sizeof(LINEADDRESSCAPS) ?
            lpAddressCaps->dwTotalSize : sizeof(LINEADDRESSCAPS));
    }
    else
    {
        lpAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS); // v2.0 struct

        INSERTVARDATASTRING(
            pCaps,
            &pCaps->ulAddressSize,
            lpAddressCaps,
            &lpAddressCaps->dwAddressSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.Address"
            );

        INSERTVARDATA(
            pCaps,
            &pCaps->ulDevSpecificSize,
            lpAddressCaps,
            &lpAddressCaps->dwDevSpecificSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.DevSpecific"
            );

        if (pCaps->ulCompletionMsgTextSize != 0)
        {
            // @@@ convert ComplMsgText to unicode???
            INSERTVARDATA(
                pCaps,
                &pCaps->ulCompletionMsgTextSize,
                lpAddressCaps,
                &lpAddressCaps->dwCompletionMsgTextSize,
                sizeof (LINE_ADDRESS_CAPS),
                "LINE_ADDRESS_CAPS.CompletionMsgText"
                );

            lpAddressCaps->dwNumCompletionMessages =
                pCaps->ulNumCompletionMessages;
            lpAddressCaps->dwCompletionMsgTextEntrySize =
                pCaps->ulCompletionMsgTextEntrySize;
        }

        // make sure dwNeededSize == dwUsedSize
        lpAddressCaps->dwNeededSize = lpAddressCaps->dwUsedSize;
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVLINE                    pLine;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_GET_ADDRESS_ID   pNdisTapiGetAddressID;

    TspLog(DL_TRACE, "lineGetAddressID(%d): line(%p), addressMode(%x)", 
           ++dwSum, hdLine, dwAddressMode);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_ID,           // opcode
             pLine->dwDeviceID,                 // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_ID) + // size of req data
             dwSize / 2 - 1,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetAddressID = (PNDIS_TAPI_GET_ADDRESS_ID)pNdisTapiRequest->Data;

    pNdisTapiGetAddressID->hdLine = pLine->hd_Line;
    pNdisTapiGetAddressID->ulAddressMode = dwAddressMode;
    pNdisTapiGetAddressID->ulAddressSize = dwSize / 2;

    WideCharToMultiByte(CP_ACP, 0, lpsAddress, dwSize,
            (LPSTR)pNdisTapiGetAddressID->szAddress, dwSize / 2, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwAddressID = pNdisTapiGetAddressID->ulAddressID;

        TspLog(DL_INFO, "lineGetAddressID: addressID(%x)", *lpdwAddressID);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PLINE_ADDRESS_STATUS            pStatus;
    PNDIS_TAPI_GET_ADDRESS_STATUS   pNdisTapiGetAddressStatus;

    TspLog(DL_TRACE, "lineGetAddressStatus(%d): line(%p), addressID(%x)", 
           ++dwSum, hdLine, dwAddressID);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_STATUS,           // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_STATUS) + // size of req data
             (lpAddressStatus->dwTotalSize - sizeof(LINE_ADDRESS_STATUS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetAddressStatus =
        (PNDIS_TAPI_GET_ADDRESS_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetAddressStatus->hdLine = pLine->hd_Line;
    pNdisTapiGetAddressStatus->ulAddressID = dwAddressID;

    pStatus = &pNdisTapiGetAddressStatus->LineAddressStatus;

    pStatus->ulTotalSize = lpAddressStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_ADDRESS_STATUS);

    ZeroMemory(&pStatus->ulNumInUse, 
               sizeof(LINE_ADDRESS_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpAddressStatus,
            &pNdisTapiGetAddressStatus->LineAddressStatus,
            pNdisTapiGetAddressStatus->LineAddressStatus.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVCALL                        pCall;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_GET_CALL_ADDRESS_ID  pNdisTapiGetCallAddressID;

    TspLog(DL_TRACE, "lineGetCallAddressID(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_ADDRESS_ID,          // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_ADDRESS_ID), // size of req data
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallAddressID =
        (PNDIS_TAPI_GET_CALL_ADDRESS_ID)pNdisTapiRequest->Data;

    pNdisTapiGetCallAddressID->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwAddressID = pNdisTapiGetCallAddressID->ulAddressID;
        TspLog(DL_INFO, "lineGetCallAddressID: addressID(%x)", *lpdwAddressID);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_CALL_INFO             pInfo;
    PNDIS_TAPI_GET_CALL_INFO    pNdisTapiGetCallInfo;

    TspLog(DL_TRACE, "lineGetCallInfo(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_INFO,                // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_INFO) +      // size of req data
             (lpCallInfo->dwTotalSize - sizeof(LINE_CALL_INFO)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallInfo = (PNDIS_TAPI_GET_CALL_INFO)pNdisTapiRequest->Data;

    pNdisTapiGetCallInfo->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    pInfo = &pNdisTapiGetCallInfo->LineCallInfo;

    pInfo->ulTotalSize = lpCallInfo->dwTotalSize;
    pInfo->ulNeededSize = pInfo->ulUsedSize = sizeof(LINE_CALL_INFO);

    ZeroMemory(&pInfo->hLine, sizeof(LINE_CALL_INFO) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //

    lpCallInfo->dwNeededSize =
        pInfo->ulNeededSize +
        (sizeof(LINECALLINFO) -        // v2.0 struct
            sizeof(LINE_CALL_INFO)) +  // v1.0 struct
        (pInfo->ulNeededSize - sizeof(LINE_CALL_INFO));

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwLineDeviceID to dwTrunk
    //

    CopyMemory(
        &lpCallInfo->dwLineDeviceID,
        &pInfo->ulLineDeviceID,
        23 * sizeof(DWORD)
        );

    if (lpCallInfo->dwNeededSize > lpCallInfo->dwTotalSize)
    {
        lpCallInfo->dwUsedSize =
            (lpCallInfo->dwTotalSize < sizeof(LINECALLINFO) ?
            lpCallInfo->dwTotalSize : sizeof(LINECALLINFO));
    }
    else
    {
        lpCallInfo->dwUsedSize = sizeof(LINECALLINFO); // v2.0 struct

        lpCallInfo->dwCallerIDFlags = pInfo->ulCallerIDFlags;

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulCallerIDSize,
            lpCallInfo,
            &lpCallInfo->dwCallerIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CallerID"
            );

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulCallerIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwCallerIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CallerIDName"
            );

        lpCallInfo->dwCalledIDFlags = pInfo->ulCalledIDFlags;

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulCalledIDSize,
            lpCallInfo,
            &lpCallInfo->dwCalledIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CalledID"
            );

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulCalledIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwCalledIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CalledIDName"
            );

        lpCallInfo->dwConnectedIDFlags = pInfo->ulConnectedIDFlags;

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulConnectedIDSize,
            lpCallInfo,
            &lpCallInfo->dwConnectedIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ConnectID"
            );

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulConnectedIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwConnectedIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ConnectIDName"
            );

        lpCallInfo->dwRedirectionIDFlags = pInfo->ulRedirectionIDFlags;

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulRedirectionIDSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectionIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectionID"
            );

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulRedirectionIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectionIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectionIDName"
            );

        lpCallInfo->dwRedirectingIDFlags = pInfo->ulRedirectingIDFlags;

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulRedirectingIDSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectingIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectingID"
            );

        INSERTVARDATASTRING(
            pInfo,
            &pInfo->ulRedirectingIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectingIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectingIDName"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulDisplaySize,
            lpCallInfo,
            &lpCallInfo->dwDisplaySize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.Display"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulUserUserInfoSize,
            lpCallInfo,
            &lpCallInfo->dwUserUserInfoSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.UserUserInfo"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulHighLevelCompSize,
            lpCallInfo,
            &lpCallInfo->dwHighLevelCompSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.HighLevelComp"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulLowLevelCompSize,
            lpCallInfo,
            &lpCallInfo->dwLowLevelCompSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.LowLevelComp"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulChargingInfoSize,
            lpCallInfo,
            &lpCallInfo->dwChargingInfoSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ChargingInfo"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulTerminalModesSize,
            lpCallInfo,
            &lpCallInfo->dwTerminalModesSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.TerminalModes"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulDevSpecificSize,
            lpCallInfo,
            &lpCallInfo->dwDevSpecificSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.DevSpecific"
            );

        // make sure that dwNeededSize == dwUsedSize
        lpCallInfo->dwNeededSize = lpCallInfo->dwUsedSize;
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_CALL_STATUS           pStatus;
    PNDIS_TAPI_GET_CALL_STATUS  pNdisTapiGetCallStatus;

    TspLog(DL_TRACE, "lineGetCallStatus(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_STATUS,              // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_STATUS) +    // size of req data
             (lpCallStatus->dwTotalSize - sizeof(LINE_CALL_STATUS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallStatus = (PNDIS_TAPI_GET_CALL_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetCallStatus->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    pStatus = &pNdisTapiGetCallStatus->LineCallStatus;

    pStatus->ulTotalSize = lpCallStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_CALL_STATUS);
    
    ZeroMemory(&pStatus->ulCallState, 
               sizeof(LINE_CALL_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // (no embedded ascii strings to convert to unicode)
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields. (There are no embedded ascii strings to
    // convert to unicode, so no extra space needed for that.)
    //

    lpCallStatus->dwNeededSize =
        pStatus->ulNeededSize +
        (sizeof(LINECALLSTATUS) -      // v2.0 struct
            sizeof(LINE_CALL_STATUS)); // v1.0 struct

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwLineDeviceID to dwCallCompletionModes
    //

    CopyMemory(
        &lpCallStatus->dwCallState,
        &pStatus->ulCallState,
        4 * sizeof(DWORD)
        );

    if (lpCallStatus->dwNeededSize > lpCallStatus->dwTotalSize)
    {
        lpCallStatus->dwUsedSize =
            (lpCallStatus->dwTotalSize < sizeof(LINECALLSTATUS) ?
            lpCallStatus->dwTotalSize : sizeof(LINECALLSTATUS));
    }
    else
    {
        lpCallStatus->dwUsedSize = sizeof(LINECALLSTATUS);
                                                        // v2.0 struct
        INSERTVARDATA(
            pStatus,
            &pStatus->ulDevSpecificSize,
            lpCallStatus,
            &lpCallStatus->dwDevSpecificSize,
            sizeof(LINE_CALL_STATUS),
            "LINE_CALL_STATUS.DevSpecific"
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LINEDEVCAPS *
GetLineDevCaps(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    LONG                    lRes;
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PLINE_DEV_CAPS          pCaps;
    PNDIS_TAPI_GET_DEV_CAPS pNdisTapiGetDevCaps;
    DWORD                   dwNeededSize;
    LINEDEVCAPS            *pLineDevCaps;
    DWORD                   dwTotalSize = sizeof(LINEDEVCAPS) + 0x80;

get_caps:
    pLineDevCaps = (LINEDEVCAPS *)MALLOC(dwTotalSize);
    if (NULL == pLineDevCaps)
    {
        TspLog(DL_ERROR, "GetLineDevCaps: failed to alloc mem of size(%x)", 
               dwTotalSize);
        return NULL;
    }

    pLineDevCaps->dwTotalSize = dwTotalSize;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_DEV_CAPS,             // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_DEV_CAPS) +   // size of req data
             (dwTotalSize - sizeof(LINE_DEV_CAPS)),
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return NULL;
    }

    pNdisTapiGetDevCaps = (PNDIS_TAPI_GET_DEV_CAPS)pNdisTapiRequest->Data;

    pNdisTapiGetDevCaps->ulDeviceID = dwDeviceID;
    pNdisTapiGetDevCaps->ulExtVersion = dwExtVersion;

    pCaps = &pNdisTapiGetDevCaps->LineDevCaps;

    pCaps->ulTotalSize = dwTotalSize;
    pCaps->ulNeededSize = pCaps->ulUsedSize = sizeof(LINE_DEV_CAPS);

    ZeroMemory(&pCaps->ulProviderInfoSize,
               sizeof(LINE_DEV_CAPS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return NULL;
    }

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //
    TspLog(DL_TRACE, 
           "GetLineDevCaps: ulNeeded(%x), LINEDEVCAPS(%x), LINE_DEV_CAPS(%x)",
           pCaps->ulNeededSize, sizeof(LINEDEVCAPS), sizeof(LINE_DEV_CAPS));

    dwNeededSize = 
        pCaps->ulNeededSize +
        (sizeof(LINEDEVCAPS) -         // v2.0 struct
            sizeof(LINE_DEV_CAPS)) +   // v1.0 struct
        (pCaps->ulNeededSize - sizeof(LINE_DEV_CAPS));

    TspLog(DL_TRACE, "GetLineDevCaps: dwNeededSize(%x), dwTotalSize(%x)",
           dwNeededSize, dwTotalSize);

    if (dwNeededSize > dwTotalSize)
    {
        // free up the old req
        FreeRequest(pNdisTapiRequest);

        // free the old buffer
        FREE(pLineDevCaps);

        // try again with a larger buffer
        dwTotalSize = dwNeededSize;
        goto get_caps;
    }

    ASSERT(dwNeededSize <= dwTotalSize);

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwPermanentLineID to dwNumTerminals
    //
    CopyMemory(
        &pLineDevCaps->dwPermanentLineID,
        &pCaps->ulPermanentLineID,
        sizeof(LINE_DEV_CAPS) - (14 * sizeof(DWORD))
        );

    // set the local flag to indicate that 
    // the line can't be used from remote machine
    pLineDevCaps->dwDevCapFlags |= LINEDEVCAPFLAGS_LOCAL;

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    pLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS); // v2.0 struct

    INSERTVARDATASTRING(
        pCaps,
        &pCaps->ulProviderInfoSize,
        pLineDevCaps,
        &pLineDevCaps->dwProviderInfoSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.ProviderInfo"
        );

    INSERTVARDATASTRING(
        pCaps,
        &pCaps->ulSwitchInfoSize,
        pLineDevCaps,
        &pLineDevCaps->dwSwitchInfoSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.SwitchInfo"
        );

    INSERTVARDATASTRING(
        pCaps,
        &pCaps->ulLineNameSize,
        pLineDevCaps,
        &pLineDevCaps->dwLineNameSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.LineName"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulTerminalCapsSize,
        pLineDevCaps,
        &pLineDevCaps->dwTerminalCapsSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.TerminalCaps"
        );

    // @@@ convert DevCaps.TermText to unicode???

    pLineDevCaps->dwTerminalTextEntrySize =
        pCaps->ulTerminalTextEntrySize;

    INSERTVARDATA(
        pCaps,
        &pCaps->ulTerminalTextSize,
        pLineDevCaps,
        &pLineDevCaps->dwTerminalTextSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.TerminalText"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulDevSpecificSize,
        pLineDevCaps,
        &pLineDevCaps->dwDevSpecificSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.DevSpecific"
        );

    // make sure dwNeededSize == dwUsedSize
    pLineDevCaps->dwNeededSize = pLineDevCaps->dwUsedSize;

    FreeRequest(pNdisTapiRequest);
    return pLineDevCaps;
}

LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;

    TspLog(DL_TRACE, "lineGetDevCaps(%d): deviceID(%x), TSPIV(%x), ExtV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion, dwExtVersion);

    lRes = GetDevCaps(dwDeviceID, dwTSPIVersion, dwExtVersion, lpLineDevCaps);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD       dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR     lpszDeviceClass
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwLength = lstrlenW (lpszDeviceClass) + 1;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PVAR_STRING                 pConfig;
    PNDIS_TAPI_GET_DEV_CONFIG   pNdisTapiGetDevConfig;

    TspLog(DL_TRACE, "lineGetDevConfig(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_DEV_CONFIG,           // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_DEV_CONFIG) + // size of req data
             (lpDeviceConfig->dwTotalSize - sizeof(VAR_STRING)) + dwLength,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetDevConfig = (PNDIS_TAPI_GET_DEV_CONFIG)pNdisTapiRequest->Data;

    pNdisTapiGetDevConfig->ulDeviceID = dwDeviceID;
    pNdisTapiGetDevConfig->ulDeviceClassSize = dwLength;
    pNdisTapiGetDevConfig->ulDeviceClassOffset =
        sizeof(NDIS_TAPI_GET_DEV_CONFIG) + 
        (lpDeviceConfig->dwTotalSize - sizeof(VAR_STRING));

    pConfig = &pNdisTapiGetDevConfig->DeviceConfig;
    pConfig->ulTotalSize = lpDeviceConfig->dwTotalSize;
    pConfig->ulNeededSize = pConfig->ulUsedSize = sizeof(VAR_STRING);

    pConfig->ulStringFormat = 
    pConfig->ulStringSize = 
    pConfig->ulStringOffset = 0;
    
    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(CP_ACP, 0, lpszDeviceClass, -1,
        (LPSTR) (((LPBYTE) pNdisTapiGetDevConfig) +
            pNdisTapiGetDevConfig->ulDeviceClassOffset),
        dwLength, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpDeviceConfig,
            &pNdisTapiGetDevConfig->DeviceConfig,
            pNdisTapiGetDevConfig->DeviceConfig.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_GET_EXTENSION_ID pNdisTapiGetExtensionID;

    TspLog(DL_TRACE, "lineGetExtensionID(%d): deviceID(%x), TSPIV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_EXTENSION_ID,             // opcode
             dwDeviceID,                            // device id
             sizeof(NDIS_TAPI_GET_EXTENSION_ID),    // size of req data
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetExtensionID =
        (PNDIS_TAPI_GET_EXTENSION_ID)pNdisTapiRequest->Data;

    pNdisTapiGetExtensionID->ulDeviceID = dwDeviceID;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpExtensionID,
            &pNdisTapiGetExtensionID->LineExtensionID,
            sizeof(LINE_EXTENSION_ID)
            );
    }
    else
    {
        //
        // Rather than indicating a failure, we'll just zero out the
        // ext id (implying driver doesn't support extensions) and
        // return success to tapisrv so it'll complete the open ok
        //
        ZeroMemory(lpExtensionID, sizeof(LINE_EXTENSION_ID));

        lRes = TAPI_SUCCESS;
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine = NULL;
    PDRVCALL            pCall = NULL;
    PNDISTAPI_REQUEST   pNdisTapiRequest;
    DWORD               dwLength = lstrlenW(lpszDeviceClass) + 1;
    DWORD               dwDeviceID;
    PUCHAR              pchDest;
    PVAR_STRING         pID;
    PNDIS_TAPI_GET_ID   pNdisTapiGetID;

    TspLog(DL_TRACE, 
           "lineGetID(%d): line(%p), call(%p), addressID(%x), select(%x)", 
           ++dwSum, hdLine, hdCall, dwAddressID, dwSelect);

    if(LINECALLSELECT_LINE != dwSelect &&
           LINECALLSELECT_ADDRESS != dwSelect &&
           LINECALLSELECT_CALL != dwSelect)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    if (LINECALLSELECT_LINE == dwSelect ||
        LINECALLSELECT_ADDRESS == dwSelect)
    {
        lRes = GetLineObjWithReadLock(hdLine, &pLine);
        if (    (lRes != TAPI_SUCCESS)
            ||  (NULL == pLine))
        {
            return lRes;
        }
    }

    if (LINECALLSELECT_CALL == dwSelect)
    {
        lRes = GetCallObjWithReadLock(hdCall, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            return lRes;
        }
    }

    //
    // Kmddsp will field this specific call on behalf of the
    // wan miniports.  It returns the guid and media string
    // of the adapter that this line lives on
    //
    if (LINECALLSELECT_LINE == dwSelect &&
        !wcscmp(lpszDeviceClass, L"LineGuid"))
    {
        lpDeviceID->dwNeededSize =
            sizeof(VARSTRING) + sizeof(GUID) +
            sizeof(pLine->MediaType) + sizeof('\0');

        if (lpDeviceID->dwTotalSize < lpDeviceID->dwNeededSize)
        {
            if (pCall != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdCall);
            }
            if (pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }
            return LINEERR_STRUCTURETOOSMALL;
        }

        lpDeviceID->dwUsedSize = lpDeviceID->dwNeededSize;
        lpDeviceID->dwStringFormat = STRINGFORMAT_ASCII;
        pchDest = (PUCHAR)lpDeviceID + sizeof(*lpDeviceID);
        lpDeviceID->dwStringOffset = (DWORD)(pchDest - (PUCHAR)lpDeviceID);
        lpDeviceID->dwStringSize =
            sizeof(GUID) + sizeof(pLine->MediaType) +sizeof('\0');

        MoveMemory(
            pchDest,
            (PUCHAR)&pLine->Guid,
            sizeof(pLine->Guid)
            );

        pchDest += sizeof(pLine->Guid);

        MoveMemory(
            pchDest,
            &pLine->MediaType,
            sizeof(pLine->MediaType)
            );

        pchDest += sizeof(pLine->MediaType);
        *pchDest = '\0';

        TspLog(DL_INFO, "lineGetID: obj(%p)", hdLine);

        if(pLine != NULL)
        {
            TspLog(
                DL_INFO,
                "Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
                pLine->Guid.Data1, pLine->Guid.Data2,
                pLine->Guid.Data3, pLine->Guid.Data4[0],
                pLine->Guid.Data4[1], pLine->Guid.Data4[2],
                pLine->Guid.Data4[3], pLine->Guid.Data4[4],
                pLine->Guid.Data4[5], pLine->Guid.Data4[6],
                pLine->Guid.Data4[7]
                );
        }            

        TspLog(DL_INFO, "MediaType: %d", pLine->MediaType);

        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return TAPI_SUCCESS;
    }

    dwDeviceID = (LINECALLSELECT_CALL == dwSelect) ? 
                      pCall->dwDeviceID : pLine->dwDeviceID;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ID,                   // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_ID) +         // size of req data
             (lpDeviceID->dwTotalSize - sizeof(VAR_STRING)) + dwLength,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return lRes;
    }

    pNdisTapiGetID = (PNDIS_TAPI_GET_ID)pNdisTapiRequest->Data;

    if (LINECALLSELECT_LINE == dwSelect ||
        LINECALLSELECT_ADDRESS == dwSelect)
    {
        pNdisTapiGetID->hdLine = pLine->hd_Line;
    }

    pNdisTapiGetID->ulAddressID = dwAddressID;

    if (LINECALLSELECT_CALL == dwSelect)
    {
        pNdisTapiGetID->hdCall = GetNdisTapiHandle(pCall, &lRes);
        if(lRes != TAPI_SUCCESS)
        {
            if(pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE) hdLine);
            }

            return lRes;
        }
    }

    pNdisTapiGetID->ulSelect = dwSelect;
    pNdisTapiGetID->ulDeviceClassSize = dwLength;
    pNdisTapiGetID->ulDeviceClassOffset = sizeof(NDIS_TAPI_GET_ID) +
        (lpDeviceID->dwTotalSize - sizeof(VAR_STRING));

    pID = &pNdisTapiGetID->DeviceID;

    pID->ulTotalSize = lpDeviceID->dwTotalSize;
    pID->ulNeededSize = pID->ulUsedSize = sizeof(VAR_STRING);
    pID->ulStringFormat = pID->ulStringSize = pID->ulStringOffset = 0;

    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(
            CP_ACP, 0, lpszDeviceClass, -1,
            (LPSTR) (((LPBYTE) pNdisTapiGetID) +
                pNdisTapiGetID->ulDeviceClassOffset),
            dwLength, NULL, NULL);
    
    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpDeviceID,
            &pNdisTapiGetID->DeviceID,
            pNdisTapiGetID->DeviceID.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);

    if (pCall != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
    }
    if (pLine != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PLINE_DEV_STATUS                pStatus;
    PNDIS_TAPI_GET_LINE_DEV_STATUS  pNdisTapiGetLineDevStatus;

    TspLog(DL_TRACE, "lineGetLineDevStatus(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_LINE_DEV_STATUS,              // opcode
             pLine->dwDeviceID,                         // device id
             sizeof(NDIS_TAPI_GET_LINE_DEV_STATUS) +    // size of req data
             (lpLineDevStatus->dwTotalSize - sizeof(LINE_DEV_STATUS)),
             &pNdisTapiRequest                          // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetLineDevStatus =
        (PNDIS_TAPI_GET_LINE_DEV_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetLineDevStatus->hdLine = pLine->hd_Line;

    pStatus = &pNdisTapiGetLineDevStatus->LineDevStatus;

    pStatus->ulTotalSize = lpLineDevStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_DEV_STATUS);

    ZeroMemory(&pStatus->ulNumOpens,
               sizeof(LINE_DEV_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // (no embedded ascii strings to convert to unicode)
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields. (There are no embedded ascii strings to
    // convert to unicode, so no extra space needed for that.)
    //

    lpLineDevStatus->dwNeededSize =
        pStatus->ulNeededSize +
        (sizeof(LINEDEVSTATUS) -       // v2.0 struct
            sizeof(LINE_DEV_STATUS));  // v1.0 struct

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwNumActiveCalls to dwDevStatusFlags
    //

    CopyMemory(
        &lpLineDevStatus->dwNumActiveCalls,
        &pStatus->ulNumActiveCalls,
        sizeof(LINE_DEV_STATUS) - (9 * sizeof(DWORD))
        );

    if (lpLineDevStatus->dwNeededSize > lpLineDevStatus->dwTotalSize)
    {
        lpLineDevStatus->dwUsedSize =
            (lpLineDevStatus->dwTotalSize < sizeof(LINEDEVSTATUS) ?
            lpLineDevStatus->dwTotalSize : sizeof(LINEDEVSTATUS));
    }
    else
    {
        lpLineDevStatus->dwUsedSize = sizeof(LINEDEVSTATUS);
                                                        // v2.0 struct
        INSERTVARDATA(
            pStatus,
            &pStatus->ulTerminalModesSize,
            lpLineDevStatus,
            &lpLineDevStatus->dwTerminalModesSize,
            sizeof(LINE_DEV_STATUS),
            "LINE_DEV_STATUS.TerminalModes"
            );

        INSERTVARDATA(
            pStatus,
            &pStatus->ulDevSpecificSize,
            lpLineDevStatus,
            &lpLineDevStatus->dwDevSpecificSize,
            sizeof(LINE_DEV_STATUS),
            "LINE_DEV_STATUS.DevSpecific"
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVLINE        pLine;

    TspLog(DL_TRACE, "lineGetNumAddressIDs(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetNumAddressIDs(pLine->dwDeviceID, lpdwNumAddressIDs);

    if (TAPI_SUCCESS == lRes)
    {
        TspLog(DL_INFO, "lineGetNumAddressIDs: numAddressIDs(%x)",
               *lpdwNumAddressIDs);
    }

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
PASCAL
TSPI_lineMakeCall_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    LONG        lSuc;
    HDRVLINE    hdLine;
    PDRVLINE    pLine;
    HDRVCALL    hdCall;
    PDRVCALL    pCall;

    TspLog(DL_TRACE, "lineMakeCall_post: lRes(%x)", lRes);

    hdCall = (HDRVCALL)(pAsyncReqWrapper->dwRequestSpecific);

    lSuc = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetLineObjWithReadLock(hdLine, &pLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetCallObjWithWriteLock(hdCall, &pCall);
    if (lSuc != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lSuc;
    }

    if (TAPI_SUCCESS == lRes)
    {
        PNDIS_TAPI_MAKE_CALL    pNdisTapiMakeCall = (PNDIS_TAPI_MAKE_CALL)
            pAsyncReqWrapper->NdisTapiRequest.Data;
          
        // check to see if a call state msg was received before we had
        // the chance to process the completion notification, & if so
        // fill in the msg params
        if (pCall->dwPendingCallState)
        {
            callStateMsgParams[0] = (DWORD_PTR)pLine->htLine;
            callStateMsgParams[1] = (DWORD_PTR)pCall->htCall;
            callStateMsgParams[2] = pCall->dwPendingCallState;
            callStateMsgParams[3] = pCall->dwPendingCallStateMode;
            callStateMsgParams[4] = pCall->dwPendingMediaMode;
        }
        pCall->hd_Call = pNdisTapiMakeCall->hdCall;
        pCall->bIncomplete = FALSE;

        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
    }
    else
    {
        pCall->dwKey = INVALID_KEY;

        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        CloseObjHandle((HANDLE)hdCall);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes; 
    PDRVLINE                pLine;
    PDRVCALL                pCall;
    HDRVCALL                hdCall;
    DWORD                   dwDALength, dwCPLength, dwOrgDALength;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_MAKE_CALL    pNdisTapiMakeCall;
    UINT                    nCodePage;

    TspLog(DL_TRACE, "lineMakeCall(%d): reqID(%x), line(%p)", 
           ++dwSum, dwRequestID, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // alloc & init a DRVCALL
    if (!(pCall = AllocCallObj(sizeof(DRVCALL))))
    {
        TspLog(DL_ERROR, "lineMakeCall: failed to create call obj");

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_NOMEM;
    }
    pCall->dwKey       = OUTBOUND_CALL_KEY;
    pCall->dwDeviceID  = pLine->dwDeviceID;
    pCall->htCall      = htCall;
    pCall->hdLine      = hdLine;
    pCall->bIncomplete = TRUE;

    // set nCodePage depending on the medium type
    nCodePage = (pLine->MediaType == NdisWanMediumPppoe) ? CP_UTF8 : CP_ACP;

    // init the request
    dwOrgDALength = (lpszDestAddress ? (lstrlenW (lpszDestAddress) + 1) : 0);
    
    dwDALength = (lpszDestAddress ? 
                  GetDestAddressLength(lpszDestAddress, dwOrgDALength, &nCodePage) : 0);
                  
    dwCPLength = (lpCallParams ? 
                  (lpCallParams->dwTotalSize - sizeof(LINE_CALL_PARAMS)) : 0);

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_MAKE_CALL,            // opcode
             pLine->dwDeviceID,             // device id
             dwRequestID,                   // request id
             sizeof(NDIS_TAPI_MAKE_CALL) +
             dwDALength + dwCPLength,       // size
             &pAsyncReqWrapper              // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        FreeCallObj(pCall);

        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiMakeCall = (PNDIS_TAPI_MAKE_CALL)
        pAsyncReqWrapper->NdisTapiRequest.Data;

    // make sure releasing read lock before calling OpenObjHandle()
    // to avoid deadlock on acquiring write lock for the global mapper
    ReleaseObjReadLock((HANDLE)hdLine);

    lRes = OpenObjHandle(pCall, FreeCallObj, (HANDLE *)&hdCall);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "lineMakeCall: failed to map obj(%p) to handle",
               pCall);

        FreeRequest(pAsyncReqWrapper);
        FreeCallObj(pCall);
        return lRes;
    }

    // reacquire the read lock
    lRes = AcquireObjReadLock((HANDLE)hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR,
               "lineMakeCall: failed to reacquire read lock for obj(%p)",
               hdLine);

        FreeRequest(pAsyncReqWrapper);
        CloseObjHandle((HANDLE)hdCall);
        return lRes;
    }

    // save the TSP handle
    pCall->hdCall = hdCall;

    pNdisTapiMakeCall->hdLine = pLine->hd_Line;
    pNdisTapiMakeCall->htCall = (HTAPI_CALL)hdCall;
    pNdisTapiMakeCall->ulDestAddressSize = dwDALength;

    if (lpszDestAddress)
    {
        pNdisTapiMakeCall->ulDestAddressOffset = 
            sizeof(NDIS_TAPI_MAKE_CALL) + dwCPLength;

        // old miniports expect strings to be ascii
        WideCharToMultiByte(
                nCodePage,
                0,
                lpszDestAddress,
                dwOrgDALength,
                (LPSTR) (((LPBYTE) pNdisTapiMakeCall) +
                    pNdisTapiMakeCall->ulDestAddressOffset),
                dwDALength,
                NULL,
                NULL
                );
    }
    else
    {
        pNdisTapiMakeCall->ulDestAddressOffset = 0;
    }

    if (lpCallParams)
    {
        pNdisTapiMakeCall->bUseDefaultLineCallParams = FALSE;

        CopyMemory(
            &pNdisTapiMakeCall->LineCallParams,
            lpCallParams,
            lpCallParams->dwTotalSize
            );

        if (lpCallParams->dwOrigAddressSize != 0)
        {
            WideCharToMultiByte(
                CP_ACP,
                0,
                (LPCWSTR) (((LPBYTE) lpCallParams) +
                    lpCallParams->dwOrigAddressOffset),
                lpCallParams->dwOrigAddressSize / sizeof (WCHAR),
                (LPSTR) (((LPBYTE) &pNdisTapiMakeCall->LineCallParams) +
                    lpCallParams->dwOrigAddressOffset),
                lpCallParams->dwOrigAddressSize,
                NULL,
                NULL
                );

            pNdisTapiMakeCall->LineCallParams.ulOrigAddressSize /= 2;
        }
    }
    else
    {
        pNdisTapiMakeCall->bUseDefaultLineCallParams = TRUE;
    }

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)hdCall;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineMakeCall_postProcess;

    *lphdCall = hdCall;

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static DWORD                        dwSum = 0;
    LONG                                lRes;
    PNDISTAPI_REQUEST                   pNdisTapiRequest;
    PNDIS_TAPI_NEGOTIATE_EXT_VERSION    pNdisTapiNegotiateExtVersion;

    TspLog(DL_TRACE, 
           "lineNegotiateExtVersion(%d): deviceID(%x), TSPIV(%x), "\
           "LowV(%x), HighV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion, dwLowVersion, dwHighVersion);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_NEGOTIATE_EXT_VERSION,            // opcode
             dwDeviceID,                                // device id
             sizeof(NDIS_TAPI_NEGOTIATE_EXT_VERSION),   // size of req data
             &pNdisTapiRequest                          // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiNegotiateExtVersion =
        (PNDIS_TAPI_NEGOTIATE_EXT_VERSION)pNdisTapiRequest->Data;
    
    pNdisTapiNegotiateExtVersion->ulDeviceID = dwDeviceID;
    pNdisTapiNegotiateExtVersion->ulLowVersion = dwLowVersion;
    pNdisTapiNegotiateExtVersion->ulHighVersion = dwHighVersion;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwExtVersion = pNdisTapiNegotiateExtVersion->ulExtVersion;

        // save version for future verification
        lRes = SetNegotiatedExtVersion(dwDeviceID, *lpdwExtVersion);
    }
    else
    {
        TspLog(DL_WARNING, "lineNegotiateExtVersion: syncRequest returned(%x)", 
               lRes);
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;

    TspLog(DL_TRACE, "lineNegotiateTSPIVersion(%d): deviceID(%x)", 
           ++dwSum, dwDeviceID);

    *lpdwTSPIVersion = 0x00010003;  // until the ndistapi spec widened

    // save version for future verification
    lRes = SetNegotiatedTSPIVersion(dwDeviceID, 0x00010003);

    if (TAPI_SUCCESS == lRes)
    {
        TspLog(DL_INFO, "lineNegotiateTSPIVersion: TSPIVersion(%x)",
               *lpdwTSPIVersion);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVLINE                pLine;
    HDRVLINE                hdLine;
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PNDIS_TAPI_OPEN         pNdisTapiOpen;
    GUID                    Guid;
    NDIS_WAN_MEDIUM_SUBTYPE MediaType;
    PNDISTAPI_OPENDATA      OpenData;

    
    TspLog(DL_TRACE, "lineOpen(%d): deviceID(%x), htLine(%p)", 
           ++dwSum, dwDeviceID, htLine);

    // alloc & init a DRVLINE
    if (!(pLine = AllocLineObj(sizeof(DRVLINE))))
    {
        TspLog(DL_ERROR, "lineOpen: failed to create line obj");
        return LINEERR_NOMEM;
    }
    pLine->dwKey = LINE_KEY;
    pLine->dwDeviceID = dwDeviceID;
    pLine->htLine = htLine;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_OPEN,             // opcode
             dwDeviceID,                // device id
             sizeof(NDIS_TAPI_OPEN) + 
             sizeof(NDISTAPI_OPENDATA), // size
             &pNdisTapiRequest          // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        FreeLineObj(pLine);
        return lRes;
    }

    pNdisTapiOpen = (PNDIS_TAPI_OPEN)pNdisTapiRequest->Data;

    pNdisTapiOpen->ulDeviceID = dwDeviceID;

    lRes = OpenObjHandle(pLine, FreeLineObj, (HANDLE *)&hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, "lineOpen: failed to map obj(%p) to handle", pLine);
        FreeLineObj(pLine);
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    pNdisTapiOpen->htLine = (HTAPI_LINE)hdLine;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        CloseObjHandle((HANDLE)hdLine);
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    OpenData = (PNDISTAPI_OPENDATA)
                    ((PUCHAR)pNdisTapiOpen + sizeof(NDIS_TAPI_OPEN));

    MoveMemory(&pLine->Guid,&OpenData->Guid, sizeof(pLine->Guid));
    pLine->MediaType = OpenData->MediaType;

    TspLog(DL_INFO, "lineOpen: obj(%p)", hdLine);
    TspLog(
        DL_INFO,
        "Guid: %4.4x-%4.4x-%2.2x%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
        pLine->Guid.Data1, pLine->Guid.Data2,
        pLine->Guid.Data3, pLine->Guid.Data4[0],
        pLine->Guid.Data4[1], pLine->Guid.Data4[2],
        pLine->Guid.Data4[3], pLine->Guid.Data4[4],
        pLine->Guid.Data4[5], pLine->Guid.Data4[6],
        pLine->Guid.Data4[7]
        );

    TspLog(DL_INFO, "MediaType(%ld)", pLine->MediaType);

    pLine->hd_Line = pNdisTapiOpen->hdLine;
    *lphdLine = hdLine;

    lRes = CommitNegotiatedTSPIVersion(dwDeviceID);

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_SECURE_CALL  pNdisTapiSecureCall;

    TspLog(DL_TRACE, "lineSecureCall(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SECURE_CALL,          // opcode
             pCall->dwDeviceID,             // device id
             dwRequestID,                   // req id
             sizeof(NDIS_TAPI_SECURE_CALL), // size
             &pAsyncReqWrapper              // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSecureCall =
        (PNDIS_TAPI_SECURE_CALL)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSecureCall->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE    hdLine,
    DWORD       dwExtVersion
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_SELECT_EXT_VERSION   pNdisTapiSelectExtVersion;

    TspLog(DL_TRACE, "lineSelectExtVersion(%d): line(%p), ExtV(%x)", 
           ++dwSum, hdLine, dwExtVersion);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SELECT_EXT_VERSION,           // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SELECT_EXT_VERSION),  // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSelectExtVersion =
        (PNDIS_TAPI_SELECT_EXT_VERSION)pNdisTapiRequest->Data;

    pNdisTapiSelectExtVersion->hdLine = pLine->hd_Line;
    pNdisTapiSelectExtVersion->ulExtVersion = dwExtVersion;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    
    if (TAPI_SUCCESS == lRes)
    {
        lRes = SetSelectedExtVersion(pLine->dwDeviceID, dwExtVersion);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVCALL                        pCall;
    PASYNC_REQUEST_WRAPPER          pAsyncReqWrapper;
    PNDIS_TAPI_SEND_USER_USER_INFO  pNdisTapiSendUserUserInfo;

    TspLog(DL_TRACE, "lineSendUserUserInfo(%d): reqID(%x), call(%p)",
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SEND_USER_USER_INFO,      // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_SEND_USER_USER_INFO) + dwSize,
             &pAsyncReqWrapper                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSendUserUserInfo = (PNDIS_TAPI_SEND_USER_USER_INFO)
                                   pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSendUserUserInfo->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    if (pNdisTapiSendUserUserInfo->ulUserUserInfoSize = dwSize)
    {
        CopyMemory(
            pNdisTapiSendUserUserInfo->UserUserInfo,
            lpsUserUserInfo,
            dwSize
            );
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL    hdCall,
    DWORD       dwAppSpecific
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_APP_SPECIFIC pNdisTapiSetAppSpecific;

    TspLog(DL_TRACE, "lineSetAppSpecific(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_APP_SPECIFIC,             // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_APP_SPECIFIC),    // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetAppSpecific =
        (PNDIS_TAPI_SET_APP_SPECIFIC)pNdisTapiRequest->Data;

    pNdisTapiSetAppSpecific->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    pNdisTapiSetAppSpecific->ulAppSpecific = dwAppSpecific;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PASYNC_REQUEST_WRAPPER      pAsyncReqWrapper;
    PNDIS_TAPI_SET_CALL_PARAMS  pNdisTapiSetCallParams;

    TspLog(DL_TRACE, "lineSetCallParams(%d): reqID(%x), call(%p)",
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SET_CALL_PARAMS,          // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_SET_CALL_PARAMS), // size
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetCallParams =
        (PNDIS_TAPI_SET_CALL_PARAMS)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSetCallParams->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiSetCallParams->ulBearerMode = dwBearerMode;
    pNdisTapiSetCallParams->ulMinRate = dwMinRate;
    pNdisTapiSetCallParams->ulMaxRate = dwMaxRate;

    if (lpDialParams)
    {
        pNdisTapiSetCallParams->bSetLineDialParams = TRUE;
        CopyMemory(
            &pNdisTapiSetCallParams->LineDialParams,
            lpDialParams,
            sizeof(LINE_DIAL_PARAMS)
            );
    }
    else
    {
        pNdisTapiSetCallParams->bSetLineDialParams = FALSE;
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    static DWORD                            dwSum = 0;
    LONG                                    lRes;
    PDRVLINE                                pLine;
    PNDISTAPI_REQUEST                       pNdisTapiRequest;
    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION  pNdisTapiSetDefaultMediaDetection;

    TspLog(DL_TRACE, "lineSetDefaultMediaDetection(%d): line(%p), mode(%x)", 
           ++dwSum, hdLine, dwMediaModes);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_DEFAULT_MEDIA_DETECTION,  // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION), // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSetDefaultMediaDetection =
        (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) pNdisTapiRequest->Data;

    pNdisTapiSetDefaultMediaDetection->hdLine = pLine->hd_Line;
    pNdisTapiSetDefaultMediaDetection->ulMediaModes = dwMediaModes;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwLength = lstrlenW(lpszDeviceClass) + 1;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_DEV_CONFIG   pNdisTapiSetDevConfig;

    TspLog(DL_TRACE, "lineSetDevConfig(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_DEV_CONFIG,       // opcode
             dwDeviceID,                    // device id
             sizeof(NDIS_TAPI_SET_DEV_CONFIG) + dwLength + dwSize,
             &pNdisTapiRequest              // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiSetDevConfig = (PNDIS_TAPI_SET_DEV_CONFIG)pNdisTapiRequest->Data;

    pNdisTapiSetDevConfig->ulDeviceID = dwDeviceID;
    pNdisTapiSetDevConfig->ulDeviceClassSize = dwLength;
    pNdisTapiSetDevConfig->ulDeviceClassOffset =
        sizeof(NDIS_TAPI_SET_DEV_CONFIG) + dwSize - 1;
    pNdisTapiSetDevConfig->ulDeviceConfigSize = dwSize;

    CopyMemory(
        pNdisTapiSetDevConfig->DeviceConfig,
        lpDeviceConfig,
        dwSize
        );

    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(CP_ACP, 0, lpszDeviceClass, -1,
        (LPSTR) (((LPBYTE) pNdisTapiSetDevConfig) +
            pNdisTapiSetDevConfig->ulDeviceClassOffset),
        dwLength, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_MEDIA_MODE   pNdisTapiSetMediaMode;

    TspLog(DL_TRACE, "lineSetMediaMode(%d): call(%p), mode(%x)", 
           ++dwSum, hdCall, dwMediaMode);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
            OID_TAPI_SET_MEDIA_MODE,            // opcode
            pCall->dwDeviceID,                  // device id
            sizeof(NDIS_TAPI_SET_MEDIA_MODE),   // size
            &pNdisTapiRequest                   // ptr to ptr to req buf
        )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetMediaMode = (PNDIS_TAPI_SET_MEDIA_MODE)pNdisTapiRequest->Data;

    pNdisTapiSetMediaMode->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    pNdisTapiSetMediaMode->ulMediaMode = dwMediaMode;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE    hdLine,
    DWORD       dwLineStates,
    DWORD       dwAddressStates
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_SET_STATUS_MESSAGES  pNdisTapiSetStatusMessages;

    TspLog(DL_TRACE, "lineSetStatusMessages(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_STATUS_MESSAGES,          // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_STATUS_MESSAGES), // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSetStatusMessages =
        (PNDIS_TAPI_SET_STATUS_MESSAGES)pNdisTapiRequest->Data;

    pNdisTapiSetStatusMessages->hdLine = pLine->hd_Line;
    pNdisTapiSetStatusMessages->ulLineStates = dwLineStates;
    pNdisTapiSetStatusMessages->ulAddressStates = dwAddressStates;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

//
// TAPI_providerXxx funcs
//
LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    TspLog(DL_TRACE, "providerEnumDevices: permProvID(%x)",
           dwPermanentProviderID);

    //
    // NOTE: We really enum devs in providerInit, see the
    // special case note there
    //
    *lpdwNumLines = 0;
    *lpdwNumPhones = 0;

    gpfnLineEvent = lpfnLineCreateProc;
    ghProvider = hProvider;

    return 0;
}

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    LONG    lRes = LINEERR_OPERATIONFAILED;
    char    szDeviceName[] = "NDISTAPI";
    char    szTargetPath[] = "\\Device\\NdisTapi";
    char    szCompleteDeviceName[] = "\\\\.\\NDISTAPI";
    DWORD   cbReturned, dwThreadID;
    DWORD   adwConnectInfo[2];

    TspLog(DL_TRACE, "providerInit: perfProvID(%x), lineDevIDBase(%x)",
            dwPermanentProviderID, dwLineDeviceIDBase);

    //
    // inform tapisrv that we support multiple simultaneous requests
    // (the WAN wrapper handles request serialization for miniports)
    //
    *lpdwTSPIOptions = 0;

    //
    // create symbolic link to the kernel-mode driver
    //
    DefineDosDevice(DDD_RAW_TARGET_PATH, szDeviceName, szTargetPath);

    //
    // open driver handles
    //
    if ((ghDriverSync = CreateFileA(
            szCompleteDeviceName,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,                               // no security attrs
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                                // no template file
            )) == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, "providerInit: CreateFile(%s, sync) failed(%ld)",
               szCompleteDeviceName, GetLastError());

        goto providerInit_error0;
    }

    if ((ghDriverAsync = CreateFileA(
            szCompleteDeviceName,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,                               // no security attrs
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL                                // no template file
            )) == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, "providerInit: CreateFile(%s, async) failed(%ld)",
               szCompleteDeviceName, GetLastError());

        goto providerInit_error1;
    }

    //
    // create io completion port
    //
    if ((ghCompletionPort = CreateIoCompletionPort(ghDriverAsync, NULL, 0, 0)) 
        == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, "providerInit: CreateIoCompletionPort failed(%ld)",
               GetLastError());

        goto providerInit_error2;
    }

    //
    // connect to driver- we send it a device ID base & it returns
    // the number of devices it supports
    //
    {
        adwConnectInfo[0] = dwLineDeviceIDBase;
        adwConnectInfo[1] = 1;

        if (!DeviceIoControl(
                ghDriverSync,
                IOCTL_NDISTAPI_CONNECT,
                adwConnectInfo,
                2 * sizeof(DWORD),
                adwConnectInfo,
                2 * sizeof(DWORD),
                &cbReturned,
                (LPOVERLAPPED)NULL
                ) ||
            (cbReturned < sizeof(DWORD)))
        {
            TspLog(DL_ERROR, "providerInit: CONNECT failed(%ld)", 
                   GetLastError());

            goto providerInit_error3;
        }
    }

    // init mapper, allocator and dev list
    if (InitializeMapper() != TAPI_SUCCESS)
    {
        goto providerInit_error3_5;
    }

    InitAllocator();

    //
    // alloc the resources needed by the AsyncEventThread, and then
    // create the thread
    //
    if ((gpAsyncEventsThreadInfo = (PASYNC_EVENTS_THREAD_INFO)
            MALLOC(sizeof(ASYNC_EVENTS_THREAD_INFO))) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: failed to alloc thread info");
        goto providerInit_error4;
    }

    gpAsyncEventsThreadInfo->dwBufSize = EVENT_BUFFER_SIZE;

    if ((gpAsyncEventsThreadInfo->pBuf = (PNDISTAPI_EVENT_DATA)
            MALLOC(EVENT_BUFFER_SIZE)) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: failed to alloc event buf");
        goto providerInit_error5;
    }

    if ((gpAsyncEventsThreadInfo->hThread = CreateThread(
            (LPSECURITY_ATTRIBUTES)NULL,    // no security attrs
            0,                              // default stack size
            (LPTHREAD_START_ROUTINE)        // func addr
                AsyncEventsThread,
            (LPVOID)NULL,                   // thread param
            0,                              // create flags
            &dwThreadID                     // thread id
            )) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: CreateThread failed(%ld)",
               GetLastError());

        goto providerInit_error7;
    }

    gdwRequestID = 1;

    //
    // !!! Special case for KMDDSP.TSP only !!!
    //
    // For KMDDSP.TSP only, TAPISRV.EXE will pass pointers in the
    // dwNumLines/dwNumPhones variables rather than an actual
    // number of lines/phones, thereby allowing the driver to tell
    // TAPISRV.EXE how many devices are currently registered.
    //
    // This is really due to a design/interface problem in NDISTAPI.SYS.
    // Since the current CONNECT IOCTLS expects both a device ID base &
    // returns the num devs, we can't really do this in
    // TSPI_providerEnumDevices as the device ID base is unknown
    // at that point
    //
    *((LPDWORD)dwNumLines)  = adwConnectInfo[0];
    *((LPDWORD)dwNumPhones) = 0;

    //
    // if here success
    //
    gpfnCompletionProc = lpfnCompletionProc;
    lRes = TAPI_SUCCESS;

    goto providerInit_return;

    //
    // clean up resources if an error occured & then return
    //
providerInit_error7:

    FREE(gpAsyncEventsThreadInfo->pBuf);

providerInit_error5:

    FREE(gpAsyncEventsThreadInfo);

providerInit_error4:
    UninitAllocator();
    UninitializeMapper();

providerInit_error3_5:
providerInit_error3:

    CloseHandle(ghCompletionPort);

providerInit_error2:

    CloseHandle(ghDriverAsync);

providerInit_error1:

    CloseHandle(ghDriverSync);

providerInit_error0:

    DefineDosDevice(DDD_REMOVE_DEFINITION, szDeviceName, NULL);

providerInit_return:

    TspLog(DL_INFO, "providerInit: lRes(%x)", lRes);

    return lRes;
}

LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD_PTR dwTempID,
    DWORD     dwDeviceID
    )
{
    DWORD                   cbReturned;
    NDISTAPI_CREATE_INFO    CreateInfo;

    CreateInfo.TempID = dwTempID;
    CreateInfo.DeviceID = dwDeviceID;

    TspLog(DL_TRACE, "providerCreateLineDevice: tempID(%x), deviceID(%x)",
           dwTempID, dwDeviceID);

    if (!DeviceIoControl(
            ghDriverSync,
            IOCTL_NDISTAPI_CREATE,
            &CreateInfo,
            sizeof(CreateInfo),
            &CreateInfo,
            sizeof(CreateInfo),
            &cbReturned,
            (LPOVERLAPPED)NULL
            ))
    {
        TspLog(DL_ERROR, "providerCreateLineDevice: failed(%ld) to create",
               GetLastError());
        return LINEERR_OPERATIONFAILED;
    }

    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    char                    deviceName[] = "NDISTAPI";
    ASYNC_REQUEST_WRAPPER   asyncRequestWrapper;

    TspLog(DL_TRACE, "providerShutdown: perfProvID(%x)", dwPermanentProviderID);

    // @@@ all we ought to have to do here is send a DISCONNECT IOCTL

    //
    // Close the driver & remove the symbolic link
    //
    
    CancelIo(ghDriverSync);
    CancelIo(ghDriverAsync);
    CloseHandle (ghDriverSync);
    
   TspLog(DL_WARNING, "providerShutdown: Calling PostQueuedCompletionStatus"); 
    if( !PostQueuedCompletionStatus
        ( ghCompletionPort, 0, 0,(LPOVERLAPPED) &gOverlappedTerminate) )
        {
            
            TspLog(DL_ERROR, "providerShutdown: PostQueuedCompletionStatus "\
                "failed");
        }
    else
        {
     WaitForSingleObject(gpAsyncEventsThreadInfo->hThread, INFINITE);
        }
    CloseHandle (ghDriverAsync);
    CloseHandle (ghCompletionPort);
    DefineDosDevice (DDD_REMOVE_DEFINITION, deviceName, NULL);

    CloseHandle(gpAsyncEventsThreadInfo->hThread);
    FREE(gpAsyncEventsThreadInfo->pBuf);
    FREE(gpAsyncEventsThreadInfo);

    UninitAllocator();
    UninitializeMapper();

    return TAPI_SUCCESS;
}

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#if DBG
            {
                HKEY    hKey;
                DWORD   dwDataSize, dwDataType;
                TCHAR   szTelephonyKey[] =
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";
                TCHAR   szKmddspDebugLevel[] = "KmddspDebugLevel";

                RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szTelephonyKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

                dwDataSize = sizeof(DWORD);
                gdwDebugLevel = DL_WARNING;

                RegQueryValueEx(
                    hKey,
                    szKmddspDebugLevel,
                    0,
                    &dwDataType,
                    (LPBYTE)&gdwDebugLevel,
                    &dwDataSize
                    );

                RegCloseKey(hKey);
            }
#endif
            gdwTraceID = TraceRegisterA("KMDDSP");
            ASSERT(gdwTraceID != INVALID_TRACEID);

            TspLog(DL_TRACE, "DLL_PROCESS_ATTACH");

            //
            // Init global sync objects
            //
            InitializeCriticalSection(&gRequestIDCritSec);

            InitLineDevList();

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            TspLog(DL_TRACE, "DLL_PROCESS_DETACH");

            UninitLineDevList();

            DeleteCriticalSection(&gRequestIDCritSec);

            TraceDeregisterA(gdwTraceID);

            break;
        }
    } // switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\kmddsp\kmddsp.h ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: kmddsp.h
//
// History:
//      Yi Sun  June-27-2000    Created
//
// Abstract:
//============================================================================
#ifndef _KMDDSP_H_
#define _KMDDSP_H_

// handle types
#define HT_HDCALL               1
#define HT_HDLINE               2

// tapi success code
#define TAPI_SUCCESS            0

// alloc fixed mem then zeroinit it
#define MALLOC(x)               LocalAlloc(LPTR, x) 

#define FREE(x)                 LocalFree(x)

// debug levels
#define DL_ERROR                1
#define DL_WARNING              2
#define DL_INFO                 4
#define DL_TRACE                8

typedef VOID (*FREEOBJPROC)(PVOID);

// debug routine
VOID
TspLog(
    IN DWORD dwDebugLevel,
    IN PCHAR pchFormat,
    ...
    );

//
// implemented in mapper.c
//
LONG
InitializeMapper();

VOID
UninitializeMapper();

LONG
OpenObjHandle(
    IN PVOID pObjPtr,
    IN FREEOBJPROC pfnFreeProc,
    OUT HANDLE *phObj
    );

LONG
CloseObjHandle(
    IN HANDLE hObj
    );

LONG
AcquireObjReadLock(
    IN HANDLE hObj
    );

LONG
GetObjWithReadLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    );

LONG
ReleaseObjReadLock(
    IN HANDLE hObj
    );

LONG
AcquireObjWriteLock(
    IN HANDLE hObj
    );

LONG
GetObjWithWriteLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    );

LONG
ReleaseObjWriteLock(
    IN HANDLE hObj
    );

//
// implemented in allocatr.c
//
VOID
InitAllocator();

VOID
UninitAllocator();

PVOID
AllocRequest(
    IN DWORD dwSize
    );

VOID
FreeRequest(
    IN PVOID pMem
    );

VOID
MarkRequest(
    IN PVOID pMem
    );

VOID
UnmarkRequest(
    IN PVOID pMem
    );

PVOID
AllocCallObj(
    IN DWORD dwSize
    );

VOID
FreeCallObj(
    IN PVOID pCall
    );

PVOID
AllocLineObj(
    IN DWORD dwSize
    );

VOID
FreeLineObj(
    IN PVOID pLine
    );

//
// implemented in devlist.c
//
VOID
InitLineDevList();

VOID
UninitLineDevList();

LONG
SetNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwTSPIVersion
    );

LONG
SetNegotiatedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    );

LONG
SetSelectedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    );

LONG
CommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    );

LONG
DecommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    );

LONG
GetNumAddressIDs(
    IN DWORD    dwDeviceID,
    OUT DWORD  *pdwNumAddressIDs
    );

LONG
GetDevCaps(
    IN DWORD            dwDeviceID,
    IN DWORD            dwTSPIVersion,
    IN DWORD            dwExtVersion,
    OUT LINEDEVCAPS    *pLineDevCaps
    );

//
// implemented in kmddsp.c
//
LINEDEVCAPS *
GetLineDevCaps(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    );

#endif // _KMDDSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\esp\ui\espui.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    espui.c

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    30-Sep-1995

Revision History:


Notes:


--*/


#include "windows.h"
#include "tapi.h"
#include "tspi.h"
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "malloc.h"
#include "string.h"


typedef struct _MYDIALOGPARAMS
{
    char               *pszTitle;

    char               *pszDataIn;

    TUISPIDLLCALLBACK   lpfnUIDLLCallback;

    ULONG_PTR           ObjectID;

    DWORD               dwObjectType;

    LONG                lResult;

} MYDIALOGPARAMS, *PMYDIALOGPARAMS;


HINSTANCE   ghInstance;
char        szMySection[] = "ESP32";
char        szShowProviderXxxDlgs[] = "ShowProviderXxxDlgs";

#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

DWORD   gdwDebugLevel;

#else

#define DBGOUT(arg)

#endif


INT_PTR
CALLBACK
GenericDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WINAPI
_CRT_INIT(
    HINSTANCE   hDLL,
    DWORD       dwReason,
    LPVOID      lpReserved
    );

LONG
PASCAL
ProviderInstall(
    char   *pszProviderName,
    BOOL    bNoMultipleInstance
    );


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    static HANDLE hInitEvent;

/*
    if (!_CRT_INIT (hDLL, dwReason, lpReserved))
    {
        OutputDebugString ("ESPUI: DllMain: _CRT_INIT() failed\n\r");
    }
*/

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

#if DBG

    {
        HKEY    hKey;
        DWORD   dwDataSize, dwDataType;
        TCHAR   szTelephonyKey[] =
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony",
                szEsp32DebugLevel[] = "Esp32DebugLevel";


        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szTelephonyKey,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );

        dwDataSize = sizeof (DWORD);
        gdwDebugLevel=0;

        RegQueryValueEx(
            hKey,
            szEsp32DebugLevel,
            0,
            &dwDataType,
            (LPBYTE) &gdwDebugLevel,
            &dwDataSize
            );

        RegCloseKey (hKey);
    }

#endif
        ghInstance = hDLL;
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}


LONG
TSPIAPI
TUISPI_lineConfigDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
    char buf[64];
    MYDIALOGPARAMS params =
    {
        "TUISPI_lineConfigDialog",
        buf,
        lpfnUIDLLCallback,
        dwDeviceID,
        TUISPIDLL_OBJECT_LINEID,
        0
    };


    wsprintf(
        buf,
        "devID=%d, devClass='%ws'",
        dwDeviceID,
        (lpszDeviceClass ? lpszDeviceClass : L"")
        );

    DialogBoxParam(
        ghInstance,
        MAKEINTRESOURCE(100),
        hwndOwner,
        GenericDlgProc,
        (LPARAM) &params
        );

    return params.lResult;
}


LONG
TSPIAPI
TUISPI_lineConfigDialogEdit(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
    char buf[64];
    MYDIALOGPARAMS params =
    {
        "TUISPI_lineConfigDialogEdit",
        buf,
        lpfnUIDLLCallback,
        dwDeviceID,
        TUISPIDLL_OBJECT_LINEID,
        0
    };


    wsprintf(
        buf,
        "devID=%d, devClass='%ws'",
        dwDeviceID,
        (lpszDeviceClass ? lpszDeviceClass : L"")
        );

    DialogBoxParam(
        ghInstance,
        MAKEINTRESOURCE(100),
        hwndOwner,
        GenericDlgProc,
        (LPARAM) &params
        );

    return params.lResult;
}


LONG
TSPIAPI
TUISPI_phoneConfigDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
    char buf[64];
    MYDIALOGPARAMS params =
    {
        "TUISPI_phoneConfigDialog",
        buf,
        lpfnUIDLLCallback,
        dwDeviceID,
        TUISPIDLL_OBJECT_PHONEID,
        0
    };


    wsprintf(
        buf,
        "devID=%d, devClass='%ws'",
        dwDeviceID,
        (lpszDeviceClass ? lpszDeviceClass : L"")
        );

    DialogBoxParam(
        ghInstance,
        MAKEINTRESOURCE(100),
        hwndOwner,
        GenericDlgProc,
        (LPARAM) &params
        );

    if (params.lResult)
    {
        params.lResult = PHONEERR_OPERATIONFAILED;
    }

    return params.lResult;
}


LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    char buf[64];
    MYDIALOGPARAMS params =
    {
        "TUISPI_providerConfig",
        buf,
        lpfnUIDLLCallback,
        dwPermanentProviderID,
        TUISPIDLL_OBJECT_PROVIDERID,
        0
    };


    wsprintf (buf, "providerID=%d", dwPermanentProviderID);

    DialogBoxParam(
        ghInstance,
        MAKEINTRESOURCE(100),
        hwndOwner,
        GenericDlgProc,
        (LPARAM) &params
        );

    return params.lResult;
}


LONG
TSPIAPI
TUISPI_providerGenericDialog(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize,
    HANDLE              hEvent
    )
{
    char buf[80];
    MYDIALOGPARAMS params =
    {
        "TUISPI_providerGenericDialog",
        buf,
        lpfnUIDLLCallback,
        (ULONG_PTR) htDlgInst,
        TUISPIDLL_OBJECT_DIALOGINSTANCE
    };


    SetEvent (hEvent);

    wsprintf(
        buf,
        "htDlgInst=x%x, lpParams='%s', dwSize=x%x",
        htDlgInst,
        lpParams,
        dwSize
        );

    DialogBoxParam(
        ghInstance,
        MAKEINTRESOURCE(100),
        NULL,
        GenericDlgProc,
        (LPARAM) &params
        );

    return 0;
}


LONG
TSPIAPI
TUISPI_providerGenericDialogData(
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
    DBGOUT((3, "TUISPI_providerGenericDialogData: enter"));
    DBGOUT((
        3,
        "\thtDlgInst=x%x, lpParams='%s', dwSize=x%x",
        htDlgInst,
        lpParams,
        dwSize
        ));

    return 0;
}


LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    char            buf[64];
    LONG            lResult;
    MYDIALOGPARAMS  params =
    {
        "TUISPI_providerInstall",
        buf,
        lpfnUIDLLCallback,
        dwPermanentProviderID,
        TUISPIDLL_OBJECT_PROVIDERID,
        0
    };
    BOOL    bShowDlgs = (BOOL) GetProfileInt(
                szMySection,
                szShowProviderXxxDlgs,
                0
                );


    if ((lResult = ProviderInstall ("esp32.tsp", TRUE)) == 0)
    {
        if (bShowDlgs)
        {
            wsprintf (buf, "providerID=%d", dwPermanentProviderID);

            DialogBoxParam(
                ghInstance,
                MAKEINTRESOURCE(100),
                hwndOwner,
                GenericDlgProc,
                (LPARAM) &params
                );

            lResult = params.lResult;
        }
    }
    else
    {
        if (bShowDlgs)
        {
            MessageBox(
                hwndOwner,
                "ESP32 already installed",
                "ESP32.TSP",
                MB_OK
                );
        }
    }

    return lResult;
}


LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LONG    lResult = 0;


    if (GetProfileInt (szMySection, szShowProviderXxxDlgs, 0) != 0)
    {
        char buf[64];
        MYDIALOGPARAMS params =
        {
            "TUISPI_providerRemove",
            buf,
            lpfnUIDLLCallback,
            dwPermanentProviderID,
            TUISPIDLL_OBJECT_PROVIDERID,
            0
        };


        wsprintf (buf, "providerID=%d", dwPermanentProviderID);

        DialogBoxParam(
            ghInstance,
            MAKEINTRESOURCE(100),
            hwndOwner,
            GenericDlgProc,
            (LPARAM) &params
            );

        lResult = params.lResult;
    }

    return lResult;
}


INT_PTR
CALLBACK
GenericDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
    {
        PMYDIALOGPARAMS pParams = (PMYDIALOGPARAMS) lParam;


        SetWindowText (hwnd, pParams->pszTitle);
        SetDlgItemText (hwnd, 104, pParams->pszDataIn);
        SetWindowLongPtr (hwnd, GWLP_USERDATA, (LONG_PTR) pParams);

        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL: // closing by clicking on the standard X on the right hand top corner
        case 105: // Error Button
        {
            PMYDIALOGPARAMS pParams;


            pParams = (PMYDIALOGPARAMS) GetWindowLongPtr (hwnd, GWLP_USERDATA);

			// return LINEERR_OPERATIONFAILED if "Error" is clicked
			// else, return 0
            pParams->lResult = (LOWORD(wParam) == 105 ? LINEERR_OPERATIONFAILED : 0);

            EndDialog (hwnd, 0);
            break;
        }
        case 102: // send data
        {
            #define BUFSIZE 32

            char buf[BUFSIZE] = "espui data";
            PMYDIALOGPARAMS pParams;


            pParams = (PMYDIALOGPARAMS) GetWindowLongPtr (hwnd, GWLP_USERDATA);

            (*pParams->lpfnUIDLLCallback)(
                pParams->ObjectID,
                pParams->dwObjectType,
                (LPVOID) buf,
                BUFSIZE
                );

            DBGOUT((3, buf));

            break;
        }
        }
        break;

    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return FALSE;
}


LONG
PASCAL
ProviderInstall(
    char   *pszProviderName,
    BOOL    bNoMultipleInstance
    )
{
    LONG    lResult;


    //
    // If only one installation instance of this provider is
    // allowed then we want to check the provider list to see
    // if the provider is already installed
    //

    if (bNoMultipleInstance)
    {
        LONG                (WINAPI *pfnGetProviderList)();
        DWORD               dwTotalSize, i;
        HINSTANCE           hTapi32;
        LPLINEPROVIDERLIST  pProviderList;
        LPLINEPROVIDERENTRY pProviderEntry;


        //
        // Load Tapi32.dll & get a pointer to the lineGetProviderList
        // func.  We could just statically link with Tapi32.lib and
        // avoid the hassle (and this wouldn't have any adverse
        // performance effects because of the fact that this
        // implementation has a separate ui dll that runs only on the
        // client context), but a provider who implemented these funcs
        // in it's TSP module would want to do an explicit load like
        // we do here to prevent the performance hit of Tapi32.dll
        // always getting loaded in Tapisrv.exe's context.
        //

        if (!(hTapi32 = LoadLibrary ("tapi32.dll")))
        {
            DBGOUT((
                1,
                "LoadLibrary(tapi32.dll) failed, err=%d",
                GetLastError()
                ));

            lResult = LINEERR_OPERATIONFAILED;
            goto ProviderInstall_return;
        }

        if (!((FARPROC) pfnGetProviderList = GetProcAddress(
                hTapi32,
                (LPCSTR) "lineGetProviderList"
                )))
        {
            DBGOUT((
                1,
                "GetProcAddr(lineGetProviderList) failed, err=%d",
                GetLastError()
                ));

            lResult = LINEERR_OPERATIONFAILED;
            goto ProviderInstall_unloadTapi32;
        }


        //
        // Loop until we get the full provider list
        //

        dwTotalSize = sizeof (LINEPROVIDERLIST);

        goto ProviderInstall_allocProviderList;

ProviderInstall_getProviderList:

        if ((lResult = (*pfnGetProviderList)(0x00020000, pProviderList)) != 0)
        {
            goto ProviderInstall_freeProviderList;
        }

        if (pProviderList->dwNeededSize > pProviderList->dwTotalSize)
        {
            dwTotalSize = pProviderList->dwNeededSize;

            LocalFree (pProviderList);

ProviderInstall_allocProviderList:

            if (!(pProviderList = LocalAlloc (LPTR, dwTotalSize)))
            {
                lResult = LINEERR_NOMEM;
                goto ProviderInstall_unloadTapi32;
            }

            pProviderList->dwTotalSize = dwTotalSize;

            goto ProviderInstall_getProviderList;
        }


        //
        // Inspect the provider list entries to see if this provider
        // is already installed
        //

        pProviderEntry = (LPLINEPROVIDERENTRY) (((LPBYTE) pProviderList) +
            pProviderList->dwProviderListOffset);

        for (i = 0; i < pProviderList->dwNumProviders; i++)
        {
            char   *pszInstalledProviderName = ((char *) pProviderList) +
                        pProviderEntry->dwProviderFilenameOffset,
                   *psz;


            if ((psz = strrchr (pszInstalledProviderName, '\\')))
            {
                pszInstalledProviderName = psz + 1;
            }

            if (lstrcmpi (pszInstalledProviderName, pszProviderName) == 0)
            {
                lResult = LINEERR_NOMULTIPLEINSTANCE;
                goto ProviderInstall_freeProviderList;
            }

            pProviderEntry++;
        }


        //
        // If here then the provider isn't currently installed,
        // so do whatever configuration stuff is necessary and
        // indicate SUCCESS
        //

        lResult = 0;


ProviderInstall_freeProviderList:

        LocalFree (pProviderList);

ProviderInstall_unloadTapi32:

        FreeLibrary (hTapi32);
    }
    else
    {
        //
        // Do whatever configuration stuff is necessary and return SUCCESS
        //

        lResult = 0;
    }

ProviderInstall_return:

    return lResult;
}


#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[128] = "ESPUI: ";
        va_list ap;


        va_start(ap, lpszFormat);

        vsprintf (&buf[7],
                  lpszFormat,
                  ap
                  );

        strcat (buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\kmddsp\allocatr.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: allocatr.c
//
// History:
//      Yi Sun  June-28-2000    Created
//
// Abstract:
//      There could be tens of thousands of calls each day for a RAS server. 
//      6 or 7 requests on average per call. Each request requires to allocate
//      a request block of which the size can be as small as 20 bytes and as
//      large as 1000 bytes, all depending on both the request type and the
//      parameters. If all request allocation comes directly from OS, you can
//      imagine how bad the memory fragmentation situation would be after a
//      while. To avoid that, we keep a list of request blocks from the 
//      smallest to the largest. Whenever we need to allocate one, we traverse
//      the list looking for the first free one that's large enough to host
//      the current request. If we can't find one, we allocate a block
//      directly from OS and insert it into the list. To avoid having lots of
//      small blocks in the list, we free back to the OS the smallest block 
//      which is not currently being occupied by any request whenever we are
//      going to allocate a new block from the OS. 
//      We also keep lists of call objs and line objs instead of allocating
//      and freeing them directly from/to OS, for the same reason (although to
//      a less extent) stated above.
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stddef.h"
#include "tapi.h"
#include "kmddsp.h"

typedef struct _VARSIZED_BLOCK
{
    DWORD                   dwSize;     // size of the mem block
    BOOL                    bInUse;     // whether occupied by a request
    BOOL                    bInDrv;     // whether req is being processed by drv

    struct _VARSIZED_BLOCK *pNext;      // points to the next block node

    BYTE                    bytes[1];   // the mem block starts from here
                                        // NOTE: bytes needs to be the last
                                        // field in the struct
                                        // NOTE: make sure bytes is following
                                        // a pointer. That way, we won't have 
                                        // alignment problem
} VARSIZED_BLOCK, *PVARSIZED_BLOCK;

//
// a sorted list of req blocks from smallest to largest
//
typedef struct _VARSIZED_BLOCK_LIST
{
#if DBG
    DWORD                   dwTotal;    // total number of mem blks outstanding
#endif //DBG
    PVARSIZED_BLOCK         pHead;      // points to the head of req block list
    CRITICAL_SECTION        critSec;    // shared mem protection

} VARSIZED_BLOCK_LIST;

typedef struct _FIXSIZED_BLOCK
{
    struct _FIXSIZED_BLOCK *pNext;      // points to the next block node

} FIXSIZED_BLOCK, *PFIXSIZED_BLOCK;

typedef struct _FIXSIZED_BLOCK_LIST
{
#if DBG
    DWORD                   dwTotal;    // total number of mem blks outstanding
    DWORD                   dwUsed;     // total number of mem blocks used
#endif //DBG
    DWORD                   dwSize;     // size of each mem block in the list
    PFIXSIZED_BLOCK         pHeadFree;  // points to the head of free blk list
    CRITICAL_SECTION        critSec;    // shared mem protection

} FIXSIZED_BLOCK_LIST;

static VARSIZED_BLOCK_LIST gReqList;

static FIXSIZED_BLOCK_LIST gCallObjList;
static FIXSIZED_BLOCK_LIST gLineObjList;

VOID
InitAllocator()
{
    TspLog(DL_TRACE, "InitAllocator: entering...");

    InitializeCriticalSection(&gReqList.critSec);
#if DBG
    gReqList.dwTotal = 0;
#endif // DBG
    gReqList.pHead = NULL;

    InitializeCriticalSection(&gCallObjList.critSec);
    gCallObjList.dwSize = 0;
#if DBG
    gCallObjList.dwTotal = 0;
    gCallObjList.dwUsed = 0;
#endif //DBG
    gCallObjList.pHeadFree = NULL;

    InitializeCriticalSection(&gLineObjList.critSec);
    gLineObjList.dwSize = 0;
#if DBG
    gLineObjList.dwTotal = 0;
    gLineObjList.dwUsed = 0;
#endif //DBG
    gLineObjList.pHeadFree = NULL;
}

VOID
UninitAllocator()
{
    DWORD i = 0, j = 0, k = 0;

    while (gReqList.pHead != NULL)
    {
        PVARSIZED_BLOCK pBlock = gReqList.pHead;
        gReqList.pHead = gReqList.pHead->pNext;

        ASSERT(FALSE == pBlock->bInUse);
        
        FREE(pBlock);
        i++;
    }
    ASSERT(i == gReqList.dwTotal);
    DeleteCriticalSection(&gReqList.critSec);

    ASSERT(0 == gCallObjList.dwUsed);
    while (gCallObjList.pHeadFree != NULL)
    {
        PFIXSIZED_BLOCK pBlock = gCallObjList.pHeadFree;
        gCallObjList.pHeadFree = gCallObjList.pHeadFree->pNext;

        FREE(pBlock);
        j++;
    }
    ASSERT(j == gCallObjList.dwTotal);
    DeleteCriticalSection(&gCallObjList.critSec);

    ASSERT(0 == gLineObjList.dwUsed);
    while (gLineObjList.pHeadFree != NULL)
    {
        PFIXSIZED_BLOCK pBlock = gLineObjList.pHeadFree;
        gLineObjList.pHeadFree = gLineObjList.pHeadFree->pNext;

        FREE(pBlock);
        k++;
    }
    ASSERT(k == gLineObjList.dwTotal);
    DeleteCriticalSection(&gLineObjList.critSec);

    TspLog(DL_TRACE, "UninitAllocator: exited(%d, %d, %d)", i, j, k);
}

PVOID
AllocRequest(
    IN DWORD dwSize
    )
{
    PVARSIZED_BLOCK pNew;
    PVARSIZED_BLOCK pPrevFree = NULL;   // point to first free node's prev node
    BOOL bFoundFree = FALSE;            // whether we have found a free node
    PVARSIZED_BLOCK pPrevSize = NULL;   // point to node after which a node of 
                                        // size dwSize would insert
    PVARSIZED_BLOCK pPPrevSize = NULL;  // point to prev node of pPrevSize
    BOOL bFoundSize = FALSE;            // whether we have found the right pos

    EnterCriticalSection(&gReqList.critSec);

    if (gReqList.pHead != NULL)
    {
        PVARSIZED_BLOCK pCurr = gReqList.pHead;

        // see if there is a large enough free mem block 
        while ((pCurr != NULL) && 
               (pCurr->bInUse ||            // not a free node
                (dwSize > pCurr->dwSize)))  // not large enough
        {
            if (!pCurr->bInUse)             // found a free node
            {
                bFoundFree = TRUE;
            }
            if (!bFoundFree)
            {
                pPrevFree = pCurr;          // move pPrevFree until
                                            // a free node is found
            }
            if (dwSize <= pCurr->dwSize)    // found the location
            {
                bFoundSize = TRUE;
            }
            if (!bFoundSize)
            {
                pPPrevSize = pPrevSize;
                pPrevSize = pCurr;          // move pPrevSize until
                                            // a larger node is found
            }

            pCurr = pCurr->pNext;           // check the next one
        }

        if (pCurr != NULL) // found one
        {
            pCurr->bInUse = TRUE;

            LeaveCriticalSection(&gReqList.critSec);

#if 0 //DBG
            TspLog(DL_TRACE, "pHead(%p)", gReqList.pHead);
#endif //DBG

            return (PVOID)pCurr->bytes;
        }
        else // none of the free blocks is large enough
        {
            if (bFoundFree)
            {
                PVARSIZED_BLOCK pFree;

                // we are going to allocate one from the system,
                // to avoid having too many mem blocks outstanding
                // we free the smallest free block
                if (NULL == pPrevFree) // the head node is a free one
                {
                    pFree = gReqList.pHead;
                    gReqList.pHead = pFree->pNext;
                }
                else
                {
                    pFree = pPrevFree->pNext;
                    pPrevFree->pNext = pFree->pNext;
                }
                ASSERT(FALSE == pFree->bInUse);

                // if pPrevSize is the same as pFree,
                // reset pPrevSize to pPPrevSize
                if (pPrevSize == pFree)
                {
                    pPrevSize = pPPrevSize;
                }

                FREE(pFree);
#if DBG
                TspLog(DL_TRACE, "AllocRequest: after free, total(%d)",
                       --gReqList.dwTotal);
#endif //DBG
            }
        }
    }

    // make sure dwSize is ptr-size aligned
    dwSize = (dwSize + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);

    // need to allocate and zeroinit a mem block from the system
    pNew = (PVARSIZED_BLOCK)MALLOC(offsetof(VARSIZED_BLOCK, bytes) + 
                               dwSize * sizeof(BYTE));
    if (NULL == pNew)
    {
        TspLog(DL_ERROR, "AllocRequest: failed to alloc a req block");
        LeaveCriticalSection(&gReqList.critSec);
        return NULL;
    }
#if DBG
    TspLog(DL_TRACE, "AllocRequest: after alloc, total(%d)", 
           ++gReqList.dwTotal);
#endif //DBG

    pNew->dwSize = dwSize;
    pNew->bInUse = TRUE;

    // insert the newly created node into the list
    if (NULL == pPrevSize)
    {
        pNew->pNext = gReqList.pHead;
        gReqList.pHead = pNew;
    }
    else
    {
        pNew->pNext = pPrevSize->pNext;
        pPrevSize->pNext = pNew;
    }

    LeaveCriticalSection(&gReqList.critSec);

#if 0 //DBG
    TspLog(DL_TRACE, "pPrevSize(%p), pNew(%p), pHead(%p)",
           pPrevSize, pNew, gReqList.pHead);
#endif //DBG

    // return the mem ptr
    return (PVOID)pNew->bytes;
}

VOID
FreeRequest(
    IN PVOID pMem
    )
{
    PVARSIZED_BLOCK pBlock = (PVARSIZED_BLOCK)((PBYTE)pMem - 
                                        offsetof(VARSIZED_BLOCK, bytes));
    ASSERT((pBlock != NULL) && (TRUE == pBlock->bInUse) && 
           (FALSE == pBlock->bInDrv));

    EnterCriticalSection(&gReqList.critSec);

    pBlock->bInUse = FALSE;
    ZeroMemory(pBlock->bytes, pBlock->dwSize * sizeof(BYTE));

    LeaveCriticalSection(&gReqList.critSec);
}

//
// called before passing the req to driver in an IOCTL
//
VOID
MarkRequest(
    IN PVOID pMem
    )
{
    PVARSIZED_BLOCK pBlock = (PVARSIZED_BLOCK)((PBYTE)pMem -
                                        offsetof(VARSIZED_BLOCK, bytes));
    ASSERT((pBlock != NULL) && (TRUE == pBlock->bInUse) &&
           (FALSE == pBlock->bInDrv));

    //EnterCriticalSection(&gReqList.critSec);

    pBlock->bInDrv = TRUE;

    //LeaveCriticalSection(&gReqList.critSec);
}

//
// called after the IOCTL gets completed
//
VOID
UnmarkRequest(
    IN PVOID pMem
    )
{
    PVARSIZED_BLOCK pBlock = (PVARSIZED_BLOCK)((PBYTE)pMem -
                                        offsetof(VARSIZED_BLOCK, bytes));
    ASSERT((pBlock != NULL) && (TRUE == pBlock->bInUse) &&
           (TRUE == pBlock->bInDrv));

    //EnterCriticalSection(&gReqList.critSec);

    pBlock->bInDrv = FALSE;

    //LeaveCriticalSection(&gReqList.critSec);
}

PVOID
AllocCallObj(
    DWORD dwSize
    )
{
    PFIXSIZED_BLOCK pBlock;

    if (0 == gCallObjList.dwSize)
    {
        ASSERT(dwSize >= sizeof(PFIXSIZED_BLOCK));
        gCallObjList.dwSize = dwSize;
    }

    ASSERT(dwSize == gCallObjList.dwSize);

    EnterCriticalSection(&gCallObjList.critSec);

    // move the node out of the free list
    if (gCallObjList.pHeadFree != NULL)
    {
        pBlock = gCallObjList.pHeadFree;
        gCallObjList.pHeadFree = pBlock->pNext;
    }
    else
    {
        pBlock = (PFIXSIZED_BLOCK)MALLOC(dwSize);
        if (NULL == pBlock)
        {
            TspLog(DL_ERROR, "AllocCallObj: failed to alloc a call obj");
            LeaveCriticalSection(&gCallObjList.critSec);
            return NULL;
        }
#if DBG
        TspLog(DL_TRACE, "AllocCallObj: after alloc, total(%d)", 
               ++gCallObjList.dwTotal);
#endif //DBG
    }
    
#if DBG
    gCallObjList.dwUsed++;
#endif //DBG

    LeaveCriticalSection(&gCallObjList.critSec);

    return (PVOID)pBlock;
}

VOID
FreeCallObj(
    IN PVOID pCall
    )
{
    PFIXSIZED_BLOCK pBlock = (PFIXSIZED_BLOCK)pCall;
#if DBG
    static DWORD    dwSum = 0;
    TspLog(DL_TRACE, "FreeCallObj(%d): pCall(%p)", ++dwSum, pCall);
#endif //DBG

    ASSERT(pBlock != NULL);
    ZeroMemory(pBlock, gCallObjList.dwSize);

    EnterCriticalSection(&gCallObjList.critSec);

    // insert the node back into the free list
    pBlock->pNext = gCallObjList.pHeadFree;
    gCallObjList.pHeadFree = pBlock;

#if DBG
    gCallObjList.dwUsed--;
#endif //DBG

    LeaveCriticalSection(&gCallObjList.critSec);
}

PVOID
AllocLineObj(
    DWORD dwSize
    )
{
    PFIXSIZED_BLOCK pBlock;

    if (0 == gLineObjList.dwSize)
    {
        ASSERT(dwSize >= sizeof(PFIXSIZED_BLOCK));
        gLineObjList.dwSize = dwSize;
    }

    ASSERT(dwSize == gLineObjList.dwSize);

    EnterCriticalSection(&gLineObjList.critSec);

    // move the node out of the free list
    if (gLineObjList.pHeadFree != NULL)
    {
        pBlock = gLineObjList.pHeadFree;
        gLineObjList.pHeadFree = pBlock->pNext;
    }
    else
    {
        pBlock = (PFIXSIZED_BLOCK)MALLOC(dwSize);
        if (NULL == pBlock)
        {
            TspLog(DL_ERROR, "AllocLineObj: failed to alloc a line obj");
            LeaveCriticalSection(&gLineObjList.critSec);
            return NULL;
        }
#if DBG
        TspLog(DL_TRACE, "AllocLineObj: after alloc, total(%d)", 
               ++gLineObjList.dwTotal);
#endif //DBG
    }
    
#if DBG
    gLineObjList.dwUsed++;
#endif //DBG

    LeaveCriticalSection(&gLineObjList.critSec);

    return (PVOID)pBlock;
}

VOID
FreeLineObj(
    IN PVOID pLine
    )
{
    PFIXSIZED_BLOCK pBlock = (PFIXSIZED_BLOCK)pLine;
#if DBG
    static DWORD    dwSum = 0;
    TspLog(DL_TRACE, "FreeLineObj(%d): pLine(%p)", ++dwSum, pLine);
#endif //DBG

    ASSERT(pBlock != NULL);
    ZeroMemory(pBlock, gLineObjList.dwSize);

    EnterCriticalSection(&gLineObjList.critSec);

    // insert the node back into the free list
    pBlock->pNext = gLineObjList.pHeadFree;
    gLineObjList.pHeadFree = pBlock;

#if DBG
    gLineObjList.dwUsed--;
#endif //DBG

    LeaveCriticalSection(&gLineObjList.critSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\kmddsp\devlist.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: devlist.c
//
// History:
//      Yi Sun  July-26-2000    Created
//
// Abstract:
//      TSPI_lineGetDevCaps queries a specified line device to determine 
//      its telephony capabilities. The returned cap structure doesn't change
//      with time. This allows us to be able to save that structure so that
//      we don't have to take a user/kernel transition for every GetCaps call.
//      We also save negotiated/committed TSPI version and extension version
//      so that we can verify version numbers passed in with a GetCaps call.
//      Since TSPI_lineGetNumAddressIDs is based on TSPI_lineGetDevCaps, by
//      implementing this optimization, we also save an IOCTL call for every
//      GetNumAddressIDs call.
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "tapi.h"
#include "kmddsp.h"

typedef struct _LINE_DEV_NODE
{
    struct _LINE_DEV_NODE  *pNext;
    LINEDEVCAPS            *pCaps;
    DWORD                   dwDeviceID;
    DWORD                   dwNegTSPIV; // negotiated TSPI version
    DWORD                   dwComTSPIV; // committed TSPI version
    DWORD                   dwNegExtV;  // negotiated ext version
    DWORD                   dwComExtV;  // committed ext version

} LINE_DEV_NODE, *PLINE_DEV_NODE;

typedef struct _LINE_DEV_LIST
{
    CRITICAL_SECTION    critSec;
    PLINE_DEV_NODE      pHead;

} LINE_DEV_LIST, *PLINE_DEV_LIST;

static LINE_DEV_LIST gLineDevList;

//
// call InitLineDevList() in DllMain(): DLL_PROCESS_ATTACH
// to make sure that the dev list is initialized before 
// TSPI version negotiation happens
//
VOID
InitLineDevList()
{
    InitializeCriticalSection(&gLineDevList.critSec);
    gLineDevList.pHead = NULL;
}

//
// call UninitLineDevList() in DllMain(): DLL_PROCESS_DETACH
//
VOID
UninitLineDevList()
{
    while (gLineDevList.pHead != NULL)
    {
        PLINE_DEV_NODE pNode = gLineDevList.pHead;
        gLineDevList.pHead = gLineDevList.pHead->pNext;

        if (pNode->pCaps != NULL)
        {
            FREE(pNode->pCaps);
        }

        FREE(pNode);
    }

    DeleteCriticalSection(&gLineDevList.critSec);
}

PLINE_DEV_NODE
GetLineDevNode(
    IN DWORD    dwDeviceID
    )
{
    PLINE_DEV_NODE pNode;
    
    EnterCriticalSection(&gLineDevList.critSec);

    pNode = gLineDevList.pHead;
    while ((pNode != NULL) && (pNode->dwDeviceID != dwDeviceID))
    {
        pNode = pNode->pNext;
    }

    if (pNode != NULL)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return pNode;
    }

    // pNode == NULL
    // so allocate and zeroinit a node
    pNode = (PLINE_DEV_NODE)MALLOC(sizeof(LINE_DEV_NODE));
    if (NULL == pNode)
    {
        TspLog(DL_ERROR, "GetLineDevNode: failed to alloc LINE_DEV_NODE");
        LeaveCriticalSection(&gLineDevList.critSec);
        return NULL;
    }

    ASSERT(pNode != NULL);
    // init pNode
    pNode->dwDeviceID = dwDeviceID;

    // insert pNode into the list
    pNode->pNext = gLineDevList.pHead;
    gLineDevList.pHead = pNode;

    LeaveCriticalSection(&gLineDevList.critSec);
    return pNode;
}

//
// TSPI_lineNegotiateTSPIVersion calls this function to pass
// the negotiated TSPI version number
//
LONG
SetNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwTSPIVersion
    )
{
    PLINE_DEV_NODE pNode;
    
    TspLog(DL_TRACE, "SetNegotiatedTSPIVersion: deviceID(%x), TSPIV(%x)",
           dwDeviceID, dwTSPIVersion);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwNegTSPIV = dwTSPIVersion;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineNegotiateExtVersion calls this function to pass 
// the negotiated extension version number
//
LONG
SetNegotiatedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    PLINE_DEV_NODE pNode;
    
    TspLog(DL_TRACE, "SetNegotiatedExtVersion: deviceID(%x), ExtV(%x)",
           dwDeviceID, dwExtVersion);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwNegExtV = dwExtVersion;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineSelectExtVersion calls this function to commit/decommit
// extension version. The ext version is decommitted by selecting ext
// version 0
//
LONG
SetSelectedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    PLINE_DEV_NODE pNode;

    TspLog(DL_TRACE, "SetSelectedExtVersion: deviceID(%x), ExtV(%x)",
           dwDeviceID, dwExtVersion);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    if ((dwExtVersion != 0) && (dwExtVersion != pNode->dwNegExtV))
    {
        TspLog(DL_ERROR,
               "SetSelectedExtVersion: ext version(%x) not match "\
               "the negotiated one(%x)",
               dwExtVersion, pNode->dwNegExtV);

        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_INCOMPATIBLEEXTVERSION;
    }

    pNode->dwComExtV = dwExtVersion;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineOpen calls this function to commit TSPI version
//
LONG
CommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    )
{
    PLINE_DEV_NODE pNode;

    TspLog(DL_TRACE, "CommitNegotiatedTSPIVersion: deviceID(%x)", dwDeviceID);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwComTSPIV = pNode->dwNegTSPIV;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineClose calls this function to decommit TSPI version
//
LONG
DecommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    )
{
    PLINE_DEV_NODE pNode;

    TspLog(DL_TRACE, "DecommitNegotiatedTSPIVersion: deviceID(%x)", dwDeviceID);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwComTSPIV = 0;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// actual implementation of TSPI_lineGetNumAddressIDs
//
LONG
GetNumAddressIDs(
    IN DWORD    dwDeviceID,
    OUT DWORD  *pdwNumAddressIDs
    )
{
    PLINE_DEV_NODE pNode;
    
    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    ASSERT(pNode != NULL);
    if (NULL == pNode->pCaps)
    {
        pNode->pCaps = GetLineDevCaps(dwDeviceID, pNode->dwComExtV);
        if (NULL == pNode->pCaps)
        {
            LeaveCriticalSection(&gLineDevList.critSec);
            return LINEERR_NOMEM;
        }
    }

    ASSERT(pNode->pCaps != NULL);
    *pdwNumAddressIDs = pNode->pCaps->dwNumAddresses;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// actual implementation of TSPI_lineGetDevCaps
//
LONG
GetDevCaps(
    IN DWORD            dwDeviceID,
    IN DWORD            dwTSPIVersion,
    IN DWORD            dwExtVersion,
    OUT LINEDEVCAPS    *pLineDevCaps
    )
{
    PLINE_DEV_NODE pNode;
    
    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    ASSERT(pNode != NULL);
    //
    // check the version numbers
    //
    if ((pNode->dwComTSPIV != 0) && (dwTSPIVersion != pNode->dwComTSPIV))
    {
        TspLog(DL_ERROR, 
               "GetDevCaps: tspi version(%x) not match"\
               "the committed one(%x)",
               dwTSPIVersion, pNode->dwComTSPIV);

        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }
    if ((pNode->dwComExtV != 0) && (dwExtVersion != pNode->dwComExtV))
    {
        TspLog(DL_ERROR, 
               "GetDevCaps: ext version(%x) not match "\
               "the committed one(%x)",
               dwExtVersion, pNode->dwComExtV);

        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_INCOMPATIBLEEXTVERSION;
    }

    if (NULL == pNode->pCaps)
    {
        pNode->pCaps = GetLineDevCaps(dwDeviceID, dwExtVersion);
        if (NULL == pNode->pCaps)
        {
            LeaveCriticalSection(&gLineDevList.critSec);
            return LINEERR_NOMEM;
        }
    }

    ASSERT(pNode->pCaps != NULL);
    
    //
    // copy caps over
    //
    if (pNode->pCaps->dwNeededSize > pLineDevCaps->dwTotalSize)
    {
        pLineDevCaps->dwNeededSize = pNode->pCaps->dwNeededSize;
        pLineDevCaps->dwUsedSize = 
            (pLineDevCaps->dwTotalSize < sizeof(LINEDEVCAPS) ?
             pLineDevCaps->dwTotalSize : sizeof(LINEDEVCAPS));

        ASSERT(pLineDevCaps->dwUsedSize >= 10);
        // reset dwProviderInfoSize to dwLineNameOffset to 0
        ZeroMemory(&pLineDevCaps->dwProviderInfoSize, 7 * sizeof(DWORD));
        // copy over dwPermanentLineID
        pLineDevCaps->dwPermanentLineID = pNode->pCaps->dwPermanentLineID;
        // copy everything from dwStringFormat
        CopyMemory(&pLineDevCaps->dwStringFormat, 
                   &pNode->pCaps->dwStringFormat, 
                   pLineDevCaps->dwUsedSize - 10 * sizeof(DWORD));

        // we don't need to set dwTerminalCaps(Size, Offset), 
        // dwTerminalText(Size, Offset), etc. to 0
        // because these fields have been preset with 0
        // before the service provider was called
    }
    else
    {
        // copy over all fields except dwTotalSize
        CopyMemory(&pLineDevCaps->dwNeededSize,
                   &pNode->pCaps->dwNeededSize,
                   pNode->pCaps->dwNeededSize - sizeof(DWORD));
        
    }

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\ndptsp\tsp\allocatr.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: allocatr.c
//
// History:
//      Yi Sun  June-28-2000    Created
//
// Abstract:
//      There could be tens of thousands of calls each day for a RAS server.
//      6 or 7 requests on average per call. Each request requires to allocate
//      a request block of which the size can be as small as 20 bytes and as
//      large as 1000 bytes, all depending on both the request type and the
//      parameters. If all request allocation comes directly from OS, you can
//      imagine how bad the memory fragmentation situation would be after a
//      while. To avoid that, we keep a list of request blocks from the
//      smallest to the largest. Whenever we need to allocate one, we traverse
//      the list looking for the first free one that's large enough to host
//      the current request. If we can't find one, we allocate a block
//      directly from OS and insert it into the list. To avoid having lots of
//      small blocks in the list, we free back to the OS the smallest block
//      which is not currently being occupied by any request whenever we are
//      going to allocate a new block from the OS.
//      We also keep lists of call objs and line objs instead of allocating
//      and freeing them directly from/to OS, for the same reason (although to
//      a less extent) stated above.
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stddef.h"
#include "tapi.h"
#include "ndptsp.h"

typedef struct _VARSIZED_BLOCK
{
    DWORD                   dwSize;     // size of the mem block
    BOOL                    bInUse;     // whether occupied by a request
    BOOL                    bInDrv;     // whether req is being processed by drv

    struct _VARSIZED_BLOCK *pNext;      // points to the next block node

    BYTE                    bytes[1];   // the mem block starts from here
                                        // NOTE: bytes needs to be the last
                                        // field in the struct
                                        // NOTE: make sure bytes is following
                                        // a pointer. That way, we won't have 
                                        // alignment problem
} VARSIZED_BLOCK, *PVARSIZED_BLOCK;

//
// a sorted list of req blocks from smallest to largest
//
typedef struct _VARSIZED_BLOCK_LIST
{
#if DBG
    DWORD                   dwTotal;    // total number of mem blks outstanding
#endif //DBG
    PVARSIZED_BLOCK         pHead;      // points to the head of req block list
    CRITICAL_SECTION        critSec;    // shared mem protection

} VARSIZED_BLOCK_LIST;

typedef struct _FIXSIZED_BLOCK
{
    struct _FIXSIZED_BLOCK *pNext;      // points to the next block node

} FIXSIZED_BLOCK, *PFIXSIZED_BLOCK;

typedef struct _FIXSIZED_BLOCK_LIST
{
#if DBG
    DWORD                   dwTotal;    // total number of mem blks outstanding
    DWORD                   dwUsed;     // total number of mem blocks used
#endif //DBG
    DWORD                   dwSize;     // size of each mem block in the list
    PFIXSIZED_BLOCK         pHeadFree;  // points to the head of free blk list
    CRITICAL_SECTION        critSec;    // shared mem protection

} FIXSIZED_BLOCK_LIST;

static VARSIZED_BLOCK_LIST gReqList;

static FIXSIZED_BLOCK_LIST gCallObjList;
static FIXSIZED_BLOCK_LIST gLineObjList;
static FIXSIZED_BLOCK_LIST gMSPLineObjList;

VOID
InitAllocator()
{
    TspLog(DL_TRACE, "InitAllocator: entering...");

    InitializeCriticalSection(&gReqList.critSec);
#if DBG
    gReqList.dwTotal = 0;
#endif // DBG
    gReqList.pHead = NULL;

    InitializeCriticalSection(&gCallObjList.critSec);
    gCallObjList.dwSize = 0;
#if DBG
    gCallObjList.dwTotal = 0;
    gCallObjList.dwUsed = 0;
#endif //DBG
    gCallObjList.pHeadFree = NULL;

    InitializeCriticalSection(&gLineObjList.critSec);
    gLineObjList.dwSize = 0;
#if DBG
    gLineObjList.dwTotal = 0;
    gLineObjList.dwUsed = 0;
#endif //DBG
    gLineObjList.pHeadFree = NULL;

    InitializeCriticalSection(&gMSPLineObjList.critSec);
    gMSPLineObjList.dwSize = 0;
#if DBG
    gMSPLineObjList.dwTotal = 0;
    gMSPLineObjList.dwUsed = 0;
#endif //DBG
    gMSPLineObjList.pHeadFree = NULL;
}

VOID
UninitAllocator()
{
    DWORD i = 0, j = 0, k = 0, l = 0;

    while (gReqList.pHead != NULL)
    {
        PVARSIZED_BLOCK pBlock = gReqList.pHead;
        gReqList.pHead = gReqList.pHead->pNext;

        ASSERT(FALSE == pBlock->bInUse);
        
        FREE(pBlock);
        i++;
    }
    ASSERT(i == gReqList.dwTotal);
    DeleteCriticalSection(&gReqList.critSec);

    ASSERT(0 == gCallObjList.dwUsed);
    while (gCallObjList.pHeadFree != NULL)
    {
        PFIXSIZED_BLOCK pBlock = gCallObjList.pHeadFree;
        gCallObjList.pHeadFree = gCallObjList.pHeadFree->pNext;

        FREE(pBlock);
        j++;
    }
    ASSERT(j == gCallObjList.dwTotal);
    DeleteCriticalSection(&gCallObjList.critSec);

    ASSERT(0 == gLineObjList.dwUsed);
    while (gLineObjList.pHeadFree != NULL)
    {
        PFIXSIZED_BLOCK pBlock = gLineObjList.pHeadFree;
        gLineObjList.pHeadFree = gLineObjList.pHeadFree->pNext;

        FREE(pBlock);
        k++;
    }
    ASSERT(k == gLineObjList.dwTotal);
    DeleteCriticalSection(&gLineObjList.critSec);

    ASSERT(0 == gMSPLineObjList.dwUsed);
    while (gMSPLineObjList.pHeadFree != NULL)
    {
        PFIXSIZED_BLOCK pBlock = gMSPLineObjList.pHeadFree;
        gMSPLineObjList.pHeadFree = gMSPLineObjList.pHeadFree->pNext;

        FREE(pBlock);
        l++;
    }
    ASSERT(l == gMSPLineObjList.dwTotal);
    DeleteCriticalSection(&gMSPLineObjList.critSec);

    TspLog(DL_TRACE, "UninitAllocator: exited(%d, %d, %d, %d)", i, j, k, l);
}

PVOID
AllocRequest(
    IN DWORD dwSize
    )
{
    PVARSIZED_BLOCK pNew;
    PVARSIZED_BLOCK pPrevFree = NULL;   // point to first free node's prev node
    BOOL bFoundFree = FALSE;            // whether we have found a free node
    PVARSIZED_BLOCK pPrevSize = NULL;   // point to node after which a node of 
                                        // size dwSize would insert
    PVARSIZED_BLOCK pPPrevSize = NULL;  // point to prev node of pPrevSize
    BOOL bFoundSize = FALSE;            // whether we have found the right pos

    EnterCriticalSection(&gReqList.critSec);

    if (gReqList.pHead != NULL)
    {
        PVARSIZED_BLOCK pCurr = gReqList.pHead;

        // see if there is a large enough free mem block 
        while ((pCurr != NULL) && 
               (pCurr->bInUse ||            // not a free node
                (dwSize > pCurr->dwSize)))  // not large enough
        {
            if (!pCurr->bInUse)             // found a free node
            {
                bFoundFree = TRUE;
            }
            if (!bFoundFree)
            {
                pPrevFree = pCurr;          // move pPrevFree until
                                            // a free node is found
            }
            if (dwSize <= pCurr->dwSize)    // found the location
            {
                bFoundSize = TRUE;
            }
            if (!bFoundSize)
            {
                pPPrevSize = pPrevSize;
                pPrevSize = pCurr;          // move pPrevSize until
                                            // a larger node is found
            }

            pCurr = pCurr->pNext;           // check the next one
        }

        if (pCurr != NULL) // found one
        {
            pCurr->bInUse = TRUE;

            LeaveCriticalSection(&gReqList.critSec);

#if 0 //DBG
            TspLog(DL_TRACE, "pHead(%p)", gReqList.pHead);
#endif //DBG

            return (PVOID)pCurr->bytes;
        }
        else // none of the free blocks is large enough
        {
            if (bFoundFree)
            {
                PVARSIZED_BLOCK pFree;

                // we are going to allocate one from the system,
                // to avoid having too many mem blocks outstanding
                // we free the smallest free block
                if (NULL == pPrevFree) // the head node is a free one
                {
                    pFree = gReqList.pHead;
                    gReqList.pHead = pFree->pNext;
                }
                else
                {
                    pFree = pPrevFree->pNext;
                    pPrevFree->pNext = pFree->pNext;
                }
                ASSERT(FALSE == pFree->bInUse);

                // if pPrevSize is the same as pFree,
                // reset pPrevSize to pPPrevSize
                if (pPrevSize == pFree)
                {
                    pPrevSize = pPPrevSize;
                }

                FREE(pFree);
#if DBG
                TspLog(DL_TRACE, "AllocRequest: after free, total(%d)",
                       --gReqList.dwTotal);
#endif //DBG
            }
        }
    }

    // make sure dwSize is ptr-size aligned
    dwSize = (dwSize + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);

    // need to allocate and zeroinit a mem block from the system
    pNew = (PVARSIZED_BLOCK)MALLOC(offsetof(VARSIZED_BLOCK, bytes) + 
                               dwSize * sizeof(BYTE));
    if (NULL == pNew)
    {
        TspLog(DL_ERROR, "AllocRequest: failed to alloc a req block");
        LeaveCriticalSection(&gReqList.critSec);
        return NULL;
    }
#if DBG
    TspLog(DL_TRACE, "AllocRequest: after alloc, total(%d)", 
           ++gReqList.dwTotal);
#endif //DBG

    pNew->dwSize = dwSize;
    pNew->bInUse = TRUE;

    // insert the newly created node into the list
    if (NULL == pPrevSize)
    {
        pNew->pNext = gReqList.pHead;
        gReqList.pHead = pNew;
    }
    else
    {
        pNew->pNext = pPrevSize->pNext;
        pPrevSize->pNext = pNew;
    }

    LeaveCriticalSection(&gReqList.critSec);

#if 0 //DBG
    TspLog(DL_TRACE, "pPrevSize(%p), pNew(%p), pHead(%p)",
           pPrevSize, pNew, gReqList.pHead);
#endif //DBG

    // return the mem ptr
    return (PVOID)pNew->bytes;
}

VOID
FreeRequest(
    IN PVOID pMem
    )
{
    PVARSIZED_BLOCK pBlock = (PVARSIZED_BLOCK)((PBYTE)pMem - 
                                        offsetof(VARSIZED_BLOCK, bytes));
    ASSERT((pBlock != NULL) && (TRUE == pBlock->bInUse) && 
           (FALSE == pBlock->bInDrv));

    EnterCriticalSection(&gReqList.critSec);

    pBlock->bInUse = FALSE;
    ZeroMemory(pBlock->bytes, pBlock->dwSize * sizeof(BYTE));

    LeaveCriticalSection(&gReqList.critSec);
}

//
// called before passing the req to driver in an IOCTL
//
VOID
MarkRequest(
    IN PVOID pMem
    )
{
    PVARSIZED_BLOCK pBlock = (PVARSIZED_BLOCK)((PBYTE)pMem -
                                        offsetof(VARSIZED_BLOCK, bytes));
    ASSERT((pBlock != NULL) && (TRUE == pBlock->bInUse) &&
           (FALSE == pBlock->bInDrv));

    //EnterCriticalSection(&gReqList.critSec);

    pBlock->bInDrv = TRUE;

    //LeaveCriticalSection(&gReqList.critSec);
}

//
// called after the IOCTL gets completed
//
VOID
UnmarkRequest(
    IN PVOID pMem
    )
{
    PVARSIZED_BLOCK pBlock = (PVARSIZED_BLOCK)((PBYTE)pMem -
                                        offsetof(VARSIZED_BLOCK, bytes));
    ASSERT((pBlock != NULL) && (TRUE == pBlock->bInUse) &&
           (TRUE == pBlock->bInDrv));

    //EnterCriticalSection(&gReqList.critSec);

    pBlock->bInDrv = FALSE;

    //LeaveCriticalSection(&gReqList.critSec);
}

PVOID
AllocCallObj(
    DWORD dwSize
    )
{
    PFIXSIZED_BLOCK pBlock;

    if (0 == gCallObjList.dwSize)
    {
        ASSERT(dwSize >= sizeof(PFIXSIZED_BLOCK));
        gCallObjList.dwSize = dwSize;
    }

    ASSERT(dwSize == gCallObjList.dwSize);

    EnterCriticalSection(&gCallObjList.critSec);

    // move the node out of the free list
    if (gCallObjList.pHeadFree != NULL)
    {
        pBlock = gCallObjList.pHeadFree;
        gCallObjList.pHeadFree = pBlock->pNext;
    }
    else
    {
        pBlock = (PFIXSIZED_BLOCK)MALLOC(dwSize);
        if (NULL == pBlock)
        {
            TspLog(DL_ERROR, "AllocCallObj: failed to alloc a call obj");
            LeaveCriticalSection(&gCallObjList.critSec);
            return NULL;
        }
#if DBG
        TspLog(DL_TRACE, "AllocCallObj: after alloc, total(%d)", 
               ++gCallObjList.dwTotal);
#endif //DBG
    }
    
#if DBG
    gCallObjList.dwUsed++;
#endif //DBG

    LeaveCriticalSection(&gCallObjList.critSec);

    return (PVOID)pBlock;
}

VOID
FreeCallObj(
    IN PVOID pCall
    )
{
    PFIXSIZED_BLOCK pBlock = (PFIXSIZED_BLOCK)pCall;
#if DBG
    static DWORD    dwSum = 0;
    TspLog(DL_TRACE, "FreeCallObj(%d): pCall(%p)", ++dwSum, pCall);
#endif //DBG

    ASSERT(pBlock != NULL);
    ZeroMemory(pBlock, gCallObjList.dwSize);

    EnterCriticalSection(&gCallObjList.critSec);

    // insert the node back into the free list
    pBlock->pNext = gCallObjList.pHeadFree;
    gCallObjList.pHeadFree = pBlock;

#if DBG
    gCallObjList.dwUsed--;
#endif //DBG

    LeaveCriticalSection(&gCallObjList.critSec);
}

PVOID
AllocLineObj(
    DWORD dwSize
    )
{
    PFIXSIZED_BLOCK pBlock;

    if (0 == gLineObjList.dwSize)
    {
        ASSERT(dwSize >= sizeof(PFIXSIZED_BLOCK));
        gLineObjList.dwSize = dwSize;
    }

    ASSERT(dwSize == gLineObjList.dwSize);

    EnterCriticalSection(&gLineObjList.critSec);

    // move the node out of the free list
    if (gLineObjList.pHeadFree != NULL)
    {
        pBlock = gLineObjList.pHeadFree;
        gLineObjList.pHeadFree = pBlock->pNext;
    }
    else
    {
        pBlock = (PFIXSIZED_BLOCK)MALLOC(dwSize);
        if (NULL == pBlock)
        {
            TspLog(DL_ERROR, "AllocLineObj: failed to alloc a line obj");
            LeaveCriticalSection(&gLineObjList.critSec);
            return NULL;
        }
#if DBG
        TspLog(DL_TRACE, "AllocLineObj: after alloc, total(%d)", 
               ++gLineObjList.dwTotal);
#endif //DBG
    }
    
#if DBG
    gLineObjList.dwUsed++;
#endif //DBG

    LeaveCriticalSection(&gLineObjList.critSec);

    return (PVOID)pBlock;
}

VOID
FreeLineObj(
    IN PVOID pLine
    )
{
    PFIXSIZED_BLOCK pBlock = (PFIXSIZED_BLOCK)pLine;
#if DBG
    static DWORD    dwSum = 0;
    TspLog(DL_TRACE, "FreeLineObj(%d): pLine(%p)", ++dwSum, pLine);
#endif //DBG

    ASSERT(pBlock != NULL);
    ZeroMemory(pBlock, gLineObjList.dwSize);

    EnterCriticalSection(&gLineObjList.critSec);

    // insert the node back into the free list
    pBlock->pNext = gLineObjList.pHeadFree;
    gLineObjList.pHeadFree = pBlock;

#if DBG
    gLineObjList.dwUsed--;
#endif //DBG

    LeaveCriticalSection(&gLineObjList.critSec);
}

PVOID
AllocMSPLineObj(
    DWORD dwSize
    )
{
    PFIXSIZED_BLOCK pBlock;

    if (0 == gMSPLineObjList.dwSize)
    {
        ASSERT(dwSize >= sizeof(PFIXSIZED_BLOCK));
        gMSPLineObjList.dwSize = dwSize;
    }

    ASSERT(dwSize == gMSPLineObjList.dwSize);

    EnterCriticalSection(&gMSPLineObjList.critSec);

    // move the node out of the free list
    if (gMSPLineObjList.pHeadFree != NULL)
    {
        pBlock = gMSPLineObjList.pHeadFree;
        gMSPLineObjList.pHeadFree = pBlock->pNext;
    }
    else
    {
        pBlock = (PFIXSIZED_BLOCK)MALLOC(dwSize);
        if (NULL == pBlock)
        {
            TspLog(DL_ERROR, "AllocLineObj: failed to alloc a line obj");
            LeaveCriticalSection(&gMSPLineObjList.critSec);
            return NULL;
        }
#if DBG
        TspLog(DL_TRACE, "AllocLineObj: after alloc, total(%d)", 
               ++gMSPLineObjList.dwTotal);
#endif //DBG
    }
    
#if DBG
    gMSPLineObjList.dwUsed++;
#endif //DBG

    LeaveCriticalSection(&gMSPLineObjList.critSec);

    return (PVOID)pBlock;
}

VOID
FreeMSPLineObj(
    IN PVOID pLine
    )
{
    PFIXSIZED_BLOCK pBlock = (PFIXSIZED_BLOCK)pLine;
#if DBG
    static DWORD    dwSum = 0;
    TspLog(DL_TRACE, "FreeMSPLineObj(%d): pLine(%p)", ++dwSum, pLine);
#endif //DBG

    ASSERT(pBlock != NULL);
    ZeroMemory(pBlock, gMSPLineObjList.dwSize);

    EnterCriticalSection(&gMSPLineObjList.critSec);

    // insert the node back into the free list
    pBlock->pNext = gMSPLineObjList.pHeadFree;
    gMSPLineObjList.pHeadFree = pBlock;

#if DBG
    gMSPLineObjList.dwUsed--;
#endif //DBG

    LeaveCriticalSection(&gMSPLineObjList.critSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\ndptsp\tsp\ndptsp.h ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: ndptsp.h
//
// History:
//      Yi Sun  June-27-2000    Created
//
// Abstract:
//============================================================================
#ifndef _NDPTSP_H_
#define _NDPTSP_H_

// handle types
#define HT_HDCALL               1
#define HT_HDLINE               2

// tapi success code
#define TAPI_SUCCESS            0

// alloc fixed mem then zeroinit it
#define MALLOC(x)               LocalAlloc(LPTR, x)

#define FREE(x)                 LocalFree(x)

// debug levels
#define DL_ERROR                1
#define DL_WARNING              2
#define DL_INFO                 4
#define DL_TRACE                8

typedef VOID (*FREEOBJPROC)(PVOID);

// debug routine
VOID
TspLog(
    IN DWORD dwDebugLevel,
    IN PCHAR pchFormat,
    ...
    );

//
// implemented in mapper.c
//
LONG
InitializeMapper();

VOID
UninitializeMapper();

LONG
OpenObjHandle(
    IN PVOID pObjPtr,
    IN FREEOBJPROC pfnFreeProc,
    OUT HANDLE *phObj
    );

LONG
CloseObjHandle(
    IN HANDLE hObj
    );

LONG
AcquireObjReadLock(
    IN HANDLE hObj
    );

LONG
GetObjWithReadLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    );

LONG
ReleaseObjReadLock(
    IN HANDLE hObj
    );

LONG
AcquireObjWriteLock(
    IN HANDLE hObj
    );

LONG
GetObjWithWriteLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    );

LONG
ReleaseObjWriteLock(
    IN HANDLE hObj
    );

//
// implemented in allocatr.c
//
VOID
InitAllocator();

VOID
UninitAllocator();

PVOID
AllocRequest(
    IN DWORD dwSize
    );

VOID
FreeRequest(
    IN PVOID pMem
    );

VOID
MarkRequest(
    IN PVOID pMem
    );

VOID
UnmarkRequest(
    IN PVOID pMem
    );

PVOID
AllocCallObj(
    IN DWORD dwSize
    );

VOID
FreeCallObj(
    IN PVOID pCall
    );

PVOID
AllocLineObj(
    IN DWORD dwSize
    );

VOID
FreeLineObj(
    IN PVOID pLine
    );

PVOID
AllocMSPLineObj(
    IN DWORD dwSize
    );

VOID
FreeMSPLineObj(
    IN PVOID pLine
    );

//
// implemented in devlist.c
//
VOID
InitLineDevList();

VOID
UninitLineDevList();

LONG
SetNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwTSPIVersion
    );

LONG
SetNegotiatedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    );

LONG
SetSelectedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    );

LONG
CommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    );

LONG
DecommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    );

LONG
GetNumAddressIDs(
    IN DWORD    dwDeviceID,
    OUT DWORD  *pdwNumAddressIDs
    );

LONG
GetDevCaps(
    IN DWORD            dwDeviceID,
    IN DWORD            dwTSPIVersion,
    IN DWORD            dwExtVersion,
    OUT LINEDEVCAPS    *pLineDevCaps
    );

//
// implemented in ndptsp.c
//
LINEDEVCAPS *
GetLineDevCaps(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    );

#endif // _NDPTSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\kmddsp\mapper.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: mapper.c
//
// History:
//      Yi Sun  June-27-2000    Created
//
// Abstract:
//      We implement a locking system with read and write locks. Callers
//      can simply acquire a read lock to the obj to prevent the obj 
//      from being released since whoever doing the release is supposed
//      acquire the write lock first. Routines for mapping between
//      obj pointers and handles are also provided.
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "tapi.h"
#include "kmddsp.h"

typedef struct _RW_LOCK
{
    CRITICAL_SECTION    critSec;    // critical section
    HANDLE              hEvent;     // no-one-holds-any-lock event
    DWORD               dwRefCt;    // number of threads holding locks

} RW_LOCK, *PRW_LOCK;

typedef struct _MAPPER_ENTRY
{
    // DEF: a free entry is one that no obj is associated with

    RW_LOCK     rwLock;         // a lock for each entry to ensure thread-safe
    PVOID       pObjPtr;        // point to the mem block of the associated obj
                                // NULL when the entry is free
    FREEOBJPROC pfnFreeProc;    // function to call to free the obj
    WORD        wID;            // id used for detecting bad handles
                                // valid value range: 1 - 0x7FFF
    WORD        wIndexNextFree; // index of the next free entry in the global
                                // mapper array, invalid when the entry is busy
} MAPPER_ENTRY, *PMAPPER_ENTRY;

typedef struct _HANDLE_OBJECT_MAPPER
{
    RW_LOCK rwLock;             // a global lock for the whole mapper
    WORD    wNextID;            // a global id counter incremented 
                                // after each handle mapping
    WORD    wIndexFreeHead;     // index of head of free entry list
    DWORD   dwCapacity;         // total number of entries in the array
    DWORD   dwFree;             // total number of free entries left
    PMAPPER_ENTRY pArray;       // the global array that keeps all the mapping

} HANDLE_OBJECT_MAPPER;
    
// the capacity to begin with, can be read from registry
#define INITIAL_MAPPER_SIZE     32
#define MAXIMUM_MAPPER_SIZE     (64 * 1024) // 16-bit index limitation

// the global mapper object
static HANDLE_OBJECT_MAPPER     gMapper;

BOOL
InitializeRWLock(
    IN PRW_LOCK pLock
    )
{
    // create an autoreset event, non-signaled initially
    pLock->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pLock->hEvent)
    {
        return FALSE;
    }

    InitializeCriticalSection(&pLock->critSec);
    pLock->dwRefCt = 0;

    return TRUE;
}

BOOL
UninitializeRWLock(
    IN PRW_LOCK pLock
    )
{
    pLock->dwRefCt = 0;
    DeleteCriticalSection(&pLock->critSec);
    return CloseHandle(pLock->hEvent);
}

//
// NOTE: due to the limitation of the current 
//       implementation, calling AcquireWriteLock() 
//       while holding a read lock of the same 
//       RW_LOCK will result in a DEADLOCK!!!
//       Be sure to release the read lock before 
//       attempting to acquire the write lock.
//       This limitation can be lifted by implementing
//       lock upgrade (from read to write) which
//       requires RW_LOCK to remember ids of all   
//       owning threads.
//

VOID
AcquireReadLock(
    IN PRW_LOCK pLock
    )
{
    //
    // increase the ref count, then leave
    // the critical section to allow others
    // to enter
    //
    EnterCriticalSection(&pLock->critSec);
    ++pLock->dwRefCt;
    LeaveCriticalSection(&pLock->critSec);
}

VOID
ReleaseReadLock(
    IN PRW_LOCK pLock
    )
{
    //
    // decrease the ref count, check whether 
    // the new ref count is 0 (meaning no one
    // else holds any lock), if yes, signal
    // the event to allow others waiting to
    // acquire write locks to continue
    //
    EnterCriticalSection(&pLock->critSec);
    if (0 == --pLock->dwRefCt)
    {
        SetEvent(pLock->hEvent);
    }
    LeaveCriticalSection(&pLock->critSec);
}

VOID
AcquireWriteLock(
    IN PRW_LOCK pLock
    )
{
    //
    // enter critical section, check whether
    // the ref count is 0: if yes, return
    // without leaving the critical section
    // to block others from entering; if no,
    // leave the section before wait for others 
    // to release locks then reenter the section
    //
try_entering_crit_sec:
    EnterCriticalSection(&pLock->critSec);
    if (pLock->dwRefCt > 0)
    {
        // make sure leaving critSec before waiting
        LeaveCriticalSection(&pLock->critSec);

        WaitForSingleObject(pLock->hEvent, INFINITE);
        goto try_entering_crit_sec;
    }
    pLock->dwRefCt = 1;
}

VOID
ReleaseWriteLock(
    IN PRW_LOCK pLock
    )
{
    //
    // reset the ref count to 0, signal
    // the event, leave the critical section
    //
    pLock->dwRefCt = 0;
    SetEvent(pLock->hEvent);
    LeaveCriticalSection(&pLock->critSec);
}

LONG
InitializeMapper(
    )
{
    DWORD dwIndex;

    TspLog(DL_TRACE, "InitializeMapper: entering...");

    // alloc and zeroinit the array
    gMapper.pArray = (PMAPPER_ENTRY)
                         MALLOC(INITIAL_MAPPER_SIZE * sizeof(MAPPER_ENTRY));
    if (NULL == gMapper.pArray)
    {
        TspLog(DL_ERROR, 
               "InitializeMapper: failed to alloc(1) mapper array");
        return LINEERR_NOMEM;
    }

    // init the global lock for the mapper
    InitializeRWLock(&gMapper.rwLock);

    gMapper.wNextID = 1;
    gMapper.wIndexFreeHead = 0;
    gMapper.dwCapacity = INITIAL_MAPPER_SIZE;
    gMapper.dwFree = INITIAL_MAPPER_SIZE;

    // init the lock for each mapper entry and link the free entry list
    for (dwIndex = 0; dwIndex < INITIAL_MAPPER_SIZE - 1; dwIndex++)
    {
        InitializeRWLock(&(gMapper.pArray[dwIndex].rwLock));
        gMapper.pArray[dwIndex].wIndexNextFree = (WORD)(dwIndex + 1);
    }
    InitializeRWLock(&(gMapper.pArray[INITIAL_MAPPER_SIZE - 1].rwLock));

    return TAPI_SUCCESS;
}

VOID
UninitializeMapper()
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < gMapper.dwCapacity; dwIndex++)
    {
        UninitializeRWLock(&(gMapper.pArray[dwIndex].rwLock));
    }

    UninitializeRWLock(&gMapper.rwLock);

    FREE(gMapper.pArray);

    TspLog(DL_TRACE, "UninitializeMapper: exited");
}

//
// NOTE: both OpenObjHandle() and CloseObjHandle() acquire write lock of
//       gMapper.rwLock at the beginning and release it at the end;
//       but that's not the case for AcquireObjReadLock(), GetObjWithReadLock(),
//       AcquireObjWriteLock() and GetObjWithWriteLock(): they acquire read 
//       lock of gMapper.rwLock at the beginning and never release it before 
//       exit, the lock is actually released in either ReleaseObjReadLock() 
//       or ReleaseObjWriteLock(), which means the caller thread of these 
//       four lock-acquiring functions actually not only holds the lock 
//       it intends to acquire but also holds the read lock of gMapper.rwLock 
//       as a by-product. The reason for that is preventing CloseObjHandle()
//       from getting the write lock of gMapper.rwLock while waiting for the
//       write lock for a mapper entry -- that sure will result in a DEADLOCK
//       because if another thread has the read lock for that entry, for it to
//       release the lock, it needs to acquire the read lock of gMapper.rwLock.
//       The consequence of keeping the read lock of gMapper.rwLock is that 
//       the caller thread has to call ReleaseObjXXXLock() to release it
//       before calling OpenObjHandle() or CloseObjHandle() to avoid another
//       kind of DEADLOCK (see previous NOTE).
//       

LONG
OpenObjHandle(
    IN PVOID pObjPtr,
    IN FREEOBJPROC pfnFreeProc,
    OUT HANDLE *phObj
    )
{
    WORD wIndex;
    PMAPPER_ENTRY pEntry;
    DWORD dwHandle;

    AcquireWriteLock(&gMapper.rwLock);

    if (0 == gMapper.dwFree)
    {
        DWORD dwIndex;
        DWORD dwOldSize = gMapper.dwCapacity;
        PMAPPER_ENTRY pOldArray = gMapper.pArray;

        if (MAXIMUM_MAPPER_SIZE == gMapper.dwCapacity)
        {
            TspLog(DL_ERROR, 
                   "OpenObjHandle: failed to grow mapper array");
            ReleaseWriteLock(&gMapper.rwLock);
            return LINEERR_OPERATIONFAILED;
        }

        // increase the capacity by a factor of two
        gMapper.dwCapacity <<= 1;
        
        // allocate a new array twice the old size, then zeroinit it
        gMapper.pArray = (PMAPPER_ENTRY)
                         MALLOC(gMapper.dwCapacity * sizeof(MAPPER_ENTRY));
        if (NULL == gMapper.pArray)
        {
            TspLog(DL_ERROR, 
                   "OpenObjHandle: failed to alloc(2) mapper array");
            ReleaseWriteLock(&gMapper.rwLock);
            return LINEERR_NOMEM;
        }
        
        TspLog(DL_INFO, "OpenObjHandle: the mapper array has grown to %d",
               gMapper.dwCapacity);

        // copy the old array over
        for (dwIndex = 0; dwIndex < dwOldSize; dwIndex++)
        {
            CopyMemory(&(gMapper.pArray[dwIndex].rwLock),
                       &(pOldArray[dwIndex].rwLock),
                       sizeof(RW_LOCK));

            //
            // Delete the lock from the old table and initialize
            // the cs in the new table. Otherwise pageheap will
            // assert when oldtable is being freed - and its not
            // a good thing anyway. Note that since the global
            // lock is held across all Acquire/Get/Release functions
            // for the lock, this is a safe operation to do here -
            // no object would be holding the lock when this is
            // being done since we are holding the write lock
            // for the gmapper.
            //
            DeleteCriticalSection(&pOldArray[dwIndex].rwLock.critSec);
            InitializeCriticalSection(&gMapper.pArray[dwIndex].rwLock.critSec);

            gMapper.pArray[dwIndex].pObjPtr = pOldArray[dwIndex].pObjPtr;
            gMapper.pArray[dwIndex].pfnFreeProc =
                                              pOldArray[dwIndex].pfnFreeProc;
            gMapper.pArray[dwIndex].wID =     pOldArray[dwIndex].wID;
        }

        // init locks for new entries and link them
        for (dwIndex = dwOldSize; dwIndex < gMapper.dwCapacity - 1; dwIndex++)
        {
            InitializeRWLock(&(gMapper.pArray[dwIndex].rwLock));
            gMapper.pArray[dwIndex].wIndexNextFree = (WORD)(dwIndex + 1);
        }
        InitializeRWLock(&(gMapper.pArray[gMapper.dwCapacity - 1].rwLock));

        // reset the globals
        gMapper.dwFree = dwOldSize;
        gMapper.wIndexFreeHead = (WORD)dwOldSize;

        // free the old array
        FREE(pOldArray);
    }

    ASSERT(gMapper.dwFree != 0);
    wIndex = gMapper.wIndexFreeHead;
    pEntry = gMapper.pArray + wIndex;
    gMapper.wIndexFreeHead = pEntry->wIndexNextFree;
    gMapper.dwFree--;

    pEntry->pObjPtr = pObjPtr;
    pEntry->pfnFreeProc = pfnFreeProc;
    pEntry->wID = gMapper.wNextID++;

    // make sure wNextID is within range
    if (gMapper.wNextID & 0x8000)
    {
        gMapper.wNextID = 1;
    }
    pEntry->wIndexNextFree = 0; // it's always 0 when the entry is not free

    //
    // bit 0 is always 0
    // bits 1-16 contains the index into pArray
    // bits 17-31 contains the id
    //
    // this enables us to differentiate the TSP handles
    // created here for outgoing calls and the pseudo handles
    // created in NDISTAPI for incoming calls which always
    // has the lower bit set
    //
    dwHandle = (((pEntry->wID) << 16) | wIndex) << 1;

    // a handle is a ptr, so on 64-bit platform, dwHandle needs to be extended
    *phObj = (HANDLE)UlongToPtr(dwHandle);

    ReleaseWriteLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}

LONG
CloseObjHandle(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireWriteLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "CloseObjHandle: bad handle(%p)", hObj);

        ReleaseWriteLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "CloseObjHandle: closing handle(%p)", hObj);
#endif //DBG

    // free the obj
    (*(gMapper.pArray[wIndex].pfnFreeProc))(gMapper.pArray[wIndex].pObjPtr);

    // close obj handle
    gMapper.pArray[wIndex].pObjPtr = NULL;
    gMapper.pArray[wIndex].pfnFreeProc = NULL;
    gMapper.pArray[wIndex].wID = 0;

    // insert the entry into the free list as the head
    gMapper.pArray[wIndex].wIndexNextFree = gMapper.wIndexFreeHead;
    gMapper.wIndexFreeHead = wIndex;

    // update the free total
    gMapper.dwFree++;

    ReleaseWriteLock(&gMapper.pArray[wIndex].rwLock);
    ReleaseWriteLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}

LONG
AcquireObjReadLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "AcquireObjReadLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireReadLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "AcquireObjReadLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    return TAPI_SUCCESS;
}

LONG
GetObjWithReadLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "GetObjWithReadLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireReadLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "GetObjWithReadLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    *ppObjPtr = gMapper.pArray[wIndex].pObjPtr;
    return TAPI_SUCCESS;
}

LONG
ReleaseObjReadLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "ReleaseObjReadLock: bad handle(%p)", hObj);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseReadLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "ReleaseObjReadLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    ReleaseReadLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}

LONG
AcquireObjWriteLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "AcquireObjWriteLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "AcquireObjWriteLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    return TAPI_SUCCESS;
}

LONG
GetObjWithWriteLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "GetObjWithWriteLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "GetObjWithWriteLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    *ppObjPtr = gMapper.pArray[wIndex].pObjPtr;
    return TAPI_SUCCESS;
}

LONG
ReleaseObjWriteLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "ReleaseObjWriteLock: bad handle(%p)", hObj);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "ReleaseObjWriteLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    ReleaseReadLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\ndptsp\tsp\resource.h ===
#define IDD_MEDIA_MAP                   10
#define IDD_MEDIA_ADD                   101

#define IDC_STATIC						(-1)

#define IDC_MEDIA_TYPE                  1000
#define IDC_ADDRESS_LIST                1001
#define IDC_ADD_ADDRESS                 1002
#define IDC_DELETE_ADDRESS              1003
#define IDC_ADDRESS_GROUP				1004

#define IDS_TYPE_DIGITALDATA			2000
#define IDS_TYPE_INTERACTIVEVOICE		2001
#define IDS_TYPE_G3FAX					2002
#define IDS_TYPE_G4FAX					2003

#define IDS_ERR_REGLOAD					2020
#define IDS_ERR_BAD_ADDRESS				2021
#define	IDS_ERR_ALREADY_ASSIGNED		2022
#define	IDS_ERR_DUPLICATE_ADDRESS		2023
#define IDS_ERR_OOM						2024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\ndptsp\tsp\mapper.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: mapper.c
//
// History:
//      Yi Sun  June-27-2000    Created
//
// Abstract:
//      We implement a locking system with read and write locks. Callers
//      can simply acquire a read lock to the obj to prevent the obj
//      from being released since whoever doing the release is supposed
//      acquire the write lock first. Routines for mapping between
//      obj pointers and handles are also provided.
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "tapi.h"
#include "ndptsp.h"

typedef struct _RW_LOCK
{
    CRITICAL_SECTION    critSec;    // critical section
    HANDLE              hEvent;     // no-one-holds-any-lock event
    DWORD               dwRefCt;    // number of threads holding locks

} RW_LOCK, *PRW_LOCK;

typedef struct _MAPPER_ENTRY
{
    // DEF: a free entry is one that no obj is associated with

    RW_LOCK     rwLock;         // a lock for each entry to ensure thread-safe
    PVOID       pObjPtr;        // point to the mem block of the associated obj
                                // NULL when the entry is free
    FREEOBJPROC pfnFreeProc;    // function to call to free the obj
    WORD        wID;            // id used for detecting bad handles
                                // valid value range: 1 - 0x7FFF
    WORD        wIndexNextFree; // index of the next free entry in the global
                                // mapper array, invalid when the entry is busy
} MAPPER_ENTRY, *PMAPPER_ENTRY;

typedef struct _HANDLE_OBJECT_MAPPER
{
    RW_LOCK rwLock;             // a global lock for the whole mapper
    WORD    wNextID;            // a global id counter incremented 
                                // after each handle mapping
    WORD    wIndexFreeHead;     // index of head of free entry list
    DWORD   dwCapacity;         // total number of entries in the array
    DWORD   dwFree;             // total number of free entries left
    PMAPPER_ENTRY pArray;       // the global array that keeps all the mapping

} HANDLE_OBJECT_MAPPER;
    
// the capacity to begin with, can be read from registry
#define INITIAL_MAPPER_SIZE     32
#define MAXIMUM_MAPPER_SIZE     (64 * 1024) // 16-bit index limitation

// the global mapper object
static HANDLE_OBJECT_MAPPER     gMapper;

BOOL
InitializeRWLock(
    IN PRW_LOCK pLock
    )
{
    // create an autoreset event, non-signaled initially
    pLock->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pLock->hEvent)
    {
        return FALSE;
    }

    InitializeCriticalSection(&pLock->critSec);
    pLock->dwRefCt = 0;

    return TRUE;
}

BOOL
UninitializeRWLock(
    IN PRW_LOCK pLock
    )
{
    pLock->dwRefCt = 0;
    DeleteCriticalSection(&pLock->critSec);
    return CloseHandle(pLock->hEvent);
}

//
// NOTE: due to the limitation of the current
//       implementation, calling AcquireWriteLock()
//       while holding a read lock of the same
//       RW_LOCK will result in a DEADLOCK!!!
//       Be sure to release the read lock before
//       attempting to acquire the write lock.
//       This limitation can be lifted by implementing
//       lock upgrade (from read to write) which
//       requires RW_LOCK to remember ids of all
//       owning threads.
//

VOID
AcquireReadLock(
    IN PRW_LOCK pLock
    )
{
    //
    // increase the ref count, then leave
    // the critical section to allow others
    // to enter
    //
    EnterCriticalSection(&pLock->critSec);
    ++pLock->dwRefCt;
    LeaveCriticalSection(&pLock->critSec);
}

VOID
ReleaseReadLock(
    IN PRW_LOCK pLock
    )
{
    //
    // decrease the ref count, check whether
    // the new ref count is 0 (meaning no one
    // else holds any lock), if yes, signal
    // the event to allow others waiting to
    // acquire write locks to continue
    //
    EnterCriticalSection(&pLock->critSec);
    if (0 == --pLock->dwRefCt)
    {
        SetEvent(pLock->hEvent);
    }
    LeaveCriticalSection(&pLock->critSec);
}

VOID
AcquireWriteLock(
    IN PRW_LOCK pLock
    )
{
    //
    // enter critical section, check whether
    // the ref count is 0: if yes, return
    // without leaving the critical section
    // to block others from entering; if no,
    // leave the section before wait for others
    // to release locks then reenter the section
    //
try_entering_crit_sec:
    EnterCriticalSection(&pLock->critSec);
    if (pLock->dwRefCt > 0)
    {
        // make sure leaving critSec before waiting
        LeaveCriticalSection(&pLock->critSec);

        WaitForSingleObject(pLock->hEvent, INFINITE);
        goto try_entering_crit_sec;
    }
    pLock->dwRefCt = 1;
}

VOID
ReleaseWriteLock(
    IN PRW_LOCK pLock
    )
{
    //
    // reset the ref count to 0, signal
    // the event, leave the critical section
    //
    pLock->dwRefCt = 0;
    SetEvent(pLock->hEvent);
    LeaveCriticalSection(&pLock->critSec);
}

LONG
InitializeMapper(
    )
{
    DWORD dwIndex;

    TspLog(DL_TRACE, "InitializeMapper: entering...");

    // alloc and zeroinit the array
    gMapper.pArray = (PMAPPER_ENTRY)
                         MALLOC(INITIAL_MAPPER_SIZE * sizeof(MAPPER_ENTRY));
    if (NULL == gMapper.pArray)
    {
        TspLog(DL_ERROR, 
               "InitializeMapper: failed to alloc(1) mapper array");
        return LINEERR_NOMEM;
    }

    // init the global lock for the mapper
    InitializeRWLock(&gMapper.rwLock);

    gMapper.wNextID = 1;
    gMapper.wIndexFreeHead = 0;
    gMapper.dwCapacity = INITIAL_MAPPER_SIZE;
    gMapper.dwFree = INITIAL_MAPPER_SIZE;

    // init the lock for each mapper entry and link the free entry list
    for (dwIndex = 0; dwIndex < INITIAL_MAPPER_SIZE - 1; dwIndex++)
    {
        InitializeRWLock(&(gMapper.pArray[dwIndex].rwLock));
        gMapper.pArray[dwIndex].wIndexNextFree = (WORD)(dwIndex + 1);
    }
    InitializeRWLock(&(gMapper.pArray[INITIAL_MAPPER_SIZE - 1].rwLock));

    return TAPI_SUCCESS;
}

VOID
UninitializeMapper()
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < gMapper.dwCapacity; dwIndex++)
    {
        UninitializeRWLock(&(gMapper.pArray[dwIndex].rwLock));
    }

    UninitializeRWLock(&gMapper.rwLock);

    FREE(gMapper.pArray);

    TspLog(DL_TRACE, "UninitializeMapper: exited");
}

//
// NOTE: both OpenObjHandle() and CloseObjHandle() acquire write lock of
//       gMapper.rwLock at the beginning and release it at the end;
//       but that's not the case for AcquireObjReadLock(), GetObjWithReadLock(),
//       AcquireObjWriteLock() and GetObjWithWriteLock(): they acquire read
//       lock of gMapper.rwLock at the beginning and never release it before
//       exit, the lock is actually released in either ReleaseObjReadLock()
//       or ReleaseObjWriteLock(), which means the caller thread of these
//       four lock-acquiring functions actually not only holds the lock
//       it intends to acquire but also holds the read lock of gMapper.rwLock
//       as a by-product. The reason for that is preventing CloseObjHandle()
//       from getting the write lock of gMapper.rwLock while waiting for the
//       write lock for a mapper entry -- that sure will result in a DEADLOCK
//       because if another thread has the read lock for that entry, for it to
//       release the lock, it needs to acquire the read lock of gMapper.rwLock.
//       The consequence of keeping the read lock of gMapper.rwLock is that
//       the caller thread has to call ReleaseObjXXXLock() to release it
//       before calling OpenObjHandle() or CloseObjHandle() to avoid another
//       kind of DEADLOCK (see previous NOTE).
//

LONG
OpenObjHandle(
    IN PVOID pObjPtr,
    IN FREEOBJPROC pfnFreeProc,
    OUT HANDLE *phObj
    )
{
    WORD wIndex;
    PMAPPER_ENTRY pEntry;
    DWORD dwHandle;

    AcquireWriteLock(&gMapper.rwLock);

    if (0 == gMapper.dwFree)
    {
        DWORD dwIndex;
        DWORD dwOldSize = gMapper.dwCapacity;
        PMAPPER_ENTRY pOldArray = gMapper.pArray;

        if (MAXIMUM_MAPPER_SIZE == gMapper.dwCapacity)
        {
            TspLog(DL_ERROR, 
                   "OpenObjHandle: failed to grow mapper array");
            ReleaseWriteLock(&gMapper.rwLock);
            return LINEERR_OPERATIONFAILED;
        }

        // increase the capacity by a factor of two
        gMapper.dwCapacity <<= 1;
        
        // allocate a new array twice the old size, then zeroinit it
        gMapper.pArray = (PMAPPER_ENTRY)
                         MALLOC(gMapper.dwCapacity * sizeof(MAPPER_ENTRY));
        if (NULL == gMapper.pArray)
        {
            TspLog(DL_ERROR, 
                   "OpenObjHandle: failed to alloc(2) mapper array");
            ReleaseWriteLock(&gMapper.rwLock);
            return LINEERR_NOMEM;
        }
        
        TspLog(DL_INFO, "OpenObjHandle: the mapper array has grown to %d",
               gMapper.dwCapacity);

        // copy the old array over
        for (dwIndex = 0; dwIndex < dwOldSize; dwIndex++)
        {
            CopyMemory(&(gMapper.pArray[dwIndex].rwLock),
                       &(pOldArray[dwIndex].rwLock),
                       sizeof(RW_LOCK));

            //
            // Delete the lock from the old table and initialize
            // the cs in the new table. Otherwise pageheap will
            // assert when oldtable is being freed - and its not
            // a good thing anyway. Note that since the global
            // lock is held across all Acquire/Get/Release functions
            // for the lock, this is a safe operation to do here -
            // no object would be holding the lock when this is
            // being done since we are holding the write lock
            // for the gmapper.
            //
            DeleteCriticalSection(&pOldArray[dwIndex].rwLock.critSec);
            InitializeCriticalSection(&gMapper.pArray[dwIndex].rwLock.critSec);
            
            gMapper.pArray[dwIndex].pObjPtr = pOldArray[dwIndex].pObjPtr;
            gMapper.pArray[dwIndex].pfnFreeProc =
                                              pOldArray[dwIndex].pfnFreeProc;
            gMapper.pArray[dwIndex].wID =     pOldArray[dwIndex].wID;
        }

        // init locks for new entries and link them
        for (dwIndex = dwOldSize; dwIndex < gMapper.dwCapacity - 1; dwIndex++)
        {
            InitializeRWLock(&(gMapper.pArray[dwIndex].rwLock));
            gMapper.pArray[dwIndex].wIndexNextFree = (WORD)(dwIndex + 1);
        }
        InitializeRWLock(&(gMapper.pArray[gMapper.dwCapacity - 1].rwLock));

        // reset the globals
        gMapper.dwFree = dwOldSize;
        gMapper.wIndexFreeHead = (WORD)dwOldSize;

        // free the old array
        FREE(pOldArray);
    }

    ASSERT(gMapper.dwFree != 0);
    wIndex = gMapper.wIndexFreeHead;
    pEntry = gMapper.pArray + wIndex;
    gMapper.wIndexFreeHead = pEntry->wIndexNextFree;
    gMapper.dwFree--;

    pEntry->pObjPtr = pObjPtr;
    pEntry->pfnFreeProc = pfnFreeProc;
    pEntry->wID = gMapper.wNextID++;

    // make sure wNextID is within range
    if (gMapper.wNextID & 0x8000)
    {
        gMapper.wNextID = 1;
    }
    pEntry->wIndexNextFree = 0; // it's always 0 when the entry is not free

    //
    // bit 0 is always 0
    // bits 1-16 contains the index into pArray
    // bits 17-31 contains the id
    //
    // this enables us to differentiate the TSP handles 
    // created here for outgoing calls and the pseudo handles
    // created in NDPROXY for incoming calls which always 
    // has the lower bit set
    //
    dwHandle = (((pEntry->wID) << 16) | wIndex) << 1;

    // a handle is a ptr, so on 64-bit platform, dwHandle needs to be extended
    *phObj = (HANDLE)UlongToPtr(dwHandle);

    ReleaseWriteLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}

LONG
CloseObjHandle(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireWriteLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "CloseObjHandle: bad handle(%p)", hObj);

        ReleaseWriteLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "CloseObjHandle: closing handle(%p)", hObj);
#endif //DBG

    // free the obj
    (*(gMapper.pArray[wIndex].pfnFreeProc))(gMapper.pArray[wIndex].pObjPtr);

    // close obj handle
    gMapper.pArray[wIndex].pObjPtr = NULL;
    gMapper.pArray[wIndex].pfnFreeProc = NULL;
    gMapper.pArray[wIndex].wID = 0;

    // insert the entry into the free list as the head
    gMapper.pArray[wIndex].wIndexNextFree = gMapper.wIndexFreeHead;
    gMapper.wIndexFreeHead = wIndex;

    // update the free total
    gMapper.dwFree++;

    ReleaseWriteLock(&gMapper.pArray[wIndex].rwLock);
    ReleaseWriteLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}

LONG
AcquireObjReadLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "AcquireObjReadLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireReadLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "AcquireObjReadLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    return TAPI_SUCCESS;
}

LONG
GetObjWithReadLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "GetObjWithReadLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireReadLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "GetObjWithReadLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    *ppObjPtr = gMapper.pArray[wIndex].pObjPtr;
    return TAPI_SUCCESS;
}

LONG
ReleaseObjReadLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "ReleaseObjReadLock: bad handle(%p)", hObj);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseReadLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "ReleaseObjReadLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    ReleaseReadLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}

LONG
AcquireObjWriteLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "AcquireObjWriteLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "AcquireObjWriteLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    return TAPI_SUCCESS;
}

LONG
GetObjWithWriteLock(
    IN HANDLE hObj,
    OUT PVOID *ppObjPtr
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    AcquireReadLock(&gMapper.rwLock);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "GetObjWithWriteLock: bad handle(%p)", hObj);
        ReleaseReadLock(&gMapper.rwLock);
        return LINEERR_OPERATIONFAILED;
    }

    AcquireWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "GetObjWithWriteLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    *ppObjPtr = gMapper.pArray[wIndex].pObjPtr;
    return TAPI_SUCCESS;
}

LONG
ReleaseObjWriteLock(
    IN HANDLE hObj
    )
{
    DWORD dwHandle = PtrToUlong(hObj) >> 1;
    WORD wIndex = (WORD)(dwHandle & 0xFFFF);
    WORD wID = (WORD)(dwHandle >> 16);

    if ((wIndex >= gMapper.dwCapacity) ||
        (wID != gMapper.pArray[wIndex].wID) ||
        (NULL == gMapper.pArray[wIndex].pObjPtr))
    {
        TspLog(DL_WARNING, "ReleaseObjWriteLock: bad handle(%p)", hObj);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseWriteLock(&gMapper.pArray[wIndex].rwLock);

#if DBG
    TspLog(DL_TRACE, "ReleaseObjWriteLock: RefCt(%p, %d)",
           hObj, gMapper.pArray[wIndex].rwLock.dwRefCt);
#endif //DBG

    ReleaseReadLock(&gMapper.rwLock);
    return TAPI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\ndptsp\tsp\devlist.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: devlist.c
//
// History:
//      Yi Sun  July-26-2000    Created
//
// Abstract:
//      TSPI_lineGetDevCaps queries a specified line device to determine
//      its telephony capabilities. The returned cap structure doesn't change
//      with time. This allows us to be able to save that structure so that
//      we don't have to take a user/kernel transition for every GetCaps call.
//      We also save negotiated/committed TSPI version and extension version
//      so that we can verify version numbers passed in with a GetCaps call.
//      Since TSPI_lineGetNumAddressIDs is based on TSPI_lineGetDevCaps, by
//      implementing this optimization, we also save an IOCTL call for every
//      GetNumAddressIDs call.
//============================================================================

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "tapi.h"
#include "ndptsp.h"

typedef struct _LINE_DEV_NODE
{
    struct _LINE_DEV_NODE  *pNext;
    LINEDEVCAPS            *pCaps;
    DWORD                   dwDeviceID;
    DWORD                   dwNegTSPIV; // negotiated TSPI version
    DWORD                   dwComTSPIV; // committed TSPI version
    DWORD                   dwNegExtV;  // negotiated ext version
    DWORD                   dwComExtV;  // committed ext version

} LINE_DEV_NODE, *PLINE_DEV_NODE;

typedef struct _LINE_DEV_LIST
{
    CRITICAL_SECTION    critSec;
    PLINE_DEV_NODE      pHead;

} LINE_DEV_LIST, *PLINE_DEV_LIST;

static LINE_DEV_LIST gLineDevList;

//
// call InitLineDevList() in DllMain(): DLL_PROCESS_ATTACH
// to make sure that the dev list is initialized before
// TSPI version negotiation happens
//
VOID
InitLineDevList()
{
    InitializeCriticalSection(&gLineDevList.critSec);
    gLineDevList.pHead = NULL;
}

//
// call UninitLineDevList() in DllMain(): DLL_PROCESS_DETACH
//
VOID
UninitLineDevList()
{
    while (gLineDevList.pHead != NULL)
    {
        PLINE_DEV_NODE pNode = gLineDevList.pHead;
        gLineDevList.pHead = gLineDevList.pHead->pNext;

        if (pNode->pCaps != NULL)
        {
            FREE(pNode->pCaps);
        }

        FREE(pNode);
    }

    DeleteCriticalSection(&gLineDevList.critSec);
}

PLINE_DEV_NODE
GetLineDevNode(
    IN DWORD    dwDeviceID
    )
{
    PLINE_DEV_NODE pNode;
    
    EnterCriticalSection(&gLineDevList.critSec);

    pNode = gLineDevList.pHead;
    while ((pNode != NULL) && (pNode->dwDeviceID != dwDeviceID))
    {
        pNode = pNode->pNext;
    }

    if (pNode != NULL)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return pNode;
    }

    // pNode == NULL
    // so allocate and zeroinit a node
    pNode = (PLINE_DEV_NODE)MALLOC(sizeof(LINE_DEV_NODE));
    if (NULL == pNode)
    {
        TspLog(DL_ERROR, "GetLineDevNode: failed to alloc LINE_DEV_NODE");
        LeaveCriticalSection(&gLineDevList.critSec);
        return NULL;
    }

    ASSERT(pNode != NULL);
    // init pNode
    pNode->dwDeviceID = dwDeviceID;

    // insert pNode into the list
    pNode->pNext = gLineDevList.pHead;
    gLineDevList.pHead = pNode;

    LeaveCriticalSection(&gLineDevList.critSec);
    return pNode;
}

//
// TSPI_lineNegotiateTSPIVersion calls this function to pass
// the negotiated TSPI version number
//
LONG
SetNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwTSPIVersion
    )
{
    PLINE_DEV_NODE pNode;
    
    TspLog(DL_TRACE, "SetNegotiatedTSPIVersion: deviceID(%x), TSPIV(%x)",
           dwDeviceID, dwTSPIVersion);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwNegTSPIV = dwTSPIVersion;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineNegotiateExtVersion calls this function to pass
// the negotiated extension version number
//
LONG
SetNegotiatedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    PLINE_DEV_NODE pNode;
    
    TspLog(DL_TRACE, "SetNegotiatedExtVersion: deviceID(%x), ExtV(%x)",
           dwDeviceID, dwExtVersion);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwNegExtV = dwExtVersion;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineSelectExtVersion calls this function to commit/decommit
// extension version. The ext version is decommitted by selecting ext
// version 0
//
LONG
SetSelectedExtVersion(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    PLINE_DEV_NODE pNode;

    TspLog(DL_TRACE, "SetSelectedExtVersion: deviceID(%x), ExtV(%x)",
           dwDeviceID, dwExtVersion);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    if ((dwExtVersion != 0) && (dwExtVersion != pNode->dwNegExtV))
    {
        TspLog(DL_ERROR,
               "SetSelectedExtVersion: ext version(%x) not match "\
               "the negotiated one(%x)",
               dwExtVersion, pNode->dwNegExtV);

        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_INCOMPATIBLEEXTVERSION;
    }

    pNode->dwComExtV = dwExtVersion;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineOpen calls this function to commit TSPI version
//
LONG
CommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    )
{
    PLINE_DEV_NODE pNode;

    TspLog(DL_TRACE, "CommitNegotiatedTSPIVersion: deviceID(%x)", dwDeviceID);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwComTSPIV = pNode->dwNegTSPIV;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// TSPI_lineClose calls this function to decommit TSPI version
//
LONG
DecommitNegotiatedTSPIVersion(
    IN DWORD    dwDeviceID
    )
{
    PLINE_DEV_NODE pNode;

    TspLog(DL_TRACE, "DecommitNegotiatedTSPIVersion: deviceID(%x)", dwDeviceID);

    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    pNode->dwComTSPIV = 0;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// actual implementation of TSPI_lineGetNumAddressIDs
//
LONG
GetNumAddressIDs(
    IN DWORD    dwDeviceID,
    OUT DWORD  *pdwNumAddressIDs
    )
{
    PLINE_DEV_NODE pNode;
    
    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    ASSERT(pNode != NULL);
    if (NULL == pNode->pCaps)
    {
        pNode->pCaps = GetLineDevCaps(dwDeviceID, pNode->dwComExtV);
        if (NULL == pNode->pCaps)
        {
            LeaveCriticalSection(&gLineDevList.critSec);
            return LINEERR_NOMEM;
        }
    }

    ASSERT(pNode->pCaps != NULL);
    *pdwNumAddressIDs = pNode->pCaps->dwNumAddresses;

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}

//
// actual implementation of TSPI_lineGetDevCaps
//
LONG
GetDevCaps(
    IN DWORD            dwDeviceID,
    IN DWORD            dwTSPIVersion,
    IN DWORD            dwExtVersion,
    OUT LINEDEVCAPS    *pLineDevCaps
    )
{
    PLINE_DEV_NODE pNode;
    
    EnterCriticalSection(&gLineDevList.critSec);

    pNode = GetLineDevNode(dwDeviceID);
    if (NULL == pNode)
    {
        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_NOMEM;
    }

    ASSERT(pNode != NULL);
    //
    // check the version numbers
    //
    if ((pNode->dwComTSPIV != 0) && (dwTSPIVersion != pNode->dwComTSPIV))
    {
        TspLog(DL_ERROR, 
               "GetDevCaps: tspi version(%x) not match"\
               "the committed one(%x)",
               dwTSPIVersion, pNode->dwComTSPIV);

        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }
    if ((pNode->dwComExtV != 0) && (dwExtVersion != pNode->dwComExtV))
    {
        TspLog(DL_ERROR, 
               "GetDevCaps: ext version(%x) not match "\
               "the committed one(%x)",
               dwExtVersion, pNode->dwComExtV);

        LeaveCriticalSection(&gLineDevList.critSec);
        return LINEERR_INCOMPATIBLEEXTVERSION;
    }

    if (NULL == pNode->pCaps)
    {
        pNode->pCaps = GetLineDevCaps(dwDeviceID, dwExtVersion);
        if (NULL == pNode->pCaps)
        {
            LeaveCriticalSection(&gLineDevList.critSec);
            return LINEERR_NOMEM;
        }
    }

    ASSERT(pNode->pCaps != NULL);
    
    //
    // copy caps over
    //
    if (pNode->pCaps->dwNeededSize > pLineDevCaps->dwTotalSize)
    {
        pLineDevCaps->dwNeededSize = pNode->pCaps->dwNeededSize;
        pLineDevCaps->dwUsedSize = 
            (pLineDevCaps->dwTotalSize < sizeof(LINEDEVCAPS) ?
             pLineDevCaps->dwTotalSize : sizeof(LINEDEVCAPS));

        ASSERT(pLineDevCaps->dwUsedSize >= 10);
        // reset dwProviderInfoSize to dwLineNameOffset to 0
        ZeroMemory(&pLineDevCaps->dwProviderInfoSize, 7 * sizeof(DWORD));
        // copy over dwPermanentLineID
        pLineDevCaps->dwPermanentLineID = pNode->pCaps->dwPermanentLineID;
        // copy everything from dwStringFormat
        CopyMemory(&pLineDevCaps->dwStringFormat, 
                   &pNode->pCaps->dwStringFormat, 
                   pLineDevCaps->dwUsedSize - 10 * sizeof(DWORD));

        // we don't need to set dwTerminalCaps(Size, Offset),
        // dwTerminalText(Size, Offset), etc. to 0
        // because these fields have been preset with 0
        // before the service provider was called
    }
    else
    {
        // copy over all fields except dwTotalSize
        CopyMemory(&pLineDevCaps->dwNeededSize,
                   &pNode->pCaps->dwNeededSize,
                   pNode->pCaps->dwNeededSize - sizeof(DWORD));
        
    }

    LeaveCriticalSection(&gLineDevList.critSec);
    return TAPI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\ndptsp\tsp\ndptsp.c ===
//============================================================================
// Copyright (c) 2000, Microsoft Corporation
//
// File: ndptsp.c
//
// History:
//      Dan Knudson (DanKn)         11-Apr-1995     Created
//      Richard Machin (RMachin)    05-05-97        NDIS 5.0 changes
//      Radu Simionescu (RaduS)     10-Feb-1999     UI config
//      Yi Sun (YiSun)              June-29-2000    Rewriten
//
// Abstract:
//============================================================================

#define NDIS_TAPI_CURRENT_VERSION 0x00030000
#define TAPI_CURRENT_VERSION    NDIS_TAPI_CURRENT_VERSION

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "rtutils.h"
#include "winioctl.h"
#include "ntddndis.h"
#include "ndistapi.h"
#include "ndpif.h"

//
// NOTE: the following are defined in both ndistapi.h & tapi.h (or tspi.h)
//       and cause (more or less non-interesting) build warnings, so we
//       undefine them after the first #include to do away with this
//

#undef LAST_LINEMEDIAMODE
#undef TSPI_MESSAGE_BASE
#undef LINE_NEWCALL
#undef LINE_CALLDEVSPECIFIC
#undef LINE_CREATE

#include "tapi.h"
#include "tspi.h"
#include "ndptsp.h"
#include "resource.h"

#define OUTBOUND_CALL_KEY       ((DWORD) 'OCAL')
#define INBOUND_CALL_KEY        ((DWORD) 'ICAL')
#define LINE_KEY                ((DWORD) 'KLIN')
#define ASYNCREQWRAPPER_KEY     ((DWORD) 'ARWK')
#define MSP_KEY                 ((DWORD) 'MSPK')
#define INVALID_KEY             ((DWORD) 'XXXX')

#define EVENT_BUFFER_SIZE       1024

#define RCA_SAP_STRING          L"WAN/RCA"
#define NDPTSP_UIDLL            L"NDPTSP.TSP"

#define WINDOWS_REGKEY_ROOT L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
#define NDPTSP_SUBKEY   L"NdpTsp"
#define NDPTSP_NOTIFY_SUBKEY    L"ForceRefresh"

#define NDPTSP_REGKEY_ROOT \
    WINDOWS_REGKEY_ROOT L"\\" NDPTSP_SUBKEY

#define NDPTSP_NOTIFY_REGKEY_ROOT \
    NDPTSP_REGKEY_ROOT L"\\" NDPTSP_NOTIFY_SUBKEY

typedef struct _NDP_MEDIA_TYPE
{
    DWORD   dwResourceID;   // Resource ID for the localized string
    PWSTR   pwszString;
    DWORD   dwMediaMode;
    PWSTR   pwszRegString;   // Name of the registry value
} NDP_MEDIA_TYPE;


NDP_MEDIA_TYPE  NdpModeArray[] = {
    IDS_TYPE_DIGITALDATA,       NULL,   
    LINEMEDIAMODE_DIGITALDATA,      L"Digita lData",

    IDS_TYPE_INTERACTIVEVOICE,  NULL,   
    LINEMEDIAMODE_INTERACTIVEVOICE, L"Intera ctiveVoice",

    IDS_TYPE_G3FAX,             NULL,   
    LINEMEDIAMODE_G3FAX,            L"G3Fax" ,

    IDS_TYPE_G4FAX,             NULL,   
    LINEMEDIAMODE_G4FAX,            L"G4Fax"
};

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define NUM_NDP_MODES   ARRAYSIZE(NdpModeArray)

typedef struct _ADDRESS_MAP
{
    PWSTR               pwszAddress;
    DWORD               dwAddressLength;
    struct _ADDRESS_MAP *pNext;
    struct _ADDRESS_MAP *pPrev;
} ADDRESS_MAP, *PADDRESS_MAP;

typedef struct _CONFIG_UI_CTX
{
    PADDRESS_MAP        pAddressMapListArray[NUM_NDP_MODES];
    HWND                hwndListBox;
    DWORD               dwCrtTypeIndex;
} CONFIG_UI_CTX;

//
// help support
//
#define NDPTSP_HELP_FILE                    L"tapi.hlp"

#ifndef IDH_DISABLEHELP
#define IDH_DISABLEHELP                     ((DWORD)-1)
#endif

#define IDH_MEDIA_MAP_MEDIA_TYPE            10011
#define IDH_MEDIA_MAP_ADDRESS_GROUP         10012
#define IDH_MEDIA_MAP_ADDRESS_LIST          10013
#define IDH_MEDIA_MAP_ADD_ADDRESS           10014
#define IDH_MEDIA_MAP_DELETE_ADDRESS        10015
#define IDH_MEDIA_ADD_ADD_ADDRESS           10016

static const DWORD g_aHelpIDs_IDD_MEDIA_MAP[]=
{
    IDC_MEDIA_TYPE,     IDH_MEDIA_MAP_MEDIA_TYPE,   // Drop-down list
    IDC_ADDRESS_GROUP,  IDH_MEDIA_MAP_ADDRESS_GROUP,    // Group box
    IDC_ADDRESS_LIST,   IDH_MEDIA_MAP_ADDRESS_LIST, // List box
    IDC_ADD_ADDRESS,    IDH_MEDIA_MAP_ADD_ADDRESS,  // Add button
    IDC_DELETE_ADDRESS, IDH_MEDIA_MAP_DELETE_ADDRESS,   // Delete button
    0,                  0
};

const DWORD g_aHelpIDs_IDD_MEDIA_ADD[]=
{
    IDC_ADD_ADDRESS,    IDH_MEDIA_ADD_ADD_ADDRESS,  // edit box
    0,                  0
};

typedef LONG (*POSTPROCESSPROC)(PASYNC_REQUEST_WRAPPER, LONG, PDWORD_PTR);

typedef struct _ASYNC_REQUEST_WRAPPER
{
    // NOTE: overlapped must remain 1st field in this struct
    OVERLAPPED          Overlapped;
    DWORD               dwKey;
    DWORD               dwRequestID;
    POSTPROCESSPROC     pfnPostProcess;
    CRITICAL_SECTION    CritSec;
    ULONG               RefCount;
    DWORD_PTR           dwRequestSpecific;
    // NOTE: NdisTapiRequest must follow a ptr to avoid alignment problem
    NDISTAPI_REQUEST    NdisTapiRequest;

} ASYNC_REQUEST_WRAPPER, *PASYNC_REQUEST_WRAPPER;

#define REF_ASYNC_REQUEST_WRAPPER(_pAsyncReqWrapper)    \
{                                                       \
    EnterCriticalSection(&_pAsyncReqWrapper->CritSec);  \
    _pAsyncReqWrapper->RefCount++;                      \
    LeaveCriticalSection(&_pAsyncReqWrapper->CritSec);  \
}

#define DEREF_ASYNC_REQUEST_WRAPPER(_pAsyncReqWrapper)      \
{                                                           \
    EnterCriticalSection(&_pAsyncReqWrapper->CritSec);      \
    if (--(_pAsyncReqWrapper->RefCount) == 0) {             \
        LeaveCriticalSection(&_pAsyncReqWrapper->CritSec);  \
        DeleteCriticalSection(&_pAsyncReqWrapper->CritSec); \
        FreeRequest(_pAsyncReqWrapper);                     \
        _pAsyncReqWrapper = NULL;                           \
    } else {                                                \
        LeaveCriticalSection(&_pAsyncReqWrapper->CritSec);  \
    }                                                       \
}

typedef struct _ASYNC_EVENTS_THREAD_INFO
{
    HANDLE                  hThread;    // thread handle
    PNDISTAPI_EVENT_DATA    pBuf;       // ptr to a buf for async events
    DWORD                   dwBufSize;  // size of the previous buffer

} ASYNC_EVENTS_THREAD_INFO, *PASYNC_EVENTS_THREAD_INFO;


typedef struct _DRVCALL
{
    DWORD                   dwKey;
    DWORD                   dwDeviceID;
    HTAPICALL               htCall;                 // TAPI's handle to the call
    HDRVCALL                hdCall;                 // TSP's handle to the call
    HDRV_CALL               hd_Call;                // NDPROXY's call handle
    HDRVLINE                hdLine;                 // TSP's handle to the line
    union
    {
        struct _DRVCALL    *pPrev;                  // for inbound calls only
        DWORD               dwPendingCallState;     // for outbound calls only
    };
    union
    {
        struct _DRVCALL    *pNext;                  // for inbound calls only
        DWORD               dwPendingCallStateMode; // for outbound calls only
    };
    union
    {
        HTAPI_CALL          ht_Call;                // for inbound calls only
        DWORD               dwPendingMediaMode;     // for outbound calls only
    };
    BOOL                    bIncomplete;
    BOOL                    bDropped;

} DRVCALL, *PDRVCALL;

typedef struct _DRVMSPLINE
{
    DWORD                   dwKey;
    DWORD                   dwAddressID;
    HDRVLINE                hdLine;
    HTAPIMSPLINE            htMSPLine;
    BOOL                    bStreamingStarted;

} DRVMSPLINE, *PDRVMSPLINE;

typedef struct _DRVLINE
{
    DWORD                   dwKey;
    DWORD                   dwDeviceID;
    HTAPILINE               htLine;                 // TAPI's line handle
    HDRV_LINE               hd_Line;                // NDPROXY's line handle
    PDRVCALL                pInboundCalls;          // inbound call list

    HANDLE                  hMSPMutex;
    PDRVMSPLINE             pMSPLine;

    // the following two related to PNP/POWER
    GUID                    Guid;
    NDIS_WAN_MEDIUM_SUBTYPE MediaType;

} DRVLINE, *PDRVLINE;

// globals
HANDLE                      ghDriverSync, ghDriverAsync, ghCompletionPort;
PASYNC_EVENTS_THREAD_INFO   gpAsyncEventsThreadInfo;
PADDRESS_MAP                gpAddressMapListArray[NUM_NDP_MODES];
BOOL                        gbAddressMapListLoaded;
CRITICAL_SECTION            gAddressMapCritSec;
DWORD                       gdwRequestID;
ASYNC_COMPLETION            gpfnCompletionProc;
CRITICAL_SECTION            gRequestIDCritSec;
DWORD                       gInitResult;
LINEEVENT                   gpfnLineEvent;
HPROVIDER                   ghProvider;
HINSTANCE                   ghInstance;
OVERLAPPED 	gOverlappedTerminate;
//Dummy overlapped structure used 
// by provider shutdown to inform 
// AsyncEventsThread before it closes 
// the handle to the completion port.



//
// CLSID for the RCA MSP.
// @@@ we should grab this from an include directory in the MSP
//     sources, but that can only be done when the MSP/TSP source is
//     moved to the right place.
//
const CLSID CLSID_RCAMSP = {
    0x11D59011, 0xCF23, 0x11d1, 
    {0xA0, 0x2D, 0x00, 0xC0, 0x4F, 0xB6, 0x80, 0x9F}
};

//
// debug globals
//
#if DBG
DWORD                       gdwDebugLevel;
#endif // DBG

DWORD                       gdwTraceID = INVALID_TRACEID;

//
// creates a log using the RAS tracing utility
// also prints it onto the attached debugger 
// if a debug build is running
//
VOID
TspLog(
    IN DWORD    dwDebugLevel,
    IN PCHAR    pchFormat,
    ...
    )
{
    va_list arglist;
    CHAR    chNewFmt[256];

    va_start(arglist, pchFormat);

    switch (dwDebugLevel)
    {
        case DL_ERROR:
            strcpy(chNewFmt, "!!! ");
            break;

        case DL_WARNING:
            strcpy(chNewFmt, "!!  ");
            break;

        case DL_INFO:
            strcpy(chNewFmt, "!   ");
            break;

        case DL_TRACE:
            strcpy(chNewFmt, "    ");
            break;
    }
    strcat(chNewFmt, pchFormat);

#if DBG
    if (dwDebugLevel <= gdwDebugLevel)
    {
#if 0
        DbgPrint("++NDPTSP++ ");
        DbgPrint(chNewFmt, arglist);
        DbgPrint("\n");
#else
        char szBuffer[256];
        OutputDebugString("++NDPTSP++ ");
        wvsprintf(szBuffer, chNewFmt, arglist);
        OutputDebugString(szBuffer);
        OutputDebugString("\n");
#endif
    }
#endif // DBG

    if (gdwTraceID != INVALID_TRACEID)
    {
        TraceVprintfEx(gdwTraceID,
                       (dwDebugLevel << 16) | TRACE_USE_MASK | TRACE_USE_MSEC,
                       chNewFmt,
                       arglist);
    }

    va_end(arglist);

#if DBG
    if (DL_ERROR == dwDebugLevel)
    {
        //DebugBreak();
    }
#endif // DBG
}

#if DBG

#define INSERTVARDATASTRING(a,b,c,d,e,f) InsertVarDataString(a,b,c,d,e,f)

void
PASCAL
InsertVarDataString(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize,
    char   *pszFieldName
    )

#else

#define INSERTVARDATASTRING(a,b,c,d,e,f) InsertVarDataString(a,b,c,d,e)

void
PASCAL
InsertVarDataString(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize
    )

#endif
{
    DWORD   dwXxxSize, dwTotalSize, dwXxxOffset;


    //
    // If the dwXxxSize field of the old struct is non-zero, then
    // we need to do a ascii->unicode conversion on it.  Check to
    // make sure that the size/offset are valid (if not set the
    // data size/offset in the new struct to 0) and then convert.
    //

    if ((dwXxxSize = *pdwXxxSize))
    {
        dwXxxOffset = *(pdwXxxSize + 1);

#if DBG
        dwTotalSize = ((LPVARSTRING) pStruct)->dwTotalSize;

        if (dwXxxSize > (dwTotalSize - dwFixedStructSize) ||
            dwXxxOffset < dwFixedStructSize ||
            dwXxxOffset >= dwTotalSize ||
            (dwXxxSize + dwXxxOffset) > dwTotalSize)
        {
            TspLog(DL_ERROR, 
                  "INSERTVARDATASTRING: bad %s values - size(x%x), "\
                  "offset(x%x)",
                   pszFieldName, dwXxxSize, dwXxxOffset);

            *pdwNewXxxSize = *(pdwNewXxxSize + 1) = 0;
            return;
        }
#endif

        // make sure the string is NULL terminated
        *(((LPBYTE)pStruct) + (dwXxxOffset + dwXxxSize - 1)) = '\0';

        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            ((LPBYTE) pStruct) + dwXxxOffset,
            dwXxxSize,
            (LPWSTR) (((LPBYTE) pNewStruct) +
                ((LPVARSTRING) pNewStruct)->dwUsedSize),
            dwXxxSize
            );

        *pdwNewXxxSize = dwXxxSize * sizeof(WCHAR);
        *(pdwNewXxxSize + 1) = ((LPVARSTRING) pNewStruct)->dwUsedSize; // offset
        ((LPVARSTRING) pNewStruct)->dwUsedSize += (dwXxxSize * sizeof(WCHAR));
    }
}


#if DBG

#define INSERTVARDATA(a,b,c,d,e,f) InsertVarData(a,b,c,d,e,f)

void
PASCAL
InsertVarData(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize,
    char   *pszFieldName
    )

#else

#define INSERTVARDATA(a,b,c,d,e,f) InsertVarData(a,b,c,d,e)

void
PASCAL
InsertVarData(
    LPVOID  pStruct,
    LPDWORD pdwXxxSize,
    LPVOID  pNewStruct,
    LPDWORD pdwNewXxxSize,
    DWORD   dwFixedStructSize
    )

#endif
{
    DWORD   dwTotalSize, dwXxxSize, dwXxxOffset;


    if ((dwXxxSize = *pdwXxxSize))
    {
        dwXxxOffset = *(pdwXxxSize + 1);

#if DBG
        dwTotalSize = ((LPVARSTRING) pStruct)->dwTotalSize;

        if (dwXxxSize > (dwTotalSize - dwFixedStructSize) ||
            dwXxxOffset < dwFixedStructSize ||
            dwXxxOffset >= dwTotalSize ||
            (dwXxxSize + dwXxxOffset) > dwTotalSize)
        {
            TspLog(DL_ERROR,
                   "INSERTVARDATA: bad %s values - size(x%x), offset(x%x)",
                   pszFieldName, dwXxxSize, dwXxxOffset);

            *pdwNewXxxSize = *(pdwNewXxxSize + 1) = 0;
            return;
        }
#endif
        CopyMemory(
            ((LPBYTE) pNewStruct) + ((LPVARSTRING) pNewStruct)->dwUsedSize,
            ((LPBYTE) pStruct) + dwXxxOffset,
            dwXxxSize
            );

        *pdwNewXxxSize = dwXxxSize;
        *(pdwNewXxxSize + 1) = ((LPVARSTRING) pNewStruct)->dwUsedSize; // offset
        ((LPVARSTRING) pNewStruct)->dwUsedSize += dwXxxSize;
    }
}

BOOL 
IsValidAddressChar(
    WCHAR wch
    )
{
    // 0..9, A..F, * # .
    if (iswdigit(wch) || (wch >= L'A' && wch <= L'F') || 
        (wch >= L'a' && wch <= L'f') || wch == L'*' || 
        wch == L'#' || wch == L'.')
    {
        return TRUE;
    }

    return FALSE;
}

int 
CompareAddressChars(
    WCHAR wch1, 
    WCHAR wch2
    )
{
    // convert lowercase to uppercase
    wch1 = (WCHAR)towupper(wch1);
    wch2 = (WCHAR)towupper(wch2);

    return (int)(wch1-wch2);
}

int 
CompareAddresses(
    PCWSTR pwszAddress1, 
    PCWSTR pwszAddress2
    )
{
    WCHAR const * pCrt1,* pCrt2;
    int     iResult;

    pCrt1 = pwszAddress1;
    pCrt2 = pwszAddress2;
    while (1)
    {
        // skip invalid chars from the first string
        while (*pCrt1 && !IsValidAddressChar(*pCrt1))
        {
            pCrt1++;
        }

        // skip invalid chars from the second string
        while (*pCrt2 && !IsValidAddressChar(*pCrt2))
        {
            pCrt2++;
        }

        if (!*pCrt1 && !*pCrt2)
        {
            return 0;
        }

        if (!*pCrt1)
        {
            return 1;
        }

        if (!*pCrt2)
        {
            return -1;
        }

        iResult = CompareAddressChars(*pCrt1, *pCrt2);
        if (iResult!=0)
        {
            return iResult;
        }

        pCrt1++;
        pCrt2++;
    }
}

BOOL
FindAddressInOneList(
    PADDRESS_MAP pAddress,
    PCWSTR pwszAddress,
    PADDRESS_MAP *pAddressEntry
    )
{
    while (pAddress!=NULL)
    {
        if (0 == CompareAddresses(pAddress->pwszAddress, pwszAddress))
        {
            // found !
            *pAddressEntry = pAddress;
            return TRUE;
        }
        pAddress = pAddress->pNext;
    }

    // not found
    return FALSE;
}

BOOL
FindAddressInLists(
    PADDRESS_MAP *pAddressListArray,
    PCWSTR    pwszAddress,
    DWORD *pdwModeIndex,
    PADDRESS_MAP *pAddressEntry
    )
{
    DWORD           dwModeCnt;

    for (dwModeCnt=0; dwModeCnt<NUM_NDP_MODES; dwModeCnt++)
    {
        if (FindAddressInOneList(pAddressListArray[dwModeCnt],
                                 pwszAddress,
                                 pAddressEntry))
        {
            *pdwModeIndex = dwModeCnt;
            return TRUE;
        }
    }

    // not found
    return FALSE;
}

void
FreeAddressList(
    PADDRESS_MAP pAddressList
    )
{
    PADDRESS_MAP    pCrtCell;
    PADDRESS_MAP    pPrevCell;

    pCrtCell = pAddressList;

    while (pCrtCell!=NULL)
    {
        if (pCrtCell->pwszAddress)
        {
            FREE(pCrtCell->pwszAddress);
        }
        pPrevCell = pCrtCell;
        pCrtCell = pCrtCell->pNext;
        FREE(pPrevCell);
    }
}

void
FreeAllAddressLists(
    PADDRESS_MAP *pAddressListArray
    )
{
    DWORD           dwModeCnt;

    for (dwModeCnt=0; dwModeCnt<NUM_NDP_MODES; dwModeCnt++)
    {
        FreeAddressList(pAddressListArray[dwModeCnt]);
    }
}

INT_PTR
CALLBACK
ProviderConfigDetailDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LONG lStatus;
    CONFIG_UI_CTX   *UIContext;

    PADDRESS_MAP    pAddressList;
    PADDRESS_MAP    pAddress;
    PADDRESS_MAP    pLastCell;
    DWORD           dwStart;
    DWORD           dwEnd;
    DWORD           dwStrLength;
    DWORD           dwTmp;
    PADDRESS_MAP    pAddressEntry;
    PWSTR           pwszAddress = NULL;
    PWSTR           pwszCrt;
    WCHAR           wszTmp[0x40];
    DWORD           dwLengthW;
    DWORD           dwErrorID;

    // decode
    switch (uMsg) {
    
    case WM_HELP:

        // F1 key or the "?" button is pressed
        (void) WinHelpW(((LPHELPINFO) lParam)->hItemHandle,
                        NDPTSP_HELP_FILE,
                        HELP_WM_HELP,
                        (DWORD_PTR) (LPVOID) g_aHelpIDs_IDD_MEDIA_ADD);
        break;

    case WM_CONTEXTMENU:

        // Right-mouse click on a dialog control
        (void) WinHelpW((HWND) wParam,
                        NDPTSP_HELP_FILE,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR) (LPVOID) g_aHelpIDs_IDD_MEDIA_ADD);
        break;

    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg,
                         DWLP_USER,
                         lParam);
                            
        SetFocus(GetDlgItem(hDlg, IDC_ADD_ADDRESS));
        
        break;

    case WM_COMMAND:

        UIContext = (CONFIG_UI_CTX *)GetWindowLongPtr(hDlg, DWLP_USER);

        // decode command
        switch (LOWORD(wParam)) {

        case IDOK:

            pAddressList = NULL;
            pLastCell = NULL;
            dwErrorID = 0;

            // Get the text
            SendDlgItemMessageW(hDlg, IDC_ADD_ADDRESS, EM_SETSEL, 0, -1);
            SendDlgItemMessageW(hDlg, IDC_ADD_ADDRESS,
                                EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);

            dwEnd++;                // add room for a NULL terminator
            dwStrLength = dwEnd*sizeof(WCHAR); // We have unicode chars
            pwszAddress = (dwEnd <= ARRAYSIZE(wszTmp)) ? wszTmp : 
                                                         MALLOC(dwStrLength);
            if (pwszAddress==NULL)
            {
                TspLog(DL_ERROR, "ProviderConfigDetailDlgProc: out of mem");
                break;
            }

            GetWindowTextW(GetDlgItem(hDlg, IDC_ADD_ADDRESS),
                           pwszAddress, dwEnd);

            // Parse the string and create a local list
            pwszCrt = pwszAddress;
            while (*pwszCrt)
            {
                PWSTR pwszNext;
                WCHAR wch;
  
                // trim leading spaces
                while ((*pwszCrt == L' ') || (*pwszCrt == L','))
                {
                    pwszCrt++;
                }

                // check if trimming the spaces toke us to the end of the string
                if (*pwszCrt)
                {
                    // find next space and make it a temporary null
                    // in the same time verify the address chars
                    pwszNext = pwszCrt;
                    while (*pwszNext && 
                           (*pwszNext != L' ') && 
                           (*pwszNext != L',') )
                    {
                        // All characters allowed
                        
                        //if (*pszNext>='0' && *pszNext<='9')
                            pwszNext++;
                        //else
                        //{
                        //  dwErrorID = IDS_ERR_BAD_ADDRESS;
                        //  break;
                        //}
                    }
                    if (dwErrorID)
                    {
                        break;
                    }

                    // save the char and replace with a temporary NULL
                    wch = *pwszNext;
                    *pwszNext = L'\0';

                    // Test 1 - the address must not be already assigned
                    if (FindAddressInLists(UIContext->pAddressMapListArray,
                                          pwszCrt,
                                          &dwTmp,
                                          &pAddressEntry))
                    {
                        dwErrorID = IDS_ERR_ALREADY_ASSIGNED;
                        break;
                    }

                    // Test 2 - the address must be unique in the edit field
                    if (FindAddressInOneList(pAddressList,
                                            pwszCrt,
                                            &pAddressEntry))
                    {
                        dwErrorID = IDS_ERR_DUPLICATE_ADDRESS;
                        break;
                    }

                    // Create cell
                    pAddress = (PADDRESS_MAP)MALLOC(sizeof(ADDRESS_MAP));
                    if (pAddress == NULL)
                    {
                        dwErrorID = IDS_ERR_OOM;
                        break;
                    }

                    dwLengthW = lstrlenW(pwszCrt);
                    pAddress -> pwszAddress = MALLOC((dwLengthW + 1)*sizeof(WCHAR)); 
                    if (pAddress->pwszAddress == NULL)
                    {
                        dwErrorID = IDS_ERR_OOM;
                        FREE(pAddress);
                        break;
                    }

                    lstrcpynW(pAddress->pwszAddress, pwszCrt, dwLengthW+1);
                    pAddress->dwAddressLength = dwLengthW;

                    // insert the entry in the local list
                    pAddress->pNext = NULL;
                    pAddress->pPrev = pLastCell;
                    if (pLastCell)
                    {
                        pLastCell->pNext = pAddress;
                    }
                    else    
                    {
                        pAddressList = pAddress;
                    }
                    pLastCell = pAddress;
                    
                    // replace our temporary null with it's previous value
                    *pwszNext = wch;

                    // advance the pszCrt point
                    pwszCrt = pwszNext;               
                }
            }
            
            if (pwszAddress!=wszTmp)
            {
                FREE(pwszAddress);
            }

            if (dwErrorID == 0)
            {
                // no error
                PADDRESS_MAP    *ppInsertPoint;

                if (pAddressList)
                {
                    // add the addresses to the list box
                    for (pAddress=pAddressList; 
                        pAddress!=NULL; 
                        pAddress = pAddress->pNext)
                    {
                        SendMessageW(UIContext->hwndListBox, 
                                     LB_ADDSTRING, 
                                     0, 
                                     (LPARAM)pAddress->pwszAddress);
                    }

                    // glue the local list to the global one
                    ppInsertPoint = &UIContext->pAddressMapListArray[
                                                UIContext->dwCrtTypeIndex];
                    pLastCell->pNext = *ppInsertPoint;
                    if (pLastCell->pNext)
                    {
                        pLastCell->pNext->pPrev = pLastCell;
                    }
                    *ppInsertPoint = pAddressList;
                }
            }
            else
            {
                WCHAR wszErrorMsg[0x100];
        
                // load error string
                LoadStringW(ghInstance,
                            dwErrorID,
                            wszErrorMsg,
                            ARRAYSIZE(wszErrorMsg));

                // pop up error dialog
                MessageBoxW(hDlg,wszErrorMsg,NULL,MB_OK | MB_ICONEXCLAMATION);

                break;
            }

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDCANCEL:

            // close dialog
            EndDialog(hDlg, 0);
            break;

        }

        break;
    }

    // success
    return FALSE;
}

LONG
RegistrySaveConfig(
    PADDRESS_MAP *pAddressListArray
    )
{
    HKEY            hKey;
    HKEY            hNotifyKey;
    LONG            lRes;
    DWORD           dwDisp;
    DWORD           dwModeCnt;
    PADDRESS_MAP    pAddress;
    DWORD           dwLengthW;
    DWORD           dwTotalLengthW;
    DWORD           dwBufferLengthW;
    WCHAR           wszBuffer[0x100];
    PWSTR           pwszBuffer;
    PWSTR           pwszCrt;
    
    // Open/create the key
    lRes = RegCreateKeyExW (HKEY_LOCAL_MACHINE,
                               NDPTSP_REGKEY_ROOT,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &hKey,
                               &dwDisp
                               );

    if (lRes != ERROR_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "RegistrySaveConfig: open/create config key failed(%ld)", 
               lRes);

        return lRes;
    }

    // for speed we use a local buffer. If it is too small, alloc one
    pwszBuffer = wszBuffer;
    dwBufferLengthW = ARRAYSIZE(wszBuffer);

    // for each type
    for (dwModeCnt=0; dwModeCnt<NUM_NDP_MODES; dwModeCnt++)
    {   
        pAddress = pAddressListArray[dwModeCnt];

        // calculate the length needed for multistring
        dwTotalLengthW = 1;
        while (pAddress!=NULL)
        {
            dwTotalLengthW += pAddress->dwAddressLength + 1;
            pAddress = pAddress->pNext;
        }

        if (dwTotalLengthW > dwBufferLengthW)
        {
            // need a bigger buffer..
            if (pwszBuffer!=wszBuffer)
            {
                FREE(pwszBuffer);
            }

            pwszBuffer = MALLOC(dwTotalLengthW*sizeof(WCHAR));
            if (pwszBuffer == NULL)
            {
                TspLog(DL_ERROR, "RegistrySaveConfig: out of mem");
                RegCloseKey(hKey);
                return ERROR_OUTOFMEMORY;
            }
            dwBufferLengthW = dwTotalLengthW;
        }

        pAddress = pAddressListArray[dwModeCnt];
        pwszCrt = pwszBuffer;
        
        // linear search, hope not too many values...
        while (pAddress != NULL)
        {
            // Add the value to the multi string
            lstrcpyW(pwszCrt, pAddress->pwszAddress);
            // prepare for next string
            pwszCrt += pAddress->dwAddressLength + 1 ;
        
            pAddress = pAddress->pNext;
        }
        // final NULL
        *pwszCrt++ = L'\0';

        dwLengthW = (DWORD)(pwszCrt - pwszBuffer);
        lRes = RegSetValueExW(hKey,
                                 NdpModeArray[dwModeCnt].pwszRegString,
                                 0,
                                 REG_MULTI_SZ,
                                 (PVOID)pwszBuffer,
                                 dwLengthW*sizeof(WCHAR));
        if (lRes != ERROR_SUCCESS)
        {
            TspLog(DL_ERROR, "RegistrySaveConfig: failed(%ld) to save value",
                   lRes);
            break;
        }
    }

    // notify the server with a volatile key
    if (lRes==ERROR_SUCCESS)
    {
        lRes = RegCreateKeyExW(hKey,
                                  NDPTSP_NOTIFY_SUBKEY,
                                  0,
                                  NULL,
                                  REG_OPTION_VOLATILE,
                                  KEY_READ,
                                  NULL,
                                  &hNotifyKey,
                                  &dwDisp);

        if (lRes == ERROR_SUCCESS)
        {
            RegCloseKey(hNotifyKey);
        }
        else
        {
            TspLog(DL_ERROR, 
                   "RegistrySaveConfig: failed(%ld) to create notify key",
                   lRes);
        }
    }

    RegCloseKey(hKey);
    if (pwszBuffer != wszBuffer)
    {
        FREE(pwszBuffer);
    }

    return lRes;
}

LONG
RegistryLoadConfig(
    PADDRESS_MAP *pAddressListArray
    )
{
    HKEY            hKey;
    LONG            lRes;
    DWORD           dwDisp;
    DWORD           dwModeCnt;
    PADDRESS_MAP    pAddress;
    PADDRESS_MAP    pPrevCell;
    DWORD           dwLength;
    DWORD           dwLengthW;
    DWORD           dwBufferLength;
    DWORD           dwType;
    WCHAR           wszBuffer[0x100];
    PWSTR           pwszBuffer;
    PWSTR           pwszCrt;

    FreeAllAddressLists(pAddressListArray);
    
    // Open/create the key
    lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                              NDPTSP_REGKEY_ROOT,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ ,
                              NULL,
                              &hKey,
                              &dwDisp);

    if (lRes != ERROR_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "RegistryLoadConfig: open/create config key failed(%ld)",
               lRes);

        return lRes;
    }

    // for speed we use a local buffer. If it is too small, alloc one
    pwszBuffer = wszBuffer;
    dwBufferLength = sizeof(wszBuffer); // In bytes !!

    // for each type
    for (dwModeCnt=0; dwModeCnt<NUM_NDP_MODES; dwModeCnt++)
    {   
        pPrevCell = NULL;

        // try to load the value. If the space is a problem, grow the buffer
        while (TRUE)
        {
            dwLength = dwBufferLength;
            lRes = RegQueryValueExW(hKey,
                                       NdpModeArray[dwModeCnt].pwszRegString,
                                       NULL,
                                       &dwType,
                                       (PVOID)pwszBuffer,
                                       &dwLength
                                       );

            if (lRes == ERROR_MORE_DATA)
            {
                // need a bigger buffer..
                if (pwszBuffer!=wszBuffer)
                {
                    FREE(pwszBuffer);
                }

                pwszBuffer = MALLOC(dwLength);
                if (pwszBuffer == NULL)
                {
                    TspLog(DL_ERROR, "RegistryLoadConfig: out of mem");
                    RegCloseKey(hKey);
                    return ERROR_OUTOFMEMORY;
                }

                dwBufferLength = dwLength;
            }
            else
            {
                break;
            }
        }

        if (lRes != ERROR_SUCCESS || dwType != REG_MULTI_SZ)
        {
            // no values
            pwszBuffer[0] = L'\0';
            lRes = ERROR_SUCCESS;
        }
            
        // parse the multistring and create the list    
        pwszCrt = pwszBuffer;

        while (*pwszCrt != L'\0')
        {
            // Alloc a cell
            pAddress = (PADDRESS_MAP)MALLOC(sizeof(ADDRESS_MAP));
            if (pAddress!= NULL)
            {
                dwLengthW = lstrlenW(pwszCrt);
                pAddress->pwszAddress = MALLOC((dwLengthW + 1)*sizeof(WCHAR));
                if (pAddress->pwszAddress != NULL)
                {
                    lstrcpynW(pAddress->pwszAddress, pwszCrt, dwLengthW+1);
                    pAddress->dwAddressLength = dwLengthW;

                    // Insert in the list. Don't matter where, the lists are not sorted...
                    pAddress->pNext = NULL;
                    pAddress->pPrev = pPrevCell;
                    if (pPrevCell)
                        pPrevCell->pNext = pAddress;
                    else
                        pAddressListArray[dwModeCnt] = pAddress;
                                        
                    pPrevCell = pAddress;
                }
                else
                {
                    TspLog(DL_ERROR, "RegistryLoadConfig: out of mem");
                    lRes = ERROR_OUTOFMEMORY;
                    FREE(pAddress);
                    break;
                }
            }
            else
            {
                TspLog(DL_ERROR, "RegistryLoadConfig: out of mem");
                lRes = ERROR_OUTOFMEMORY;
                break;
            }

            // Next string
            pwszCrt += dwLengthW + 1;
        }
    }

    if (lRes!=ERROR_SUCCESS)
    {
        FreeAllAddressLists(pAddressListArray);
    }

    RegCloseKey(hKey);
    if (pwszBuffer != wszBuffer)
    {
        FREE(pwszBuffer);
    }

    return lRes;
}

LONG
GetMediaModeForAddress(
    PCWSTR  pwszAddress,
    DWORD * pdwMediaMode
    )
{

    LONG            lRes;
    DWORD           dwModeIndex;
    PADDRESS_MAP    pAddressEntry;

    EnterCriticalSection(&gAddressMapCritSec);

    // force a reload:
    // 1. at first call
    // 2. after a change notification
    if (gbAddressMapListLoaded)
    {
        lRes = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
                                NDPTSP_NOTIFY_REGKEY_ROOT);

        gbAddressMapListLoaded = (lRes != ERROR_SUCCESS);
    }

    lRes = ERROR_SUCCESS;
    if (!gbAddressMapListLoaded)
    {
        TspLog(DL_TRACE, "GetMediaModeForAddress: reload the reg settings");

        lRes = RegistryLoadConfig(gpAddressMapListArray);
    }

    if (lRes == ERROR_SUCCESS)
    {
        if (FindAddressInLists(gpAddressMapListArray,
                              pwszAddress,
                              &dwModeIndex,
                              &pAddressEntry))
        {
            *pdwMediaMode = NdpModeArray[dwModeIndex].dwMediaMode;
        }
        else
        {
            *pdwMediaMode = LINEMEDIAMODE_UNKNOWN;
        }
    }

    LeaveCriticalSection(&gAddressMapCritSec);

    return lRes;
}

void
UpdateAddressListBox(
    PADDRESS_MAP    pAddress,
    HWND            hwndListBox
    )
{

    SendMessageW(hwndListBox, LB_RESETCONTENT, 0, 0);

    for (; pAddress!=NULL; pAddress = pAddress->pNext)
    {
         SendMessageW(hwndListBox, 
                      LB_ADDSTRING, 
                      0, 
                      (LPARAM)(pAddress->pwszAddress));
    }
}

INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LONG                    lStatus;
    CONFIG_UI_CTX           *UIContext;
    DWORD                   dwModeIndex;
    LONG                    lIndex;
    LONG                    lRes;
    WCHAR                   wszTmp[0x40];

    // decode
    switch (uMsg) {
    
    case WM_HELP:

        // F1 key or the "?" button is pressed
        (void) WinHelpW(((LPHELPINFO)lParam)->hItemHandle,
                        NDPTSP_HELP_FILE,
                        HELP_WM_HELP,
                        (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_MEDIA_MAP);

        break;

    case WM_CONTEXTMENU:

        // Right-mouse click on a dialog control
        (void) WinHelpW((HWND)wParam,
                        NDPTSP_HELP_FILE,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_MEDIA_MAP);

        break;

    case WM_INITDIALOG:

        SetWindowLongPtr(
                hDlg,
                DWLP_USER,
                lParam);

        UIContext = (CONFIG_UI_CTX *)lParam;
        
        // Get the registry values
        lRes = RegistryLoadConfig(UIContext->pAddressMapListArray);
        if (lRes != ERROR_SUCCESS)
        {
            WCHAR wszErrorMsg[0x100];

            TspLog(DL_ERROR, 
                   "ProviderConfigDlgProc: loading reg key failed(0x%08lx)", 
                   lRes);

            // load error string
            LoadStringW(ghInstance,
                        IDS_ERR_REGLOAD,
                        wszErrorMsg,
                        ARRAYSIZE(wszErrorMsg));

            // pop up error dialog
            MessageBoxW(hDlg, wszErrorMsg, NULL, MB_OK | MB_ICONSTOP);

            // stop dialog
            EndDialog(hDlg, 0);

            break;
        }

        
        // populate the combo box
        for (dwModeIndex = 0; dwModeIndex < NUM_NDP_MODES; dwModeIndex++)
        {
            LoadStringW(ghInstance,
                        NdpModeArray[dwModeIndex].dwResourceID,
                        wszTmp,
                        ARRAYSIZE(wszTmp));

        
            lIndex = (LONG)SendDlgItemMessageW(hDlg, 
                                               IDC_MEDIA_TYPE, 
                                               CB_ADDSTRING, 
                                               0, 
                                               (LPARAM)wszTmp);
            if (lIndex >= 0)
            {
                SendDlgItemMessage(hDlg, 
                                   IDC_MEDIA_TYPE, 
                                   CB_SETITEMDATA, 
                                   (WPARAM)lIndex, 
                                   (LPARAM)dwModeIndex);
            }
            else {
                TspLog(DL_ERROR, 
                       "ProviderConfigDlgProc: CB_ADDSTRING failed(%ld)", 
                       lIndex);
            }
        
        }

        // select the first
        SendDlgItemMessage(hDlg, IDC_MEDIA_TYPE, CB_SETCURSEL, (WPARAM)0, 0);
        dwModeIndex = (DWORD)SendDlgItemMessageW(hDlg, 
                                                 IDC_MEDIA_TYPE, 
                                                 CB_GETITEMDATA, 
                                                 (WPARAM)0, 
                                                 0);
        
        UIContext->hwndListBox = GetDlgItem(hDlg, IDC_ADDRESS_LIST);
        UIContext->dwCrtTypeIndex = dwModeIndex;

        // update the listbox
        UpdateAddressListBox(UIContext->pAddressMapListArray[dwModeIndex], 
                             UIContext->hwndListBox);

        // Disable the Delete button
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), FALSE); 

        break;

    case WM_COMMAND:

        UIContext = (CONFIG_UI_CTX *)GetWindowLongPtr(hDlg, DWLP_USER);

        // decode command
        switch(LOWORD(wParam))
        {
        case IDC_ADD_ADDRESS:

            if (HIWORD(wParam)==BN_CLICKED)
            {
                DialogBoxParamW(ghInstance,
                                (LPWSTR)MAKEINTRESOURCE(IDD_MEDIA_ADD),
                                hDlg,
                                ProviderConfigDetailDlgProc,
                                (LPARAM)UIContext);
                }
            break;

        case IDC_DELETE_ADDRESS:

            if (HIWORD(wParam)==BN_CLICKED)
            {
                lIndex = (LONG)SendDlgItemMessageW(hDlg, 
                                                   IDC_ADDRESS_LIST, 
                                                   LB_GETCURSEL, 
                                                   0, 
                                                   0);
                if (lIndex>=0)
                {
                    PWSTR           pwszAddress = NULL;
                    DWORD           dwLengthW;
                    DWORD           dwMode;
                    PADDRESS_MAP    pAddress;

                    dwLengthW =1 + (DWORD)SendDlgItemMessageW(hDlg, 
                                                              IDC_ADDRESS_LIST, 
                                                              LB_GETTEXTLEN, 
                                                              (WPARAM)lIndex, 
                                                              0);
                    
                    pwszAddress = (dwLengthW <= ARRAYSIZE(wszTmp)) ? wszTmp : 
                        MALLOC(dwLengthW * sizeof(WCHAR));

                    if (pwszAddress)
                    {
                        SendDlgItemMessageW(hDlg, 
                                            IDC_ADDRESS_LIST, 
                                            LB_GETTEXT, 
                                            (WPARAM)lIndex, 
                                            (LPARAM)pwszAddress);

                        // Find the address in the lists
                        if (FindAddressInLists(UIContext->pAddressMapListArray,
                                              pwszAddress,
                                              &dwMode,
                                              &pAddress))
                        {
                            // delete from list
                            if (pAddress->pNext)
                            {
                                pAddress->pNext->pPrev = pAddress->pPrev;
                            }
                            if (pAddress->pPrev)
                            {
                                pAddress->pPrev->pNext = pAddress->pNext;
                            }
                            else
                            {
                                UIContext->pAddressMapListArray[dwMode] = 
                                    pAddress->pNext;
                            }

                            FREE(pAddress->pwszAddress);
                            FREE(pAddress);
                        }
                        else
                        {
                            TspLog(DL_ERROR, 
                                   "ProviderConfigDlgProc: "\
                                   "IDC_DELETE_ADDRESS - cannot find address");
                        }

                        // delete from list box
                        SendDlgItemMessageW(hDlg, 
                                            IDC_ADDRESS_LIST, 
                                            LB_DELETESTRING, 
                                            (WPARAM)lIndex, 
                                            0);

                        // Try to select the previous one
                        if (lIndex > 0)
                        {
                            lIndex--;
                        }

                        if (LB_ERR == SendDlgItemMessageW(hDlg, 
                                                          IDC_ADDRESS_LIST, 
                                                          LB_SETCURSEL, 
                                                          (WPARAM)lIndex, 
                                                          0))
                        {
                            // Disable the Delete button
                            EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), 
                                         FALSE); 
                        }
                            
                        
                        if (pwszAddress != wszTmp)
                        {
                            FREE(pwszAddress);
                        }
                    }
                    else
                    {
                        TspLog(DL_ERROR, 
                               "ProviderConfigDlgProc: "\
                               "IDC_DELETE_ADDRESS - out of memory");
                    }
                }
                else
                {
                    TspLog(DL_ERROR, "ProviderConfigDlgProc: "\
                           "IDC_DELETE_ADDRESS - no item selected");
                }
            }

            break;

        case IDOK:
            RegistrySaveConfig(UIContext->pAddressMapListArray);

            FreeAllAddressLists(UIContext->pAddressMapListArray);

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDCANCEL:

            FreeAllAddressLists(UIContext->pAddressMapListArray);

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDC_MEDIA_TYPE:    

            if (HIWORD(wParam)==CBN_SELCHANGE)
            {
                // Disable the Delete button
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), FALSE); 

                // refresh the list box
                lIndex = (LONG)SendDlgItemMessageW(hDlg, 
                                                   IDC_MEDIA_TYPE, 
                                                   CB_GETCURSEL, 
                                                   0, 
                                                   0);

                dwModeIndex = (DWORD)SendDlgItemMessageW(hDlg, 
                                                         IDC_MEDIA_TYPE, 
                                                         CB_GETITEMDATA, 
                                                         (WPARAM)lIndex, 
                                                         0);

                // Update the context structure
                UIContext->dwCrtTypeIndex = dwModeIndex;

                // update the listbox
                UpdateAddressListBox(
                    UIContext->pAddressMapListArray[dwModeIndex], 
                    GetDlgItem(hDlg, IDC_ADDRESS_LIST));
            }

            break;

        case IDC_ADDRESS_LIST:
            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                // Enable the Delete button
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE_ADDRESS), TRUE); 
            }
            break;

        }

        break;
    }

    // success
    return FALSE;
}

static char *pszOidNames[] =
{
    "Accept",
    "Answer",
    "Close",
    "CloseCall",
    "ConditionalMediaDetection",
    "ConfigDialog",
    "DevSpecific",
    "Dial",
    "Drop",
    "GetAddressCaps",
    "GetAddressID",
    "GetAddressStatus",
    "GetCallAddressID",
    "GetCallInfo",
    "GetCallStatus",
    "GetDevCaps",
    "GetDevConfig",
    "GetExtensionID",
    "GetID",
    "GetLineDevStatus",
    "MakeCall",
    "NegotiateExtVersion",
    "Open",
    "ProviderInitialize",
    "ProviderShutdown",
    "SecureCall",
    "SelectExtVersion",
    "SendUserUserInfo",
    "SetAppSpecific",
    "StCallParams",
    "StDefaultMediaDetection",
    "SetDevConfig",
    "SetMediaMode",
    "SetStatusMessages"
};

//
// translates NDIS TAPI status codes into LINEERR_XXX
//
LONG
WINAPI
TranslateDriverResult(
    ULONG   ulRes
    )
{
    typedef struct _RESULT_LOOKUP
    {
        ULONG   NdisTapiResult;
        LONG    TapiResult;

    } RESULT_LOOKUP, *PRESULT_LOOKUP;

    typedef ULONG NDIS_STATUS;
    #define NDIS_STATUS_SUCCESS     0x00000000L
    #define NDIS_STATUS_RESOURCES   0xC000009AL
    #define NDIS_STATUS_FAILURE     0xC0000001L
    #define NDIS_STATUS_INVALID_OID 0xC0010017L

    static RESULT_LOOKUP aResults[] =
    {

    //
    // Defined in NDIS.H
    //

    { NDIS_STATUS_SUCCESS                    ,0 },

    //
    // These errors are defined in NDISTAPI.H
    //

    { NDIS_STATUS_TAPI_ADDRESSBLOCKED        ,LINEERR_ADDRESSBLOCKED        },
    { NDIS_STATUS_TAPI_BEARERMODEUNAVAIL     ,LINEERR_BEARERMODEUNAVAIL     },
    { NDIS_STATUS_TAPI_CALLUNAVAIL           ,LINEERR_CALLUNAVAIL           },
    { NDIS_STATUS_TAPI_DIALBILLING           ,LINEERR_DIALBILLING           },
    { NDIS_STATUS_TAPI_DIALDIALTONE          ,LINEERR_DIALDIALTONE          },
    { NDIS_STATUS_TAPI_DIALPROMPT            ,LINEERR_DIALPROMPT            },
    { NDIS_STATUS_TAPI_DIALQUIET             ,LINEERR_DIALQUIET             },
    { NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION,LINEERR_INCOMPATIBLEEXTVERSION},
    { NDIS_STATUS_TAPI_INUSE                 ,LINEERR_INUSE                 },
    { NDIS_STATUS_TAPI_INVALADDRESS          ,LINEERR_INVALADDRESS          },
    { NDIS_STATUS_TAPI_INVALADDRESSID        ,LINEERR_INVALADDRESSID        },
    { NDIS_STATUS_TAPI_INVALADDRESSMODE      ,LINEERR_INVALADDRESSMODE      },
    { NDIS_STATUS_TAPI_INVALBEARERMODE       ,LINEERR_INVALBEARERMODE       },
    { NDIS_STATUS_TAPI_INVALCALLHANDLE       ,LINEERR_INVALCALLHANDLE       },
    { NDIS_STATUS_TAPI_INVALCALLPARAMS       ,LINEERR_INVALCALLPARAMS       },
    { NDIS_STATUS_TAPI_INVALCALLSTATE        ,LINEERR_INVALCALLSTATE        },
    { NDIS_STATUS_TAPI_INVALDEVICECLASS      ,LINEERR_INVALDEVICECLASS      },
    { NDIS_STATUS_TAPI_INVALLINEHANDLE       ,LINEERR_INVALLINEHANDLE       },
    { NDIS_STATUS_TAPI_INVALLINESTATE        ,LINEERR_INVALLINESTATE        },
    { NDIS_STATUS_TAPI_INVALMEDIAMODE        ,LINEERR_INVALMEDIAMODE        },
    { NDIS_STATUS_TAPI_INVALRATE             ,LINEERR_INVALRATE             },
    { NDIS_STATUS_TAPI_NODRIVER              ,LINEERR_NODRIVER              },
    { NDIS_STATUS_TAPI_OPERATIONUNAVAIL      ,LINEERR_OPERATIONUNAVAIL      },
    { NDIS_STATUS_TAPI_RATEUNAVAIL           ,LINEERR_RATEUNAVAIL           },
    { NDIS_STATUS_TAPI_RESOURCEUNAVAIL       ,LINEERR_RESOURCEUNAVAIL       },
    { NDIS_STATUS_TAPI_STRUCTURETOOSMALL     ,LINEERR_STRUCTURETOOSMALL     },
    { NDIS_STATUS_TAPI_USERUSERINFOTOOBIG    ,LINEERR_USERUSERINFOTOOBIG    },
    { NDIS_STATUS_TAPI_ALLOCATED             ,LINEERR_ALLOCATED             },
    { NDIS_STATUS_TAPI_INVALADDRESSSTATE     ,LINEERR_INVALADDRESSSTATE     },
    { NDIS_STATUS_TAPI_INVALPARAM            ,LINEERR_INVALPARAM            },
    { NDIS_STATUS_TAPI_NODEVICE              ,LINEERR_NODEVICE              },

    //
    // These errors are defined in NDIS.H
    //

    { NDIS_STATUS_RESOURCES                  ,LINEERR_NOMEM },
    { NDIS_STATUS_FAILURE                    ,LINEERR_OPERATIONFAILED },
    { NDIS_STATUS_INVALID_OID                ,LINEERR_OPERATIONFAILED },

    //
    //
    //

    { NDISTAPIERR_UNINITIALIZED              ,LINEERR_OPERATIONFAILED },
    { NDISTAPIERR_BADDEVICEID                ,LINEERR_OPERATIONFAILED },
    { NDISTAPIERR_DEVICEOFFLINE              ,LINEERR_OPERATIONFAILED },

    //
    // The terminating fields
    //

    { 0xffffffff, 0xffffffff }

    };

    int i;

    for (i = 0; aResults[i].NdisTapiResult != 0xffffffff; i++)
    {
        if (ulRes == aResults[i].NdisTapiResult)
        {
            return (aResults[i].TapiResult);
        }
    }

    TspLog(DL_WARNING, "TranslateDriverResult: unknown driver result(%x)",
           ulRes);

    return LINEERR_OPERATIONFAILED;
}

//
// NOTE: for functions that need to acquire (read, write) locks for both
//       a line and a call, we enforce the order to be line first, call
//       second to avoid potential DEADLOCK.
//

LONG
GetLineObjWithReadLock(
    IN HDRVLINE     hdLine,
    OUT PDRVLINE   *ppLine
    )
{
    LONG        lRes;
    PDRVLINE    pLine;

    lRes = GetObjWithReadLock((HANDLE)hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pLine != NULL);
    if (pLine->dwKey != LINE_KEY)
    {
        TspLog(DL_WARNING, "GetLineObjWithReadLock: obj(%p) has bad key(%x)",
               hdLine, pLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppLine = pLine;
    return lRes;
}

LONG
GetLineObjWithWriteLock(
    IN HDRVLINE     hdLine,
    OUT PDRVLINE   *ppLine
    )
{
    LONG        lRes;
    PDRVLINE    pLine;

    lRes = GetObjWithWriteLock((HANDLE)hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pLine != NULL);
    if (pLine->dwKey != LINE_KEY)
    {
        TspLog(DL_WARNING, "GetLineObjWithWriteLock: obj(%p) has bad key(%x)",
               hdLine, pLine->dwKey);

        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppLine = pLine;
    return lRes;
}

LONG
GetMSPLineObjWithReadLock(
    IN HDRVMSPLINE     hdMSPLine,
    OUT PDRVMSPLINE   *ppMSPLine
    )
{
    LONG        lRes;
    PDRVMSPLINE pMSPLine;

    lRes = GetObjWithReadLock((HANDLE)hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pMSPLine != NULL);
    if (pMSPLine->dwKey != MSP_KEY)
    {
        TspLog(DL_WARNING, "GetMSPLineObjWithReadLock: obj(%p) has bad key(%x)",
               hdMSPLine, pMSPLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdMSPLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppMSPLine = pMSPLine;
    return lRes;
}

LONG
GetMSPLineObjWithWriteLock(
    IN HDRVMSPLINE     hdMSPLine,
    OUT PDRVMSPLINE   *ppMSPLine
    )
{
    LONG        lRes;
    PDRVMSPLINE pMSPLine;

    lRes = GetObjWithWriteLock((HANDLE)hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pMSPLine != NULL);
    if (pMSPLine->dwKey != MSP_KEY)
    {
        TspLog(DL_WARNING, 
               "GetMSPLineObjWithWriteLock: obj(%p) has bad key(%x)",
               hdMSPLine, pMSPLine->dwKey);

        ReleaseObjWriteLock((HANDLE)hdMSPLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *ppMSPLine = pMSPLine;
    return lRes;
}

LONG
GetLineHandleFromMSPLineHandle(
    IN HDRVMSPLINE     hdMSPLine,
    OUT HDRVLINE      *phdLine
    )
{
    LONG        lRes;
    PDRVMSPLINE pMSPLine;

    lRes = GetObjWithReadLock((HANDLE)hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    ASSERT(pMSPLine != NULL);
    if (pMSPLine->dwKey != MSP_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineHandleFromMSPLineHandle: obj(%p) has bad key(%x)",
               hdMSPLine, pMSPLine->dwKey);

        ReleaseObjReadLock((HANDLE)hdMSPLine);
        return LINEERR_INVALLINEHANDLE;
    }

    *phdLine = pMSPLine->hdLine;

    ReleaseObjReadLock((HANDLE)hdMSPLine);
    return lRes;
}

LONG
GetCallObjWithReadLock(
    IN HDRVCALL     hdCall,
    OUT PDRVCALL   *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithReadLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, "GetCallObjWithReadLock: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;
    return lRes;
}

LONG
GetCallObjWithWriteLock(
    IN HDRVCALL     hdCall,
    OUT PDRVCALL   *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithWriteLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, "GetCallObjWithWriteLock: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjWriteLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;
    return lRes;
}

LONG
GetLineHandleFromCallHandle(
    IN HDRVCALL     hdCall,
    OUT HDRVLINE   *phdLine
    )
{
    LONG        lRes;
    PDRVCALL    pCall;

    lRes = GetObjWithReadLock((HANDLE)hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return LINEERR_INVALCALLHANDLE;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != INBOUND_CALL_KEY &&
        pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineHandleFromCallHandle: obj(%p) has bad key(%x)",
               hdCall, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)hdCall);
        return LINEERR_INVALCALLHANDLE;
    }

    *phdLine = pCall->hdLine;

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
GetLineAndCallObjWithReadLock(
    HTAPI_LINE ht_Line,
    HTAPI_CALL ht_Call,
    PDRVLINE  *ppLine,
    PDRVCALL  *ppCall
    )
{
    LONG        lRes;
    PDRVCALL    pCall;
    PDRVLINE    pLine;

    lRes = GetLineObjWithReadLock((HDRVLINE)ht_Line, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    *ppLine = pLine;

    //
    // figure out whether this is an inbound call or
    // outbound call: for inbound calls, ht_Call is
    // generated by NDPROXY and bit 0 is 1;
    // for outbound calls, ht_Call is a TSP handle
    // and we make sure that bit 0 is 0
    //
    if (ht_Call & 0x1)
    {
        // inbound call: we need to walk the list
        // of inbound calls on this line and 
        // find the right one
        if ((pCall = pLine->pInboundCalls) != NULL)
        {
            while (pCall && (pCall->ht_Call != ht_Call))
            {
                pCall = pCall->pNext;
            }
        }

        if (NULL == pCall || pCall->dwKey != INBOUND_CALL_KEY)
        {
            TspLog(DL_WARNING, 
                   "GetLineAndCallObjWithReadLock: "\
                   "inbound ht_call(%p) closed already",
                   ht_Call);

            ReleaseObjReadLock((HANDLE)ht_Line);
            return LINEERR_INVALCALLHANDLE;
        }

        // call the following to increase the ref count
        lRes = AcquireObjReadLock((HANDLE)pCall->hdCall);
        if (lRes != TAPI_SUCCESS)
        {
            ReleaseObjReadLock((HANDLE)ht_Line);
            return lRes;
        }

        *ppCall = pCall;

        return TAPI_SUCCESS;
    }
    
    // ht_Call is a TSP handle and the call is OUTBOUND
    lRes = GetObjWithReadLock((HANDLE)ht_Call, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)ht_Line);
        return lRes;
    }

    ASSERT(pCall != NULL);
    if (pCall->dwKey != OUTBOUND_CALL_KEY)
    {
        TspLog(DL_WARNING, 
               "GetLineAndCallObjWithReadLock: bad call handle(%p, %x)",
               ht_Call, pCall->dwKey);

        ReleaseObjReadLock((HANDLE)ht_Call);
        ReleaseObjReadLock((HANDLE)ht_Line);
        return LINEERR_INVALCALLHANDLE;
    }

    *ppCall = pCall;

    return TAPI_SUCCESS;
}

//
// allocates mem for a NDISTAPI_REQUEST plus some initialization
//
LONG
WINAPI
PrepareSyncRequest(
    ULONG               Oid,
    ULONG               ulDeviceID,
    DWORD               dwDataSize,
    PNDISTAPI_REQUEST  *ppNdisTapiRequest
    )
{
    PNDISTAPI_REQUEST   pNdisTapiRequest =
        (PNDISTAPI_REQUEST)AllocRequest(dwDataSize + sizeof(NDISTAPI_REQUEST));
    if (NULL == pNdisTapiRequest)
    {
        TspLog(DL_ERROR, 
               "PrepareSyncRequest: failed to alloc sync req for oid(%x)", 
               Oid);
        return LINEERR_NOMEM;
    }

    pNdisTapiRequest->Oid = Oid;
    pNdisTapiRequest->ulDeviceID = ulDeviceID;
    pNdisTapiRequest->ulDataSize = dwDataSize;

    EnterCriticalSection(&gRequestIDCritSec);

    // setting ulRequestId of NDIS_TAPI_xxxx
    if ((*((ULONG *)pNdisTapiRequest->Data) = ++gdwRequestID) >= 0x7fffffff)
    {
        gdwRequestID = 1;
    }

    LeaveCriticalSection(&gRequestIDCritSec);

    *ppNdisTapiRequest = pNdisTapiRequest;

    return TAPI_SUCCESS;
}

//
// allocates mem for a ASYNC_REQUEST_WRAPPER plus some initialization
//
LONG
WINAPI
PrepareAsyncRequest(
    ULONG                   Oid,
    ULONG                   ulDeviceID,
    DWORD                   dwRequestID,
    DWORD                   dwDataSize,
    PASYNC_REQUEST_WRAPPER *ppAsyncReqWrapper
    )
{
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;

    // alloc & init an async request wrapper
    pAsyncReqWrapper = (PASYNC_REQUEST_WRAPPER)
        AllocRequest(dwDataSize + sizeof(ASYNC_REQUEST_WRAPPER));
    if (NULL == pAsyncReqWrapper)
    {
        TspLog(DL_ERROR, 
               "PrepareAsyncRequest: failed to alloc async req for oid(%x)", 
               Oid);
        return LINEERR_NOMEM;
    }

    // don't need to create an event when using completion ports
    pAsyncReqWrapper->Overlapped.hEvent = (HANDLE)NULL;

    pAsyncReqWrapper->dwKey          = ASYNCREQWRAPPER_KEY;
    pAsyncReqWrapper->dwRequestID    = dwRequestID;
    pAsyncReqWrapper->pfnPostProcess = (POSTPROCESSPROC)NULL;

    // initialize the critical section, ref the request wrapper. 
    // NOTE: this crit sec will be deleted by the last deref. 
    InitializeCriticalSection(&pAsyncReqWrapper->CritSec); 
    pAsyncReqWrapper->RefCount = 1;

    // safely initialize the driver request
    pNdisTapiRequest = &(pAsyncReqWrapper->NdisTapiRequest);

    pNdisTapiRequest->Oid = Oid;
    pNdisTapiRequest->ulDeviceID = ulDeviceID;
    pNdisTapiRequest->ulDataSize = dwDataSize;

    EnterCriticalSection(&gRequestIDCritSec);

    if ((*((ULONG *)pNdisTapiRequest->Data) = ++gdwRequestID) >= 0x7fffffff)
    {
        gdwRequestID = 1;
    }

    LeaveCriticalSection(&gRequestIDCritSec);

    *ppAsyncReqWrapper = pAsyncReqWrapper;

    return TAPI_SUCCESS;
}

//
// makes a non-overlapped request to ndproxy.sys
// so it doesn't return until the req is completed
//
LONG
WINAPI
SyncDriverRequest(
    DWORD               dwIoControlCode,
    PNDISTAPI_REQUEST   pNdisTapiRequest
    )
{
    BOOL    bRes;
    DWORD   cbReturned;

    TspLog(DL_INFO, 
           "SyncDriverRequest: oid(%s), devID(%x), reqID(%x), hdCall(%x)",
           pszOidNames[pNdisTapiRequest->Oid - OID_TAPI_ACCEPT],
           pNdisTapiRequest->ulDeviceID,
           *((ULONG *)pNdisTapiRequest->Data),
           *(((ULONG *)pNdisTapiRequest->Data) + 1));

    // mark the request as being processed by the driver
    MarkRequest(pNdisTapiRequest);

    bRes = DeviceIoControl(ghDriverSync,
                              dwIoControlCode,
                              pNdisTapiRequest,
                              (DWORD)(sizeof(NDISTAPI_REQUEST) +
                                      pNdisTapiRequest->ulDataSize),
                              pNdisTapiRequest,
                              (DWORD)(sizeof(NDISTAPI_REQUEST) +
                                      pNdisTapiRequest->ulDataSize),
                              &cbReturned,
                              0);

    // unmark the request now that the ioctl is completed
    UnmarkRequest(pNdisTapiRequest);

    if (bRes != TRUE)
    {
        TspLog(DL_ERROR, "SyncDriverRequest: IoCtl(Oid %x) failed(%d)",
               pNdisTapiRequest->Oid, GetLastError());

        return (LINEERR_OPERATIONFAILED);
    }
    else
    {
        // the errors returned by ndproxy.sys don't match the TAPI
        // LINEERR_'s, so return the translated values (but preserve
        // the original driver return val so it's possible to distinguish
        // between  NDISTAPIERR_DEVICEOFFLINE & LINEERR_OPERATIONUNAVAIL,
        // etc.)
        return (TranslateDriverResult(pNdisTapiRequest->ulReturnValue));
    }
}

//
// Routine Description:
//
// Sends a message to the MSP telling it the VC handle for a call and
// instructing it to begin streaming on that call.
//
// Arguments:
// hdLine   -   Handle to line device
// hdCall   -   Handle for call
//
// NOTES - must be called while holding the MSP mutex
//
VOID
StartMSPStream(
    HDRVLINE    hdLine,
    HDRVCALL    hdCall
    )
{
    LONG        lRes;
    DWORD       adwMSPMessage[2];
    PDRVLINE    pLine;
    PDRVCALL    pCall;
    PDRVMSPLINE pMSPLine;
    LPVARSTRING lpDeviceID;

    TspLog(DL_TRACE, "StartMSPStream: enter");

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return;
    }

    pMSPLine = pLine->pMSPLine;

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }

    //
    // allocate a VARSTRING structure with enough space for the DWORD line id.
    // @@@ shouldn't always assume that this will be the right size.
    //
    lpDeviceID = (LPVARSTRING)MALLOC(sizeof(VARSTRING) + sizeof(DWORD));
    if (NULL == lpDeviceID)
    {
        TspLog(DL_ERROR, "StartMSPStream: failed to alloc deviceID");

        ReleaseObjReadLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }
    lpDeviceID->dwTotalSize = sizeof(VARSTRING) + sizeof(DWORD);
    
    if ((lRes = TSPI_lineGetID(
                    hdLine,
                    0,  // @@@ the proxy always makes this 0, so we use 0. 
                        // Change this if the proxy changes.
                    hdCall,
                    LINECALLSELECT_CALL,
                    lpDeviceID,
                    RCA_SAP_STRING,
                    0   // @@@ we don't use this parameter, so I set it 0.
                    )) != TAPI_SUCCESS) 
    {
        TspLog(DL_ERROR, "StartMSPStream: failed to get the VC handle");

        FREE(lpDeviceID);

        ReleaseObjReadLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }

    //
    // pass the VC Handle to the MSP.
    //
    adwMSPMessage[0] = 0;   // command code for "Here's the VC Handle"
    adwMSPMessage[1] = *((DWORD *)(((PBYTE)lpDeviceID) + 
                                   lpDeviceID->dwStringOffset));

    TspLog(DL_INFO, 
           "StartMSPStream: sending VC handle(%x) to htline(%p), htcall(%p)",
           adwMSPMessage[1], pLine->htLine, pCall->htCall);

    (*gpfnLineEvent)(pLine->htLine,
                     pCall->htCall,
                     LINE_SENDMSPDATA,                          
                     (DWORD_PTR)0,
                     (DWORD_PTR)adwMSPMessage,
                     (DWORD_PTR)sizeof(DWORD) * 2);

    //
    // tell the MSP to start streaming.
    //
    adwMSPMessage[0] = 1; // command code for "Start Streaming"

    (*gpfnLineEvent)(pLine->htLine,
                     pCall->htCall,
                     LINE_SENDMSPDATA,
                     (DWORD_PTR)0,
                     (DWORD_PTR)adwMSPMessage,
                     (DWORD_PTR)sizeof(DWORD));

    pMSPLine->bStreamingStarted = TRUE;

    FREE(lpDeviceID);

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
}


//
// Routine Description:
//
// Sends a message to the MSP telling it to stop streaming on a
// particular call.
//
// Arguments:
// hdLine   -   Handle to line device
// hdCall   -   Handle for call
//
// NOTES - must be called while holding the MSP mutex
//
VOID
StopMSPStream(
    HDRVLINE    hdLine,
    HDRVCALL    hdCall
    )
{
    LONG        lRes;
    DWORD       adwMSPMessage;
    PDRVLINE    pLine;
    PDRVCALL    pCall;
    PDRVMSPLINE pMSPLine;

    TspLog(DL_TRACE, "StopMSPStream: enter");

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return;
    }

    pMSPLine = pLine->pMSPLine;

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return;
    }

    //
    // tell the MSP to stop streaming.
    //
    adwMSPMessage = 2; // command code for "Stop Streaming"
        
    TspLog(DL_INFO, 
           "StopMSPStream: sending MSP stop cmd to htline(%p), htcall(%p)",
           pLine->htLine, pCall->htCall);

    (*gpfnLineEvent)(pLine->htLine,
                     pCall->htCall,
                     LINE_SENDMSPDATA,
                     (DWORD_PTR)0,
                     (DWORD_PTR)&adwMSPMessage,
                     (DWORD_PTR)sizeof(DWORD));

    pMSPLine->bStreamingStarted = FALSE;

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
}

//
// make an overlapped call
//
LONG
WINAPI
AsyncDriverRequest(
    DWORD                   dwIoControlCode,
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper
    )
{
    BOOL    bRes;
    LONG    lRes;
    DWORD   dwRequestSize, cbReturned, dwLastError;

    TspLog(DL_INFO,
           "AsyncDriverRequest: oid(%s), devID(%x), ReqID(%x), "
           "reqID(%x), hdCall(%x)",
           pszOidNames[pAsyncReqWrapper->NdisTapiRequest.Oid -
                       OID_TAPI_ACCEPT],
           pAsyncReqWrapper->NdisTapiRequest.ulDeviceID,
           pAsyncReqWrapper->dwRequestID,
           *((ULONG *)pAsyncReqWrapper->NdisTapiRequest.Data),
           *(((ULONG *)pAsyncReqWrapper->NdisTapiRequest.Data) + 1));

    lRes = (LONG)pAsyncReqWrapper->dwRequestID;

    dwRequestSize = sizeof(NDISTAPI_REQUEST) +
        (pAsyncReqWrapper->NdisTapiRequest.ulDataSize - 1);

    REF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

    // mark the request as being processed by the driver
    MarkRequest(pAsyncReqWrapper);

    bRes = DeviceIoControl(
        ghDriverAsync,
        dwIoControlCode,
        &pAsyncReqWrapper->NdisTapiRequest,
        dwRequestSize,
        &pAsyncReqWrapper->NdisTapiRequest,
        dwRequestSize,
        &cbReturned,
        &pAsyncReqWrapper->Overlapped
        );

    DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

    if (bRes != TRUE) {

        dwLastError = GetLastError();

        if (dwLastError != ERROR_IO_PENDING) {

            TspLog(DL_ERROR, "AsyncDriverRequest: IoCtl(oid %x) failed(%d)",
                   pAsyncReqWrapper->NdisTapiRequest.Oid, dwLastError);

            // the ioctl failed and was not pended
            // this does not trigger the completion port
            // so we have to cleanup here.
            (*gpfnCompletionProc)(pAsyncReqWrapper->dwRequestID,
                                  LINEERR_OPERATIONFAILED);

            DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);
        }
    }

    return lRes;
}

//
// reports to TAPI events that occur on the line or on calls on the line
//
VOID
WINAPI
ProcessEvent(
    PNDIS_TAPI_EVENT    pEvent
    )
{
    LONG        lRes;
    ULONG       ulMsg = pEvent->ulMsg;
    HTAPI_LINE  ht_Line = (HTAPI_LINE)pEvent->htLine;
    HTAPI_CALL  ht_Call = (HTAPI_CALL)pEvent->htCall;

    TspLog(DL_INFO, 
           "ProcessEvent: event(%p), msg(%x), ht_line(%p), ht_call(%p), "\
           "p1(%p), p2(%p), p3(%p)",
           pEvent, ulMsg, ht_Line, ht_Call, 
           pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

    switch (ulMsg)
    {
    case LINE_ADDRESSSTATE:
    case LINE_CLOSE:
    case LINE_DEVSPECIFIC:
    case LINE_LINEDEVSTATE:
    {
        PDRVLINE    pLine;

        lRes = GetLineObjWithReadLock((HDRVLINE)ht_Line, &pLine);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        TspLog(DL_INFO, 
            "PE::fnLineEvent: msg(%x), htline(%p), p1(%p), p2(%p), p3(%p)",
            ulMsg, pLine->htLine, 
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         (HTAPICALL)NULL,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)ht_Line);

        break;
    }
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLINFO:
    {
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        TspLog(DL_INFO,
            "PE::fnLineEvent: msg(%x), htline(%p), htcall(%p), "\
            "p1(%p), p2(%p), p3(%p)",
            ulMsg, pLine->htLine, pCall->htCall, 
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    case LINE_CALLSTATE:
    {
        DWORD       dwWaitStatus;
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        // we may still receive a few events
        // for calls that have been closed/dropped
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        //
        // for outbound calls there exists a race condition between
        // receiving the first call state msg(s) and receiving the
        // make call completion notification (if we pass a call state
        // msg on to tapi for a call that hasn't been completed yet
        // tapi will just discard the msg since the htCall really
        // isn't valid at that point).  So if htCall references a
        // valid outbound call which hasn't completed yet, we'll save
        // the call state params, and pass them on to tapi after we
        // get & indicate a (successful) completion notification.
        //

        if ((OUTBOUND_CALL_KEY == pCall->dwKey) &&
            (TRUE == pCall->bIncomplete))
        {
            TspLog(DL_INFO, 
                   "ProcessEvent: incomplete outbound call, saving state");

            pCall->dwPendingCallState     = (DWORD)pEvent->ulParam1;
            pCall->dwPendingCallStateMode = (DWORD)pEvent->ulParam2;
            pCall->dwPendingMediaMode     = (DWORD)pEvent->ulParam3;

            ReleaseObjReadLock((HANDLE)pCall->hdCall);
            ReleaseObjReadLock((HANDLE)hdLine);
            break;
        }

        //
        // Start or stop the MSP streaming as appropriate. The only states in
        // which this might happen are CONNECTED, DISCONNECTED, or IDLE.
        //
        if ((LINECALLSTATE_CONNECTED == pEvent->ulParam1) ||
            (LINECALLSTATE_DISCONNECTED == pEvent->ulParam1) ||
            (LINECALLSTATE_IDLE == pEvent->ulParam1)) {

            TspLog(DL_TRACE, "ProcessEvent: using MSP");

            if ((dwWaitStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE))
                == WAIT_OBJECT_0) 
            {
                TspLog(DL_TRACE, "ProcessEvent: acquired MSP Mutex");
            
                if (pLine->pMSPLine) 
                {
                    TspLog(DL_TRACE, "ProcessEvent: we have an MSP");

                    if ((LINECALLSTATE_CONNECTED == pEvent->ulParam1) &&
                        (FALSE == pLine->pMSPLine->bStreamingStarted)) 
                    {
                        DWORD   dwMessage = 3;  // Command code for 
                                                // "Are you there?"
                        (*gpfnLineEvent)(pLine->htLine,
                                         pCall->htCall,
                                         LINE_SENDMSPDATA,
                                         (DWORD_PTR)0, // Send to all MSPs
                                         (DWORD_PTR)&dwMessage,
                                         (DWORD_PTR)sizeof(DWORD));

                        TspLog(DL_TRACE, 
                               "ProcessEvent: sent 'are you there ?' "\
                               "message to MSP");
                            
                    } 
                    else if(((LINECALLSTATE_DISCONNECTED == pEvent->ulParam1) ||
                             (LINECALLSTATE_IDLE == pEvent->ulParam1)) && 
                            (pLine->pMSPLine->bStreamingStarted)) 
                    {
                        TspLog(DL_TRACE, 
                               "ProcessEvent: about to call StopMSPStream");
                        StopMSPStream(pCall->hdLine, pCall->hdCall);
                    }
                }
            
                ReleaseMutex(pLine->hMSPMutex);
                TspLog(DL_TRACE, "ProcessEvent: released MSP Mutex");
            } 
            else 
            {
                TspLog(DL_ERROR, 
                       "ProcessEvent: wait for MSP Mutex failed(%x)",
                       dwWaitStatus);
            }
        }

        if (LINECALLSTATE_OFFERING == pEvent->ulParam1)
        {
            LPLINECALLINFO lpLineCallInfo;
            //
            // We're about to indicate up an offering call. We need
            // to make sure the media mode we're indicating up is 
            // correct (we can't rely on what the proxy gave us). 
            // So, we call lineGetCallInfo, which will look up the
            // proper value in a table based on the called address.
            //
            lpLineCallInfo = (LPLINECALLINFO)MALLOC(sizeof(LINECALLINFO));

            if (lpLineCallInfo) 
            {
                lpLineCallInfo->dwTotalSize = sizeof(LINECALLINFO);

                if (TSPI_lineGetCallInfo(pCall->hdCall, lpLineCallInfo) 
                    == TAPI_SUCCESS) 
                {
                    if (lpLineCallInfo->dwNeededSize > 
                        lpLineCallInfo->dwTotalSize) 
                    {
                        DWORD   dwNeededSize = lpLineCallInfo->dwNeededSize;

                        FREE(lpLineCallInfo);
                        lpLineCallInfo = (LPLINECALLINFO)MALLOC(dwNeededSize);

                        if (lpLineCallInfo) 
                        {
                            lpLineCallInfo->dwTotalSize = dwNeededSize;

                            if (TSPI_lineGetCallInfo(pCall->hdCall, 
                                                     lpLineCallInfo) 
                                != TAPI_SUCCESS) 
                            {
                                TspLog(DL_ERROR, 
                                       "ProcessEvent: second call to "\
                                       "TSPI_lineGetCallInfo failed");
                                
                                FREE(lpLineCallInfo);
                                lpLineCallInfo = NULL;
                            }
                        } 
                        else 
                        {
                            TspLog(DL_ERROR, 
                                   "ProcessEvent: failed to allocate line "\
                                   "call info structure 2nd time");
                        }
                    }

                    if (lpLineCallInfo) {
                        pEvent->ulParam3 = lpLineCallInfo->dwMediaMode;
                        
                        TspLog(DL_TRACE, 
                               "ProcessEvent: just set media mode(%x)", 
                               pEvent->ulParam3);
                    }
                } 
                else 
                {
                    TspLog(DL_ERROR, 
                           "ProcessEvent: first call to "\
                           "TSPI_lineGetCallInfo failed");
                }
                
                if (lpLineCallInfo) 
                {
                    FREE(lpLineCallInfo);
                    lpLineCallInfo = NULL;
                }
            } 
            else 
            {
                TspLog(DL_ERROR, 
                       "ProcessEvent: couldn't allocate mem "\
                       "for line call info");
            }
        }

        TspLog(DL_INFO, 
               "PE::fnLineEvent(CALLSTATE): htline(%p), htcall(%p), "\
               "p1(%p), p2(%p), p3(%p)",
               pLine->htLine, pCall->htCall, 
               pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        //
        // As a perf tweak we want to indicate an IDLE
        // immediately following the disconnected.  The proxy
        // will never indicate a callstate_idle.
        //
        if(LINECALLSTATE_DISCONNECTED == pEvent->ulParam1)
        {
            TspLog(DL_INFO,
              "PE::fnLineEvent(CALLSTATE_IDLE): htline(%p), htcall(%p), p3(%p)",
               pLine->htLine, pCall->htCall, pEvent->ulParam3);

            (*gpfnLineEvent)(pLine->htLine,
                             pCall->htCall,
                             ulMsg,
                             (DWORD_PTR)LINECALLSTATE_IDLE,
                             (DWORD_PTR)0,
                             (DWORD_PTR)pEvent->ulParam3);
        }

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    case LINE_NEWCALL:
    {
        HDRVCALL    hdCall;
        PDRVCALL    pCall;
        PDRVLINE    pLine;
        
        lRes = GetLineObjWithWriteLock((HDRVLINE)ht_Line, &pLine);

        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        // alloc & initialize a new DRVCALL object
        if (pCall = AllocCallObj(sizeof(DRVCALL)))
        {
            pCall->dwKey   = INBOUND_CALL_KEY;
            pCall->hd_Call = (HDRV_CALL)pEvent->ulParam1;
            pCall->ht_Call = (HTAPI_CALL)pEvent->ulParam2;
            pCall->hdLine   = (HDRVLINE)ht_Line;
            pCall->bIncomplete = FALSE;
        }

        //
        // if the new call object allocation failed above then we
        // want to tell the driver to drop & close the call,
        // then just break
        //

        if (NULL == pCall)
        {
            PNDISTAPI_REQUEST       pNdisTapiRequestDrop;
            PNDISTAPI_REQUEST       pNdisTapiRequestCloseCall;
            PNDIS_TAPI_DROP         pNdisTapiDrop;
            PNDIS_TAPI_CLOSE_CALL   pNdisTapiCloseCall;

            if ((lRes = PrepareSyncRequest(
                    OID_TAPI_DROP,                  // opcode
                    pLine->dwDeviceID,              // device id
                    sizeof(NDIS_TAPI_DROP),         // size of drve req data
                    &pNdisTapiRequestDrop           // ptr to ptr to request buf
                 )) != TAPI_SUCCESS)
            {
                ReleaseObjWriteLock((HANDLE)ht_Line);
                break;
            }

            pNdisTapiDrop = (PNDIS_TAPI_DROP)pNdisTapiRequestDrop->Data;

            pNdisTapiDrop->hdCall = (HDRV_CALL) pEvent->ulParam1;
            pNdisTapiDrop->ulUserUserInfoSize = 0;

            SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequestDrop);
            FreeRequest(pNdisTapiRequestDrop);

            if ((lRes = PrepareSyncRequest(
                    OID_TAPI_CLOSE_CALL,            // opcode
                    pLine->dwDeviceID,              // device id
                    sizeof(NDIS_TAPI_CLOSE_CALL),   // size of drve req data
                    &pNdisTapiRequestCloseCall      // ptr to ptr to request buf
                 )) != TAPI_SUCCESS)
            {
                ReleaseObjWriteLock((HANDLE)ht_Line);
                break;
            }

            pNdisTapiCloseCall =
                (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequestCloseCall->Data;

            pNdisTapiCloseCall->hdCall = (HDRV_CALL) pEvent->ulParam1;

            SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO,
                              pNdisTapiRequestCloseCall);

            FreeRequest(pNdisTapiRequestCloseCall);

            ReleaseObjWriteLock((HANDLE)ht_Line);
            break;
        }

        ASSERT(pCall != NULL);

        pCall->dwDeviceID = pLine->dwDeviceID;

        // make sure releasing write lock before calling OpenObjHandle()
        // to avoid deadlock on acquiring write lock for the global mapper
        ReleaseObjWriteLock((HANDLE)ht_Line);

        lRes = OpenObjHandle(pCall, FreeCallObj, (HANDLE *)&hdCall);
        if (lRes != TAPI_SUCCESS)
        {
            TspLog(DL_ERROR, 
                   "ProcessEvent: failed to map obj(%p) to handle",
                   pCall);

            FreeCallObj(pCall);
            break;
        }

        // reacquire the write lock
        lRes = AcquireObjWriteLock((HANDLE)ht_Line);
        if (lRes != TAPI_SUCCESS)
        {
            TspLog(DL_ERROR,
                   "ProcessEvent: failed to reacquire write lock for obj(%p)",
                   ht_Line);

            CloseObjHandle((HANDLE)hdCall);
            break;
        }

        // save the TSP handle
        pCall->hdCall = hdCall;

        // send the LINE_NEWCALL to TAPI, getting back the TAPI call handle
        TspLog(DL_INFO,
           "PE::fnLineEvent(NEWCALL): htline(%p), call(%p)",
           pLine->htLine, hdCall);

        (*gpfnLineEvent)(pLine->htLine,
                         (HTAPICALL)NULL,
                         LINE_NEWCALL,
                         (DWORD_PTR)hdCall,
                         (DWORD_PTR)&pCall->htCall,
                         0);

        //
        // insert the new call into the line's inbound calls list
        // regardless of the result of the LINE_NEWCALL
        // if it failed, we'll destroy the call next, and 
        // TSPI_lineCloseCall will expect the call to be
        // in the line's inbound call list
        //
        if ((pCall->pNext = pLine->pInboundCalls) != NULL)
        {
            pCall->pNext->pPrev = pCall;
        }
        pLine->pInboundCalls = pCall;

        ReleaseObjWriteLock((HANDLE)ht_Line);

        //
        // if TAPI didn't create it's own representation of this
        // cal (if pCall->htCall == NULL), then either:
        //
        //   1) the line is in the process of being closed, or
        //   2) TAPI was unable to allocate the necessary resources
        //
        // ...so we'll close the call
        //
        if (NULL == pCall->htCall)
        {
            TspLog(DL_WARNING, "ProcessEvent: TAPI failed to create "
                   "its own handle for the new call, so we close the call");
            TSPI_lineCloseCall(hdCall);
        }

        break;
    }

    case LINE_CREATE:

        TspLog(DL_INFO,
           "PE::fnLineEvent(CREATE): ghProvider(%p), p2(%p), p3(%p)",
           ghProvider, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)((HTAPILINE)NULL,
                         (HTAPICALL)NULL,
                         ulMsg,
                         (DWORD_PTR)ghProvider,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        break;

    case LINE_MONITORDIGITS:
    {
        PDRVLINE    pLine;
        PDRVCALL    pCall;
        HDRVLINE    hdLine;

        lRes = GetLineAndCallObjWithReadLock(ht_Line, ht_Call, &pLine, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            break;
        }

        hdLine = pCall->hdLine;

        TspLog(DL_INFO,
            "PE::fnLineEvent(MONITORDIGITS): htline(%p), htcall(%p), "\
            "p1(%p), p2(%p), p3(%p)",
            pLine->htLine, pCall->htCall,
            pEvent->ulParam1, pEvent->ulParam2, pEvent->ulParam3);

        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         ulMsg,
                         (DWORD_PTR)pEvent->ulParam1,
                         (DWORD_PTR)pEvent->ulParam2,
                         (DWORD_PTR)pEvent->ulParam3);

        ReleaseObjReadLock((HANDLE)pCall->hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        break;
    }
    default:

        TspLog(DL_ERROR, "ProcessEvent: unknown msg(%x)", ulMsg);

        break;

    } // switch
}

//
// thread proc that retrieves and processes completed requests 
// and async events
//
VOID
AsyncEventsThread(
    LPVOID  lpParams
    )
{
    OVERLAPPED  overlapped;
    DWORD       cbReturned;

    //
    // send an IOCTL to retrieve async events
    //
    overlapped.hEvent = NULL;   // don't need event when using completion ports

    gpAsyncEventsThreadInfo->pBuf->ulTotalSize = 
         gpAsyncEventsThreadInfo->dwBufSize - sizeof(NDISTAPI_EVENT_DATA);

    gpAsyncEventsThreadInfo->pBuf->ulUsedSize = 0;

    if (DeviceIoControl(
            ghDriverAsync,
            IOCTL_NDISTAPI_GET_LINE_EVENTS,
            gpAsyncEventsThreadInfo->pBuf,
            sizeof(NDISTAPI_EVENT_DATA),
            gpAsyncEventsThreadInfo->pBuf,
            gpAsyncEventsThreadInfo->dwBufSize,
            &cbReturned,
            &overlapped
            ) != TRUE)
    {
        DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_IO_PENDING)
        {
            TspLog(DL_ERROR,
                   "AsyncEventsThread: IoCtl(GetEvent) failed(%d)",
                   dwLastError);
        }
        ASSERT(ERROR_IO_PENDING == dwLastError);
    }

    // loop waiting for completed requests and retrieving async events
    while (1)
    {
        BOOL                bRes;
        LPOVERLAPPED        lpOverlapped;
        PNDIS_TAPI_EVENT    pEvent;

        // wait for a request to complete
        while (1) {
            DWORD       dwNumBytesTransferred;
            DWORD_PTR   dwCompletionKey;

            bRes = GetQueuedCompletionStatus(
                        ghCompletionPort,
                        &dwNumBytesTransferred,
                        &dwCompletionKey,
                        &lpOverlapped,
                        (DWORD)-1);              // infinite wait

            if (bRes) 
            {
                //
                // GetQueuedCompletion returned success so if our
                // overlapped field is non-NULL then process the
                // event.  If the overlapped field is NULL try
                // to get another event.
                //
        		if (&gOverlappedTerminate==lpOverlapped)
            	{
            		
            		TspLog(DL_WARNING, "AsyncEventsThread: "\
            			"Got exit message from TSPI_providerShutdown");

                    //
                    // Deregister from tracing
                    //
                    if(INVALID_TRACEID != gdwTraceID)
                    {
                        TraceDeregisterA(gdwTraceID);            			
                        gdwTraceID = INVALID_TRACEID;
                    }
            		return;
            	}

                if (lpOverlapped != NULL) {
                    break;
                }
                
                TspLog(DL_WARNING,
                      "AsyncEventsThread: GetQueuedCompletionStatus "\
                      "lpOverlapped == NULL!");

            } else {

                DWORD dwErr = GetLastError();


                if(ERROR_INVALID_HANDLE != dwErr)
                {
                    //
                    // Error returned from GetQueuedCompletionStatus 
                    //
                    TspLog(DL_ERROR, 
                      "AsyncEventsThread: GetQueuedCompletionStatus "\
                      "failed(%d)", dwErr);

                    Sleep(1);
                }
                else
                {
                    ExitThread(0);
                }
            }
        }

        ASSERT(lpOverlapped != NULL);

        //
        // check the returned overlapped struct to determine if
        // we have some events to process or a completed request
        //
        if (lpOverlapped == &overlapped)
        {
            DWORD   i;

            TspLog(DL_INFO, "AsyncEventsThread: got a line event");

            // handle the events
            pEvent = (PNDIS_TAPI_EVENT)gpAsyncEventsThreadInfo->pBuf->Data;

            for (i = 0;
                i < (gpAsyncEventsThreadInfo->pBuf->ulUsedSize / 
                     sizeof(NDIS_TAPI_EVENT));
                i++
                )
            {
                ProcessEvent(pEvent);
                pEvent++;
            }

            //
            // send another IOCTL to retrieve new async events
            //
            overlapped.hEvent = NULL;

            gpAsyncEventsThreadInfo->pBuf->ulTotalSize =
                 gpAsyncEventsThreadInfo->dwBufSize - 
                 sizeof(NDISTAPI_EVENT_DATA) + 1;

            gpAsyncEventsThreadInfo->pBuf->ulUsedSize = 0;

            if (DeviceIoControl(
                    ghDriverAsync,
                    IOCTL_NDISTAPI_GET_LINE_EVENTS,
                    gpAsyncEventsThreadInfo->pBuf,
                    sizeof(NDISTAPI_EVENT_DATA),
                    gpAsyncEventsThreadInfo->pBuf,
                    gpAsyncEventsThreadInfo->dwBufSize,
                    &cbReturned,
                    &overlapped
                    ) != TRUE)
            {
                DWORD dwLastError = GetLastError();
                if (dwLastError != ERROR_IO_PENDING) {
                    TspLog(DL_ERROR,
                           "AsyncEventsThread: IoCtl(GetEvent) failed(%d)",
                           dwLastError);

                    ASSERT(ERROR_IO_PENDING == dwLastError);
           
                    Sleep(1);
                }
            }
        }
        else
        {
            LONG                    lRes;
            DWORD                   dwRequestID, callStateMsgParams[5];
            PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper = 
                                        (PASYNC_REQUEST_WRAPPER)lpOverlapped;

            TspLog(DL_INFO, "AsyncEventsThread: got a completed req");

            // verify that pointer is valid
            if (pAsyncReqWrapper->dwKey != ASYNCREQWRAPPER_KEY)
            {
                TspLog(DL_WARNING, "AsyncEventsThread: got a bogus req");
                continue;
            }

            dwRequestID = pAsyncReqWrapper->dwRequestID;

            // unmark the request now that the ioctl is completed
            UnmarkRequest(pAsyncReqWrapper);

            lRes = TranslateDriverResult(
                pAsyncReqWrapper->NdisTapiRequest.ulReturnValue
                );

            TspLog(DL_INFO, 
                  "AsyncEventsThread: req(%p) with reqID(%x) returned lRes(%x)",
                   pAsyncReqWrapper, dwRequestID, lRes);

            // call the post processing proc if appropriate
            callStateMsgParams[0] = 0;
            if (pAsyncReqWrapper->pfnPostProcess)
            {
                (*pAsyncReqWrapper->pfnPostProcess)(
                    pAsyncReqWrapper,
                    lRes,
                    callStateMsgParams
                    );
            }

            // call completion proc
            TspLog(DL_TRACE, 
                   "AsyncEventsThread: call compproc with ReqID(%x), lRes(%x)",
                   dwRequestID, lRes);

            // this is a bit ugly. LineGatherDigits is not actually
            // an asynchronous call though conceptually it seems as though it
            // is. The upshot of this is that we're not supposed to call the
            // completion proc for it. If there are more calls like this that
            // we have to support, we should come up with a better mechanism
            // than this "if" statement.
            if (pAsyncReqWrapper->NdisTapiRequest.Oid != 
                OID_TAPI_GATHER_DIGITS)
            {
                (*gpfnCompletionProc)(dwRequestID, lRes);
            }

            // free the async request wrapper
            DEREF_ASYNC_REQUEST_WRAPPER(pAsyncReqWrapper);

            // when outbounding call completes, we need to 
            // report back the saved call state
            if (callStateMsgParams[0])
            {
                TspLog(DL_INFO, 
                       "AsyncEventsThread: report back the saved call state");

                TspLog(DL_INFO, 
                       "AET::fnLineEvent(CALLSTATE): htline(%p), htcall(%p), "\
                       "p1(%p), p2(%p), p3(%p)",
                       callStateMsgParams[0], callStateMsgParams[1],
                       callStateMsgParams[2], callStateMsgParams[3],
                       callStateMsgParams[4]);

                (*gpfnLineEvent)((HTAPILINE)ULongToPtr(callStateMsgParams[0]),
                                 (HTAPICALL)ULongToPtr(callStateMsgParams[1]),
                                 LINE_CALLSTATE,
                                 (DWORD_PTR)callStateMsgParams[2],
                                 (DWORD_PTR)callStateMsgParams[3],
                                 (DWORD_PTR)callStateMsgParams[4]);
            }
        }
    } // while
}

HDRV_CALL
GetNdisTapiHandle(
    PDRVCALL pCall,
    LONG *plRes
    )
{
    HDRVCALL hdCall;
    PDRVCALL pCallLocal = pCall;
    LONG lRes;
    
    ASSERT(pCall != NULL);

    hdCall  = pCall->hdCall;

    if(plRes != NULL)
    {
        *plRes = TAPI_SUCCESS;
    }

    //
    // if the call is outbound, wait until the make call request
    // has completed so we don't send a bad NDPROXY handle down
    // to the driver
    //
    if (OUTBOUND_CALL_KEY == pCall->dwKey)
    {
        if (pCall->bIncomplete)
        {
            TspLog(DL_INFO, 
                "GetNdisTapiHandle: wait for the outbound call to complete...");

            do
            {
                ASSERT(plRes != NULL);
                
                //
                // Release lock before going to sleep, ow we
                // have a deadlock.
                //
                ReleaseObjReadLock((HANDLE) hdCall);
                Sleep(250);
                
                //
                // ReAcquire Read Lock. Break if we can't
                //
                lRes = GetCallObjWithReadLock(hdCall, &pCallLocal);
                if(lRes != TAPI_SUCCESS)
                {
                    *plRes = lRes;
                    break;
                }
            } while (pCall->bIncomplete);
        }
    }

    return pCall->hd_Call;
}

//
// TSPI_lineXXX functions
//
LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_ACCEPT       pNdisTapiAccept;

    TspLog(DL_TRACE, "lineAccept(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_ACCEPT,                   // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_ACCEPT) + dwSize, // size of drv request data
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiAccept =
        (PNDIS_TAPI_ACCEPT)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiAccept->hdCall = GetNdisTapiHandle(pCall, NULL);

    if ((pNdisTapiAccept->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiAccept->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_ANSWER       pNdisTapiAnswer;

    TspLog(DL_TRACE, "lineAnswer(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_ANSWER,                   // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_ANSWER) + dwSize, // size of drv request data
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiAnswer =
        (PNDIS_TAPI_ANSWER)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiAnswer->hdCall = GetNdisTapiHandle(pCall, NULL);

    if ((pNdisTapiAnswer->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiAnswer->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine;
    PNDISTAPI_REQUEST   pNdisTapiRequest;
    PNDIS_TAPI_CLOSE    pNdisTapiClose;

    TspLog(DL_TRACE, "lineClose(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_CLOSE,             // opcode
             pLine->dwDeviceID,          // device id
             sizeof(NDIS_TAPI_CLOSE),    // size of drve req data
             &pNdisTapiRequest           // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiClose = (PNDIS_TAPI_CLOSE)pNdisTapiRequest->Data;

    // mark line as invalid so any related events that show up
    // will be discarded.
    pLine->dwKey = INVALID_KEY;

    pNdisTapiClose->hdLine = pLine->hd_Line;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    FreeRequest(pNdisTapiRequest);

    CloseHandle(pLine->hMSPMutex);

    if (TAPI_SUCCESS == lRes)
    {
        lRes = DecommitNegotiatedTSPIVersion(pLine->dwDeviceID);
    }

    ReleaseObjWriteLock((HANDLE)hdLine);

    // release line resources
    CloseObjHandle((HANDLE)hdLine);

    return lRes;
}

LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    HDRVLINE                hdLine;
    PDRVLINE                pLine;
    PDRVCALL                pCall;
    PNDISTAPI_REQUEST       pNdisTapiRequestCloseCall;
    PNDIS_TAPI_CLOSE_CALL   pNdisTapiCloseCall;
    BOOL                    bInboundCall;
    HDRV_CALL               NdisTapiHandle;

    TspLog(DL_TRACE, "lineCloseCall(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    //
    // Initially we need to acquire the read lock for the objects.
    // We can't acquire the write lock immediately because we might 
    // have to spin-wait in the GetNdisTapiHandle call.
    //
    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    bInboundCall = (INBOUND_CALL_KEY == pCall->dwKey);

    NdisTapiHandle = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);

    //
    // Now acquire the write locks
    //
    lRes = AcquireObjWriteLock((HANDLE)hdLine);
    if (lRes != TAPI_SUCCESS) {
        return lRes;
    }

    lRes = AcquireObjWriteLock((HANDLE)hdCall);
    if (lRes != TAPI_SUCCESS) {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
            OID_TAPI_CLOSE_CALL,            // opcode
            pCall->dwDeviceID,              // device id
            sizeof(NDIS_TAPI_CLOSE_CALL),   // size of drve req data
            &pNdisTapiRequestCloseCall      // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }


    // mark the call as bad so any events get discarded
    pCall->dwKey = INVALID_KEY;

    // set up the params & call the driver
    pNdisTapiCloseCall = (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequestCloseCall->Data;
    pNdisTapiCloseCall->hdCall = NdisTapiHandle;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO,
                             pNdisTapiRequestCloseCall);
    FreeRequest(pNdisTapiRequestCloseCall);

    // if inbound call, remove it from the list
    if (bInboundCall)
    {
        if (pCall->pNext)
        {
            pCall->pNext->pPrev = pCall->pPrev;
        }
        if (pCall->pPrev)
        {
            pCall->pPrev->pNext = pCall->pNext;
        }
        else
        {
            pLine->pInboundCalls = pCall->pNext;
        }
    }

    ReleaseObjWriteLock((HANDLE)hdCall);
    ReleaseObjWriteLock((HANDLE)hdLine);

    // free the call struct now that the call is closed
    CloseObjHandle((HANDLE)hdCall);

    return lRes;
}

//
// Routine Description:
//
// Called when an instance of our MSP is closed. In this routine we
// just clean up our structures.
//
// Arguments:
// hdMSPLine    - Our MSP handle: we returned this in
//                TSPI_lineCreateMSPInstance()
//
// Return value:
// If the MSP handle is invalid, we return LINEERR_OPERATIONFAILED,
// otherwise we return NOERROR.
//
LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE   hdMSPLine
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVMSPLINE     pMSPLine;
    HDRVLINE        hdLine;
    PDRVLINE        pLine;
    DWORD           dwStatus;

    TspLog(DL_TRACE, "lineCloseMSPInstance(%d): MSPline(%p)", 
           ++dwSum, hdMSPLine);

    lRes = GetLineHandleFromMSPLineHandle(hdMSPLine, &hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetMSPLineObjWithWriteLock(hdMSPLine, &pMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdLine);
        return lRes;
    }

    pMSPLine->dwKey = INVALID_KEY;

    if ((dwStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE)) 
        != WAIT_OBJECT_0) 
    {
        TspLog(DL_ERROR, "lineCloseMSPInstance: MSP mutex wait failed(%x)",
               dwStatus);

        ReleaseObjWriteLock((HANDLE)hdMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    pLine->pMSPLine = NULL;

    if (!ReleaseMutex(pLine->hMSPMutex)) 
    {
        TspLog(DL_ERROR, "lineCloseMSPInstance: MSP mutex release failed");

        ReleaseObjWriteLock((HANDLE)hdMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseObjWriteLock((HANDLE)hdMSPLine);
    ReleaseObjWriteLock((HANDLE)hdLine);

    CloseObjHandle((HANDLE)hdMSPLine);

    return lRes;
}

LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static DWORD                            dwSum = 0;
    LONG                                    lRes;
    PDRVLINE                                pLine;
    PNDISTAPI_REQUEST                       pNdisTapiRequest;
    PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION  pNdisTapiConditionalMediaDetection;

    TspLog(DL_TRACE, "lineConditionalMediaDetection(%d): line(%p), mode(%x)", 
           ++dwSum, hdLine, dwMediaModes);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_CONDITIONAL_MEDIA_DETECTION,      // opcode
             pLine->dwDeviceID,                         // device id
             sizeof(NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION) +
             (lpCallParams->dwTotalSize - sizeof(LINE_CALL_PARAMS)),
             &pNdisTapiRequest                          // ptr to ptr to 
                                                        // req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiConditionalMediaDetection =
        (PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION) pNdisTapiRequest->Data;

    pNdisTapiConditionalMediaDetection->hdLine = pLine->hd_Line;
    pNdisTapiConditionalMediaDetection->ulMediaModes = dwMediaModes;

    CopyMemory(
        &pNdisTapiConditionalMediaDetection->LineCallParams,
        lpCallParams,
        lpCallParams->dwTotalSize
        );

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

//
// Routine Description:
//
// Called when an instance of our MSP is created. In this routine we
// just set up our structures and save away the TAPI handle to this
// MSP instance.
//
// Arguments:
// hdLine   - Handle to the line on which the MSP is being created
// dwAddressID - An address on the given open line device
// htMSPLine    - The TAPI handle to the MSP call
// lphdMSPLine  - Pointer to location in which to return our handle
//                to the MSP instance.
//
// Return value:
// If things go well, NOERROR, otherwise LINEERR_NOMEM if we fail to
// allocate a DRVMSPLINE structure.
//
LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE         hdLine,
    DWORD            dwAddressID,
    HTAPIMSPLINE     htMSPLine,
    LPHDRVMSPLINE    lphdMSPLine
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVLINE        pLine;
    PDRVMSPLINE     pMSPLine;
    DWORD           dwStatus;

    TspLog(DL_TRACE, "lineCreateMSPInstance(%d): line(%p), addressID(%x)", 
           ++dwSum, hdLine, dwAddressID);

    lRes = GetLineObjWithWriteLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // allocate and init a DRVMSPLINE struct
    if (!(pMSPLine = AllocMSPLineObj(sizeof(DRVMSPLINE))))
    {
        TspLog(DL_ERROR, 
               "lineCreateMSPInstance: failed to create MSP line obj");

        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_NOMEM;
    }
    pMSPLine->dwKey = MSP_KEY;
    pMSPLine->hdLine = hdLine;
    pMSPLine->dwAddressID = dwAddressID;
    pMSPLine->htMSPLine = htMSPLine;
    
    if ((dwStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE)) 
        != WAIT_OBJECT_0) 
    {
        TspLog(DL_ERROR, "lineCreateMSPInstance: MSP mutex wait failed(%x)",
               dwStatus);

        FreeMSPLineObj(pMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }
    
    pLine->pMSPLine = pMSPLine;

    if (!ReleaseMutex(pLine->hMSPMutex))
    {
        TspLog(DL_ERROR, "lineCreateMSPInstance: MSP mutex release failed");

        FreeMSPLineObj(pMSPLine);
        ReleaseObjWriteLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    // make sure release read lock before calling OpenObjHandle()
    // to avoid deadlock on acquiring write lock for the global mapper
    ReleaseObjWriteLock((HANDLE)hdLine);

    lRes = OpenObjHandle(pMSPLine, FreeMSPLineObj, (HANDLE *)lphdMSPLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "lineCreateMSPInstance: failed to map obj(%p) to handle", 
               pMSPLine);

        FreeMSPLineObj(pMSPLine);
    }

    return lRes;
}

LONG
PASCAL
TSPI_lineDevSpecific_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    TspLog(DL_TRACE, "lineDevSpecific_post: lRes(%x)", lRes);

    if (TAPI_SUCCESS == lRes)
    {
        PNDIS_TAPI_DEV_SPECIFIC pNdisTapiDevSpecific =
            (PNDIS_TAPI_DEV_SPECIFIC)pAsyncReqWrapper->NdisTapiRequest.Data;

        CopyMemory(
            (LPVOID) pAsyncReqWrapper->dwRequestSpecific,
            pNdisTapiDevSpecific->Params,
            pNdisTapiDevSpecific->ulParamsSize
            );
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HDRVCALL        hdCall,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVLINE                pLine;
    PDRVCALL                pCall = NULL;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DEV_SPECIFIC pNdisTapiDevSpecific;

    TspLog(DL_TRACE, 
           "lineDevSpecific(%d): reqID(%x), line(%p), addressID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdLine, dwAddressID, hdCall);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DEV_SPECIFIC,             // opcode
             pLine->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DEV_SPECIFIC) +   // size of drv request data
             (dwSize - 1),
             &pAsyncReqWrapper                  // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiDevSpecific = 
        (PNDIS_TAPI_DEV_SPECIFIC)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDevSpecific->hdLine = pLine->hd_Line;
    pNdisTapiDevSpecific->ulAddressID = dwAddressID;

    if (hdCall)
    {
        lRes = GetCallObjWithReadLock(hdCall, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            FreeRequest(pAsyncReqWrapper);
            ReleaseObjReadLock((HANDLE)hdLine);
            return lRes;
        }
        pNdisTapiDevSpecific->hdCall = GetNdisTapiHandle(pCall, &lRes);

        if(lRes != TAPI_SUCCESS)
        {
            FreeRequest(pAsyncReqWrapper);
            ReleaseObjReadLock((HANDLE)hdLine);
            return lRes;
        }
    }
    else
    {
        pNdisTapiDevSpecific->hdCall = (HDRV_CALL)NULL;
    }

    pNdisTapiDevSpecific->ulParamsSize = dwSize;
    CopyMemory(pNdisTapiDevSpecific->Params, lpParams, dwSize);

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)lpParams;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineDevSpecific_postProcess;

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    if (pCall != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
    }
    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCWSTR         lpszDestAddress,
    DWORD           dwCountryCode
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    DWORD                   dwLength = lstrlenW (lpszDestAddress) + 1;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DIAL         pNdisTapiDial;

    TspLog(DL_TRACE, "lineDial(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DIAL,                     // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DIAL) + dwLength, // size of driver req buffer
             &pAsyncReqWrapper                  // ptr to ptr to req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiDial =
        (PNDIS_TAPI_DIAL)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDial->hdCall = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiDial->ulDestAddressSize = dwLength;

    WideCharToMultiByte(CP_ACP, 0, lpszDestAddress, 
                        -1, (LPSTR)pNdisTapiDial->szDestAddress,
                        dwLength, NULL, NULL);

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_DROP         pNdisTapiDrop;
    HDRV_CALL               NdisTapiHandle;

    TspLog(DL_TRACE, "lineDrop(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    //
    // Initially we need to acquire the read lock for the object.
    // We can't acquire the write lock immediately because we
    // might have to spin-wait in the GetNdisTapiHandle call.
    //
    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    NdisTapiHandle = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    ReleaseObjReadLock((HANDLE)hdCall);

    //
    // Now acquire the write lock
    //
    lRes = AcquireObjWriteLock((HANDLE)hdCall);
    if (lRes) {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_DROP,                     // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_DROP) + dwSize,   // size of driver req buffer
             &pAsyncReqWrapper                  // ptr to ptr to req buffer
         )) != TAPI_SUCCESS)
    {
        ReleaseObjWriteLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiDrop =
        (PNDIS_TAPI_DROP)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiDrop->hdCall = NdisTapiHandle;

    //
    // @@@: the following is for legacy NDISWAN ISDN miniports
    //
    // Safely mark the call as dropped so the CloseCall code
    // won't follow up with another "automatic" drop
    //
    pCall->bDropped = TRUE;

    if ((pNdisTapiDrop->ulUserUserInfoSize = dwSize) != 0)
    {
        CopyMemory(pNdisTapiDrop->UserUserInfo, lpsUserUserInfo, dwSize);
    }

    ReleaseObjWriteLock((HANDLE)hdCall);

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    return lRes;
}

LONG
PASCAL
TSPI_lineGatherDigits_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    LPDWORD                 callStateMsgParams
    )
{
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    LPWSTR                      lpsDigitsBuffer;
    LONG                        lSuc;
    HDRVLINE                    hdLine;
    PDRVLINE                    pLine;
    HDRVCALL                    hdCall;
    PDRVCALL                    pCall;

    TspLog(DL_TRACE, "lineGatherDigits_post: lRes(%x)", lRes);

    hdCall = (HDRVCALL)(pAsyncReqWrapper->dwRequestSpecific);

    lSuc = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetLineObjWithReadLock(hdLine, &pLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetCallObjWithReadLock(hdCall, &pCall);
    if (lSuc != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lSuc;
    }

    if (TAPI_SUCCESS == lRes) 
    {
        pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pAsyncReqWrapper->NdisTapiRequest.Data;

        lpsDigitsBuffer = (LPWSTR)(((LPBYTE)pNdisTapiGatherDigits) +
                                   pNdisTapiGatherDigits->ulDigitsBufferOffset);

        wcscpy(pNdisTapiGatherDigits->lpsOrigDigitsBuffer, lpsDigitsBuffer);
        
        // send the LINE_GATHERDIGITS message to TAPI.
        (*gpfnLineEvent)(pLine->htLine,
                         pCall->htCall,
                         LINE_GATHERDIGITS,
                         (DWORD_PTR)pNdisTapiGatherDigits->ulTerminationReason,
                         (DWORD_PTR)pNdisTapiGatherDigits->ulEndToEndID,
                         (DWORD_PTR)pNdisTapiGatherDigits->ulTickCount);
    }

    ReleaseObjReadLock((HANDLE)hdCall);
    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

// ++ DTMFDigitToOrdinal
//
// Turn a DTMF digit into a number between 0 and 15. The digits are assigned
// numbers in the following order: '0' - '9', 'A' - 'D', '*', '#'.
//
// Arguments:
// wcDigit  - The digit, expressed as a UNICODE character.
//
// Return value:
// A number between 0 and 15, or 16 if the digit passed in was not a valid 
// DTMF digit. 
// 
ULONG
DTMFDigitToOrdinal(
    WCHAR    wcDigit
    )
{
    if ((wcDigit >= L'0') && (wcDigit <= L'9'))
    {
        return (wcDigit - L'0');
    }
    if ((wcDigit >= L'A') && (wcDigit <= L'D'))
    {
        return (10 + (wcDigit - L'A'));
    }
    if (L'*' == wcDigit)
    {
        return 14;
    }
    if (L'#' == wcDigit)
    {
        return 15;
    }
    
    return 16;
}

LONG
TSPIAPI
TSPI_lineGatherDigits(
    HDRVCALL  hdCall,
    DWORD     dwEndToEndID,
    DWORD     dwDigitModes,
    LPWSTR    lpsDigits,
    DWORD     dwNumDigits,
    LPCWSTR   lpszTerminationDigits,
    DWORD     dwFirstDigitTimeout,
    DWORD     dwInterDigitTimeout
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwDigitsLength, dwTermDigitsLength;
    PASYNC_REQUEST_WRAPPER      pAsyncReqWrapper;
    PDRVCALL                    pCall;
    WCHAR                      *pwszTerminationDigit;
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    
    TspLog(DL_TRACE, "lineGatherDigits(%d): call(%p), EndToEndID(%x)",
           hdCall, dwEndToEndID);
    
    if (0 == dwNumDigits) 
    {
        TspLog(DL_ERROR, "lineGatherDigits: dwNumDigits is 0");
        return LINEERR_INVALPARAM;
    }

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // calculate the length required to store the digits.
    if (lpsDigits) 
    {
        dwDigitsLength = dwNumDigits + 1;
    } 
    else 
    {
        dwDigitsLength = 0;
    }   

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_GATHER_DIGITS,
             pCall->dwDeviceID,
             dwEndToEndID,              // @@@: don't know what to pass in
             sizeof(NDIS_TAPI_GATHER_DIGITS) + (dwDigitsLength * 2),
             &pAsyncReqWrapper
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }
        
    pNdisTapiGatherDigits =
        (PNDIS_TAPI_GATHER_DIGITS) pAsyncReqWrapper->NdisTapiRequest.Data;

    // store the pointer to the pCall because we'll need it 
    // in our postprocess function.
    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)hdCall;
    
    //
    // Set up the parameters in our structure.
    //
    pNdisTapiGatherDigits->hdCall = GetNdisTapiHandle(pCall, &lRes);
    
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiGatherDigits->ulEndToEndID = dwEndToEndID;
    pNdisTapiGatherDigits->ulDigitModes = dwDigitModes;
    pNdisTapiGatherDigits->lpsOrigDigitsBuffer = lpsDigits;
    pNdisTapiGatherDigits->ulDigitsBufferOffset = 
        (lpsDigits ? sizeof(NDIS_TAPI_GATHER_DIGITS) : 0);
    pNdisTapiGatherDigits->ulNumDigitsNeeded = dwNumDigits;
    pNdisTapiGatherDigits->ulNumDigitsRead = 0;
    pNdisTapiGatherDigits->ulFirstDigitTimeout = dwFirstDigitTimeout;
    pNdisTapiGatherDigits->ulInterDigitTimeout = dwInterDigitTimeout;

    //
    // Turn the termination digits into a bit mask. There are 16 DTMF digits 
    // and I assign each one a bit in a word. If the digit is present in the 
    // termination digit string we were passed, we set the bit to 1 in the 
    // mask, otherwise it's set to zero. This makes it easier for the proxy 
    // to determine if it's read a termination digit: just turn the read digit 
    // into it's assigned bit number between 0 and 15 (I use the order '0' - 
    // '9', 'A' - 'D', '*', '#') and bitwise AND the mask with a word 
    // containing a 1 in the bit belonging to the digit. This makes it an O(1) 
    // operation. 
    //
    pNdisTapiGatherDigits->ulTerminationDigitsMask = 0;

    pwszTerminationDigit = (LPWSTR)lpszTerminationDigits;
    while (*pwszTerminationDigit != UNICODE_NULL) 
    {
        ULONG ulBitNum = DTMFDigitToOrdinal(*pwszTerminationDigit);         

        if (ulBitNum < 16) {
            pNdisTapiGatherDigits->ulTerminationDigitsMask |= (1 << ulBitNum);
        }

        pwszTerminationDigit++;
    }

    pAsyncReqWrapper->pfnPostProcess = TSPI_lineGatherDigits_postProcess;

    //
    // I'm not setting lRes to the return value from here. This is because 
    // TAPI requires this function to return zero in the success case. This 
    // is a bit of a hokey situation - will need further discussion.
    //
    AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_ADDRESS_CAPS          pCaps;
    PNDIS_TAPI_GET_ADDRESS_CAPS pNdisTapiGetAddressCaps;

    TspLog(DL_TRACE, 
           "lineGetAddressCaps(%d): deviceID(%x), addressID(%x), "\
           "TSPIV(%x), ExtV(%x)",
           ++dwSum, dwDeviceID, dwAddressID);


    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_CAPS,             // opcode
             dwDeviceID,                            // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_CAPS) +   // size of req data
             (lpAddressCaps->dwTotalSize - sizeof(LINE_ADDRESS_CAPS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetAddressCaps =
        (PNDIS_TAPI_GET_ADDRESS_CAPS)pNdisTapiRequest->Data;

    pNdisTapiGetAddressCaps->ulDeviceID = dwDeviceID;
    pNdisTapiGetAddressCaps->ulAddressID = dwAddressID;
    pNdisTapiGetAddressCaps->ulExtVersion = dwExtVersion;

    pCaps = &pNdisTapiGetAddressCaps->LineAddressCaps;
    pCaps->ulTotalSize  = lpAddressCaps->dwTotalSize;
    pCaps->ulNeededSize = pCaps->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);

    ZeroMemory(
        &pCaps->ulLineDeviceID, 
        sizeof(LINE_ADDRESS_CAPS) - 3 * sizeof(ULONG)
        );

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //

    lpAddressCaps->dwNeededSize =
        pCaps->ulNeededSize +
        (sizeof(LINEADDRESSCAPS) -         // v2.0 struct
            sizeof(LINE_ADDRESS_CAPS)) +   // v1.0 struct
        (pCaps->ulNeededSize - sizeof(LINE_ADDRESS_CAPS));


    //
    // Copy over the fixed fields that don't need changing, i.e.
    // everything from dwAddressSharing to dwCallCompletionModes
    //

    lpAddressCaps->dwLineDeviceID = dwDeviceID;

    CopyMemory(
        &lpAddressCaps->dwAddressSharing,
        &pCaps->ulAddressSharing,
        sizeof(LINE_ADDRESS_CAPS) - (12 * sizeof(DWORD))
        );

    if (lpAddressCaps->dwNeededSize > lpAddressCaps->dwTotalSize)
    {
        lpAddressCaps->dwUsedSize =
            (lpAddressCaps->dwTotalSize < sizeof(LINEADDRESSCAPS) ?
            lpAddressCaps->dwTotalSize : sizeof(LINEADDRESSCAPS));
    }
    else
    {
        lpAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS); // v2.0 struct

        //
        // Supported device classes
        //
        INSERTVARDATA(
            pCaps,
            &pCaps->ulDeviceClassesSize,
            lpAddressCaps,
            &lpAddressCaps->dwDeviceClassesSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.DeviceClasses"
            );

        INSERTVARDATA(
            pCaps,
            &pCaps->ulAddressSize,
            lpAddressCaps,
            &lpAddressCaps->dwAddressSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.Address"
            );

        INSERTVARDATA(
            pCaps,
            &pCaps->ulDevSpecificSize,
            lpAddressCaps,
            &lpAddressCaps->dwDevSpecificSize,
            sizeof(LINE_ADDRESS_CAPS),
            "LINE_ADDRESS_CAPS.DevSpecific"
            );

        if (pCaps->ulCompletionMsgTextSize != 0)
        {
            // @@@ convert ComplMsgText to unicode???
            INSERTVARDATA(
                pCaps,
                &pCaps->ulCompletionMsgTextSize,
                lpAddressCaps,
                &lpAddressCaps->dwCompletionMsgTextSize,
                sizeof(LINE_ADDRESS_CAPS),
                "LINE_ADDRESS_CAPS.CompletionMsgText"
                );

            lpAddressCaps->dwNumCompletionMessages =
                pCaps->ulNumCompletionMessages;
            lpAddressCaps->dwCompletionMsgTextEntrySize =
                pCaps->ulCompletionMsgTextEntrySize;
        }

        // make sure dwNeededSize == dwUsedSize
        lpAddressCaps->dwNeededSize = lpAddressCaps->dwUsedSize;
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVLINE                    pLine;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_GET_ADDRESS_ID   pNdisTapiGetAddressID;

    TspLog(DL_TRACE, "lineGetAddressID(%d): line(%p), addressMode(%x)", 
           ++dwSum, hdLine, dwAddressMode);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_ID,           // opcode
             pLine->dwDeviceID,                 // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_ID) + // size of req data
             dwSize / 2 - 1,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetAddressID = (PNDIS_TAPI_GET_ADDRESS_ID)pNdisTapiRequest->Data;

    pNdisTapiGetAddressID->hdLine = pLine->hd_Line;
    pNdisTapiGetAddressID->ulAddressMode = dwAddressMode;
    pNdisTapiGetAddressID->ulAddressSize = dwSize / 2;

    WideCharToMultiByte(CP_ACP, 0, lpsAddress, dwSize,
            (LPSTR)pNdisTapiGetAddressID->szAddress, dwSize / 2, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwAddressID = pNdisTapiGetAddressID->ulAddressID;

        TspLog(DL_INFO, "lineGetAddressID: addressID(%x)", *lpdwAddressID);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PLINE_ADDRESS_STATUS            pStatus;
    PNDIS_TAPI_GET_ADDRESS_STATUS   pNdisTapiGetAddressStatus;

    TspLog(DL_TRACE, "lineGetAddressStatus(%d): line(%p), addressID(%x)", 
           ++dwSum, hdLine, dwAddressID);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ADDRESS_STATUS,           // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_ADDRESS_STATUS) + // size of req data
             (lpAddressStatus->dwTotalSize - sizeof(LINE_ADDRESS_STATUS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetAddressStatus =
        (PNDIS_TAPI_GET_ADDRESS_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetAddressStatus->hdLine = pLine->hd_Line;
    pNdisTapiGetAddressStatus->ulAddressID = dwAddressID;

    pStatus = &pNdisTapiGetAddressStatus->LineAddressStatus;

    pStatus->ulTotalSize = lpAddressStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_ADDRESS_STATUS);

    ZeroMemory(&pStatus->ulNumInUse, 
               sizeof(LINE_ADDRESS_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpAddressStatus,
            &pNdisTapiGetAddressStatus->LineAddressStatus,
            pNdisTapiGetAddressStatus->LineAddressStatus.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVCALL                        pCall;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_GET_CALL_ADDRESS_ID  pNdisTapiGetCallAddressID;

    TspLog(DL_TRACE, "lineGetCallAddressID(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_ADDRESS_ID,          // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_ADDRESS_ID), // size of req data
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallAddressID =
        (PNDIS_TAPI_GET_CALL_ADDRESS_ID)pNdisTapiRequest->Data;

    pNdisTapiGetCallAddressID->hdCall = GetNdisTapiHandle(pCall, &lRes);

    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwAddressID = pNdisTapiGetCallAddressID->ulAddressID;
        TspLog(DL_INFO, "lineGetCallAddressID: addressID(%x)", *lpdwAddressID);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_CALL_INFO             pInfo;
    PNDIS_TAPI_GET_CALL_INFO    pNdisTapiGetCallInfo;

    TspLog(DL_TRACE, "lineGetCallInfo(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_INFO,                // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_INFO) +      // size of req data
             (lpCallInfo->dwTotalSize - sizeof(LINE_CALL_INFO)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallInfo = (PNDIS_TAPI_GET_CALL_INFO)pNdisTapiRequest->Data;

    pNdisTapiGetCallInfo->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    pInfo = &pNdisTapiGetCallInfo->LineCallInfo;

    pInfo->ulTotalSize = lpCallInfo->dwTotalSize;
    pInfo->ulNeededSize = pInfo->ulUsedSize = sizeof(LINE_CALL_INFO);

    ZeroMemory(&pInfo->hLine, sizeof(LINE_CALL_INFO) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //

    lpCallInfo->dwNeededSize =
        pInfo->ulNeededSize +
        (sizeof(LINECALLINFO) -        // v2.0 struct
            sizeof(LINE_CALL_INFO)) +  // v1.0 struct
        (pInfo->ulNeededSize - sizeof(LINE_CALL_INFO));

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwLineDeviceID to dwTrunk
    //

    CopyMemory(
        &lpCallInfo->dwLineDeviceID,
        &pInfo->ulLineDeviceID,
        23 * sizeof(DWORD)
        );

    if (lpCallInfo->dwNeededSize > lpCallInfo->dwTotalSize)
    {
        lpCallInfo->dwUsedSize =
            (lpCallInfo->dwTotalSize < sizeof(LINECALLINFO) ?
            lpCallInfo->dwTotalSize : sizeof(LINECALLINFO));
    }
    else
    {
        PWSTR   pwszCalledAddress;
        DWORD   dwAlteredMediaModes;

        lpCallInfo->dwUsedSize = sizeof(LINECALLINFO); // v2.0 struct

        lpCallInfo->dwCallerIDFlags = pInfo->ulCallerIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCallerIDSize,
            lpCallInfo,
            &lpCallInfo->dwCallerIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CallerID"
            );

        lpCallInfo->dwCallerIDAddressType = pInfo->ulCallerIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCallerIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwCallerIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CallerIDName"
            );

        lpCallInfo->dwCalledIDFlags = pInfo->ulCalledIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCalledIDSize,
            lpCallInfo,
            &lpCallInfo->dwCalledIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CalledID"
            );

        lpCallInfo->dwCalledIDAddressType = pInfo->ulCalledIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulCalledIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwCalledIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.CalledIDName"
            );

        lpCallInfo->dwConnectedIDFlags = pInfo->ulConnectedIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulConnectedIDSize,
            lpCallInfo,
            &lpCallInfo->dwConnectedIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ConnectID"
            );

        lpCallInfo->dwConnectedIDAddressType = pInfo->ulConnectedIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulConnectedIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwConnectedIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ConnectIDName"
            );

        lpCallInfo->dwRedirectionIDFlags = pInfo->ulRedirectionIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectionIDSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectionIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectionID"
            );

        lpCallInfo->dwRedirectionIDAddressType = 
                                       pInfo->ulRedirectionIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectionIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectionIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectionIDName"
            );

        lpCallInfo->dwRedirectingIDFlags = pInfo->ulRedirectingIDFlags;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectingIDSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectingIDSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectingID"
            );

        lpCallInfo->dwRedirectingIDAddressType = 
                                       pInfo->ulRedirectingIDAddressType;

        INSERTVARDATA(
            pInfo,
            &pInfo->ulRedirectingIDNameSize,
            lpCallInfo,
            &lpCallInfo->dwRedirectingIDNameSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.RedirectingIDName"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulDisplaySize,
            lpCallInfo,
            &lpCallInfo->dwDisplaySize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.Display"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulUserUserInfoSize,
            lpCallInfo,
            &lpCallInfo->dwUserUserInfoSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.UserUserInfo"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulHighLevelCompSize,
            lpCallInfo,
            &lpCallInfo->dwHighLevelCompSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.HighLevelComp"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulLowLevelCompSize,
            lpCallInfo,
            &lpCallInfo->dwLowLevelCompSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.LowLevelComp"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulChargingInfoSize,
            lpCallInfo,
            &lpCallInfo->dwChargingInfoSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.ChargingInfo"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulTerminalModesSize,
            lpCallInfo,
            &lpCallInfo->dwTerminalModesSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.TerminalModes"
            );

        INSERTVARDATA(
            pInfo,
            &pInfo->ulDevSpecificSize,
            lpCallInfo,
            &lpCallInfo->dwDevSpecificSize,
            sizeof(LINE_CALL_INFO),
            "LINE_CALL_INFO.DevSpecific"
            );

        // make sure that dwNeededSize == dwUsedSize
        lpCallInfo->dwNeededSize = lpCallInfo->dwUsedSize;

        //
        // we now have the called address, look up the 
        // proper associated media mode in TAPI's table
        //
        if (lpCallInfo->dwCalledIDFlags & LINECALLPARTYID_UNAVAIL)
        {
            TspLog(DL_INFO, 
                   "lineGetCallInfo: dwCalledIDFlags contained "\
                   "LINECALLPARTYID_UNAVAIL");

            goto get_call_info_end;
        }
        if (lpCallInfo->dwCalledIDSize == 0)
        {
            TspLog(DL_INFO, "lineGetCallInfo: dwCalledIDSize was 0");

            goto get_call_info_end;
        }

        // we've got a called address that we need to look up.
        // we have to copy it and make it null-terminated.
        pwszCalledAddress = (PWSTR)MALLOC(lpCallInfo->dwCalledIDSize +
                                          sizeof(UNICODE_NULL));
        if (NULL == pwszCalledAddress)
        {
            TspLog(DL_ERROR, 
                   "lineGetCallInfo: failed to alloc mem for called address");

            lRes = LINEERR_NOMEM;
            goto get_call_info_end;
        }

        CopyMemory((PUCHAR)pwszCalledAddress,
                   (((PUCHAR)lpCallInfo) + lpCallInfo->dwCalledIDOffset),
                   lpCallInfo->dwCalledIDSize);

        *((PWSTR)(((PUCHAR)pwszCalledAddress) + lpCallInfo->dwCalledIDSize))
            = UNICODE_NULL;

        lRes = GetMediaModeForAddress(pwszCalledAddress,
                                      &dwAlteredMediaModes);

        FREE(pwszCalledAddress);
        pwszCalledAddress = NULL;

        if (lRes != TAPI_SUCCESS)
        {
            goto get_call_info_end;
        }

        if (dwAlteredMediaModes == LINEMEDIAMODE_UNKNOWN)
        {
            TspLog(DL_INFO, "lineGetCallInfo: got unknown media mode");

            goto get_call_info_end;
        }

        TspLog(DL_INFO, "lineGetCallInfo: got media mode(%x)", 
               dwAlteredMediaModes);

        lpCallInfo->dwMediaMode = dwAlteredMediaModes;
    }

get_call_info_end:
    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PLINE_CALL_STATUS           pStatus;
    PNDIS_TAPI_GET_CALL_STATUS  pNdisTapiGetCallStatus;

    TspLog(DL_TRACE, "lineGetCallStatus(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_CALL_STATUS,              // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_GET_CALL_STATUS) +    // size of req data
             (lpCallStatus->dwTotalSize - sizeof(LINE_CALL_STATUS)),
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiGetCallStatus = (PNDIS_TAPI_GET_CALL_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetCallStatus->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    pStatus = &pNdisTapiGetCallStatus->LineCallStatus;

    pStatus->ulTotalSize = lpCallStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_CALL_STATUS);
    
    ZeroMemory(&pStatus->ulCallState, 
               sizeof(LINE_CALL_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);

        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // (no embedded ascii strings to convert to unicode)
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields. (There are no embedded ascii strings to
    // convert to unicode, so no extra space needed for that.)
    //

    lpCallStatus->dwNeededSize =
        pStatus->ulNeededSize +
        (sizeof(LINECALLSTATUS) -      // v2.0 struct
            sizeof(LINE_CALL_STATUS)); // v1.0 struct

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwLineDeviceID to dwCallCompletionModes
    //

    CopyMemory(
        &lpCallStatus->dwCallState,
        &pStatus->ulCallState,
        4 * sizeof(DWORD)
        );

    if (lpCallStatus->dwNeededSize > lpCallStatus->dwTotalSize)
    {
        lpCallStatus->dwUsedSize =
            (lpCallStatus->dwTotalSize < sizeof(LINECALLSTATUS) ?
            lpCallStatus->dwTotalSize : sizeof(LINECALLSTATUS));
    }
    else
    {
        lpCallStatus->dwUsedSize = sizeof(LINECALLSTATUS);
                                                        // v2.0 struct
        INSERTVARDATA(
            pStatus,
            &pStatus->ulDevSpecificSize,
            lpCallStatus,
            &lpCallStatus->dwDevSpecificSize,
            sizeof(LINE_CALL_STATUS),
            "LINE_CALL_STATUS.DevSpecific"
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LINEDEVCAPS *
GetLineDevCaps(
    IN DWORD    dwDeviceID,
    IN DWORD    dwExtVersion
    )
{
    LONG                    lRes;
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PLINE_DEV_CAPS          pCaps;
    PNDIS_TAPI_GET_DEV_CAPS pNdisTapiGetDevCaps;
    DWORD                   dwNeededSize;
    LINEDEVCAPS            *pLineDevCaps;
    DWORD                   dwTotalSize = sizeof(LINEDEVCAPS) + 0x80;

get_caps:
    pLineDevCaps = (LINEDEVCAPS *)MALLOC(dwTotalSize);
    if (NULL == pLineDevCaps)
    {
        TspLog(DL_ERROR, "GetLineDevCaps: failed to alloc mem of size(%x)",
               dwTotalSize);
        return NULL;
    }

    pLineDevCaps->dwTotalSize = dwTotalSize;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_DEV_CAPS,             // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_DEV_CAPS) +   // size of req data
             (dwTotalSize - sizeof(LINE_DEV_CAPS)),
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return NULL;
    }

    pNdisTapiGetDevCaps = (PNDIS_TAPI_GET_DEV_CAPS)pNdisTapiRequest->Data;

    pNdisTapiGetDevCaps->ulDeviceID = dwDeviceID;
    pNdisTapiGetDevCaps->ulExtVersion = dwExtVersion;

    pCaps = &pNdisTapiGetDevCaps->LineDevCaps;

    pCaps->ulTotalSize = dwTotalSize;
    pCaps->ulNeededSize = pCaps->ulUsedSize = sizeof(LINE_DEV_CAPS);

    ZeroMemory(&pCaps->ulProviderInfoSize,
               sizeof(LINE_DEV_CAPS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return NULL;
    }

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields, plus the size of the var data returned
    // by the driver to account for the ascii->unicode conversion.
    // @@@ Granted, we are very liberal in computing the value for
    // this last part, but at least this way it's fast & we'll
    // never have too little buffer space.
    //
    TspLog(DL_TRACE,
           "GetLineDevCaps: ulNeeded(%x), LINEDEVCAPS(%x), LINE_DEV_CAPS(%x)",
           pCaps->ulNeededSize, sizeof(LINEDEVCAPS), sizeof(LINE_DEV_CAPS));

    dwNeededSize = 
        pCaps->ulNeededSize +
        (sizeof(LINEDEVCAPS) -         // v2.0 struct
            sizeof(LINE_DEV_CAPS)) +   // v1.0 struct
        (pCaps->ulNeededSize - sizeof(LINE_DEV_CAPS));

    TspLog(DL_TRACE, "GetLineDevCaps: dwNeededSize(%x), dwTotalSize(%x)",
           dwNeededSize, dwTotalSize);

    if (dwNeededSize > dwTotalSize)
    {
        // free up the old req
        FreeRequest(pNdisTapiRequest);

        // free the old buffer
        FREE(pLineDevCaps);

        // try again with a larger buffer
        dwTotalSize = dwNeededSize;
        goto get_caps;
    }

    ASSERT(dwNeededSize <= dwTotalSize);

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwPermanentLineID to dwNumTerminals
    //
    CopyMemory(
        &pLineDevCaps->dwPermanentLineID,
        &pCaps->ulPermanentLineID,
        sizeof(LINE_DEV_CAPS) - (7 * sizeof(DWORD))
        );

    // @@@ not sure if this is the right place to do this
    pLineDevCaps->dwDevCapFlags |= LINEDEVCAPFLAGS_MSP;

    // set the local flag to indicate that
    // the line can't be used from remote machine
    pLineDevCaps->dwDevCapFlags |= LINEDEVCAPFLAGS_LOCAL;

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // 2. Convert ascii strings to unicode, & rebase all var data
    //

    pLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS); // v2.0 struct

    INSERTVARDATA(
        pCaps,
        &pCaps->ulDeviceClassesSize,
        pLineDevCaps,
        &pLineDevCaps->dwDeviceClassesSize,
        sizeof (LINE_DEV_CAPS),
        "LINE_DEV_CAPS.DeviceClasses"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulProviderInfoSize,
        pLineDevCaps,
        &pLineDevCaps->dwProviderInfoSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.ProviderInfo"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulSwitchInfoSize,
        pLineDevCaps,
        &pLineDevCaps->dwSwitchInfoSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.SwitchInfo"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulLineNameSize,
        pLineDevCaps,
        &pLineDevCaps->dwLineNameSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.LineName"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulTerminalCapsSize,
        pLineDevCaps,
        &pLineDevCaps->dwTerminalCapsSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.TerminalCaps"
        );

    // @@@ convert DevCaps.TermText to unicode???

    pLineDevCaps->dwTerminalTextEntrySize =
        pCaps->ulTerminalTextEntrySize;

    INSERTVARDATA(
        pCaps,
        &pCaps->ulTerminalTextSize,
        pLineDevCaps,
        &pLineDevCaps->dwTerminalTextSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.TerminalText"
        );

    INSERTVARDATA(
        pCaps,
        &pCaps->ulDevSpecificSize,
        pLineDevCaps,
        &pLineDevCaps->dwDevSpecificSize,
        sizeof(LINE_DEV_CAPS),
        "LINE_DEV_CAPS.DevSpecific"
        );

    // make sure dwNeededSize == dwUsedSize
    pLineDevCaps->dwNeededSize = pLineDevCaps->dwUsedSize;

    FreeRequest(pNdisTapiRequest);
    return pLineDevCaps;
}

LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;

    TspLog(DL_TRACE, "lineGetDevCaps(%d): deviceID(%x), TSPIV(%x), ExtV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion, dwExtVersion);

    lRes = GetDevCaps(dwDeviceID, dwTSPIVersion, dwExtVersion, lpLineDevCaps);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD       dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR     lpszDeviceClass
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwLength = lstrlenW (lpszDeviceClass) + 1;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PVAR_STRING                 pConfig;
    PNDIS_TAPI_GET_DEV_CONFIG   pNdisTapiGetDevConfig;

    TspLog(DL_TRACE, "lineGetDevConfig(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_DEV_CONFIG,           // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_DEV_CONFIG) + // size of req data
             (lpDeviceConfig->dwTotalSize - sizeof(VAR_STRING)) + dwLength,
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetDevConfig = (PNDIS_TAPI_GET_DEV_CONFIG)pNdisTapiRequest->Data;

    pNdisTapiGetDevConfig->ulDeviceID = dwDeviceID;
    pNdisTapiGetDevConfig->ulDeviceClassSize = dwLength;
    pNdisTapiGetDevConfig->ulDeviceClassOffset =
        sizeof(NDIS_TAPI_GET_DEV_CONFIG) + 
        (lpDeviceConfig->dwTotalSize - sizeof(VAR_STRING));

    pConfig = &pNdisTapiGetDevConfig->DeviceConfig;
    pConfig->ulTotalSize = lpDeviceConfig->dwTotalSize;
    pConfig->ulNeededSize = pConfig->ulUsedSize = sizeof(VAR_STRING);

    pConfig->ulStringFormat = 
    pConfig->ulStringSize = 
    pConfig->ulStringOffset = 0;
    
    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(CP_ACP, 0, lpszDeviceClass, -1,
        (LPSTR) (((LPBYTE) pNdisTapiGetDevConfig) +
            pNdisTapiGetDevConfig->ulDeviceClassOffset),
        dwLength, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpDeviceConfig,
            &pNdisTapiGetDevConfig->DeviceConfig,
            pNdisTapiGetDevConfig->DeviceConfig.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_GET_EXTENSION_ID pNdisTapiGetExtensionID;

    TspLog(DL_TRACE, "lineGetExtensionID(%d): deviceID(%x), TSPIV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_EXTENSION_ID,             // opcode
             dwDeviceID,                            // device id
             sizeof(NDIS_TAPI_GET_EXTENSION_ID),    // size of req data
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiGetExtensionID =
        (PNDIS_TAPI_GET_EXTENSION_ID)pNdisTapiRequest->Data;

    pNdisTapiGetExtensionID->ulDeviceID = dwDeviceID;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpExtensionID,
            &pNdisTapiGetExtensionID->LineExtensionID,
            sizeof(LINE_EXTENSION_ID)
            );
    }
    else
    {
        //
        // Rather than indicating a failure, we'll just zero out the
        // ext id (implying driver doesn't support extensions) and
        // return success to tapisrv so it'll complete the open ok
        //
        ZeroMemory(lpExtensionID, sizeof(LINE_EXTENSION_ID));

        lRes = TAPI_SUCCESS;
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine = NULL;
    PDRVCALL            pCall = NULL;
    PNDISTAPI_REQUEST   pNdisTapiRequest;
    DWORD               dwLength = lstrlenW(lpszDeviceClass) + 1;
    DWORD               dwDeviceID;
    PUCHAR              pchDest;
    PVAR_STRING         pID;
    PNDIS_TAPI_GET_ID   pNdisTapiGetID;

    TspLog(DL_TRACE, 
           "lineGetID(%d): line(%p), call(%p), addressID(%x), select(%x)", 
           ++dwSum, hdLine, hdCall, dwAddressID, dwSelect);

    ASSERT(LINECALLSELECT_LINE == dwSelect ||
           LINECALLSELECT_ADDRESS == dwSelect ||
           LINECALLSELECT_CALL == dwSelect);

    if (LINECALLSELECT_LINE == dwSelect ||
        LINECALLSELECT_ADDRESS == dwSelect)
    {
        lRes = GetLineObjWithReadLock(hdLine, &pLine);
        if (    (lRes != TAPI_SUCCESS)
            ||  (NULL == pLine))
        {
            return lRes;
        }
    }

    if (LINECALLSELECT_CALL == dwSelect)
    {
        lRes = GetCallObjWithReadLock(hdCall, &pCall);
        if (lRes != TAPI_SUCCESS)
        {
            return lRes;
        }
    }

    //
    // Ndptsp will field this specific call on behalf of the
    // wan miniports.  It returns the guid and media string
    // of the adapter that this line lives on
    //
    if (LINECALLSELECT_LINE == dwSelect &&
        !wcscmp(lpszDeviceClass, L"LineGuid"))
    {
        lpDeviceID->dwNeededSize =
            sizeof(VARSTRING) + sizeof(GUID) +
            sizeof(pLine->MediaType) + sizeof('\0');

        if (lpDeviceID->dwTotalSize < lpDeviceID->dwNeededSize)
        {
            if (pCall != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdCall);
            }
            if (pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }
            return LINEERR_STRUCTURETOOSMALL;
        }

        lpDeviceID->dwUsedSize = lpDeviceID->dwNeededSize;
        lpDeviceID->dwStringFormat = STRINGFORMAT_ASCII;
        pchDest = (PUCHAR)lpDeviceID + sizeof(*lpDeviceID);
        lpDeviceID->dwStringOffset = (DWORD)(pchDest - (PUCHAR)lpDeviceID);
        lpDeviceID->dwStringSize =
            sizeof(GUID) + sizeof(pLine->MediaType) +sizeof('\0');

        if(NULL != pLine)
        {
            MoveMemory(
                pchDest,
                (PUCHAR)&pLine->Guid,
                sizeof(pLine->Guid)
                );

            pchDest += sizeof(pLine->Guid);

            MoveMemory(
                pchDest,
                &pLine->MediaType,
                sizeof(pLine->MediaType)
                );
            pchDest += sizeof(pLine->MediaType);
            *pchDest = '\0';

            TspLog(DL_INFO, "lineGetID: obj(%p)", hdLine);

            TspLog(
            DL_INFO,
            "Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
            pLine->Guid.Data1, pLine->Guid.Data2,
            pLine->Guid.Data3, pLine->Guid.Data4[0],
            pLine->Guid.Data4[1], pLine->Guid.Data4[2],
            pLine->Guid.Data4[3], pLine->Guid.Data4[4],
            pLine->Guid.Data4[5], pLine->Guid.Data4[6],
            pLine->Guid.Data4[7]
            );
            TspLog(DL_INFO, "MediaType: %d", pLine->MediaType);

        }            

        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return TAPI_SUCCESS;
    }
    else if (LINECALLSELECT_CALL == dwSelect)
    {
        lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);
        if (lpDeviceID->dwTotalSize < lpDeviceID->dwNeededSize) 
        {
            if (pCall != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdCall);
            }
            if (pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }

            return LINEERR_STRUCTURETOOSMALL;
        }
    }
    else
    {
        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return LINEERR_OPERATIONUNAVAIL;
    }

    dwDeviceID = (LINECALLSELECT_CALL == dwSelect) ? 
                      pCall->dwDeviceID : pLine->dwDeviceID;

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_ID,                   // opcode
             dwDeviceID,                        // device id
             sizeof(NDIS_TAPI_GET_ID) +         // size of req data
             (lpDeviceID->dwTotalSize - sizeof(VAR_STRING)) + 2 * dwLength + 4,
                                                // 4 for returned ID
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        if (pCall != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdCall);
        }
        if (pLine != NULL)
        {
            ReleaseObjReadLock((HANDLE)hdLine);
        }

        return lRes;
    }

    pNdisTapiGetID = (PNDIS_TAPI_GET_ID)pNdisTapiRequest->Data;

    if (LINECALLSELECT_LINE == dwSelect ||
        LINECALLSELECT_ADDRESS == dwSelect)
    {
        pNdisTapiGetID->hdLine = pLine->hd_Line;
    }

    pNdisTapiGetID->ulAddressID = dwAddressID;

    if (LINECALLSELECT_CALL == dwSelect)
    {
        pNdisTapiGetID->hdCall = GetNdisTapiHandle(pCall, &lRes);
        if(lRes != TAPI_SUCCESS)
        {
            if(pLine != NULL)
            {
                ReleaseObjReadLock((HANDLE)hdLine);
            }

            return lRes;
        }
    }

    pNdisTapiGetID->ulSelect = dwSelect;
    pNdisTapiGetID->ulDeviceClassSize = dwLength;
    pNdisTapiGetID->ulDeviceClassOffset = sizeof(NDIS_TAPI_GET_ID) +
        (lpDeviceID->dwTotalSize - sizeof(VAR_STRING));

    pID = &pNdisTapiGetID->DeviceID;

    pID->ulTotalSize = lpDeviceID->dwTotalSize;
    pID->ulNeededSize = pID->ulUsedSize = sizeof(VAR_STRING);
    pID->ulStringFormat = pID->ulStringSize = pID->ulStringOffset = 0;

    // we use wide strings in the proxy
    wcsncpy ((LPWSTR)(((LPBYTE)pNdisTapiGetID) + 
                      pNdisTapiGetID->ulDeviceClassOffset), 
             lpszDeviceClass, 
             dwLength);
    
    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (TAPI_SUCCESS == lRes)
    {
        CopyMemory(
            lpDeviceID,
            &pNdisTapiGetID->DeviceID,
            pNdisTapiGetID->DeviceID.ulUsedSize
            );
    }

    FreeRequest(pNdisTapiRequest);

    if (pCall != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
    }
    if (pLine != NULL)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PLINE_DEV_STATUS                pStatus;
    PNDIS_TAPI_GET_LINE_DEV_STATUS  pNdisTapiGetLineDevStatus;

    TspLog(DL_TRACE, "lineGetLineDevStatus(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_GET_LINE_DEV_STATUS,              // opcode
             pLine->dwDeviceID,                         // device id
             sizeof(NDIS_TAPI_GET_LINE_DEV_STATUS) +    // size of req data
             (lpLineDevStatus->dwTotalSize - sizeof(LINE_DEV_STATUS)),
             &pNdisTapiRequest                          // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiGetLineDevStatus =
        (PNDIS_TAPI_GET_LINE_DEV_STATUS)pNdisTapiRequest->Data;

    pNdisTapiGetLineDevStatus->hdLine = pLine->hd_Line;

    pStatus = &pNdisTapiGetLineDevStatus->LineDevStatus;

    pStatus->ulTotalSize = lpLineDevStatus->dwTotalSize;
    pStatus->ulNeededSize = pStatus->ulUsedSize = sizeof(LINE_DEV_STATUS);

    ZeroMemory(&pStatus->ulNumOpens,
               sizeof(LINE_DEV_STATUS) - 3 * sizeof(ULONG));

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    //
    // Do some post processing to the returned data structure
    // before passing it back to tapi:
    // 1. Pad the area between the fixed 1.0 structure and the
    //    var data that the miniports pass back with 0's so a
    //    bad app that disregards the 1.0 version negotiation &
    //    references new 1.4 or 2.0 structure fields won't blow up
    // (no embedded ascii strings to convert to unicode)
    //

    //
    // The real needed size is the sum of that requested by the
    // underlying driver, plus padding for the new TAPI 1.4/2.0
    // structure fields. (There are no embedded ascii strings to
    // convert to unicode, so no extra space needed for that.)
    //

    lpLineDevStatus->dwNeededSize =
        pStatus->ulNeededSize +
        (sizeof(LINEDEVSTATUS) -       // v2.0 struct
            sizeof(LINE_DEV_STATUS));  // v1.0 struct

    //
    // Copy over the fixed fields that don't need changing,
    // i.e. everything from dwNumActiveCalls to dwDevStatusFlags
    //

    CopyMemory(
        &lpLineDevStatus->dwNumActiveCalls,
        &pStatus->ulNumActiveCalls,
        sizeof(LINE_DEV_STATUS) - (9 * sizeof(DWORD))
        );

    if (lpLineDevStatus->dwNeededSize > lpLineDevStatus->dwTotalSize)
    {
        lpLineDevStatus->dwUsedSize =
            (lpLineDevStatus->dwTotalSize < sizeof(LINEDEVSTATUS) ?
            lpLineDevStatus->dwTotalSize : sizeof(LINEDEVSTATUS));
    }
    else
    {
        lpLineDevStatus->dwUsedSize = sizeof(LINEDEVSTATUS);
                                                        // v2.0 struct
        INSERTVARDATA(
            pStatus,
            &pStatus->ulTerminalModesSize,
            lpLineDevStatus,
            &lpLineDevStatus->dwTerminalModesSize,
            sizeof(LINE_DEV_STATUS),
            "LINE_DEV_STATUS.TerminalModes"
            );

        INSERTVARDATA(
            pStatus,
            &pStatus->ulDevSpecificSize,
            lpLineDevStatus,
            &lpLineDevStatus->dwDevSpecificSize,
            sizeof(LINE_DEV_STATUS),
            "LINE_DEV_STATUS.DevSpecific"
            );
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    PDRVLINE        pLine;

    TspLog(DL_TRACE, "lineGetNumAddressIDs(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    lRes = GetNumAddressIDs(pLine->dwDeviceID, lpdwNumAddressIDs);

    if (TAPI_SUCCESS == lRes)
    {
        TspLog(DL_INFO, "lineGetNumAddressIDs: numAddressIDs(%x)",
               *lpdwNumAddressIDs);
    }

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
PASCAL
TSPI_lineMakeCall_postProcess(
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper,
    LONG                    lRes,
    PDWORD_PTR              callStateMsgParams
    )
{
    LONG        lSuc;
    HDRVLINE    hdLine;
    PDRVLINE    pLine;
    HDRVCALL    hdCall;
    PDRVCALL    pCall;

    TspLog(DL_TRACE, "lineMakeCall_post: lRes(%x)", lRes);

    hdCall = (HDRVCALL)(pAsyncReqWrapper->dwRequestSpecific);

    lSuc = GetLineHandleFromCallHandle(hdCall, &hdLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetLineObjWithReadLock(hdLine, &pLine);
    if (lSuc != TAPI_SUCCESS)
    {
        return lSuc;
    }

    lSuc = GetCallObjWithWriteLock(hdCall, &pCall);
    if (lSuc != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lSuc;
    }

    if (TAPI_SUCCESS == lRes)
    {
        PNDIS_TAPI_MAKE_CALL    pNdisTapiMakeCall = (PNDIS_TAPI_MAKE_CALL)
            pAsyncReqWrapper->NdisTapiRequest.Data;
          
        // check to see if a call state msg was received before we had
        // the chance to process the completion notification, & if so
        // fill in the msg params
        if (pCall->dwPendingCallState)
        {
            callStateMsgParams[0] = (DWORD_PTR)pLine->htLine;
            callStateMsgParams[1] = (DWORD_PTR)pCall->htCall;
            callStateMsgParams[2] = pCall->dwPendingCallState;
            callStateMsgParams[3] = pCall->dwPendingCallStateMode;
            callStateMsgParams[4] = pCall->dwPendingMediaMode;
        }
        pCall->hd_Call = pNdisTapiMakeCall->hdCall;
        pCall->bIncomplete = FALSE;

        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);
    }
    else
    {
        pCall->dwKey = INVALID_KEY;

        ReleaseObjWriteLock((HANDLE)hdCall);
        ReleaseObjReadLock((HANDLE)hdLine);

        CloseObjHandle((HANDLE)hdCall);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes; 
    PDRVLINE                pLine;
    PDRVCALL                pCall;
    HDRVCALL                hdCall;
    DWORD                   dwDALength, dwCPLength;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_MAKE_CALL    pNdisTapiMakeCall;

    TspLog(DL_TRACE, "lineMakeCall(%d): reqID(%x), line(%p)", 
           ++dwSum, dwRequestID, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    // alloc & init a DRVCALL
    if (!(pCall = AllocCallObj(sizeof(DRVCALL))))
    {
        TspLog(DL_ERROR, "lineMakeCall: failed to create call obj");
        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_NOMEM;
    }
    pCall->dwKey       = OUTBOUND_CALL_KEY;
    pCall->dwDeviceID  = pLine->dwDeviceID;
    pCall->htCall      = htCall;
    pCall->hdLine      = hdLine;
    pCall->bIncomplete = TRUE;

    // init the request
    dwDALength = (lpszDestAddress ? (lstrlenW (lpszDestAddress) + 1) : 0);
    dwCPLength = (lpCallParams ? 
                  (lpCallParams->dwTotalSize - sizeof(LINE_CALL_PARAMS)) : 0);

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_MAKE_CALL,            // opcode
             pLine->dwDeviceID,             // device id
             dwRequestID,                   // request id
             sizeof(NDIS_TAPI_MAKE_CALL) +
             2 * dwDALength + dwCPLength +
             sizeof(PVOID),                 // size
             &pAsyncReqWrapper              // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        FreeCallObj(pCall);
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiMakeCall = (PNDIS_TAPI_MAKE_CALL)
        pAsyncReqWrapper->NdisTapiRequest.Data;

    // make sure releasing read lock before calling OpenObjHandle()
    // to avoid deadlock on acquiring write lock for the global mapper
    ReleaseObjReadLock((HANDLE)hdLine);

    lRes = OpenObjHandle(pCall, FreeCallObj, (HANDLE *)&hdCall);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, 
               "lineMakeCall: failed to map obj(%p) to handle",
               pCall);

        FreeRequest(pAsyncReqWrapper);
        FreeCallObj(pCall);
        return lRes;
    }

    // reacquire the read lock
    lRes = AcquireObjReadLock((HANDLE)hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR,
               "lineMakeCall: failed to reacquire read lock for obj(%p)",
               hdLine);

        FreeRequest(pAsyncReqWrapper);
        CloseObjHandle((HANDLE)hdCall);
        return lRes;
    }

    // save the TSP handle
    pCall->hdCall = hdCall;

    pNdisTapiMakeCall->hdLine = pLine->hd_Line;
    pNdisTapiMakeCall->htCall = (HTAPI_CALL)hdCall;
    pNdisTapiMakeCall->ulDestAddressSize = dwDALength;

    if (lpszDestAddress)
    {
        UCHAR   *pDest;

        // end of pNdisTapiMakeCall
        pDest = (UCHAR *)(pNdisTapiMakeCall + 1);

        // add room for lpCallParams
        (ULONG_PTR)pDest += dwCPLength;

        // align
        (ULONG_PTR)pDest += sizeof(PVOID);
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        pNdisTapiMakeCall->ulDestAddressOffset =
            (ULONG)(pDest - (UCHAR*)pNdisTapiMakeCall);

        // use wide strings in NDPROXY
        wcsncpy ((LPWSTR)pDest, lpszDestAddress, dwDALength);
    }
    else
    {
        pNdisTapiMakeCall->ulDestAddressOffset = 0;
    }

    if (lpCallParams)
    {
        pNdisTapiMakeCall->bUseDefaultLineCallParams = FALSE;

        CopyMemory(
            &pNdisTapiMakeCall->LineCallParams,
            lpCallParams,
            lpCallParams->dwTotalSize
            );

        if (lpCallParams->dwOrigAddressSize != 0)
        {
            WideCharToMultiByte(
                CP_ACP,
                0,
                (LPCWSTR) (((LPBYTE) lpCallParams) +
                    lpCallParams->dwOrigAddressOffset),
                lpCallParams->dwOrigAddressSize / sizeof(WCHAR),
                (LPSTR) (((LPBYTE) &pNdisTapiMakeCall->LineCallParams) +
                    lpCallParams->dwOrigAddressOffset),
                lpCallParams->dwOrigAddressSize,
                NULL,
                NULL
                );

            pNdisTapiMakeCall->LineCallParams.ulOrigAddressSize /= 2;
        }
    }
    else
    {
        pNdisTapiMakeCall->bUseDefaultLineCallParams = TRUE;
    }

    pAsyncReqWrapper->dwRequestSpecific = (DWORD_PTR)hdCall;
    pAsyncReqWrapper->pfnPostProcess = TSPI_lineMakeCall_postProcess;

    *lphdCall = hdCall;

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL    hdCall,
    DWORD       dwDigitModes
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_MONITOR_DIGITS   pNdisTapiMonitorDigits;
    
    TspLog(DL_TRACE, "lineMonitorDigits(%d): call(%p), DigitModes(%x)", 
           ++dwSum, hdCall, dwDigitModes);
    
    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_MONITOR_DIGITS,           // opcode
             pCall->dwDeviceID,                 // device ID
             sizeof(NDIS_TAPI_MONITOR_DIGITS),  // size of req data
             &pNdisTapiRequest                  // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiMonitorDigits = (PNDIS_TAPI_MONITOR_DIGITS)pNdisTapiRequest->Data;
    
    // set up the parameters in our structure.
    pNdisTapiMonitorDigits->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    
    pNdisTapiMonitorDigits->ulDigitModes = dwDigitModes;
            
    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

//
// Routine Description:
//
// Identifies the MSP to use for a particular line device. In our case,
// this is always the RCA MSP for all devices that support audio.
//
// Arguments:
// dwDeviceID - The line device whose MSP identifier is being requested
// pCLSID     - Pointer to location at which to store the MSP CLSID
//
// Return value:
// For devices that support TAPIMEDIAMODE_AUDIO, returns NOERROR, otherwise
// LINEERR_OPERATIONUNAVAIL.
//
LONG
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD   dwDeviceID,
    GUID   *pCLSID
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;
    LINEDEVCAPS     DevCaps;

    TspLog(DL_TRACE, "lineMSPIdentify(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    //
    // ugly, but we have to do it. We need to get the dev caps so we can see 
    // if the line supports audio. If it does, then we return the CLSID of 
    // the RCA MSP, otherwise return a null GUID 
    // (@@@ check if a null guid is the right thing to return)
    //      

    ZeroMemory(&DevCaps, sizeof(LINEDEVCAPS));

    DevCaps.dwTotalSize = sizeof(LINEDEVCAPS);
    
    if ((lRes = TSPI_lineGetDevCaps(dwDeviceID, 0, 0, &DevCaps)) 
        == TAPI_SUCCESS) {
        //
        // NOTE: LINEMEDIAMODE_AUTOMATEDVOICE == TAPIMEDIAMODE_AUDIO
        //
        if (DevCaps.dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) {
            //
            // The RCA MSP handles all lines that support AUDIO, 
            // so send this there. 
            //
            *pCLSID = CLSID_RCAMSP;
        }
    } 

    return lRes;
}

LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwTSPIVersion,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwExtVersion
    )
{
    static DWORD                        dwSum = 0;
    LONG                                lRes;
    PNDISTAPI_REQUEST                   pNdisTapiRequest;
    PNDIS_TAPI_NEGOTIATE_EXT_VERSION    pNdisTapiNegotiateExtVersion;

    TspLog(DL_TRACE, 
           "lineNegotiateExtVersion(%d): deviceID(%x), TSPIV(%x), "\
           "LowV(%x), HighV(%x)", 
           ++dwSum, dwDeviceID, dwTSPIVersion, dwLowVersion, dwHighVersion);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_NEGOTIATE_EXT_VERSION,            // opcode
             dwDeviceID,                                // device id
             sizeof(NDIS_TAPI_NEGOTIATE_EXT_VERSION),   // size of req data
             &pNdisTapiRequest                          // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiNegotiateExtVersion =
        (PNDIS_TAPI_NEGOTIATE_EXT_VERSION)pNdisTapiRequest->Data;
    
    pNdisTapiNegotiateExtVersion->ulDeviceID = dwDeviceID;
    pNdisTapiNegotiateExtVersion->ulLowVersion = dwLowVersion;
    pNdisTapiNegotiateExtVersion->ulHighVersion = dwHighVersion;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);

    if (TAPI_SUCCESS == lRes)
    {
        *lpdwExtVersion = pNdisTapiNegotiateExtVersion->ulExtVersion;

        // save version for future verification
        lRes = SetNegotiatedExtVersion(dwDeviceID, *lpdwExtVersion);
    }
    else
    {
        TspLog(DL_WARNING, "lineNegotiateExtVersion: syncRequest returned(%x)", 
               lRes);
    }

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    static DWORD    dwSum = 0;
    LONG            lRes;

    TspLog(DL_TRACE, "lineNegotiateTSPIVersion(%d): deviceID(%x)", 
           ++dwSum, dwDeviceID);

    *lpdwTSPIVersion = 0x00030000;

    // save version for future verification
    lRes = SetNegotiatedTSPIVersion(dwDeviceID, 0x00030000);

    if (TAPI_SUCCESS == lRes)
    {
        TspLog(DL_INFO, "lineNegotiateTSPIVersion: TSPIVersion(%x)",
               *lpdwTSPIVersion);
    }

    return lRes;
}

LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVLINE                pLine;
    HDRVLINE                hdLine;
    PNDISTAPI_REQUEST       pNdisTapiRequest;
    PNDIS_TAPI_OPEN         pNdisTapiOpen;
    GUID                    Guid;
    NDIS_WAN_MEDIUM_SUBTYPE MediaType;
    PNDISTAPI_OPENDATA      OpenData;

    
    TspLog(DL_TRACE, "lineOpen(%d): deviceID(%x), htLine(%p)", 
           ++dwSum, dwDeviceID, htLine);

    // alloc & init a DRVLINE
    if (!(pLine = AllocLineObj(sizeof(DRVLINE))))
    {
        TspLog(DL_ERROR, "lineOpen: failed to create line obj");
        return LINEERR_NOMEM;
    }
    pLine->dwKey = LINE_KEY;
    pLine->dwDeviceID = dwDeviceID;
    pLine->htLine = htLine;

    pLine->hMSPMutex = CreateMutex(NULL, FALSE, "MSPMutex");
    if (NULL == pLine->hMSPMutex)
    {
        TspLog(DL_ERROR, "lineOpen: failed to create mutex");
        FreeLineObj(pLine);
        return LINEERR_NOMEM;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_OPEN,             // opcode
             dwDeviceID,                // device id
             sizeof(NDIS_TAPI_OPEN) + 
             sizeof(NDISTAPI_OPENDATA), // size
             &pNdisTapiRequest          // ptr to ptr to request buffer
         )) != TAPI_SUCCESS)
    {
        CloseHandle(pLine->hMSPMutex);
        FreeLineObj(pLine);
        return lRes;
    }

    pNdisTapiOpen = (PNDIS_TAPI_OPEN)pNdisTapiRequest->Data;

    pNdisTapiOpen->ulDeviceID = dwDeviceID;

    lRes = OpenObjHandle(pLine, FreeLineObj, (HANDLE *)&hdLine);
    if (lRes != TAPI_SUCCESS)
    {
        TspLog(DL_ERROR, "lineOpen: failed to map obj(%p) to handle", pLine);
        CloseHandle(pLine->hMSPMutex);
        FreeLineObj(pLine);
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    pNdisTapiOpen->htLine = (HTAPI_LINE)hdLine;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_QUERY_INFO, pNdisTapiRequest);
    if (lRes != TAPI_SUCCESS)
    {
        CloseHandle(pLine->hMSPMutex);
        CloseObjHandle((HANDLE)hdLine);
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }

    OpenData = (PNDISTAPI_OPENDATA)
                    ((PUCHAR)pNdisTapiOpen + sizeof(NDIS_TAPI_OPEN));

    MoveMemory(&pLine->Guid,&OpenData->Guid, sizeof(pLine->Guid));
    pLine->MediaType = OpenData->MediaType;

    TspLog(DL_INFO, "lineOpen: obj(%p)", hdLine);
    TspLog(
        DL_INFO,
        "Guid: %4.4x-%4.4x-%2.2x%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
        pLine->Guid.Data1, pLine->Guid.Data2,
        pLine->Guid.Data3, pLine->Guid.Data4[0],
        pLine->Guid.Data4[1], pLine->Guid.Data4[2],
        pLine->Guid.Data4[3], pLine->Guid.Data4[4],
        pLine->Guid.Data4[5], pLine->Guid.Data4[6],
        pLine->Guid.Data4[7]
        );

    TspLog(DL_INFO, "MediaType(%ld)", pLine->MediaType);

    pLine->hd_Line = pNdisTapiOpen->hdLine;
    *lphdLine = hdLine;

    lRes = CommitNegotiatedTSPIVersion(dwDeviceID);

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

//
// Routine Description:
//
// Called when an MSP wants to send us data. Right now we have not
// defined any TSP / MSP communication, so this function does nothing.
//
// Arguments:
// hdLine   -   Handle to line device
// hdCall   -   Handle for call
// hdMSPLine -  MSP handle for the call
// pBuffer  -   Pointer to buffer containing MSP data
// dwSize   -   Size of MSP data buffer
//
// Return value:
// LINEERR_OPERATIONFAILED  - if data size is too small
// LINEERR_OPERATIONUNAVAIL - if the message contains an unrecognized command
// NOERROR                  - if everything went OK
//
LONG
TSPIAPI
TSPI_lineReceiveMSPData(
    HDRVLINE    hdLine,
    HDRVCALL    hdCall,
    HDRVMSPLINE hdMSPLine,
    LPVOID      pBuffer,
    DWORD       dwSize
    )
{
    static DWORD        dwSum = 0;
    LONG                lRes;
    PDRVLINE            pLine;
    DWORD               dwMsg;
    DWORD               dwStatus;

    TspLog(DL_TRACE, "lineReceiveMSPData(%d): line(%p), call(%p), MSPline(%p)",
           ++dwSum, hdLine, hdCall, hdMSPLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if (dwSize < sizeof(DWORD))
    {
        TspLog(DL_ERROR, 
               "lineReceiveMSPData: data buf smaller than dword size");

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    dwMsg = *((DWORD *)pBuffer);

    if (dwMsg != 0)
    {
        TspLog(DL_ERROR, "lineReceiveMSPData: unrecognized msg(%x)", dwMsg);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONUNAVAIL;
    }

    //
    // have to call StartMSPStream with the MSP mutex held
    //
    if ((dwStatus = WaitForSingleObject(pLine->hMSPMutex, INFINITE))
        != WAIT_OBJECT_0)
    {
        TspLog(DL_ERROR, "lineReceiveMSPData: MSP mutex wait failed(%x)",
               dwStatus);

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    StartMSPStream(hdLine, hdCall);

    if (!ReleaseMutex(pLine->hMSPMutex))
    {
        TspLog(DL_ERROR, "lineReceiveMSPData: MSP mutex release failed");

        ReleaseObjReadLock((HANDLE)hdLine);
        return LINEERR_OPERATIONFAILED;
    }

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall
    )
{
    static DWORD            dwSum = 0;
    LONG                    lRes;
    PDRVCALL                pCall;
    PASYNC_REQUEST_WRAPPER  pAsyncReqWrapper;
    PNDIS_TAPI_SECURE_CALL  pNdisTapiSecureCall;

    TspLog(DL_TRACE, "lineSecureCall(%d): reqID(%x), call(%p)", 
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SECURE_CALL,          // opcode
             pCall->dwDeviceID,             // device id
             dwRequestID,                   // req id
             sizeof(NDIS_TAPI_SECURE_CALL), // size
             &pAsyncReqWrapper              // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSecureCall =
        (PNDIS_TAPI_SECURE_CALL)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSecureCall->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE    hdLine,
    DWORD       dwExtVersion
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_SELECT_EXT_VERSION   pNdisTapiSelectExtVersion;

    TspLog(DL_TRACE, "lineSelectExtVersion(%d): line(%p), ExtV(%x)", 
           ++dwSum, hdLine, dwExtVersion);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SELECT_EXT_VERSION,           // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SELECT_EXT_VERSION),  // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSelectExtVersion =
        (PNDIS_TAPI_SELECT_EXT_VERSION)pNdisTapiRequest->Data;

    pNdisTapiSelectExtVersion->hdLine = pLine->hd_Line;
    pNdisTapiSelectExtVersion->ulExtVersion = dwExtVersion;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);
    
    if (TAPI_SUCCESS == lRes)
    {
        lRes = SetSelectedExtVersion(pLine->dwDeviceID, dwExtVersion);
    }

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVCALL                        pCall;
    PASYNC_REQUEST_WRAPPER          pAsyncReqWrapper;
    PNDIS_TAPI_SEND_USER_USER_INFO  pNdisTapiSendUserUserInfo;

    TspLog(DL_TRACE, "lineSendUserUserInfo(%d): reqID(%x), call(%p)",
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SEND_USER_USER_INFO,      // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_SEND_USER_USER_INFO) + dwSize,
             &pAsyncReqWrapper              // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSendUserUserInfo = (PNDIS_TAPI_SEND_USER_USER_INFO)
                                   pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSendUserUserInfo->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    if (pNdisTapiSendUserUserInfo->ulUserUserInfoSize = dwSize)
    {
        CopyMemory(
            pNdisTapiSendUserUserInfo->UserUserInfo,
            lpsUserUserInfo,
            dwSize
            );
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL    hdCall,
    DWORD       dwAppSpecific
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_APP_SPECIFIC pNdisTapiSetAppSpecific;

    TspLog(DL_TRACE, "lineSetAppSpecific(%d): call(%p)", ++dwSum, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_APP_SPECIFIC,             // opcode
             pCall->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_APP_SPECIFIC),    // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetAppSpecific =
        (PNDIS_TAPI_SET_APP_SPECIFIC)pNdisTapiRequest->Data;

    pNdisTapiSetAppSpecific->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    pNdisTapiSetAppSpecific->ulAppSpecific = dwAppSpecific;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PASYNC_REQUEST_WRAPPER      pAsyncReqWrapper;
    PNDIS_TAPI_SET_CALL_PARAMS  pNdisTapiSetCallParams;

    TspLog(DL_TRACE, "lineSetCallParams(%d): reqID(%x), call(%p)",
           ++dwSum, dwRequestID, hdCall);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareAsyncRequest(
             OID_TAPI_SET_CALL_PARAMS,          // opcode
             pCall->dwDeviceID,                 // device id
             dwRequestID,                       // request id
             sizeof(NDIS_TAPI_SET_CALL_PARAMS), // size
             &pAsyncReqWrapper                  // ptr to ptr to request buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetCallParams =
        (PNDIS_TAPI_SET_CALL_PARAMS)pAsyncReqWrapper->NdisTapiRequest.Data;

    pNdisTapiSetCallParams->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pAsyncReqWrapper);
        return lRes;
    }
    
    pNdisTapiSetCallParams->ulBearerMode = dwBearerMode;
    pNdisTapiSetCallParams->ulMinRate = dwMinRate;
    pNdisTapiSetCallParams->ulMaxRate = dwMaxRate;

    if (lpDialParams)
    {
        pNdisTapiSetCallParams->bSetLineDialParams = TRUE;
        CopyMemory(
            &pNdisTapiSetCallParams->LineDialParams,
            lpDialParams,
            sizeof(LINE_DIAL_PARAMS)
            );
    }
    else
    {
        pNdisTapiSetCallParams->bSetLineDialParams = FALSE;
    }

    lRes = AsyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pAsyncReqWrapper);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    static DWORD                            dwSum = 0;
    LONG                                    lRes;
    PDRVLINE                                pLine;
    PNDISTAPI_REQUEST                       pNdisTapiRequest;
    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION  pNdisTapiSetDefaultMediaDetection;

    TspLog(DL_TRACE, "lineSetDefaultMediaDetection(%d): line(%p), mode(%x)", 
           ++dwSum, hdLine, dwMediaModes);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_DEFAULT_MEDIA_DETECTION,  // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION), // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSetDefaultMediaDetection =
        (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) pNdisTapiRequest->Data;

    pNdisTapiSetDefaultMediaDetection->hdLine = pLine->hd_Line;
    pNdisTapiSetDefaultMediaDetection->ulMediaModes = dwMediaModes;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    DWORD                       dwLength = lstrlenW(lpszDeviceClass) + 1;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_DEV_CONFIG   pNdisTapiSetDevConfig;

    TspLog(DL_TRACE, "lineSetDevConfig(%d): deviceID(%x)", ++dwSum, dwDeviceID);

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_DEV_CONFIG,       // opcode
             dwDeviceID,                    // device id
             sizeof(NDIS_TAPI_SET_DEV_CONFIG) + dwLength + dwSize,
             &pNdisTapiRequest              // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        return lRes;
    }

    pNdisTapiSetDevConfig = (PNDIS_TAPI_SET_DEV_CONFIG)pNdisTapiRequest->Data;

    pNdisTapiSetDevConfig->ulDeviceID = dwDeviceID;
    pNdisTapiSetDevConfig->ulDeviceClassSize = dwLength;
    pNdisTapiSetDevConfig->ulDeviceClassOffset =
        sizeof(NDIS_TAPI_SET_DEV_CONFIG) + dwSize - 1;
    pNdisTapiSetDevConfig->ulDeviceConfigSize = dwSize;

    CopyMemory(
        pNdisTapiSetDevConfig->DeviceConfig,
        lpDeviceConfig,
        dwSize
        );

    // NOTE: old miniports expect strings to be ascii
    WideCharToMultiByte(CP_ACP, 0, lpszDeviceClass, -1,
        (LPSTR) (((LPBYTE) pNdisTapiSetDevConfig) +
            pNdisTapiSetDevConfig->ulDeviceClassOffset),
        dwLength, NULL, NULL);

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
    )
{
    static DWORD                dwSum = 0;
    LONG                        lRes;
    PDRVCALL                    pCall;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PNDIS_TAPI_SET_MEDIA_MODE   pNdisTapiSetMediaMode;

    TspLog(DL_TRACE, "lineSetMediaMode(%d): call(%p), mode(%x)", 
           ++dwSum, hdCall, dwMediaMode);

    lRes = GetCallObjWithReadLock(hdCall, &pCall);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
            OID_TAPI_SET_MEDIA_MODE,            // opcode
            pCall->dwDeviceID,                  // device id
            sizeof(NDIS_TAPI_SET_MEDIA_MODE),   // size
            &pNdisTapiRequest                   // ptr to ptr to req buf
        )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdCall);
        return lRes;
    }

    pNdisTapiSetMediaMode = (PNDIS_TAPI_SET_MEDIA_MODE)pNdisTapiRequest->Data;

    pNdisTapiSetMediaMode->hdCall = GetNdisTapiHandle(pCall, &lRes);
    if(lRes != TAPI_SUCCESS)
    {
        FreeRequest(pNdisTapiRequest);
        return lRes;
    }
    
    pNdisTapiSetMediaMode->ulMediaMode = dwMediaMode;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdCall);
    return lRes;
}

LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE    hdLine,
    DWORD       dwLineStates,
    DWORD       dwAddressStates
    )
{
    static DWORD                    dwSum = 0;
    LONG                            lRes;
    PDRVLINE                        pLine;
    PNDISTAPI_REQUEST               pNdisTapiRequest;
    PNDIS_TAPI_SET_STATUS_MESSAGES  pNdisTapiSetStatusMessages;

    TspLog(DL_TRACE, "lineSetStatusMessages(%d): line(%p)", ++dwSum, hdLine);

    lRes = GetLineObjWithReadLock(hdLine, &pLine);
    if (lRes != TAPI_SUCCESS)
    {
        return lRes;
    }

    if ((lRes = PrepareSyncRequest(
             OID_TAPI_SET_STATUS_MESSAGES,          // opcode
             pLine->dwDeviceID,                     // device id
             sizeof(NDIS_TAPI_SET_STATUS_MESSAGES), // size
             &pNdisTapiRequest                      // ptr to ptr to req buf
         )) != TAPI_SUCCESS)
    {
        ReleaseObjReadLock((HANDLE)hdLine);
        return lRes;
    }

    pNdisTapiSetStatusMessages =
        (PNDIS_TAPI_SET_STATUS_MESSAGES)pNdisTapiRequest->Data;

    pNdisTapiSetStatusMessages->hdLine = pLine->hd_Line;
    pNdisTapiSetStatusMessages->ulLineStates = dwLineStates;
    pNdisTapiSetStatusMessages->ulAddressStates = dwAddressStates;

    lRes = SyncDriverRequest(IOCTL_NDISTAPI_SET_INFO, pNdisTapiRequest);

    FreeRequest(pNdisTapiRequest);

    ReleaseObjReadLock((HANDLE)hdLine);
    return lRes;
}

//
// TAPI_providerXxx funcs
//
LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    char    szDeviceName[] = "NDProxy";
    char    szTargetPath[] = "\\Device\\NDProxy";
    char    szCompleteDeviceName[] = "\\\\.\\NDProxy";
    DWORD   cbReturned, dwNumLines;
    DWORD   adwConnectInfo[2] = {1, 1};

    TspLog(DL_TRACE, "providerEnumDevices: permProvID(%x)",
           dwPermanentProviderID);

    gpfnLineEvent = lpfnLineCreateProc;
    ghProvider = hProvider;

    gInitResult= LINEERR_OPERATIONFAILED;

    // create symbolic link to the kernel-mode driver
    DefineDosDevice (DDD_RAW_TARGET_PATH, szDeviceName, szTargetPath);
    
    //
    // open driver handles
    //
    if ((ghDriverSync = CreateFileA(
                            szCompleteDeviceName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,       // no security attrs
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL        // no template file
                            )) == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CreateFile(%s, sync) failed(%ld)",
               szCompleteDeviceName, GetLastError());

        goto enumdevs_error0;
    }

    if ((ghDriverAsync = CreateFileA(
                             szCompleteDeviceName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,      // no security attrs
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL       // no template file
                             )) == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CreateFile(%s, async) failed(%ld)",
               szCompleteDeviceName, GetLastError());

        goto enumdevs_error1;
    }

    // create io completion port
    if ((ghCompletionPort = CreateIoCompletionPort(ghDriverAsync, NULL, 0, 0))
        == INVALID_HANDLE_VALUE)
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CreateIoCompletionPort failed(%ld)",
               GetLastError());

        goto enumdevs_error2;
    }

    // connect to driver: sending a device ID base
    // and it will return the number of devices it supports
    if (!DeviceIoControl(ghDriverSync,
                         (DWORD) IOCTL_NDISTAPI_CONNECT,
                         adwConnectInfo,
                         2*sizeof(DWORD),
                         &dwNumLines,
                         sizeof(DWORD),
                         &cbReturned,
                         (LPOVERLAPPED) NULL
                         ) || (cbReturned < sizeof(DWORD)))
    {
        TspLog(DL_ERROR, 
               "providerEnumDevices: CONNECT failed(%ld)", 
               GetLastError());

        goto enumdevs_error3;
    }

    // init the req id
    gdwRequestID = 1;

    // set the number of devices
    *((LPDWORD)lpdwNumLines) = dwNumLines;

    // if here, success
    gInitResult = TAPI_SUCCESS;
    goto enumdevs_return;

    // clean up resources if an error occurred
enumdevs_error3:
    CloseHandle (ghCompletionPort);

enumdevs_error2:
    CloseHandle (ghDriverAsync);

enumdevs_error1:
    CloseHandle (ghDriverSync);

enumdevs_error0:
    DefineDosDevice (DDD_REMOVE_DEFINITION, szDeviceName, NULL);

enumdevs_return:
    TspLog(DL_INFO, "providerEnumDevices:  gInitResult(%x)", gInitResult);
    return gInitResult;
}

LONG
TSPIAPI
TSPI_providerConfig(
    HWND  hwndOwner,
    DWORD dwPermanentProviderID
    )
{
    UNREFERENCED_PARAMETER(hwndOwner);              // no dialog here
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // not needed anymore

    // success
    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    LONG    lRes = LINEERR_OPERATIONFAILED;
    DWORD   cbReturned, dwThreadID;

    if(INVALID_TRACEID != gdwTraceID)
    {
        gdwTraceID = TraceRegisterA("NDPTSP");
    }
    
    TspLog(DL_TRACE, "providerInit: perfProvID(%x), lineDevIDBase(%x)",
            dwPermanentProviderID, dwLineDeviceIDBase);

    gpfnCompletionProc = lpfnCompletionProc;

    // inform tapisrv that we support multiple simultaneous requests
    // (the WAN wrapper handles request serialization for miniports)
    *lpdwTSPIOptions = 0;

    // check for successful init in EnumDevs
    if (gInitResult != TAPI_SUCCESS)
    {
        goto providerInit_return;
    }

    // send the base ID to the proxy
    if (!DeviceIoControl(ghDriverSync,
                         (DWORD) IOCTL_NDISTAPI_SET_DEVICEID_BASE,
                         &dwLineDeviceIDBase,
                         sizeof(DWORD),
                         NULL,
                         0,
                         &cbReturned,
                         (LPOVERLAPPED)NULL))
    {
        TspLog(DL_ERROR, "providerInit: SET_DEVICEID_BASE failed(%ld)",
               GetLastError());

        goto providerInit_return;
    }

    //
    // init mapper and allocator
    //
    if (InitializeMapper() != TAPI_SUCCESS)
    {
        goto providerInit_return;
    }

    InitAllocator();

    //
    // alloc the resources needed by the AsyncEventThread, 
    // and then create the thread
    //
    if ((gpAsyncEventsThreadInfo = (PASYNC_EVENTS_THREAD_INFO)
            MALLOC(sizeof(ASYNC_EVENTS_THREAD_INFO))) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: failed to alloc thread info");
        goto providerInit_error4;
    }

    gpAsyncEventsThreadInfo->dwBufSize = EVENT_BUFFER_SIZE;

    if ((gpAsyncEventsThreadInfo->pBuf = (PNDISTAPI_EVENT_DATA)
            MALLOC(EVENT_BUFFER_SIZE)) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: failed to alloc event buf");
        goto providerInit_error5;
    }

    if ((gpAsyncEventsThreadInfo->hThread = CreateThread(
            (LPSECURITY_ATTRIBUTES)NULL,    // no security attrs
            0,                              // default stack size
            (LPTHREAD_START_ROUTINE)        // func addr
                AsyncEventsThread,
            (LPVOID)NULL,                   // thread param
            0,                              // create flags
            &dwThreadID                     // thread id
            )) == NULL)
    {
        TspLog(DL_ERROR, "providerInit: CreateThread failed(%ld)",
               GetLastError());

        goto providerInit_error7;
    }

    //
    // If here success
    //
    lRes = TAPI_SUCCESS;
    goto providerInit_return;

    //
    // clean up resources if an error occured & then return
    //
providerInit_error7:

    FREE(gpAsyncEventsThreadInfo->pBuf);

providerInit_error5:

    FREE(gpAsyncEventsThreadInfo);

providerInit_error4:
    UninitAllocator();
    UninitializeMapper();

providerInit_return:

    TspLog(DL_INFO, "providerInit: lRes(%x)", lRes);
    return lRes;
}

LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD_PTR dwTempID,
    DWORD     dwDeviceID
    )
{
    DWORD                   cbReturned;
    NDISTAPI_CREATE_INFO    CreateInfo;

    CreateInfo.TempID = (DWORD)dwTempID;
    CreateInfo.DeviceID = dwDeviceID;

    TspLog(DL_TRACE, "providerCreateLineDevice: tempID(%x), deviceID(%x)",
           dwTempID, dwDeviceID);

    if (!DeviceIoControl(
            ghDriverSync,
            IOCTL_NDISTAPI_CREATE,
            &CreateInfo,
            sizeof(CreateInfo),
            &CreateInfo,
            sizeof(CreateInfo),
            &cbReturned,
            (LPOVERLAPPED)NULL
            ))
    {
        TspLog(DL_ERROR, "providerCreateLineDevice: failed(%ld) to create",
               GetLastError());
        return LINEERR_OPERATIONFAILED;
    }

    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    char                    deviceName[] = "NDPROXY";
    ASYNC_REQUEST_WRAPPER   asyncRequestWrapper;
    DWORD                   cbReturned;

    TspLog(DL_TRACE, "providerShutdown: perfProvID(%x)", dwPermanentProviderID);

    // disconnect with the driver
    if (!DeviceIoControl(ghDriverSync,
                         (DWORD) IOCTL_NDISTAPI_DISCONNECT,
                         NULL,
                         0,
                         NULL,
                         0,
                         &cbReturned,
                         (LPOVERLAPPED) NULL
                         )) 
    {
        TspLog(DL_ERROR, "providerShutdown: DISCONNECT failed(%ld)",
               GetLastError());
    }

    //
    // Close the driver & remove the symbolic link
    //
    CancelIo(ghDriverSync);
    CancelIo(ghDriverAsync);
    CloseHandle (ghDriverSync);
    
TspLog(DL_WARNING, "providerShutdown: Posting exit message to completion port"
	, dwPermanentProviderID);
     if( !PostQueuedCompletionStatus
     		(ghCompletionPort, 0, 0, (LPOVERLAPPED)(&(gOverlappedTerminate))))
        {
        	
        	TspLog(DL_ERROR, 
        			"providerShutdown: PostQueuedCompletionStatus failed");
    	}
    else
    	{
   	 WaitForSingleObject(gpAsyncEventsThreadInfo->hThread, INFINITE);
    	}
   
    CloseHandle (ghDriverAsync);
    CloseHandle (ghCompletionPort);
    DefineDosDevice (DDD_REMOVE_DEFINITION, deviceName, NULL);


    CloseHandle(gpAsyncEventsThreadInfo->hThread);
    FREE(gpAsyncEventsThreadInfo->pBuf);
    FREE(gpAsyncEventsThreadInfo);

    UninitAllocator();
    UninitializeMapper();

    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR pwszUIDLLName
   )
{
    // copy name of our dll as ui dll
    lstrcpyW(pwszUIDLLName, NDPTSP_UIDLL);

    // success
    return TAPI_SUCCESS;
}

LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    INT_PTR         nResult;
    CONFIG_UI_CTX   Ctx;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    ZeroMemory(&Ctx, sizeof(Ctx));

    // invoke dialog box
    nResult = DialogBoxParamW(
                  ghInstance,
                  (LPWSTR)MAKEINTRESOURCE(IDD_MEDIA_MAP),
                  hwndOwner,
                  ProviderConfigDlgProc,
                  (LPARAM)&Ctx
                  );

    // status based on whether dialog executed properly
    return ((DWORD)nResult == 0) ? TAPI_SUCCESS : LINEERR_OPERATIONFAILED;
}

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#if DBG
            {
                HKEY    hKey;
                DWORD   dwDataSize, dwDataType;
                TCHAR   szTelephonyKey[] =
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";
                TCHAR   szNdptspDebugLevel[] = "NdptspDebugLevel";

                RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szTelephonyKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

                dwDataSize = sizeof(DWORD);
                gdwDebugLevel = DL_WARNING;

                RegQueryValueEx(
                    hKey,
                    szNdptspDebugLevel,
                    0,
                    &dwDataType,
                    (LPBYTE)&gdwDebugLevel,
                    &dwDataSize
                    );

                RegCloseKey(hKey);
            }
#endif

#if 0
            gdwTraceID = TraceRegisterA("NDPTSP");
            ASSERT(gdwTraceID != INVALID_TRACEID);

#endif            

            TspLog(DL_TRACE, "DLL_PROCESS_ATTACH");

            // save the handle for the UI
            ghInstance = hDLL;

            ZeroMemory(&gpAddressMapListArray, sizeof(gpAddressMapListArray));
            gbAddressMapListLoaded = FALSE;

            //
            // Init global sync objects
            //
            InitializeCriticalSection(&gRequestIDCritSec);
            InitializeCriticalSection(&gAddressMapCritSec);

            InitLineDevList();

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            TspLog(DL_TRACE, "DLL_PROCESS_DETACH");

            UninitLineDevList();

            // free address list
            FreeAllAddressLists(gpAddressMapListArray);

            DeleteCriticalSection(&gRequestIDCritSec);
            DeleteCriticalSection(&gAddressMapCritSec);

#if 0
            TraceDeregisterA(gdwTraceID);
#endif            

            break;
        }
    } // switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\remotesp\dslookup.cpp ===
/*
 * Purpose: C++ API for finding the telephony
 *         servers in Active Directory
 *
 */

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#include <windows.h>
#include <objbase.h>
#include <activeds.h>

#include "tspi.h"
#include "tapi.h"
#include "dslookup.h"
#include "utils.h"

#include "tchar.h"

const TCHAR gszNoDSQuery[] = TEXT("NoDSQuery");
const TCHAR gszStatusActive[] = TEXT("S{Active}");
const TCHAR gszTTLWithBrace[] = TEXT("TTL{");

//
//  Utility functions
//

//
//  GetIntFromString
//      Utility function used for retrieving TTL information
//  Parameters:
//      sz       -  String that contains the integer
//      dwDigits -  Number of digits to convert
//
int GetIntFromString (LPTSTR & sz, DWORD dwDigits)
{
    int         iRet = 0;

    while (*sz != 0 && dwDigits)
    {
        iRet = ((iRet << 3) + (iRet << 1)) + // IRet * 10
               + (*sz - '0');
        ++sz;
        --dwDigits;
    }

    return iRet;
}

//
//  Rules:
//      The following codes are not thread safe, the caller
//  needs to be concious about synchronization.
//      Currently theses are only used in remotesp.tsp
//

/**********************************************************
 *  Get TAPI servers list from the registry
 *********************************************************/

DWORD                 gdwCurServerNum = 0;
HKEY                  ghRegistry = NULL;

BOOL
RegOpenServerLookup(
    HKEY    hRegistry
    )
{
    if (NULL != ghRegistry)
    {
        // Already have a search in progress or the
        // caller did not close the last search.
        return FALSE;
    }
    else
    {
        ghRegistry = hRegistry;
        return TRUE;
    }
}

BOOL
RegGetNextServer(
    LPTSTR  pszServerName,
    DWORD   dwSize
    )
{
    DWORD dwRet;
    LOG((TL_TRACE, "GetNextServer entered"));

    TCHAR szServerN[24];
    DWORD dwType;

    wsprintf(szServerN, TEXT("Server%d"), gdwCurServerNum++);

    LOG((TL_INFO, "RegGetNextServer: Getting server %d from reg", gdwCurServerNum-1));

    dwRet = RegQueryValueEx(
        ghRegistry,
        szServerN,
        0,
        &dwType,
        (LPBYTE) pszServerName,
        &dwSize
        );
    if (ERROR_SUCCESS != dwRet)
    {
    	LOG((TL_INFO, "Got last server"));
        LOG((TL_TRACE, "GetNextServer exited"));
		return FALSE;
    }

    LOG((TL_TRACE, "GetNextServer exited"));
    return TRUE;
}

BOOL
RegCloseLookup(
    void
    )
{
    LOG((TL_INFO, "Closing directory lookup"));

    ghRegistry = NULL;
    gdwCurServerNum = 0;
    return TRUE;
}


/**********************************************************
 *  Enumerate published telephony servers
 *********************************************************/

typedef struct _TAPISRV_LOOKUP_CTX {
    ADS_SEARCH_HANDLE     hDirSearch;
    IDirectorySearch *    pDirSearch;
} TAPISRV_LOOKUP_CTX, *PTAPISRV_LOOKUP_CTX;

//  gszTapisrvGuid needs to be consistant with server\dspub.cpp
const WCHAR gszTapisrvGuid[] = L"keywords=B1A37774-E3F7-488E-ADBFD4DB8A4AB2E5";

//
//  GetGC
//
//      Retrieve the IDirectorySearch of the Global Catalog (GC)
//  for SCP maintenance / discovery
//

HRESULT GetGC (IDirectorySearch ** ppGC)
{
    HRESULT             hr = S_OK;
    IEnumVARIANT        * pEnum = NULL;
    IADsContainer       * pCont = NULL;
    VARIANT             var;
    IDispatch           * pDisp = NULL;
    ULONG               lFetch;

    // Set IDirectorySearch pointer to NULL.
    *ppGC = NULL;

    // First, bind to the GC: namespace container object. The "real" GC DN 
    // is a single immediate child of the GC: namespace, which must 
    // be obtained using enumeration.
    hr = ADsOpenObject(
        TEXT("GC:"),
        NULL,
        NULL,
        ADS_SECURE_AUTHENTICATION, //Use Secure Authentication
        IID_IADsContainer,
        (void**)&pCont
        );
    if (FAILED(hr))
    {
        LOG((TL_ERROR, "ADsOpenObject failed: 0x%x\n", hr));
        goto cleanup;
    } 

    // Fetch an enumeration interface for the GC container. 
    hr = ADsBuildEnumerator(pCont, &pEnum);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "ADsBuildEnumerator failed: 0x%x\n", hr));
        goto cleanup;
    } 

    //Now enumerate. There's only one child of the GC: object.
    hr = ADsEnumerateNext(pEnum, 1, &var, &lFetch);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "ADsEnumerateNext failed: 0x%x\n", hr));
        goto cleanup;
    } 

    if (( hr == S_OK ) && ( lFetch == 1 ) )
    {
        pDisp = V_DISPATCH(&var);
        hr = pDisp->QueryInterface( IID_IDirectorySearch, (void**)ppGC); 
    }

cleanup:
    if (pEnum)
    {
        ADsFreeEnumerator(pEnum);
    }
    if (pCont)
    {
        pCont->Release();
    }
    if (pDisp)
    {
        (pDisp)->Release();
    }
    return hr;
}

//
//  DsOpenServerLookup
//      Start the operation of tapisrv server lookup
//  pctx    - The lookup context
//

HRESULT
DsOpenServerLookup(
    PTAPISRV_LOOKUP_CTX     pctx
    )
{
    HRESULT             hr = S_OK;
    ADS_SEARCHPREF_INFO SearchPref[3];
    BOOL                bInited = FALSE;
    DWORD               dwPref;

    WCHAR   *szAttribs[]={
        L"distinguishedName"
        };

    if (pctx == NULL)
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    pctx->hDirSearch = NULL;
    pctx->pDirSearch = NULL;

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    bInited = TRUE;

    //  Get the global catalog
    hr = GetGC (&pctx->pDirSearch);
    if (FAILED (hr) || pctx->pDirSearch == NULL)
    {
        goto ExitHere;
    }

    // Set up the search. We want to do a deep search.
    // Note that we are not expecting thousands of objects
    // in this example, so we will ask for 10 rows / page.
    dwPref=sizeof(SearchPref)/sizeof(ADS_SEARCHPREF_INFO);
    SearchPref[0].dwSearchPref =    ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref[0].vValue.dwType =   ADSTYPE_INTEGER;
    SearchPref[0].vValue.Integer =  ADS_SCOPE_SUBTREE;

    SearchPref[1].dwSearchPref =    ADS_SEARCHPREF_PAGESIZE;
    SearchPref[1].vValue.dwType =   ADSTYPE_INTEGER;
    SearchPref[1].vValue.Integer =  10;

    SearchPref[2].dwSearchPref =    ADS_SEARCHPREF_TIME_LIMIT;
    SearchPref[2].vValue.dwType =   ADSTYPE_INTEGER;
    SearchPref[2].vValue.Integer =  5 * 60; // 5 minute search timeout

    hr = pctx->pDirSearch->SetSearchPreference(SearchPref, dwPref);
    if (FAILED(hr))    {
        LOG((TL_ERROR, "Failed to set search prefs: hr:0x%x\n", hr));
        goto ExitHere;
    }

    //  Now execute the search
    hr = pctx->pDirSearch->ExecuteSearch(
        (LPWSTR)gszTapisrvGuid, 
        szAttribs, 
        sizeof(szAttribs) / sizeof(WCHAR *),
        &pctx->hDirSearch
        );

ExitHere:
    if (FAILED(hr) && pctx != NULL)
    {
        if (pctx->pDirSearch)
        {
            pctx->pDirSearch->Release();
        }
    }
    if (FAILED(hr) && bInited)
    {
        CoUninitialize ();
    }
    return hr;
}

//
//  DsGetNextServer
//
//      Return the next server name (in ANSI since that is what the
//  RPC subsystem uses)
//
//      returns S_FALSE if no more server to enumerate
//

HRESULT
DsGetNextServer(
    PTAPISRV_LOOKUP_CTX     pctx,
    LPTSTR                  pszServerName,
    DWORD                   dwSize
    )
{
    HRESULT             hr = S_OK;
    ADS_SEARCH_COLUMN   Col;
    TCHAR               szDN[MAX_PATH];
    WCHAR   *szAttribs[]={
        L"serviceDNSName",
        L"serviceBindingInformation",
        };
    ADS_ATTR_INFO       *pPropEntries = NULL;
    DWORD               dwNumAttrGot;
    IDirectoryObject    * pSCP = NULL;
    int                 i;
    LPWSTR              wsz;
    BOOL                bCheckedBinding;

    if (pctx == NULL || pctx->pDirSearch == NULL ||
        pctx->hDirSearch == NULL ||
        dwSize < sizeof(WCHAR))
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    hr = pctx->pDirSearch->GetNextRow(pctx->hDirSearch);
    if (SUCCEEDED (hr) && hr != S_ADS_NOMORE_ROWS)
    {
        hr = pctx->pDirSearch->GetColumn(
            pctx->hDirSearch,
            L"distinguishedName",
            &Col
            );
        if (FAILED (hr))
        {
            goto ExitHere;
        }
        _tcscpy (szDN, TEXT("LDAP://"));
        _tcsncpy (
            szDN + _tcslen (szDN), 
            Col.pADsValues->CaseExactString, 
            sizeof(szDN)/sizeof(TCHAR) - _tcslen (szDN)
            );
        pctx->pDirSearch->FreeColumn(&Col);
        hr = ADsGetObject (
            szDN,
            IID_IDirectoryObject,
            (void **)&pSCP
            );

        if (FAILED(hr))
        {
            LOG((TL_ERROR, "DsGetNextServer: ADsGetObject %S failed", szDN));
            hr = S_FALSE;  // return a non-critical error so that we 
                           // ignore this server but don't abandon the search
            goto ExitHere;
        }
        LOG((TL_TRACE, "DsGetNextServer: ADsGetObject %S succeeded", szDN));
        hr = pSCP->GetObjectAttributes (
            szAttribs,
            sizeof(szAttribs) / sizeof(WCHAR *),
            &pPropEntries,
            &dwNumAttrGot
            );
        if (FAILED(hr) || dwNumAttrGot != sizeof(szAttribs) / sizeof(WCHAR *))
        {
            LOG((TL_ERROR, "DsGetNextServer: GetObjectAttributes %S failed", szDN));
            hr = S_FALSE;
            goto ExitHere;
        }
        LOG((TL_TRACE, "DsGetNextServer: GetObjectAttributes %S succeeded", szDN));

        bCheckedBinding = FALSE;
        for (i=0;i<(int)dwNumAttrGot;i++) 
        {
            if (_tcsicmp(TEXT("serviceDNSName"), pPropEntries[i].pszAttrName) ==0 &&
                (pPropEntries[i].pADsValues->dwType == ADSTYPE_CASE_EXACT_STRING ||
                pPropEntries[i].pADsValues->dwType == ADSTYPE_CASE_IGNORE_STRING))
            {
                _tcsncpy (
                    pszServerName, 
                    pPropEntries[i].pADsValues->CaseExactString, 
                    dwSize/sizeof(TCHAR)
                    );
                pszServerName[dwSize/sizeof(TCHAR) - 1] = '\0';
                if (bCheckedBinding)
                {
                    break;
                }
            }
            else if (_tcsicmp(TEXT("serviceBindingInformation"), pPropEntries[i].pszAttrName) ==0 &&
                (pPropEntries[i].pADsValues->dwType == ADSTYPE_CASE_EXACT_STRING ||
                pPropEntries[i].pADsValues->dwType == ADSTYPE_CASE_IGNORE_STRING))
            {
                SYSTEMTIME          st;
                FILETIME            ft1, ft2;

                bCheckedBinding = TRUE;
                wsz = pPropEntries[i].pADsValues->CaseExactString;
                wsz = wcsstr (wsz, gszStatusActive);
                if (wsz == NULL)
                {
                    //  No server status information or server is not active
                    //  ignore this server
                    LOG((TL_ERROR, "DsGetNextServer:  %S No server status information", szDN));
                    hr = S_FALSE;
                    break;
                }
                wsz += _tcslen(gszStatusActive); // skip "S{Active}" itself
                wsz = wcsstr (wsz, gszTTLWithBrace);
                if (wsz == NULL)
                {
                    // No TTL found, corrupt serviceBindingInformation, ignore
                    LOG((TL_ERROR, "DsGetNextServer: %S No TTL found", szDN));
                    hr = S_FALSE;
                    break;
                }
                wsz += _tcslen (gszTTLWithBrace);   // skip "TTL{"
                
                //
                //  The following codes parses the TTL information
                //  created in server\dspub.cpp. They need to be
                //  consistant. The current format is 5 digits for
                //  year & 3 digits for milliseconds, 2 digits for
                //  the remaining
                //
                st.wYear = (WORD) GetIntFromString (wsz, 5);
                st.wMonth = (WORD) GetIntFromString (wsz, 2);
                st.wDay = (WORD) GetIntFromString (wsz, 2),
                st.wHour = (WORD) GetIntFromString (wsz, 2);
                st.wMinute = (WORD) GetIntFromString (wsz, 2);
                st.wSecond = (WORD) GetIntFromString (wsz, 2);
                st.wMilliseconds = (WORD) GetIntFromString (wsz, 3);
                SystemTimeToFileTime (&st, &ft1);
                GetSystemTimeAsFileTime (&ft2);
                if (CompareFileTime (&ft1, &ft2) < 0)
                {
                    //  The TapiSCP object has passed its TTL, ignore
                    hr = S_FALSE;
                    LOG((TL_ERROR, "DsGetNextServer: %S The TapiSCP object has passed its TTL", szDN));
                    break;
                }
            }
        }
        if (i == (int) dwNumAttrGot)
        {
            //  Did not find an attribute
            hr = S_FALSE;
        }
    }

ExitHere:
    if (pSCP)
        pSCP->Release();

    if (pPropEntries)
        FreeADsMem(pPropEntries);

    return hr;
}


//
//  DsCloseLookup
//      Close the TAPI DS published server lookup identified by pctx
//

HRESULT
DsCloseLookup(
    PTAPISRV_LOOKUP_CTX     pctx
    )
{
    if (pctx && pctx->pDirSearch && pctx->hDirSearch)
    {
        pctx->pDirSearch->CloseSearchHandle(pctx->hDirSearch);
    }
    if (pctx && pctx->pDirSearch)
    {
        pctx->pDirSearch->Release();
    }
    CoUninitialize ();
    return S_OK;
}

/**********************************************************
 *  Get TAPI servers list remotesp.tsp should contact
 *      Servers include those specified in registry through
 *  tcmsetup.exe and those servers published in the DS
 *********************************************************/

typedef struct _SERVER_LOOKUP_ENTRY {
    TCHAR           szServer[MAX_PATH];
    BOOL            bFromReg;
} SERVER_LOOKUP_ENTRY, *PSERVER_LOOKUP_ENTRY;

typedef struct _SERVER_LOOKUP {
    DWORD                   dwTotalEntries;
    DWORD                   dwUsedEntries;
    SERVER_LOOKUP_ENTRY     * aEntries;
} SERVER_LOOKUP, *PSERVER_LOOKUP;

SERVER_LOOKUP       gLookup;
DWORD               gdwCurIndex;

//
//  AddEntry : return FALSE if failed; otherwise, return true
//

BOOL
AddEntry (
    LPTSTR          szServer,
    BOOL            bFromReg
    )
{
    LPTSTR          psz;
    
    if (gLookup.dwUsedEntries >= gLookup.dwTotalEntries)
    {
        PSERVER_LOOKUP_ENTRY            pNew;

        pNew = (PSERVER_LOOKUP_ENTRY) DrvAlloc (
            sizeof(SERVER_LOOKUP_ENTRY) * (gLookup.dwTotalEntries + 5)
            );
        if (pNew == NULL)
        {
            return FALSE;
        }
        if (gLookup.dwUsedEntries > 0)
        {
            CopyMemory (
                pNew,
                gLookup.aEntries,
                sizeof(SERVER_LOOKUP_ENTRY) * gLookup.dwTotalEntries
                );
        }
        if (gLookup.aEntries)
        {
            DrvFree (gLookup.aEntries);
        }
        gLookup.aEntries = pNew;
        gLookup.dwTotalEntries += 5;
    }
    wcsncpy (
        gLookup.aEntries[gLookup.dwUsedEntries].szServer, 
        szServer,
        sizeof(gLookup.aEntries[gLookup.dwUsedEntries].szServer)/sizeof(TCHAR)
        );
    psz = _tcschr(gLookup.aEntries[gLookup.dwUsedEntries].szServer, TEXT('.'));
    if (psz != NULL)
    {
        *psz = 0;
    }
    gLookup.aEntries[gLookup.dwUsedEntries].bFromReg = bFromReg;
    ++gLookup.dwUsedEntries;
    return TRUE;
}

BOOL
IsServerInListOrSelf (
    LPTSTR          szServer
    )
{
    int             i;
    TCHAR           szServer1[MAX_PATH + 1];
    LPTSTR          psz;
    BOOL            bRet = FALSE;

    _tcsncpy (szServer1, szServer, MAX_PATH);
    szServer1[MAX_PATH] = 0;

    //  A computer name might be DNS name like comp1.microsoft.com
    //  only compare the computer name
    psz = _tcschr(szServer1, TEXT('.'));
    if (psz != NULL)
    {
        *psz = 0;
    }
    for (i = 0; i < (int)gLookup.dwUsedEntries; ++i)
    {
        if (_tcsicmp (szServer1, gLookup.aEntries[i].szServer) == 0)
        {
            bRet = TRUE;
            break;
        }
    }

    if (!bRet)
    {
        TCHAR           szSelf[MAX_PATH];
        DWORD           dwSize = sizeof(szSelf);
        
        if (GetComputerName (szSelf, &dwSize))
        {
            if (_tcsicmp (szServer1, szSelf) == 0)
            {
                bRet = TRUE;
            }
        }
    }

    return bRet;
}

BOOL OpenServerLookup (
    HKEY            hRegistry
    )
{
    BOOL                bRet = TRUE;
    TCHAR               szServer[MAX_PATH];
    TAPISRV_LOOKUP_CTX  ctx;
    HRESULT             hr;
    DWORD               dwNoDSQuery = 0;
    DWORD               dwSize = sizeof(dwNoDSQuery);

    gLookup.dwTotalEntries = 0;
    gLookup.dwUsedEntries = 0;
    gLookup.aEntries = NULL;

    //
    //  First add the computer from registry
    //
    if (RegOpenServerLookup (hRegistry))
    {
        while (RegGetNextServer (szServer, sizeof(szServer)))
        {
            if (!IsServerInListOrSelf (szServer))
            {
                AddEntry (szServer, TRUE);
            }
        }
        RegCloseLookup ();
    }

    if (hRegistry != NULL)
    {
        if (ERROR_SUCCESS != RegQueryValueEx (
            hRegistry,
            gszNoDSQuery,
            NULL,
            NULL,
            (LPBYTE)&dwNoDSQuery,
            &dwSize
            ))
        {
            dwNoDSQuery = 0;
        }
    }

    //
    //  Next add the computer from DS unless disabled
    //
    if (dwNoDSQuery == 0)
    {
        if (DsOpenServerLookup (&ctx) == S_OK)
        {
            while (SUCCEEDED(hr = DsGetNextServer (&ctx,szServer, sizeof(szServer))))
            {
                if (hr == S_ADS_NOMORE_ROWS)
                {
                    break;
                }
                else if (hr != S_OK)
                {
                    continue;   //  Server needs to be ignored
                }
                if (szServer[0] != 0 && !IsServerInListOrSelf (szServer))
                {
                    AddEntry (szServer, FALSE);
                }
            }
            DsCloseLookup (&ctx);
        }
    }

    gdwCurIndex = 0;

    return TRUE;
}

BOOL GetNextServer (
    LPSTR           szServer,
    DWORD           dwSize,
    BOOL            * pbReg
    )
{
    BOOL             bRet = TRUE;
    DWORD            dwRet;

    if (gdwCurIndex >= gLookup.dwUsedEntries)
    {
        bRet = FALSE;
        goto ExitHere;
    }
    if (pbReg != NULL)
    {
        *pbReg = gLookup.aEntries[gdwCurIndex].bFromReg;
    }
    dwRet = WideCharToMultiByte(
        GetACP(),
        0,
        gLookup.aEntries[gdwCurIndex].szServer,
        -1,
        szServer,
        dwSize,
        0,
        NULL
        );
    if (dwRet == 0)
    {
        bRet = FALSE;
        goto ExitHere;
    }
    ++gdwCurIndex;

ExitHere:
    return bRet;
}

BOOL CloseLookup (
    void
    )
{
    if (gLookup.aEntries)
    {
        DrvFree (gLookup.aEntries);
    }
    gLookup.aEntries = NULL;
    gLookup.dwTotalEntries = 0;
    gLookup.dwUsedEntries = 0;
    gdwCurIndex = 0;

    return TRUE;
}

HRESULT SockStartup (
    RSPSOCKET       * pSocket
    )
{
    HRESULT             hr = S_OK;
    BOOL                bCleanup = FALSE;
    WSADATA             wsadata;
    WORD                wVersionRequested = MAKEWORD( 2, 2 );

    if (pSocket == NULL)
    {
        hr = LINEERR_INVALPARAM;
        goto ExitHere;
    }
    ZeroMemory (pSocket, sizeof(RSPSOCKET));
    bCleanup = TRUE;

    ZeroMemory (pSocket, sizeof(RSPSOCKET));

    pSocket->hWS2 = LoadLibrary (TEXT("ws2_32.dll"));
    if (pSocket->hWS2 == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }
    
    pSocket->pFnWSAStartup = (PFNWSASTARTUP)GetProcAddress (
        pSocket->hWS2,
        "WSAStartup"
        );
    pSocket->pFnWSACleanup = (PFNWSACLEANUP)GetProcAddress (
        pSocket->hWS2,
        "WSACleanup"
        );
    pSocket->pFngethostbyname = (PFNGETHOSTBYNAME)GetProcAddress(
        pSocket->hWS2,
        "gethostbyname"
        );
    if (pSocket->pFnWSAStartup == NULL ||
        pSocket->pFnWSACleanup == NULL ||
        pSocket->pFngethostbyname == NULL)
    {
        hr = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    pSocket->hICMP = LoadLibrary (TEXT("icmp.dll"));
    if (pSocket->hICMP == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }
    pSocket->pFnIcmpCreateFile = (PFNICMPCREATEFILE)GetProcAddress (
        pSocket->hICMP,
        "IcmpCreateFile"
        );
    pSocket->pFnIcmpCloseHandle = (PFNICMPCLOSEHANDLE)GetProcAddress (
        pSocket->hICMP,
        "IcmpCloseHandle"
        );
    pSocket->pFnIcmpSendEcho = (PFNICMPSENDECHO)GetProcAddress (
        pSocket->hICMP,
        "IcmpSendEcho"
        );
    if (pSocket->pFnIcmpCreateFile == NULL ||
        pSocket->pFnIcmpCloseHandle == NULL ||
        pSocket->pFnIcmpSendEcho == NULL)
    {
        hr = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    hr = (*pSocket->pFnWSAStartup)(
        wVersionRequested,
        &wsadata
        );
    if(FAILED(hr))
    {
        goto ExitHere;
    }

    pSocket->IcmpHandle = (*pSocket->pFnIcmpCreateFile)();
    if (pSocket->IcmpHandle == INVALID_HANDLE_VALUE)
    {
        (*pSocket->pFnWSACleanup)();
        hr = LINEERR_OPERATIONFAILED;
    }

ExitHere:
    if (hr != S_OK && bCleanup)
    {
        if (pSocket->hWS2 != NULL)
        {
            FreeLibrary (pSocket->hWS2);
        }
        if (pSocket->hICMP != NULL)
        {
            FreeLibrary (pSocket->hICMP);
        }
        ZeroMemory (pSocket, sizeof(RSPSOCKET));
    }
    return hr;
}

#define MAX_PACKET_SIZE	    256
#define PING_TIMEOUT        1000

HRESULT SockIsServerResponding (
    RSPSOCKET       * pSocket,
    char *          szServer
    )
{
    HRESULT             hr = S_OK;
    unsigned long       inetAddr;
    HOSTENT             * pHost;
    BOOL                bRet;
	CHAR			    ReplyBuf[MAX_PACKET_SIZE];
	
    //  Validate parameters
    if (pSocket == NULL ||
        pSocket->hWS2 == NULL ||
        pSocket->hICMP == NULL ||
        pSocket->IcmpHandle == NULL ||
        pSocket->IcmpHandle == INVALID_HANDLE_VALUE)
    {
        hr = LINEERR_INVALPARAM;
        goto ExitHere;
    }

    //  Get the server IP address
    pHost = (*pSocket->pFngethostbyname)(szServer);
    if (pHost == NULL)
    {
        hr = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }
    inetAddr = *(unsigned long *)pHost->h_addr;

    //  Ping the server
    bRet = (*pSocket->pFnIcmpSendEcho)(
        pSocket->IcmpHandle,
        inetAddr,
        0,
        0,
        0,
        (LPVOID)ReplyBuf,
        sizeof(ReplyBuf),
        PING_TIMEOUT
        );
    if (!bRet || ((PICMP_ECHO_REPLY)ReplyBuf)->Address != inetAddr)
    {
        hr = S_FALSE;
    }
    
ExitHere:
    return hr;
}

HRESULT SockShutdown (
    RSPSOCKET       * pSocket
    )
{
    if (pSocket != NULL)
    {
        if (pSocket->IcmpHandle != INVALID_HANDLE_VALUE &&
            pSocket->IcmpHandle != NULL)
        {
            (*pSocket->pFnIcmpCloseHandle)(pSocket->IcmpHandle);
        }
        if (pSocket->hICMP != NULL)
        {
            FreeLibrary (pSocket->hICMP);
        }
        if (pSocket->hWS2 != NULL)
        {
            (*pSocket->pFnWSACleanup)();
            FreeLibrary (pSocket->hWS2);
        }
        ZeroMemory (pSocket, sizeof(RSPSOCKET));
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\remotesp\imperson.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    impersn.h

Abstract:

    Definitions for impersonation routines

Author:

    Anthony Discolo (adiscolo)  04-Aug-1995

Revision History:

--*/

#ifndef _IMPERSON_
#define _IMPERSON_

VOID
RevertImpersonation();

BOOLEAN
GetCurrentlyLoggedOnUser(
    HANDLE *phProcess
    );

BOOLEAN
SetProcessImpersonationToken(
    HANDLE hProcess
    );

VOID
ClearImpersonationToken();

#endif // _IMPERSON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\remotesp\dslookup.h ===
#ifndef _DSLOOKUP_H
#define _DSLOOKUP_H

#include <ipexport.h>
#include <Winsock2.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DBG
LPVOID
RSPAlloc(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    );
#else
LPVOID
RSPAlloc(
    DWORD   dwSize
    );
#endif

void
DrvFree(
    LPVOID  p
    );

#if DBG

#define DrvAlloc(x)    RSPAlloc(x, __LINE__, __FILE__)

#else

#define DrvAlloc(x)    RSPAlloc(x)

#endif

#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

#else
#define DBGOUT(arg)
#endif

BOOL OpenServerLookup(HKEY hRegistry);
BOOL GetNextServer(LPSTR pszServerName, DWORD dwSize, BOOL * pbFromReg);
BOOL CloseLookup(void);

typedef int (WSAAPI * PFNWSASTARTUP)(
    WORD                    wVersionRequested,
    LPWSADATA               lpWSAData
    );
typedef int (WSAAPI * PFNWSACLEANUP)(
    VOID
    );
typedef HOSTENT FAR * (WSAAPI * PFNGETHOSTBYNAME)(
    const char FAR *name
    );


typedef HANDLE (WINAPI * PFNICMPCREATEFILE)(
    VOID
    );
typedef BOOL (WINAPI * PFNICMPCLOSEHANDLE)(
    HANDLE                  IcmpHandle
    );
typedef BOOL (WINAPI * PFNICMPSENDECHO)(
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );

typedef struct rspsocket_tag
{
    HMODULE             hWS2;
    HMODULE             hICMP;
    HANDLE              IcmpHandle;

    PFNWSASTARTUP       pFnWSAStartup;
    PFNWSACLEANUP       pFnWSACleanup;
    PFNGETHOSTBYNAME    pFngethostbyname;
    PFNICMPCREATEFILE   pFnIcmpCreateFile;
    PFNICMPCLOSEHANDLE  pFnIcmpCloseHandle;
    PFNICMPSENDECHO     pFnIcmpSendEcho;
} RSPSOCKET, * PRSPSOCKET;

HRESULT SockStartup (
    RSPSOCKET       * pSocket
    );

HRESULT SockIsServerResponding(
    RSPSOCKET       * pSocket,
    char *          szServer
    );

HRESULT SockShutdown (
    RSPSOCKET       * pSocket
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\remotesp\makefile.inc ===
$(O)\rmotsprpc.c: ..\..\idl\$(O)\rmotsp_s.c
    -copy /v $? $@

$(O)\tapsrvrpc.c: ..\..\idl\$(O)\tapsrv_c.c
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\remotesp\imperson.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    impersn.c

ABSTRACT
    Impersonation routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 04-Aug-1995

REVISION HISTORY

    mquinton 8/2/96 - stole this code to use in remotesp

--*/

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
//#include <npapi.h>

#include "utils.h"
#include "imperson.h"

// some constant stuff for registry
#define SHELL_REGKEY            L"\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL            L"shell"
#define DEFAULT_SHELL           L"explorer.exe"

// for remotesp dbgout
#if DBG
#define DBGOUT(arg) DbgPrt arg
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

#else
#define DBGOUT(arg)
#endif

//
// The static information we
// need to impersonate the currently
// logged-in user.
//

HANDLE              ghTokenImpersonation = NULL;

//
// Security attributes and descriptor
// necessary for creating shareable handles.
//

SECURITY_ATTRIBUTES SecurityAttributeG;
SECURITY_DESCRIPTOR SecurityDescriptorG;

PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo()

/*++

DESCRIPTION
    Return a block containing information about all processes
    currently running in the system.

ARGUMENTS
    None.

RETURN VALUE
    A pointer to the system process information or NULL if it could
    not be allocated or retrieved.

--*/

{
    NTSTATUS status;
    PUCHAR pLargeBuffer;
    ULONG ulcbLargeBuffer = 64 * 1024;

    //
    // Get the process list.
    //
    for (;;) {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL) {
            LOG((TL_ERROR,
              "GetSystemProcessInfo: VirtualAlloc failed (status=0x%x)",
              status));
			return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS) break;
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
            LOG((TL_INFO,
              "GetSystemProcesInfo: enlarging buffer to %d",
              ulcbLargeBuffer));
        }
    }

    return (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
} // GetSystemProcessInfo



PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR lpExeName
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeName: a pointer to a Unicode string containing the
        process to be found.

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;

    //
    // Look in the process list for lpExeName.
    //

    for (;;)
    {
        if (pProcessInfo->ImageName.Buffer != NULL) {

            //DBGOUT((
            //    3,
            //    "FindProcessByName: process: %S (%d)",
            //    pProcessInfo->ImageName.Buffer,
            //    pProcessInfo->UniqueProcessId
            //    ));

            if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeName))
            {
                return pProcessInfo;
            }
        }

        //
        // Increment offset to next process information block.
        //

        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }

        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    return NULL;
} // FindProcessByName



VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )

/*++

DESCRIPTION
    Free a buffer returned by GetSystemProcessInfo().

ARGUMENTS
    pProcessInfo: the pointer returned by GetSystemProcessInfo().

RETURN VALUE
    None.

--*/

{
    VirtualFree((PUCHAR)pProcessInfo, 0, MEM_RELEASE);
} // FreeSystemProcessInfo



BOOLEAN
SetProcessImpersonationToken(
    HANDLE hProcess
    )

{
    NTSTATUS status;
    BOOL fDuplicated = FALSE;
    HANDLE hThread, hToken;

    static lCookie = 0;


    //
    // Open the impersonation token for the
    // process we want to impersonate.
    //
    // Note: we use InterlockedExchange as an inexpensive mutex
    //

    while (InterlockedExchange (&lCookie, 1) != 0)
    {
        Sleep (50);
    }

    if (ghTokenImpersonation == NULL)
    {
        if (!OpenProcessToken(
              hProcess,
              TOKEN_ALL_ACCESS,
              &hToken))

        {
            InterlockedExchange (&lCookie, 0);

            LOG((
                TL_ERROR,
                "SetProcessImpersonationToken: OpenProcessToken " \
                    "failed, err=%d",
                GetLastError()
                ));

            return FALSE;
        }

        //
        // Duplicate the impersonation token.
        //

        fDuplicated = DuplicateToken(
                        hToken,
                        TokenImpersonation,
                        &ghTokenImpersonation);

        if (!fDuplicated)
        {
            InterlockedExchange (&lCookie, 0);

            LOG((
                TL_ERROR,
                "SetProcessImpersonationToken: NtSetInformationThread " \
                    "failed, err=%d",
                GetLastError()
                ));

            return FALSE;
        }
    }

    InterlockedExchange (&lCookie, 0);


    //
    // Set the impersonation token on the current
    // thread.  We are now running in the same
    // security context as the supplied process.
    //

    hThread = NtCurrentThread();

    status = NtSetInformationThread(
               hThread,
               ThreadImpersonationToken,
               (PVOID)&ghTokenImpersonation,
               sizeof (ghTokenImpersonation));

    if (status != STATUS_SUCCESS)
    {
        LOG((TL_ERROR,
          "SetProcessImpersonationToken: NtSetInformationThread failed (error=%d)",
          GetLastError()));
    }
    if (fDuplicated)
    {
        CloseHandle(hToken);
        CloseHandle(hThread);
    }

    return (status == STATUS_SUCCESS);

} // SetProcessImpersonationToken



VOID
ClearImpersonationToken()

{
    //
    // Clear the impersonation token on the current
    // thread.  We are now running in LocalSystem
    // security context.
    //
    if (!SetThreadToken(NULL, NULL))
    {
        LOG((TL_ERROR,
          "ClearImpersonationToken: SetThreadToken failed (error=%d)",
          GetLastError()));
    }
} // ClearImpersonationToken



BOOLEAN
GetCurrentlyLoggedOnUser(
    HANDLE *phProcess
    )
{
    BOOLEAN fSuccess = FALSE;
    HKEY hkey;
    DWORD dwType;
    DWORD dwDisp;
    WCHAR szShell[512];
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    PWCHAR psz;
    DWORD dwSize = sizeof (szShell);
    NTSTATUS status;
    HANDLE hProcess = NULL;


    //
    // Get the shell process name.  We will look for this
    // to find out who the currently logged-on user is.
    // Create a unicode string that describes this name.
    //

    wcscpy (szShell, DEFAULT_SHELL);

    if (RegCreateKeyEx(
          HKEY_LOCAL_MACHINE,
          SHELL_REGKEY,
          0,
          NULL,
          REG_OPTION_NON_VOLATILE,
          KEY_ALL_ACCESS,
          NULL,
          &hkey,
          &dwDisp) == ERROR_SUCCESS)

    {
        if (RegQueryValueEx(
              hkey,
              SHELL_REGVAL,
              NULL,
              &dwType,
              (PBYTE)&szShell,
              &dwSize) == ERROR_SUCCESS)

        {
            //
            // Remove parameters from command line.
            //
            psz = szShell;
            while (*psz != L' ' && *psz != L'\0')
                psz++;
            *psz = L'\0';
        }
        RegCloseKey(hkey);
    }
    LOG((TL_INFO,
      "ImpersonateCurrentlyLoggedInUser: shell is %S",
      &szShell));

    //
    // Get the process list.
    //

    pSystemInfo = GetSystemProcessInfo();


    //
    // See if szShell is running.
    //

    pProcessInfo = pSystemInfo ? 
        FindProcessByName(pSystemInfo, (LPTSTR)&szShell) : NULL;

    if (pProcessInfo != NULL)
    {
        HANDLE hToken;

        //
        // Open the process.
        //
        hProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            (DWORD) ((ULONG_PTR) pProcessInfo->UniqueProcessId)
            );

        if (hProcess == NULL)
        {
            LOG((TL_ERROR,
              "ImpersonateCurrentlyLoggedInUser: OpenProcess(x%x) failed (dwErr=%d)",
              pProcessInfo->UniqueProcessId,
              GetLastError()));
        }
        fSuccess = (hProcess != NULL);
    }

    //
    // Free resources.
    //

    if (pSystemInfo)
    {
        FreeSystemProcessInfo(pSystemInfo);
    }

    //
    // Return process handle.
    //

    *phProcess = hProcess;

    return fSuccess;

} // GetCurrentlyLoggedOnUser



VOID
RevertImpersonation()

/*++

DESCRIPTION
    Close all open handles associated with the
    logged-in user who has just logged out.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    CloseHandle (ghTokenImpersonation);
    ghTokenImpersonation = NULL;

} // RevertImpersonation

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\sp\remotesp\remotesp.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    remotesp.c

Abstract:

    This module contains

Author:

    Dan Knudson (DanKn)    09-Aug-1995

Revision History:


Notes:

    In a nutshell, this service provider connects to tapisrv.exe on remote
    pc's via the same rpc interface used by tapi32, and sends the remote
    tapisrv's the same kinds of requests (as defined in \dev\server\line.h
    & phone.h).

    This service provider also acts as an rpc server, receiving async event
    notifications from the remote tapisrv's.  Remote tapisrv's call our
    RemoteSPAttach() function at init time (during our call to their
    ClientAttach() proc) to establish a binding instance, and then can call
    RemoteSPEventProc() to send async events. Since we don't want to block
    the servers for any length of time, we immediately queue the events they
    send us, and a dedicated thread (EventHandlerThread) services this
    queue.

    Now a brief note on handle resolution.  When we open a line or a phone,
    we alloc our own DRVXXX structure to represent this widget, and pass
    tapisrv a pointer to this widget in the open request (see the
    hRemoteLine field in LINEOPEN_PARAMS in line.h).  Then, when remote
    tapisrv's send us events on those lines/phones, they pass us the
    widget pointer we passed them (instead of the normal hLine/hPhone).
    This allows us to easily find and reference our data structure
    associated with this widget.  Dealing with calls is a little more
    problematic, since remote tapisrv's can present incoming calls, and
    there is no clean way to initially specify our own handle to the call
    as with lines or phones.  (A RemoteSPNewCall() function which would
    allow for this handle swapping was considered, but not implemented due
    to possible blocking problems on the remote server.)  The solution
    is to maintain a list of calls in each line structure, and when call
    events are parsed we resolve the hCall by walking the list of calls in
    the corresponding line (tapisrv is nice enough to indicate our line
    pointer in dwParam4 of the relevant messages).  Since we expect client
    machines using remotesp to have a relatively low call bandwidth, this
    look up method should be pretty fast.

--*/
#include <tchar.h>
#include "remotesp.h"
#include "imperson.h"
#include "rmotsp.h"
#include "dslookup.h"
#include "tapihndl.h"
#include "shlwapi.h"
#include "utils.h"

//  defined in server\private.h
#define TAPIERR_INVALRPCCONTEXT     0xF101

#if DBG

BOOL    gfBreakOnSeriousProblems = FALSE;

#define DrvAlloc(x)    RSPAlloc(x, __LINE__, __FILE__)

#else

#define DrvAlloc(x)    RSPAlloc(x)

#endif


#define MODULE_NAME "remotesp.tsp"


typedef struct _ASYNCEVENTMSGRSP
{
    DWORD                   TotalSize;
    DWORD                   InitContext;
    ULONG_PTR               fnPostProcessProcHandle;
    DWORD                   hDevice;

    DWORD                   Msg;
    DWORD                   OpenContext;

    union {

        ULONG_PTR       Param1;
    };

    union {

        ULONG_PTR       Param2;
    };

    union {

        ULONG_PTR       Param3;
    };

    union {

        ULONG_PTR       Param4;
    };

} ASYNCEVENTMSGRSP, *PASYNCEVENTMSGRSP;


HANDLE     ghRSPHeap, ghHandleTable;
LIST_ENTRY gTlsListHead;

#undef DWORD_CAST
#if DBG


#define DWORD_CAST(v,f,l) (((v)>MAXDWORD)?(DbgPrt(0,"DWORD_CAST: information will be lost during cast from %p in file %s, line %d",(v),(f),(l)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))
#define DWORD_CAST_HINT(v,f,l,h) (((v)>MAXDWORD)?(DbgPrt(0,"DWORD_CAST: information will be lost during cast from %p in file %s, line %d, hint %d",(v),(f),(l),(h)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))

#else

#define DWORD_CAST(v,f,l)           ((DWORD)(v))
#define DWORD_CAST_HINT(v,f,l,h)    ((DWORD)(v))
#endif


VOID
CALLBACK
FreeContextCallback(
    LPVOID      Context,
    LPVOID      Context2
    )
{
    if (Context2 == (LPVOID) 1)
    {
        //
        // Special case: don't free the Context
        //
    }
    else if (Context != (LPVOID) -1)
    {
        //
        // The general case, Context is the pointer to free
        //

        DrvFree (Context);
    }
}


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        gpStaleInitContexts = NULL;
        gdwNumStaleInitContexts = 0;

#if DBG

    {
        HKEY    hTelephonyKey;
        DWORD   dwDataSize, dwDataType;
        TCHAR   szRemotespDebugLevel[] = "RemotespDebugLevel";


        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszTelephonyKey,
            0,
            KEY_ALL_ACCESS,
            &hTelephonyKey
            );

        dwDataSize = sizeof (DWORD);
        gdwDebugLevel=0;

        RegQueryValueEx(
            hTelephonyKey,
            szRemotespDebugLevel,
            0,
            &dwDataType,
            (LPBYTE) &gdwDebugLevel,
            &dwDataSize
            );

        RegCloseKey (hTelephonyKey);
    }

#endif

        //
        //
        //

        LOG((TL_INFO, "DLL_PROCESS_ATTACH"));

        ghInst = hDLL;


        //
        // Allocate a private heap (use process heap if that fails)
        //

        if (!(ghRSPHeap = HeapCreate(
                0,      // return NULL on failure, serialize access
                0x1000, // initial heap size
                0       // max heap size (0 == growable)
                )))
        {
            ghRSPHeap = GetProcessHeap();
        }


        //
        //
        //

        if (!(ghHandleTable = CreateHandleTable(
                ghRSPHeap,
                FreeContextCallback,
                0x10000000,
                0x7fffffff
                )))
        {
            LOG((TL_ERROR, "DLL_PROCESS_ATTACH, CreateHandleTable() failed"));

            return FALSE;
        }


        //
        // Alloc a Tls index
        //

        if ((gdwTlsIndex = TlsAlloc()) == 0xffffffff)
        {
            LOG((TL_ERROR, "DLL_PROCESS_ATTACH, TlsAlloc() failed"));

            return FALSE;
        }


        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);


        //
        // Init a couple of critical sections for serializing
        // access to resources
        //

        InitializeCriticalSection (&gEventBufferCriticalSection);
        InitializeCriticalSection (&gCallListCriticalSection);
        InitializeCriticalSection (&gcsTlsList);
        TapiInitializeCriticalSectionAndSpinCount (&gCriticalSection, 100);

        InitializeListHead (&gTlsListHead);


        //
        // Load the device icons
        //

        {
            HINSTANCE hUser;
            typedef HICON ( WINAPI PLOADICON(
                                               HINSTANCE hInstance,
                                               LPCTSTR   lpIconName
                                             ));
            PLOADICON *pLoadIcon;



            hUser = LoadLibrary( "USER32.DLL" );
            if ( NULL == hUser )
            {
                LOG((TL_ERROR, "Couldn't load USER32.DLL!!"));
                break;
            }

            pLoadIcon = (PLOADICON *)GetProcAddress( hUser, "LoadIconA");
            if ( NULL == pLoadIcon )
            {
                LOG((TL_ERROR, "Couldn't load LoadIconA()!!"));
                FreeLibrary( hUser );
                break;
            }

            ghLineIcon  = pLoadIcon( hDLL, MAKEINTRESOURCE(IDI_ICON3) );
            ghPhoneIcon = pLoadIcon( hDLL, MAKEINTRESOURCE(IDI_ICON2) );

            FreeLibrary( hUser );
        }

        gEventHandlerThreadParams.hMailslot = INVALID_HANDLE_VALUE;
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        PRSP_THREAD_INFO    pTls;


        LOG((TL_INFO, "DLL_PROCESS_DETACH"));


        //
        // Clean up any Tls (no need to enter crit sec since process detaching)
        //

        while (!IsListEmpty (&gTlsListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList (&gTlsListHead);

            pTls = CONTAINING_RECORD (pEntry, RSP_THREAD_INFO, TlsList);

            DrvFree (pTls->pBuf);
            DrvFree (pTls);
        }

        TlsFree (gdwTlsIndex);


        //
        // Free the critical sections & icons
        //

        DeleteCriticalSection (&gEventBufferCriticalSection);
        DeleteCriticalSection (&gCallListCriticalSection);
        DeleteCriticalSection (&gcsTlsList);
        TapiDeleteCriticalSection (&gCriticalSection);

        {
            HINSTANCE hUser;
            typedef BOOL ( WINAPI PDESTROYICON(
                                               HICON hIcon
                                             ));
            PDESTROYICON *pDestroyIcon;



            hUser = LoadLibrary( "USER32.DLL" );
            if ( NULL == hUser )
            {
                LOG((TL_ERROR, "Couldn't load USER32.DLL!!d"));
                break;
            }

            pDestroyIcon = (PDESTROYICON *)GetProcAddress( hUser, "DestroyIcon");
            if ( NULL == pDestroyIcon )
            {
                LOG((TL_ERROR, "Couldn't load DestroyIcon()!!"));
                FreeLibrary( hUser );
                break;
            }

            pDestroyIcon (ghLineIcon);
            pDestroyIcon (ghPhoneIcon);


            FreeLibrary( hUser );
        }

        DeleteHandleTable (ghHandleTable);

        if (ghRSPHeap != GetProcessHeap())
        {
            HeapDestroy (ghRSPHeap);
        }

        break;
    }
    case DLL_THREAD_ATTACH:

        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);

        break;

    case DLL_THREAD_DETACH:
    {
        PRSP_THREAD_INFO    pTls;


        //
        // Clean up any Tls
        //

        if ((pTls = (PRSP_THREAD_INFO) TlsGetValue (gdwTlsIndex)))
        {
            EnterCriticalSection (&gcsTlsList);

            RemoveEntryList (&pTls->TlsList);

            LeaveCriticalSection (&gcsTlsList);

            if (pTls->pBuf)
            {
                DrvFree (pTls->pBuf);
            }

            DrvFree (pTls);
        }

        break;
    }
    } // switch

    return TRUE;
}


BOOL
PASCAL
IsValidObject(
    PVOID   pObject,
    DWORD   dwKey
    )
{
    BOOL fResult;

    try
    {
        fResult = (*((LPDWORD) pObject) == dwKey);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        fResult = FALSE;
    }

    return fResult;
}


void LogRemoteSPError(CHAR * szServer, DWORD dwErrorContext, 
                      DWORD dwErrorCode, DWORD dwErrorDet,
                      BOOL bNoKeyCreation)
{
    HKEY    hKeyServer = NULL;
    DWORD   dwDisposition;
    CHAR    szRegKeyServer[255];

    if (!szServer)
    {
        goto ExitHere;
    }
    wsprintf(szRegKeyServer, "%s\\Provider%d\\", 
            gszTelephonyKey, gdwPermanentProviderID);
    lstrcat(szRegKeyServer, szServer);
    if (bNoKeyCreation)
    {
        //  If the logging is requested from NetworkPollThread
        //  do not create ProviderN key if not exist already
        if (ERROR_SUCCESS != RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    szRegKeyServer,
                    0,
                    KEY_WRITE,
                    &hKeyServer
                    ))
        {
            goto ExitHere;
        }
    }
    else
    {
        if (ERROR_SUCCESS != RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szRegKeyServer,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKeyServer,
                    &dwDisposition))
        {
            goto ExitHere;
        }
    }
    RegSetValueExW (hKeyServer,
                    L"ErrorContext",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwErrorContext,
                    sizeof(dwErrorContext));
    RegSetValueExW (hKeyServer,
                    L"ErrorCode",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwErrorCode,
                    sizeof(dwErrorCode));
    RegSetValueExW (hKeyServer,
                    L"ErrorDetail",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwErrorDet,
                    sizeof(dwErrorCode));
    
ExitHere:
    if (hKeyServer)
    {
        RegCloseKey(hKeyServer);
    }
    return;
}

//
//  Function get called when the remotesp lost connection with the
//  remote server and the status is detected
//
LONG
OnServerDisconnected(PDRVSERVER pServer)
{
    LONG            lResult = 0;

    TapiEnterCriticalSection(&gCriticalSection);

    if ( gEventHandlerThreadParams.bExit )
    {
        goto ExitHere;
    }

    //
    //  It is possible we come here durning FinishEnumDevices
    //  in which case pServer is not in any double link list
    //
    if (pServer->ServerList.Flink == NULL || 
        pServer->ServerList.Blink == NULL)
    {
        goto ExitHere;
    }

    //
    //  Bail if not transiting from connected to disconnected state
    //  otherwise set the disconnection flag
    //
    if (pServer->dwFlags & SERVER_DISCONNECTED)
    {
        goto ExitHere;
    }
    pServer->dwFlags |= SERVER_DISCONNECTED;

    TapiLeaveCriticalSection (&gCriticalSection);

    //
    // Leave Shutdown() outside of the CS to avoid deadlock
    //
    Shutdown (pServer);
    
    TapiEnterCriticalSection(&gCriticalSection);

    if ( gEventHandlerThreadParams.bExit )
    {
        goto ExitHere;
    }

    //
    //  Put this server into the gNptListHead so that the 
    //  NetworkPollThread will try to re-establish the connection
    //
    RemoveEntryList (&pServer->ServerList);
    InsertTailList (&gNptListHead, &pServer->ServerList);

    //
    //  Start the NetworkPollThread if not started yet
    //
    if (ghNetworkPollThread == NULL)
    {
        DWORD       dwTID;
        
        ghNptShutdownEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (!ghNptShutdownEvent)
        {
            LOG((TL_ERROR, "OnServerDisconnected: Unable to create poll thread! Argh!"));
        }
        else
        {
            if (!(ghNetworkPollThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) NetworkPollThread,
                    (LPVOID) gpszThingToPassToServer,
                    0,
                    &dwTID
                    )))
            {
                LOG((TL_ERROR, "OnServerDisconnected: Unable to create poll thread! Argh!"));
                CloseHandle (ghNptShutdownEvent);
                ghNptShutdownEvent = NULL;
            }
        }

        if (!ghNptShutdownEvent || !ghNetworkPollThread)
        {

            // Failed to create Network Poll Thread
            // Ignore this server
            while (!IsListEmpty (&gNptListHead))
            {
                PDRVSERVER  pServer;
                LIST_ENTRY  *pEntry = RemoveHeadList (&gNptListHead);

                pServer = CONTAINING_RECORD (pEntry, DRVSERVER, ServerList);
                DereferenceObject(ghHandleTable, pServer->InitContext, 1);
            }
        }
    }

ExitHere:

    TapiLeaveCriticalSection (&gCriticalSection);

    return lResult;
}

//
//  Function get called when remotesp is able to re-establis the
//  connection with the remote server after losing it
//
LONG
OnServerConnected(PDRVSERVER pServer)
{
    LONG        lResult = 0;
    
    //
    //  Clear the disconnection bit
    //
    TapiEnterCriticalSection(&gCriticalSection);
    pServer->dwFlags &= (~SERVER_DISCONNECTED);
    pServer->bShutdown = FALSE;
    TapiLeaveCriticalSection(&gCriticalSection);

    return lResult;
}

PASYNCEVENTMSG
GetEventFromQueue(
    )
{
    BOOL            bAllocFailed = FALSE;
    DWORD           dwMsgSize, dwUsedSize, dwMoveSize, dwMoveSizeReal,
                    dwMoveSizeWrapped, dwMoveSizeWrappedReal;
    PASYNCEVENTMSG  pMsg;


    //
    // Enter the critical section to serialize access to the event
    // queue, and grab an event from the queue.  Copy it to our local
    // event buf so that we can leave the critical section asap and
    // not block other threads writing to the queue.
    //

    EnterCriticalSection (&gEventBufferCriticalSection);


    //
    // If there are no events in the queue return NULL
    //

    if (gEventHandlerThreadParams.dwEventBufferUsedSize == 0)
    {

GetEventFromQueue_noEvents:

        pMsg = NULL;

        //
        // Take this opportunity to tidy up a bit.  The reasoning for doing
        // this is that we should be reducing the odds we'll have to wrap
        // at the end of the buffer, or at least, put off dealing with such
        // things until later (as the non-wrap code executes quickest)
        //

        gEventHandlerThreadParams.pDataOut =
        gEventHandlerThreadParams.pDataIn  =
            gEventHandlerThreadParams.pEventBuffer;

        ResetEvent (gEventHandlerThreadParams.hEvent);

        goto GetEventFromQueue_done;
    }


    //
    // Determine the size of this msg & the num bytes to the end of the
    // event buffer, then from these get the MoveSize & MoveSizeWrapped
    // values
    //

    dwMsgSize = (DWORD) ((PASYNCEVENTMSG)
        gEventHandlerThreadParams.pDataOut)->TotalSize;

    if ((dwMsgSize & 0x3)  ||
        (dwMsgSize > gEventHandlerThreadParams.dwEventBufferTotalSize))
    {
        //
        // Something is corrupt (the msg or our queue), so just nuke
        // everything in the queue and bail out
        //

        LOG((TL_ERROR, "GetEventFromQueue: ERROR! bad msgSize=x%x", dwMsgSize));

        gEventHandlerThreadParams.dwEventBufferUsedSize = 0;

        goto GetEventFromQueue_noEvents;
    }

    dwUsedSize = (DWORD) ((gEventHandlerThreadParams.pEventBuffer +
        gEventHandlerThreadParams.dwEventBufferTotalSize)  -
        gEventHandlerThreadParams.pDataOut);

    if (dwMsgSize <= dwUsedSize)
    {
        dwMoveSize        = dwMoveSizeReal = dwMsgSize;
        dwMoveSizeWrapped = 0;
    }
    else
    {
        dwMoveSize        = dwMoveSizeReal        = dwUsedSize;
        dwMoveSizeWrapped = dwMoveSizeWrappedReal = dwMsgSize - dwUsedSize;
    }


    //
    // See if we need to grow the msg buffer before we copy
    //

    if (dwMsgSize > gEventHandlerThreadParams.dwMsgBufferTotalSize)
    {
        if ((pMsg = DrvAlloc (dwMsgSize)))
        {
            DrvFree (gEventHandlerThreadParams.pMsgBuffer);

            gEventHandlerThreadParams.pMsgBuffer = (LPBYTE) pMsg;
            gEventHandlerThreadParams.dwMsgBufferTotalSize = dwMsgSize;
        }
        else
        {
            //
            // Couldn't alloc a bigger buf, so try to complete this
            // msg as gracefully as possible, i.e. set the XxxReal
            // vars so that we'll only actually copy over the fixed
            // size of the msg (but the event buf ptrs will still
            // get updated correctly) and set a flag to say that
            // we need to do some munging on the msg before returning
            //

            dwMoveSizeReal = (dwMoveSizeReal <= sizeof (ASYNCEVENTMSG) ?
                dwMoveSizeReal : sizeof (ASYNCEVENTMSG));

            dwMoveSizeWrappedReal = (dwMoveSizeReal < sizeof (ASYNCEVENTMSG) ?
                sizeof (ASYNCEVENTMSG) - dwMoveSizeReal : 0);

            bAllocFailed = TRUE;
        }
    }


    //
    // Copy the msg from the event buf to the msg buf, and update the
    // event buf pointers
    //

    pMsg = (PASYNCEVENTMSG) gEventHandlerThreadParams.pMsgBuffer;

    CopyMemory (pMsg, gEventHandlerThreadParams.pDataOut, dwMoveSizeReal);

    if (dwMoveSizeWrapped)
    {
        CopyMemory(
            ((LPBYTE) pMsg) + dwMoveSizeReal,
            gEventHandlerThreadParams.pEventBuffer,
            dwMoveSizeWrappedReal
            );

        gEventHandlerThreadParams.pDataOut =
            gEventHandlerThreadParams.pEventBuffer + dwMoveSizeWrapped;
    }
    else
    {
        gEventHandlerThreadParams.pDataOut += dwMoveSize;


        //
        // If msg ran to end of the event buffer then reset pDataOut
        //

        if (gEventHandlerThreadParams.pDataOut >=
            (gEventHandlerThreadParams.pEventBuffer +
                gEventHandlerThreadParams.dwEventBufferTotalSize))
        {
            gEventHandlerThreadParams.pDataOut =
                gEventHandlerThreadParams.pEventBuffer;
        }
    }

    gEventHandlerThreadParams.dwEventBufferUsedSize -= dwMsgSize;


    //
    // Special msg param munging in case an attempt to grow the
    // buffer size above failed
    //

    if (bAllocFailed)
    {
        switch (pMsg->Msg)
        {
        case LINE_REPLY:

            pMsg->Param2 = LINEERR_NOMEM;
            break;

        case PHONE_REPLY:

            pMsg->Param2 = PHONEERR_NOMEM;
            break;

        default:

            break;
        }
    }

GetEventFromQueue_done:

    LeaveCriticalSection (&gEventBufferCriticalSection);

    return pMsg;
}


BOOL
GetEventsFromServer(
    DWORD   dwInitContext
    )
{
    BOOL            bResult = FALSE;
    DWORD           dwUsedSize, dwRetryCount;
    PDRVSERVER      pServer;
    PTAPI32_MSG     pMsg;


    if (!(pServer = (PDRVSERVER) ReferenceObject(
            ghHandleTable,
            dwInitContext,
            gdwDrvServerKey
            )) ||
        pServer->bShutdown)
    {
        LOG((TL_ERROR, "GetEventsFromServer: bad InitContext=x%x", dwInitContext));

        if (pServer)
        {
            DereferenceObject (ghHandleTable, dwInitContext, 1);
        }

        return FALSE;
    }

getEvents:

    dwRetryCount = 0;
    pMsg = (PTAPI32_MSG) gEventHandlerThreadParams.pMsgBuffer;

    do
    {
        pMsg->u.Req_Func = xGetAsyncEvents;
        pMsg->Params[0]  = gEventHandlerThreadParams.dwMsgBufferTotalSize -
            sizeof (TAPI32_MSG);

        dwUsedSize = sizeof (TAPI32_MSG);

        RpcTryExcept
        {
            ClientRequest(
                pServer->phContext,
                (char *) pMsg,
                gEventHandlerThreadParams.dwMsgBufferTotalSize,
                &dwUsedSize
                );

            if (pMsg->u.Ack_ReturnValue == TAPIERR_INVALRPCCONTEXT)
            {
                OnServerDisconnected (pServer);
                pMsg->u.Ack_ReturnValue = LINEERR_OPERATIONFAILED;
            }
            dwRetryCount = gdwRetryCount;
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_INFO,
                "GetEventsFromServer: rpc exception %d handled",
                RpcExceptionCode()
                ));

            dwRetryCount++;

            if (dwRetryCount < gdwRetryCount)
            {
                Sleep (gdwRetryTimeout);
            }
            else
            {
                unsigned long ulResult = RpcExceptionCode();

                if ((ulResult == RPC_S_SERVER_UNAVAILABLE)  ||
                    (ulResult == ERROR_INVALID_HANDLE))
                {
                    OnServerDisconnected (pServer);

                    LOG((TL_ERROR,
                        "GetEventsFromServer: server '%s' unavailable",
                        pServer->szServerName
                        ));
                }

                pMsg->u.Ack_ReturnValue = LINEERR_OPERATIONFAILED;
            }
        }
        RpcEndExcept

    } while (dwRetryCount < gdwRetryCount);

    if (pMsg->u.Ack_ReturnValue == 0)
    {
        DWORD   dwNeededSize = (DWORD) pMsg->Params[1],
                dwUsedSize = (DWORD) pMsg->Params[2];


        if (dwUsedSize)
        {
            RemoteSPEventProc(
                (PCONTEXT_HANDLE_TYPE2) IntToPtr(0xfeedface),
                (unsigned char *) (pMsg + 1),
                dwUsedSize
                );


            //
            // RemoteSPEventProc will set the byte pointed to by (pMsg+1)
            // to non-zero on success, or zero on error (indicating
            // bad data in the event buffer, which we'll discard)
            //

            if (*((unsigned char *) (pMsg + 1)) != 0)
            {
                bResult = TRUE;
            }
            else
            {
                bResult = FALSE;
                goto GetEventsFromServer_dereference;
            }
        }

        if (dwNeededSize > dwUsedSize)
        {
            //
            // There's still more data to retrieve on the server.
            // Grow the buffer so we can get it all next time.
            //

            DWORD   dwNewSize = dwNeededSize + 256;
            LPVOID  p;


            if ((p = DrvAlloc (dwNewSize)))
            {
                DrvFree (gEventHandlerThreadParams.pMsgBuffer);

                gEventHandlerThreadParams.pMsgBuffer = p;
                gEventHandlerThreadParams.dwMsgBufferTotalSize = dwNewSize;
            }
            else if (dwUsedSize == 0)
            {
            }

            goto getEvents;
        }
    }

GetEventsFromServer_dereference:

    DereferenceObject (ghHandleTable, dwInitContext, 1);

    return bResult;
}


void
EventHandlerThread(
    LPVOID  pParams
    )
{
    //
    // NOTES:
    //
    // 1. depending on server side implementation, we may experience race
    //    conditions where msgs that we expect to show up in a certain
    //    sequence show up out of sequence (i.e. call state msgs that show
    //    up before make call completion msgs), which could present problems.
    //
    //    one solution is to to queue call state/info msgs to incomplete
    //    calls (to be sent after call is completed).  another is not to send
    //    any call state msgs after the idle is received
    //

    DWORD           dwMsgSize, dwNumObjects, dwResult, dwData,
                    dwNumBytesRead, dwTimeout;
    HANDLE          ahObjects[2];
    OVERLAPPED      overlapped;
    PASYNCEVENTMSG  pMsg;
    HANDLE            hProcess;

    LOG((TL_INFO, "EventHandlerThread: enter"));

    //
    // This thread has no user context, which prevents it from rpc'ing
    // back to remote tapisrv when/if necessary.  So, find the user
    // that is logged on and impersonate them in this thread.
    //

    if (!GetCurrentlyLoggedOnUser (&hProcess))
    {
        LOG((TL_ERROR, "GetCurrentlyLoggedOnUser failed"));
    }
    else
    {
        if (!SetProcessImpersonationToken(hProcess))
        {
            LOG((TL_ERROR, "SetProcessImpersonationToken failed"));
        }
    }

    //
    // Bump up the thread priority a bit so we don't get starved by
    // ill-behaved apps
    //

    if (!SetThreadPriority(
            GetCurrentThread(),
            THREAD_PRIORITY_ABOVE_NORMAL
            ))
    {
        LOG((TL_ERROR,
            "EventHandlerThread: SetThreadPriority failed, err=%d",
            GetLastError()
            ));
    }

    ahObjects[0] = gEventHandlerThreadParams.hEvent;

    if (gEventHandlerThreadParams.hMailslot != INVALID_HANDLE_VALUE)
    {
        ZeroMemory (&overlapped, sizeof (overlapped));

        ahObjects[1] =
        overlapped.hEvent = gEventHandlerThreadParams.hMailslotEvent;

        dwNumObjects = 2;

        if (!ReadFile(
                gEventHandlerThreadParams.hMailslot,
                &dwData,
                sizeof (dwData),
                &dwNumBytesRead,
                &overlapped
                )

            &&  (GetLastError() != ERROR_IO_PENDING))
        {
            LOG((TL_ERROR,
                "EventHandlerThread: ReadFile failed, err=%d",
                GetLastError()
                ));
        }

        dwTimeout = MAX_MAILSLOT_TIMEOUT;
    }
    else
    {
        dwNumObjects = 1;

        dwTimeout = INFINITE;
    }

    while (1)
    {
        //
        // Wait for an event to show up in the queue or for a msg
        // to show up in the mailslot
        //

        dwResult = WaitForMultipleObjects(
            dwNumObjects,
            ahObjects,
            FALSE,
            dwTimeout
            );

        if (gEventHandlerThreadParams.bExit)
        {
            break;
        }

        switch (dwResult)
        {
        case WAIT_OBJECT_0:

            //
            // Simply break & process the events
            //

            break;

        case WAIT_OBJECT_0+1:

            //
            // Post another read, the retrieve & process the events
            //

            if (!ReadFile(
                    gEventHandlerThreadParams.hMailslot,
                    &dwData,
                    sizeof (dwData),
                    &dwNumBytesRead,
                    &overlapped
                    )

                &&  (GetLastError() != ERROR_IO_PENDING))
            {
                LOG((TL_ERROR,
                    "EventHandlerThread: ReadFile failed, err=%d",
                    GetLastError()
                    ));
            }

            if (GetEventsFromServer (dwData))
            {
                dwTimeout = MIN_MAILSLOT_TIMEOUT;
            }

            break;

        case WAIT_TIMEOUT:
        {

#define DWORD_ARRAY_BLOCK_SIZE    128

            //
            // Check to see if any of the mailslot servers have
            // events waiting for us
            //

            BOOL            bGotSomeEvents  = FALSE;
            PDRVSERVER      pServer;
            LIST_ENTRY *    pEntry;
            DWORD *         pArray          = NULL;
            DWORD *         pTempArray      = NULL;
            DWORD           dwEntriesCount  = 0;
            DWORD           dwEntriesUsed   = 0;
            DWORD           dwIdx;
            BOOL            bAddOK;

            pArray = (DWORD *) DrvAlloc ( sizeof(DWORD) * DWORD_ARRAY_BLOCK_SIZE );

            if ( pArray )
            {
                dwEntriesCount  = DWORD_ARRAY_BLOCK_SIZE;
            }

            TapiEnterCriticalSection(&gCriticalSection);
            
            for(
                pEntry = gpCurrentInitContext->ServerList.Flink;
                pEntry != &gpCurrentInitContext->ServerList;
                // null op
                )
            {
                PDRVSERVER pServer;


                pServer = CONTAINING_RECORD(
                    pEntry,
                    DRVSERVER,
                    ServerList
                    );
                pEntry = pEntry->Flink;
                
                if (!pServer->bConnectionOriented  &&
                    pServer->dwFlags == 0)
                {
                    //
                    // if possible, store the InitContext and postpone 
                    // the RPC call for after we leave the Crit. Sec. 
                    //

                    bAddOK = FALSE;
                    
                    if ( pArray )
                    {

                        if ( dwEntriesCount == dwEntriesUsed )
                        {
                            //
                            // need to increase the array size
                            //

                            pTempArray = (DWORD *) DrvAlloc (
                                    sizeof(DWORD) * (DWORD_ARRAY_BLOCK_SIZE + dwEntriesCount)
                                    );

                            if ( pTempArray )
                            {

                                bAddOK = TRUE;
                                CopyMemory(
                                    pTempArray,
                                    pArray,
                                    sizeof(DWORD) * dwEntriesCount
                                    );
                                dwEntriesCount += DWORD_ARRAY_BLOCK_SIZE;
                                DrvFree( pArray );
                                pArray = pTempArray;

                            }
                        }
                        else
                        {
                            bAddOK = TRUE;
                        }

                        if ( bAddOK )
                        {
                            pArray[ dwEntriesUsed++ ] = pServer->InitContext;
                        }
                    }

                    if ( !bAddOK )
                    {
                        if (GetEventsFromServer (pServer->InitContext))
                        {
                            bGotSomeEvents = TRUE;
                        }
                    }
                }
            }

            TapiLeaveCriticalSection(&gCriticalSection);

            if ( pArray )
            {
                for( dwIdx = 0; dwIdx < dwEntriesUsed; dwIdx++ )
                {
                    if (GetEventsFromServer (pArray[ dwIdx ]))
                    {
                        bGotSomeEvents = TRUE;
                    }
                }

                DrvFree( pArray );
            }

            if (bGotSomeEvents)
            {
                dwTimeout = MIN_MAILSLOT_TIMEOUT;
            }
            else if (dwTimeout < MAX_MAILSLOT_TIMEOUT)
            {
                dwTimeout += 500;
            }

            break;
        }
        default:

            //
            // Print a dbg msg & process any available events
            //

            LOG((TL_ERROR,
                "EventHandlerThread: WaitForMultObjs failed, result=%d/err=%d",
                dwResult,
                GetLastError()
                ));

            break;
        }


        //
        // Process the events in the queue
        //

        while ((pMsg = GetEventFromQueue()))
        {
            //
            // First validate the pDrvServer pointer in the msg
            //

            PDRVLINE    pLine;
            PDRVPHONE   pPhone;
            PDRVSERVER  pServer;


            if (!(pServer = ReferenceObject(
                    ghHandleTable,
                    pMsg->InitContext,
                    gdwDrvServerKey
                    )))
            {
                LOG((TL_ERROR,
                    "EventHandlerThread: bad InitContext=x%x in msg",
                    pMsg->InitContext
                    ));

                continue;
            }


            switch (pMsg->Msg)
            {
            case LINE_CREATEDIALOGINSTANCE:

                break;

            case LINE_PROXYREQUEST:

                break;

            case LINE_ADDRESSSTATE:
            case LINE_AGENTSTATUS:
            case LINE_AGENTSESSIONSTATUS:
            case LINE_QUEUESTATUS:
            case LINE_AGENTSTATUSEX:
            case LINE_GROUPSTATUS:
            case LINE_PROXYSTATUS:

                if ((pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVLINE_KEY
                        )))
                {
                    (*gpfnLineEventProc)(
                        pLine->htLine,
                        0,
                        pMsg->Msg,
                        pMsg->Param1,
                        pMsg->Param2,
                        pMsg->Param3
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case LINE_AGENTSPECIFIC:
            {
                DWORD       hDeviceCallback = (DWORD) (pMsg->Param4 ?
                                pMsg->Param4 : pMsg->hDevice);
                PDRVCALL    pCall;
                HTAPICALL   htCall;


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        hDeviceCallback,
                        DRVLINE_KEY
                        )))
                {
                    break;
                }

                if (pMsg->Param4)
                {
                    EnterCriticalSection (&gCallListCriticalSection);

                    pCall = (PDRVCALL) pLine->pCalls;

                    while (pCall && (pCall->hCall != (HCALL) pMsg->hDevice))
                    {
                        pCall = pCall->pNext;
                    }

                    if (!pCall  ||  pCall->dwKey != DRVCALL_KEY)
                    {
                        LeaveCriticalSection (&gCallListCriticalSection);
                        DereferenceObject (ghHandleTable, hDeviceCallback, 1);
                        break;
                    }

                    htCall = pCall->htCall;

                    LeaveCriticalSection (&gCallListCriticalSection);
                }
                else
                {
                    htCall = 0;
                }

                (*gpfnLineEventProc)(
                    pLine->htLine,
                    htCall,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

                DereferenceObject (ghHandleTable, hDeviceCallback, 1);

                break;
            }
            case LINE_CALLINFO:
            case LINE_CALLSTATE:
            case LINE_GENERATE:
            case LINE_MONITORDIGITS:
            case LINE_MONITORMEDIA:
            case LINE_MONITORTONE:
            {
                //
                // For all the msgs where hDevice refers to a call tapisrv
                // will pass us the pLine (hRemoteLine) for that call in
                // dwParam4 to make the lookup of the corresponding pCall
                // easier
                //

                HCALL       hCall = (HCALL) pMsg->hDevice;
                PDRVCALL    pCall;
                HTAPICALL   htCall;
                ASYNCEVENTMSGRSP MsgRsp;


                MsgRsp.TotalSize = pMsg->TotalSize;
                MsgRsp.InitContext = pMsg->InitContext;
                MsgRsp.fnPostProcessProcHandle = pMsg->fnPostProcessProcHandle;
                MsgRsp.hDevice = pMsg->hDevice;
                MsgRsp.Msg = pMsg->Msg;
                MsgRsp.OpenContext = pMsg->OpenContext;
                MsgRsp.Param1 = pMsg->Param1;
                MsgRsp.Param2 = pMsg->Param2;
                MsgRsp.Param3 = pMsg->Param3;
                MsgRsp.Param4 = pMsg->Param4;


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->Param4,
                        DRVLINE_KEY
                        )))
                {
                    break;
                }

                EnterCriticalSection (&gCallListCriticalSection);

                pCall = (PDRVCALL) pLine->pCalls;

                while (pCall && (pCall->hCall != hCall))
                {
                    pCall = pCall->pNext;
                }

                if (!pCall  ||  pCall->dwKey != DRVCALL_KEY)
                {
                    LeaveCriticalSection (&gCallListCriticalSection);
                    DereferenceObject (ghHandleTable, pMsg->Param4, 1);
                    LOG((TL_ERROR,"EventHandlerThread: Bad hCall(cs) x%lx",hCall));
                    break;
                }

                htCall = pCall->htCall;
#if DBG
                if ( 0 == htCall )
                {
                    LOG((TL_ERROR, "htCall is now NULL! pCall=x%lx", pCall));
                }
#endif
                if ( LINE_CALLINFO == MsgRsp.Msg )
                {
                    pCall->dwDirtyStructs |= STRUCTCHANGE_LINECALLINFO;

                    if (MsgRsp.Param1 & LINECALLINFOSTATE_DEVSPECIFIC)
                    {
                        pCall->dwDirtyStructs |= STRUCTCHANGE_LINECALLSTATUS;
                    }
                    if (MsgRsp.Param1 & (LINECALLINFOSTATE_CALLID |
                            LINECALLINFOSTATE_RELATEDCALLID))
                    {
                        pCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;
                    }
                }
                else if (LINE_CALLSTATE == MsgRsp.Msg )
                {
                    pCall->dwDirtyStructs |= STRUCTCHANGE_LINECALLSTATUS;


                    //
                    // If the state == CONFERENCED then dwParam2 should
                    // contain the hConfCall.  Note that the real dwParam2
                    // actually lives in MsgRsp.pfnPostProcessProc (see note
                    // below), so we retrieve it from there and (if non-NULL)
                    // try to map it to an htCall, then write the htCall
                    // value back to MsgRsp.pfnPostProcessProc.
                    //

                    if (MsgRsp.Param1 == LINECALLSTATE_CONFERENCED  &&
                        MsgRsp.fnPostProcessProcHandle)
                    {
                        HCALL     hConfCall = (HCALL) DWORD_CAST(MsgRsp.fnPostProcessProcHandle,__FILE__,__LINE__);
                        PDRVCALL  pConfCall = (PDRVCALL) pLine->pCalls;


                        while (pConfCall && (pConfCall->hCall != hConfCall))
                        {
                            pConfCall = pConfCall->pNext;
                        }

                        if (!pConfCall  ||  pConfCall->dwKey != DRVCALL_KEY)
                        {
                            LOG((TL_ERROR,
                                "EventHandlerThread: Bad pConfCall(cs) x%lx",
                                pCall
                                ));

                            MsgRsp.fnPostProcessProcHandle = 0;
                        }
                        else
                        {
                            MsgRsp.fnPostProcessProcHandle = (ULONG_PTR)(pConfCall->htCall);
                        }
                    }


                    //
                    // HACK ALERT!
                    //
                    // The remote tapisrv will pass us the call privilege
                    // in MsgRsp.dwParam2, and the real dwParam2 (the call
                    // state mode) in MsgRsp.pfnPostProcess.  For the very
                    // 1st CALLSTATE msg for an incoming call we want to
                    // indicate the appropriate privilege to the local
                    // tapisrv so it knows whether or not it needs to find
                    // find a local owner for the call.  So, we save the
                    // privilege & real dwParam2 in the call struct and
                    // pass a pointer to these in dwParam2.
                    //
                    // For all other cases we set MsgRsp.dwParam2 to the
                    // real dwParam2 in MsgRsp.pfnPostProcess.
                    //

                    if (!pCall->dwInitialPrivilege)
                    {
                        pCall->dwInitialCallStateMode = MsgRsp.fnPostProcessProcHandle;

                        pCall->dwInitialPrivilege = MsgRsp.Param2;

                        MsgRsp.Param2 = (ULONG_PTR)
                            &pCall->dwInitialCallStateMode;
                    }
                    else
                    {
                        MsgRsp.Param2 = MsgRsp.fnPostProcessProcHandle;
                    }
                }

                LeaveCriticalSection (&gCallListCriticalSection);

                if (MsgRsp.Msg == LINE_MONITORTONE)
                {
                    MsgRsp.Param2 = 0;
                }

                (*gpfnLineEventProc)(
                    pLine->htLine,
                    htCall,
                    MsgRsp.Msg,
                    MsgRsp.Param1,
                    MsgRsp.Param2,
                    MsgRsp.Param3
                    );

                DereferenceObject (ghHandleTable, pMsg->Param4, 1);

                break;
            }
            case LINE_DEVSPECIFIC:
            case LINE_DEVSPECIFICFEATURE:
            {
                //
                // For all the msgs where hDevice refers to a call tapisrv
                // will pass us the pLine (hRemoteLine) for that call in
                // dwParam4 to make the lookup of the corresponding pCall
                // easier
                //

                HTAPICALL htCall;
                DWORD     hDeviceCallback = (DWORD) (pMsg->Param4 ?
                              pMsg->Param4 : pMsg->hDevice);


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        hDeviceCallback,
                        DRVLINE_KEY
                        )))
                {
                    break;
                }

                if (pMsg->Param4)
                {
                    HCALL       hCall = (HCALL) pMsg->hDevice;
                    PDRVCALL    pCall;


                    EnterCriticalSection (&gCallListCriticalSection);

                    pCall = (PDRVCALL) pLine->pCalls;

                    while (pCall && (pCall->hCall != hCall))
                    {
                        pCall = pCall->pNext;
                    }

                    if (pCall)
                    {
                        if (pCall->dwKey != DRVCALL_KEY)
                        {
                            LeaveCriticalSection (&gCallListCriticalSection);

                            LOG((TL_ERROR,
                                "EventHandlerThread: Bad pCall(ds) x%lx",
                                pCall
                                ));

                            goto LINE_DEVSPECIFIC_dereference;
                        }

                        htCall = pCall->htCall;

                        LeaveCriticalSection (&gCallListCriticalSection);

                        pMsg->Msg = (pMsg->Msg == LINE_DEVSPECIFIC ?
                            LINE_CALLDEVSPECIFIC :
                            LINE_CALLDEVSPECIFICFEATURE);
                    }
                    else
                    {
                        LeaveCriticalSection (&gCallListCriticalSection);
                        goto LINE_DEVSPECIFIC_dereference;
                    }
                }
                else
                {
                    htCall = 0;
                }

                (*gpfnLineEventProc)(
                    pLine->htLine,
                    htCall,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

LINE_DEVSPECIFIC_dereference:

                DereferenceObject (ghHandleTable, hDeviceCallback, 1);

                break;
            }
            case PHONE_BUTTON:
            case PHONE_DEVSPECIFIC:

                if ((pPhone = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVPHONE_KEY
                        )))
                {
                    (*gpfnPhoneEventProc)(
                        pPhone->htPhone,
                        pMsg->Msg,
                        pMsg->Param1,
                        pMsg->Param2,
                        pMsg->Param3
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case LINE_LINEDEVSTATE:

                if (pMsg->Param1 & LINEDEVSTATE_REINIT)
                {
                    //
                    // Be on our best behavior and immediately shutdown
                    // our init instances on the server
                    //
                    
                    if (pMsg->InitContext)
                    {
                        //
                        //  In the case of TAPISRV shutdown, server sends 
                        //  LINEDEVSTATE_REINIT, then waits for everybody to 
                        //  finish, we do not want to retry the connection until
                        //  it indeed stopped, so we insert a wait
                        //
                        Sleep (8000);
                        OnServerDisconnected(pServer);
                        break;
                    }

                    pMsg->hDevice = 0;

                    /*
                    if (pMsg->Param2 == RSP_MSG)
                    {
                        //
                        // This is a message from TAPISRV indicating that this
                        // client need to reinit.  RemoteSP doesn't need to do
                        // it's shut down, but should notify client tapisrv
                        // that it needs to reinit.
                    }
                    else
                    {
                        Shutdown (pServer);
                    }
                    */
                }

                if (pMsg->Param1 & LINEDEVSTATE_TRANSLATECHANGE)
                {
                    // we shouldn't send this up to tapisrv, since this
                    // means that the translatecaps have changed on the
                    // server.  just ignore this message

                    break;
                }

                if (pMsg->hDevice)
                {
                    if (!(pLine = ReferenceObject(
                            ghHandleTable,
                            pMsg->hDevice,
                            DRVLINE_KEY
                            )))
                    {
                        break;
                    }
                }

                (*gpfnLineEventProc)(
                    pMsg->hDevice ? pLine->htLine : 0,
                    0,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

                if (pMsg->hDevice)
                {
                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case PHONE_STATE:

                if (pMsg->Param1 & PHONESTATE_REINIT)
                {
                    //
                    // Be on our best behavior and immediately shutdown
                    // our init instances on the server
                    //
                    
                    if (pMsg->InitContext)
                    {
                        //
                        //  In the case of TAPISRV shutdown, server sends 
                        //  LINEDEVSTATE_REINIT, then waits for everybody to 
                        //  finish, we do not want to retry the connection until
                        //  it indeed stopped, so we insert a wait
                        //
                        Sleep (8000);
                        OnServerDisconnected(pServer);
                        break;
                    }

                    pMsg->hDevice = 0;
                }

                if (pMsg->hDevice)
                {
                    if (!(pPhone = ReferenceObject(
                            ghHandleTable,
                            pMsg->hDevice,
                            DRVPHONE_KEY
                            )))
                    {
                        break;
                    }
                }

                (*gpfnPhoneEventProc)(
                    pMsg->hDevice ? pPhone->htPhone : 0,
                    pMsg->Msg,
                    pMsg->Param1,
                    pMsg->Param2,
                    pMsg->Param3
                    );

                if (pMsg->hDevice)
                {
                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;

            case LINE_CLOSE:
            {
                PDRVCALL    pCall;


                if ((pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVLINE_KEY
                        )))
                {
                    //
                    // Nullify the hLine field so that when TSPI_Close
                    // is called we know not to call the server
                    //

                    pLine->hLine = 0;


                    //
                    // Safely walk the call list for this line & nullify
                    // each call's hCall field so that when TSPI_CloseCall
                    // is called we know not to call the server
                    //

                    EnterCriticalSection (&gCallListCriticalSection);

                    pCall = pLine->pCalls;

                    while (pCall)
                    {
                        if (pCall->dwKey != DRVCALL_KEY)
                        {
                            LOG((TL_ERROR,
                                "EventHandlerThread: Bad pCall(lc) x%lx",
                                pCall
                                ));

                            continue;
                        }

                        pCall->hCall = 0;
                        pCall = pCall->pNext;
                    }

                    LeaveCriticalSection (&gCallListCriticalSection);

                    (*gpfnLineEventProc)(
                        pLine->htLine,
                        0,
                        LINE_CLOSE,
                        0,
                        0,
                        0
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;
            }
            case PHONE_CLOSE:
            {
                if ((pPhone = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVPHONE_KEY
                        )))
                {
                    //
                    // Nullify the hPhone field so that when TSPI_Close
                    // is called we know not to call the server
                    //

                    pPhone->hPhone = 0;

                    (*gpfnPhoneEventProc)(
                        pPhone->htPhone,
                        PHONE_CLOSE,
                        0,
                        0,
                        0
                        );

                    DereferenceObject (ghHandleTable, pMsg->hDevice, 1);
                }

                break;
            }
            case LINE_GATHERDIGITS:
            {
                if (pMsg->TotalSize >= (sizeof (*pMsg) + sizeof (PDRVLINE)))
                {
                    DWORD       hLineCallback = ((DWORD *)(pMsg + 1))[1];
                    HCALL       hCall = (HCALL) pMsg->hDevice;
                    PDRVCALL    pCall;
                    HTAPICALL   htCall;

                    if ((pLine = ReferenceObject(
                            ghHandleTable,
                            hLineCallback,
                            DRVLINE_KEY
                            )))
                    {
                        EnterCriticalSection (&gCallListCriticalSection);

                        pCall = (PDRVCALL) pLine->pCalls;

                        while (pCall && (pCall->hCall != hCall))
                        {
                            pCall = pCall->pNext;
                        }

                        htCall = (pCall ? pCall->htCall : 0);

                        if (pCall && pCall->dwKey != DRVCALL_KEY)
                        {
                            LeaveCriticalSection (&gCallListCriticalSection);

                            goto LINE_GATHERDIGITS_dereference;
                        }

                        LeaveCriticalSection (&gCallListCriticalSection);

                        TSPI_lineGatherDigits_PostProcess (pMsg);

                        (*gpfnLineEventProc)(
                            pLine->htLine,
                            htCall,
                            LINE_GATHERDIGITS,
                            pMsg->Param1,
                            pMsg->Param2,   // dwEndToEndID
                            0
                            );

LINE_GATHERDIGITS_dereference:

                        DereferenceObject (ghHandleTable, hLineCallback, 1);
                    }
                }

                break;
            }

            case LINE_REPLY:
            case PHONE_REPLY:
            {
                ULONG_PTR               Context2;
                DWORD                   originalRequestID;
                PASYNCREQUESTCONTEXT    pContext;


                if ((pContext = ReferenceObjectEx(
                        ghHandleTable,
                        pMsg->Param1,
                        0,
                        (LPVOID *) &Context2
                        )))
                {
                    originalRequestID = DWORD_CAST(Context2,__FILE__,__LINE__);

                    LOG((TL_INFO,
                        "Doing LINE_/PHONE_REPLY: LocID=x%x (RemID=x%x), " \
                            "Result=x%x",
                        originalRequestID,
                        pMsg->Param1,
                        pMsg->Param2
                        ));

                    if (pContext != (PASYNCREQUESTCONTEXT) -1)
                    {
                        if (pContext->dwKey == DRVASYNC_KEY)
                        {
                            //
                            // Set pContext->dwOriginalRequestID so
                            // MakeCallPostProcess &
                            // SetupConferencePostProcess can check it
                            // againt pCall->dwOriginalRequestID for
                            // verification.
                            //

                            pContext->dwOriginalRequestID = (DWORD)
                                originalRequestID;

                            (*pContext->pfnPostProcessProc)(
                                pMsg,
                                pContext
                                );
                        }
                        else
                        {
                            //
                            // Not a valid request id, do a single deref
                            // & break
                            //

                            DereferenceObject (ghHandleTable, pMsg->Param1, 1);
                            break;
                        }
                    }

                    (*gpfnCompletionProc)(
                        (DRV_REQUESTID) originalRequestID,
                        (LONG) pMsg->Param2
                        );


                    //
                    // Double deref to free the object
                    //

                    DereferenceObject (ghHandleTable, pMsg->Param1, 2);
                }

                break;
            }
            case LINE_CREATE:
            {
                //
                // Check validity of new device ID to thwart RPC attacks.
                // Compare with known/existing device ID's on for this
                // server, and also try to get devCaps for this device
                // from server.
                //

                #define V1_0_LINEDEVCAPS_SIZE 236

                BYTE            buf[sizeof (TAPI32_MSG) +
                                    V1_0_LINEDEVCAPS_SIZE];
                DWORD           i, dwRetryCount = 0, dwUsedSize;
                PTAPI32_MSG     pReq = (PTAPI32_MSG) buf;
                PDRVLINELOOKUP  pLookup;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpLineLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is already in our global
                            // table, so blow off this msg
                            //
                            TapiLeaveCriticalSection(&gCriticalSection);
                            goto LINE_CREATE_break;
                        }
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                do
                {
                    pReq->u.Req_Func = lGetDevCaps;

                    pReq->Params[0] = pServer->hLineApp;
                    pReq->Params[1] = pMsg->Param1;
                    pReq->Params[2] = TAPI_VERSION1_0;
                    pReq->Params[3] = 0;
                    pReq->Params[4] = V1_0_LINEDEVCAPS_SIZE;

                    dwUsedSize = sizeof (TAPI32_MSG);

                    RpcTryExcept
                    {
                        ClientRequest(
                            pServer->phContext,
                            (char *) pReq,
                            sizeof (buf),
                            &dwUsedSize
                            );

                        dwRetryCount = gdwRetryCount;
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                        dwRetryCount++;

                        if (dwRetryCount < gdwRetryCount)
                        {
                            Sleep (gdwRetryTimeout);
                        }
                        else
                        {
                            pReq->u.Ack_ReturnValue = LINEERR_BADDEVICEID;
                        }
                    }
                    RpcEndExcept

                } while (dwRetryCount < gdwRetryCount);

                if ((LONG) pReq->u.Ack_ReturnValue != LINEERR_BADDEVICEID)
                {
                    if (AddLine(
                        pServer,
                        gdwTempLineID,
                        (DWORD) pMsg->Param1,
                        FALSE,
                        FALSE,
                        0,
                        NULL
                        ) == 0)
                    {
                        (*gpfnLineEventProc)(
                            0,
                            0,
                            LINE_CREATE,
                            (ULONG_PTR) ghProvider,
                            gdwTempLineID--,
                            0
                            );
                    }
                }

LINE_CREATE_break:

                break;
            }
            case LINE_REMOVE:
            {
                PDRVLINELOOKUP  pLookup;
                BOOL            fValidID = FALSE;
                DWORD           dwDeviceID, i;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpLineLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is in our global
                            //
                            fValidID = TRUE;
                            dwDeviceID = pLookup->aEntries[i].dwDeviceIDLocal;
                            pLookup->aEntries[i].dwDeviceIDServer = 0xffffffff;
                            break;
                        }
                    }

                    if (fValidID)
                    {
                        break;
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                if (fValidID)
                {
                    (*gpfnLineEventProc)(
                        0,
                        0,
                        LINE_REMOVE,
                        dwDeviceID,
                        0,
                        0
                        );
                }
            }
            break;
            case PHONE_CREATE:
            {
                //
                // Check validity of new device ID to thwart RPC attacks.
                // Compare with known/existing device ID's on for this
                // server, and also try to get devCaps for this device
                // from server.
                //

                #define V1_0_PHONECAPS_SIZE 144

                BYTE            buf[sizeof (TAPI32_MSG) + V1_0_PHONECAPS_SIZE];
                DWORD           i, dwRetryCount = 0, dwUsedSize;
                PTAPI32_MSG     pReq = (PTAPI32_MSG) buf;
                PDRVPHONELOOKUP pLookup;
                
                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpPhoneLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is already in our global
                            // table, so blow off this msg
                            //
                            TapiLeaveCriticalSection(&gCriticalSection);
                            goto PHONE_CREATE_break;
                        }
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                do
                {
                    pReq->u.Req_Func = pGetDevCaps;

                    pReq->Params[0] = pServer->hPhoneApp;
                    pReq->Params[1] = pMsg->Param1;
                    pReq->Params[2] = TAPI_VERSION1_0;
                    pReq->Params[3] = 0;
                    pReq->Params[4] = V1_0_PHONECAPS_SIZE;

                    dwUsedSize = sizeof (TAPI32_MSG);

                    RpcTryExcept
                    {
                        ClientRequest(
                            pServer->phContext,
                            (char *) pReq,
                            sizeof (buf),
                            &dwUsedSize
                            );

                        dwRetryCount = gdwRetryCount;
                    }
                    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                        dwRetryCount++;

                        if (dwRetryCount < gdwRetryCount)
                        {
                            Sleep (gdwRetryTimeout);
                        }
                        else
                        {
                            pReq->u.Ack_ReturnValue = PHONEERR_BADDEVICEID;
                        }
                    }
                    RpcEndExcept

                } while (dwRetryCount < gdwRetryCount);

                if ((LONG) pReq->u.Ack_ReturnValue != PHONEERR_BADDEVICEID)
                {
                    AddPhone(
                        pServer,
                        gdwTempPhoneID,
                        (DWORD) pMsg->Param1,
                        FALSE,
                        FALSE,
                        0,
                        NULL
                        );

                    (*gpfnPhoneEventProc)(
                        0,
                        PHONE_CREATE,
                        (ULONG_PTR) ghProvider,
                        gdwTempPhoneID--,
                        0
                        );
                }

PHONE_CREATE_break:

                break;
            }
            case PHONE_REMOVE:
            {
                PDRVPHONELOOKUP pLookup;
                BOOL            fValidID = FALSE;
                DWORD           dwDeviceID, i;

                TapiEnterCriticalSection(&gCriticalSection);
                pLookup = gpPhoneLookup;
                while (pLookup)
                {
                    for (i = 0; i < pLookup->dwUsedEntries; i++)
                    {
                        if ((pLookup->aEntries[i].pServer == pServer) &&
                            (pLookup->aEntries[i].dwDeviceIDServer ==
                                (DWORD) pMsg->Param1))
                        {
                            //
                            // This server/id combo is in our global
                            //
                            fValidID = TRUE;
                            dwDeviceID = pLookup->aEntries[i].dwDeviceIDLocal;
                            break;
                        }
                    }

                    if (fValidID)
                    {
                        break;
                    }

                    pLookup = pLookup->pNext;
                }
                TapiLeaveCriticalSection(&gCriticalSection);

                if (fValidID)
                {
                    (*gpfnPhoneEventProc)(
                        0,
                        PHONE_REMOVE,
                        dwDeviceID,
                        0,
                        0
                        );
                }
            }
            break;
            case LINE_APPNEWCALL:
            {
                PDRVCALL  pCall;
                HTAPICALL htCall;


                if (!(pLine = ReferenceObject(
                        ghHandleTable,
                        pMsg->hDevice,
                        DRVLINE_KEY
                        )))
                {
                   break;
                }

                if ((pCall = DrvAlloc (sizeof (DRVCALL))))
                {
                    pCall->hCall           = (HCALL) pMsg->Param2;
                    pCall->dwAddressID     = (DWORD) pMsg->Param1;
                    if (pMsg->TotalSize >=
                            (sizeof (*pMsg) + 2 * sizeof (DWORD)))
                    {
                        pCall->dwCallID        = (DWORD) *(&pMsg->Param4 + 1);
                        pCall->dwRelatedCallID = (DWORD) *(&pMsg->Param4 + 2);
                    }
                    else
                    {
                        pCall->dwDirtyStructs |= STRUCTCHANGE_CALLIDS;

                        pLine->pServer->bVer2xServer = TRUE;
                    }

                    if (pLine->htLine)
                    {

                        (*gpfnLineEventProc)(
                            pLine->htLine,
                            0,
                            LINE_NEWCALL,
                            (ULONG_PTR) pCall,
                            (ULONG_PTR) &(pCall->htCall),
                            (ULONG_PTR) 0
                            );

                        EnterCriticalSection (&gCallListCriticalSection);

                        AddCallToList (pLine, pCall);

                        htCall = pCall->htCall;

                        LeaveCriticalSection (&gCallListCriticalSection);

                        if (!htCall)
                        {
                            //
                            // tapi was not able to create it's own instance
                            // to represent ths incoming call, perhaps
                            // because the line was closed, or out of
                            // memory.  if the line was closed then we've
                            // already notified the remote server, and it
                            // should have destroyed the call client.
                            // otherwise, we probably want to do a closecall
                            // here or in a worker thread

                            RemoveCallFromList (pCall);
                        }
                    }
                    else
                    {
                        DrvFree (pCall);
                    }
                }
                else
                {
                }

                DereferenceObject (ghHandleTable, pMsg->hDevice, 1);

                break;
            }
#if DBG
            default:

                LOG((TL_ERROR,
                    "EventHandlerThread: unknown msg=x%x, hDev=x%x, p1=x%x",
                    pMsg->Msg,
                    pMsg->hDevice,
                    pMsg->Param1
                    ));

                break;
#endif
            } // switch (pMsg->dwMsg)

            DereferenceObject (ghHandleTable, pMsg->InitContext, 1);

        } // while ((pMsg = GetEventFromQueue()))

    } // while (1)


    if (gEventHandlerThreadParams.hMailslot != INVALID_HANDLE_VALUE)
    {
        CancelIo (gEventHandlerThreadParams.hMailslot);
    }

    ClearImpersonationToken();
    RevertImpersonation();
    CloseHandle(hProcess);

    LOG((TL_INFO, "EventHandlerThread: exit"));

    ExitThread (0);
}


PDRVLINE
GetLineFromID(
    DWORD   dwDeviceID
    )
{
    PDRVLINE    pLine;

    //
    // First check to see if it's a valid device ID.
    //
    if (dwDeviceID < gdwLineDeviceIDBase || gpLineLookup == NULL)
    {
        return NULL;
    }

    TapiEnterCriticalSection(&gCriticalSection);

    //
    // First check to see if it's a "static" device, i.e. a device
    // that we knew about at start up time, in which case we know
    // it's exact location in the lookup table
    //
    if (dwDeviceID < (gdwLineDeviceIDBase + gdwInitialNumLineDevices))
    {
        pLine = gpLineLookup->aEntries + dwDeviceID - gdwLineDeviceIDBase;
    }

    //
    // If here, the id references a "dynamic" device, i.e. one that
    // we found out about on the fly via a CREATE msg, so we need to
    // walk the lookup table(s) to find it
    //
    // TODO: the while loops down below are not efficient at all
    //

    else
    {
        PDRVLINELOOKUP  pLookup = gpLineLookup;
        DWORD i;


        pLine = NULL;

        while (pLookup)
        {
            i = 0;
            while (i != pLookup->dwUsedEntries &&
                   pLookup->aEntries[i].dwDeviceIDLocal != dwDeviceID)
            {
                i++;
            }

            if (i < pLookup->dwUsedEntries)
            {
                pLine = &(pLookup->aEntries[i]);
                break;
            }

            pLookup = pLookup->pNext;
        }
    }

    TapiLeaveCriticalSection(&gCriticalSection);
    return pLine;
}


PDRVPHONE
GetPhoneFromID(
    DWORD   dwDeviceID
    )
{
    PDRVPHONE   pPhone;

    //
    // First check to see if it's a valid device ID.
    //
    if (dwDeviceID < gdwPhoneDeviceIDBase || gpPhoneLookup == NULL)
    {
        return NULL;
    }

    TapiEnterCriticalSection(&gCriticalSection);

    //
    // Then check to see if it's a "static" device, i.e. a device
    // that we knew about at start up time, in which case we know
    // it's exact location in the lookup table
    //
    if (dwDeviceID < (gdwPhoneDeviceIDBase + gdwInitialNumPhoneDevices))
    {
        pPhone = gpPhoneLookup->aEntries + dwDeviceID - gdwPhoneDeviceIDBase;
    }


    //
    // If here, the id references a "dynamic" device, i.e. one that
    // we found out about on the fly via a CREATE msg, so we need to
    // walk the lookup table(s) to find it
    //
    // TODO: the while loops down below are not efficient at all
    //

    else
    {
        PDRVPHONELOOKUP pLookup = gpPhoneLookup;
        DWORD i;


        pPhone = NULL;

        while (pLookup)
        {
            i = 0;

            while (i != pLookup->dwUsedEntries &&
                   pLookup->aEntries[i].dwDeviceIDLocal != dwDeviceID)
            {
                i++;
            }

            if (i < pLookup->dwUsedEntries)
            {
                pPhone = &(pLookup->aEntries[i]);
                break;
            }

            pLookup = pLookup->pNext;
        }
    }

    TapiLeaveCriticalSection(&gCriticalSection);
    return pPhone;
}


BOOL
WINAPI
GrowBuf(
    LPBYTE *ppBuf,
    LPDWORD pdwBufSize,
    DWORD   dwCurrValidBytes,
    DWORD   dwBytesToAdd
    )
{
    DWORD   dwCurrBufSize, dwNewBufSize;
    LPBYTE  pNewBuf;


    //
    // Try to get a new buffer big enough to hold everything
    //

    for(
        dwNewBufSize = 2 * (dwCurrBufSize = *pdwBufSize);
        dwNewBufSize < (dwCurrBufSize + dwBytesToAdd);
        dwNewBufSize *= 2
        );

    if (!(pNewBuf = DrvAlloc (dwNewBufSize)))
    {
        return FALSE;
    }


    //
    // Copy the "valid" bytes in the old buf to the new buf,
    // then free the old buf
    //

    CopyMemory (pNewBuf, *ppBuf, dwCurrValidBytes);

    DrvFree (*ppBuf);


    //
    // Reset the pointers to the new buf & buf size
    //

    *ppBuf = pNewBuf;
    *pdwBufSize = dwNewBufSize;

    return TRUE;
}


PRSP_THREAD_INFO
WINAPI
GetTls(
    void
    )
{
    PRSP_THREAD_INFO    pClientThreadInfo;


    if (!(pClientThreadInfo = TlsGetValue (gdwTlsIndex)))
    {
        pClientThreadInfo = (PRSP_THREAD_INFO)
            DrvAlloc (sizeof(RSP_THREAD_INFO));

        if (!pClientThreadInfo)
        {
            return NULL;
        }

        pClientThreadInfo->pBuf = DrvAlloc (INITIAL_CLIENT_THREAD_BUF_SIZE);

        if (!pClientThreadInfo->pBuf)
        {
            DrvFree (pClientThreadInfo);

            return NULL;
        }

        pClientThreadInfo->dwBufSize = INITIAL_CLIENT_THREAD_BUF_SIZE;

        EnterCriticalSection (&gcsTlsList);

        InsertHeadList (&gTlsListHead, &pClientThreadInfo->TlsList);

        LeaveCriticalSection (&gcsTlsList);

        TlsSetValue (gdwTlsIndex, (LPVOID) pClientThreadInfo);
    }

    return pClientThreadInfo;
}


#if DBG

LONG
WINAPI
RemoteDoFunc(
    PREMOTE_FUNC_ARGS   pFuncArgs,
    char               *pszFuncName
    )

#else

LONG
WINAPI
RemoteDoFunc(
    PREMOTE_FUNC_ARGS   pFuncArgs
    )

#endif
{
    LONG    lResult;
    BOOL    bCopyOnSuccess = FALSE, bRpcImpersonate, bNeedToReInit = FALSE;
    DWORD   i, j, dwUsedSize, dwNeededSize;
    DWORD   dwFuncClassErrorIndex = (pFuncArgs->Flags & 0x00000030) >> 4;
    DWORD   requestID;
    ULONG_PTR           value;
    PDRVSERVER          pServer = NULL;
    PRSP_THREAD_INFO    pTls;


    //
    // Get the tls
    //

    if (!(pTls = GetTls()))
    {
        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
        goto RemoteDoFunc_return;
    }


    //
    // Validate all the func args
    //

    dwNeededSize = dwUsedSize = sizeof (TAPI32_MSG);

    for (i = 0, j = 0; i < (pFuncArgs->Flags & NUM_ARGS_MASK); i++, j++)
    {
        value = pFuncArgs->Args[i];

        switch (pFuncArgs->ArgTypes[i])
        {
        case lpContext:
            // do nothing
            continue;

        case Dword:

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST_HINT(pFuncArgs->Args[i],__FILE__,__LINE__,i);
            continue;

        case LineID:
        {
            PDRVLINE    pLine = GetLineFromID ((DWORD) value);

            try
            {
                pServer = pLine->pServer;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                lResult = LINEERR_BADDEVICEID;
                goto RemoteDoFunc_return;
            }

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pLine->dwDeviceIDServer;

            continue;
        }
        case PhoneID:
        {
            PDRVPHONE   pPhone = GetPhoneFromID ((DWORD) value);

            try
            {
                pServer = pPhone->pServer;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                lResult = PHONEERR_BADDEVICEID;
                goto RemoteDoFunc_return;
            }

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pPhone->dwDeviceIDServer;

            continue;
        }
        case Hdcall:

            //
            // Save the pServer & adjust the call handle as understood by
            // the server
            //

            try
            {
                pServer = ((PDRVCALL) value)->pServer;

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = ((PDRVCALL) value)->hCall;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                lResult = LINEERR_INVALCALLHANDLE;
                goto RemoteDoFunc_return;
            }

            continue;

        case Hdline:

            //
            // Save the pServer & adjust the line handle as understood by
            // the server.  There's no need to wrap this in a try/except
            // since the object pointed at by the pLine is static, whether
            // or not the device is actually open.
            //

            pServer = ((PDRVLINE) value)->pServer;

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = ((PDRVLINE) value)->hLine;

            continue;

        case Hdphone:

            //
            // Save the pServer & adjust the phone handle as understood by
            // the server.  There's no need to wrap this in a try/except
            // since the object pointed at by the pLine is static, whether
            // or not the device is actually open.
            //

            pServer = ((PDRVPHONE) value)->pServer;

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = ((PDRVPHONE) value)->hPhone;

            continue;

        case lpDword:

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;

            bCopyOnSuccess = TRUE;

            continue;

        case lpsz:

            //
            // Check if value is a valid string ptr and if so
            // copy the contents of the string to the extra data
            // buffer passed to the server, else indicate no data
            //

            if (value)
            {
                DWORD   n = (lstrlenW ((WCHAR *) value) + 1) *
                            sizeof (WCHAR),
                        nAligned = (n + 3) & 0xfffffffc;


                if ((nAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            nAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto RemoteDoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, n);


                //
                // Pass the server the offset of the string in the var data
                // portion of the buffer
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);


                //
                // Increment the total number of data bytes
                //

                dwUsedSize   += nAligned;
                dwNeededSize += nAligned;
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }

            continue;


        case lpGet_Struct:
        case lpGet_CallParamsStruct:
        case lpGet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpGet_SizeToFollow);
            DWORD dwSize;


            if (bSizeToFollow)
            {
#if DBG
                //
                // Check to make sure the following arg is of type Size
                //

                if ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                    (pFuncArgs->ArgTypes[i + 1] != Size))
                {
                    LOG((TL_ERROR,
                        "DoFunc: error, lpGet_SizeToFollow !followed by Size"
                        ));

                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    goto RemoteDoFunc_return;
                }
#endif
                dwSize = DWORD_CAST_HINT(pFuncArgs->Args[i + 1],__FILE__,__LINE__,i);
            }
            else
            {
                dwSize = *((LPDWORD) value); // lpXxx->dwTotalSize
            }

            if (bSizeToFollow)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
                ++j;++i;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST_HINT(pFuncArgs->Args[i],__FILE__,__LINE__,i);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = dwSize;
            }


            //
            // Now set the bCopyOnSuccess flag to indicate that we've data
            // to copy back on successful completion, and add to the
            // dwNeededSize field
            //

            bCopyOnSuccess = TRUE;

            dwNeededSize += dwSize;

            continue;
        }

        case lpSet_Struct:
        case lpSet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpSet_SizeToFollow);
            DWORD dwSize, dwSizeAligned;

#if DBG
            //
            // Check to make sure the following arg is of type Size
            //

            if (bSizeToFollow &&
                ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                (pFuncArgs->ArgTypes[i + 1] != Size)))
            {
                LOG((TL_ERROR,
                    "DoFunc: error, lpSet_SizeToFollow !followed by Size"
                    ));

                lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                goto RemoteDoFunc_return;
            }
#endif
            if (bSizeToFollow)
            {
                dwSize = (value ? DWORD_CAST_HINT(pFuncArgs->Args[i + 1],__FILE__,__LINE__,i) : 0);
            }
            else
            {
                dwSize = (value ? *((LPDWORD) value) : 0);
            }

            if (dwSize)
            {
                //
                // Grow the buffer if necessary, & do the copy
                //

                dwSizeAligned = (dwSize + 3) & 0xfffffffc;

                if ((dwSizeAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            dwSizeAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto RemoteDoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, dwSize);
            }
            else
            {
                dwSizeAligned = 0;
            }


            //
            // Pass the server the offset of the data in the var data
            // portion of the buffer
            //

            if (dwSize)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }


            //
            // Increment the dwXxxSize vars appropriately
            //

            dwUsedSize   += dwSizeAligned;
            dwNeededSize += dwSizeAligned;


            //
            // Since we already know the next arg (Size) just handle
            // it here so we don't have to run thru the loop again
            //

            if (bSizeToFollow)
            {
                ++j;++i;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST_HINT(pFuncArgs->Args[i],__FILE__,__LINE__,i);
            }

            continue;
        }

        case lpServer:

            pServer = (PDRVSERVER) value;
            --j;

            continue;

#if DBG
        case Size:

            LOG((TL_ERROR, "DoFunc: error, hit case Size"));

            continue;

        default:

            LOG((TL_ERROR, "DoFunc: error, unknown arg type"));

            continue;
#endif
        } // switch

    } // for


    //
    // Verify if the target server is valid & in a good state
    //

    if (IsValidObject ((PVOID) pServer, gdwDrvServerKey))
    {
        if (SERVER_REINIT & pServer->dwFlags)
        {
            LOG((TL_ERROR, "pServer says REINIT in RemoteDoFunc"));
            lResult = gaServerReInitErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }

        if (SERVER_DISCONNECTED & pServer->dwFlags)
        {
            LOG((TL_ERROR, "pServer is disconnected in RemoteDoFunc"));
            lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }
    }
    else
    {
        lResult = (pServer ?
            gaOpFailedErrors[dwFuncClassErrorIndex] :
            gaServerDisconnectedErrors[dwFuncClassErrorIndex]);
        goto RemoteDoFunc_return;
    }


    //
    // Now make the request
    //

    if (dwNeededSize > pTls->dwBufSize)
    {
        if (!GrowBuf(
                &pTls->pBuf,
                &pTls->dwBufSize,
                dwUsedSize,
                dwNeededSize - pTls->dwBufSize
                ))
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }
    }

    ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func = (DWORD)HIWORD(pFuncArgs->Flags);


    //
    // If this is an async request then add it to our "handle" table &
    // used the returned value for the request id passed to the server.
    //
    // TODO: would be faster to do this before the loop above so could
    //       bypass 1 or 2 loop iterations
    //

    if (pFuncArgs->Flags & ASYNC)
    {
        PASYNCREQUESTCONTEXT    pContext;


        if (pFuncArgs->Flags & INCL_CONTEXT)
        {
            pContext = (PASYNCREQUESTCONTEXT) pFuncArgs->Args[1];
            pContext->dwKey = DRVASYNC_KEY;
            ((PTAPI32_MSG) pTls->pBuf)->Params[1] = 0;
        }
        else
        {
            pContext = (PASYNCREQUESTCONTEXT) -1;
        }

        requestID =
        ((PTAPI32_MSG) pTls->pBuf)->Params[0] = NewObject(
            ghHandleTable,
            pContext,
            (LPVOID) pFuncArgs->Args[0]     // the original request id
            );

        if (!requestID)
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto RemoteDoFunc_return;
        }
    }


    //
    // Impersonate the client.  In some cases impersonation
    // will fail, mostly likely because we're being called
    // by a worker thread in tapisrv to close a line/call/
    // phone object; what we do in this case is impersonate
    // the logged on user (like the EventHandlerThread does).
    //

    if (!pTls->bAlreadyImpersonated)
    {
        RPC_STATUS  status;

        status = RpcImpersonateClient(0);

        if (status == RPC_S_OK)
        {
            bRpcImpersonate = TRUE;
        }
        else
        {
            bRpcImpersonate = FALSE;

            LOG((TL_ERROR,
                "RemoteDoFunc: RpcImpersonateClient failed, err=%d",
                status
                ));

            if (!SetProcessImpersonationToken (NULL))
            {
                LOG((TL_ERROR,
                    "RemoteDoFunc: SetProcessImpersToken failed, lastErr=%d",
                    GetLastError()
                    ));

                lResult =  gaOpFailedErrors[dwFuncClassErrorIndex];
                goto RemoteDoFunc_return;
            }
        }
    }


    {
        DWORD   dwRetryCount = 0;


        do
        {
            //
            // check if the server is shutting down, to avoid making RPC request 
            // with invalid handle
            //
            if (pServer->bShutdown)
            {
                lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
                break;
            }

            RpcTryExcept
            {
                ClientRequest(
                    pServer->phContext,
                    pTls->pBuf,
                    dwNeededSize,
                    &dwUsedSize
                    );

                lResult = (LONG) ((PTAPI32_MSG) pTls->pBuf)->u.Ack_ReturnValue;

                if (lResult == TAPIERR_INVALRPCCONTEXT)
                {
                    OnServerDisconnected (pServer);
                    lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
                }

                break;  // break out of do while
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                if (dwRetryCount++ < gdwRetryCount)
                {
                    Sleep (gdwRetryTimeout);
                }
                else
                {
                    unsigned long ulResult = RpcExceptionCode();


                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];

                    if ((ulResult == RPC_S_SERVER_UNAVAILABLE) ||
                        (ulResult == ERROR_INVALID_HANDLE))
                    {
                        OnServerDisconnected (pServer);
                        lResult = gaServerDisconnectedErrors[dwFuncClassErrorIndex];
                    }

                    break;
                }
            }
            RpcEndExcept

        } while (TRUE); //while (dwRetryCount < gdwRetryCount);
    }

    if (!pTls->bAlreadyImpersonated)
    {
        if (bRpcImpersonate)
        {
            RpcRevertToSelf();
        }
        else
        {
            ClearImpers