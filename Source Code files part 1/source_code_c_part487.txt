tInfoCache)->AddRefData(_iPEI);
    if(_iCustomCursor >= 0)
        TLS(_pCustomCursorCache)->AddRefData(_iCustomCursor);

    return *this;
}

//+----------------------------------------------------------------------------
//
//  Member:     CFancyFormat::Compare
//
//  Synopsis:   Compare 2 structs
//              return TRUE iff equal, else FALSE
//
//-----------------------------------------------------------------------------

BOOL
CFancyFormat::Compare(const CFancyFormat *pFF) const
{
    Assert(pFF);

    BOOL fRet = memcmp(this, pFF, offsetof(CFancyFormat, _pszFilters));
    if (!fRet)
    {
        fRet = (_pszFilters && pFF->_pszFilters)
                ? _tcsicmp(_pszFilters, pFF->_pszFilters)
                : ((!_pszFilters && !pFF->_pszFilters) ? FALSE : TRUE);
    }
    return !fRet;
}



//+----------------------------------------------------------------------
//  CFancyFormat::CompareForLayout(pFF)
// 
//      Compare this CFancyFormat to *<p pFF> and return FALSE if any
//      attribute generally requiring a re-layout is different. return
//      TRUE if they are close enough to only require invalidation
//
//--------------------------------------------------------------------
BOOL CFancyFormat::CompareForLayout (const CFancyFormat *pFF) const
{
    Assert(pFF);

    CFancyFormat ffNew;
    BOOL fRet;

    memcpy(&ffNew, this, sizeof(CFancyFormat));
    ffNew._fHasExplicitUnderline = pFF->_fHasExplicitUnderline;
    ffNew._fHasExplicitOverline = pFF->_fHasExplicitOverline;
    ffNew._fHasExplicitLineThrough = pFF->_fHasExplicitLineThrough;
    ffNew._lZIndex = pFF->_lZIndex;
    ffNew._lImgCtxCookie = pFF->_lImgCtxCookie;
    ffNew._bPageBreaks = pFF->_bPageBreaks;
    ffNew._iExpandos = pFF->_iExpandos;
    ffNew._iCustomCursor = pFF->_iCustomCursor;
    ffNew._fBgRepeatX = pFF->_fBgRepeatX;
    ffNew._fBgRepeatY = pFF->_fBgRepeatY;
    ffNew._pszFilters = NULL;
    for(int i = SIDE_TOP; i < SIDE_MAX; i++)
    {
        ffNew._cuvPositions[i] = pFF->_cuvPositions[i];
        ffNew._cuvClip[i] = pFF->_cuvClip[i];
    }

    fRet = ffNew.Compare(pFF);
    ffNew._iExpandos = ffNew._iPEI = ffNew._iCustomCursor = -1;
    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Member:     CFancyFormat::ComputeCrc
//
//  Synopsis:   Compute Hash
//
//-----------------------------------------------------------------------------

WORD
CFancyFormat::ComputeCrc() const
{
    DWORD dwCrc = 0;
    size_t z;
    size_t size = offsetof(CFancyFormat, _pszFilters)/sizeof(DWORD);

    for (z = 0; z < size; z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    if (_pszFilters)
    {
        TCHAR *psz = _pszFilters;

        while (*psz)
        {
            dwCrc ^= (*psz++);
        }
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

//+------------------------------------------------------------------------
//
//  Member:     CFancyFormat::HasBackgrounds
//
//  Synopsis:   Check to see if backgrounds have been set
//
//-------------------------------------------------------------------------
CFancyFormat::HasBackgrounds(BOOL fIsPseudo) const
{
    if (fIsPseudo)
    {
        if (_iPEI >= 0)
        {
            const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(_iPEI);
            return (pPEI->_ccvBackColor.IsDefined() || pPEI->_lImgCtxCookie);
        }
        else
            return FALSE;
    }
    else
    {
        return (   _ccvBackColor.IsDefined()
                || _lImgCtxCookie);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPseudoElementInfo::ComputeCrc
//
//  Synopsis:   Compute Hash
//
//-------------------------------------------------------------------------
WORD
CPseudoElementInfo::ComputeCrc() const
{
    DWORD dwCrc=0, z;

    for (z=0;z<sizeof(CPseudoElementInfo)/sizeof(DWORD);z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

HRESULT
CPseudoElementInfo::InitDefault()
{
    BYTE i;
    
    memset(this, 0, sizeof(CPseudoElementInfo));

    _ccvBackColor.Undefine();

    _bd._ccvBorderColorLight.Undefine();
    _bd._ccvBorderColorDark.Undefine();
    _bd._ccvBorderColorHilight.Undefine();
    _bd._ccvBorderColorShadow.Undefine();

    // We are setting all border sides to the same value, so it doesn't matter
    // if we set logical or physical values.
    CColorValue ccvUndefine;
    CUnitValue cuvNull;
    ccvUndefine.Undefine();
    cuvNull.SetNull();
    for (i = 0; i < SIDE_MAX; i++)
    {
        _bd.SetBorderColor(i, ccvUndefine);
        _bd.SetBorderWidth(i, cuvNull);
        _bd.SetBorderStyle(i, (BYTE)-1);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CopyAttrVal
//
//  Synopsis:   Copies wSize bytes of dwSrc onto pDest
//
//-------------------------------------------------------------------------
inline void CopyAttrVal(BYTE *pDest, DWORD dwSrc, WORD wSize)
{
    switch (wSize)
    {
    case 1:
        *(BYTE*) pDest  = (BYTE) dwSrc;
        break;
    case 2:
        *(WORD*) pDest  = (WORD) dwSrc;
        break;
    case 4:
        *(DWORD*) pDest  = (DWORD) dwSrc;
        break;
    default:
        Assert(0);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyClear
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Clear Type
//
//-----------------------------------------------------------------------------
void ApplyClear(CElement * pElem, htmlClear hc, CFormatInfo *pCFI)
{
    BOOL fClearLeft = FALSE;
    BOOL fClearRight = FALSE;

    switch (hc)
    {
    case htmlClearBoth:
    case htmlClearAll:
        fClearLeft  = fClearRight = TRUE;
        break;
    case htmlClearLeft:
        fClearLeft  = TRUE;
        fClearRight = FALSE;
        break;
    case htmlClearRight:
        fClearRight = TRUE;
        fClearLeft  = FALSE;
        break;
    case htmlClearNone:
        fClearLeft  = fClearRight = FALSE;
        break;
    case htmlClearNotSet:
        AssertSz(FALSE, "Invalid Clear value.");
        break;
    }

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._fClearLeft  = fClearLeft;
    pCFI->_ff()._fClearRight = fClearRight;
    pCFI->UnprepareForDebug();
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontFace
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Face
//
//-----------------------------------------------------------------------------

struct CFBAG
{
    CCharFormat * pcf;
    BOOL fMatched;
    BYTE bFamily;
    BYTE bPitch;

    CFBAG(CCharFormat * pcfArg)
    {
        pcf = pcfArg;
        fMatched = FALSE;
        bFamily = 0;
        bPitch = 0;
    };
};

static int CALLBACK
__ApplyFontFace_Compare(const LOGFONT FAR * lplf, 
                        const TEXTMETRIC FAR * lptm, 
                        DWORD FontType, 
                        LPARAM lParam)
{
    // Prefer TrueType fonts
    struct CFBAG * pcfbag = (struct CFBAG *)lParam;
    if (   (TRUETYPE_FONTTYPE & FontType) 
        || !pcfbag->fMatched)
    {
        pcfbag->fMatched = TRUE;
        pcfbag->pcf->_bCharSet = lplf->lfCharSet;
        pcfbag->pcf->_bPitchAndFamily = lplf->lfPitchAndFamily;
        pcfbag->pcf->SetFaceName(lplf->lfFaceName);
    }
    return !(TRUETYPE_FONTTYPE & FontType);
}

static int CALLBACK
__ApplyFontFace_CompareFamily(const LOGFONT FAR * lplf, 
                              const TEXTMETRIC FAR * lptm, 
                              DWORD FontType, 
                              LPARAM lParam)
{
    if (   (lplf->lfPitchAndFamily & 0xf0) == ((struct CFBAG *)lParam)->bFamily
        && lplf->lfCharSet != SYMBOL_CHARSET)   // Skip 'Symbol' font
    {
        return __ApplyFontFace_Compare(lplf, lptm, FontType, lParam);
    }
    return TRUE;
}

static int CALLBACK
__ApplyFontFace_ComparePitch(const LOGFONT FAR * lplf, 
                              const TEXTMETRIC FAR * lptm, 
                              DWORD FontType, 
                              LPARAM lParam)
{
    if (   (lplf->lfPitchAndFamily & 0x0f) == ((struct CFBAG *)lParam)->bPitch
        && lplf->lfCharSet != SYMBOL_CHARSET)   // Skip 'Symbol' font
    {
        return __ApplyFontFace_Compare(lplf, lptm, FontType, lParam);
    }
    return TRUE;
}

static BOOL 
__ApplyFontFace_IsDeviceFontExists(HDC hDC, 
                                   LPLOGFONT lpLogfont, 
                                   struct CFBAG & cfbag, 
#if DBG==1
                                   CCharFormat *pCF, 
#endif
                                   FONTENUMPROC lpEnumFontFamExProc,
                                   BOOL fCheckAlternate)
{
    // (1) Check the system if we have a facename match

    EnumFontFamiliesEx(hDC, lpLogfont, lpEnumFontFamExProc, (LPARAM)&cfbag, 0);
    if (   !cfbag.fMatched 
        && lpLogfont->lfCharSet != DEFAULT_CHARSET)
    {
    // (2) If cannot match in current charset, ignore charset and enumerate again.

        BYTE lfCharSet = lpLogfont->lfCharSet;
        lpLogfont->lfCharSet = DEFAULT_CHARSET;
        EnumFontFamiliesEx(hDC, lpLogfont, lpEnumFontFamExProc, (LPARAM)&cfbag, 0);
        lpLogfont->lfCharSet = lfCharSet;
    }

    if (   fCheckAlternate 
        && !cfbag.fMatched)
    {
    // (3) Check if we have an known alternate name, and see if the system has a match

        const TCHAR * pAltFace = AlternateFontName(lpLogfont->lfFaceName);
        if (pAltFace)
        {
            Assert(_tcsclen(pAltFace) < LF_FACESIZE);

            LOGFONT lf = *lpLogfont;
            StrCpyN(lf.lfFaceName, pAltFace, LF_FACESIZE);

            __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                               pCF,
#endif
                                               lpEnumFontFamExProc, FALSE);
        }
    }
#if DBG==1
    else if (cfbag.fMatched)
    {
        // NOTE (cthrash) Terribly hack for Mangal.  When we
        // enumerate for Mangal, which as Indic font, GDI says we
        // have font with a GDI charset of ANSI.  This is simply
        // false, and furthermore will not create the proper font
        // when we do a CreateFontIndirect.  Hack this so we have
        // some hope of handling Indic correctly.

        // This hack has been removed. We are using EnumFontFamiliesEx,
        // and we are expecting better results.

#if defined(UNIX) || defined(_MAC)
        if (StrCmpIC( szFaceName, TEXT("Mangal")) == 0)
        {
            Assert(pCF->_bCharSet == DEFAULT_CHARSET);
        }
#else
        if (   (((*(DWORD *)lpLogfont->lfFaceName) & 0xffdfffdf) == 0x41004d)
            && StrCmpIC(lpLogfont->lfFaceName, TEXT("Mangal")) == 0)
        {
            Assert(pCF->_bCharSet == DEFAULT_CHARSET);
        }
#endif
    }
#endif // DBG==1

    return cfbag.fMatched;
}

//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_MatchGenericFamily, static
//
//  Synopsis:   If the supplied face name maps to a generic font family, 
//              fill in the appropriate pCF members and return TRUE. 
//              Otherwise, leave pCF untouched and return FALSE.
//
//-----------------------------------------------------------------------------

static BOOL
__ApplyFontFace_MatchGenericFamily(HDC hDC,
                                   TCHAR * szFamilyName, 
                                   BYTE bCharSet,
                                   struct CFBAG & cfbag, 
                                   CCharFormat * pCF)
{
    Assert(_tcsclen(szFamilyName) < LF_FACESIZE);

    int n;
    for (n = 0; n < ARRAY_SIZE(s_fontFamilyMap); ++n)
    {
        if (StrCmpIC(szFamilyName, s_fontFamilyMap[n].szGenericFamily) == 0)
        {
            LOGFONT lf;
            lf.lfCharSet = bCharSet;
            lf.lfPitchAndFamily = 0;
            lf.lfFaceName[0] = _T('\0');
            cfbag.bFamily = s_fontFamilyMap[n].dwWindowsFamily;
            BOOL fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                             pCF,
#endif
                                                             __ApplyFontFace_CompareFamily, FALSE);

            // If enumeration failed for generic font family, use following:
            //   * sans-serif   (FF_SWISS) - use default font
            //   * serif        (FF_ROMAN) - use default font
            //   * monospace   (FF_MODERN) - fixed pitch font
            //   * cursive     (FF_SCRIPT) - italic serif
            //   * fantasy (FF_DECORATIVE) - serif
            if (!fFound)
            {
                switch (s_fontFamilyMap[n].dwWindowsFamily)
                {
                case FF_SWISS:
                case FF_ROMAN:
                    // It shouldn't ever happen. Assert below.
                    break;

                case FF_MODERN:
                    cfbag.bPitch = FIXED_PITCH;
                    fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                pCF,
#endif
                                                                __ApplyFontFace_ComparePitch, FALSE);
                    break;

                case FF_SCRIPT:
                    cfbag.pcf->_fItalic = TRUE;
                    // fall through

                case FF_DECORATIVE:
                    cfbag.bFamily = FF_ROMAN;
                    fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                pCF,
#endif
                                                                __ApplyFontFace_CompareFamily, FALSE);
                    break;
                }
            }

            Assert(fFound);  // It shouldn't ever happen.
            return fFound;
        }
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_MatchDownloadedFont, static
//
//  Synopsis:   If the supplied face name maps to a successfully 
//              downloaded (embedded) font, fill in the appropriate 
//              pCF members and return TRUE. Otherwise, leave pCF untouched 
//              and return FALSE.
//
//-----------------------------------------------------------------------------

static BOOL
__ApplyFontFace_MatchDownloadedFont(TCHAR * szFaceName, 
                                    CCharFormat * pCF, 
                                    CMarkup * pMarkup)
{
    CStyleSheetArray * pStyleSheets = pMarkup->GetStyleSheetArray();
    if (!pStyleSheets)
        return FALSE;

    return pStyleSheets->__ApplyFontFace_MatchDownloadedFont(szFaceName, pCF, pMarkup);
}

//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_ExtractFamilyName, static
//
//  Synopsis:   From the comma-delimited font-family property, extract the
//              next facename.
//
//              As of IE5, we also decode hex-encoded unicode codepoints.
//
//  Returns:    Pointer to scan the next iteration.
//
//-----------------------------------------------------------------------------

static TCHAR *
__ApplyFontFace_ExtractFamilyName(TCHAR * pchSrc, 
                                  TCHAR achFaceName[LF_FACESIZE])
{
    enum PSTATE
    {
        PSTATE_START,
        PSTATE_COPY,
        PSTATE_HEX
    } state = PSTATE_START;

    TCHAR * pchDst = achFaceName;
    TCHAR * pchDstStop = achFaceName + LF_FACESIZE - 1;
    TCHAR chHex = 0;
    TCHAR chStop = _T(',');
    TCHAR * pchSrcOneAfterStart = pchSrc;

    achFaceName[0] = 0;

    while (pchDst < pchDstStop)
    {
        const TCHAR ch = *pchSrc++;

        if (!ch)
        {
            if (chHex)
            {
                *pchDst++ = chHex;
            }

            --pchSrc; // backup for outer while loop.
            break;
        }

        switch (state)
        {
            case PSTATE_START:
                if (ch == _T(' ') || ch == _T(',')) // skip leading junk
                {
                    break;
                }

                pchSrcOneAfterStart = pchSrc;

                state = PSTATE_COPY;

                if (ch == _T('\"') || ch == _T('\'')) // consume quote.
                {
                    pchSrcOneAfterStart++;
                    chStop = ch;
                    break;
                }

                // fall through if non of the above

            case PSTATE_COPY:
                if (ch == chStop)
                {
                    pchDstStop = pchDst; // force exit
                }
                else if (ch == _T('\\'))
                {
                    chHex = 0;
                    state = PSTATE_HEX;
                }
                else
                {
                    *pchDst++ = ch;
                }
                break;

            case PSTATE_HEX:
                if (InRange( ch, _T('a'), _T('f')))
                {
                    chHex = (chHex << 4) + (ch - _T('a') + 10);
                }
                else if (InRange( ch, _T('A'), _T('F')))
                {
                    chHex = (chHex << 4) + (ch - _T('A') + 10);
                }
                else if (InRange( ch, _T('0'), _T('9')))
                {
                    chHex = (chHex << 4) + (ch - _T('0'));
                }
                else if (chHex)
                {
                    *pchDst++ = chHex;
                    --pchSrc; // backup
                    state = PSTATE_COPY;
                    chHex = 0;
                }
                else
                {
                    *pchDst++ = ch;
                }
        }
    }

    // Trim off trailing white space.

    while (pchDst > achFaceName && pchDst[-1] == _T(' '))
    {
        --pchDst;
    }
    *pchDst = 0;

    return (achFaceName[0] == _T('@') && achFaceName[1]) ? pchSrcOneAfterStart : pchSrc;
}

BOOL
MapToInstalledFont(LPCTSTR szFaceName, BYTE * pbCharSet, LONG * platmFaceName)
{
    Assert(pbCharSet);
    Assert(platmFaceName);

    HDC hDC = TLS(hdcDesktop);

    LOGFONT lf;
    lf.lfCharSet = *pbCharSet;
    lf.lfPitchAndFamily = 0;
    Assert(_tcsclen(szFaceName) < LF_FACESIZE);
    StrCpyN(lf.lfFaceName, szFaceName, LF_FACESIZE);

    CCharFormat cf;
    struct CFBAG cfbag(&cf);

    BOOL fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                     &cf,
#endif
                                                     __ApplyFontFace_Compare, TRUE);
    if (fFound)
    {
        *pbCharSet = cf._bCharSet;
        *platmFaceName = cf._latmFaceName;
    }

    return fFound;
}

void
ApplyAtFontFace(CCharFormat *pCF, CDoc *pDoc, CMarkup * pMarkup)
{
    Assert(pCF->NeedAtFont() && !pCF->_fExplicitAtFont);

    const TCHAR * pszFaceNameOriginal = fc().GetFaceNameFromAtom(pCF->_latmFaceName);
    if (pszFaceNameOriginal && pszFaceNameOriginal[0] != _T('@'))
    {
        TCHAR szFaceName[LF_FACESIZE];
        szFaceName[0] = _T('@');
        _tcsncpy(szFaceName + 1, pszFaceNameOriginal, LF_FACESIZE - 2);
        szFaceName[LF_FACESIZE - 1] = 0;

        ApplyFontFace(pCF, szFaceName, AFF_ATFONTPASS | AFF_ATFONTSRCH, pDoc, pMarkup);
    }
}

void
RemoveAtFontFace(CCharFormat *pCF, CDoc *pDoc, CMarkup * pMarkup)
{
    Assert(!pCF->NeedAtFont() && !pCF->_fExplicitAtFont);

    const TCHAR * pszFaceNameOriginal = fc().GetFaceNameFromAtom(pCF->_latmFaceName);
    if (pszFaceNameOriginal && pszFaceNameOriginal[0] == _T('@'))
    {
        TCHAR szFaceName[LF_FACESIZE];
        _tcsncpy(szFaceName, pszFaceNameOriginal + 1, LF_FACESIZE - 1);
        Assert(_tcsclen(szFaceName) < LF_FACESIZE);

        ApplyFontFace(pCF, szFaceName, AFF_ATFONTPASS, pDoc, pMarkup);
    }
}

void
ApplyFontFace(CCharFormat *pCF, LPTSTR p, DWORD dwFlags, CDoc *pDoc, CMarkup * pMarkup)
{
    // Often fonts are specified as a comma-separated list, so we need to
    // just pick the first one in the list which is installed on the user's
    // system.
    // Note: If no fonts in the list are available pCF->szFaceName will not
    //       be touched.

    HDC hDC = TLS(hdcDesktop);
    CODEPAGESETTINGS * pCS = pMarkup->GetCodepageSettings();
    BYTE bCharSet = pCS ? pCS->bCharSet : pDoc->PrimaryMarkup()->GetCodepageSettings()->bCharSet;
    const BOOL fIsPrintDoc = pMarkup && pMarkup->IsPrintMedia();
    CFontCache *pfc = &fc();

    if (p && p[0])
    {
        TCHAR *pStr;
        TCHAR  szFaceName[LF_FACESIZE];
        BOOL   fCacheHit = FALSE;

        // Because we have a cache for most recently used face names
        // that is used for all instances, we enclose the whole thing
        // in a critical section.
        if (!fIsPrintDoc)
            EnterCriticalSection(&pfc->_csFaceCache);

        pStr = (LPTSTR)p;
        while (*pStr)
        {
            struct CFBAG cfbag(pCF);
            BOOL fFound;

            pStr = __ApplyFontFace_ExtractFamilyName(pStr, szFaceName);

            if (!szFaceName[0])
                break;

            // When we're on the screen, we use a cache to speed things up.
            // We don't use if for the printer because we share the cache
            // across all DCs, and we don't want to have matching problems
            // across DCs.
            if (!fIsPrintDoc)
            {
                // The atom name for the given face name.
                LONG lAtom = pfc->FindAtomFromFaceName(szFaceName);

                // Check to see if it's the same as a recent find.
                if (lAtom)
                {
                    int i;
                    for (i = 0; i < pfc->_iCacheLen; i++)
                    {
                        // Check the facename and charset.
                        if (lAtom == pfc->_fcFaceCache[i]._latmFaceName &&
                            bCharSet == pfc->_fcFaceCache[i]._bCharSet)
                        {
                            pCF->_bCharSet = pfc->_fcFaceCache[i]._bCharSet;
                            pCF->_bPitchAndFamily = pfc->_fcFaceCache[i]._bPitchAndFamily;
                            pCF->SetFaceNameAtom(pfc->_fcFaceCache[i]._latmFaceName);
                            pCF->_fExplicitFace = pfc->_fcFaceCache[i]._fExplicitFace;
                            pCF->_fNarrow = pfc->_fcFaceCache[i]._fNarrow;
#if DBG==1
                            pfc->_iCacheHitCount++;
#endif
                            fCacheHit = TRUE;
                            break;
                        }
                    }
                }
                if (fCacheHit)
                    break;
            }
            else
            {
                // Evil, evil hack for IE6 34752
                // The "hi-res" (complex transform)  selection we use when picking fonts
                // doesn't work at measure time.  This should be fixed.
                // Instead, we pretend that "System" is "Arial" while in a layout rect.
                // Please remove this if the device fonts/hi-res non TT font engine get fixes.
                if (_tcsicmp(szFaceName, _T("System")) == 0)
                {
                    _tcscpy(szFaceName, _T("Arial"));
                }
            }

            //
            // Check to see if the font exists. If so, break and return
            //

            // (1) Check our download font list to see if we have a match

            fFound = __ApplyFontFace_MatchDownloadedFont(szFaceName, pCF, pMarkup);

            if (!fFound)
            {
                LOGFONT lf;
                lf.lfCharSet = bCharSet;
                lf.lfPitchAndFamily = 0;
                StrCpyN(lf.lfFaceName, szFaceName, LF_FACESIZE);

            // (2) Check if device font exists

                fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                            pCF,
#endif
                                                            __ApplyFontFace_Compare, TRUE);

            // (3) Check for generic family names (Serif, etc.)

                if (!fFound)
                {
                    fFound = __ApplyFontFace_MatchGenericFamily(hDC, szFaceName, bCharSet, cfbag, pCF);

            // (4) In case of printing check if desktop device font exists

                    if (!fFound && fIsPrintDoc)
                        fFound = __ApplyFontFace_IsDeviceFontExists(TLS(hdcDesktop), &lf, cfbag, 
#if DBG==1
                                                                    pCF,
#endif
                                                                    __ApplyFontFace_Compare, TRUE);

            // (5) In some cases we can ask for non-existing @font. 
            //     In this case ignore font face and ask only for charset. Returned font name 
            //     is existing font, so it is more likely that we have corresponding @font.
            //     But do it only for FE charsets.

                    if (   !fFound 
                        && (dwFlags & AFF_ATFONTSRCH)
                        && IsFECharset(bCharSet) && szFaceName[0] == _T('@'))
                    {
                        Assert(lf.lfCharSet == bCharSet);
                        Assert(lf.lfPitchAndFamily == 0);

                        // There is possiblity that using following logic we don't find any
                        // @font. In this case restore original CF values, because we 
                        // prefer to use original font then fallback font.
                        BYTE bOrigCharSet = pCF->_bCharSet;
                        BYTE bOrigPitchAndFamily = pCF->_bPitchAndFamily;
                        BYTE latmOrigFaceName = pCF->_latmFaceName;

                        FONTENUMPROC lpEnumFontFamExProc = __ApplyFontFace_Compare;
#if NEVER
                        // NOTE (grzegorz): Following code should be enabled, but due
                        // to ForceTT fonts issues need to remove it.
                        // Need to fix every call of GetCss() to get the right font.
                        if (pCF->_bPitchAndFamily)
                        {
                            lpEnumFontFamExProc = __ApplyFontFace_CompareFamily;
                            cfbag.bFamily = (pCF->_bPitchAndFamily & 0xf0);
                        }
#endif

                        lf.lfFaceName[0] = 0;
                        fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                    pCF,
#endif
                                                                    lpEnumFontFamExProc, FALSE);
                        if (fFound)
                        {
                            cfbag.fMatched = FALSE;
                            lf.lfFaceName[0] = _T('@');
                            _tcsncpy(lf.lfFaceName + 1, fc().GetFaceNameFromAtom(pCF->_latmFaceName), LF_FACESIZE - 2);
                            lf.lfFaceName[LF_FACESIZE - 1] = 0;
                            fFound = __ApplyFontFace_IsDeviceFontExists(hDC, &lf, cfbag, 
#if DBG==1
                                                                        pCF,
#endif
                                                                        lpEnumFontFamExProc, FALSE);
                            if (!fFound)
                            {
                                // Restore original CF values (see comment above)
                                pCF->_bCharSet = bOrigCharSet;
                                pCF->_bPitchAndFamily = bOrigPitchAndFamily;
                                pCF->SetFaceNameAtom(latmOrigFaceName);
                            }
                        }
                    }
                }
            }

            if (fFound)
            {

                // (greglett)
                // Enabling this hack causes problems when printing fonts that don't exist in a local character
                // set (e.g.: Tahoma font on a localized KOR Win98 - Bug 101341).
                // This should work okay, as the new fontlinking code should pick up that the font does not support
                // the given charset and link in a font that does.
#ifdef PRINT_HACKS
                //
                // HACK (cthrash) Font enumeration doens't work on certain
                // drivers.  Insist on the charset rather than the facename.
                //

                if (   VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID
                    && cfbag.fMatched
                    && pCF->_bCharSet != bCharSet
                    && pCF->_bCharSet != SYMBOL_CHARSET
                    && pCF->_bCharSet != OEM_CHARSET
                    && fIsPrintDoc)
                {
                    pCF->_bCharSet = bCharSet;
                }
#endif

                pCF->_fExplicitFace = TRUE;
                pCF->_fNarrow = IsNarrowCharSet(pCF->_bCharSet);
                break;
            }
        }

        // Update the cache and leave the critical section.
        if (!fIsPrintDoc)
        {
            if (!fCacheHit)
            {
                int iCacheNext = pfc->_iCacheNext;
                pfc->_fcFaceCache[iCacheNext]._bCharSet = pCF->_bCharSet;
                pfc->_fcFaceCache[iCacheNext]._bPitchAndFamily = pCF->_bPitchAndFamily;
                pfc->_fcFaceCache[iCacheNext]._latmFaceName = pCF->_latmFaceName;
                pfc->_fcFaceCache[iCacheNext]._fExplicitFace = pCF->_fExplicitFace;
                pfc->_fcFaceCache[iCacheNext]._fNarrow = pCF->_fNarrow;

                pfc->_iCacheNext++;
                if (pfc->_iCacheLen < CFontCache::cFontFaceCacheSize)
                    pfc->_iCacheLen++;
                if (pfc->_iCacheNext >= CFontCache::cFontFaceCacheSize)
                    pfc->_iCacheNext = 0;
            }
            LeaveCriticalSection(&pfc->_csFaceCache);
        }

        // If we picked up @font, store this information
        pCF->_fExplicitAtFont = !(dwFlags & AFF_ATFONTPASS) && 
            (fc().GetFaceNameFromAtom(pCF->_latmFaceName)[0] == _T('@')) ;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleLargerSmaller
//
//  Synopsis:   Helper function called from ApplyFontSize to handle "larger"
//              and "smaller" font sizes.  Returns TRUE if we handled a "larger"
//              or "smaller" case, returns FALSE if we didn't do anything.
//
//-----------------------------------------------------------------------------

static BOOL HandleLargerSmaller(long *plSize, long lUnitValue )
{
    long lSize = *plSize;
    const int nNumElem = ARRAY_SIZE(aiSizesInTwips);
    int i;

    switch (lUnitValue)
    {
    case styleFontSizeLarger:
        // Look for a larger size in the abs. size array
        for (i=0 ; i < nNumElem ; ++i)
        {
            if (aiSizesInTwips[i] > lSize)
            {
                *plSize = aiSizesInTwips[i];
                return TRUE;
            }
        }
        // We are bigger than "xx-large"; use factor of 1.5x
        *plSize = lSize * 3 / 2;
        return TRUE;
    case styleFontSizeSmaller:
        // If we are more than 1.5x bigger than the largest size in the
        // abs. size array, then only shrink down by 1.5x.
        if ( (lSize * 2 / 3) > aiSizesInTwips[nNumElem-1] )
        {
            *plSize = lSize * 2 / 3;
            return TRUE;
        }
        // Look for a smaller size in the abs. size array
        for (i=nNumElem-1 ; i >= 0 ; --i)
        {
            if (aiSizesInTwips[i] < lSize)
            {
                *plSize = aiSizesInTwips[i];
                return TRUE;
            }
        }
        // We are smaller than "xx-small"; use factor of 1/1.5x
        *plSize = lSize * 2 / 3;
        return TRUE;
    default:
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontSize
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Size
//
//-----------------------------------------------------------------------------
void ApplyFontSize(
    CFormatInfo *pCFI,
    const CUnitValue *pCUV,
    BOOL fAlwaysUseMyFontSize,
    BOOL fComputingFirstLetter,
    BOOL fComputingFirstLine)
{
    LONG lSize;
    BOOL fScale = FALSE;
    CUnitValue::UNITVALUETYPE uvt;
    CCharFormat *pCF   = &pCFI->_cf();
    CTreeNode   *pNode = pCFI->_pNodeContext;

    Assert( pNode );
    Assert( pCF );

    if ( pCUV->IsNull() )
        return;

    // See what value we inherited in the CF.  lSize is in twips.
    lSize = pCF->GetHeightInTwips( pNode->Doc() );

    if (fComputingFirstLine && !pCFI->_fUseParentSizeForPseudo)
    {
        if (pCFI->_fSecondCallForFirstLine)
        {
            lSize = pCFI->_lParentHeightForFirstLine;
        }
        else
        {
            pCFI->_lParentHeightForFirstLine = lSize;
            pCFI->_fSecondCallForFirstLine = TRUE;
        }
    }
    else if (fComputingFirstLetter && !pCFI->_fUseParentSizeForPseudo)
    {
        if (pCFI->_fSecondCallForFirstLetter)
        {
            lSize = pCFI->_lParentHeightForFirstLetter;
        }
        else
        {
            pCFI->_lParentHeightForFirstLetter = lSize;
            pCFI->_fSecondCallForFirstLetter = TRUE;
        }
    }
    else
    {
        // But use our parent element's value if we can get it, as per CSS1 spec for font-size.
        // However, if we are computing first letter and our block element has a first-line
        // spec, then that firstline spec is our "parent" and we need to respect its size.
        // However, the parent over here is the body and not the block element. Hence the
        // check for fUseParentSize above.
        CTreeNode * pNodeParent = pNode->Parent();
        if (pNodeParent)
        {
            const CCharFormat *pParentCF = pNodeParent->GetCharFormat();
            if (pParentCF)
            {
                lSize = pParentCF->GetHeightInTwips( pNodeParent->Doc() );
                fScale = !pParentCF->_fSizeDontScale;
            }
        }
    }
    
    uvt = pCUV->GetUnitType();

    switch(uvt)
    {
    case CUnitValue::UNIT_RELATIVE:     // Relative to the base font size
        {
            LONG lBaseFontHtmlSize = 3;

            // Base fonts don't inherit through table cells or other
            // text sites.
            pNode = pNode->SearchBranchToFlowLayoutForTag( ETAG_BASEFONT );

            if (pNode)
                lBaseFontHtmlSize = DYNCAST(CBaseFontElement, pNode->Element())->GetFontSize();

            lSize = ConvertHtmlSizeToTwips( lBaseFontHtmlSize + pCUV->GetUnitValue() );
        }
        fScale = TRUE;
        break;
    case CUnitValue::UNIT_PERCENT:
        lSize = MulDivQuick( lSize, pCUV->GetPercent(), 100 );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_EM:
        lSize = MulDivQuick(lSize, pCUV->GetUnitValue(), CUnitValue::TypeNames[CUnitValue::UNIT_EM].wScaleMult);
        break;
//        UNIT_EN,            // en's ( relative to width of an "n" character in current-font )
    case CUnitValue::UNIT_EX:
        // NOTE (mikhaill, grzegorz): following "* 2" should be kind of approximation, since we do not
        // actually extract sizes of letter "x" for UNIT_EX (nor "m" for UNIT_EM). This can affect
        // tags with declaration like style = "font-size:1ex" that currently is not used in DRT.
        lSize = MulDivQuick( lSize, pCUV->GetUnitValue(), CUnitValue::TypeNames[CUnitValue::UNIT_EX].wScaleMult * 2 );
        break;
    case CUnitValue::UNIT_POINT:  // Convert from points to twips
        lSize = MulDivQuick( pCUV->GetUnitValue(), 20, CUnitValue::TypeNames[CUnitValue::UNIT_POINT].wScaleMult );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_ENUM:
        if ( !HandleLargerSmaller( &lSize, pCUV->GetUnitValue() ) ) // lSize modified if ret=true
        {
            BOOL fIsStrictCSS = pNode->GetMarkup()->IsStrictCSS1Document();
            lSize = ConvertFontSizeToTwips( pCUV->GetUnitValue(), fIsStrictCSS);
        }
        fScale = TRUE;
        break;
    case CUnitValue::UNIT_INTEGER:
        lSize = ConvertHtmlSizeToTwips( pCUV->GetUnitValue() );
        fScale = TRUE;
        break;
    case CUnitValue::UNIT_PICA:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 240, CUnitValue::TypeNames[CUnitValue::UNIT_PICA].wScaleMult );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_INCH:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 1440, CUnitValue::TypeNames[CUnitValue::UNIT_INCH].wScaleMult );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_CM:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 144000, CUnitValue::TypeNames[CUnitValue::UNIT_CM].wScaleMult * 254 );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_MM:
        lSize = MulDivQuick( pCUV->GetUnitValue(), 144000, CUnitValue::TypeNames[CUnitValue::UNIT_MM].wScaleMult * 2540 );
        fScale = FALSE;
        break;
    case CUnitValue::UNIT_PIXELS:
        {
            CUnitValue cuv;

            cuv.SetRawValue( pCUV->GetRawValue() );
            THR( cuv.ConvertToUnitType( CUnitValue::UNIT_POINT, 1, CUnitValue::DIRECTION_CY, lSize ) );
            lSize = MulDivQuick( cuv.GetUnitValue(), 20, CUnitValue::TypeNames[CUnitValue::UNIT_POINT].wScaleMult );
            fScale = FALSE;
        }
        break;
    default:
        //AssertSz(FALSE,"Suspicious CUnitValue in ApplyFontSize.");
        break;
    }

    if ( lSize < 0 )
        lSize = -lSize;

    if (pCF->_fBumpSizeDown &&
        uvt != CUnitValue::UNIT_RELATIVE &&
        uvt != CUnitValue::UNIT_PERCENT &&
        uvt != CUnitValue::UNIT_TIMESRELATIVE)
    {
        // For absolute font size specifications, element which normally
        // may have set fBumpSize down must cancel it (nav compatibility).
        pCF->_fBumpSizeDown = FALSE;
    }


    // Make sure that size is within the abs. size array range if
    // 'Always Use My Font Size' is chosen from the option settings
    if (fAlwaysUseMyFontSize)
    {
        long nSizes = ARRAY_SIZE(aiSizesInTwips);
        lSize = (lSize < aiSizesInTwips[0]) ? aiSizesInTwips[0] : ((lSize > aiSizesInTwips[nSizes-1]) ? aiSizesInTwips[nSizes-1] : lSize);
    }

    if ( fScale )
        pCF->SetHeightInTwips( lSize );
    else
        pCF->SetHeightInNonscalingTwips( lSize );
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyBaseFont
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Base Font Size
//
//-----------------------------------------------------------------------------
inline void ApplyBaseFont(CCharFormat *pCF, long lSize)
{
    pCF->SetHeightInTwips( ConvertHtmlSizeToTwips(lSize) );
}

//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontStyle
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Style
//
//-----------------------------------------------------------------------------
inline void ApplyFontStyle(CCharFormat *pCF, styleFontStyle sfs)
{
    if ( sfs == styleFontStyleNotSet )
        return;

    if ( ( sfs == styleFontStyleItalic ) || ( sfs == styleFontStyleOblique ) )
        pCF->_fItalic = TRUE;
    else
        pCF->_fItalic = FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   ApplyFontWeight
//
//  Synopsis:   Helper function called exactly once from ApplyAttrArrayOnXF.
//              Apply a Font Weight
//
//-----------------------------------------------------------------------------
inline void ApplyFontWeight(CCharFormat *pCF, styleFontWeight sfw )
{
    if ( sfw == styleFontWeightNotSet  )
        return;

    if ( sfw == styleFontWeightBolder )
    {
        pCF->_wWeight = (WORD)min( 900, pCF->_wWeight+300 );
    }
    else if ( sfw == styleFontWeightLighter )
    {
        pCF->_wWeight = (WORD)max( 100, pCF->_wWeight-300 );
    }
    else
    {
        //See wingdi.h and our enum table
        //we currently do not handle relative boldness
        Assert(1 == styleFontWeight100);

        if ( sfw == styleFontWeightNormal )
            sfw = styleFontWeight400;
        if ( sfw == styleFontWeightBold )
            sfw = styleFontWeight700;

        pCF->_wWeight = 100 * (DWORD) sfw;
    }

    if (FW_NORMAL < pCF->_wWeight)
        pCF->_fBold = TRUE;
    else
        pCF->_fBold = FALSE;
}

BOOL g_fSystemFontsNeedRefreshing = TRUE;
#define NUM_SYS_FONTS 6
static LOGFONTW alfSystemFonts[ NUM_SYS_FONTS ]; // sysfont_caption, sysfont_icon, sysfont_menu, sysfont_messagebox, sysfont_smallcaption, sysfont_statusbar
extern int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch); // defined in core\wrappers\unicwrap.cxx

void RefreshSystemFontCache( void )
{
#ifdef WINCE
    GetObject(GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &alfSystemFonts[ sysfont_icon ]);

    memcpy( &alfSystemFonts[ sysfont_caption ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_menu ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_messagebox ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_smallcaption ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
    memcpy( &alfSystemFonts[ sysfont_statusbar ], &alfSystemFonts[ sysfont_icon ], sizeof(LOGFONT) );
#else

    SystemParametersInfo( SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &alfSystemFonts[ sysfont_icon ], 0 );
    if (VER_PLATFORM_WIN32_WINDOWS != g_dwPlatformID)
    {
        NONCLIENTMETRICS ncm;
        
        ncm.cbSize  = sizeof(NONCLIENTMETRICS);
        if ( SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 ) )
        {   // Copy fonts into place
            memcpy( &alfSystemFonts[ sysfont_caption ], &ncm.lfCaptionFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_menu ], &ncm.lfMenuFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_messagebox ], &ncm.lfMessageFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_smallcaption ], &ncm.lfSmCaptionFont, sizeof(LOGFONT) );
            memcpy( &alfSystemFonts[ sysfont_statusbar ], &ncm.lfStatusFont, sizeof(LOGFONT) );
        }
    }
    else
    {   // Probably failed due to Unicodeness, try again with short char version of NCM.
        NONCLIENTMETRICSA ncma;

        ncma.cbSize = sizeof(NONCLIENTMETRICSA);
        if ( SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncma, 0 ) )
        {   // Copy the fonts and do the Unicode conversion.
            memcpy( &alfSystemFonts[ sysfont_caption ], &ncma.lfCaptionFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_caption ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_caption ].lfFaceName),
                             ncma.lfCaptionFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_menu ], &ncma.lfMenuFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_menu ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_menu ].lfFaceName),
                             ncma.lfMenuFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_messagebox ], &ncma.lfMessageFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_messagebox ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_messagebox ].lfFaceName),
                             ncma.lfMessageFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_smallcaption ], &ncma.lfSmCaptionFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_smallcaption ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_smallcaption ].lfFaceName),
                             ncma.lfSmCaptionFont.lfFaceName, -1 );
            memcpy( &alfSystemFonts[ sysfont_statusbar ], &ncma.lfStatusFont, sizeof(LOGFONTA) );
            UnicodeFromMbcs( alfSystemFonts[ sysfont_statusbar ].lfFaceName, ARRAY_SIZE(alfSystemFonts[ sysfont_statusbar ].lfFaceName),
                             ncma.lfStatusFont.lfFaceName, -1 );
        }
    }
#endif // WINCE
    g_fSystemFontsNeedRefreshing = FALSE;
}

void ApplySystemFont( CCharFormat *pCF, Esysfont eFontType )
{
    LOGFONT *lplf = NULL;
    long lSize = 1;

    if ( g_fSystemFontsNeedRefreshing )
        RefreshSystemFontCache();

    if ( ( eFontType < sysfont_caption ) || ( eFontType > sysfont_statusbar ) )
        return;

    lplf = &alfSystemFonts[ eFontType ];

    pCF->SetFaceName( lplf->lfFaceName );
    pCF->_bCharSet = lplf->lfCharSet;
    pCF->_fNarrow = IsNarrowCharSet(lplf->lfCharSet);
    pCF->_bPitchAndFamily = lplf->lfPitchAndFamily;
    pCF->_wWeight = lplf->lfWeight;
    pCF->_fBold = (pCF->_wWeight > 400);
    pCF->_fItalic = lplf->lfItalic;
    pCF->_fUnderline = lplf->lfUnderline;
    pCF->_fStrikeOut = lplf->lfStrikeOut;

    lSize = g_uiDisplay.TwipsFromDeviceY(lplf->lfHeight);
    if ( lSize < 0 )
        lSize = -lSize;
    pCF->SetHeightInTwips( lSize );
}

void ApplySiteAlignment (CFormatInfo *pCFI, htmlControlAlign at, CElement * pElem)
{
    if (at == htmlControlAlignNotSet)
        return;

    BYTE va = styleVerticalAlignAuto;
    switch (at)
    {
    case htmlControlAlignLeft:
        if(pElem->Tag() == ETAG_LEGEND)
            pCFI->_bCtrlBlockAlign = htmlBlockAlignLeft;
        break;
    case htmlControlAlignCenter:
        pCFI->_bCtrlBlockAlign = htmlBlockAlignCenter;
        va = styleVerticalAlignMiddle;
        break;
    case htmlControlAlignRight:
        if(pElem->Tag() == ETAG_LEGEND)
            pCFI->_bCtrlBlockAlign = htmlBlockAlignRight;
        break;
    case htmlControlAlignTextTop:
        va = styleVerticalAlignTextTop;
        break;
    case htmlControlAlignAbsMiddle:
        va = styleVerticalAlignAbsMiddle;
        break;
    case htmlControlAlignBaseline:
        va = styleVerticalAlignBaseline;
        break;
    case htmlControlAlignAbsBottom:
        va = styleVerticalAlignBottom;
        break;
    case htmlControlAlignBottom:
        va = styleVerticalAlignTextBottom;
        break;
    case htmlControlAlignMiddle:
        va = styleVerticalAlignMiddle;
        break;
    case htmlControlAlignTop:
        va = styleVerticalAlignTop;
        break;
    default:
        Assert(FALSE);
    }

    if (styleVerticalAlignAuto != va)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff().SetVerticalAlign((styleVerticalAlign)va);
        pCFI->UnprepareForDebug();
    }
    pCFI->_bControlAlign = at;
}

void ApplyParagraphAlignment ( CFormatInfo *pCFI, htmlBlockAlign at, CElement *pElem )
{
    if ( at == htmlBlockAlignNotSet )
        return;

    switch(at)
    {
    case htmlBlockAlignRight:
    case htmlBlockAlignLeft:
    case htmlBlockAlignCenter:
        pCFI->_bBlockAlign = at;
        break;
    case htmlBlockAlignJustify:
        if (pElem->Tag() != ETAG_CAPTION)   // ignore Justify for captions,
                                            // we use Justify enum in cpation.pdl just to be consistent
                                            // with the rest of the block alignment enums.
        {
            pCFI->_bBlockAlign = at;
        }
        break;
    default:
        if (pElem->Tag() == ETAG_CAPTION)
        {
            // There's some trickyness going on here.  The caption.pdl
            // specifies the align as DISPID_A_BLOCKALIGN - which means it
            // gets written into the lrcAlign - but caption has two extra
            // ( vertical ) enum values that we need to map onto the equivalent
            // vertical alignment values.

            if ((BYTE)at == htmlCaptionAlignTop || (BYTE)at == htmlCaptionAlignBottom)
            {
                at = (htmlBlockAlign)((BYTE)at == htmlCaptionAlignTop? htmlCaptionVAlignTop: htmlCaptionVAlignBottom);
                if (pCFI->_ppf->_bTableVAlignment != (BYTE)at)
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._bTableVAlignment = (BYTE)at;
                    pCFI->UnprepareForDebug();
                }
                break;
            }
        }
        pCFI->_bBlockAlign = htmlBlockAlignNotSet;
        break;
    }
}

void ApplyVerticalAlignment(CFormatInfo *pCFI, BYTE va, CElement *pElem)
{
    switch (pElem->Tag())
    {
    case ETAG_TD:
    case ETAG_TH:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_TBODY:
    case ETAG_TFOOT:
    case ETAG_THEAD:
    case ETAG_TR:
    case ETAG_CAPTION:
        {
            htmlCellVAlign cvt = htmlCellVAlignNotSet;

            switch (va)
            {
            case styleVerticalAlignTop:
            case styleVerticalAlignTextTop:
                cvt = htmlCellVAlignTop;
                break;
            case styleVerticalAlignTextBottom:
            case styleVerticalAlignBottom:
                cvt = htmlCellVAlignBottom;
                break;
            case styleVerticalAlignBaseline:
                cvt = htmlCellVAlignBaseline;
                break;
            case styleVerticalAlignMiddle:
            default:
                cvt = pElem->Tag() != ETAG_CAPTION ? htmlCellVAlignMiddle : htmlCellVAlignTop;
                break;
            }
            if (pCFI->_ppf->_bTableVAlignment != cvt)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = cvt;
                pCFI->UnprepareForDebug();
            }
        }
        break;
    default:
        {
            htmlControlAlign at = htmlControlAlignNotSet;
            BOOL fSetCtrl       = TRUE;

            switch (va)
            {
            case styleVerticalAlignSub:
            case styleVerticalAlignSuper:
                fSetCtrl = FALSE;
                break;

            case styleVerticalAlignTextBottom:
            case styleVerticalAlignBaseline:
                at = htmlControlAlignNotSet;
                break;
            case styleVerticalAlignTop:
                at = htmlControlAlignTop;
                break;
            case styleVerticalAlignTextTop:
                at = htmlControlAlignTextTop;
                break;
            case styleVerticalAlignMiddle:
                at = htmlControlAlignMiddle;
                break;
            case styleVerticalAlignBottom:
                at = htmlControlAlignAbsBottom;
                break;
            }

            if (fSetCtrl)
                pCFI->_bControlAlign = at;
        }
        break;
    }
}

void ApplyTableVAlignment ( CParaFormat *pPF, htmlCellVAlign at)
{
    if ( at == htmlCellVAlignNotSet )
        return;
    pPF ->_bTableVAlignment = at;

}

void ApplyLineHeight( CCharFormat *pCF, CUnitValue *cuv )
{
    Assert( pCF && cuv );

    if ( ( cuv->GetUnitType() == CUnitValue::UNIT_ENUM ) && ( cuv->GetUnitValue() == styleNormalNormal ) )
        cuv->SetNull();

    pCF->_cuvLineHeight = *cuv;

}

BOOL ConvertCSSToFmBorderStyle( long lCSSBorderStyle, BYTE *pbFmBorderStyle )
{
    switch ( lCSSBorderStyle )
    {
    case styleBorderStyleNotSet: // No change
        return FALSE;
    case styleBorderStyleDotted:
        *pbFmBorderStyle = fmBorderStyleDotted;
        break;
    case styleBorderStyleDashed:
        *pbFmBorderStyle = fmBorderStyleDashed;
        break;
    case styleBorderStyleDouble:
        *pbFmBorderStyle = fmBorderStyleDouble;
        break;
    case styleBorderStyleSolid:
        *pbFmBorderStyle = fmBorderStyleSingle;
        break;
    case styleBorderStyleGroove:
        *pbFmBorderStyle = fmBorderStyleEtched;
        break;
    case styleBorderStyleRidge:
        *pbFmBorderStyle = fmBorderStyleBump;
        break;
    case styleBorderStyleInset:
        *pbFmBorderStyle = fmBorderStyleSunken;
        break;
    case styleBorderStyleOutset:
        *pbFmBorderStyle = fmBorderStyleRaised;
        break;
    case styleBorderStyleWindowInset:
        *pbFmBorderStyle = fmBorderStyleWindowInset;
        break;
    case styleBorderStyleNone:
        *pbFmBorderStyle = fmBorderStyleNone;
        break;
    default:
        Assert( FALSE && "Unknown Border Style!" );
        return FALSE;
    }
    return TRUE;
}

void ApplyLang(CCharFormat *pCF, LPTSTR achLang)
{
    if (!pCF)
        return;

    pCF->_lcid = mlang().LCIDFromString(achLang);
}

//+------------------------------------------------------------------------
//
//  Method:     ::ApplyAttrArrayValues
//
//  Synopsis:   Apply all the CAttrValues in a CAttrArray to a given set of formats.
//
//      If passType is APPLY_All, work normally.  If passType is APPLY_ImportantOnly,
//  then only apply attrvals with the "!important" bit set.  If passType is
//  APPLY_NoImportant, then only apply attrvals that do not have the "!important"
//  bit set - but if pfContainsImportant is non-NULL, set it to TRUE if you see
//  an attrval with the "!important" bit set.
//
//+------------------------------------------------------------------------
HRESULT ApplyAttrArrayValues (
    CStyleInfo *pStyleInfo,
    CAttrArray **ppAA,
    CachedStyleSheet *pStyleCache /* = NULL */,
    ApplyPassType passType /*=APPLY_All*/,
    BOOL *pfContainsImportant /*=NULL*/,
    BOOL fApplyExpandos /*= TRUE */,
    DISPID dispidSetValue /* = 0 */)
{
    // Apply all Attr values
    HRESULT hr = S_OK;

    Assert(ppAA);
    if ( !*ppAA || (*ppAA) -> Size() == 0 )
        return S_OK;

    if (passType == APPLY_Behavior)
    {
        hr = THR(ApplyBehaviorProperty(
            *ppAA,
            (CBehaviorInfo*) pStyleInfo,
            pStyleCache));
    }
    else // if (passType != APPLY_Init)
    {
        CFormatInfo *pCFI;
        CAttrValue *pAV;  //The current AttrValue.  Only valid when nAA>0
        INT i;
        VARIANT varVal;
        
        pAV = (CAttrValue *)*(CAttrArray *)(*ppAA);

        pCFI = (CFormatInfo*)pStyleInfo;

        // Apply regular attributes
        for ( i = 0 ; i < (*ppAA) -> Size() ; i++, pAV++ )
        {
            // When applying extra values apply only the value that was requested
            if ((pCFI->_eExtraValues & ComputeFormatsType_GetValue) && 
                pAV->GetDISPID() != pCFI->_dispIDExtra)
                continue;

            pAV->GetAsVariantNC(&varVal);

            // Apply these only if they're set & actual properties
            if ( pAV->IsStyleAttribute() )
            {
                if ( ( passType == APPLY_All ) ||   // Normal pass
                     ( passType == APPLY_NoImportant && !pAV->IsImportant() ) ||    // Only non-important properties
                     ( passType == APPLY_ImportantOnly && pAV->IsImportant() ) )    // Important properties only
                {                    
                    hr = THR(ApplyFormatInfoProperty ( pAV->GetPropDesc(), pAV->GetDISPID(),
                        varVal, pCFI, pStyleCache, ppAA  ));
                    if ( hr )
                        break;

                    // If there's an expression with the same DISPID, now is the time to delete it.
                    //
                    // NOTE: (michaelw) this work should go away when CAttrValueExpression comes into being.
                    //
                    // If dispidSetValue is set then we do not overwrite expressions with that dispid
                    // dispidSetValue == 0 means that we overwrite any and all expressions
                    //
                    // Expression values never overwrite expressions (hence the !pAV->IsExpression())
                    //
                    if (!pAV->IsExpression() && pCFI->_pff->_fHasExpressions && ((dispidSetValue == 0) || (dispidSetValue != pAV->GetDISPID())))
                    {
                        CAttrArray *pAA = pCFI->GetAAExpando();

                        if (pAA)
                        {
#if DBG == 1
                            {
                                CAttrValue *pAVExpr = pAA->Find(pAV->GetDISPID(), CAttrValue::AA_Expression, NULL, FALSE);
                                if (pAVExpr)
                                {
                                    TraceTag((tagRecalcStyle, "ApplyAttrArrayValues: overwriting expression: dispid: %08x expr: %ls with value dispid: %08x", pAVExpr->GetDISPID(), pAVExpr->GetLPWSTR(), pAV->GetDISPID()));
                                }
                            }
#endif
                            pAA->FindSimpleAndDelete(pAV->GetDISPID(), CAttrValue::AA_Expression);
                        }

                    }
                }
                if ( pfContainsImportant && pAV->IsImportant())
                    *pfContainsImportant = TRUE;

            }
            else if(fApplyExpandos && passType != APPLY_ImportantOnly && (pAV->AAType() == CAttrValue::AA_Expando))
            {
                CAttrArray * pAA = pCFI->GetAAExpando();
                hr = THR(CAttrArray::Set(&pAA, pAV->GetDISPID(), &varVal, NULL, CAttrValue::AA_Expando));
                if(hr)
                    break;
            }
            else if (   fApplyExpandos 
                     && passType != APPLY_ImportantOnly 
                     && pAV->AAType() == CAttrValue::AA_Expression
                     && pCFI->GetMatchedBy() == pelemNone
                    )
            {

                TraceTag((tagRecalcStyle, "ApplyAttrArrayValues: cascading expression %08x '%ls'", pAV->GetDISPID(), pAV->GetLPWSTR()));
                CAttrArray *pAA = pCFI->GetAAExpando();
                hr = THR(CAttrArray::Set(&pAA, pAV->GetDISPID(), &varVal, NULL, CAttrValue::AA_Expression));
                if (hr)
                    break;
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._fHasExpressions = TRUE;
                pCFI->UnprepareForDebug();
            }
        }  // eo for ( i = 0 ; i < (*ppAA) -> Size() ; i++, pAV++ )
    } // eo if (passType != APPLY_Init)

    RRETURN(hr);
}

// Convert attribute to style list types.
static styleListStyleType ListTypeToStyle (htmlListType type)
{
    styleListStyleType retType;
    switch (type)
    {
        default:
        case htmlListTypeNotSet:
            retType = styleListStyleTypeNotSet;
            break;
        case htmlListTypeLargeAlpha:
            retType = styleListStyleTypeUpperAlpha;
            break;
        case htmlListTypeSmallAlpha:
            retType = styleListStyleTypeLowerAlpha;
            break;
        case htmlListTypeLargeRoman:
            retType = styleListStyleTypeUpperRoman;
            break;
        case htmlListTypeSmallRoman:
            retType = styleListStyleTypeLowerRoman;
            break;
        case htmlListTypeNumbers:
            retType = styleListStyleTypeDecimal;
            break;
        case htmlListTypeDisc:
            retType = styleListStyleTypeDisc;
            break;
        case htmlListTypeCircle:
            retType = styleListStyleTypeCircle;
            break;
        case htmlListTypeSquare:
            retType = styleListStyleTypeSquare;
            break;
    }
    return retType;
}

//+---------------------------------------------------------------------------
//
// Helper class: CUrlStringIterator
//
//----------------------------------------------------------------------------

class CUrlStringIterator
{
public:

    CUrlStringIterator();
    ~CUrlStringIterator();
    void            Init(LPTSTR pch);
    void            Unroll();
    void            Step();
    inline BOOL     IsEnd()   { return 0 == _pchStart[0]; };
    inline BOOL     IsError() { return S_OK != _hr; }
    inline LPTSTR   Current() { return _pchStart; };

    HRESULT _hr;
    LPTSTR  _pch;
    LPTSTR  _pchStart;
    LPTSTR  _pchEnd;
    TCHAR   _chEnd;
};

CUrlStringIterator::CUrlStringIterator()
{
    memset (this, 0, sizeof(*this));
}

CUrlStringIterator::~CUrlStringIterator()
{
    Unroll();
}

void
CUrlStringIterator::Init(LPTSTR pch)
{
    _hr = S_OK;
    _pch = pch;

    Assert (_pch);

    Step();
}

void
CUrlStringIterator::Unroll()
{
    if (_pchEnd)
    {
        *_pchEnd = _chEnd;
        _pchEnd =  NULL;
    }
}

void
CUrlStringIterator::Step()
{
    Unroll();

    //
    // CONSIDER (alexz) using a state machine instead
    //

    _pchStart = _pch;

    // skip spaces or commas
    while (_istspace(*_pchStart) || _T(',') == *_pchStart)
        _pchStart++;

    if (0 == *_pchStart)
        return;

    // verify presence of "URL" prefix
    if (0 != StrCmpNIC(_pchStart, _T("URL"), 3))
        goto Error;

    _pchStart += 3; // step past "URL"

    // skip spaces between "URL" and "("
    while (_istspace(*_pchStart))
        _pchStart++;

    // verify presence of "("
    if (_T('(') != *_pchStart)
        goto Error;

    _pchStart++; // step past "("

    // skip spaces following "("
    while (_istspace(*_pchStart))
        _pchStart++;

    // verify that not end yet
    if (0 == *_pchStart)
        goto Error;

    // if quoted string...
    if (_T('\'') == *_pchStart || _T('"') == *_pchStart)
    {
        TCHAR       chClosing;

        chClosing = *_pchStart;
        _pchStart++;

        _pch = _pchStart;

        while (0 != *_pch && chClosing != *_pch)
            _pch++;

        // verify that not end yet
        if (0 == *_pch)
            goto Error;

        _pchEnd = _pch;

        _pch++; // step past quote
    }
    else // if not quoted
    {
        _pch = _pchStart;

        // scan to end, ")" or space
        while (0 != *_pch && _T(')') != *_pch && !_istspace(*_pch))
            _pch++;

        // verify that not end yet
        if (0 == *_pch)
            goto Error;

        _pchEnd = _pch;
    }

    // skip spaces
    while (_istspace(*_pch))
        _pch++;

    if (_T(')') != *_pch)
        goto Error;

    _pch++;

    // null-terminate current url (Unroll restores it)
    _chEnd = *_pchEnd;
    *_pchEnd = 0;

    return;

Error:
    _pchEnd = NULL;
    _hr = E_INVALIDARG;
    return;
}

//+---------------------------------------------------------------------------
//
// Helper:      ApplyBehaviorProperty
//
//----------------------------------------------------------------------------

HRESULT
ApplyBehaviorProperty (
    CAttrArray *        pAA,
    CBehaviorInfo *     pInfo,
    CachedStyleSheet *  pSheetCache)
{
    HRESULT             hr = S_OK;
    LPTSTR              pchUrl;
    CAttrValue *        pAV;
    AAINDEX             aaIdx = AA_IDX_UNKNOWN;
    CUrlStringIterator  iterator;

    pAV = pAA->Find(DISPID_A_BEHAVIOR, CAttrValue::AA_Attribute, &aaIdx);
    if (!pAV)
        goto Cleanup;

    pInfo->_acstrBehaviorUrls.Free();

    Assert (VT_LPWSTR == pAV->GetAVType());

    pchUrl = pAV->GetString();
    if (!pchUrl || !pchUrl[0])
        goto Cleanup;

    iterator.Init(pchUrl);
    while (!iterator.IsEnd() && !iterator.IsError())
    {
        hr = THR(pInfo->_acstrBehaviorUrls.AddNameToAtomTable(iterator.Current(), NULL));
        if (hr)
            goto Cleanup;

        iterator.Step();
    }

Cleanup:
    RRETURN (hr);
}

BOOL FilterForPseudoCore(DISPID aSupport[], LONG len, DISPID dispID)
{
    LONG i;
    for (i = 0; i < len; i++)
    {
        if (aSupport[i] == dispID)
            return TRUE;
    }
    return FALSE;
}

BOOL FilterForPseudoElement(EPseudoElement pPseudoElem, DISPID dispID)
{
    static DISPID aSupportedByBoth[] = {
        // Font properties
        DISPID_A_FONT, DISPID_A_FONTSIZE, DISPID_A_FONTSTYLE, DISPID_A_FONTVARIANT,
        DISPID_A_FONTFACE, DISPID_A_BASEFONT, DISPID_A_FONTWEIGHT,

        // Color and background
        DISPID_A_COLOR, DISPID_BACKCOLOR, DISPID_A_BACKGROUNDIMAGE, DISPID_A_BACKGROUNDPOSX,
        DISPID_A_BACKGROUNDPOSY, DISPID_A_BACKGROUNDREPEAT, DISPID_A_BACKGROUNDATTACHMENT,

        // Text properties
        DISPID_A_TEXTDECORATION, DISPID_A_VERTICALALIGN, DISPID_A_TEXTTRANSFORM,

        // Line height and clear
        DISPID_A_LINEHEIGHT, DISPID_A_CLEAR,
    };
    static DISPID aSupportedByLetter[] = {
        // Margins
        DISPID_A_MARGINTOP, DISPID_A_MARGINBOTTOM,
        DISPID_A_MARGINLEFT, DISPID_A_MARGINRIGHT,

        // Borders
        DISPID_A_BORDERTOPSTYLE, DISPID_A_BORDERRIGHTSTYLE,
        DISPID_A_BORDERBOTTOMSTYLE, DISPID_A_BORDERLEFTSTYLE,
        
        DISPID_A_BORDERTOPCOLOR, DISPID_A_BORDERRIGHTCOLOR,
        DISPID_A_BORDERBOTTOMCOLOR, DISPID_A_BORDERLEFTCOLOR,
        
        DISPID_A_BORDERTOPWIDTH, DISPID_A_BORDERRIGHTWIDTH,
        DISPID_A_BORDERBOTTOMWIDTH, DISPID_A_BORDERLEFTWIDTH,

        // Padding
        DISPID_A_PADDINGTOP, DISPID_A_PADDINGRIGHT,
        DISPID_A_PADDINGBOTTOM, DISPID_A_PADDINGLEFT,

        // Float
        DISPID_A_FLOAT,
    };
    static DISPID aSupportedByLine[] = {
        // Character spearation
        DISPID_A_WORDSPACING, DISPID_A_LETTERSPACING,
    };
    BOOL fRet;
    
    if (FilterForPseudoCore(aSupportedByBoth, ARRAY_SIZE(aSupportedByBoth), dispID))
    {
        fRet = TRUE;
    }
    else if (pPseudoElem == pelemFirstLine)
    {
        fRet = FilterForPseudoCore(aSupportedByLine, ARRAY_SIZE(aSupportedByLine), dispID);
    }
    else
    {
        Assert(pPseudoElem == pelemFirstLetter);
        fRet = FilterForPseudoCore(aSupportedByLetter, ARRAY_SIZE(aSupportedByLetter), dispID);
    }
    return fRet;
}

styleLayoutFlow
FilterTagForAlwaysHorizontal(CElement * pElem,
                             styleLayoutFlow wFlowMe,
                             styleLayoutFlow wFlowParent)
{
    styleLayoutFlow wFlowRet = wFlowMe;
#define X(Y) case ETAG_##Y:
    switch(pElem->Tag())
    {
        X(APPLET)   X(AREA)     X(BASE)     X(BASEFONT) X(BGSOUND)  
        X(BODY)     X(COL)      X(COLGROUP) X(FRAME)    X(FRAMESET) X(HEAD)
        X(HTML)     X(IFRAME)   X(IMG)      X(ISINDEX)  X(LINK)     X(MAP)
        X(META)     X(NOFRAMES) X(NOSCRIPT) X(OBJECT)   X(OPTION)   X(PARAM)
        X(SCRIPT)   X(SELECT)   X(STYLE)    X(TABLE)    X(TBODY)    X(TFOOT)
        X(THEAD)    X(TR)       X(GENERIC)  X(OPTGROUP)
        {
            if (   wFlowParent  == styleLayoutFlowVerticalIdeographic
                || wFlowMe      == styleLayoutFlowVerticalIdeographic
               )
            {
                wFlowRet = styleLayoutFlowHorizontal;
            }
            break;
        }
        X(BR) X(WBR)
        {
            wFlowRet = wFlowParent;
            break;
        }
        X(INPUT)
        {
            if (DYNCAST(CInput, pElem)->GetType() == htmlInputImage)
                wFlowRet = styleLayoutFlowHorizontal;
            break;
        }
        default:
            break;
    }
#undef X
    return wFlowRet;
}

BOOL CanApplyMarginProperties(CTreeNode *pNode)
{
    CMarkup *pMarkup = pNode->GetMarkup();
    BOOL fApply;

    if (pNode->Tag() == ETAG_HTML)
    {
        if (   pMarkup->IsPrimaryMarkup()
            || pMarkup->IsPendingPrimaryMarkup()
           )
            fApply = TRUE;
        else
            fApply = FALSE;
    }
    else
        fApply = TRUE;
    return fApply;
}

//+---------------------------------------------------------------------------
//
// Helper:      ApplyFormatInfoProperty
//
//----------------------------------------------------------------------------

HRESULT
ApplyFormatInfoProperty (
    const PROPERTYDESC * pPropertyDesc,
    DISPID dispID,
    VARIANT varValue,
    CFormatInfo *pCFI,
    CachedStyleSheet *pSheetCache,
    CAttrArray  **ppAA )
{
    HRESULT hr = S_OK;

    Assert(pCFI && pCFI->_pNodeContext);

    CElement * pElem          = pCFI->_pNodeContext->Element();
    CMarkup *pMarkup          = pCFI->_pNodeContext->GetMarkup();
    BOOL fComputingFirstLetter = FALSE;
    BOOL fComputingFirstLine = FALSE;

    if (pCFI->GetMatchedBy() != pelemNone)
    {
        CTreeNode *pNode = pCFI->_pNodeContext;
        if (pCFI->GetMatchedBy() == pelemFirstLetter)
        {
            // Call to apply only the first letter relevant properties
            if (FilterForPseudoElement(pelemFirstLetter, dispID))
            {
                CComputeFormatState * pcfState;
                if (    pMarkup->HasCFState() 
                    &&  (pcfState = pMarkup->GetCFState()) != NULL
                    &&  pcfState->GetComputingFirstLetter(pNode))
                {
                    fComputingFirstLetter = TRUE;
                    goto Doit;
                }
                else
                {
                    if (!pCFI->_pff->_fHasFirstLetter)
                    {
                        pCFI->PrepareFancyFormat();
                        pCFI->_ff()._fHasFirstLetter = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                    if (!pCFI->_ppf->_fHasPseudoElement)
                    {
                        pCFI->PrepareParaFormat();
                        pCFI->_pf()._fHasPseudoElement = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                }
            }
        }
        else if (pCFI->GetMatchedBy() == pelemFirstLine)
        {
            // call to apply only the first line relevant properties
            if (FilterForPseudoElement(pelemFirstLine, dispID))
            {
                CComputeFormatState * pcfState;
                if (    pMarkup->HasCFState() 
                    &&  (pcfState = pMarkup->GetCFState()) != NULL
                    &&  pcfState->GetComputingFirstLine(pNode))
                {
                    if (SameScope(pNode, pcfState->GetBlockNodeLine()))
                    {
                        fComputingFirstLine = TRUE;
                        goto Doit;
                    }
                }
                else
                {
                    if (!pCFI->_pff->_fHasFirstLine)
                    {
                        pCFI->PrepareFancyFormat();
                        pCFI->_ff()._fHasFirstLine = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                    if (!pCFI->_ppf->_fHasPseudoElement)
                    {
                        pCFI->PrepareParaFormat();
                        pCFI->_pf()._fHasPseudoElement = TRUE;
                        pCFI->UnprepareForDebug();
                    }
                }
            }
        }
        else
        {
            // Its unknown, do not do anything
        }
        goto Cleanup;
    }

Doit:
    switch ( dispID )
    {
    case STDPROPID_XOBJ_HEIGHT:
        {
            const CUnitValue * pcuv = (const CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetHeight(*pcuv);
                pCFI->_ff().SetHeightPercent(
                         pCFI->_ff().GetHeight().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_TOP).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_BOTTOM).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_WIDTH:
        {
            const CUnitValue * pcuv = (const CUnitValue *)&V_I4(&varValue);
            if ( !pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetWidth(*pcuv);
                pCFI->_ff().SetWidthPercent(
                         pCFI->_ff().GetWidth().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_LEFT).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_RIGHT).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_TOP:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_TOP, *pcuv);
                pCFI->_ff().SetHeightPercent(
                         pCFI->_ff().GetHeight().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_TOP).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_BOTTOM).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_BOTTOM:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_BOTTOM, *pcuv);
                pCFI->_ff().SetHeightPercent(TRUE);
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_LEFT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_LEFT, *pcuv);
                pCFI->_ff().SetWidthPercent(
                         pCFI->_ff().GetWidth().IsPercent() 
                    ||   pCFI->_ff().GetPosition(SIDE_LEFT).IsPercent() 
                    ||  !pCFI->_ff().GetPosition(SIDE_RIGHT).IsNull()
                    );
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case STDPROPID_XOBJ_RIGHT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetPosition(SIDE_RIGHT, *pcuv);
                pCFI->_ff().SetWidthPercent(TRUE);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_VERTICALALIGN:
        {
            BYTE va;
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);

            if (pcuv->IsNullOrEnum())
            {
                va = pcuv->GetUnitValue();
                if (va >= styleVerticalAlignNotSet)
                    va = styleVerticalAlignAuto;
            }
            else
            {
                va = pcuv->IsPercent() ? styleVerticalAlignPercent : styleVerticalAlignNumber;
            }

            pCFI->PrepareFancyFormat();
            pCFI->PrepareCharFormat();
            pCFI->_ff().SetVerticalAlignValue(*pcuv);
            pCFI->_ff().SetVerticalAlign(va);
            pCFI->_ff().SetCSSVerticalAlign(TRUE);
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
            pCFI->UnprepareForDebug();

            ApplyVerticalAlignment(pCFI, va, pElem);
        }
        break;

    case STDPROPID_XOBJ_CONTROLALIGN:
        {
            BOOL fIsInputNotImage   = (pElem->Tag() == ETAG_INPUT 
                                    && DYNCAST(CInput, pElem)->GetType() != htmlInputImage);
            if (fIsInputNotImage)
               break;
            pCFI->_fCtrlAlignLast = TRUE;
            ApplySiteAlignment(pCFI, (htmlControlAlign) V_I4(&varValue), pElem);
        }
        break;

    case DISPID_A_LISTTYPE:
        {   // This code treads a careful line with Nav3/Nav4/IE3 compat.  Before changing it,
            // please consult CWilso and/or AryeG.
            pCFI->PrepareParaFormat();
            pCFI->_pf().SetListStyleType(ListTypeToStyle ((htmlListType)V_I4(&varValue)));
            if (pElem->Tag() == ETAG_LI)
            {   // LIs inside OLs can't be converted to ULs via attribute, or vice versa.
                switch (pCFI->_pf().GetListStyleType())
                {
                case styleListStyleTypeSquare:
                case styleListStyleTypeCircle:
                case styleListStyleTypeDisc:
                    if (pCFI->_ppf->_cListing.GetType() == CListing::NUMBERING)
                        pCFI->_pf().SetListStyleType(styleListStyleTypeDecimal);
                    break;
                case styleListStyleTypeLowerRoman:
                case styleListStyleTypeUpperRoman:
                case styleListStyleTypeLowerAlpha:
                case styleListStyleTypeUpperAlpha:
                case styleListStyleTypeDecimal:
                    if (pCFI->_ppf->_cListing.GetType() == CListing::BULLET)
                        pCFI->_pf().SetListStyleType(styleListStyleTypeDisc);
                    break;
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_LISTSTYLETYPE:
        {
            styleListStyleType lst = (styleListStyleType)(V_I4(&varValue));
            if (lst != styleListStyleTypeNotSet)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf().SetListStyleType(lst);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_LISTSTYLEPOSITION:
        {
            styleListStylePosition lsp = (styleListStylePosition)(V_I4(&varValue));
            if (lsp != styleListStylePositionNotSet)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bListPosition = lsp;
                pCFI->_pf()._fExplicitListPosition = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BACKGROUNDIMAGE:
        if (pCFI->_fAlwaysUseMyColors)
            break;

        pCFI->_fMayHaveInlineBg = TRUE;
        // fall through!
    case DISPID_A_LISTSTYLEIMAGE:
        // fall through
        {
            TCHAR * pchURL = NULL;
            TCHAR * pchURLToSet;
            CStr *  pcstr = NULL;
            
            Assert(varValue.vt == VT_LPWSTR);

            // If the sheet this attribute is in has an absolute URL then use this
            // url as the base url to construct the relative URL passed in.
            if (varValue.byref && ((LPTSTR)varValue.byref)[0])
            {
                TCHAR *pchAbsURL = pSheetCache
                                   ? pSheetCache->GetBaseURL()
                                   : NULL;

                if (pchAbsURL)
                {
                    hr = THR(ExpandUrlWithBaseUrl(pchAbsURL,
                                                   (LPTSTR)varValue.byref,
                                                   &pchURL));

                    // E_POINTER implies that there was a problem with the URL.
                    // We don't want to set the format, but we also don't want
                    // to propagate the HRESULT to ApplyFormat, as this would
                    // cause the format caches not to be created. (cthrash)

                    if (hr)
                    {
                        hr = (hr == E_POINTER) ? S_OK : hr;
                        break;
                    }
                }
            }

            pchURLToSet = pchURL
                               ? pchURL
                               : (TCHAR *)varValue.byref;

            if (DISPID_A_BACKGROUNDIMAGE == dispID)
            {
                pcstr = (fComputingFirstLetter || fComputingFirstLine) ? 
                            &pCFI->_cstrPseudoBgImgUrl : 
                            &pCFI->_cstrBgImgUrl;
                if (fComputingFirstLetter)
                {
                    pCFI->_fBgImageInFLetter = TRUE;
                }
                else if (fComputingFirstLine)
                {
                    pCFI->_fBgImageInFLine = TRUE;
                }
            }
            else if (DISPID_A_LISTSTYLEIMAGE == dispID)
            {
                pcstr = &pCFI->_cstrLiImgUrl;
            }
            pCFI->_fHasSomeBgImage = TRUE;
            pcstr->Set(pchURLToSet);
            MemFreeString(pchURL);
        }
        break;

    case DISPID_A_BORDERTOPSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_TOP, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_TOP, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_TOP, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;
        
    case DISPID_A_BORDERRIGHTSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_RIGHT, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_RIGHT, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_RIGHT, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;
        
    case DISPID_A_BORDERBOTTOMSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_BOTTOM, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_BOTTOM, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_BOTTOM, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;
        
    case DISPID_A_BORDERLEFTSTYLE:
        {
            BYTE bBorderStyle;
            BOOL fHasBorder = ConvertCSSToFmBorderStyle(V_I4(&varValue), &bBorderStyle);

            if (fComputingFirstLetter)
            {
                pCFI->PreparePEI();
                pCFI->_pei()._bd.SetBorderStyle(SIDE_LEFT, bBorderStyle);
                if (fHasBorder)
                    pCFI->_pei()._fHasMBP = TRUE;
            }
            else
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd.SetBorderStyle(SIDE_LEFT, bBorderStyle);
                if (fHasBorder)
                {
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    // NOTE (greglett) -- no double borders on the outermost displayed element,
                    // because the transparent area is difficult to render correctly.
                    // This gets ALL canvas elements; could be relaxed to primary (nonslave) canvas element.
                    if (    (   bBorderStyle == fmBorderStyleDouble
                            ||  bBorderStyle == fmBorderStyleDotted
                            ||  bBorderStyle == fmBorderStyleDashed)                
                        &&  pMarkup->GetCanvasElement() == pElem )
                    {
                        pCFI->_ff()._bd.SetBorderStyle(SIDE_LEFT, fmBorderStyleSingle);
                    }
                }
            }
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_MARGINTOP:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                pCFI->_fHasCSSTopMargin = !!pPropertyDesc->IsStyleSheetProperty();
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_TOP, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_TOP, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_TOP, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;
    case DISPID_A_MARGINBOTTOM:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_BOTTOM, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_BOTTOM, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_BOTTOM, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_MARGINLEFT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                pCFI->_fHasCSSLeftMargin = !!pPropertyDesc->IsStyleSheetProperty();
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_LEFT, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_LEFT, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_LEFT, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_MARGINRIGHT:
        {
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull() && CanApplyMarginProperties(pCFI->_pNodeContext))
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetMargin(SIDE_RIGHT, *pcuv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetMargin(SIDE_RIGHT, *pcuv);
                    pCFI->_ff()._fHasMargins = TRUE;
                    pCFI->_ff().SetExplicitMargin(SIDE_RIGHT, TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_CLEAR:
        if (fComputingFirstLetter || fComputingFirstLine)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fClearFromPseudo = TRUE;
            pCFI->UnprepareForDebug();
        }
        ApplyClear(pElem, (htmlClear) V_I4(&varValue), pCFI);
        break;

    case DISPID_A_PAGEBREAKBEFORE:
        if (V_I4(&varValue))
        {
            pCFI->PrepareFancyFormat();
            SET_PGBRK_BEFORE(pCFI->_ff()._bPageBreaks,V_I4(&varValue));

            pCFI->UnprepareForDebug();
        }
        break;
    case DISPID_A_PAGEBREAKAFTER:
        if (V_I4(&varValue))
        {
            pCFI->PrepareFancyFormat();
            SET_PGBRK_AFTER(pCFI->_ff()._bPageBreaks,V_I4(&varValue));

            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_COLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._ccvTextColor = *pccv;
                pCFI->_fFontColorSet = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_DISPLAY:
        // We can only display this element if the parent is not display:none.
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bDisplay = V_I4(&varValue);
        pCFI->_fDisplayNone = !!(pCFI->_ff()._bDisplay == styleDisplayNone);
        // Some elements have a default of TRUE for _fRectangular, set in ApplyDefaultFormats.  Don't disturb that!
        if (V_I4(&varValue) == styleDisplayInlineBlock)
            pCFI->_ff()._fRectangular = TRUE;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_VISIBILITY:
        if (!g_fInWin98Discover ||
            !pCFI->_pcfSrc->_fVisibilityHidden)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bVisibility = V_I4(&varValue);

            if (pCFI->_pff->_bVisibility == styleVisibilityHidden)
                 pCFI->_fVisibilityHidden = TRUE;
            else if (pCFI->_pff->_bVisibility == styleVisibilityVisible)
                 pCFI->_fVisibilityHidden = FALSE;
            else if (pCFI->_pff->_bVisibility == styleVisibilityInherit)
                 pCFI->_fVisibilityHidden = pCFI->_pcfSrc->_fVisibilityHidden;
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_IMEMODE:
    case DISPID_A_RUBYOVERHANG:
    case DISPID_A_RUBYALIGN:
        if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        break;

    case DISPID_A_SCROLLBARBASECOLOR:
    case DISPID_A_SCROLLBARFACECOLOR:
    case DISPID_A_SCROLLBAR3DLIGHTCOLOR:
    case DISPID_A_SCROLLBARSHADOWCOLOR:
    case DISPID_A_SCROLLBARHIGHLIGHTCOLOR:
    case DISPID_A_SCROLLBARDARKSHADOWCOLOR:
    case DISPID_A_SCROLLBARARROWCOLOR:
    case DISPID_A_SCROLLBARTRACKCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            pCFI->PrepareParaFormat();
            pCFI->_pf()._fHasScrollbarColors = !pccv->IsNull();
            pCFI->UnprepareForDebug();
            if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
            {
                *pCFI->_pvarExtraValue = varValue;
            }
        }
        break;

    case DISPID_A_RUBYPOSITION:
        if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
        }
        if(pElem->Tag() == ETAG_RUBY)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fIsRuby = (styleRubyPositionInline != V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_TEXTTRANSFORM:
        {
            if ( styleTextTransformNotSet != V_I4(&varValue) )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._bTextTransform = (BYTE)V_I4(&varValue);
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_LETTERSPACING:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._cuvLetterSpacing = *puv;
                pCFI->_cf()._fHasLetterOrWordSpacing = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

        
    case DISPID_A_WORDSPACING:
    {
        CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
        if ( !puv->IsNull() )
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._cuvWordSpacing = *puv;
            pCFI->_cf()._fHasLetterOrWordSpacing = TRUE;
            pCFI->UnprepareForDebug();
        }
    }
    break;
        
    case DISPID_A_OVERFLOWX:
        if ( V_I4(&varValue) != styleOverflowNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetOverflowX((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_OVERFLOWY:
        if ( V_I4(&varValue) != styleOverflowNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetOverflowY((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_OVERFLOW:
        if ( V_I4(&varValue) != styleOverflowNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetOverflowX((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->_ff().SetOverflowY((styleOverflow)(BYTE)V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_PADDINGTOP:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_TOP, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_TOP, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentVertPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingTopSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_PADDINGRIGHT:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_RIGHT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_RIGHT, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentHorzPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingRightSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_PADDINGBOTTOM:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_BOTTOM, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_BOTTOM, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentVertPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingBottomSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_PADDINGLEFT:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if (!puv->IsNull())
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei().SetPadding(SIDE_LEFT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff().SetPadding(SIDE_LEFT, *puv);

                    if (puv->IsPercent())
                    {
                        pCFI->_ff().SetPercentHorzPadding(TRUE);
                    }

                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fPadBord = TRUE;   // Apply directly to CF & skip CFI
                    pCFI->_fPaddingLeftSet = TRUE;
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TABLEBORDERCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                pCFI->_ff()._bd.SetBorderColor(SIDE_TOP, *pccv);
                pCFI->_ff()._bd.SetBorderColor(SIDE_RIGHT, *pccv);
                pCFI->_ff()._bd.SetBorderColor(SIDE_BOTTOM, *pccv);
                pCFI->_ff()._bd.SetBorderColor(SIDE_LEFT, *pccv);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TABLEBORDERCOLORLIGHT:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                pCFI->_ff()._bd._ccvBorderColorLight = *pccv;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TABLEBORDERCOLORDARK:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                pCFI->_ff()._bd._ccvBorderColorDark = *pccv;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERTOPCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_TOP, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_TOP );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_TOP, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_TOP );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_BORDERRIGHTCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_RIGHT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_RIGHT );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_RIGHT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_RIGHT );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_BORDERBOTTOMCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_BOTTOM, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_BOTTOM );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_BOTTOM, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_BOTTOM );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERLEFTCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderColor(SIDE_LEFT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_pei()._bd), SIDE_LEFT );
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_ff()._bd.SetBorderColor(SIDE_LEFT, *pccv);
                    SETBORDERSIDECLRUNIQUE( (&pCFI->_ff()._bd), SIDE_LEFT );
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;


    case DISPID_A_BORDERTOPWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_TOP, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_TOP, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERRIGHTWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_RIGHT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_RIGHT, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERBOTTOMWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_BOTTOM, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_BOTTOM, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BORDERLEFTWIDTH:
        {
            CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
            if ( !puv->IsNull() )
            {
                if (fComputingFirstLetter)
                {
                    pCFI->PreparePEI();
                    pCFI->_pei()._bd.SetBorderWidth(SIDE_LEFT, *puv);
                    pCFI->_pei()._fHasMBP = TRUE;
                }
                else
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bd.SetBorderWidth(SIDE_LEFT, *puv);
                    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
                    pCFI->_fPadBord = TRUE;
                    pCFI->_ff().SetThemeDisabled(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_POSITION:
        if (V_I4(&varValue) != stylePositionNotSet )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bPositionType = (BYTE)V_I4(&varValue);
            // Body's don't support being positioned, even though they are a positioning parent by default.
            pCFI->_ff()._fRelative = (pElem->Tag() != ETAG_BODY)  
                ? (pCFI->_ff()._bPositionType == stylePositionrelative)
                : FALSE;
            pCFI->_fRelative = pCFI->_ff()._fRelative;
            pCFI->UnprepareForDebug();

            #if DBG==1
            if(pCFI->_pff->_bPositionType == stylePositionabsolute || pCFI->_pff->_bPositionType == stylePositionrelative)
            {
                // 
                // (IEv60 35609) If formats are computed during unloading content CDoc::UnloadContents() first 
                // clears _fRegionCollection flag and then calls CMarkup::TearDownMarkup() that caused the Assert 
                // below to fire. There are two possible incorrectnesses that cause this behaviour: 
                // 1) The order of operation in CDoc::UnloadContents() described above;
                // 2) The fact that formats are calculated during unload (more information can be found in 
                //    the bug's description. 
                // Currently we are changing Assert to Check in order to avoid regressions and suppress AF in 
                // WindowsXP CHK builds. 
                // 
                Check(pElem->Doc()->_fRegionCollection &&
                        "Inconsistent _fRegionCollection flag, user style sheet sets the position?");
            }
            #endif
        }
        break;

    case DISPID_A_ZINDEX:
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._lZIndex = V_I4(&varValue);
        pCFI->UnprepareForDebug();
        break;

    case DISPID_BACKCOLOR:
        if (!pCFI->_fAlwaysUseMyColors)
        {
            CColorValue *pccv = (CColorValue *)&V_I4(&varValue);
            if ( !pccv->IsNull())
            {
                BOOL fTransparent = (pccv->GetType()
                                    == CColorValue::TYPE_TRANSPARENT);

                
                if (fTransparent)
                {
                    //
                    // The assumption that ancestor's draw background color
                    // is not true in the following case(s):
                    //

                    if (!pElem->GetMarkup()->IsPrimaryMarkup())
                    {
                        if (fComputingFirstLetter || fComputingFirstLine)
                        {
                            pCFI->PreparePEI();
                            pCFI->_pei()._ccvBackColor.Undefine();
                        }
                        else
                        {
                            pCFI->PrepareFancyFormat();
                            pCFI->_ff()._ccvBackColor.Undefine();
                            pCFI->_ff().SetThemeDisabled(TRUE);
                        }
                    }
                    //BODY can't be transparent in compat mode (non CSS1)
                    if (    pElem->Tag() != ETAG_BODY
                         || pMarkup->IsHtmlLayout() )
                    {
                        if (fComputingFirstLetter || fComputingFirstLine)
                        {
                            pCFI->PreparePEI();
                            pCFI->_pei()._ccvBackColor.Undefine();
                        }
                        else
                        {
                            pCFI->PrepareFancyFormat();
                            pCFI->_ff()._ccvBackColor.Undefine();
                            pCFI->_ff().SetThemeDisabled(TRUE);
                        }
                    }
                }
                else
                {
                    if (fComputingFirstLetter || fComputingFirstLine)
                    {
                        pCFI->PreparePEI();
                        pCFI->_pei()._ccvBackColor = *pccv;
                    }
                    else
                    {
                        pCFI->PrepareFancyFormat();
                        pCFI->_ff()._ccvBackColor = *pccv;
                        pCFI->_ff().SetThemeDisabled(TRUE);
                    }
                }
                pCFI->UnprepareForDebug();                

                if (fComputingFirstLetter)
                    pCFI->_fBgColorInFLetter = TRUE;
                
                // site draw their own background, so we dont have
                // to inherit their background info
                pCFI->_fHasBgColor = !fTransparent;

                pCFI->_fMayHaveInlineBg = TRUE;
            }
        }
        break;

    case DISPID_A_BACKGROUNDPOSX:
        {
            // Return the value if extra info is requested
            if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
            {
                *pCFI->_pvarExtraValue = varValue;
                break;
            }
            CUnitValue *cuv = (CUnitValue *)&V_I4(&varValue);
            if ( !cuv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                if ( cuv->GetUnitType() == CUnitValue::UNIT_ENUM )
                {
                    long lVal = 0;
                    switch ( cuv->GetUnitValue() )
                    {
                    //  styleBackgroundPositionXLeft - do nothing.
                    case styleBackgroundPositionXCenter:
                        lVal = 50;
                        break;
                    case styleBackgroundPositionXRight:
                        lVal = 100;
                        break;
                    }
                    pCFI->_ff().SetBgPosXValue(lVal * CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult, CUnitValue::UNIT_PERCENT);
                }
                else
                {
                    pCFI->_ff().SetBgPosX(*cuv);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BACKGROUNDPOSY:
        {
            // Return the value if extra info is requested
            if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
            {
                *pCFI->_pvarExtraValue = varValue;
                break;
            }
            CUnitValue *pcuv = (CUnitValue *)&V_I4(&varValue);
            if ( !pcuv->IsNull() )
            {
                pCFI->PrepareFancyFormat();
                if ( pcuv->GetUnitType() == CUnitValue::UNIT_ENUM )
                {
                    long lVal = 0;
                    switch ( pcuv->GetUnitValue() )
                    {
                    //  styleBackgroundPositionXLeft - do nothing.
                    case styleBackgroundPositionYCenter:
                        lVal = 50;
                        break;
                    case styleBackgroundPositionYBottom:
                        lVal = 100;
                        break;
                    }
                    pCFI->_ff().SetBgPosYValue(lVal * CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult, CUnitValue::UNIT_PERCENT);
                }
                else
                {
                    pCFI->_ff().SetBgPosY(*pcuv);
                }
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_BACKGROUNDREPEAT:
        {
            const LONG lRepeat = V_I4(&varValue);

            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetBgRepeatX(lRepeat == styleBackgroundRepeatRepeatX ||
                                     lRepeat == styleBackgroundRepeatRepeat);
            pCFI->_ff().SetBgRepeatY(lRepeat == styleBackgroundRepeatRepeatY ||
                                     lRepeat == styleBackgroundRepeatRepeat);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_BACKGROUNDATTACHMENT:
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fBgFixed = V_I4(&varValue) == styleBackgroundAttachmentFixed;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LANG:
        Assert ( varValue.vt == VT_LPWSTR );
        pCFI->PrepareCharFormat();
        ApplyLang(&pCFI->_cf(), (LPTSTR) varValue.byref);
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_FLOAT:
        if (   pElem->Tag() != ETAG_BODY
            && pElem->Tag() != ETAG_FRAMESET
            && pElem->Tag() != ETAG_HTML
            && V_I4(&varValue) != styleStyleFloatNotSet
           )
        {
            pCFI->PrepareFancyFormat();
            if (fComputingFirstLetter)
            {
                styleStyleFloat sf = styleStyleFloat(V_I4(&varValue));
                if (styleStyleFloatLeft == sf)
                {
                    pCFI->_ff()._fHasAlignedFL = TRUE;
                }
            }
            else
                pCFI->_ff()._bStyleFloat = (BYTE)V_I4(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_CLIPRECTTOP:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_TOP, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_CLIPRECTLEFT:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_LEFT, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_CLIPRECTRIGHT:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_RIGHT, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_CLIPRECTBOTTOM:
        {
           CUnitValue *puv = (CUnitValue *)&V_I4(&varValue);
           if ( !puv->IsNull() )
           {
               pCFI->PrepareFancyFormat();
               pCFI->_ff().SetClip(SIDE_BOTTOM, *puv);
               pCFI->UnprepareForDebug();
           }
        }
        break;

    case DISPID_A_FILTER:
        {
            if (pCFI->_cstrFilters.Set(varValue.byref ? (LPTSTR)varValue.byref : NULL) == S_OK)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._pszFilters = pCFI->_cstrFilters;
                pCFI->_fHasFilters = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TEXTINDENT:
        {
            CUnitValue *cuv = (CUnitValue *)&V_I4(&varValue);
            if ( !cuv->IsNull() )
            {
                pCFI->_cuvTextIndent.SetRawValue(V_I4(&varValue));
            }
        }
        break;

    case DISPID_A_TABLELAYOUT:
        // table-layout CSS2 attribute
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bTableLayout = V_I4(&varValue) == styleTableLayoutFixed;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_BORDERCOLLAPSE:
        // border-collapse CSS2 attribute
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._bBorderCollapse = V_I4(&varValue) == styleBorderCollapseCollapse;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_DIR:
        {
            BOOL fRTL = FALSE;
            BOOL fExplicitDir = TRUE;

            switch (V_I4(&varValue))
            {
            case htmlDirNotSet:
                fExplicitDir = FALSE;
                //fall through
            case htmlDirLeftToRight:
                fRTL = FALSE;
                break;
            case htmlDirRightToLeft:
                fRTL = TRUE;
                break;
            default:
                Assert("Fix the .PDL");
                break;
            }

            pCFI->_fBidiEmbed = TRUE;

            pCFI->PrepareCharFormat();
            pCFI->PrepareFancyFormat();
            pCFI->_cf()._fRTL = fRTL;
            pCFI->_ff().SetExplicitDir(fExplicitDir);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_DIRECTION:
        {
            BOOL fRTL = FALSE;
            BOOL fExplicitDir = TRUE;

            switch (V_I4(&varValue))
            {
            case styleDirLeftToRight:
                fRTL = FALSE;
                break;
            case styleDirRightToLeft:
                fRTL = TRUE;
                break;
            case styleDirNotSet:
            case styleDirInherit:
                // Use our parent element's value.
                fRTL = pCFI->_pcfSrc->_fRTL;
                fExplicitDir = FALSE;
                break;
            default:
                Assert("Fix the .PDL");
                break;
            }

            pCFI->PrepareCharFormat();
            pCFI->PrepareFancyFormat();
            pCFI->_cf()._fRTL = fRTL;
            pCFI->_ff().SetExplicitDir(fExplicitDir);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_UNICODEBIDI:
        switch (V_I4(&varValue))
        {
        case styleBidiEmbed:
            pCFI->_fBidiEmbed = TRUE;
            pCFI->_fBidiOverride = FALSE;
            break;
        case styleBidiOverride:
            pCFI->_fBidiEmbed = TRUE;
            pCFI->_fBidiOverride = TRUE;
            break;
        case styleBidiNotSet:
        case styleBidiNormal:
            pCFI->_fBidiEmbed = FALSE;
            pCFI->_fBidiOverride = FALSE;
            break;
        case styleBidiInherit:
            pCFI->_fBidiEmbed = pCFI->_pcfSrc->_fBidiEmbed;
            pCFI->_fBidiOverride = pCFI->_pcfSrc->_fBidiOverride;
            break;
        }
        break;

    case DISPID_A_TEXTAUTOSPACE:
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fTextAutospace = varValue.lVal;
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LINEBREAK:
        if (V_I4(&varValue) != styleLineBreakNotSet)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fLineBreakStrict = V_I4(&varValue) == styleLineBreakStrict ? TRUE : FALSE;
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_WORDBREAK:
        if (V_I4(&varValue) != styleWordBreakNotSet)
        {
            Assert( V_I4(&varValue) >= 1 && V_I4(&varValue) <= 3 );
            pCFI->PrepareParaFormat();
            pCFI->_pf()._fWordBreak = V_I4(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_WORDWRAP:
        if (V_I4(&varValue) != styleWordWrapNotSet)
        {
            Assert( V_I4(&varValue) >= 1 && V_I4(&varValue) <= 2 );
            pCFI->PrepareParaFormat();
            pCFI->_pf()._fWordWrap = V_I4(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_TEXTJUSTIFY:
        pCFI->_uTextJustify = V_I4(&varValue);
        break;

    case DISPID_A_TEXTALIGNLAST:
        pCFI->_uTextAlignLast = V_I4(&varValue);
        break;
       
    case DISPID_A_TEXTJUSTIFYTRIM:
        pCFI->_uTextJustifyTrim = V_I4(&varValue);
        break;

    case DISPID_A_TEXTKASHIDA:        
        pCFI->_cuvTextKashida.SetRawValue(V_I4(&varValue));
        break;

    case DISPID_A_TEXTKASHIDASPACE:
        pCFI->_cuvTextKashidaSpace.SetRawValue(V_I4(&varValue));
        break;

    case DISPID_A_WHITESPACE:
        switch (V_I4(&varValue))
        {
            case styleWhiteSpacePre:
                if (pElem->GetMarkup()->SupportsCollapsedWhitespace())
                {
                    pCFI->PrepareParaFormat();            
                    pCFI->_pf()._fTabStops = TRUE;
                    pCFI->_pf()._fHasPreLikeParent = TRUE;
                    pCFI->PrepareFancyFormat();            
                    pCFI->_ff().SetWhitespace(TRUE); 
                    pCFI->UnprepareForDebug();
                    
                    pCFI->_fPre = TRUE;
                    pCFI->_fInclEOLWhite = TRUE;
                    pCFI->_fNoBreak = TRUE;
                }
                break;
                
            case styleWhiteSpaceNowrap:
            case styleWhiteSpaceNormal:
            {
                BOOL fNoWrap = (V_I4(&varValue) == styleWhiteSpaceNowrap);
                    
                if (pElem->GetMarkup()->SupportsCollapsedWhitespace())
                {
                    pCFI->PrepareParaFormat();            
                    pCFI->_pf()._fTabStops = FALSE;
                    pCFI->_pf()._fHasPreLikeParent = FALSE;
                    pCFI->_pf()._fPreInner = FALSE;
                    pCFI->_pf()._fPre = FALSE;
                    
                    pCFI->PrepareFancyFormat();            
                    pCFI->_ff().SetWhitespace(TRUE); 
                    
                    if (!fNoWrap)
                    {
                        pCFI->PrepareCharFormat();
                        pCFI->_cf()._fNoBreak = FALSE;
                        pCFI->_cf()._fNoBreakInner = FALSE;
                    }
                    pCFI->UnprepareForDebug();
                    
                    pCFI->_fPre = FALSE;
                    pCFI->_fInclEOLWhite = FALSE;
                }
                pCFI->_fNoBreak = fNoWrap;
                break;
            }
        }
        
        break;

    case DISPID_A_NOWRAP:
        if ( V_I4(&varValue) )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fHasNoWrap = TRUE;
            pCFI->UnprepareForDebug();
            pCFI->_fNoBreak = TRUE;
        }
        break;


    case DISPID_A_TEXTDECORATION:
        {
            long lTDBits = V_I4(&varValue);
            BOOL fInsideAnchor = FALSE;
            
            pCFI->PrepareCharFormat();
            pCFI->PrepareFancyFormat();

            if (   pCFI->_pcf->_fUnderline
                && (lTDBits & TD_NONE)
               )
            {
                CTreeNode *pNode = pCFI->_pNodeContext->Parent();
                if (pNode)
                    fInsideAnchor = !!pElem->GetMarkup()->SearchBranchForAnchorLink(pNode);
            }

            // Clear text explicity set decoration attributes
            if (pCFI->_pff->_fHasExplicitUnderline || fInsideAnchor)
            {
                pCFI->_cf()._fUnderline = 0;
                pCFI->_ff()._fHasExplicitUnderline   = 0;
            }
            if (pCFI->_pff->_fHasExplicitOverline)
            {
                pCFI->_cf()._fOverline  = 0;
                pCFI->_ff()._fHasExplicitOverline    = 0;
            }
            if (pCFI->_pff->_fHasExplicitLineThrough)
            {
                pCFI->_cf()._fStrikeOut = 0;
                pCFI->_ff()._fHasExplicitLineThrough = 0;
            }

            // Set text decoration attributes
            if (lTDBits & TD_UNDERLINE)
            {
                if (!pCFI->_cf()._fAccelerator || !(pElem->Doc()->_wUIState & UISF_HIDEACCEL))
                {
                    pCFI->_cf()._fUnderline = 1;
                    pCFI->_ff()._fHasExplicitUnderline = 1;
                }
            }
            if (lTDBits & TD_OVERLINE)
            {
                pCFI->_cf()._fOverline  = 1;
                pCFI->_ff()._fHasExplicitOverline = 1;
            }
            if (lTDBits & TD_LINETHROUGH)
            {
                pCFI->_cf()._fStrikeOut = 1;
                pCFI->_ff()._fHasExplicitLineThrough = 1;
            }


            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_ACCELERATOR:
        {
            BOOL fAccelerator = (V_I4(&varValue) == styleAcceleratorTrue);

            pCFI->PrepareCharFormat();

            pCFI->_cf()._fAccelerator = fAccelerator;
            if (fAccelerator)
            {
                pElem->Doc()->_fHaveAccelerators = TRUE;
                if (pElem->Doc()->_wUIState & UISF_HIDEACCEL)
                    pCFI->_cf()._fUnderline = FALSE;
                else
                    pCFI->_cf()._fUnderline = TRUE;
            }

            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_FONT:
        {
            Esysfont eFontType = FindSystemFontByName( (LPTSTR)varValue.byref );
            if ( eFontType != sysfont_non_system )
            {
                pCFI->PrepareCharFormat();
                ApplySystemFont( &pCFI->_cf(), eFontType );
                pCFI->_fFontSet = TRUE;
                pCFI->UnprepareForDebug();                
            }
        }
        break;
    case DISPID_A_FONTSIZE:
        // Return the value if extra info is requested by currentStyle
        if(pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        if (!pCFI->_fAlwaysUseMyFontSize)
        {
            pCFI->PrepareCharFormat();
            ApplyFontSize(pCFI,
                          (CUnitValue*) (void*) &V_I4(&varValue),
                          pElem->Doc()->_pOptionSettings->fAlwaysUseMyFontSize,
                          fComputingFirstLetter,
                          fComputingFirstLine
                         );
            pCFI->_fFontHeightSet = TRUE;
            pCFI->UnprepareForDebug();            
        }
        break;
        
    case DISPID_A_FONTSTYLE:
        if (pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        pCFI->PrepareCharFormat();
        ApplyFontStyle(&pCFI->_cf(), (styleFontStyle) V_I4(&varValue));
        pCFI->UnprepareForDebug();        
        // Save the value if extra info is requested
        break;
    case DISPID_A_FONTVARIANT:
        if (pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fSmallCaps = (V_I4(&varValue) == styleFontVariantSmallCaps);
        pCFI->UnprepareForDebug();
        break;
    case DISPID_A_FONTFACE:
        // Return the unmodified value if requested for currentStyle
        if (pCFI->_eExtraValues & ComputeFormatsType_GetValue)
        {
            *pCFI->_pvarExtraValue = varValue;
            break;
        }
        if (!pCFI->_fAlwaysUseMyFontFace)
        {
            pCFI->PrepareCharFormat();
            ApplyFontFace(&pCFI->_cf(), (LPTSTR)V_BSTR(&varValue), AFF_NONE, pElem->Doc(), pElem->GetMarkup());
            if (pCFI->_pcf->NeedAtFont() && !pCFI->_pcf->_fExplicitAtFont)
            {
                ApplyAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
            }
            pCFI->_fFontSet = TRUE;
            pCFI->UnprepareForDebug();
        }
        break;
    case DISPID_A_BASEFONT:
        pCFI->PrepareCharFormat();
        ApplyBaseFont(&pCFI->_cf(), (long) V_I4(&varValue));
        pCFI->_fFontHeightSet = TRUE;
        pCFI->UnprepareForDebug();        
        break;
    case DISPID_A_FONTWEIGHT:
        pCFI->PrepareCharFormat();
        ApplyFontWeight(&pCFI->_cf(), (styleFontWeight) V_I4(&varValue));
        pCFI->_fFontWeightSet = TRUE;
        pCFI->UnprepareForDebug();        
        break;
    case DISPID_A_LINEHEIGHT:
        pCFI->PrepareCharFormat();
        ApplyLineHeight(&pCFI->_cf(), (CUnitValue*) &V_I4(&varValue));
        pCFI->UnprepareForDebug();
        break;
    case DISPID_A_TABLEVALIGN:
        pCFI->PrepareParaFormat();
        ApplyTableVAlignment(&pCFI->_pf(), (htmlCellVAlign) V_I4(&varValue) );
        pCFI->UnprepareForDebug();
        break;

    case STDPROPID_XOBJ_BLOCKALIGN:
        pCFI->_fCtrlAlignLast = FALSE;
        ApplyParagraphAlignment(pCFI, (htmlBlockAlign) V_I4(&varValue), pElem);
        break;

    case DISPID_A_CURSOR:
        {
            pCFI->PrepareCharFormat();
            Assert( V_VT( & varValue ) == VT_I4 );
            
            pCFI->_cf()._bCursorIdx = V_I4( & varValue );            
            if (  pCFI->_cf()._bCursorIdx == styleCursorcustom )
            {
                CCustomCursor* pCursor = pCFI->GetCustomCursor();
                
                if ( pCursor )
                {
                    CStr cstrCustom;
                    pPropertyDesc->GetBasicPropParams()->GetCustomString( ppAA, &cstrCustom );
                    
                    pCursor->Init( cstrCustom ,pElem  );
                }
            }            
            pCFI->UnprepareForDebug();
        }
        break;
    case STDPROPID_XOBJ_DISABLED:
        if (V_BOOL(&varValue))
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fDisabled = V_BOOL(&varValue);
            pCFI->UnprepareForDebug();
        }
        break;

    case DISPID_A_LAYOUTGRIDCHAR:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._cuvCharGridSizeInner = (CUnitValue)(V_I4(&varValue));

        // In case of change of layout-grid-char, layout-grid-mode must be updated 
        // if its value is not set. This helps handle default values.
        if (    pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNotSet
            ||  (   pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeNone
                &&  pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeBoth))
        {
            pCFI->PrepareCharFormat();

            // Now _uLayoutGridModeInner can be one of { 000, 101, 110, 111 }
            // it means that layout-grid-mode is not set

            if (pCFI->_pf()._cuvCharGridSizeInner.IsNull())
            {   // clear deduced char mode
                pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeLine);
                if (pCFI->_cf()._uLayoutGridModeInner == styleLayoutGridModeNone)
                    pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
            }
            else
            {   // set deduced char mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeChar);
            }
        }
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LAYOUTGRIDLINE:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._cuvLineGridSizeInner = (CUnitValue)(V_I4(&varValue));

        // In case of change of layout-grid-line, layout-grid-mode must be updated 
        // if its value is not set. This helps handle default values.
        if (    pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNotSet
            ||  (   pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeNone
                &&  pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeBoth))
        {
            pCFI->PrepareCharFormat();

            // Now _uLayoutGridModeInner can be one of { 000, 101, 110, 111 }
            // it means that layout-grid-mode is not set

            if (pCFI->_pf()._cuvLineGridSizeInner.IsNull())
            {   // clear deduced line mode
                pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeChar);
                if (pCFI->_cf()._uLayoutGridModeInner == styleLayoutGridModeNone)
                    pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
            }
            else
            {   // set deduced line mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeLine);
            }
        }
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LAYOUTGRIDMODE:
        pCFI->PrepareCharFormat();
        pCFI->_cf()._uLayoutGridModeInner = V_I4(&varValue);

        // Handle default values of layout-grid-mode.
        if (pCFI->_cf()._uLayoutGridModeInner == styleLayoutGridModeNotSet)
        {
            if (!pCFI->_ppf->_cuvCharGridSizeInner.IsNull())
            {   // set deduced char mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeChar);
            }
            if (!pCFI->_ppf->_cuvLineGridSizeInner.IsNull())
            {   // set deduced line mode
                pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeLine);
            }
        }
        pCFI->UnprepareForDebug();
        break;

    case DISPID_A_LAYOUTGRIDTYPE:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._uLayoutGridTypeInner = V_I4(&varValue);
        pCFI->UnprepareForDebug();
        break;

#ifdef IE6_WYSIWYG_OM
    case DISPID_A_ROTATE:
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._lRotationAngle = (long)(V_I4(&varValue));
            pCFI->UnprepareForDebug();
        }
        break;
#endif //IE6_WYSIWYG_OM
    case DISPID_A_ZOOM:
        {
            if (    pElem->Tag() != ETAG_HTML
                ||  !pMarkup->IsHtmlLayout() )
            {
                pCFI->PrepareFancyFormat();

                CUnitValue cuv = (CUnitValue)(V_I4(&varValue));

                switch (cuv.GetUnitType())
                {
                case CUnitValue::UNIT_ENUM:
                    Assert (cuv.GetRawValue() == 0xf); // we only have 1 enum && its value = 0
                    pCFI->_ff()._flZoomFactor = 0.0;
                    break;

                case CUnitValue::UNIT_PERCENT:
                    pCFI->_ff()._flZoomFactor = 1.0*cuv.GetPercent() / CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult;
                    break;

                case CUnitValue::UNIT_FLOAT:
                    // "2" is 200%; 1.25 is 125%; 1 is 100% ...
                    pCFI->_ff()._flZoomFactor = 1.0*cuv.GetUnitValue() / CUnitValue::TypeNames[CUnitValue::UNIT_FLOAT].wScaleMult;
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
                }

                if (pCFI->_ff()._flZoomFactor < 0.0)
                    pCFI->_ff()._flZoomFactor = 0.0;  // use 'Normal" if they set a negative zoom

                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_LAYOUTFLOW:
    case DISPID_A_WRITINGMODE:
        {
            styleLayoutFlow flow;

            if (DISPID_A_LAYOUTFLOW == dispID)
            {
                flow = (styleLayoutFlow)V_I4(&varValue);
            }
            else
            {
                // layout-flow and writing mode are synonyms in trident
                switch((styleWritingMode)V_I4(&varValue))
                {
                    case styleWritingModeLrtb:   flow = styleLayoutFlowHorizontal; break;
                    case styleWritingModeTbrl:   flow = styleLayoutFlowVerticalIdeographic; break;
                    case styleWritingModeNotSet:
                    default:                     flow = styleLayoutFlowNotSet; break;
                }
            }

            CTreeNode * pNodeParent = pCFI->_pNodeContext->Parent();
            styleLayoutFlow flowParent = pNodeParent ? (styleLayoutFlow)pNodeParent->GetCharFormat()->_wLayoutFlow : styleLayoutFlowHorizontal;

            flow = FilterTagForAlwaysHorizontal(pElem, flow, flowParent);
            
            if (flow != styleLayoutFlowNotSet)
            {
                pCFI->PrepareCharFormat();

                if (flow != pCFI->_pcf->_wLayoutFlow)
                {

                    // Check if layout-flow is changing
                    bool fSelfHorizontal   = (styleLayoutFlowHorizontal == flow);
                    bool fParentHorizontal = (styleLayoutFlowHorizontal == flowParent);
                    pCFI->PrepareFancyFormat();
                    if (fSelfHorizontal != fParentHorizontal)
                    {
                        pCFI->_ff()._fLayoutFlowChanged = TRUE;
                        pElem->GetMarkup()->_fHaveDifferingLayoutFlows = TRUE;                        
                    }
                    else
                    {
                        pCFI->_ff()._fLayoutFlowChanged = FALSE;
                    }

                    pCFI->_cf()._wLayoutFlow = flow;

                    if (!pCFI->_pcf->_fExplicitAtFont)
                    {
                        if (pCFI->_pcf->NeedAtFont())
                        {
                            ApplyAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                        else
                        {
                            RemoveAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                    }
                }
                else if (pCFI->_pcf->_latmFaceName != pCFI->_pcfSrc->_latmFaceName)
                {
                    if (!pCFI->_pcf->_fExplicitAtFont)
                    {
                        if (pCFI->_pcf->NeedAtFont())
                        {
                            ApplyAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                        else
                        {
                            RemoveAtFontFace(&pCFI->_cf(), pElem->Doc(), pElem->GetMarkup());
                        }
                    }
                }
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._fLayoutFlowSet = TRUE;
                pCFI->_cf()._fWritingModeUsed = DISPID_A_WRITINGMODE == dispID;
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TEXTUNDERLINEPOSITION:
        {
            styleTextUnderlinePosition up = (styleTextUnderlinePosition)V_I4(&varValue);
            if (up != styleTextUnderlinePositionNotSet)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._bTextUnderlinePosition = (styleTextUnderlinePosition)V_I4(&varValue);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_TEXTOVERFLOW:
        {
            styleTextOverflow to = (styleTextOverflow)V_I4(&varValue);
            if (to != styleTextOverflowNotSet)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetTextOverflow(to);
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_MINHEIGHT:
        {
            const CUnitValue * pcuv = (const CUnitValue *)&V_I4(&varValue);
            if (!pcuv->IsNull())
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetMinHeight(*pcuv);
                pCFI->_ff().SetMinHeightPercent(pcuv->IsPercent());
                pCFI->UnprepareForDebug();
            }
        }
        break;

    case DISPID_A_EDITABLE:
        {
            BOOL fEditable = FALSE;

            //
            // For IE5.5 - we will not allow contentEditable to be set on tables, or parts of tables.
            //

            if (    pElem->_etag != ETAG_TABLE
                &&  pElem->_etag != ETAG_HTML
                &&  !pElem->IsTablePart(  ) )
            {
            
                switch ((htmlEditable)V_I4(&varValue))
                {

                case htmlEditableInherit:
                    // _fParentEditable can be set only for input and text area, if so, fall thru and set to true.
                    if (!pCFI->_fParentEditable)
                        break;
                    // else fall through ...

                case htmlEditableTrue:
                    fEditable = TRUE;
                    // fall through ...

                case htmlEditableFalse:
                    // change only if different.
                    if (pCFI->_pcf->_fEditable != fEditable)
                    {
                        pCFI->PrepareCharFormat();
                        pCFI->_cf()._fEditable = fEditable;
                    }

                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._fContentEditable = fEditable;
                    pCFI->UnprepareForDebug();

                    break;

                default:
                    Assert("Invalid Editable property value");
                    break;
                }
   

                // cache the contentEditable attribute on the element.
            
                pElem->_fEditable = fEditable;
                
                // Set a flag to indicate that we should not set the default values for input\textarea from (_fEditAtBrowse)
                // in ComputeFormats, after the call to ApplyDefaultFormats, as contentEditable has been explicity set
                pCFI->_fEditableExplicitlySet = TRUE;
            }
            
        }
        break;

    case DISPID_INTERNAL_MEDIA_REFERENCE:
        {
            mediaType media = (mediaType) V_I4(&varValue);
            
            // PRINT is the only media currently handled
            if (mediaTypePrint == media)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff().SetMediaReference(media);
                pCFI->UnprepareForDebug();
            }
            else
                AssertSz(0, "unexpected media type");
        }
        break;

    default:
        break;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member:      SwapSelectionColors
//
// Synopsis:    Decide if we need to swap the windows selection colors
//              based on the current text color.
//
// Returns:     TRUE: If swap, FALSE otherwise
//
//----------------------------------------------------------------------------
BOOL
CCharFormat::SwapSelectionColors() const
{
    BOOL fSwapColor;
    COLORREF crTextColor, crNewTextColor, crNewBkColor;

    if(_ccvTextColor.IsDefined())
    {
        crTextColor = _ccvTextColor.GetColorRef();

        crNewTextColor = GetSysColor (COLOR_HIGHLIGHTTEXT);
        crNewBkColor   = GetSysColor (COLOR_HIGHLIGHT);
        fSwapColor = ColorDiff (crTextColor, crNewTextColor) <
                     ColorDiff (crTextColor, crNewBkColor);
    }
    else
    {
        fSwapColor = FALSE;
    }

    return fSwapColor;
}

BOOL
CCharFormat::AreInnerFormatsDirty()
{
    return(   _fHasBgImage
           || _fHasBgColor
           || _fRelative
           || _fBidiEmbed
           || _fBidiOverride
           || _fPadBord
           || _fHasInlineMargins
           || _fHasInlineBg
          );
}

void
CCharFormat::ClearInnerFormats()
{
    _fHasBgImage = FALSE;
    _fHasBgColor = FALSE;
    _fRelative   = FALSE;
    _fBidiEmbed  = FALSE;
    _fBidiOverride = FALSE;
    _fPadBord    = FALSE;
    _fHasInlineMargins = FALSE;
    _fHasInlineBg = FALSE;
    _fHasDirtyInnerFormats = FALSE;
    Assert(!AreInnerFormatsDirty());
}

BOOL
CParaFormat::AreInnerFormatsDirty()
{
    CUnitValue cuvZeroPoints, cuvZeroPercent;
    LONG lZeroPoints, lZeroPercent;
    cuvZeroPoints.SetPoints(0);
    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    lZeroPoints = cuvZeroPoints.GetRawValue();
    lZeroPercent = cuvZeroPercent.GetRawValue();

    return( _fTabStops
        ||  _fCompactDL
        ||  _fResetDLLevel
        ||  _cuvLeftIndentPoints.GetRawValue() != lZeroPoints
        ||  _cuvLeftIndentPercent.GetRawValue() != lZeroPercent
        ||  _cuvRightIndentPoints.GetRawValue() != lZeroPoints
        ||  _cuvRightIndentPercent.GetRawValue() != lZeroPercent
        ||  _cuvNonBulletIndentPoints.GetRawValue() != lZeroPoints
        ||  _cTabCount != 0);
}

void
CParaFormat::ClearInnerFormats()
{
    CUnitValue cuvZeroPoints, cuvZeroPercent;
    LONG lZeroPoints, lZeroPercent;
    cuvZeroPoints.SetPoints(0);
    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    lZeroPoints = cuvZeroPoints.GetRawValue();
    lZeroPercent = cuvZeroPercent.GetRawValue();

    _fTabStops = FALSE;
    _fCompactDL = FALSE;
    _fResetDLLevel = FALSE;
    _cuvLeftIndentPoints.SetRawValue(lZeroPoints);
    _cuvLeftIndentPercent.SetRawValue(lZeroPercent);
    _cuvRightIndentPoints.SetRawValue(lZeroPoints);
    _cuvRightIndentPercent.SetRawValue(lZeroPercent);
    _cuvNonBulletIndentPoints.SetRawValue(lZeroPoints);
    _cTabCount = 0;
    _fHasDirtyInnerFormats = FALSE;
    Assert(!AreInnerFormatsDirty());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\clrngprs.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CLRNGPRS_HXX_
#define X_CLRNGPRS_HXX_
#include <clrngprs.hxx>
#endif


MtDefine(CCellRangeParser, ObjectModel, "CCellRangeParser")


CCellRangeParser::CCellRangeParser(LPCTSTR szRange)
{
    int nCurIndex;

    _fFailed = FALSE;
    _fOneValue = FALSE;

    if(szRange == NULL || *szRange == 0)
        goto Fail;
    
    // Remove all the spaces, convert to uppercase, replace .. with : and
    // store in _strNormString
    Normalize(szRange);

    nCurIndex = 0;

    if(!GetColumn(&nCurIndex, &(_RangeRect.left)))
        goto Fail;
    if(!GetNumber(&nCurIndex, &(_RangeRect.top)))
        goto Fail;
    
    if(_strNormString[nCurIndex] == 0)
    {
        _fOneValue = TRUE;
        _RangeRect.right = _RangeRect.left;
        _RangeRect.bottom = _RangeRect.top;
        goto Done;
    }

    if(((LPCTSTR)_strNormString)[nCurIndex++] != _T(':'))
        goto Fail;
    
    if(!GetColumn(&nCurIndex, &(_RangeRect.right)))
        goto Fail;
    if(!GetNumber(&nCurIndex, &(_RangeRect.bottom)))
        goto Fail;
Done:
    return;

Fail:
    _fFailed = TRUE;
    goto Done;
}


#define eStart       0
#define eSeenLetter1 1
#define eSeenNumber1 2
#define eSeenSepar   3
#define eSeenLetter2 4
#define eSeenNumber2 5
        
void 
CCellRangeParser::Normalize(LPCTSTR szRange)
{
    TCHAR       c, cAppnd;
    int         i;
    int         nLen = _tcslen(szRange);
    int         nState;
    int         nDigit;

    _strNormString.ReAlloc(nLen + 1); 
    _strNormString.SetLengthNoAlloc(0);
    nState = eStart;

    for(i = 0; i < nLen; i++)
    {
        c = szRange[i];
        if(_istspace(c))
            continue;
        else if((c == _T('.') && szRange[i+1] == _T('.')) || c == _T(':'))
        {
            if(nState == eSeenNumber1)
            {
                cAppnd = _T(':');
                if(c == _T('.')) i++;
                nState++;
            }
            else
                goto Fail;
        }
        else if(_istalpha(c))
        {
            if(nState == eSeenSepar || nState == eStart)
            {
                cAppnd = c;
                if(_istalpha(szRange[i+1]))
                {
                    _strNormString.Append(&cAppnd, 1);
                    i++;
                    cAppnd = szRange[i];
                }
                nState++;
            }
            else
                goto Fail;
        } else if(_istdigit(c))
        {
            if(nState == eSeenLetter1 || nState == eSeenLetter2)
            {
                // Remove heading 0's
                while(c == _T('0'))
                {
                    i++;
                    c = szRange[i];
                }
                if(!_istdigit(c))
                    goto Fail;
                cAppnd = c;
                // make sure that no more then 5 digits are processed
                nDigit = 0;
                while(_istdigit(szRange[i+1]))
                {
                    if(nDigit > 5)
                        goto Fail;
                    nDigit++;
                    _strNormString.Append(&cAppnd, 1);
                    i++;
                    cAppnd = szRange[i];
                }
                nState++;
            }
            else
                goto Fail;
        }
        _strNormString.Append(&cAppnd, 1);
    } /* for */


    if(nState != eSeenNumber1 && nState != eSeenNumber2)
        goto Fail;

    if(nState == eSeenNumber1)
        _fOneValue = TRUE;

    CharUpper(_strNormString);

    return;
Fail:
    _fFailed = TRUE;
    return;
}

BOOL 
CCellRangeParser::GetColumn(int *pnCurIndex, long *pnCol)
{
    int nVal;

    if(_fFailed)
        return FALSE;

    if(_strNormString.Length() == 0 || !_istalpha(_strNormString[*pnCurIndex]))
    {
        _fFailed = TRUE;
        return FALSE;
    }

  nVal = _strNormString[*pnCurIndex] - _T('A');
  
  (*pnCurIndex)++;

  if(_istalpha(_strNormString[*pnCurIndex]))
  {
      // A translates to 0 but AA to 1*26+0 so we need 26*(nVal+1)
      nVal = 26 * (nVal + 1) + (_strNormString[*pnCurIndex] - _T('A'));
      (*pnCurIndex)++;
  }

  *pnCol = nVal;

  return TRUE;
}

BOOL 
CCellRangeParser::GetNumber(int *pnCurIndex, long *pnRow)
{
    int nVal;

    if(_fFailed)
        return FALSE;

    if(_strNormString.Length() == 0 || !_istdigit(_strNormString[*pnCurIndex]))
    {
        _fFailed = TRUE;
        return FALSE;
    }

  nVal = _strNormString[*pnCurIndex] - _T('0');
  
  (*pnCurIndex)++;

  while(_istdigit(_strNormString[*pnCurIndex]))
  {
      nVal = 10 * nVal + (_strNormString[*pnCurIndex] - _T('0'));
      (*pnCurIndex)++;
  }

  // Adjust for the fact that first row is row 1 and return the value
  *pnRow = nVal - 1;
  
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\dimm.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module DIMM.CXX -- Handlers for Active IMM (component formerly known as Dynamic IMM)
 *
 *
 *  Owner: <nl>
 *      Ben Westbrook <nl>
 *      Chris Thrasher <nl>
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef NO_IME

#ifndef X_IMM_H_
#define X_IMM_H_
#include "imm.h"
#endif

#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif

DeclareTag(tagDIMM, "AIMM", "Tracking AIMM states");

static IActiveIMMApp * s_pActiveIMM;
const IID IID_IActiveIMMAppPostNT4 = {0xc839a84c, 0x8036, 0x11d3, {0x92, 0x70, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e}  };
//
// IEV6-23905-01/25/2000  ZhenbinX
// We call into AIMM1.2 directly on Win2000+ platforms
//
const CLSID CLSID_CActiveIMM12 = { 
    0xc1ee01f2,
    0xb3b6,
    0x4a6a,
    {0x9d, 0xdd, 0xe9, 0x88, 0xc0, 0x88, 0xec, 0x82}
  };

/* 50D5107A-D278-4871-8989-F4CEAAF59CFC */
const CLSID CLSID_CActiveIMM12_Trident = {
    0x50d5107a,
    0xd278,
    0x4871,
    {0x89, 0x89, 0xf4, 0xce, 0xaa, 0xf5, 0x9c, 0xfc}
   };



BOOL HasActiveIMM() { return s_pActiveIMM != NULL; }
IActiveIMMApp * GetActiveIMM() { return s_pActiveIMM; }

// returns TRUE iff plResult is set in lieu of call to DefWindowProc
BOOL DIMMHandleDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    if (HasActiveIMM())
    {
        if (GetActiveIMM()->OnDefWindowProc(hWnd, Msg, wParam, lParam, plResult) == S_OK)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT EnsureLoadedDIMM()
{
    static BOOL fFailedCoCreate = FALSE;
    HRESULT hr;

    if (HasActiveIMM())
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Already CoCreated [%x]", GetCurrentThreadId(), s_pActiveIMM));
        return S_OK;
    }

    // since the DIMM typically won't be installed on a system,
    // try to avoid constant calls to CoCreate
    if (fFailedCoCreate)
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Already failed to create AIMM before, simply bail out AIMM", GetCurrentThreadId()));
        return E_FAIL;
    }

    LOCK_GLOBALS;

    // Need to check again after locking globals.
    if (HasActiveIMM())
        return S_OK;

    if (   g_dwPlatformID != VER_PLATFORM_WIN32_NT
        || g_dwPlatformVersion < 0x00050000)
    {

        // mwatt changed the context from CLSCTX_INPROC_SERVER to CLSCTX_NO_CODE_DOWNLOAD
        // for Win2000 only.

        TraceTag((tagDIMM, "TID [%x] AIMM CoCreate CLSID_CActiveIMM, IID_IActiveIMMApp for platfroms other than Win2k+", GetCurrentThreadId()));
        hr = CoCreateInstance(CLSID_CActiveIMM, NULL, CLSCTX_INPROC_SERVER,
                              IID_IActiveIMMApp, (void**)&s_pActiveIMM);
    }
    else if (g_dwPlatformVersion == 0x00050000)     // Win2k - cicero wrapper layer
    {
        // 
        // IEV6-5013-2000/07/31/-zhenbinx:
        // CLSCTX_INPROC_SERVER has to be specified in any case! 
        //
        TraceTag((tagDIMM, "TID [%x] AIMM CoCreate CLSID_CActiveIMM, IID_IActiveIMMAppPostNT4 for Win2k", GetCurrentThreadId()));
        hr = CoCreateInstance(CLSID_CActiveIMM, NULL, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD,
                              IID_IActiveIMMAppPostNT4, (void**)&s_pActiveIMM);
        
    }
    else    // Whistler or above - talk to AIMM12 directly
    {
        TraceTag((tagDIMM, "TID [%x] AIMM CoCreate CLSID_CActiveIMM12, IID_IActiveIMMApp for Whistler+", GetCurrentThreadId()));
        hr = CoCreateInstance(CLSID_CActiveIMM12_Trident, NULL, CLSCTX_INPROC_SERVER|CLSCTX_NO_CODE_DOWNLOAD,
                              IID_IActiveIMMApp, (void**)&s_pActiveIMM);
    }

    fFailedCoCreate = FAILED(hr);
#if DBG == 1
    if (fFailedCoCreate)
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Failed CoCreated with hr 0X%x", GetCurrentThreadId(), hr));
    }
    else
    {
        TraceTag((tagDIMM, "TID [%x] AIMM Successfully CoCreated [%x]", GetCurrentThreadId(), s_pActiveIMM));
    }
#endif

    return hr;
}

HRESULT ActivateDIMM()
{
    if (FAILED(EnsureLoadedDIMM()))
        return E_FAIL;

    return GetActiveIMM()->Activate(TRUE);
}

HRESULT DeactivateDIMM()
{
    if (HasActiveIMM())
    {
        // NOTE: assuming here the correct thread is matching an original Begin() call.
        // Could add some debug code to tls to try to catch this....thinking not worth
        // the effort currently. (benwest)

        // Consider adding a cookie (threadid) to the interface if this becomes an issue?

        return GetActiveIMM()->Deactivate();
    }

    return E_FAIL;
}

HRESULT FilterClientWindowsDIMM(ATOM *aaWindowClasses, UINT uSize)
{
    if (FAILED(EnsureLoadedDIMM()))
    {
        return E_FAIL;
    }

    return GetActiveIMM()->FilterClientWindows(aaWindowClasses, uSize);
}

// Called during CServer shutdown, globals are already locked
void DeinitDIMM()
{
    ClearInterface(&s_pActiveIMM);
}

#endif // NO_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\domcoll.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DOMCOLL_HXX_
#define X_DOMCOLL_HXX_
#include "domcoll.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#define _cxx_
#include "domcoll.hdl"

MtDefine(CAttrCollectionator, ObjectModel, "CAttrCollectionator")
MtDefine(CAttrCollectionator_aryAttrDescs, CAttrCollectionator, "CAttrCollectionator::_aryAttrDescs")
MtDefine(CDOMChildrenCollectionGetNewEnum_pary, ObjectModel, "CDOMChildrenCollection::GetNewEnum pary")
MtDefine(CDOMChildrenCollectionGetNewEnum_pary_pv, ObjectModel, "CDOMChildrenCollection::GetNewEnum pary->_pv")
MtDefine(CAttrCollectionatorGetNewEnum_pary, ObjectModel, "CAttrCollectionator::GetNewEnum pary")
MtDefine(CAttrCollectionatorGetNewEnum_pary_pv, ObjectModel, "CAttrCollectionator::GetNewEnum pary->_pv")

MtDefine(CDOMChildrenCollection, ObjectModel, "CDOMChildrenCollection")

//+---------------------------------------------------------------
//
//  Member  : CAttrCollectionator::~CAttrCollectionator
//
//----------------------------------------------------------------

CAttrCollectionator::~CAttrCollectionator()
{
    Assert(_pElemColl);
    _pElemColl->FindAAIndexAndDelete(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, CAttrValue::AA_Internal);
    _pElemColl->Release();
}


//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAttrCollectionator::s_classdesc =
{
    &CLSID_HTMLAttributeCollection,   // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLAttributeCollection,  // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


HRESULT
CAttrCollectionator::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLAttributeCollection, NULL)
        QI_TEAROFF(this, IHTMLAttributeCollection2, NULL)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT
CAttrCollectionator::get_length(long *plLength)
{
    HRESULT hr = S_OK;

    if (!plLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *plLength = _aryAttrDescs.Size();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAttrCollectionator::EnsureCollection()
{
    HRESULT hr = S_OK;
    AttrDesc ad;
    DISPID startdispid = DISPID_STARTENUM;

    Assert(_pElemColl);
    CPtrBagVTableAggregate::CIterator vTableIterator(_pElemColl->GetStringTableAggregate());
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(pPropDesc);
        
        ad._pPropdesc = pPropDesc;
        ad._dispid = pPropDesc->GetDispid();
        hr = THR(_aryAttrDescs.AppendIndirect(&ad));
        if (hr)
            goto Cleanup;
    }

    // Now store index, so we can directly access the expandos
    _lexpandoStartIndex = _aryAttrDescs.Size();

    // Now we fill in the dispids of the expandos
    ad._pPropdesc = NULL;
    while (hr != S_FALSE)
    {
        hr = THR(_pElemColl->GetNextDispIDExpando(startdispid, NULL, &ad._dispid));
        if (FAILED(hr))
            goto Cleanup;

        if (hr != S_FALSE)
        {
            Assert(_pElemColl->IsExpandoDISPID(ad._dispid));
            _aryAttrDescs.AppendIndirect(&ad);
        }
        
        startdispid = ad._dispid;
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT
CAttrCollectionator::item(VARIANT *pvarName, IDispatch **ppdisp)
{
    HRESULT   hr;
    CVariant  varArg;
    VARIANT   varDispatch;
    long      lIndex = 0;

    if (!ppdisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if ((V_VT(pvarName) != VT_ERROR) && (V_VT(pvarName) != VT_EMPTY))
    {
        // first attempt ordinal access...
        hr = THR(varArg.CoerceVariantArg(pvarName, VT_I4));
        if (hr==S_OK)
            lIndex = V_I4(&varArg);
        else
        {
            // not a number, try named access
            hr = THR_NOTRACE(varArg.CoerceVariantArg(pvarName, VT_BSTR));
            if (hr)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            else
            {
                // find the attribute with this name
                lIndex = FindByName((LPCTSTR)V_BSTR(&varArg));
            }
        }
    }

    // TODO(perf): can be optimized to combine FindByName and GetItem
    hr = THR(GetItem(lIndex, &varDispatch));
    if(hr == S_FALSE)
        hr = E_INVALIDARG;
    else
    {
        Assert(V_VT(&varDispatch) == VT_DISPATCH);
        *ppdisp = V_DISPATCH(&varDispatch);
    }
 
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttrCollectionator::GetItemAt(long lIndex, IDispatch **ppDisp)
{
    Assert(_pElemColl);

    HRESULT hr = S_OK;
    AAINDEX aaIdx;
    DISPID dispid = _aryAttrDescs[lIndex]._dispid;
    const PROPERTYDESC *pPropdesc = _aryAttrDescs[lIndex]._pPropdesc;
    CAttrArray *pAA = *(_pElemColl->GetAttrArray());
    CAttribute *pAttribute;
    LPCTSTR pchAttrName;

    Assert(dispid != DISPID_UNKNOWN);

    aaIdx = pAA->FindAAIndex(dispid, CAttrValue::AA_DOMAttribute);
    if (aaIdx == AA_IDX_UNKNOWN)
    {
        pAttribute = new CAttribute(pPropdesc, dispid, _pElemColl);
        if (!pAttribute)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (pPropdesc)
            pchAttrName = pPropdesc->pstrName;
        else
        {
            DISPID expDispid;
            IsExpandoDISPID(dispid, &expDispid);
            hr = THR(_pElemColl->GetExpandoName(expDispid, &pchAttrName));
            if (hr)
                goto Cleanup;
        }

        Assert(pchAttrName);
        hr = THR(pAttribute->_cstrName.Set(pchAttrName));
        if (hr)
            goto Cleanup;

        hr = THR(_pElemColl->AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttribute, CAttrValue::AA_DOMAttribute));
        pAttribute->Release();
        if (hr)
            goto Cleanup;
    }
    else
    {
        IUnknown *pUnk;
        hr = THR(_pElemColl->GetUnknownObjectAt(aaIdx, &pUnk));
        if (hr)
            goto Cleanup;

        pAttribute = (CAttribute *)pUnk;
        Assert(pAttribute);
        pAttribute->Release();
    }

    hr = THR(pAttribute->QueryInterface(IID_IDispatch, (void **)ppDisp));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

HRESULT
CAttrCollectionator::get__newEnum(IUnknown ** ppEnum)
{
    Assert(_pElemColl);

    HRESULT hr = S_OK;
    CPtrAry<LPUNKNOWN> *pary = NULL;
    long lSize;
    long l;
    IDispatch *pdisp;

    if (!ppEnum)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppEnum = NULL;

    pary = new(Mt(CAttrCollectionatorGetNewEnum_pary)) CPtrAry<LPUNKNOWN>(Mt(CAttrCollectionatorGetNewEnum_pary_pv));
    if (!pary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    lSize = _aryAttrDescs.Size();
    
    hr = THR(pary->EnsureSize(lSize));
    if (hr)
        goto Error;

    // Now make a snapshot of our collection.
    for (l = 0; l < lSize; ++l)
    {
        hr = THR(GetItemAt(l, &pdisp));
        if (hr)
            goto Error;

        hr = THR(pary->Append(pdisp));
        if (hr)
        {
            pdisp->Release();
            goto Error;
        }
    }

    // Turn the snapshot into an enumerator.
    hr = THR(pary->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **) ppEnum, FALSE, TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(SetErrorInfo(hr));

Error:
    pary->ReleaseAll();
    goto Cleanup;
}

long 
CAttrCollectionator::FindByName(LPCTSTR pszName, BOOL fCaseSensitive)
{
    HRESULT hr = S_OK;
    long  lIdx = 0;
    PROPERTYDESC *pPropDesc;
    DISPID dispid;
    long lloopindex;

    Assert(_pElemColl);
    pPropDesc = (PROPERTYDESC *)_pElemColl->FindPropDescForName(pszName, fCaseSensitive, &lIdx);

    if (pPropDesc)
        return lIdx;
    else
    {
        for (lloopindex = _lexpandoStartIndex; lloopindex < _aryAttrDescs.Size(); lloopindex++)
        {
            hr = THR(_pElemColl->GetExpandoDISPID((LPTSTR)pszName, &dispid, fCaseSensitive ? fdexNameCaseSensitive : 0));
            if (hr)
                goto Cleanup;

            if (dispid == _aryAttrDescs[lloopindex]._dispid)
                break;
        }

        if (lloopindex == _aryAttrDescs.Size())
            lloopindex = -1;

        return lloopindex;
    }

Cleanup:
    return -1;
}

LPCTSTR 
CAttrCollectionator::GetName(long lIdx)
{
    Assert(_pElemColl);

    LPCTSTR pch = NULL;
    DISPID dispid = _aryAttrDescs[lIdx]._dispid;
    const PROPERTYDESC *pPropdesc = _aryAttrDescs[lIdx]._pPropdesc;

    Assert(dispid != DISPID_UNKNOWN);
    
    if (pPropdesc)
        pch = pPropdesc->pstrExposedName ? pPropdesc->pstrExposedName : pPropdesc->pstrName;
    else
        IGNORE_HR(_pElemColl->GetExpandoName(dispid, &pch));

    return pch;        
}

HRESULT 
CAttrCollectionator::GetItem(long lIndex, VARIANT *pvar)
{
    Assert(_pElemColl);

    HRESULT hr = S_OK;

    if (lIndex < 0 || lIndex >= _aryAttrDescs.Size())
    {
        hr = S_FALSE;
        if (pvar)
            V_DISPATCH(pvar) = NULL;
        goto Cleanup;
    }

    if (!pvar)
    {
        // caller wanted only to check for correct range
        hr = S_OK;
        goto Cleanup;
    }

    V_VT(pvar) = VT_DISPATCH;
    hr = THR(GetItemAt(lIndex, &V_DISPATCH(pvar)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT 
CAttrCollectionator::getNamedItem(BSTR bstrName, IHTMLDOMAttribute **ppAttribute)
{
    return _pElemColl->getAttributeNode(bstrName, ppAttribute);
}

HRESULT 
CAttrCollectionator::setNamedItem(IHTMLDOMAttribute *pAttrIn, IHTMLDOMAttribute **ppAttribute)
{
    return _pElemColl->setAttributeNode(pAttrIn, ppAttribute);
}

HRESULT 
CAttrCollectionator::removeNamedItem(BSTR bstrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;

    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    hr = THR(_pElemColl->RemoveAttributeNode(bstrName, ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CDOMChildrenCollection
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CDOMChildrenCollection::s_classdesc =
{
    &CLSID_DOMChildrenCollection,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLDOMChildrenCollection,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};


//+---------------------------------------------------------------
//
//  Member  : CDOMChildrenCollection::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------
HRESULT
CDOMChildrenCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLDOMChildrenCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CDOMChildrenCollection::item(long lIndex, IDispatch** ppResult)
{
    HRESULT     hr;
    VARIANT     varDispatch;

    if ( !ppResult )
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varDispatch));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varDispatch) == VT_DISPATCH);
    *ppResult = V_DISPATCH(&varDispatch);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CDOMChildrenCollection::get_length(long * plSize)
{
    HRESULT hr;
    if (!plSize)
        hr = E_INVALIDARG;
    else
    {
        *plSize = GetLength();
        hr = S_OK;
    }
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CDOMChildrenCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = E_INVALIDARG;
    CPtrAry<LPUNKNOWN> *pary = NULL;
    CElement *pElement;
    CObjectElement *pelObj = NULL;
    long lSize;
    long l;

    if (!_fIsElement)
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    if (!ppEnum)
        goto Cleanup;

    *ppEnum = NULL;

    pary = new(Mt(CDOMChildrenCollectionGetNewEnum_pary)) CPtrAry<LPUNKNOWN>(Mt(CDOMChildrenCollectionGetNewEnum_pary_pv));
    if (!pary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    lSize = GetLength();
    
    hr = THR(pary->EnsureSize(lSize));
    if (hr)
        goto Error;

    pElement = DYNCAST(CElement, _pOwner);
    if (pElement->Tag() == ETAG_OBJECT || pElement->Tag() == ETAG_APPLET)
    {
        pelObj = DYNCAST(CObjectElement, _pOwner);
    }

    // Now make a snapshot of our collection.
    for (l = 0; l < lSize; ++l)
    {
        IDispatch *pdisp;

        if (pelObj)
        {
            CParamElement *pelParam = pelObj->_aryParams[l];
            Assert(pelParam && pelParam->Tag() == ETAG_PARAM);
            Assert(pelParam->_pelObjParent == pelObj);
            hr = THR(pelParam->QueryInterface(IID_IDispatch, (void **)&pdisp));
        }
        else
            hr = THR(pElement->DOMWalkChildren(l, NULL, &pdisp));
    
        if (hr)
            goto Error;

        hr = THR(pary->Append(pdisp));
        if (hr)
        {
            pdisp->Release();
            goto Error;
        }
    }

    // Turn the snapshot into an enumerator.
    hr = THR(pary->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **) ppEnum, FALSE, TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(SetErrorInfo(hr));

Error:
    pary->ReleaseAll();
    goto Cleanup;
}

HRESULT 
CDOMChildrenCollection::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT     hr = S_OK;
    IDispatch **ppDisp;

    if ( lIndex < 0  )
        return E_INVALIDARG;

    if ( pvar )
        V_DISPATCH(pvar) = NULL;

    if ( _fIsElement )
    {
        // Pass through the NULL parameter correctly
        if (pvar)
            ppDisp = &V_DISPATCH(pvar);
        else
            ppDisp = NULL;

        CElement *pElement = DYNCAST(CElement, _pOwner);
        if (pElement->Tag() == ETAG_OBJECT || pElement->Tag() == ETAG_APPLET)
        {
            CObjectElement *pelObj = DYNCAST(CObjectElement, _pOwner);
            if (lIndex < pelObj->_aryParams.Size())
            {
                Assert(lIndex == pelObj->_aryParams[lIndex]->_idxParam);
                if (ppDisp)
                {
                    CParamElement *pelParam = pelObj->_aryParams[lIndex];
                    Assert(pelParam && pelParam->Tag() == ETAG_PARAM);
                    Assert(pelParam->_pelObjParent == pelObj);
                    hr = THR(pelParam->QueryInterface(IID_IDispatch, (void **)ppDisp));
                }
            }
            else
                hr = E_INVALIDARG;
        }
        else
            hr = THR(pElement->DOMWalkChildren(lIndex, NULL, ppDisp ));
    }
    else
        hr = E_INVALIDARG;

    if (!hr && pvar)
        V_VT(pvar) = VT_DISPATCH;

    RRETURN(hr);
}

HRESULT 
CDOMChildrenCollection::IsValidIndex ( long lIndex )
{
    return (lIndex >= 0 && lIndex < GetLength()) ? S_OK : S_FALSE;
}


long 
CDOMChildrenCollection::GetLength ( void )
{
    long lCount = 0;

    if ( _fIsElement )
    {
        CElement *pElement = DYNCAST(CElement, _pOwner);
        if (pElement->Tag() == ETAG_OBJECT || pElement->Tag() == ETAG_APPLET)
            lCount = DYNCAST(CObjectElement, _pOwner)->_aryParams.Size();
        else
            pElement->DOMWalkChildren ( -1, &lCount, NULL );
    }

    return lCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\eventobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       eventobj.cxx
//
//  Contents:   Implementation of CEventObject class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_WINBASE_H_
#define X_WINBASE_H_
#include "winbase.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for CDataSourceProvider
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#define _cxx_
#include "eventobj.hdl"

MtDefine(CEventObj, ObjectModel, "CEventObj")
MtDefine(BldEventObjElemsCol, PerfPigs, "Build CEventObj::EVENT_BOUND_ELEMENTS_COLLECTION")

//=======================================================================
//
//  #defines  -- this section contains a nubmer of pound defines of functions that
//    are repreated throughout this file.  there are not quite enough to warrent
//    a functional re-write, but enough to make the redundant code difficult to
//    read.
//
//=======================================================================

//=======================================================================

#define MAKESUREPUTSAREALLOWED          \
    if(!_fReadWrite)                    \
    {                                   \
        hr = DISP_E_MEMBERNOTFOUND;     \
        goto Cleanup;                   \
    }


#define GETKEYVALUE(fnName,  MASK)   \
    HRESULT CEventObj::get_##fnName (VARIANT_BOOL *pfAlt)   \
{                                                       \
    HRESULT         hr;                                 \
    EVENTPARAM *    pparam;                             \
                                                        \
    hr = THR(GetParam(&pparam));                        \
    if (hr)                                             \
        goto Cleanup;                                   \
                                                        \
    *pfAlt = VARIANT_BOOL_FROM_BOOL(pparam->_sKeyState & ##MASK); \
                                                        \
Cleanup:                                                \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);      \
}                                                       \

#define PUTKEYVALUE(fnName,  MASK)                      \
    HRESULT CEventObj::put_##fnName (VARIANT_BOOL fPressed)   \
{                                                       \
    HRESULT         hr;                                 \
    EVENTPARAM *    pparam;                             \
                                                        \
    MAKESUREPUTSAREALLOWED                              \
                                                        \
    hr = THR(GetParam(&pparam));                        \
    if (hr)                                             \
        goto Cleanup;                                   \
                                                        \
    if(fPressed)                                        \
        pparam->_sKeyState |= ##MASK;                    \
    else                                                \
        pparam->_sKeyState &= ~##MASK;                   \
                                                        \
                                                        \
Cleanup:                                                \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);      \
}




//=======================================================================

HRESULT
CEventObj::GenericGetElement (IHTMLElement** ppElement, DISPID dispid)
{
    EVENTPARAM *    pparam;
    HRESULT         hr      = S_OK;
    CTreeNode  *    pTarget = NULL;
    long            lSubDiv = -1;
    IUnknown   *    pUnk;

    if (!ppElement)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppElement = NULL;

    if (S_OK == GetUnknownPtr(dispid, &pUnk))
    {
        goto Cleanup;
    }

    *ppElement = (IHTMLElement *)pUnk;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    switch (dispid)
    {
    case DISPID_CEventObj_srcElement:
        pTarget = pparam->_pNode;
        lSubDiv = pparam->_lSubDivisionSrc;
        break;  
    case DISPID_CEventObj_fromElement:
        pTarget = pparam->_pNodeFrom;
        lSubDiv = pparam->_lSubDivisionFrom;
        break;  
    case DISPID_CEventObj_toElement:
        pTarget = pparam->_pNodeTo;
        lSubDiv = pparam->_lSubDivisionTo;
        break;
    default:
        Assert(FALSE);
        break;
    }

    if (!pTarget || pTarget->Element() == pTarget->Doc()->PrimaryRoot())
        goto Cleanup;

    if (lSubDiv >= 0)
    {
        if (pTarget->Tag() == ETAG_IMG )
        {
            CAreaElement * pArea = NULL;
            CImgElement *pImg = DYNCAST(CImgElement, pTarget->Element());

            if (pImg->GetMap())
            {
                pImg->GetMap()->GetAreaContaining(lSubDiv, &pArea);
                if (pArea)
                    pTarget = pArea->GetFirstBranch();
            }
        }
    }

    if (!pTarget)
        goto Cleanup;

    if (pTarget == pTarget->Element()->GetFirstBranch())
    {
        hr = THR(pTarget->Element()->QueryInterface(IID_IHTMLElement, (void **)ppElement));
    }
    else
    {
        hr = THR(pTarget->GetInterface(IID_IHTMLElement, (void **)ppElement));
    }

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


HRESULT
CEventObj::GenericPutElement (IHTMLElement* pElement, DISPID dispid)
{
    RRETURN(PutUnknownPtr(dispid, pElement));
}

//=======================================================================

#define GET_STRING_VALUE(fnName, strName)       \
    HRESULT CEventObj::get_##fnName  (BSTR *p)  \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    if (!p)                                     \
    {                                           \
        hr = E_POINTER;                         \
        goto Cleanup;                           \
    }                                           \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    hr = FormsAllocString(pparam->##strName(), p);      \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);      \
}


#define PUT_STRING_VALUE(fnName, strName)       \
    HRESULT CEventObj::put_##fnName  (BSTR p)   \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    if (!p)                                     \
    {                                           \
        hr = E_POINTER;                         \
        goto Cleanup;                           \
    }                                           \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##strName(p);                       \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}


//=======================================================================

HRESULT
CEventObj::GenericGetLong(long * plongRet, ULONG uOffset)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!plongRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plongRet = -1;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *plongRet = *(long *)(((BYTE *)pparam) + uOffset);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


HRESULT 
CEventObj::GenericGetLongPtr (LONG_PTR * pLongPtr, ULONG uOffset)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pLongPtr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLongPtr = NULL;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pLongPtr = *(LONG_PTR *)(((BYTE *)pparam) + uOffset);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}



#define PUT_LONG_VALUE(fnName, propName )       \
    HRESULT CEventObj::put_##fnName (long lLongVal) \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##propName = lLongVal;              \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}

#define PUT_LONG_VALUEX(fnName, propName )       \
    HRESULT CEventObj::put_##fnName (long lLongVal) \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsX(lLongVal);  \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}

#define PUT_LONG_VALUEY(fnName, propName )       \
    HRESULT CEventObj::put_##fnName (long lLongVal) \
{                                               \
    HRESULT         hr;                         \
    EVENTPARAM *    pparam;                     \
                                                \
    MAKESUREPUTSAREALLOWED                      \
                                                \
    hr = THR(GetParam(&pparam));                \
    if (hr)                                     \
        goto Cleanup;                           \
                                                \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsY(lLongVal);  \
                                                \
Cleanup:                                        \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr); \
}

#define PUT_OFFSET_VALUEX(fnName, propName, flagName)               \
    HRESULT CEventObj::put_##fnName (long lLongVal)                 \
{                                                                   \
    HRESULT         hr;                                             \
    EVENTPARAM *    pparam;                                         \
                                                                    \
    MAKESUREPUTSAREALLOWED                                          \
                                                                    \
    hr = THR(GetParam(&pparam));                                    \
    if (hr)                                                         \
        goto Cleanup;                                               \
                                                                    \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsX(lLongVal);\
    pparam->##flagName = TRUE;                                      \
                                                                    \
Cleanup:                                                            \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);                  \
}

#define PUT_OFFSET_VALUEY(fnName, propName, flagName)               \
    HRESULT CEventObj::put_##fnName (long lLongVal)                 \
{                                                                   \
    HRESULT         hr;                                             \
    EVENTPARAM *    pparam;                                         \
                                                                    \
    MAKESUREPUTSAREALLOWED                                          \
                                                                    \
    hr = THR(GetParam(&pparam));                                    \
    if (hr)                                                         \
        goto Cleanup;                                               \
                                                                    \
    pparam->##propName = g_uiDisplay.DeviceFromDocPixelsY(lLongVal);\
    pparam->##flagName = TRUE;                                      \
                                                                    \
Cleanup:                                                            \
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);                  \
}

//=======================================================================

//---------------------------------------------------------------------------
//
//  CEventObj ClassDesc
//
//---------------------------------------------------------------------------

const CBase::CLASSDESC CEventObj::s_classdesc =
{
    &CLSID_CEventObj,                // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLEventObj,             // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};



//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::CreateEventObject
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::Create(
    IHTMLEventObj** ppEventObj,
    CDoc *          pDoc,
    CElement *      pElement,
    CMarkup *       pMarkup,
    BOOL            fCreateAttached /* = TRUE*/,
    LPTSTR          pchSrcUrn, /* = NULL */
    EVENTPARAM *    pParam /*=NULL*/
)
{
    HRESULT         hr;
    CEventObj *     pEventObj = NULL;

    if (!ppEventObj)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEventObj = NULL;

    if (   fCreateAttached 
        && pDoc 
        && pDoc->_pparam 
        && pDoc->_pparam->pEventObj)
    {
        Assert( ! pParam );
        pEventObj = pDoc->_pparam->pEventObj;
        pEventObj->AddRef();
    }
    else
    {
        pEventObj = new CEventObj(pDoc);
        if (!pEventObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj, (void **)ppEventObj));
    if (hr)
        goto Cleanup;

    if (!fCreateAttached )
    {
        pEventObj->_pparam = new EVENTPARAM(pDoc,
                                            pElement,
                                            pMarkup,
                                            /* fInitState = */ !pParam,
                                            /* fPush = */ FALSE,
                                            pParam);
        if (!pEventObj->_pparam)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pEventObj->_pparam->pEventObj = pEventObj;

        // This is an XTag event object, mark it as read/write
        pEventObj->_fReadWrite = TRUE;
    }
    else if ( pParam )
    {
        pEventObj->_pparam = new EVENTPARAM( pParam ) ;
        if (!pEventObj->_pparam)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pEventObj->_pparam->pEventObj = pEventObj;        
    }

    if (fCreateAttached || !pParam || !pElement)
        hr = pEventObj->SetAttributes(pDoc);

    if (pchSrcUrn)
        pEventObj->_pparam->SetSrcUrn(pchSrcUrn);

Cleanup:
    if (pEventObj)
        pEventObj->Release();

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::SetAttributes
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::SetAttributes(CDoc * pDoc)
{
    HRESULT      hr = S_OK;
    EVENTPARAM * pparam = pDoc ? pDoc->_pparam : _pparam;
    CMarkup *    pMarkupContext = NULL;
    BOOL         fExpando = TRUE;

    if (!pparam || !pparam->GetType())
        goto Cleanup;

    pMarkupContext = GetMarkupContext();
    if (pMarkupContext)
    {
        fExpando = pMarkupContext->_fExpando;
        pMarkupContext->_fExpando = TRUE;
    }

    // script error expandos
    if (!StrCmpIC(_T("error"), pparam->GetType()))
    {
        CVariant varErrorMessage(VT_BSTR);
        CVariant varErrorUrl(VT_BSTR);
        CVariant varErrorLine(VT_I4);
        CVariant varErrorCharacter(VT_I4);
        CVariant varErrorCode(VT_I4);

        hr = FormsAllocString(pparam->errorParams.pchErrorMessage, &varErrorMessage.bstrVal);
        if (hr)
            goto Cleanup;
        hr = FormsAllocString(pparam->errorParams.pchErrorUrl, &varErrorUrl.bstrVal);
        if (hr)
            goto Cleanup;
        V_I4(&varErrorLine) =           pparam->errorParams.lErrorLine;
        V_I4(&varErrorCharacter) =      pparam->errorParams.lErrorCharacter;
        V_I4(&varErrorCode) =           pparam->errorParams.lErrorCode;

        hr = SetExpando(_T("errorMessage"), &varErrorMessage);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorUrl"), &varErrorUrl);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorLine"), &varErrorLine);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorCharacter"), &varErrorCharacter);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("errorCode"), &varErrorCode);
    }

    // ShowMessage expandos
    else if (!StrCmpIC(_T("message"), pparam->GetType()))
    {
        CVariant varMessageText(VT_BSTR);
        CVariant varMessageCaption(VT_BSTR);
        CVariant varMessageStyle(VT_UI4);
        CVariant varMessageHelpFile(VT_BSTR);
        CVariant varMessageHelpContext(VT_UI4);

        hr = FormsAllocString(pparam->messageParams.pchMessageText, &varMessageText.bstrVal);
        if (hr)
            goto Cleanup;
        hr = FormsAllocString(pparam->messageParams.pchMessageCaption, &varMessageCaption.bstrVal);
        if (hr)
            goto Cleanup;
        hr = FormsAllocString(pparam->messageParams.pchMessageHelpFile, &varMessageHelpFile.bstrVal);
        if (hr)
            goto Cleanup;
        V_UI4(&varMessageStyle)         = pparam->messageParams.dwMessageStyle;
        V_UI4(&varMessageHelpContext)   = pparam->messageParams.dwMessageHelpContext;

        hr = SetExpando(_T("messageText"), &varMessageText);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageCaption"), &varMessageCaption);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageStyle"), &varMessageStyle);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageHelpFile"), &varMessageHelpFile);
        if (hr)
            goto Cleanup;

        hr = SetExpando(_T("messageHelpContext"), &varMessageHelpContext);
        if (hr)
            goto Cleanup;
    }
    
    // property sheet dialog expandos
    else if (!StrCmpIC(_T("propertysheet"), pparam->GetType()))
    {
        // we are using a VARIANT and not a CVariant because we do not want to free the
        // array here
        VARIANT varpaPropertysheetPunks;
        V_VT(&varpaPropertysheetPunks) = VT_SAFEARRAY;
        V_ARRAY(&varpaPropertysheetPunks) = pparam->propertysheetParams.paPropertysheetPunks;

        hr = SetExpando(_T("propertysheetPunks"), &varpaPropertysheetPunks);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (pMarkupContext)
        pMarkupContext->_fExpando = fExpando;

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::COnStackLock::COnStackLock
//
//--------------------------------------------------------------------------

CEventObj::COnStackLock::COnStackLock(IHTMLEventObj * pEventObj)
{
    HRESULT     hr;

    Assert (pEventObj);

    _pEventObj = pEventObj;
    _pEventObj->AddRef();

    hr = THR(pEventObj->QueryInterface (CLSID_CEventObj, (void**)&_pCEventObj));
    if (hr)
        goto Cleanup;

    _pCEventObj->_pparam->Push();

Cleanup:
    return;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::COnStackLock::~COnStackLock
//
//--------------------------------------------------------------------------

CEventObj::COnStackLock::~COnStackLock()
{
    _pCEventObj->_pparam->Pop();
    _pEventObj->Release();
}

//---------------------------------------------------------------------------
//
//  Member:     CEventObj::CEventObj
//
//  Synopsis:   constructor
//
//---------------------------------------------------------------------------

CEventObj::CEventObj(CDoc * pDoc)
{
    _pDoc = pDoc;
    _pMarkupContext = NULL;
    if (pDoc)
        _pDoc->SubAddRef();
    else
    {
        _pAtomTable = new CAtomTable();
    }
}

//---------------------------------------------------------------------------
//
//  Member:     CEventObj::~CEventObj
//
//  Synopsis:   destructor
//
//---------------------------------------------------------------------------

CEventObj::~CEventObj()
{
    if (_pDoc)
        _pDoc->SubRelease();

    if (_pAtomTable)
    {
        _pAtomTable->Free();
        delete _pAtomTable;
    }

    if (_pMarkupContext)
        _pMarkupContext->SubRelease();

    delete _pCollectionCache;
    delete _pparam;
}

//---------------------------------------------------------------------------
//
//  Member:     CEventObj::GetParam
//
//---------------------------------------------------------------------------

HRESULT
CEventObj::GetParam(EVENTPARAM ** ppParam)
{
    Assert (ppParam);

    if (_pparam)
    {
        // gaurenteed to be here if pdoc is NULL
        (*ppParam) = _pparam;
    }
    else
    {
        if (_pDoc->_pparam)
        {
            (*ppParam) = _pDoc->_pparam;
        }
        else
        {
            (*ppParam) = NULL;
            RRETURN (DISP_E_MEMBERNOTFOUND);

        }
    }
    RRETURN (S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTMLEventObj, NULL)
    QI_TEAROFF(this, IHTMLEventObj2, NULL)
    QI_TEAROFF(this, IHTMLEventObj3, NULL)
    QI_TEAROFF(this, IHTMLEventObj4, NULL)
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    default:
        if (IsEqualGUID(iid, CLSID_CEventObj))
        {
            *ppv = this;
            return S_OK;
        }

        // Primary default interface, or the non dual
        // dispinterface return the same object -- the primary interface
        // tearoff.
        if (DispNonDualDIID(iid))
        {
            HRESULT hr = CreateTearOffThunk( this,
                                        (void *)s_apfnIHTMLEventObj,
                                        NULL,
                                        ppv);
            if (hr)
                RRETURN(hr);
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the event's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CEventObj::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    if (!_pCollectionCache)
    {
        Assert(_pDoc);

        _pCollectionCache = new CCollectionCache(
                this,          // double cast needed for Win16.
                GetMarkupContext(),
                ENSURE_METHOD(CEventObj, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(NUMBER_OF_EVENT_COLLECTIONS));
        if (hr)
            goto Error;
    }

    hr = THR( _pCollectionCache->EnsureAry( 0 ) );

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the event's collections, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CEventObj::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    HRESULT hr = S_OK;
    EVENTPARAM *    pparam;
    int i;

    // Nothing to do so get out.
    if (*plCollectionVersion)
        goto Cleanup;

    MtAdd(Mt(BldEventObjElemsCol), +1, 0);

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    // Reset the collections.
    for (i = 0; i < NUMBER_OF_EVENT_COLLECTIONS; i++)
    {
        _pCollectionCache->ResetAry(i);
    }

    // Reload the bound elements collection
    if (pparam->pProvider)
    {
        hr = pparam->pProvider->
                LoadBoundElementCollection(_pCollectionCache, EVENT_BOUND_ELEMENTS_COLLECTION);
        if (hr)
        {
            _pCollectionCache->ResetAry(EVENT_BOUND_ELEMENTS_COLLECTION);
        }
    }

    *plCollectionVersion = 1;   // to mark it done

Cleanup:
    RRETURN(hr);
}

HRESULT
CEventObj::get_contentOverflow(VARIANT_BOOL * pVB)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pVB)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pVB = VARIANT_BOOL_FROM_BOOL(pparam->_fOverflow);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_nextPage(BSTR *p)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;
    LPCTSTR         pstrLeftRight;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    switch (pparam->GetOverflowType())
    {
    case OVERFLOWTYPE_LEFT:
        pstrLeftRight = TEXT("left");
        break;
    case OVERFLOWTYPE_RIGHT:
        pstrLeftRight = TEXT("right");
        break;
    default:
        pstrLeftRight = TEXT("");
    }

    hr = FormsAllocString(pstrLeftRight, p);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::get_srcElem
//  Method:     CEventObj::get_fromElement
//  Method:     CEventObj::get_toElement
//
//  Synopsis:   Per IEventObj.  see macro defined at the top of this file.
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::get_srcElement (IHTMLElement** ppElement)
{
    return GenericGetElement(ppElement, DISPID_CEventObj_srcElement);
}


HRESULT
CEventObj::get_fromElement (IHTMLElement** ppElement)
{
    return GenericGetElement(ppElement, DISPID_CEventObj_fromElement);
}


HRESULT
CEventObj::get_toElement (IHTMLElement** ppElement)
{
    return GenericGetElement(ppElement, DISPID_CEventObj_toElement);
}


HRESULT
CEventObj::put_srcElement (IHTMLElement* pElement)
{
    return GenericPutElement(pElement, DISPID_CEventObj_srcElement);
}


HRESULT
CEventObj::put_fromElement (IHTMLElement* pElement)
{
    return GenericPutElement(pElement, DISPID_CEventObj_fromElement);
}


HRESULT
CEventObj::put_toElement (IHTMLElement* pElement)
{
    return GenericPutElement(pElement, DISPID_CEventObj_toElement);
}


//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::get_button
//  Method:     CEventObj::get_keyCode      KeyCode of a key event
//  Method:     CEventObj::get_reason       reason enum for ondatasetcomplete
//  Method:     CEventObj::get_clientX      Per IEventObj, in client coordinates
//  Method:     CEventObj::get_clientY      Per IEventObj, in client coordinates
//  Method:     CEventObj::get_screenX      Per IEventObj, in screen coordinates
//  Method:     CEventObj::get_screenY      Per IEventObj, in screen coordinates
//
//  Synopsis:   Per IEventObj
//
//--------------------------------------------------------------------------

HRESULT
CEventObj::get_button (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _lButton ));
}

HRESULT
CEventObj::get_keyCode (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _lKeyCode ));
}

HRESULT
CEventObj::get_reason (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _lReason ));
}

HRESULT
CEventObj::get_clientX (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _clientX )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_clientY (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _clientY )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_screenX (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _screenX )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_screenY (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _screenY )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_offsetX (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _offsetX )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
    
}

HRESULT
CEventObj::get_offsetY (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _offsetY )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_x (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _x )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceX(*plReturn);
    }

    RRETURN(hr);
}

HRESULT
CEventObj::get_y (long * plReturn)
{
    HRESULT hr;
    
    hr = THR(GenericGetLong( plReturn, offsetof(EVENTPARAM, _y )));
    if (SUCCEEDED(hr))
    {
        *plReturn = g_uiDisplay.DocPixelsFromDeviceY(*plReturn);
    }

    RRETURN(hr);
}


PUT_LONG_VALUE(button, _lButton);
PUT_LONG_VALUE(reason, _lReason);
PUT_LONG_VALUEX(clientX, _clientX);
PUT_LONG_VALUEY(clientY, _clientY);
PUT_LONG_VALUEX(screenX, _screenX);
PUT_LONG_VALUEY(screenY, _screenY);
PUT_OFFSET_VALUEX(offsetX, _offsetX, _fOffsetXSet);
PUT_OFFSET_VALUEY(offsetY, _offsetY, _fOffsetYSet);
PUT_LONG_VALUEX(x, _x);
PUT_LONG_VALUEY(y, _y);

//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::put_keyCode
//
//  Synopsis:   Puts the keyCode
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::put_keyCode(long lKeyCode)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    // SECURITY ALERT:- we cannot allow a user to set the keycode if the 
    // srcElement is an <input type=file>, otherwise it is possible for 
    // a page to access any file off the user's HardDrive without them
    // knowing (see  bug 49620 for a more complete description)
    // HTA's (trusted Doc's) should allow this.
    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    // is the srcElement an input , and if so is the type: file ?

    if (pparam->_pNode &&
        (pparam->_pNode->Tag() == ETAG_INPUT) &&
        (DYNCAST(CInput, pparam->_pNode->Element())->GetAAtype() == htmlInputFile) &&
        _pDoc &&
        !(pparam->_pNode->Element()->GetMarkup()->IsMarkupTrusted()))
    {
        hr = E_ACCESSDENIED;
    }
    else
    {
        pparam->_lKeyCode = lKeyCode;
    }

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

//+---------------------------------------------------------------
//
//  Method : get_repeat
//
//  Synopsis : returns a vbool indicating whether this was a repeated event
//          as in the case of holing a key down
//
//--------------------------------------------------------------

HRESULT
CEventObj::get_repeat (VARIANT_BOOL *pfRepeat)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfRepeat)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfRepeat = VARIANT_BOOL_FROM_BOOL(pparam->fRepeatCode);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_shiftLeft (VARIANT_BOOL *pfShiftLeft)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfShiftLeft)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfShiftLeft = VARIANT_BOOL_FROM_BOOL(pparam->_fShiftLeft);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_altLeft (VARIANT_BOOL *pfAltLeft)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfAltLeft)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfAltLeft = VARIANT_BOOL_FROM_BOOL(pparam->_fAltLeft);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_ctrlLeft (VARIANT_BOOL *pfCtrlLeft)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfCtrlLeft)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfCtrlLeft = VARIANT_BOOL_FROM_BOOL(pparam->_fCtrlLeft);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}

HRESULT
CEventObj::get_imeCompositionChange(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}

HRESULT
CEventObj::get_imeNotifyCommand(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _wParam ));
}

HRESULT
CEventObj::get_imeNotifyData(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}


HRESULT
CEventObj::get_imeRequest(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _wParam ));
}

HRESULT
CEventObj::get_imeRequestData(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}

HRESULT
CEventObj::get_keyboardLayout(LONG_PTR * plReturn)
{
    return GenericGetLongPtr(plReturn, offsetof(EVENTPARAM, _lParam ));
}

HRESULT
CEventObj::get_wheelDelta (long * plReturn)
{
    return GenericGetLong( plReturn, offsetof(EVENTPARAM, _wheelDelta ));
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventObj::get_altKey, get_ctrlKey, get_shiftKey
//
//  Synopsis:   Per IEventObj.  see macro defined at the top of this file.
//
//--------------------------------------------------------------------------

GETKEYVALUE(altKey, VB_ALT);
GETKEYVALUE(ctrlKey, VB_CONTROL);
GETKEYVALUE(shiftKey, VB_SHIFT);


PUTKEYVALUE(altKey, VB_ALT);
PUTKEYVALUE(ctrlKey, VB_CONTROL);
PUTKEYVALUE(shiftKey, VB_SHIFT);


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::get_cancelBubble
//
//  Synopsis:   Cancels the event bubbling. Used by CElement::FireEvents
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::get_cancelBubble(VARIANT_BOOL *pfCancel)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pfCancel)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pfCancel = VARIANT_BOOL_FROM_BOOL(pparam->fCancelBubble);

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::put_cancelBubble
//
//  Synopsis:   Cancels the event bubbling. Used by CElement::FireEvents
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::put_cancelBubble(VARIANT_BOOL fCancel)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->fCancelBubble = fCancel ? TRUE : FALSE;

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::get_returnValue
//
//  Synopsis:   Retrieve the current cancel status.
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::get_returnValue(VARIANT * pvarReturnValue)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    if (!pvarReturnValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    hr = THR(VariantCopy(pvarReturnValue, &pparam->varReturnValue));

Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CEventObj::put_returnValue
//
//  Synopsis:   Cancels the default action of an event.
//
//----------------------------------------------------------------------------

HRESULT
CEventObj::put_returnValue(VARIANT varReturnValue)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    hr = THR(VariantCopy (&pparam->varReturnValue, &varReturnValue));
    
    
Cleanup:
    RRETURN(_pDoc ? _pDoc->SetErrorInfo(hr) : hr);
}




//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_type
//
//  Synopsis :  For Nav 4.2 compatability. this returns a string which is the
//              type of this event.
//
//----------------------------------------------------------------------------
GET_STRING_VALUE(type, GetType )

PUT_STRING_VALUE(type, CopyType )

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_propertyName
//
//  Synopsis :  For the onproperty change event, this returnes the name of the
//     property that changed
//
//----------------------------------------------------------------------------

GET_STRING_VALUE(propertyName, GetPropName)

PUT_STRING_VALUE(propertyName, CopyPropName)

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_qualifier
//
//  Synopsis :  Qualifier argument to ondatasetchanged, ondataavailable, and
//              ondatasetcomplete events
//
//----------------------------------------------------------------------------

GET_STRING_VALUE(qualifier, GetQualifier)

PUT_STRING_VALUE(qualifier, CopyQualifier)

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_srcUrn
//
//----------------------------------------------------------------------------

GET_STRING_VALUE(srcUrn, GetSrcUrn)

PUT_STRING_VALUE(srcUrn, CopySrcUrn)

//+-------------------------------------------------------------------------
//
//  Method:     EVENTPARAM::GetParentCoordinates
//
//  Synopsis:   Helper function for getting the parent coordinates
//              notset/statis -- doc coordinates
//              relative      --  [styleleft, styletop] +
//                                [x-site.rc.x, y-site.rc.y]
//              absolute      --  [A_parent.rc.x, A_parent.rc.y,] +
//                                [x-site.rc.x, y-site.rc.y]
//
//  Parameters : px, py - the return point 
//               fContainer :  TRUE - COORDSYS_BOX
//                             FALSE - COORDSYS_CONTENT
//
//  these parameters are here for NS compat. and as such the parent defined
//  for the positioning are only ones that are absolutely or relatively positioned
//  or the body.
//
//--------------------------------------------------------------------------


HRESULT
EVENTPARAM::GetParentCoordinates(long * px, long * py)
{
    CPoint         pt(0,0);
    HRESULT        hr = S_OK;
    CLayout *      pLayout;
    CElement *     pElement;
    CDispNode *    pDispNode;
    CRect          rc;
    CTreeNode    * pZNode = _pNode;

    if (!_pNode || !_pNode->_pNodeParent)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // First, determine if we need to climb out of a slavetree
    //---------------------------------------------------------
    if (_pNode->Element()->HasMasterPtr())
    {
        Assert(_pNode->GetMarkup());

        CElement *pElemMaster;

        pElemMaster = _pNode->Element()->GetMasterPtr();
        if (!pElemMaster)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
        
        pZNode = pElemMaster->GetFirstBranch();
        if (!pZNode)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
    }

    // now the tricky part. We have a Node for the element that 
    // the event is on, but the "parent" that we are reporting
    // position information for is not constant. The parent is the 
    // first ZParent of this node that is relatively positioned
    // The canvas element (primary BODY/FRAMESET in non CSS1, HTML in CSS1) is
    // always a valid place to stop.
    // Absolutely positioned elements DON'T COUNT.
    //---------------------------------------------------------

    // walk up looking for a positioned thing.
    {
        Assert(pZNode->GetMarkup());

        while (     pZNode
                &&  !pZNode->IsRelative()
                &&  pZNode->Tag() != ETAG_ROOT
                &&  pZNode->GetMarkup()->GetCanvasElement() != pZNode->Element() )
        {
            pZNode = pZNode->ZParentBranch();
        }
    }

    pElement = pZNode ? pZNode->Element() : NULL;

    // now we know the element that we are reporting a position wrt
    // and so we just need to get the dispnode and the position info
    //---------------------------------------------------------
    if(pElement)
    {
        pLayout = pElement->GetUpdatedNearestLayout( _pLayoutContext );

        if(pLayout)
        {
            pDispNode = pLayout->GetElementDispNode(pElement);

            if(pDispNode)
            {
                CElement *pElementContent = pLayout->ElementContent();
                if (pElementContent && !pElementContent->HasVerticalLayoutFlow())
                {
                    pDispNode->TransformPoint(pt, COORDSYS_BOX, &pt, COORDSYS_GLOBAL);
                }
                else
                {
                    CRect rcBounds;
                    pDispNode->GetBounds(&rcBounds, COORDSYS_GLOBAL);
                    pt.x = rcBounds.left;
                    pt.y = rcBounds.top;
                }
            }
        }
    }

    // adjust for the offset of the mouse wrt the postition of the parent
    pt.x = _clientX - pt.x + _ptgClientOrigin.x;
    pt.y = _clientY - pt.y + _ptgClientOrigin.y;


    // and return the values.
    if (px)
        *px = pt.x;
    if (py)
        *py = pt.y;

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}
//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_srcFilter
//
//  Synopsis :  Return boolean of the filter that fired the event.
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_srcFilter(IDispatch **pFilter)
{
    HRESULT         hr = S_OK;
    EVENTPARAM *    pparam;

    if (!pFilter)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Try to get from attr array in first
    if(S_OK == GetDispatchPtr(DISPID_CEventObj_srcFilter, pFilter))
        goto Cleanup;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    *pFilter = NULL;

    if ( pparam->psrcFilter )
    {
        hr = pparam->psrcFilter->QueryInterface (
            IID_IDispatch, (void**)&pFilter );
        if ( hr == E_NOINTERFACE )
            hr = S_OK; // Just return NULL - some filters aren't automatable
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_bookmarks
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_bookmarks(IHTMLBookmarkCollection **ppBookmarkCollection)
{
    HRESULT         hr = E_NOTIMPL;
    EVENTPARAM *    pparam;
    IUnknown      * pUnk;

    if (!ppBookmarkCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppBookmarkCollection = NULL;

    if(S_OK == GetUnknownPtr(DISPID_CEventObj_bookmarks, &pUnk))
    {
        *ppBookmarkCollection = (IHTMLBookmarkCollection *)pUnk;
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    if (pparam->pProvider)
    {
        hr = pparam->pProvider->get_bookmarks(ppBookmarkCollection);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_recordset
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_recordset(IDispatch **ppDispRecordset)
{
    HRESULT         hr = S_OK;
    EVENTPARAM *    pparam;

    if (!ppDispRecordset)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispRecordset = NULL;

    if(!GetDispatchPtr(DISPID_CEventObj_recordset, ppDispRecordset))
        goto Cleanup;

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    if (pparam->pProvider)
    {
        hr = pparam->pProvider->get_recordset(ppDispRecordset);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_dataFld
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_dataFld(BSTR *pbstrDataFld)
{
    HRESULT         hr;
    EVENTPARAM *    pparam;
    AAINDEX         aaIndex;

    if (!pbstrDataFld)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDataFld = NULL;

    aaIndex = FindAAIndex(DISPID_CEventObj_dataFld, CAttrValue::AA_Internal);
    if(aaIndex != AA_IDX_UNKNOWN)
    {
        BSTR bstrStr;
        hr = THR(GetIntoBSTRAt(aaIndex, &bstrStr));
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(bstrStr, pbstrDataFld));
        goto Cleanup;
    }

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    if (pparam->pProvider)
    {
        hr = pparam->pProvider->get_dataFld(pbstrDataFld);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_boundElements
//
//  Synopsis :
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_boundElements(IHTMLElementCollection **ppElementCollection)
{
    HRESULT         hr = S_OK;
    IUnknown      * pUnk;

    if (!ppElementCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppElementCollection = NULL;

    if(S_OK == GetUnknownPtr(DISPID_CEventObj_boundElements, &pUnk))
    {
        *ppElementCollection = (IHTMLElementCollection *)pUnk;
        goto Cleanup;
    }

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(EVENT_BOUND_ELEMENTS_COLLECTION,
                                        (IDispatch **)ppElementCollection));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::put_repeat(VARIANT_BOOL fRepeat)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->fRepeatCode = BOOL_FROM_VARIANT_BOOL(fRepeat);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::put_shiftLeft(VARIANT_BOOL fShiftLeft)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->_fShiftLeft = BOOL_FROM_VARIANT_BOOL(fShiftLeft);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::put_ctrlLeft(VARIANT_BOOL fCtrlLeft)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->_fCtrlLeft = BOOL_FROM_VARIANT_BOOL(fCtrlLeft);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::put_altLeft(VARIANT_BOOL fAltLeft)
{
    HRESULT         hr;
    EVENTPARAM    * pparam;

    MAKESUREPUTSAREALLOWED

    hr = THR(GetParam(&pparam));
    if (hr)
        goto Cleanup;

    pparam->_fAltLeft = BOOL_FROM_VARIANT_BOOL(fAltLeft);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::put_boundElements(struct IHTMLElementCollection *pColl)
{
    RRETURN(PutUnknownPtr(DISPID_CEventObj_boundElements, pColl));
}


HRESULT
CEventObj::put_dataFld(BSTR strFld)
{
    HRESULT     hr;

    MAKESUREPUTSAREALLOWED

    hr = THR(AddBSTR(DISPID_CEventObj_dataFld, strFld, CAttrValue::AA_Internal));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::put_recordset(struct IDispatch *pDispatch)
{
    RRETURN(PutDispatchPtr(DISPID_CEventObj_recordset, pDispatch));
}


HRESULT
CEventObj::put_bookmarks(struct IHTMLBookmarkCollection *pColl)
{
    RRETURN(PutUnknownPtr(DISPID_CEventObj_bookmarks, pColl));
}


HRESULT
CEventObj::put_srcFilter(struct IDispatch *pDispatch)
{
    RRETURN(PutDispatchPtr(DISPID_CEventObj_srcFilter, pDispatch));
}


HRESULT
EVENTPARAM::CalcRestOfCoordinates()
{
    HRESULT     hr = S_OK;
    CLayout   * pLayout = NULL;

    if(_pNode)
    {
        hr = THR_NOTRACE(GetParentCoordinates(&_x, &_y));
        if(hr)
            goto Cleanup;

        pLayout = _pNode->GetUpdatedNearestLayout( _pLayoutContext );
        if (!pLayout)
        {
            _offsetX = -1;
            _offsetY = -1;
            goto Cleanup;
        }
        else
        {
            CPoint ptGlobal(_clientX, _clientY);
            CPoint ptLocal;
            pLayout->PhysicalGlobalToPhysicalLocal(ptGlobal, &ptLocal);
            _offsetX = ptLocal.x;
            _offsetY = ptLocal.y;
#if 0
            //
            // I would love to keep this assert, but the problem is that the old code was buggy when
            // we changed the border on the element and then we fired an event without calcing. In that
            // case the old code would account for the newly set borders while they are not shown on the
            // screen. The new way does not have that problem and that is where they differ and hence
            // the assert. So I am just commenting it out. If there is a bug where the reported offset*
            // on the event object is incorrect, then first uncomment this block of code to see if
            // the assert fires. If it does, then maybe the new code is buggy. BTW, the DRT at this
            // time passes without this assert firing.
            //
            {
                CElement *pElement = pLayout->ElementContent();

                // NOTES(SujalP): 
                // (1) The row seems to be buggy. If the border is applied to
                // the table thru a stylesheet, then the border ends up on the row too
                // but does not when its applied thru the border attribute (!)
                // (2) When we do not have a display node, GetPositionLeft returns
                // a bogus number (not zero as one would expect). Hence, in that case
                // just do not try to remain compat with the "bogus' number :-)
                // (3) (KTam) The body's GetBorderInfo always returns 0
                // if we're printing, so avoid the assert in that case.
                if (   !pLayout->ElementContent()->HasVerticalLayoutFlow()
                    && pElement->Tag() != ETAG_TR
                    && pLayout->GetElementDispNode()
                    && pLayout->GetElementDispNode()->HasParent()
                    && !( pElement->Tag() == ETAG_BODY && pElement->GetMarkup() && pElement->GetMarkup()->IsPrintMedia() )
                   )
                {
                    CBorderInfo bi;
                    long pl = pLayout->GetPositionLeft(COORDSYS_GLOBAL);
                    long pt = pLayout->GetPositionTop(COORDSYS_GLOBAL);
                    pElement->GetBorderInfo(NULL, &bi, FALSE);
                    Assert(_offsetX == _clientX - pl + pLayout->GetXScroll() - bi.aiWidths[SIDE_LEFT]);
                    Assert(_offsetY == _clientY - pt + pLayout->GetYScroll() - bi.aiWidths[SIDE_TOP]);
                }
            }
#endif
        }
    }

Cleanup:
    RRETURN(hr);
}


void
EVENTPARAM::SetClientOrigin(CElement * pElement, const POINT * pptClient)
{
    if (pElement)
        pElement->GetClientOrigin(&_ptgClientOrigin);

    if (pptClient)
    {
        _clientX = pptClient->x - _ptgClientOrigin.x;
        _clientY = pptClient->y - _ptgClientOrigin.y;

    }
}

void
EVENTPARAM::SetNodeAndCalcCoordinates(CTreeNode *pNewNode, BOOL fFixClientOrigin /*=FALSE*/)
{
    if(_pNode != pNewNode)
    {
        if (fFixClientOrigin)
        {
            POINT ptOrgOld = _ptgClientOrigin;

            if (!pNewNode)
            {
                _ptgClientOrigin = g_Zero.pt;
            }
            else
            {
                Assert(_pNode);
                Assert(_pNode->GetMarkup()->Root()->GetMasterPtr() == pNewNode->Element());

                SetClientOrigin(pNewNode->Element(), NULL);
            }

            _clientX -= (_ptgClientOrigin.x - ptOrgOld.x);
            _clientY -= (_ptgClientOrigin.y - ptOrgOld.y);
        }

        _pNode = pNewNode;
        if (_pNode)
            CalcRestOfCoordinates();
    }
}

void
EVENTPARAM::SetNodeAndCalcCoordsFromOffset(CTreeNode *pNewNode)
{
    Assert(_fOffsetXSet || _fOffsetYSet);
    _pNode = pNewNode;
    if(_pNode)
    {
        POINT pt = {0,0};
        CLayout *pLayout = _pNode->GetUpdatedNearestLayout(_pLayoutContext);

        if (_fOffsetXSet || _fOnStack || _offsetX)
        {
            // either X offset is set explicity or implicity as a result of being in a nested event.
            Assert(_fOffsetXSet || (_fOnStack && _fOffsetYSet) || (_offsetX && _fOffsetYSet));
            if (pLayout)
            {
                CPoint ptLocal(_offsetX, 0);
                CPoint ptGlobal;
                pLayout->PhysicalLocalToPhysicalGlobal(ptLocal, &ptGlobal);
                pt.x = _clientX = ptGlobal.x;
            }
        }
        else
        {
            // Y offset is set explicity, but X offset is not set (explicitly or implicitly) 
            // -- event param created on heap --- calculate it based upon clientX of current location
            Assert(!_fOnStack && _fOffsetYSet);
            if (pLayout)
            {
                CPoint ptGlobal(_clientX, 0);
                CPoint ptLocal;
                pLayout->PhysicalGlobalToPhysicalLocal(ptGlobal, &ptLocal);
                _offsetX = ptLocal.x;
            }
            else
            {
                _offsetX = -1;
            }
            pt.x = _clientX;
        }

        if (_fOffsetYSet || _fOnStack || _offsetY)
        {
            // either Y offset is set explicity or implicity as a result of being in a nested event.
            Assert(_fOffsetYSet || (_fOnStack && _fOffsetXSet) || (_offsetY && _fOffsetXSet));
            if (pLayout)
            {
                CPoint ptLocal(0, _offsetY);
                CPoint ptGlobal;
                pLayout->PhysicalLocalToPhysicalGlobal(ptLocal, &ptGlobal);
                pt.y = _clientY = ptGlobal.y;
            }
        }
        else
        {
            // X offset is set explicity, but Y offset is not set (explicitly or implicitly) 
            // -- event param created on heap --- calculate it based upon clientX of current location
            Assert(!_fOnStack && _fOffsetXSet);
            if (pLayout)
            {
                CPoint ptGlobal(0, _clientY);
                CPoint ptLocal;
                pLayout->PhysicalGlobalToPhysicalLocal(ptGlobal, &ptLocal);
                _offsetY = ptLocal.y;
            }
            else
            {
                _offsetY = -1;
            }
            pt.y = _clientY;
        }

        if (pDoc)
        {
            if (pDoc->_pInPlace)
            {
                ClientToScreen(pDoc->_pInPlace->_hwnd, &pt);
            }
        }
        else
        {
            ::GetCursorPos(&pt);
        }
        _screenX = pt.x;
        _screenY = pt.y;

        IGNORE_HR(GetParentCoordinates(&_x, &_y));
    }
}

HRESULT
CEventObj::PutUnknownPtr(DISPID dispid, IUnknown *pElement)
{
    HRESULT hr;

    MAKESUREPUTSAREALLOWED

    if(pElement)                                              \
        pElement->AddRef();                                   \

    hr = THR(AddUnknownObject(dispid, (IUnknown *)pElement, CAttrValue::AA_Internal));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CEventObj::PutDispatchPtr(DISPID dispid, IDispatch *pDispatch)
{
    HRESULT hr;

    MAKESUREPUTSAREALLOWED

    if(pDispatch)
        pDispatch->AddRef();

    hr = THR(AddDispatchObject(dispid, pDispatch, CAttrValue::AA_Internal));

Cleanup:
    RRETURN(SetErrorInfo(hr));

}


HRESULT
CEventObj::GetUnknownPtr(DISPID dispid, IUnknown **ppElement)
{
    HRESULT hr;
    AAINDEX aaIndex = FindAAIndex(dispid, CAttrValue::AA_Internal);

    Assert(ppElement);

    if(aaIndex != AA_IDX_UNKNOWN)
        hr = THR(GetUnknownObjectAt(aaIndex, ppElement));
    else
    {
        *ppElement = NULL;
        hr = S_FALSE;
    }

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}


HRESULT
CEventObj::GetDispatchPtr(DISPID dispid, IDispatch **ppElement)
{
    HRESULT hr;
    AAINDEX aaIndex = FindAAIndex(dispid, CAttrValue::AA_Internal);

    if(aaIndex != AA_IDX_UNKNOWN)
        hr = THR(GetDispatchObjectAt(aaIndex, ppElement));
    else
        hr = S_FALSE;

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  member :    CEventObj::get_dataTransfer
//
//  Synopsis :  Return the data transfer object.
//
//----------------------------------------------------------------------------
HRESULT
CEventObj::get_dataTransfer(IHTMLDataTransfer **ppDataTransfer)
{
    HRESULT hr = S_OK;
    CDataTransfer * pDataTransfer;
    IDataObject * pDataObj = _pDoc ? _pDoc->_pInPlace->_pDataObj : NULL;

    if (!ppDataTransfer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDataTransfer = NULL;

    // are we in a drag-drop operation?
    if (!pDataObj)
    {
        CDragStartInfo * pDragStartInfo = _pDoc->_pDragStartInfo;
        if (!pDragStartInfo)
            // leave hr = S_OK and just return NULL
            goto Cleanup;
        if (!pDragStartInfo->_pDataObj)
        {
            hr = pDragStartInfo->CreateDataObj();
            if (hr || pDragStartInfo->_pDataObj == NULL)
                goto Cleanup;
        }

        pDataObj = pDragStartInfo->_pDataObj;
    }

    Assert(_pMarkupContext->Window()->Window());

    pDataTransfer = new CDataTransfer(_pMarkupContext->Window()->Window(), pDataObj, TRUE);   // fDragDrop = TRUE
    if (!pDataTransfer)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pDataTransfer->QueryInterface(
                IID_IHTMLDataTransfer,
                (void **) ppDataTransfer));
        pDataTransfer->Release();
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::get_behaviorCookie(LONG *plCookie)
{
    EVENTPARAM *pparam;

    HRESULT hr;
    
    if (!plCookie)
        hr = E_POINTER;
    else
    {
        hr = THR(GetParam(&pparam));

        if (hr == S_OK)
            *plCookie = pparam->_lBehaviorCookie;
    }

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CEventObj::get_behaviorPart(LONG *plPartID)
{
    EVENTPARAM *pparam;

    HRESULT hr;
    
    if (!plPartID)
        hr = E_POINTER;
    else
    {
        hr = THR(GetParam(&pparam));

        if (hr == S_OK)
            *plPartID = pparam->_lBehaviorPartID;
    }

    RRETURN(SetErrorInfo(hr));
}

CMarkup *
CEventObj::GetMarkupContext()
{
    EVENTPARAM *pParam;

    if (_pMarkupContext)
        return _pMarkupContext;

    GetParam(&pParam);
    
    Assert(pParam);

    _pMarkupContext = pParam->_pElement ? pParam->_pElement->GetWindowedMarkupContext() : pParam->_pMarkup;
    if (_pMarkupContext)
        _pMarkupContext->SubAddRef();

    Assert(!_pMarkupContext || pParam->_pMarkup || pParam->_pElement);

    return _pMarkupContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\filtcol.cxx ===
//=================================================================
//
//   File:      filtcol.cxx
//
//  Contents:   CFilterArray class
//
//  Classes:    CFilterArray
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DXTRANS_H_
#define X_DXTRANS_H_
#include "dxtrans.h"
#endif 

#ifndef X_DXTRANSP_H_
#define X_DXTRANSP_H_
#include "dxtransp.h"
#endif

#ifndef X_INTERNED_H_
#define X_INTERNED_HXX_
#include "interned.h"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "filter.hdl"

EXTERN_C const IID IID_IHTMLFiltersCollection;

MtDefine(CFilterBehaviorSite, Elements, "CFilterBehaviorSite")
MtDefine(CFilterArray, ObjectModel, "CFilterArray")
MtDefine(CFilterArray_aryFilters_pv, CFilterArray, "CFilterArray::_aryFilters::_pv")
MtDefine(CPageTransitionInfo, Filters, "CPageTransitionInfo")

MtExtern(CFancyFormat_pszFilters);


DeclareTag(tagPageTransitionsOn, "PageTrans", "Always do page transitions");
DeclareTag(tagPageTransitionTrace, "PageTrans", "Trace page transition calls");
DeclareTag(tagFilterChange, "filter", "Trace filter change events");


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFilterSite
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : CTOR
//
//-----------------------------------------------------------------

CFilterBehaviorSite::CFilterBehaviorSite(CElement * pElem) : super()
{
    _pElem    = pElem;
}


//+----------------------------------------------------------------
//
//  member : ClassDesc Structure
//
//-----------------------------------------------------------------

const CBase::CLASSDESC CFilterBehaviorSite::s_classdesc =
{
    NULL,                                // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                // _pcpi
    0,                                   // _dwFlags
    &IID_ICSSFilterSite,                 // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};


//+---------------------------------------------------------------------
//
//  Class:      CFilterBehaviorSite::PrivateQueryInterface
//
//  Synapsis:   Site object for CSS Extension objects on CElement
//
//------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::PrivateQueryInterface( REFIID iid, LPVOID *ppv )
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS((IServiceProvider *)this, IServiceProvider)
        QI_TEAROFF(this, IBindHost, (IOleClientSite*)this)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        
        default:
        if (iid == IID_IDispatchEx || iid == IID_IDispatch)
        {
            hr = THR(CreateTearOffThunk(this, s_apfnIDispatchEx, NULL, ppv));
        }
    }

    if (*ppv)
        ((IUnknown *)*ppv)->AddRef();
    else if (!hr)
        hr = E_NOINTERFACE;

    RRETURN(hr);
}


//+---------------------------------------------------------------------
//
//  Class:      CFilterBehaviorSite::Passivate
//
//  Synopsis:   Called when refcount goes to 0
//
//------------------------------------------------------------------------
void
CFilterBehaviorSite::Passivate()
{
    ClearInterface(&_pDXTFilterBehavior);
    ClearInterface(&_pDXTFilterCollection);

    super::Passivate();
}


//+-----------------------------------------------------------------------------
//
//  Method: CFilterBehaviorSite::GetIHTMLFiltersCollection
//
//  Overview:
//      In normal filter usage, this is called when the element's get_filters
//      method is called.  It is also called by this class when page
//      transitions are in use.
//
//------------------------------------------------------------------------------
HRESULT 
CFilterBehaviorSite::GetIHTMLFiltersCollection(IHTMLFiltersCollection ** ppCol)
{
    HRESULT                 hr              = S_OK;
    IDXTFilterCollection *  pDXTFilterCol   = NULL;

    Assert(_pDXTFilterBehavior);

    if (!_pDXTFilterBehavior)
    {
        hr = E_FAIL;

        goto Cleanup;
    }

    hr = THR(_pDXTFilterBehavior->GetFilterCollection(&pDXTFilterCol));

    if (hr)
    {
        goto Cleanup;
    }

    Assert(pDXTFilterCol);

    hr = THR(pDXTFilterCol->QueryInterface(IID_IHTMLFiltersCollection, (void **)ppCol));
    
Cleanup:

    ReleaseInterface(pDXTFilterCol);

    RRETURN(hr);
}
//  Method: CFilterBehaviorSite::GetIHTMLFiltersCollection


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::GetElement, public
//
//  Synopsis:   Returns the IHTMLElement pointer of the Element this site
//              belongs to.
//              This causes a hard AddRef on CElement. Clients are *not* to
//              cache this pointer.
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::GetElement( IHTMLElement **ppElement )
{
    RRETURN(_pElem->QueryInterface( IID_IHTMLElement,
                       (void **)ppElement ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::FireOnFilterEvent, public
//
//  Synopsis:   Fires an event for the extension object
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::FireOnFilterChangeEvent()
{
    HRESULT     hr = S_OK;

    CBase::CLock Lock1(this);
    CBase::CLock Lock2(_pElem);
    CDoc *       pDoc = _pElem->Doc();

    if(!_pElem || !_pElem->IsInMarkup())
        goto Cleanup;
    if(_pElem->IsRoot()  && _pElem->Document() && _pElem->Document()->HasPageTransitions())
    {
        // Post a request to remove the peer
        _pElem->Document()->PostCleanupPageTansitions();
        goto Cleanup;
    }


    if (!_pElem->GetAAdisabled())
    {
        EVENTPARAM  param(pDoc, _pElem, NULL, TRUE);

        CDoc::CLock Lock(pDoc);

        param.SetNodeAndCalcCoordinates(_pElem->GetFirstBranch());
        param.SetType(s_propdescCElementonfilterchange.a.pstrName + 2);
        
        hr = THR(_pDXTFilterBehavior->QueryInterface(IID_IElementBehavior, (void **)&(param.psrcFilter)));
        if(hr)
            goto Cleanup;
        // Released by dtor of EVENTPARAM

        TraceTag((tagFilterChange, "Post onfilterchange for %ls-%d",
                    _pElem->TagName(), _pElem->SN()));

        // Fire against the element
        hr = THR(GWPostMethodCall(_pElem, ONCALL_METHOD(CElement, Fire_onfilterchange, fire_onfilterchange), 
                                0, TRUE, "CElement::Fire_onfilterchange"));
    }
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::QueryService
//
//  Synopsis:   Get service from host. this delegates to the documents
//              implementation.
//
//-------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    if (IsEqualGUID(guidService, SID_SBindHost))
    {
        RRETURN (THR(QueryInterface(iid, ppv)));
    }
    else // delegate to the CDocument we are sitting in
    {
        CDocument * pDocument = _pElem->Document();

        if (pDocument)
        {
            RRETURN(pDocument->QueryService(guidService, iid, ppv));
        }
    }
    
    RRETURN(E_NOINTERFACE);
}


//+-----------------------------------------------------------------------
//
//  member : CFilterBehaviorSite::RemoveFilterBehavior
//
//  SYNOPSIS : Detaches the behavior from the element and removes it
//
//-------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::RemoveFilterBehavior()
{
    HRESULT         hr;
    VARIANT_BOOL    fbResult;

    Assert(_pDXTFilterBehavior != NULL);
    Assert(_pElem);
    
    hr = THR(_pElem->removeBehavior(_lBehaviorCookie, &fbResult));

    ClearInterface(&_pDXTFilterBehavior);
    ClearInterface(&_pDXTFilterCollection);

    _strFullText.Free();

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::CreateFilterBehavior
//
//  Overview: 
//      Creates the filter behavior and attaches it to given element.
//
//-------------------------------------------------------------------------------
STDMETHODIMP 
CFilterBehaviorSite::CreateFilterBehavior(CElement * pElem)
{
    HRESULT             hr                  = S_OK;
    CDoc *              pDoc                = pElem->Doc();
    IElementBehavior *  pIElemBehavior      = NULL;
    ICSSFilter *        pICSSFilter         = NULL;
    BSTR                bstrBehaviorFind    = NULL;
    BSTR                bstrBehaviorAdd     = NULL;
    VARIANT             varParam;

    Assert(pElem);
    Assert(pDoc);
    Assert(pDoc->_pFilterBehaviorFactory);
    Assert(_pElem);
    Assert(NULL == _pDXTFilterBehavior);
    Assert(NULL == _pDXTFilterCollection);

    bstrBehaviorFind = SysAllocString(L"DXTFilterBehavior");

    if (NULL == bstrBehaviorFind)
    {
        hr = E_OUTOFMEMORY;

        goto Cleanup;
    }

    bstrBehaviorAdd = SysAllocString(L"#DXTFilterFactory#DXTFilterBehavior");

    if (NULL == bstrBehaviorAdd)
    {
        hr = E_OUTOFMEMORY;

        goto Cleanup;
    }

    // ##ISSUE: (mcalkins) Instead of creating a filter behavior, a better idea
    //          for the future is to just create a lightweight filter collection
    //          object and let it decide when and if a filter behavior needs to
    //          be created, attached to the element, or destroyed.

    // Create the filter behavior.

    hr = THR(pDoc->_pFilterBehaviorFactory->FindBehavior(bstrBehaviorFind, NULL,
                                                         NULL, 
                                                         &pIElemBehavior));

    if (hr)
    {
        goto Cleanup;
    }

    V_VT(&varParam)         = VT_UNKNOWN;
    V_UNKNOWN(&varParam)    = pIElemBehavior;
    
    hr = THR(_pElem->addBehavior(bstrBehaviorAdd, &varParam, &_lBehaviorCookie));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(pIElemBehavior->QueryInterface(__uuidof(IDXTFilterBehavior), 
                                            (void **)&_pDXTFilterBehavior));
    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(_pDXTFilterBehavior->GetFilterCollection(&_pDXTFilterCollection));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(pIElemBehavior->QueryInterface(IID_ICSSFilter, 
                                            (void **)&pICSSFilter));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(pICSSFilter->SetSite((ICSSFilterSite *)&_CSSFilterSite));

    if (hr)
    {
        goto Cleanup;
    }

Cleanup:

    SysFreeString(bstrBehaviorFind);
    SysFreeString(bstrBehaviorAdd);
    ReleaseInterface(pIElemBehavior);
    ReleaseInterface(pICSSFilter);

    RRETURN(hr);
}
//  Member: CFilterBehaviorSite::CreateFilterBehavior


//+-----------------------------------------------------------------------
//
//  member : NextFilterDescStr
//
//  SYNOPSIS : Advances to the next filter desription string.
//             Then end if current description is considered
//             1. The end of the string
//             2. A ) symbol
//             3. A space that is not followed by a ( symbol
//
//-------------------------------------------------------------------------

TCHAR *
NextFilterDescStr(LPTSTR pszToken)
{
    BOOL fInParen = FALSE;

    while (_istspace(*pszToken))
        pszToken++;       // Skip any leading whitespace

    do
    {
        // Skip until end of string or ) or space
        while(*pszToken && *pszToken != _T(')') && *pszToken != _T('(') && (!_istspace(*pszToken) || fInParen))
            pszToken++;
        // Skip the extra spaces
        while(_istspace(*pszToken))
            pszToken++;
        // If it is a ( that means we need to continue to parse
        if(*pszToken != _T('('))
            break;
        // We are in inside ( and we will not break on spaces any more
        fInParen = TRUE;
        pszToken++;
    } while(*pszToken);

    if(*pszToken == _T(')'))
        pszToken++; 

    // Skip the extra spaces
    while(_istspace(*pszToken))
        pszToken++;

    return pszToken;     
}


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::ParseAndAddFilters
//
//  Overview:
//      Parses the filter stirng adds all the filters to the filter behavior.
//
//-------------------------------------------------------------------------

MtDefine(CFilterBehaviorSite_ParseAndAddFilters_pszCopy, Locals, "CFilterBehaviorSite::ParseAndAddFilters pszCopy");
HRESULT
CFilterBehaviorSite::ParseAndAddFilters()
{
    HRESULT hr              = S_OK;
    LPTSTR  pszCopy         = NULL;
    LPTSTR  pszFilterName   = NULL;
    LPTSTR  pszNextFilter   = NULL;
    LPTSTR  pszParams       = NULL;
    LPTSTR  pszEnd          = NULL;

    if(_strFullText.Length() == 0)
    {
        goto done;
    }

    // TODO: handle OOM here
    MemAllocString(Mt(CFilterBehaviorSite_ParseAndAddFilters_pszCopy), _strFullText, &pszCopy);
    pszFilterName = pszCopy;

    while(pszFilterName && *pszFilterName)
    {
        pszEnd = pszNextFilter = NextFilterDescStr(pszFilterName);

        // Find to the last nonspace before the next token
        // and zero the end of the stirng
        if( pszEnd > pszFilterName)
        {
            pszEnd--;
            while(pszEnd > pszFilterName && _istspace(*pszEnd))
            {
                *pszEnd = _T('\0');;   // Go back to the last nonspace
                pszEnd--;
            }
        }

        // Remove the ) if any
        if ( *pszEnd == _T(')') )
            *pszEnd-- = _T('\0');

        // Now separate the name from the parameters
        pszParams = pszFilterName;
        while(*pszParams && *pszParams != _T('('))
            pszParams++;
        
        // and remove the ( from the parameters
        if (*pszParams == _T('('))
            *pszParams++ = _T('\0');

        // Now remove all the extra spaces
        while (_istspace(*pszParams))
            pszParams++;       // Skip any leading whitespace
        while (_istspace(*pszFilterName))
            pszFilterName++;       // Skip any leading whitespace
        pszEnd = pszParams + _tcslen(pszParams) - 1;
        while(pszEnd >= pszParams && _istspace(*pszEnd))
            *pszEnd-- = 0;
        pszEnd = pszFilterName + _tcslen(pszFilterName) - 1;
        while(pszEnd >= pszFilterName && _istspace(*pszEnd))
            *pszEnd-- = 0;

        // pszFilterName should point to the function name, and pszParams should point to the parameter string
        IGNORE_HR(AddFilterToBehavior(pszFilterName, pszParams));

        // Move to the next filter description
        pszFilterName = pszNextFilter;
    }

done:

    if (pszCopy)
    {
        MemFree(pszCopy);
    }

    return hr;
}
//  Member: CFilterBehaviorSite::ParseAndAddFilters


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::AddFilterToBehavior
//
//  Overview: 
//      Adds a filter with given name and parameters to the behavior.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CFilterBehaviorSite::AddFilterToBehavior(TCHAR * szName, TCHAR * szArgs)
{
    HRESULT  hr     = S_OK;
    BSTR     bstr   = NULL;
    CStr     str;

    str.Set(szName);
    str.Append(_T("(")); 
    str.Append(szArgs);
    str.Append(_T(")"));

    hr = THR(str.AllocBSTR(&bstr));

    if (hr)
    {
        goto Cleanup;
    }

    hr = THR(_pDXTFilterCollection->AddFilter(bstr, DXTFTF_CSS, NULL, NULL));

    if (hr)
    {
        goto Cleanup;
    }

Cleanup:

    FormsFreeString(bstr);

    RRETURN(hr);
}
//  Member: CFilterBehaviorSite::AddFilterToBehavior


//+-----------------------------------------------------------------------------
//
//  Member: CFilterBehaviorSite::RemoveAllCSSFilters
//
//------------------------------------------------------------------------------
STDMETHODIMP
CFilterBehaviorSite::RemoveAllCSSFilters()
{
    Assert(_pDXTFilterCollection);

    return _pDXTFilterCollection->RemoveFilters(DXTFTF_CSS);
}
//  Member: CFilterBehaviorSite::RemoveAllCSSFilters


//+-----------------------------------------------------------------------
//
//  member : CFilterBehaviorSite::GetICSSFilter
//
//  SYNOPSIS : Returns the ICSSFilter pointer from the filter behavior
//
//-------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::GetICSSFilter(ICSSFilter **ppICSSFilter)
{
    Assert(_pDXTFilterBehavior);
    Assert(ppICSSFilter);
    *ppICSSFilter = NULL;
    if(!_pDXTFilterBehavior)
        RRETURN(E_FAIL);
    RRETURN(_pDXTFilterBehavior->QueryInterface(IID_ICSSFilter, (void **)ppICSSFilter));
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::GetFilter
//
//  Synopsis:   Given the number of the filter in the collection returns the 
//                  IDXTFilter. If number is -1 returns last filter
//----------------------------------------------------------------------------

STDMETHODIMP 
CFilterBehaviorSite::GetFilter(int nFilterNum, 
                               ICSSFilterDispatch ** ppCSSFilterDispatch)
{
    HRESULT                     hr          = S_OK;
    IHTMLFiltersCollection *    pFiltCol    = NULL;
    long                        nItems      = 0;
    CVariant                    varIn;
    CVariant                    varOut;

    Assert(ppCSSFilterDispatch);
    Assert(!(*ppCSSFilterDispatch));

    *ppCSSFilterDispatch = NULL;

    // Get the filter collection first.

    hr = THR(GetIHTMLFiltersCollection(&pFiltCol));

    if(hr)
        goto Cleanup;

    Assert(pFiltCol);
    
    // get the number of items
    hr = THR(pFiltCol->get_length(&nItems));
    if(hr)
        goto Cleanup;
    if(nFilterNum == -1)
        nFilterNum = nItems - 1;

    // Check for being in range
    if(nFilterNum < 0 || nFilterNum >= nItems)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get the filter at given postiotion
    V_VT(&varIn) = VT_I4; V_I4(&varIn) = nFilterNum;
    hr = pFiltCol->item(&varIn, &varOut);
    if(hr)
        goto Cleanup;
    if(V_VT(&varOut) != VT_DISPATCH)
    {
        AssertSz(FALSE, "item() on filters collection returned a non-dispatch pointer");
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(V_DISPATCH(&varOut)->QueryInterface(__uuidof(ICSSFilterDispatch), 
                                                 (void **)ppCSSFilterDispatch));

Cleanup:
    ReleaseInterface(pFiltCol);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::ApplyFilter
//
//  Synopsis:   Invoke apply on given transition filter, or the last one if 
//                  nFilterNum is -1
//              Invoke takes the first snapshot for the transition. Later 
//                  Play will take the second snapshot (end of transition)
//----------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::ApplyFilter(int nFilterNum)
{
    HRESULT                 hr      = S_OK;
    ICSSFilterDispatch *    pCSSFD  = NULL;

    hr = THR(GetFilter(nFilterNum, &pCSSFD));

    if(hr)
        goto Cleanup;

    hr = THR(pCSSFD->Apply());
    
Cleanup:

    ReleaseInterface(pCSSFD);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::PlayFilter
//
//  Synopsis:   Invoke play on given transition filter, or the last one if 
//                  nFilterNum is -1
//              Invoke takes the first snapshot for the transition. Then
//                  Play takes the second snapshot (end of transition)
//----------------------------------------------------------------------------

HRESULT 
CFilterBehaviorSite::PlayFilter(int nFilterNum, float fDuration /* = 0 */)
{
    HRESULT                 hr          = S_OK;
    ICSSFilterDispatch *    pCSSFD      = NULL;
    CVariant                varDuration;

    hr = THR(GetFilter(nFilterNum, &pCSSFD));

    if(hr)
        goto Cleanup;

    if(fDuration != 0)
    {
        V_VT(&varDuration) = VT_R4;
        V_R4(&varDuration) = fDuration;
    }
    else
    {
        V_VT(&varDuration) = VT_ERROR;
    }

    hr = THR(pCSSFD->Play(varDuration));
    
Cleanup:

    ReleaseInterface(pCSSFD);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::SetSize
//
//  Synopsis:   Explicitly calls SetSize of the filter behavior.
//----------------------------------------------------------------------------

HRESULT
CFilterBehaviorSite::SetSize(CSize *pSize)
{
    HRESULT           hr;
    CPeerHolder     * pPeerHolder;

    pPeerHolder = _pElem->GetPeerHolder();
    if(!pPeerHolder)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pPeerHolder->GetSize(BEHAVIORLAYOUTMODE_NATURAL, *pSize,
                                            NULL, NULL, pSize));
Cleanup:
    RRETURN(hr);   
}

HRESULT
CFilterBehaviorSite::InvokeEx(DISPID dispidMember,
                 LCID lcid,
                 WORD wFlags,
                 DISPPARAMS * pdispparams,
                 VARIANT * pvarResult,
                 EXCEPINFO * pexcepinfo,
                 IServiceProvider *pSrvProvider)
{
    HRESULT hr = S_OK;

    if (!pvarResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch (dispidMember)
    {
        case DISPID_AMBIENT_PALETTE:
        V_VT(pvarResult) = VT_HANDLE;
        V_BYREF(pvarResult) = (void *)_pElem->Doc()->GetPalette();
        break;
    }

Cleanup:
    RRETURN(hr);
}


// defined in site\ole\OleBindh.cxx:
extern HRESULT
MonikerBind(
    CMarkup *               pMarkup,
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppv,
    BOOL                    fObject,
    DWORD                   dwCompatFlags);


BEGIN_TEAROFF_TABLE(CFilterBehaviorSite, IBindHost)
    TEAROFF_METHOD(CFilterBehaviorSite, CreateMoniker, createmoniker,
    (LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved))
    TEAROFF_METHOD(CFilterBehaviorSite, MonikerBindToStorage, monikerbindtostorage,
    (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
    TEAROFF_METHOD(CFilterBehaviorSite, MonikerBindToObject, monikerbindtoobject,
    (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
END_TEAROFF_TABLE()

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CreateMoniker, IBindHost
//
//  Synopsis:   Parses display name and returns a URL moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFilterBehaviorSite::CreateMoniker(LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved)
{
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchUrl = cBuf;
    HRESULT     hr;

    hr = THR(CMarkup::ExpandUrl(
            _pElem->GetMarkup(), szName, ARRAY_SIZE(cBuf), pchUrl, _pElem));
    if (hr)
        goto Cleanup;

    hr = THR(CreateURLMoniker(NULL, pchUrl, ppmk));
        if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::MonikerBindToStorage, IBindHost
//
//  Synopsis:   Calls BindToStorage on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFilterBehaviorSite::MonikerBindToStorage(
    IMoniker * pmk,
    IBindCtx * pbc,
    IBindStatusCallback * pbsc,
    REFIID riid,
    void ** ppvObj)
{
    RRETURN1(MonikerBind(
        _pElem->GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        FALSE,
        0), S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::MonikerBindToObject, IBindHost
//
//  Synopsis:   Calls BindToObject on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFilterBehaviorSite::MonikerBindToObject(
    IMoniker * pmk,
    IBindCtx * pbc,
    IBindStatusCallback * pbsc,
    REFIID riid,
    void ** ppvObj)
{
    RRETURN1(MonikerBind(
        _pElem->GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        TRUE,
        0), S_ASYNCHRONOUS);
}


HRESULT
CFilterBehaviorSite::OnCommand ( COnCommandExecParams * pParm )
{
    CTExec(_pDXTFilterBehavior, pParm->pguidCmdGroup, pParm->nCmdID,
               pParm->nCmdexecopt, pParm->pvarargIn,
               pParm->pvarargOut);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::AddRef, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
CFilterBehaviorSite::CCSSFilterSite::AddRef()
{
    return MyFBS()->SubAddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::Release, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
CFilterBehaviorSite::CCSSFilterSite::Release()
{
    return MyFBS()->SubRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::QueryInterface, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

HRESULT
CFilterBehaviorSite::CCSSFilterSite::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
        QI_INHERITS((ICSSFilterSite *)this, ICSSFilterSite)
    }

    if (!*ppv)
    {
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::GetElement, ICSSFilterSite
//
//  Synopsis:   Returns the IHTMLElement pointer of the Element this site
//              belongs to.
//              This causes a hard AddRef on CElement. Clients are *not* to
//              cache this pointer.
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::CCSSFilterSite::GetElement( IHTMLElement **ppElement )
{
    RRETURN(MyFBS()->GetElement(ppElement));
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterBehaviorSite::CCSSFilterSite::FireOnFilterChangeEvent, ICSSFilterSite
//
//  Synopsis:   Fires an event for the extension object
//
//----------------------------------------------------------------------------
HRESULT
CFilterBehaviorSite::CCSSFilterSite::FireOnFilterChangeEvent()
{
    RRETURN(MyFBS()->FireOnFilterChangeEvent());
}



//+---------------------------------------------------------------------------
//  Member:     IsCrossWebSiteNavigation
//
//  Synopsis:   Returns True if old and new markup or on different sites (domains)
//----------------------------------------------------------------------------

BOOL 
IsCrossWebSiteNavigation(CMarkup *pMarkupOld, CMarkup * pMarkupNew)
{
    BOOL            fSite = TRUE;
    BYTE            abSID1[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID1 = ARRAY_SIZE(abSID1);
    BYTE            abSID2[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID2 = ARRAY_SIZE(abSID2);
    HRESULT         hr;

    hr = THR(pMarkupOld->GetSecurityID(abSID1, &cbSID1));
    if(hr)
        goto Cleanup;

    hr = THR(pMarkupNew->GetSecurityID(abSID2, &cbSID2));
    if(hr)
        goto Cleanup;

    if(cbSID1 == cbSID2 && !memcmp(abSID1, abSID2, cbSID1))
        fSite = FALSE;

Cleanup:
    return fSite;
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::ApplyPageTransitions
//
//  Synopsis:    Takes the old markup (that goes away, but is still the active markup)
//              and the new markup and sets up the page transition from the old one
//              to the new. Takes the snapshot from the old markup
//               As we are not guaranteed to have a body or frameset element on the
//              new markup yet, we add the filter for the page transition to the root
//              element and then delegate the calls to it to the body or frameset of 
//              the old markup (during apply) and new markup (during play and later).
//----------------------------------------------------------------------------

HRESULT 
CDocument::ApplyPageTransitions(CMarkup *pMarkupOld, CMarkup *pMarkupNew)
{
    HRESULT                hr = E_FAIL;
    CElement             * pRootElement = NULL;
    CFilterBehaviorSite  * pFS;
    CFancyFormat         * pFF;
    CPageTransitionInfo  * pPgTransInfo = GetPageTransitionInfo();
    LPCTSTR                szFilterStr;
    BOOL                   fSiteSwitch = FALSE;
    CSize                  size;
    CElement             * pCanvasElement;

    TraceTag((tagPageTransitionTrace, "PGTRANS: Apply called with markup %08lX.", pMarkupNew));

    // Get the program options object
    OPTIONSETTINGS  * pos = Doc() ? Doc()->_pOptionSettings : NULL;

    // Check if page transitions are disabled in the registry
    if(pos && !pos->fPageTransitions)
    {
        TraceTag((tagPageTransitionTrace, "PGTRANS: Transitions disabled in registry"));
        hr = S_OK;
        goto Cleanup;
    }

    // Check if the navigation is across the domains
    fSiteSwitch = IsCrossWebSiteNavigation(pMarkupOld, pMarkupNew);

#if DBG == 1
    if(IsTagEnabled(tagPageTransitionsOn))
    {
        // Do a hardcoded transition for every navigation
        EnsurePageTransitionInfo();
        pPgTransInfo = GetPageTransitionInfo();
        Assert(pPgTransInfo);
        LPCTSTR szTransEnterString = pPgTransInfo->GetTransitionEnterString(fSiteSwitch);
        if(!szTransEnterString)
        {
            if(!fSiteSwitch)
                pPgTransInfo->SetTransitionString(_T("Page-Enter"), _T("revealTrans(duration=4, transition=11"));
            else
                pPgTransInfo->SetTransitionString(_T("Site-Enter"), _T("revealTrans(duration=4, transition=9"));
        }

    }
#endif

    // If there is a transtion string set the state to requested
    if(pPgTransInfo && pPgTransInfo->GetTransitionEnterString(fSiteSwitch) &&
                pPgTransInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_NOTSTARTED)
        pPgTransInfo->SetPageTransitionState(CPageTransitionInfo::PAGETRANS_REQUESTED);


    // No transition info, nothing to do
    if(!HasPageTransitionInfo() )
    {
        TraceTag((tagPageTransitionTrace, "  PGTRANS: No page transition setup for switch to markup %08lX", pMarkupNew, NULL));
        hr = S_FALSE;
        goto Cleanup;
    }

    pCanvasElement = pMarkupOld->GetCanvasElement();
    if(!pCanvasElement)
    {
        // The old markup does not have a client element, bail out
        hr = S_FALSE;
        goto Cleanup;
    }

    // Add the filter behavior to the root of the new markup
    pRootElement = (CElement *)pMarkupNew->Root();
    if(!pRootElement)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // TODO: This is BAD BAD BAD.  The Fancy format is const for a reason.
    pFF = (CFancyFormat *)pRootElement->GetFirstBranch()->GetFancyFormat();
    Assert(pFF);

    // Set the filter string forom the transtion info structure
    pPgTransInfo = GetPageTransitionInfo();
    szFilterStr = (LPTSTR)pPgTransInfo->GetTransitionEnterString(fSiteSwitch);
    if(!szFilterStr || _tcslen(szFilterStr) == NULL)
    {
        // We do not have the right type fo the Transition
        TraceTag((tagPageTransitionTrace, "  PGTRANS: Apply: Do not have the right trans. set. Trans. cleaned up"));
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = MemAllocString( Mt(CFancyFormat_pszFilters), szFilterStr, &(pFF->_pszFilters) );
    if(hr)
    {
        goto Cleanup;
    }
    
    // Set the old markup. This will cause the paint calls to go to the root of 
    //  the old markup
    pPgTransInfo->SetTransitionFromMarkup(pMarkupOld);

    // Add the filter in pFF->_pszFilters to the root element
    hr = THR(pRootElement->AddFilters());

    Assert(pFF->_pszFilters);
    MemFree(pFF->_pszFilters);
    pFF->_pszFilters = NULL;

    if(hr)
    {
        // Something went totally wrong.
        AssertSz(FALSE, "Adding filters to the root for page transitions failed");
        goto Cleanup;
    }

    // Save the new markup in transitioninfo
    pPgTransInfo->SetTransitionToMarkup(pMarkupNew);

    pFS = pRootElement->GetFilterSitePtr();
    if(pFS == NULL)
    {
        hr = E_FAIL;
        AssertSz(FALSE, "Filter Site has not been created in page transition code");
        goto Cleanup;
    }

    // Make sure GetSize is called on the filter right now. If will wait long enough
    // it will eventually be called by the layout code, but we need it right now
    hr = THR(pCanvasElement->GetBoundingSize(size));
    if(hr)
        goto Cleanup;

    if(size.IsZero())
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    hr = THR(pFS->SetSize(&size));
    if(hr)
        goto Cleanup;

     // Invoke apply on the filter number 0 using the old document
    hr = THR(pFS->ApplyFilter(0));
    if(hr)
    {
        AssertSz(FALSE, "Apply Filter failed in page transition code");
        goto Cleanup;
    }

    // Set the state to Applied()
    pPgTransInfo->SetPageTransitionState(CPageTransitionInfo::PAGETRANS_APPLIED);

Cleanup:
    if(pPgTransInfo)
    {
        // Transition from markup will be deleted soon
        pPgTransInfo->SetTransitionFromMarkup(NULL);
        if(hr)
        {
            TraceTag((tagPageTransitionTrace, "  PGTRANS: Error occured in Apply. Trans. cleaned up"));
            CleanupPageTransitions(0);
        }
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::PlayPageTransitions
//
//  Synopsis:   Takes the second snapshot (of the page we are naviagting to) and
//              starts the page transition
//----------------------------------------------------------------------------

HRESULT
CDocument::PlayPageTransitions(BOOL fClenupIfFailed /* = TRUE */)
{
    HRESULT                hr;
    CFilterBehaviorSite  * pFS;
    CElement             * pRootElement;
    CElement             * pCanvasElement;
    CMarkup              * pMarkup = NULL;

    if(!HasPageTransitionInfo() ||  GetPageTransitionInfo()->GetPageTransitionState() 
                        != CPageTransitionInfo::PAGETRANS_APPLIED)
    {
        // We should have called Apply before if we really have a page transition
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(!GetPageTransitionInfo()->GetTransitionFromMarkup());

    pMarkup = GetPageTransitionInfo()->GetTransitionToMarkup();

    TraceTag((tagPageTransitionTrace, "PGTRANS: Play called with markup %08lX.", pMarkup));

    // If we do not have a body or frameste yet we cannot Play
    pCanvasElement = pMarkup->GetCanvasElement();
    if(pCanvasElement == NULL) 
    {
        TraceTag((tagPageTransitionTrace, "  PGTRANS: Not ready to play yet. Markup %08lX.", pMarkup));
        hr = fClenupIfFailed ? S_FALSE : S_OK;
        goto Cleanup;
    }

    pCanvasElement->Invalidate();

    // Filter behavior is on the root element
    pRootElement = (CElement *)pMarkup->Root();

    pFS = pRootElement->GetFilterSitePtr();
    if(pFS == NULL)
    {
        AssertSz(FALSE, "Filter Site has not been created");
        hr = E_FAIL;
        goto Cleanup;
    }

    // make sure there are no pending layout requests that could cause an EnsureView
    // at inapproprite times
    Doc()->GetView()->RemovePendingEnsureViewCalls();
     
    // Start playing the transition
    hr = THR(pFS->PlayFilter(0));
    if(hr)
        goto Cleanup;
    
    // Set the state to played
    GetPageTransitionInfo()->SetPageTransitionState(CPageTransitionInfo::PAGETRANS_PLAYED);

Cleanup:
    if(HasPageTransitions() && (FAILED(hr) || (hr == S_FALSE && fClenupIfFailed && 
            GetPageTransitionInfo()->GetPageTransitionState() != CPageTransitionInfo::PAGETRANS_PLAYED)))
    {
        TraceTag((tagPageTransitionTrace, "  PGTRANS: Play failed. Cleaning up with markup %08lX.", pMarkup));
        CleanupPageTransitions(0);
    }
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//  Member:     CDocument::CleanupPageTransitions
//
//  Synopsis:     We are done with the transition, free the peer and cleanup the 
//              fields on the transition info. We do not touch the transition strings,
//              bacause page-exit strings will be used later
//----------------------------------------------------------------------------

void 
CDocument::CleanupPageTransitions(DWORD_PTR fInPassivate)
{
    CElement              * pRootElement;
    CMarkup               * pMarkup;
    CFilterBehaviorSite   * pFS;

    TraceTag((tagPageTransitionTrace, "PGTRANS: Cleanup Page Transition Request Received"));

    if(HasPageTransitionInfo())
    {
        pMarkup = GetPageTransitionInfo()->GetTransitionToMarkup();
        if(pMarkup)
        {
            pMarkup->Doc()->_fPageTransitionLockPaint = FALSE;
            pRootElement = (CElement *)pMarkup->Root();

            if(pRootElement)
            {
                pFS = pRootElement->GetFilterSitePtr();
                Assert(pFS);

                pFS->RemoveFilterBehavior();
            }
        }

        GetPageTransitionInfo()->Reset();

    }

    if(!fInPassivate)
    {
        // Remove the posted calls, we have already cleaned up ourselvs
        GWKillMethodCall(this, ONCALL_METHOD(CDocument, CleanupPageTransitions, cleanuppagetransitions), 0);
    }
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::PostCleanupPageTansitions
//
//  Synopsis:     Call CleanupPageTransition asynchronously
//----------------------------------------------------------------------------

void 
CDocument::PostCleanupPageTansitions()
{
  TraceTag((tagPageTransitionTrace, "PGTRANS: Posting Cleanup Page Transition Request"));
  THR(GWPostMethodCall(this, ONCALL_METHOD(CDocument, CleanupPageTransitions, cleanuppagetransitions), 0, TRUE, "CDocument::CleanupPageTransitions"));
}


//+---------------------------------------------------------------------------
//  Member:     CDocument::SetUpPageTransitionInfo
//
//  Synopsis:     Save the page transition string for future use. If pchHttpEquiv
//              is not one of the page-transitions, we ignore the information
//----------------------------------------------------------------------------

HRESULT 
CDocument::SetUpPageTransitionInfo(LPCTSTR pchHttpEquiv, LPCTSTR pchContent)
{
    HRESULT           hr;

    TraceTag((tagPageTransitionTrace, "PGTRANS: Setting up page transition for '%ls' to '%ls'", pchHttpEquiv, pchContent));

    hr = THR(EnsurePageTransitionInfo());
    if(hr)
        goto Cleanup;
    GetPageTransitionInfo()->SetTransitionString(pchHttpEquiv, pchContent);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     CPageTransitionInfo::ShiftTransitionStrings
//
//  Synopsis:     This will move the exit strings into the enter string positions,
//              so next navigation automatically uses them
//----------------------------------------------------------------------------

void 
CPageTransitionInfo::ShiftTransitionStrings()
{
    _cstrTransitionStrings[tePageEnter].Set(_cstrTransitionStrings[tePageExit]);
    _cstrTransitionStrings[tePageExit].Free();
    _cstrTransitionStrings[teSiteEnter].Set(_cstrTransitionStrings[teSiteExit]);
    _cstrTransitionStrings[teSiteExit].Free();
}


//+---------------------------------------------------------------------------
//  Member:     CPageTransitionInfo::SetTransitionString
//
//  Synopsis:    First param is transition type that can be "page-enter", "page-exit",
//              "site-enter" or "site-exit". If it is something else it is ignored.
//               The secod parameter is the transition string.
//----------------------------------------------------------------------------

void 
CPageTransitionInfo::SetTransitionString(LPCTSTR szType,  LPCTSTR szStr)
{
    if(!szType || !_tcslen(szType))
        return;

    for(int i = 0; i < teNumEvents; i++)
    {
        if(!_tcsicmp(szType, TransitionEventNames[i]))
        {
            SetTransitionString((TransitionEvent) i, szStr);
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//  Member:     CPageTransitionInfo::GetTransitionEnterString
//
//  Synopsis:    Returns the "enter" string for site (fSiteNavigation is TRUE)
//              or page transiton.
//               Returns NULL if there is no string
//----------------------------------------------------------------------------

LPCTSTR 
CPageTransitionInfo::GetTransitionEnterString(BOOL fSiteNavigation) const
{
    TransitionEvent te;
    LPCTSTR         szStr;

    te = fSiteNavigation ? teSiteEnter : tePageEnter;
    szStr = (LPCTSTR)_cstrTransitionStrings[te];
    if(fSiteNavigation && (!szStr || !_tcslen(szStr)))
    {
        // Not site transition, return the page transition instead
        szStr = (LPCTSTR)_cstrTransitionStrings[tePageEnter];
    }

    if(szStr && !_tcslen(szStr))
        szStr = NULL;

    return szStr;
}


//+---------------------------------------------------------------------------
//  Member:     Reset::Reset
//
//  Synopsis:    Clean up the fields in the transition info structure that 
//              are not needed across page transitions
//----------------------------------------------------------------------------

void 
CPageTransitionInfo::Reset() 
{ 
    Assert(!GetTransitionFromMarkup());
    SetPageTransitionState(PAGETRANS_NOTSTARTED); 
    SetTransitionToMarkup(NULL);
}


void 
CPageTransitionInfo::SetPageTransitionState(PAGE_TRANSITION_STATE eNewState) 
{ 
    _ePageTranstionState = eNewState;
    if(eNewState == CPageTransitionInfo::PAGETRANS_APPLIED)
    {
        Assert(GetTransitionToMarkup());
        GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = TRUE;
    }
    else
    {
        if(GetTransitionToMarkup())
            GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = FALSE;
    }
}

void 
CPageTransitionInfo::SetTransitionToMarkup(CMarkup *pMarkup) 
{ 
    if(GetTransitionToMarkup())
        GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = FALSE;
    else if(pMarkup)
        pMarkup->Doc()->_fPageTransitionLockPaint = FALSE;
    
    _pMarkupTransitionTo = pMarkup; 
}



CPageTransitionInfo::~CPageTransitionInfo()
{
    if(GetTransitionToMarkup())
        GetTransitionToMarkup()->Doc()->_fPageTransitionLockPaint = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\extdl.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

MtDefine(CExternalDownload, Utilities, "CExternalDownload")

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Helper:     UnicodeStringFromAnsiStream
//
//+---------------------------------------------------------------------------

HRESULT
UnicodeStringFromAnsiStream(LPTSTR * ppch, IStream * pStream)
{
    HRESULT     hr;
    STATSTG     statstg;
    ULONG       ulLen;
    ULONG       ulLenRead;
    LPSTR       pchAnsi = NULL;
    LPTSTR      pchEnd;
    ULONG       cch;

    Assert (ppch);

    //
    // get stream length
    //

    hr = THR(pStream->Stat(&statstg, STATFLAG_NONAME));
    if (hr)
        goto Cleanup;

    ulLen = statstg.cbSize.LowPart;
    if (statstg.cbSize.HighPart || 0xFFFFFFFF == ulLen)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // read stream into buffer
    //

    pchAnsi = new char[ulLen + 1];
    if (!pchAnsi)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pStream->Read(pchAnsi, ulLen, &ulLenRead));
    if (hr)
        goto Cleanup;
    if (ulLen != ulLenRead)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // convert ANSI to unicode and normalize CRs
    //

    // get length
    cch = MultiByteToWideChar(CP_ACP, 0, pchAnsi, ulLen, NULL, 0);

    (*ppch) = new TCHAR[cch + 1];
    if (!(*ppch))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // convert now
    Verify(cch == (ULONG) MultiByteToWideChar(CP_ACP, 0, pchAnsi, ulLen, (*ppch), cch));

    pchEnd = (*ppch) + cch;
    cch -= NormalizerChar((*ppch), &pchEnd);
    (*ppch)[cch] = _T('\0');


Cleanup:
    delete pchAnsi;

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CExternalDownload
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::CExternalDownload
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CExternalDownload::CExternalDownload()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::~CExternalDownload
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CExternalDownload::~CExternalDownload()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::Download
//
//  (static)
//
//-------------------------------------------------------------------------

HRESULT
CExternalDownload::Download(
    LPTSTR      pchUrl,
    IDispatch * pdispCallbackFunction,
    CDoc *      pDoc,
    CElement *  pElement)
{
    HRESULT             hr;
    CExternalDownload * pDownload;

    pDownload = new CExternalDownload();
    if (!pDownload)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pDownload->Init(pchUrl, pdispCallbackFunction, pDoc, pElement));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::Download
//
//-------------------------------------------------------------------------

HRESULT
CExternalDownload::Init (
    LPTSTR      pchUrl,
    IDispatch * pdispCallbackFunction,
    CDoc *      pDoc,
    CElement *  pElement)
{
    HRESULT         hr;
    TCHAR   cBuf[pdlUrlLen];
    LPTSTR          pchExpandedUrl = cBuf;
    CBitsCtx *      pBitsCtx = NULL;

    //
    // general init
    //

    _pDoc = pDoc;
    ReplaceInterface (&_pdispCallbackFunction, pdispCallbackFunction);

    //
    // launch download
    //

    hr = THR(_pDoc->ExpandUrl(pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, pElement));
    if (hr)
        goto Cleanup;

    hr = THR(_pDoc->NewDwnCtx(DWNCTX_BITS, pchExpandedUrl, NULL, (CDwnCtx **)&pBitsCtx));
    if (hr)
        goto Cleanup;

    SetBitsCtx(pBitsCtx);


Cleanup:
    if (pBitsCtx)
        pBitsCtx->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExternalDownload::Done
//
//-------------------------------------------------------------------------

HRESULT
CExternalDownload::Done ()
{
    SetBitsCtx(NULL);

    ClearInterface (&_pdispCallbackFunction);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CExternalDownload::SetBitsCtx
//
//+---------------------------------------------------------------------------

void
CExternalDownload::SetBitsCtx(CBitsCtx * pBitsCtx)
{
    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }
    _pBitsCtx = pBitsCtx;

    if (_pBitsCtx)
    {
        _pBitsCtx->AddRef();

        if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
        {
            OnDwnChan(_pBitsCtx);
        }
        else
        {
            _pBitsCtx->SetProgSink(_pDoc->GetProgSink());
            _pBitsCtx->SetCallback(OnDwnChanCallback, this);
            _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CExternalDownload::OnDwnChan
//
//+---------------------------------------------------------------------------

void
CExternalDownload::OnDwnChan(CDwnChan * pDwnChan)
{
    HRESULT     hr;
    IStream *   pStream = NULL;
    LPTSTR      pchString = NULL;

    if (_pBitsCtx->GetState() & DWNLOAD_COMPLETE)
    {
        // If unsecure download, may need to remove lock icon on Doc
        if (_pDoc)
        {
            _pDoc->OnSubDownloadSecFlags(_pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
        }
        
        //
        // data downloaded successfully - get it
        //

        hr = THR(_pBitsCtx->GetStream(&pStream));
        if (hr)
            goto Cleanup;

        hr = THR(UnicodeStringFromAnsiStream(&pchString, pStream));
        if (hr)
            goto Cleanup;
    }
    else
        hr = E_FAIL;

    //
    // invoke the callback function
    //

    if (_pdispCallbackFunction)
    {
        VARIANT     varArg;
        DISPPARAMS  dispparams = {&varArg, NULL, 1, 0};
        EXCEPINFO   excepinfo;
        UINT        nArgErr;

        // if the string was downloaded successfully
        if (S_OK == hr)
        {
            // invoke with VT_BSTR and the string
            V_VT(&varArg) = VT_BSTR;
            hr = THR(FormsAllocString (STRVAL(pchString), &V_BSTR(&varArg)));
            if (hr)
                goto Cleanup;
        }
        else
        {
            // otherwise invoke with VT_NULL
            VariantInit(&varArg);
            V_VT(&varArg) = VT_NULL;
        }

        IGNORE_HR(_pdispCallbackFunction->Invoke(
            DISPID_VALUE, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            DISPATCH_METHOD, &dispparams, NULL, &excepinfo, &nArgErr));
    }

    //
    // finalize
    //

    if (_pBitsCtx && (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_STOPPED | DWNLOAD_ERROR)))
    {
        _pBitsCtx->SetProgSink(NULL);
        
        IGNORE_HR(Done());
        delete this;
    }

    // ! here the instance of class is deallocated from memory, be carefull not to use it

Cleanup:
    delete pchString;

    ReleaseInterface(pStream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\fontinfo.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module FONTINFO.H -- Font information
 *  
 *  Purpose:
 *      Font info, used with caching and fontlinking
 *  
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *
 *  History: <nl>
 *      6/25/98     cthrash     Created
 *
 *  Copyright (c) 1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FONTINFO_HXX_
#define X_FONTINFO_HXX_
#include "fontinfo.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

MtDefine(CFontInfoCache, Utilities, "CFontInfoCache")
MtDefine(CFontInfoCache_pv, CFontInfoCache, "CFontInfoCache::_pv")

// NB (cthrash) Face names are case-sensitive under Unix.

#ifdef UNIX
#define STRCMPFUNC StrCmpC
#else
#define STRCMPFUNC StrCmpIC
#endif

HRESULT
CFontInfoCache::AddInfoToAtomTable( LPCTSTR pchFaceName, LONG *plIndex )
{
    HRESULT hr = S_OK;
    LONG lIndex;
    CFontInfo * pfi;

    // Some users of CFontInfoCache assume that font face length is < LF_FACESIZE
    AssertSz(_tcsclen(pchFaceName) < LF_FACESIZE, "String length > LF_FACESIZE");
    
    for (lIndex = 0; lIndex < Size(); lIndex++)
    {
        pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);
        if (!STRCMPFUNC(pchFaceName, pfi->_cstrFaceName))
            break;
    }
    if (lIndex == Size())
    {
        CFontInfo fi;
        
        //
        // Not found, so add element to array.
        //

        hr = THR(AppendIndirect(&fi));
        if (hr)
            goto Cleanup;

        lIndex = Size() - 1;
        pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);
        pfi->_sids = sidsNotSet;
        pfi->_fFSOnly = FALSE;
        hr = THR(pfi->_cstrFaceName.Set(pchFaceName));
        if (hr)
            goto Cleanup;
    }

    if (plIndex)
    {
        *plIndex = lIndex;
    }

Cleanup:
    RRETURN(hr);

}


HRESULT
CFontInfoCache::GetAtomFromName( LPCTSTR pch, LONG *plIndex )
{
    LONG        lIndex;
    HRESULT     hr = S_OK;
    CFontInfo * pfi;

    for (lIndex = 0; lIndex < Size(); lIndex++)
    {
        pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);

        if(!STRCMPFUNC(pfi->_cstrFaceName, pch))
            break;
    }
    
    if (lIndex == Size())
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (plIndex)
    {
        *plIndex = lIndex;
    }

Cleanup:    
    RRETURN(hr);
}

HRESULT 
CFontInfoCache::GetInfoFromAtom(LONG lIndex, CFontInfo **ppfi)
{
    HRESULT hr = S_OK;
    CFontInfo * pfi;

    AssertSz(lIndex >= 0, "Font index < 0");
    
    if (Size() <= lIndex || lIndex < 0)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    pfi = (CFontInfo *)Deref(sizeof(CFontInfo), lIndex);
    *ppfi = pfi;
    
Cleanup:    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


void
CFontInfoCache::Free()
{
    CFontInfo *  pCFontInfo;
    LONG i;
    
    for (i=0; i<Size(); i++)
    {
        pCFontInfo = (CFontInfo *)Deref(sizeof(CFontInfo), i);
        pCFontInfo->_cstrFaceName.Free();
    }
    DeleteAll();
}


#if DBG==1
void
CFontInfoCache::Dump()
{
    CFontInfo *  pFontInfo;
    LONG i;

    OutputDebugStringA("*** FontInfoCache dump ***\r\n");

    for (i=0; i<Size(); i++)
    {
        TCHAR ach[LF_FACESIZE+20];
        BOOL fNotFirst = FALSE;
        SCRIPT_ID sid;

        pFontInfo = (CFontInfo *)Deref(sizeof(CFontInfo), i);

        wsprintf(ach, TEXT("%2d: "), i+1);

        OutputDebugString(ach);
        OutputDebugString(pFontInfo->_cstrFaceName);

        for (sid=0; sid < sidTridentLim; sid++)
        {
            if (pFontInfo->_sids & ScriptBit(sid))
            {
                OutputDebugStringA(fNotFirst ? ";" : " (");

                fNotFirst = TRUE;

                OutputDebugString(SidName(sid));
            }
        }
        
        OutputDebugStringA(fNotFirst ? ")\r\n" : "\r\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\lstcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       numconv.cxx
//
//  Contents:   Numeral String Conversions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TEXTEDIT_H_
#define X_TEXTEDIT_H_
#include "textedit.h"
#endif

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif

#ifndef X_ELEMENT_H_
#define X_ELEMENT_H_
#include "element.h"
#endif

#ifndef X_LSTCACHE_HXX_
#define X_LSTCACHE_HXX_
#include "lstcache.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member:     Set( wLevel, pLI, e )
//
//  Purpose:    Sets an entry in one of the two index caches.  The index
//              caches are CArray<LONG>'s.  They grow as necessary, but
//              do not ever shrink.
//
//              One important side effect is that the most current CListIndex
//              is stashed in liCurrentIndexValue.  This facilitates the
//              speedy query at render time.
//
//  Arguements: wLevel is a zero-based index into the cache. Note that
//              a level of zero indicates that there are no list containers.
//              lValue is the new value
//              e is either INDEXCACHE_TOP or INDEXCACHE_CURRENT
//
//  Returns:    Nothing.
//
//----------------------------------------------------------------------------

HRESULT
CListCache::Set(
    WORD wLevel,
    struct CListIndex * pLI,
    enum INDEXCACHE e)
{
    HRESULT hr = S_OK;

    // Make space if necessary.

    if (wLevel >= Depth(e))
    {
        if (!_pCache->_aryIndex[e].Add( 1 + wLevel - Depth(e), NULL ))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // Set the value.  Cache the value in liCurrentIndexValue for
    // speedy exectution of GetListIndex().

    *(_pCache->_aryIndex[e].Elem( wLevel )) = liCurrentIndexValue = *pLI;

    // Set the bit field, indicate that the array entry is valid.

    CListCache::ValidateLevel( wLevel, e );

Cleanup:

    RRETURN(hr);
}

HRESULT
CListCache::Instantiate()
{
    Assert( !Instantiated() );

    _pCache = new CListCacheInst;

    if (_pCache)
    {
        PrepareListIndexForRender();
        _pCache->_yScroll = 0;
    }

    return _pCache ? S_OK : E_OUTOFMEMORY;
}

void
CListCache::PrepareListIndexForRender( void )
{
    if (Instantiated())
    {
        ZeroMemory( _pCache->_abIndex[INDEXCACHE_CURRENT], (CListing::MAXLEVELS + 7) >> 3);

        _pCache->_aryIndex[INDEXCACHE_CURRENT].CopyFrom( _pCache->_aryIndex[INDEXCACHE_TOP] );
    }
}

#if DBG==1
void
CListCache::Dump()
{
    if (Instantiated())
    {
        int i;

        for (i=0;i<2;i++)
        {
            enum INDEXCACHE e = i ? INDEXCACHE_CURRENT : INDEXCACHE_TOP;
            char ach[256];
            char * pch = ach;
            WORD wLevel;

            pch += wsprintfA(ach, "%s: ", e ? "cur" : "top");

            for (wLevel = 0; wLevel <= Depth(e); wLevel++)
            {
                if (Valid(wLevel,e))
                {
                    CListIndex LI = GetAt(wLevel, e);

                    pch += wsprintfA(pch, "%3d ", LI.lValue);
                }
                else
                {
                    StrCpyA( pch, "--- " );
                    pch += 4;
                }
            }

            StrCpyA(pch, "\r\n");
            
            OutputDebugStringA(ach);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\mime64.cpp ===
/* mime64 */
/* MIME base64 encoder/decoder by Karl Hahn  hahn@lds.loral.com  3-Aug-94 */
/* Modified into an API by georgep@microsoft.com 8-Jan-96 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MIME64_HXX_
#define X_MIME64_HXX_
#include "mime64.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif


#define INVALID_CHAR (ULONG)-2
#define IGNORE_CHAR (ULONG)-1


static ULONG BinaryFromASCII2( TCHAR alpha )
{
    switch (alpha)
    {
    case _T(' '):
    case _T('\t'):
    case _T('\n'):
    case _T('\r'):
        return(IGNORE_CHAR);

    default:
        if      ( (alpha >= _T('A')) && (alpha <= _T('Z')))
        {
            return (int)(alpha - _T('A'));
        }
        else if ( (alpha >= _T('a')) && (alpha <= _T('z')))
        {
            return 26 + (int)(alpha - _T('a'));
        }
        else if ( (alpha >= _T('0')) && (alpha <= _T('9')))
        {
            return 52 + (int)(alpha - _T('0'));
        }

        return(INVALID_CHAR);

    case _T('+'):
        return 62;

    case _T('/'):
        return 63;
    }
}


struct BinASCIIData
{
    BOOL m_bInited;
    ULONG m_anBinary[256];
} g_cBinASCIIData = { FALSE } ;

static void InitTables()
{
    if (g_cBinASCIIData.m_bInited)
    {
        return;
    }

    for (int i=0; i<256; ++i)
    {
        // Note this is thread-safe, since we always set to the same value
        g_cBinASCIIData.m_anBinary[i] = BinaryFromASCII2((TCHAR)i);
    }

    // Set after initing other values to make thread-safe
    g_cBinASCIIData.m_bInited = TRUE;
}


inline static ULONG BinaryFromASCII( TCHAR alpha )
{
    return(g_cBinASCIIData.m_anBinary[alpha]);
}


HRESULT Mime64Decode(LPCMSTR pStrData, LPSTREAM *ppstm)
{
    *ppstm = NULL;

    InitTables();

    HGLOBAL hGlobal = GlobalAlloc(GPTR, (_tcslen(pStrData)*3)/4 + 2);
    LPBYTE pData = (BYTE *)GlobalLock(hGlobal);

    if (!pData)
    {
        return(E_OUTOFMEMORY);
    }

    int cbData = 0;
    int shift = 0;
    unsigned long accum = 0;

    // This loop will ignore white space, but quit at any other invalid characters
    for ( ; ; ++pStrData)
    {
        unsigned long value = BinaryFromASCII(*pStrData);

        if ( value < 64 )
        {
            accum <<= 6;
            shift += 6;
            accum |= value;

            if ( shift >= 8 )
            {
                shift -= 8;
                value = accum >> shift;
                pData[cbData++] = (BYTE)value & 0xFF;
            }
        }
        else if (IGNORE_CHAR == value)
        {
            continue;
        }
        else
        {
            break;
        }
    }

    IStream *pstm;
    HRESULT hr = THR(CreateStreamOnHGlobal(hGlobal, TRUE, &pstm));
    if(hr)
    {
        RRETURN(hr);
    }

    ULARGE_INTEGER ulibSize;

    ulibSize.HighPart = 0;
    ulibSize.LowPart = cbData;

    pstm->SetSize(ulibSize);
    *ppstm = pstm;

    return(NOERROR);
}


#define CHARS_PER_LINE 60


HRESULT Mime64Encode(LPBYTE pData, UINT cbData, LPTSTR pchData)
{
    static TCHAR const alphabet[] = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

    int shift = 0;
    int save_shift = 0;
    unsigned long accum = 0;
    TCHAR blivit;
    unsigned long value;
    BOOL quit = FALSE;

    while ( ( cbData ) || (shift != 0) )
    {
        if ( ( cbData ) && ( quit == FALSE ) )
        {
            blivit = *pData++;
            --cbData;
        }
        else
        {
            quit = TRUE;
            save_shift = shift;
            blivit = 0;
        }

        if ( (quit == FALSE) || (shift != 0) )
        {
            value = (unsigned long)blivit;
            accum <<= 8;
            shift += 8;
            accum |= value;
        }

        while ( shift >= 6 )
        {
            shift -= 6;
            value = (accum >> shift) & 0x3Fl;

            blivit = alphabet[value];

            *pchData++ = blivit;

            if ( quit != FALSE )
            {
                shift = 0;
            }
        }
    }

    if ( save_shift == 2 )
    {
        *pchData++ = _T('=');
        *pchData++ = _T('=');
    }
    else if ( save_shift == 4 )
    {
        *pchData++ = _T('=');
    }

    *pchData++ = 0;

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\intl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       intl.cxx
//
//  Contents:   Internationalization Support Functions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_MLANG_H_
#define X_MLANG_H_
#include <mlang.h>
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#undef WINCOMMCTRLAPI
#include <commctrl.h>
#endif

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

#ifndef X_WCHDEFS_H
#define X_WCHDEFS_H
#include <wchdefs.h>
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#include <inetreg.h>

//------------------------------------------------------------------------
//
//  Globals
//
//------------------------------------------------------------------------

PMIMECPINFO g_pcpInfo = NULL;
ULONG       g_ccpInfo = 0;
BOOL        g_cpInfoInitialized = FALSE;
TCHAR       g_szMore[32];

const TCHAR s_szCNumCpCache[] = TEXT("CNum_CpCache");
const TCHAR s_szCpCache[] = TEXT("CpCache");
const TCHAR s_szPathInternational[] = TEXT("\\International");

extern BYTE g_bUSPJitState;

#define BREAK_ITEM 20
#define CCPDEFAULT 1 // new spec: the real default is CP_ACP only

ULONG       CCachedCPInfo::_ccpInfo = CCPDEFAULT;
BOOL        CCachedCPInfo::_fCacheLoaded  = FALSE;
BOOL        CCachedCPInfo::_fCacheChanged = FALSE;
LPTSTR      CCachedCPInfo::_pchRegKey = NULL;
CPCACHE     CCachedCPInfo::_CpCache[5] = 
{
    {CP_ACP, 0, 0},
};

MtDefine(MimeCpInfo, PerProcess, "MIMECPINFO")
MtDefine(MimeCpInfoTemp, Locals, "MIMECPINFO_temp")
MtDefine(CpCache, PerProcess, "CpCache")
MtDefine(achKeyForCpCache, PerProcess, "achKeyForCpCache")

static struct {
    CODEPAGE cp;
    BYTE     bGDICharset;
} s_aryCpMap[] = {
    { CP_1252,  ANSI_CHARSET },
    { CP_1252,  SYMBOL_CHARSET },
#if !defined(WINCE)
    { CP_1250,  EASTEUROPE_CHARSET },
    { CP_1251,  RUSSIAN_CHARSET },
    { CP_1253,  GREEK_CHARSET },
    { CP_1254,  TURKISH_CHARSET },
    { CP_1255,  HEBREW_CHARSET },
    { CP_1256,  ARABIC_CHARSET },
    { CP_1257,  BALTIC_CHARSET },
    { CP_1258,  VIETNAMESE_CHARSET },
    { CP_THAI,  THAI_CHARSET },
#endif // !WINCE
    { CP_UTF_8, ANSI_CHARSET },
    { CP_ISO_8859_1, ANSI_CHARSET }
};

//+-----------------------------------------------------------------------
//
//  s_aryInternalCSetInfo
//
//  Note: This list is a small subset of the mlang list, used to avoid
//  loading mlang in certain cases.
//
//  *** There should be at least one entry in this list for each entry
//      in s_aryCpMap so that we can look up the name quickly. ***
//
//  NB (cthrash) List obtained from the following URL, courtesy of ChristW
//  http://iptdweb/intloc/internal/redmond/projects/ie4/charsets.htm
//
//------------------------------------------------------------------------

static const MIMECSETINFO s_aryInternalCSetInfo[] = {
    { CP_1252,  CP_ISO_8859_1,  _T("iso-8859-1") },
    { CP_1252,  CP_1252,  _T("windows-1252") },
    { NATIVE_UNICODE_CODEPAGE, CP_UTF_8, _T("utf-8") },
    { NATIVE_UNICODE_CODEPAGE, CP_UTF_8, _T("unicode-1-1-utf-8") },
    { NATIVE_UNICODE_CODEPAGE, CP_UTF_8, _T("unicode-2-0-utf-8") },
    { CP_1250,  CP_1250,  _T("windows-1250") },     // Eastern European windows
    { CP_1251,  CP_1251,  _T("windows-1251") },     // Cyrillic windows
    { CP_1253,  CP_1253,  _T("windows-1253") },     // Greek windows
    { CP_1254,  CP_1254,  _T("windows-1254") },     // Turkish windows
    { CP_1257,  CP_1257,  _T("windows-1257") },     // Baltic windows
    { CP_1258,  CP_1258,  _T("windows-1258") },     // Vietnamese windows
    { CP_1255,  CP_1255,  _T("windows-1255") },     // Hebrew windows
    { CP_1256,  CP_1256,  _T("windows-1256") },     // Arabic windows
    { CP_THAI,  CP_THAI,  _T("windows-874") },      // Thai Windows
};

//+-----------------------------------------------------------------------
//
//  g_aCPBitmapCPCharsetSid
//
//  CharSet Bitmap mapping to:
//  * codepage
//  * charset
//  * script ID
//
//------------------------------------------------------------------------

const CPBitmapCPCharsetSid g_aCPBitmapCPCharsetSid[g_nCPBitmapCount] = {
    { FS_JOHAB,         CP_1361,        JOHAB_CHARSET,          sidHangul   },
    { FS_CHINESETRAD,   CP_TWN,         CHINESEBIG5_CHARSET,    sidBopomofo },
    { FS_WANSUNG,       CP_KOR_5601,    HANGEUL_CHARSET,        sidHangul   },
    { FS_CHINESESIMP,   CP_CHN_GB,      GB2312_CHARSET,         sidHan      },
    { FS_JISJAPAN,      CP_JPN_SJ,      SHIFTJIS_CHARSET,       sidKana     },
    { FS_THAI,          CP_THAI,        THAI_CHARSET,           sidThai     },
    { FS_VIETNAMESE,    CP_1258,        VIETNAMESE_CHARSET,     sidLatin    },
    { FS_BALTIC,        CP_1257,        BALTIC_CHARSET,         sidLatin    },
    { FS_ARABIC,        CP_1256,        ARABIC_CHARSET,         sidArabic   },
    { FS_HEBREW,        CP_1255,        HEBREW_CHARSET,         sidHebrew   },
    { FS_TURKISH,       CP_1254,        TURKISH_CHARSET,        sidLatin    },
    { FS_GREEK,         CP_1253,        GREEK_CHARSET,          sidGreek    },
    { FS_CYRILLIC,      CP_1251,        RUSSIAN_CHARSET,        sidCyrillic },
    { FS_LATIN2,        CP_1250,        EASTEUROPE_CHARSET,     sidLatin    },
    { FS_LATIN1,        CP_1252,        ANSI_CHARSET,           sidLatin    }
};

const DWORD g_acpbitLang[LANG_NEPALI + 1] =
{
    /* LANG_NEUTRAL     0x00 */ 0,
    /* LANG_ARABIC      0x01 */ FS_ARABIC,
    /* LANG_BULGARIAN   0x02 */ FS_CYRILLIC,
    /* LANG_CATALAN     0x03 */ FS_LATIN1,
    /* LANG_CHINESE     0x04 */ (DWORD)-1,      // need to look at sublang id
    /* LANG_CZECH       0x05 */ FS_LATIN2,
    /* LANG_DANISH      0x06 */ FS_LATIN1,
    /* LANG_GERMAN      0x07 */ FS_LATIN1,
    /* LANG_GREEK       0x08 */ FS_GREEK,
    /* LANG_ENGLISH     0x09 */ FS_LATIN1,
    /* LANG_SPANISH     0x0a */ FS_LATIN1,
    /* LANG_FINNISH     0x0b */ FS_LATIN1,
    /* LANG_FRENCH      0x0c */ FS_LATIN1,
    /* LANG_HEBREW      0x0d */ FS_HEBREW,
    /* LANG_HUNGARIAN   0x0e */ FS_LATIN2,
    /* LANG_ICELANDIC   0x0f */ FS_LATIN1,
    /* LANG_ITALIAN     0x10 */ FS_LATIN1,
    /* LANG_JAPANESE    0x11 */ FS_JISJAPAN,
    /* LANG_KOREAN      0x12 */ (DWORD)-1,      // need to look at sublang id
    /* LANG_DUTCH       0x13 */ FS_LATIN1,
    /* LANG_NORWEGIAN   0x14 */ FS_LATIN1,
    /* LANG_POLISH      0x15 */ FS_LATIN2,
    /* LANG_PORTUGUESE  0x16 */ FS_LATIN1,
    /*                  0x17 */ 0,
    /* LANG_ROMANIAN    0x18 */ FS_LATIN2,
    /* LANG_RUSSIAN     0x19 */ FS_CYRILLIC,
    /* LANG_SERBIAN     0x1a */ (DWORD)-1,      // need to look at sublang id
    /* LANG_SLOVAK      0x1b */ FS_LATIN2,
    /* LANG_ALBANIAN    0x1c */ FS_LATIN2,
    /* LANG_SWEDISH     0x1d */ FS_LATIN1,
    /* LANG_THAI        0x1e */ FS_THAI,
    /* LANG_TURKISH     0x1f */ FS_TURKISH,
    /* LANG_URDU        0x20 */ FS_ARABIC,
    /* LANG_INDONESIAN  0x21 */ FS_LATIN1,
    /* LANG_UKRAINIAN   0x22 */ FS_CYRILLIC,
    /* LANG_BELARUSIAN  0x23 */ FS_CYRILLIC,
    /* LANG_SLOVENIAN   0x24 */ FS_LATIN2,
    /* LANG_ESTONIAN    0x25 */ FS_LATIN1,
    /* LANG_LATVIAN     0x26 */ FS_LATIN1,
    /* LANG_LITHUANIAN  0x27 */ FS_LATIN1,
    /*                  0x28 */ 0,
    /* LANG_FARSI       0x29 */ FS_ARABIC,
    /* LANG_VIETNAMESE  0x2a */ FS_VIETNAMESE,
    /* LANG_ARMENIAN    0x2b */ 0,              // FS_ shouldn't be used
    /* LANG_AZERI       0x2c */ (DWORD)-1,      // need to look at sublang id
    /* LANG_BASQUE      0x2d */ FS_LATIN1,
    /*                  0x2e */ 0,
    /* LANG_MACEDONIAN  0x2f */ FS_CYRILLIC,
    /* LANG_SUTU        0x30 */ FS_LATIN1,
    /*                  0x31 */ 0,
    /*                  0x32 */ 0,
    /*                  0x33 */ 0,
    /*                  0x34 */ 0,
    /*                  0x35 */ 0,
    /* LANG_AFRIKAANS   0x36 */ FS_LATIN1,
    /* LANG_GEORGIAN    0x37 */ 0,              // FS_ shouldn't be used
    /* LANG_FAEROESE    0x38 */ FS_LATIN1,
    /* LANG_HINDI       0x39 */ 0,              // FS_ shouldn't be used
    /*                  0x3a */ 0,
    /*                  0x3b */ 0,
    /*                  0x3c */ 0,
    /*                  0x3d */ 0,
    /* LANG_MALAY       0x3e */ FS_LATIN1,
    /* LANG_KAZAKH      0x3f */ FS_CYRILLIC,
    /*                  0x40 */ 0,
    /* LANG_SWAHILI     0x41 */ FS_LATIN1,
    /*                  0x42 */ 0,
    /* LANG_UZBEK       0x43 */ (DWORD)-1,      // need to look at sublang id
    /* LANG_TATAR       0x44 */ FS_CYRILLIC,
    /* LANG_BENGALI     0x45 */ 0,              // FS_ shouldn't be used
    /* LANG_PUNJABI     0x46 */ 0,              // FS_ shouldn't be used
    /* LANG_GUJARATI    0x47 */ 0,              // FS_ shouldn't be used
    /* LANG_ORIYA       0x48 */ 0,              // FS_ shouldn't be used
    /* LANG_TAMIL       0x49 */ 0,              // FS_ shouldn't be used
    /* LANG_TELUGU      0x4a */ 0,              // FS_ shouldn't be used
    /* LANG_KANNADA     0x4b */ 0,              // FS_ shouldn't be used
    /* LANG_MALAYALAM   0x4c */ 0,              // FS_ shouldn't be used
    /* LANG_ASSAMESE    0x4d */ 0,              // FS_ shouldn't be used
    /* LANG_MARATHI     0x4e */ 0,              // FS_ shouldn't be used
    /* LANG_SANSKRIT    0x4f */ 0,              // FS_ shouldn't be used
    /*                  0x50 */ 0,
    /*                  0x51 */ 0,
    /*                  0x52 */ 0,
    /*                  0x53 */ 0,
    /*                  0x54 */ 0,
    /* LANG_BURMESE     0x55 */ 0,              // FS_ shouldn't be used
    /*                  0x56 */ 0,
    /* LANG_KONKANI     0x57 */ 0,              // FS_ shouldn't be used
    /* LANG_MANIPURI    0x58 */ 0,              // FS_ shouldn't be used
    /* LANG_SINDHI      0x59 */ FS_ARABIC, 
    /*                  0x5a */ 0,
    /*                  0x5b */ 0,
    /*                  0x5c */ 0,
    /*                  0x5d */ 0,
    /*                  0x5e */ 0,
    /*                  0x5f */ 0,
    /* LANG_KASHMIRI    0x60 */ FS_ARABIC,
    /* LANG_NEPALI      0x61 */ 0               // FS_ shouldn't be used
};

//+-----------------------------------------------------------------------
//
//  Function:   IsPrimaryCodePage
//
//  Synopsis:   Return whether the structure in cpinfo represents the
//              'primary' codepage for a language.   Only primary codepages
//              are added, for example, to the language drop down menu.
//
//  Note:       Add special cases to pick primary codepage here.  In most
//              cases the comparison between the uiCodePage and
//              uiFamilyCodePage suffices.  HZ and Korean autodetect are 
//              other cases to consider.
//
//------------------------------------------------------------------------
inline UINT 
GetAutoDetectCp(PMIMECPINFO pcpinfo)
{
    UINT cpAuto;
    switch (pcpinfo->uiFamilyCodePage)
    {
        case CP_JPN_SJ:
           cpAuto = CP_AUTO_JP;
           break;
        default:
           cpAuto = CP_UNDEFINED;
           break;
    }
    return cpAuto;
}

inline BOOL 
IsPrimaryCodePage(MIMECPINFO *pcpinfo)
{
    UINT cpAuto = GetAutoDetectCp(pcpinfo);
    if (cpAuto != CP_UNDEFINED)
        return pcpinfo->uiCodePage == cpAuto;
    else
        return pcpinfo->uiCodePage == pcpinfo->uiFamilyCodePage;
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::RemoveInvalidCp
//  
//  Synopsis:   Clean up the last unsupported cp if it's there.
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::RemoveInvalidCp()
{
    for (UINT iCache = CCPDEFAULT; iCache < _ccpInfo; iCache++)
    {
        if (_CpCache[iCache].ulIdx == (ULONG)-1)
        {
            _ccpInfo--;
            if (_ccpInfo > iCache)
                memmove(&_CpCache[iCache], &_CpCache[iCache+1], sizeof(_CpCache[iCache])*(_ccpInfo-iCache));

            break;
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::InitCpCache
//  
//  Synopsis:   Initialize the cache with default codepages
//              which do not change through the session
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::InitCpCache(OPTIONSETTINGS *pOS, PMIMECPINFO pcp, ULONG ccp)
{
    UINT iCache, iCpInfo;

    
    if  (pcp &&  ccp > 0)
    {
        // load the existing setting from registry one time
        //
        LoadSetting(pOS);
        
        // clean up the last unsupport cp if it's there
        RemoveInvalidCp();
        
        // initialize the current setting including default
        for (iCache= 0; iCache < _ccpInfo; iCache++)
        {
            for (iCpInfo= 0; iCpInfo < ccp; iCpInfo++)
            {
                if ( pcp[iCpInfo].uiCodePage == _CpCache[iCache].cp )
                {
                    _CpCache[iCache].ulIdx = iCpInfo;

                    break;
                }   
            }
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::SaveCodePage
//  
//  Synopsis:   Cache the given codepage along with the index to
//              the given array of MIMECPINFO
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::SaveCodePage(UINT codepage, PMIMECPINFO pcp, ULONG ccp)
{
    int ccpSave = -1;
    BOOL bCached = FALSE;
    UINT i;

    // we'll ignore CP_AUTO, it's a toggle item on our menu
    if (codepage == CP_AUTO)
        return;

    // first check if we already have this cp
    for (i = 0; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cp == codepage)
        {
            ccpSave = i;
            bCached = TRUE;
            break;
        }
    }
    
    // if cache is not full, use the current
    // index to an entry
    if (ccpSave < 0  && _ccpInfo < ARRAY_SIZE(_CpCache))
    {
        ccpSave =  _ccpInfo;
    }

    //  otherwise, popout the least used entry. 
    //  the default codepages always stay
    //  this also decriments the usage count
    int cMinUsed = ARRAY_SIZE(_CpCache);
    UINT iMinUsed = 0; 
    for ( i = CCPDEFAULT; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cUsed > 0)
            _CpCache[i].cUsed--;
        
        if ( ccpSave < 0 && _CpCache[i].cUsed < cMinUsed)
        {
            cMinUsed =  _CpCache[i].cUsed;
            iMinUsed =  i;
        }
    }
    if (ccpSave < 0)
        ccpSave = iMinUsed; 
    
    // set initial usage count, which goes down to 0 if it doesn't get 
    // chosen twice in a row (with current array size)
    _CpCache[ccpSave].cUsed = ARRAY_SIZE(_CpCache)-1;
    
    // find a matching entry from given array of
    // mimecpinfo. Note that we always reassign the index
    // to the global array even when we've already had it 
    // in our cache because the index can be different 
    // after we jit-in a langpack
    //
    if (pcp &&  ccp > 0)
    {
        for (i= 0; i < ccp; i++)
        {
            if ( pcp[i].uiCodePage == codepage )
            {
                _CpCache[ccpSave].cp = codepage;
                _CpCache[ccpSave].ulIdx = i;

                break;
            }   
        }
    }
    
    if (!bCached)
    {
        _fCacheChanged = TRUE;
        if (_ccpInfo < ARRAY_SIZE(_CpCache))

            _ccpInfo++;

        // fallback case for non support codepages
        // we want have it on the tier1 menu but make
        // it disabled
        if ( i >= ccp )
        {
            _CpCache[ccpSave].cp = codepage;
            _CpCache[ccpSave].ulIdx = (ULONG)-1;
        }
    }
}

//------------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::SaveSetting
//  
//  Synopsis:   Writes out the current cache setting to registry
//              [REVIEW]
//              Can this be called from DeinitMultiLanguage?
//              Can we guarantee shlwapi is on memory there?
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::SaveSetting()
{
    UINT iCache;
    DWORD dwcbData, dwcNumCpCache;
    PUINT pcpCache;
    HRESULT hr;
    
    if (!_fCacheLoaded || !_fCacheChanged)
        goto Cleanup;

    RemoveInvalidCp();

    dwcNumCpCache = _ccpInfo-CCPDEFAULT; 
    
    dwcbData = sizeof(_CpCache[0].cp)*dwcNumCpCache; // DWORD for a terminator ?
    if (dwcNumCpCache > 0 && _pchRegKey)
    {
        pcpCache = (PUINT)MemAlloc(Mt(CpCache), dwcbData + sizeof (DWORD));
        if (pcpCache)
        {
            // Save the current num of cache
            hr =  SHSetValue(HKEY_CURRENT_USER, _pchRegKey, 
                       s_szCNumCpCache, REG_DWORD, (void *)&dwcNumCpCache, sizeof(dwcNumCpCache));

            if (hr == ERROR_SUCCESS)
            {
               // Save the current tier1 codepages
               for (iCache = 0; iCache <  dwcNumCpCache; iCache++)
                   pcpCache[iCache] = _CpCache[iCache+CCPDEFAULT].cp;
    
               IGNORE_HR(SHSetValue(HKEY_CURRENT_USER, _pchRegKey, 
                          s_szCpCache, REG_BINARY, (void *)pcpCache, dwcbData));
            }
            MemFree(pcpCache);
        }
    }
Cleanup:
    if (_pchRegKey)
    {
        MemFree(_pchRegKey);
        _pchRegKey = NULL;
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::LoadSetting
//  
//  Synopsis:   Reads cache setting from registry.
//
//------------------------------------------------------------------------

void 
CCachedCPInfo::LoadSetting( OPTIONSETTINGS *pOS )
{
    UINT iCache;
    DWORD dwType, dwcbData, dwcNumCpCache;
    PUINT pcpCache;
    HRESULT hr;

    if (_fCacheLoaded)
        return;

    _ccpInfo = CCPDEFAULT;

    // load registry path from option settings
    if (_pchRegKey == NULL)
    {
        LPTSTR pchKeyRoot = pOS ? pOS->achKeyPath : TSZIEPATH;
        _pchRegKey = (LPTSTR)MemAlloc(Mt(achKeyForCpCache), 
                  (_tcslen(pchKeyRoot)+ARRAY_SIZE(s_szPathInternational)+1) * sizeof(TCHAR));
        if (!_pchRegKey)
            goto loaddefault;

        _tcscpy(_pchRegKey, pchKeyRoot);
        _tcscat(_pchRegKey, s_szPathInternational);
    }

    // first see if we have any entry 
    dwcbData = sizeof (dwcNumCpCache);
    hr =  SHGetValue(HKEY_CURRENT_USER, _pchRegKey, 
                   s_szCNumCpCache, &dwType, (void *)&dwcNumCpCache, &dwcbData);

    if (hr == ERROR_SUCCESS && dwcNumCpCache > 0)
    {
        if (dwcNumCpCache > ARRAY_SIZE(_CpCache)-CCPDEFAULT)
            dwcNumCpCache = ARRAY_SIZE(_CpCache)-CCPDEFAULT;
    
        dwcbData = sizeof(_CpCache[0].cp)*dwcNumCpCache; // DWORD for a terminator 
        pcpCache = (PUINT)MemAlloc(Mt(CpCache), dwcbData + sizeof (DWORD));
        if (pcpCache)
        {
            hr = THR(SHGetValue(HKEY_CURRENT_USER, _pchRegKey, 
                s_szCpCache, &dwType, (void *)pcpCache, &dwcbData));
                
            if (hr == ERROR_SUCCESS && dwType == REG_BINARY)
            {
                PUINT p = pcpCache;
                for (iCache=CCPDEFAULT; iCache < dwcNumCpCache+CCPDEFAULT; iCache++) 
                {
                    _CpCache[iCache].cp = *p;
                    _CpCache[iCache].cUsed = ARRAY_SIZE(_CpCache)-1;
                    p++;
                }
                _ccpInfo += dwcNumCpCache;
            }
            
            MemFree(pcpCache);
        }
    }
    
    // Load default entries that stay regardless of menu selection
    // Add ACP to the default entry of the cache
    //
loaddefault:
    MIMECPINFO mimeCpInfo;
    UINT       cpAuto;
    for (iCache = 0; iCache < CCPDEFAULT; iCache++)
    {
        _CpCache[iCache].cUsed = ARRAY_SIZE(_CpCache)-1;
        if (_CpCache[iCache].cp == CP_ACP )
            _CpCache[iCache].cp = GetACP();

        IGNORE_HR(QuickMimeGetCodePageInfo( _CpCache[iCache].cp, &mimeCpInfo ));
        
        cpAuto = GetAutoDetectCp(&mimeCpInfo);
        _CpCache[iCache].cp = (cpAuto != CP_UNDEFINED ? cpAuto : _CpCache[iCache].cp);
    }

    // this gets set even if we fail to read reg setting.
    _fCacheLoaded = TRUE;
}

//+-----------------------------------------------------------------------
//
//  Function:   EnsureCodePageInfo
//
//  Synopsis:   Hook up to mlang.  Note: it is not an error condition to
//              get back no codepage info structures from mlang.
//
//  IE5 JIT langpack support:
//              Now user can install fonts and nls files on the fly 
//              without restarting the session.
//              This means we always have to get real information
//              as to which codepage is valid and not.
//
//------------------------------------------------------------------------

HRESULT
EnsureCodePageInfo( BOOL fForceRefresh )
{
    if (g_cpInfoInitialized && !fForceRefresh)
        return S_OK;

    HRESULT         hr;
    UINT            cNum = 0;
    IEnumCodePage * pEnumCodePage = NULL;
    PMIMECPINFO     pcpInfo = NULL;
    ULONG           ccpInfo = 0;

    hr = THR(mlang().EnumCodePages(MIMECONTF_BROWSER, &pEnumCodePage));
    if (S_OK != hr)
        goto Cleanup;

    hr = THR(mlang().GetNumberOfCodePageInfo(&cNum));
    if (S_OK != hr)
        goto Cleanup;

    if (cNum > 0)
    {
        pcpInfo = (PMIMECPINFO)MemAlloc(Mt(MimeCpInfo), sizeof(MIMECPINFO) * (cNum));
        if (!pcpInfo)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = THR(pEnumCodePage->Next(cNum, pcpInfo, &ccpInfo));
        if (hr)
            goto Cleanup;

        if (ccpInfo > 0)
        {
            IGNORE_HR(MemRealloc(Mt(MimeCpInfo), (void **)&pcpInfo, sizeof(MIMECPINFO) * (ccpInfo)));
        }
        else
        {
            MemFree(pcpInfo);
            pcpInfo = NULL;
        }
    }

Cleanup:
    {
        LOCK_GLOBALS;

        if (S_OK == hr)
        {
            if (g_pcpInfo)
            {
                MemFree(g_pcpInfo);
            }

            g_pcpInfo = pcpInfo;
            g_ccpInfo = ccpInfo;
        }
        else if (pcpInfo)
        {
            MemFree(pcpInfo);
            pcpInfo = NULL;
        }

        // If any part of the initialization fails, we do not want to keep
        // returning this function, unless, of course, fForceRefresh is true.

        g_cpInfoInitialized = TRUE;
    }

    ReleaseInterface(pEnumCodePage);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Function:   DeinitMultiLanguage
//
//  Synopsis:   Detach from mlang.  Called from DllAllThreadsDetach.
//              Globals are locked during the call.
//
//------------------------------------------------------------------------

void
DeinitMultiLanguage()
{
    CCachedCPInfo::SaveSetting(); // [review] can this be dengerous? [yutakan]
    MemFree(g_pcpInfo);
    g_cpInfoInitialized = FALSE;
    g_pcpInfo = NULL;
    g_ccpInfo = 0;

    mlang().Unload();
}

//+-----------------------------------------------------------------------
//
//  Function:   QuickMimeGetCodePageInfo
//
//  Synopsis:   This function gets cp info from mlang, but caches some
//              values to avoid loading mlang unless necessary.
//
//------------------------------------------------------------------------

HRESULT
QuickMimeGetCodePageInfo(CODEPAGE cp, PMIMECPINFO pMimeCpInfo)
{
    HRESULT hr = S_OK;
    static MIMECPINFO s_mimeCpInfoBlank = {
        0, 0, 0, _T(""), _T(""), _T(""), _T(""),
        _T("Courier New"), _T("Arial"), DEFAULT_CHARSET
    };

    // If mlang is not loaded and it is acceptable to use our defaults,
    //  try to avoid loading it by searching through our internal
    //  cache.
    for (int n = 0; n < ARRAY_SIZE(s_aryCpMap); ++n)
    {
        if (cp == s_aryCpMap[n].cp)
        {
            // Search for the name in the cset array
            for (int j = 0; j < ARRAY_SIZE(s_aryInternalCSetInfo); ++j)
            {
                if (cp == s_aryInternalCSetInfo[j].uiInternetEncoding)
                {
                    memcpy(pMimeCpInfo, &s_mimeCpInfoBlank, sizeof(MIMECPINFO));
                    pMimeCpInfo->uiCodePage = pMimeCpInfo->uiFamilyCodePage = s_aryCpMap[n].cp;
                    pMimeCpInfo->bGDICharset = s_aryCpMap[n].bGDICharset;
                    _tcscpy(pMimeCpInfo->wszWebCharset, s_aryInternalCSetInfo[j].wszCharset);
                    goto Cleanup;
                }
            }
        }
    }

    hr = THR(mlang().GetCodePageInfo(cp, MLGetUILanguage(), pMimeCpInfo));
    if (S_OK != hr)
        goto Error;

Cleanup:
    return hr;

Error:
    // Could not load mlang, fill in with a default but return the error
    memcpy(pMimeCpInfo, &s_mimeCpInfoBlank, sizeof(MIMECPINFO));
    goto Cleanup;
}


#ifndef NO_MULTILANG
//+-----------------------------------------------------------------------
//
//  Function:   QuickMimeGetCharsetInfo
//
//  Synopsis:   This function gets charset info from mlang, but caches some
//              values to avoid loading mlang unless necessary.
//
//------------------------------------------------------------------------

HRESULT
QuickMimeGetCharsetInfo(LPCTSTR lpszCharset, PMIMECSETINFO pMimeCSetInfo)
{

    // If mlang is not loaded and it is acceptable to use our defaults,
    //  try to avoid loading it by searching through our internal
    //  cache.
    for (int n = 0; n < ARRAY_SIZE(s_aryInternalCSetInfo); ++n)
    {
        if (_tcsicmp((TCHAR*)lpszCharset, s_aryInternalCSetInfo[n].wszCharset) == 0)
        {
            *pMimeCSetInfo = s_aryInternalCSetInfo[n];
            return S_OK;
        }
    }

    HRESULT hr = THR(mlang().GetCharsetInfo((LPTSTR)lpszCharset, pMimeCSetInfo));
    return hr;
}
#endif // !NO_MULTILANG

//+-----------------------------------------------------------------------
//
//  Function:   GetCodePageFromMlangString
//
//  Synopsis:   Return a codepage id from an mlang codepage string.
//
//------------------------------------------------------------------------

HRESULT
GetCodePageFromMlangString(LPCTSTR pszMlangString, CODEPAGE* pCodePage)
{
#ifdef NO_MULTILANG
    return E_NOTIMPL;
#else
    HRESULT hr;
    MIMECSETINFO mimeCharsetInfo;

    hr = QuickMimeGetCharsetInfo(pszMlangString, &mimeCharsetInfo);
    if (hr)
    {
        hr = E_INVALIDARG;
        *pCodePage = CP_UNDEFINED;
    }
    else
    {
        *pCodePage = mimeCharsetInfo.uiInternetEncoding;
    }

    return hr;
#endif
}

//+-----------------------------------------------------------------------
//
//  Function:   GetMlangStringFromCodePage
//
//  Synopsis:   Return an mlang codepage string from a codepage id.
//
//------------------------------------------------------------------------

HRESULT
GetMlangStringFromCodePage(CODEPAGE codepage, LPTSTR pMlangStringRet,
                           size_t cchMlangString)
{
    HRESULT    hr;
    MIMECPINFO mimeCpInfo;
    TCHAR*     pCpString = _T("<undefined-cp>");
    size_t     cchCopy;

    Assert(codepage != CP_ACP);

    hr = QuickMimeGetCodePageInfo(codepage, &mimeCpInfo);
    if (hr == S_OK)
    {
        pCpString = mimeCpInfo.wszWebCharset;
    }

    cchCopy = min(cchMlangString-1, _tcslen(pCpString));
    _tcsncpy(pMlangStringRet, pCpString, cchCopy);
    pMlangStringRet[cchCopy] = 0;

    return hr;
}

#ifndef NO_MULTILANG
//+-----------------------------------------------------------------------
//
//  Function:   CheckEncodingMenu
//
//  Synopsis:   Given a mime charset menu, check the specified codepage.
//
//------------------------------------------------------------------------

void
CheckEncodingMenu(CODEPAGE codepage, HMENU hMenu, BOOL fAutoMode)
{
    ULONG i;

    IGNORE_HR(EnsureCodePageInfo(FALSE));

    Assert(codepage != CP_ACP);

    if (1 < g_ccpInfo)
    {
        MIMECPINFO mimeCpInfo;

        LOCK_GLOBALS;
        
        IGNORE_HR(QuickMimeGetCodePageInfo( codepage, &mimeCpInfo ));
        
        // find index to our cache
        for(i = 0; i < CCachedCPInfo::GetCcp() && codepage != CCachedCPInfo::GetCodePage(i); i++)
            ;

        if (i >= CCachedCPInfo::GetCcp())
        {
            // the codepage is not on the tier1 menu
            // put a button to the tier2 menu if possible
            LOCK_GLOBALS;
            for (i = 0;  i < g_ccpInfo;  i++)
            {
                if (g_pcpInfo[i].uiCodePage == codepage)
                {
                    // IDM_MIMECSET__LAST__-1 is now temporarily
                    // assigned to CP_AUTO
                    CheckMenuRadioItem(hMenu, 
                                       IDM_MIMECSET__FIRST__, IDM_MIMECSET__LAST__-1, 
                                       i + IDM_MIMECSET__FIRST__,
                                       MF_BYCOMMAND);
                    break;
                }
            }
        }
        else
        {
#ifndef UNIX // Unix doesn't support AutoDetect
            UINT uiPos = CCachedCPInfo::GetCcp() + 2 - 1 ; 
#else
            UINT uiPos = CCachedCPInfo::GetCcp() - 1 ; 
#endif
            ULONG uMenuId = CCachedCPInfo::GetMenuIdx(i);
            UINT uidItem;

            // the menuid is -1 if this is the one not available for browser
            // we have to put a radiobutton by position for that case.
            // 
            uMenuId = uMenuId == (ULONG)-1 ? uMenuId : uMenuId + IDM_MIMECSET__FIRST__;
           
#ifndef UNIX // Unix uiPos == 0 isn't AutoDetect 
            while (uiPos > 0)
#else
            while (uiPos >= 0)
#endif
            {
                // On Win95, GetMenuItemID can't return (ULONG)-1
                // so we use lower word only
                uidItem = GetMenuItemID(hMenu, uiPos);
                if ( LOWORD(uidItem) == LOWORD(uMenuId) )
                {
                    CheckMenuRadioItem(
                        hMenu, 
#ifndef UNIX // No AutoDetect for UNIX
                        1, CCachedCPInfo::GetCcp() + 2 - 1, // +2 for cp_auto -1 for 0 based
#else
                        0, CCachedCPInfo::GetCcp() - 1, // +2 for cp_auto -1 for 0 based
#endif
                        uiPos,
                        MF_BYPOSITION );

                    break; 
                }
                uiPos--;
            }
        }
    }
#ifndef UNIX // Unix doesn't support AutoDetect
    // then lastly, we put check mark for the auto detect mode
    // the AutoDetect item is always at pos 0
    CheckMenuItem(hMenu, 0, fAutoMode?
                            (MF_BYPOSITION|MF_CHECKED) :
                            (MF_BYPOSITION|MF_UNCHECKED) );
#endif
}

//+-----------------------------------------------------------------------
//
//  Function:   CheckFontMenu
//
//  Synopsis:   Given a font menu, check the specified font size.
//
//------------------------------------------------------------------------

void
CheckFontMenu(short sFontSize, HMENU hMenu)
{
    CheckMenuRadioItem(hMenu, IDM_BASELINEFONT1, IDM_BASELINEFONT5, 
                       sFontSize - BASELINEFONTMIN + IDM_BASELINEFONT1, MF_BYCOMMAND);
}

//+-----------------------------------------------------------------------
//
//  Function:   CheckMenuCharSet
//
//  Synopsis:   Assuming hMenu has both encoding/font size
//              this puts checks marks on it based on the given
//              codepage and font size
//
//------------------------------------------------------------------------

void 
CheckMenuMimeCharSet(CODEPAGE codepage, short sFontSize, HMENU hMenuLang, BOOL fAutoMode)
{
    CheckEncodingMenu(codepage, hMenuLang, fAutoMode);
    CheckFontMenu(sFontSize, hMenuLang);
}
#endif

//+-----------------------------------------------------------------------
//
//  Function:   CreateMimeCSetMenu
//
//  Synopsis:   Create the mime charset menu.  Can return an empty menu.
//
//------------------------------------------------------------------------

HMENU
CreateMimeCSetMenu(OPTIONSETTINGS *pOS, CODEPAGE cp)
{
    BOOL fBroken = FALSE;
    
    HMENU hMenu = CreatePopupMenu();

    IGNORE_HR(EnsureCodePageInfo(TRUE));

    if (hMenu && 0 < g_ccpInfo)
    {
        MIMECPINFO mimeCpInfo;

        Assert(g_pcpInfo);
        LOCK_GLOBALS;
       
#ifndef UNIX // Unix doesn't have Auto Detect 
        // always add the 'Auto Detect' entry
        // get the description from mlang
        // the id needs to be special - IDM_MIMECSET__LAST__
        // is fairly unique because there are 90 codepages to
        // have between FIRST and LAST
        IGNORE_HR(QuickMimeGetCodePageInfo( CP_AUTO, &mimeCpInfo ));
        AppendMenu(hMenu, MF_ENABLED, IDM_MIMECSET__LAST__, mimeCpInfo.wszDescription);
        
        // Also add a separator
        AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
        // add the tier 1 entries to the first
        // level popup menu
#endif // UNIX

        ULONG i;
        ULONG iMenuIdx;

        CCachedCPInfo::InitCpCache(pOS, g_pcpInfo, g_ccpInfo);
        
        // Cache an autodetect codepage if it's available
        // for the given codepage
        // note that we have "AutoSelect"(CP_AUTO) for character set 
        // detection across whole codepages, and at the same time
        // "AutoDetect" within A codepage, such as JPAUTO (50932)
        // CP_AUTO is added to the menu as toggle item, so
        // we'll ignore it at SaveCodePage(), should it come down here
        //
        IGNORE_HR(QuickMimeGetCodePageInfo( cp, &mimeCpInfo ));
        UINT cpAuto = GetAutoDetectCp(&mimeCpInfo);
        
        if (cpAuto != CP_UNDEFINED)
            CCachedCPInfo::SaveCodePage(cpAuto, g_pcpInfo, g_ccpInfo);

        CCachedCPInfo::SaveCodePage(cp, g_pcpInfo, g_ccpInfo);

        for(i = 0; i < CCachedCPInfo::GetCcp(); i++)
        {
            iMenuIdx = CCachedCPInfo::GetMenuIdx(i);

            if (iMenuIdx == (ULONG)-1)
            {
                // the codepage is either not supported or 
                // not for browser. We need to add it to the
                // tier1 menu and make it disabled
                if (SUCCEEDED(QuickMimeGetCodePageInfo(CCachedCPInfo::GetCodePage(i), &mimeCpInfo)))
                {
                    AppendMenu(hMenu, MF_GRAYED, iMenuIdx, // == -1
                               mimeCpInfo.wszDescription);
                }
            }
            else
            {
                AppendMenu(hMenu, MF_ENABLED, iMenuIdx+IDM_MIMECSET__FIRST__,
                    g_pcpInfo[iMenuIdx].wszDescription);

                // mark the cp entry so we can skip it for submenu
                // this assumes we'd never use the MSB for MIMECONTF
                g_pcpInfo[iMenuIdx].dwFlags |= 0x80000000;
            }
        } 
        
        // add the submenu for the rest of encodings
        HMENU hSubMenu = CreatePopupMenu();
        UINT  uiLastFamilyCp = 0;
        if (hSubMenu)
        {
            // calculate the max # of menuitem we can show in one monitor
            unsigned int iMenuY, iScrY, iBreakItem, iItemAdded = 0;
            NONCLIENTMETRICSA ncma;
            HRESULT hr;
            
            if (g_dwPlatformVersion < 0x050000)
            {
                // Use systemparametersinfoA so it won't fail on w95
                // TODO (IE6 track bug 19) shlwapi W wrap should support this
                ncma.cbSize = sizeof(ncma);
                SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncma), &ncma, FALSE);
                iMenuY = ncma.lfMenuFont.lfHeight > 0 ? 
                         ncma.lfMenuFont.lfHeight: -ncma.lfMenuFont.lfHeight;
                iScrY  = GetSystemMetrics(SM_CYSCREEN);

                if ( iScrY > 0 && iMenuY > 0) 
                    iBreakItem = (iScrY + iMenuY - 1) / iMenuY; // round up
                else
                    iBreakItem = BREAK_ITEM; // a fallback
            }
            else // NT5 has nice auto menu scroll so let's not break
                iBreakItem = (UINT)-1;
                
            for (i = 0;  i < g_ccpInfo;  i++)
            {
                // skip codepages that are on teir1 menu
                // skip also Auto Select
                if (!(g_pcpInfo[i].dwFlags & 0x80000000)
                    && g_pcpInfo[i].uiCodePage != CP_AUTO
#ifdef UNIX // filter out Thai and Vietnamese
                    && g_pcpInfo[i].uiCodePage != CP_THAI
                    && g_pcpInfo[i].uiCodePage != CP_1258 // Vietnamese
                    && g_pcpInfo[i].uiCodePage != CP_1257 // Baltic
                    && g_pcpInfo[i].uiCodePage != CP_1256 // Arabic
#endif
                    )
                {
                    // if the codepage is not yet installed, 
                    // we show the primary codepage only
                    //
                    // we only see if the primary cp is valid, 
                    // then make the entire family shown without checking 
                    // if they're valid. this is for the case that just
                    // part of langpack (nls/font) is installed.
                    // this may need some more tweak after usability check

                    // Actually now we've decided to hide the menu items if
                    // the encodings are neither valid or installable
                    //

                    if (S_OK != THR(mlang().IsCodePageInstallable(g_pcpInfo[i].uiCodePage)))
                        continue;
                    
                    // we need to call the slow version that invokes mlang
                    // because quick version wouldn't set valid flags.
                    hr = THR(mlang().GetCodePageInfo(g_pcpInfo[i].uiFamilyCodePage, MLGetUILanguage(), &mimeCpInfo));
                    
                    if (   S_OK == hr
                        && (mimeCpInfo.dwFlags & MIMECONTF_VALID)
                        || IsPrimaryCodePage(g_pcpInfo+i))
                    {
                        UINT uiFlags = MF_ENABLED;

                        TCHAR wszDescription[ARRAY_SIZE(g_pcpInfo[0].wszDescription)];
                        _tcscpy(wszDescription, g_pcpInfo[i].wszDescription);

                        if (!(g_pcpInfo[i].dwFlags & MIMECONTF_VALID))
                        {
                            if (IsPrimaryCodePage(g_pcpInfo+i))
                            {
                                // this codepage will be added as a place holder
                                // let's rip out the detail to make it general
                                LPTSTR psz = StrChr(wszDescription, TEXT('('));
                                if (psz)
                                    *psz = TEXT('\0');        
                            }
                            else if (g_pcpInfo[i].uiCodePage == CP_GB_18030)
                            {
                                // Hide GB 18030 if it is not installed
                                continue;
                            }
                        }

                        if (uiLastFamilyCp > 0 
                        && uiLastFamilyCp != g_pcpInfo[i].uiFamilyCodePage)
                        {
                            // add separater between different family unless
                            // we will be adding the menu bar break
                            if(iItemAdded < iBreakItem || fBroken)
                            {
                                AppendMenu(hSubMenu, MF_SEPARATOR, 0, 0);
                                iItemAdded++;
                            }
                            else
                            {
                                // This menu gets really long. Let's break it so all
                                // fit on the screen
                                uiFlags |= MF_MENUBARBREAK;
                                fBroken = TRUE;
                            }
                        }
                        
                        AppendMenu(hSubMenu, 
                                   uiFlags, 
                                   i+IDM_MIMECSET__FIRST__,
                                   wszDescription);
                        iItemAdded++;

                        // save the family of added codepage
                        uiLastFamilyCp = g_pcpInfo[i].uiFamilyCodePage;
                    }
                }
                else
                    g_pcpInfo[i].dwFlags &= 0x7FFFFFFF;

            }

            // add this submenu to the last of tier1 menu
            if (!g_szMore[0])
            {
                Verify(LoadString( GetResourceHInst(), 
                                   RES_STRING_ENCODING_MORE,
                                   g_szMore,
                                   ARRAY_SIZE(g_szMore)));
            }
            if (GetMenuItemCount(hSubMenu) > 0)
            {
                AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hSubMenu, g_szMore);
            }
            else
            {
                DestroyMenu(hSubMenu);
            }
        }
    }
    return hMenu;
}

#ifndef NO_MULTILANG
//+-----------------------------------------------------------------------
//
//  Function:   CreateDocDirMenu
//
//  Synopsis:   Add document direction menu into mime charset menu.
//
//------------------------------------------------------------------------

HMENU
CreateDocDirMenu(BOOL fDocRTL, HMENU hMenuTarget)
{
    HMENU hMenu;
    hMenu = TFAIL_NOTRACE(0, LoadMenu(
                          GetResourceHInst(),
                          MAKEINTRESOURCE(IDR_HTMLFORM_DOCDIR)));

    if(hMenu != NULL)
    {

        int nItem = GetMenuItemCount(hMenu);

        if (0 < nItem)
        {
            if(hMenuTarget)
            {
                // append the menu at the bottom
                InsertMenu(hMenuTarget, 0xFFFFFFFF, MF_SEPARATOR | MF_BYPOSITION, 0, 0);
            }

            int nCheckItem= 0;

            for (int i = 0; i < nItem; i++)
            {
                UINT uiID;
                UINT uChecked = MF_BYCOMMAND | MF_ENABLED;
                TCHAR szBuf[MAX_MIMECP_NAME];

                uiID = GetMenuItemID(hMenu, i);
                GetMenuString(hMenu, i, szBuf, ARRAY_SIZE(szBuf), MF_BYPOSITION);

                if((uiID == IDM_DIRRTL) ^ (!fDocRTL))  
                    nCheckItem = i;
     
                if(hMenuTarget)
                {
                    InsertMenu(hMenuTarget, 0xFFFFFFFF, uChecked | MF_STRING, uiID, szBuf);
                }
            }
            if(hMenuTarget)
            {
                CheckMenuRadioItem(hMenuTarget, IDM_DIRLTR, IDM_DIRRTL, 
                                   IDM_DIRLTR + nCheckItem, MF_BYCOMMAND);
            }
            else
            {
                CheckMenuRadioItem(hMenu, IDM_DIRLTR, IDM_DIRRTL, 
                                   IDM_DIRLTR + nCheckItem, MF_BYCOMMAND);
            }
        }
    }
    if(hMenuTarget)
    {
        if(hMenu)
            DestroyMenu(hMenu);
        return NULL;
    }
    else
    {
        return hMenu;
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   AddFontSizeMenu
//
//  Synopsis:   Add font size menu into mime charset menu.
//
//------------------------------------------------------------------------

void
AddFontSizeMenu(HMENU hMenu)
{
    if (NULL != hMenu)
    {
        HMENU hMenuRes = TFAIL_NOTRACE(0, LoadMenu(
                GetResourceHInst(),
                MAKEINTRESOURCE(IDR_HTMLFORM_MENURUN)));

        if (NULL != hMenuRes)
        {
            HMENU hMenuView = GetSubMenu(hMenuRes, 1);
            HMENU hMenuFont = GetSubMenu(hMenuView, 3);
            int nItem = GetMenuItemCount(hMenuFont);

            if (0 < nItem)
            {
                for (int i = nItem - 1; i >= 0; i--)
                {
                    UINT uiID;
                    TCHAR szBuf[MAX_MIMECP_NAME];

                    uiID = GetMenuItemID(hMenuFont, i);
                    GetMenuString(hMenuFont, i, szBuf, ARRAY_SIZE(szBuf), MF_BYPOSITION);
                    InsertMenu(hMenu, 0, MF_STRING | MF_BYPOSITION, uiID, szBuf);
                }
            }
            DestroyMenu(hMenuRes);
        }
    }
}

//+-----------------------------------------------------------------------
//
//  Function:   CreateFontSizeMenu
//
//  Synopsis:   Creates font size menu.
//
//------------------------------------------------------------------------

HMENU
CreateFontSizeMenu()
{
    HMENU hMenuFontSize = CreatePopupMenu();
    
    AddFontSizeMenu(hMenuFontSize);
    return hMenuFontSize;
}

//+-----------------------------------------------------------------------
//
//  Function:   ShowMimeCSetMenu
//
//  Synopsis:   Display the mime charset menu.
//
//------------------------------------------------------------------------

HRESULT
ShowMimeCSetMenu(OPTIONSETTINGS *pOS, int * pnIdm, CODEPAGE codepage, LPARAM lParam, BOOL fDocRTL, BOOL fAutoMode)
{
    HMENU hMenuEncoding = NULL;
    HRESULT hr = E_FAIL;

    Assert(NULL != pnIdm);

    hMenuEncoding = CreateMimeCSetMenu(pOS, codepage);
    if (NULL != hMenuEncoding)
    {
        POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

        CheckEncodingMenu(codepage, hMenuEncoding, fAutoMode);

        GetOrAppendDocDirMenu(codepage, fDocRTL, hMenuEncoding);

        hr = FormsTrackPopupMenu(hMenuEncoding, TPM_LEFTALIGN, pt.x, pt.y, NULL, pnIdm);
        DestroyMenu(hMenuEncoding);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:   ShowFontSizeMenu
//
//  Synopsis:   Display the font size menu.
//
//------------------------------------------------------------------------

HRESULT
ShowFontSizeMenu(int * pnIdm, short sFontSize, LPARAM lParam)
{
    HMENU hMenuFont = NULL;
    HRESULT hr = E_FAIL;

    Assert(NULL != pnIdm);

    hMenuFont = CreateFontSizeMenu();
    if (NULL != hMenuFont)
    {
        POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

        CheckFontMenu(sFontSize, hMenuFont);

        hr = FormsTrackPopupMenu(hMenuFont, TPM_LEFTALIGN, pt.x, pt.y, NULL, pnIdm);

        DestroyMenu(hMenuFont);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:   GetEncodingMenu
//
//  Synopsis:   Return the mime charset menu handle.
//
//------------------------------------------------------------------------

HMENU
GetEncodingMenu(OPTIONSETTINGS *pOS, CODEPAGE codepage, BOOL fDocRTL, BOOL fAutoMode)
{
    HMENU hMenuEncoding = CreateMimeCSetMenu(pOS, codepage);
    if (NULL != hMenuEncoding)
    {
        CheckEncodingMenu(codepage, hMenuEncoding, fAutoMode);

        GetOrAppendDocDirMenu(codepage, fDocRTL, hMenuEncoding);
    }
    
    return hMenuEncoding;
}

//+-----------------------------------------------------------------------
//
//  Function:   GetOrAppendDocDirMenu
//
//  Synopsis:   Return the document direction menu handle.
//              or append it to a given menu handle.
//
//------------------------------------------------------------------------

HMENU
GetOrAppendDocDirMenu(CODEPAGE codepage, BOOL fDocRTL, HMENU hMenuTarget)
{
    HMENU hMenuDocDir = NULL;

    // put up the document dir menu only if it is likely to have
    // right-to-left
    if(g_fBidiSupport || IsRTLCodepage(codepage))
    {
        hMenuDocDir = CreateDocDirMenu(fDocRTL, hMenuTarget);
    }
    return  hMenuDocDir;
}

//+-----------------------------------------------------------------------
//
//  Function:   GetFontSizeMenu
//
//  Synopsis:   Retrun the FontSize menu handle
//
//------------------------------------------------------------------------

HMENU
GetFontSizeMenu(short sFontSize)
{
    HMENU hMenuFontSize = CreateFontSizeMenu();
    if (NULL != hMenuFontSize)
    {
        CheckFontMenu(sFontSize, hMenuFontSize);
    }
    
    return hMenuFontSize;
}
#endif // ndef NO_MULTILANG

//+-----------------------------------------------------------------------
//
//  Function:   GetCodePageFromMenuID
//
//  Synopsis:   Given a menu id return the associated codepage.
//
//------------------------------------------------------------------------

CODEPAGE
GetCodePageFromMenuID(int nIdm)
{
    UINT idx = nIdm - IDM_MIMECSET__FIRST__;

    IGNORE_HR(EnsureCodePageInfo(FALSE));

    LOCK_GLOBALS;

    if (NULL != g_pcpInfo && idx < g_ccpInfo)
        return g_pcpInfo[idx].uiCodePage;
    return CP_UNDEFINED;
}

//+-----------------------------------------------------------------------
//
//  Function:   WindowsCodePageFromCodePage
//
//  Synopsis:   Return a Windows codepage from an mlang CODEPAGE
//
//------------------------------------------------------------------------

UINT
WindowsCodePageFromCodePage( CODEPAGE cp )
{
    Assert(cp != CP_UNDEFINED);

    if (cp == CP_AUTO)
    {
        // cp 50001 (CP_AUTO)is designated to cross-language detection,
        // it really should not come in here but we'd return the default 
        // code page.
        return g_cpDefault;
    }
    else if (IsLatin1Codepage(cp))
    {
        return CP_1252; // short-circuit most common case
    }
    else if (IsStraightToUnicodeCodePage(cp))
    {
        return CP_UCS_2; // TODO (cthrash, IE6 track bug 17) Should be NATIVE_UNICODE_CODEPAGE?
    }
    else
    {
        if (!g_cpInfoInitialized)
            THR(EnsureCodePageInfo(FALSE));

        if (g_cpInfoInitialized)
        {
            LOCK_GLOBALS;

            for (UINT n = 0; n < g_ccpInfo; n++)
            {
                if (cp == g_pcpInfo[n].uiCodePage)
                    return g_pcpInfo[n].uiFamilyCodePage;
            }
        }
    }

    // NOTE: (cthrash) There's a chance that this codepage is a 'hidden'
    // codepage and that MLANG may actually know the family codepage.
    // So we ask them again, only differently.

    {
        UINT uiFamilyCodePage = 0;
        if (S_OK == THR(mlang().GetFamilyCodePage(cp, &uiFamilyCodePage)))
            return uiFamilyCodePage;
    }

    return g_cpDefault;
}

//+-----------------------------------------------------------------------
//
//  Function:   WindowsCharsetFromCodePage
//
//  Synopsis:   Return a Windows charset from an mlang CODEPAGE id
//
//------------------------------------------------------------------------

BYTE
WindowsCharsetFromCodePage( CODEPAGE cp )
{
#ifndef NO_MULTILANG
    HRESULT    hr;
    MIMECPINFO mimeCpInfo;

    if (cp == CP_ACP)
    {
        return DEFAULT_CHARSET;
    }

    hr = QuickMimeGetCodePageInfo(cp, &mimeCpInfo);
    if (!hr)
    {
        return mimeCpInfo.bGDICharset;
    }

#endif // !NO_MULTILANG
    return DEFAULT_CHARSET;
}

//+-----------------------------------------------------------------------
//
//  Function:   DefaultCodePageFromCharSet
//
//  Synopsis:   Return a Windows codepage from a Windows font charset
//
//------------------------------------------------------------------------

UINT
DefaultCodePageFromCharSet(BYTE bCharSet, CODEPAGE cp, LCID lcid)
{
    HRESULT hr;
    UINT    n;
    static  BYTE bCharSetPrev = DEFAULT_CHARSET;
    static  CODEPAGE cpPrev = CP_UNDEFINED;
    static  CODEPAGE cpDefaultPrev = CP_UNDEFINED;
    CODEPAGE cpDefault;

#ifdef NO_MULTILANG
    return GetACP();
#else
    if (   DEFAULT_CHARSET == bCharSet
        || (   bCharSet == ANSI_CHARSET
            && (   cp == CP_UCS_2
                   || cp == CP_UTF_8
               )
           )
       )
    {
        return g_cpDefault;  // Don't populate the statics.
    }
    else if (bCharSet == bCharSetPrev && cpPrev == cp)
    {
        // Here's our gamble -- We have a high likelyhood of calling with
        // the same arguments over and over.  Short-circuit this case.

        return cpDefaultPrev;
    }

    // First pick the *TRUE* codepage
    if (lcid)
    {
        char pszCodePage[5];
        
        GetLocaleInfoA( lcid, LOCALE_IDEFAULTANSICODEPAGE,
                        pszCodePage, ARRAY_SIZE(pszCodePage) );

        cp = atoi(pszCodePage);
    }

    // First check our internal lookup table in case we can avoid mlang
    for (n = 0; n < ARRAY_SIZE(s_aryCpMap); ++n)
    {
        if (cp == s_aryCpMap[n].cp && bCharSet == s_aryCpMap[n].bGDICharset)
        {
            cpDefault = cp;
            goto Cleanup;
        }
    }

    hr = THR(EnsureCodePageInfo(FALSE));
    if (hr)
    {
        cpDefault = WindowsCodePageFromCodePage(cp);
        goto Cleanup;
    }

    {
        LOCK_GLOBALS;
        
        // First see if we find an exact match for both cp and bCharset.
        for (n = 0; n < g_ccpInfo; n++)
        {
            if (cp == g_pcpInfo[n].uiCodePage &&
                bCharSet == g_pcpInfo[n].bGDICharset)
            {
                cpDefault = g_pcpInfo[n].uiFamilyCodePage;
                goto Cleanup;
            }
        }

        // Settle for the first match of bCharset.

        for (n = 0; n < g_ccpInfo; n++)
        {
            if (bCharSet == g_pcpInfo[n].bGDICharset)
            {
                cpDefault = g_pcpInfo[n].uiFamilyCodePage;
                goto Cleanup;
            }
        }

        cpDefault = g_cpDefault;
    }

Cleanup:

    bCharSetPrev = bCharSet;
    cpPrev = cp;
    cpDefaultPrev = cpDefault;

    return cpDefault;
#endif // !NO_MULTILANG
}

//+-----------------------------------------------------------------------
//
//  Function:   DefaultFontInfoFromCodePage
//
//  Synopsis:   Fills a LOGFONT structure with appropriate information for
//              a 'default' font for a given codepage.
//
//------------------------------------------------------------------------

HRESULT
DefaultFontInfoFromCodePage(CODEPAGE cp, LOGFONT * lplf, CDoc * pDoc)
{
    HFONT hfont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );

    // The strategy is thus: If we ask for a stock font in the default
    // (CP_ACP) codepage, return the logfont information of that font.
    // If we don't, replace key pieces of information.  Note we could
    // do better -- we could get the right lfPitchAndFamily.

#ifndef NO_MULTILANG
    if (!hfont)
    {
        CPINFO cpinfo;

        GetCPInfo( WindowsCodePageFromCodePage(cp), &cpinfo );

        hfont = (HFONT)((cpinfo.MaxCharSize == 1)
                        ? GetStockObject( ANSI_VAR_FONT )
                        : GetStockObject( SYSTEM_FONT ));

        AssertSz( hfont, "We'd better have a font now.");
    }
#endif

    GetObject( hfont, sizeof(LOGFONT), (LPVOID)lplf );

#ifndef NO_MULTILANG
    if (   cp != CP_ACP
        && cp != g_cpDefault
        && (   cp != CP_ISO_8859_1
            || g_cpDefault != CP_1252))
    {
        MIMECPINFO mimeCpInfo;
        IGNORE_HR(QuickMimeGetCodePageInfo(cp, &mimeCpInfo));
        // Make sure we don't overflow static buffer
        Assert(_tcsclen(mimeCpInfo.wszProportionalFont) < LF_FACESIZE);
        mimeCpInfo.wszProportionalFont[LF_FACESIZE - 1] = 0;

        BYTE bCharSet = mimeCpInfo.bGDICharset;
        LONG latmFaceName;
        if (MapToInstalledFont(mimeCpInfo.wszProportionalFont, &bCharSet, &latmFaceName))
        {
            _tcscpy(lplf->lfFaceName, fc().GetFaceNameFromAtom(latmFaceName));

            // NOTE (grzegorz): The right thing to do is to set charset to
            // lplf->lfCharSet = bCharSet;
            // But on non-FE systems we usually ask about "MS Sans Serif", which 
            // has poor coverage for Latin unicode range. So its better to 
            // font link for some upper latin characters than render square boxes.
            // To do it simply set charset to original one, even if we don't
            // match charset for the requested font.
            lplf->lfCharSet = mimeCpInfo.bGDICharset; // set original charset
        }
        else
        {
            //
            // NOTE (grzegorz): It may be good idea in this case get default
            // proportional font from the registry/MLang
            //
            SCRIPT_ID sid = ScriptIDFromCodePage(WindowsCodePageFromCodePage(cp));
            LONG latmFontFace = pDoc->_pOptionSettings->alatmProporitionalFonts[sid];
            if (latmFontFace == -1)
            {
                CODEPAGESETTINGS CS;
                CS.SetDefaults(WindowsCodePageFromCodePage(cp), pDoc->_pOptionSettings->sBaselineFontDefault);

                pDoc->_pOptionSettings->ReadCodepageSettingsFromRegistry(&CS, 0, sid);

                pDoc->_pOptionSettings->alatmFixedPitchFonts[sid]    = CS.latmFixedFontFace;
                pDoc->_pOptionSettings->alatmProporitionalFonts[sid] = CS.latmPropFontFace;

                latmFontFace = CS.latmPropFontFace;
            }

            _tcscpy(lplf->lfFaceName, fc().GetFaceNameFromAtom(latmFontFace));
            lplf->lfCharSet = CharSetFromScriptId(sid);
        }
    }
    else
    {
        // NB (cthrash) On both simplified and traditional Chinese systems,
        // we get a bogus lfCharSet value when we ask for the DEFAULT_GUI_FONT.
        // This later confuses CCcs::MakeFont -- so override.

        if (cp == 950)
        {
            lplf->lfCharSet = CHINESEBIG5_CHARSET;
        }
        else if (cp == 936)
        {
            lplf->lfCharSet = GB2312_CHARSET;
        }
    }
#endif // !NO_MULTILANG

   return S_OK;
}

//+-----------------------------------------------------------------------
//
//  Function:   CodePageFromString
//
//  Synopsis:   Map a charset to a forms3 CODEPAGE enum.  Searches in the
//              argument a string of the form charset=xxx.  This is used
//              by the META tag handler in the HTML preparser.
//
//              If fLookForWordCharset is TRUE, pch is presumed to be in
//              the form of charset=XXX.  Otherwise the string is
//              expected to contain just the charset string.
//
//------------------------------------------------------------------------

inline BOOL
IsWhite(TCHAR ch)
{
    return ch == TEXT(' ') || InRange(ch, TEXT('\t'), TEXT('\r'));
}

CODEPAGE
CodePageFromString( TCHAR * pch, BOOL fLookForWordCharset )
{
    CODEPAGE cp = CP_UNDEFINED;

    while (pch && *pch)
    {
        for (;IsWhite(*pch);pch++);

        if (!fLookForWordCharset || (_tcslen(pch) >= 7 &&
            _tcsnicmp(pch, 7, _T("charset"), 7) == 0))
        {
            if (fLookForWordCharset)
            {
                pch = _tcschr(pch, L'=');
                pch = pch ? ++pch : NULL;
            }

            if (pch)
            {
                for (;IsWhite(*pch);pch++);

                if (*pch)
                {
                    TCHAR *pchEnd, chEnd;

                    for (pchEnd = pch;
                         *pchEnd && !(*pchEnd == L';' || IsWhite(*pchEnd));
                         pchEnd++);

                    chEnd = *pchEnd;
                    *pchEnd = L'\0';

                    cp = CodePageFromAlias( pch );

                    *pchEnd = chEnd;

                    break;
                }
            }
        }

        if (pch)
        {
            pch = _tcschr( pch, L';');
            if (pch) pch++;
        }

    }

    return cp;
}

//+-----------------------------------------------------------------------
//
//  Function:   IsFECharset
//
//  Synopsis:   Returns TRUE iff charset may be for a FE country.
//
//------------------------------------------------------------------------

BOOL 
IsFECharset(BYTE bCharSet)
{
    switch(bCharSet)
    {
        case CHINESEBIG5_CHARSET:
        case SHIFTJIS_CHARSET:
        case HANGEUL_CHARSET:
#if !defined(WINCE) && !defined(UNIX)
        case JOHAB_CHARSET:
        case GB2312_CHARSET:
#endif // !WINCE && !UNIX
            return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  Member:     GetScriptProperties(eScript)
//
//  Synopsis:   Return a pointer to the script properties describing the script
//              eScript.
//
//-----------------------------------------------------------------------------

static const SCRIPT_PROPERTIES ** s_ppScriptProps = NULL;
static int s_cScript = 0;
static const SCRIPT_PROPERTIES s_ScriptPropsDefault =
{
    LANG_NEUTRAL,   // langid
    FALSE,          // fNumeric
    FALSE,          // fComplex
    FALSE,          // fNeedsWordBreaking
    FALSE,          // fNeedsCaretInfo
    ANSI_CHARSET,   // bCharSet
    FALSE,          // fControl
    FALSE,          // fPrivateUseArea
    FALSE,          // fReserved
};

const SCRIPT_PROPERTIES * 
GetScriptProperties(WORD eScript)
{
    if (s_ppScriptProps == NULL)
    {
        HRESULT hr;

        Assert(s_cScript == 0);
        if(g_bUSPJitState == JIT_OK)
            hr = ::ScriptGetProperties(&s_ppScriptProps, &s_cScript);
        else
            hr = E_PENDING;

        if (FAILED(hr))
        {
            // This should only fail if USP cannot be loaded. We shouldn't
            // really have made it here in the first place if this is true,
            // but you never know...
            return &s_ScriptPropsDefault;
        }
    }
    Assert(s_ppScriptProps != NULL && eScript < s_cScript &&
           s_ppScriptProps[eScript] != NULL);
    return s_ppScriptProps[eScript];
}

//+----------------------------------------------------------------------------
//  Member:     GetNumericScript(lang)
//
//  Synopsis:   Returns the script that should be used to shape digits in the
//              given language.
//
//-----------------------------------------------------------------------------

WORD 
GetNumericScript(DWORD lang)
{
    WORD eScript = 0;

    // We should never get here without having called GetScriptProperties().
    Assert(s_ppScriptProps != NULL && eScript < s_cScript &&
           s_ppScriptProps[eScript] != NULL);
    for (eScript = 0; eScript < s_cScript; eScript++)
    {
        if (s_ppScriptProps[eScript]->langid == lang &&
            s_ppScriptProps[eScript]->fNumeric)
        {
            return eScript;
        }
    }

    return SCRIPT_UNDEFINED;
}

//+----------------------------------------------------------------------------
//  Member:     ScriptItemize(...)
//
//  Synopsis:   Dynamically grows the needed size of paryItems as needed to
//              successfully itemize the input string.
//
//-----------------------------------------------------------------------------

HRESULT WINAPI 
ScriptItemize(
    PCWSTR                  pwcInChars,     // In   Unicode string to be itemized
    int                     cInChars,       // In   Character count to itemize
    int                     cItemGrow,      // In   Items to grow by if paryItems is too small
    const SCRIPT_CONTROL   *psControl,      // In   Analysis control (optional)
    const SCRIPT_STATE     *psState,        // In   Initial bidi algorithm state (optional)
    CDataAry<SCRIPT_ITEM>  *paryItems,      // Out  Array to receive itemization
    PINT                    pcItems)        // Out  Count of items processed
{
    HRESULT hr;

    // ScriptItemize requires that the max item buffer size be AT LEAST 2
    Assert(cItemGrow > 2);

    if(paryItems->Size() < 2)
    {
        hr = paryItems->Grow(cItemGrow);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    do {
        hr = ScriptItemize(pwcInChars, cInChars, paryItems->Size(),
                           psControl, psState, (SCRIPT_ITEM*)*paryItems, pcItems);

        if (hr == E_OUTOFMEMORY)
        {
            if (FAILED(paryItems->Grow(paryItems->Size() + cItemGrow)))
            {
                goto Cleanup;
            }
        }
    } while(hr == E_OUTOFMEMORY);

Cleanup:
    if (SUCCEEDED(hr))
    {
        // NB (mikejoch) *pcItems doesn't include the sentinel item.
        Assert(*pcItems < paryItems->Size());
        paryItems->SetSize(*pcItems + 1);
    }
    else
    {
        *pcItems = 0;
        paryItems->DeleteAll();
    }

    return hr;
}

// TODO (cthrash, IE5 track bug 112152) This class (CIntlFont) should be axed when we implement
// a light-weight fontlinking implementation of Line Services.  This LS
// implementation will work as a DrawText replacement, and can be used by
// intrinsics as well.

CIntlFont::CIntlFont(
    const CDocInfo * pdci,
    XHDC hdc,
    CODEPAGE codepage,
    LCID lcid,
    SHORT sBaselineFont,
    const TCHAR * psz)
{
    BYTE bCharSet = WindowsCharsetFromCodePage( codepage );

    // If we are working on scaled surface, avoid using stock fonts.
    BOOL fScaled = (pdci->GetUnitInfo() != &g_uiDisplay);

    _hdc = hdc;
    _hFont = NULL;

    Assert(sBaselineFont >= 0 && sBaselineFont <= 4);
    Assert(psz);

    if (IsStraightToUnicodeCodePage(codepage))
    {
        BOOL fSawHan = FALSE;
        SCRIPT_ID sid;
        
        // If the document is in a Unicode codepage, we need determine the
        // best-guess charset for this string.  To do so, we pick the first
        // interesting script id.

        while (*psz)
        {
            sid = ScriptIDFromCh(*psz++);

            if (sid == sidHan)
            {
                fSawHan = TRUE;
                continue;
            }
            
            if (sid > sidAsciiLatin)
                break;
        }

        if (*psz)
        {
            // We found something interesting, go pick that font up

            codepage = DefaultCodePageFromScript( &sid, CP_UCS_2, lcid );

        }
        else if (!fScaled)
        {
            if (!fSawHan)
            {
                // the string contained nothing interesting, go with the stock GUI font

                _hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
                _fIsStock = sBaselineFont == 2;
            }
            else
            {
                // We saw a Han character, but nothing else which would
                // disambiguate the script.  Furthermore, we don't have a good
                // fallback as we did in the above case.

                sid = sidHan;
                codepage = DefaultCodePageFromScript( &sid, CP_UCS_2, lcid );
            }
        }
    }
    else if ((  ANSI_CHARSET == bCharSet
                || (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID 
                    && !IsFECharset(bCharSet)))
             && !fScaled)
    {
        // If we're looking for an ANSI font, or if we're under NT and
        // looking for a non-FarEast font, the stockfont will suffice.

        _hFont = (HFONT)GetStockObject( ANSI_VAR_FONT );
        _fIsStock = sBaselineFont == 2;
    }
    else
    {
        codepage = WindowsCodePageFromCodePage( codepage );
    }

    if (!_hFont && codepage == g_cpDefault  && !fScaled)
    {
        // If we're going to get the correct native charset the, the
        // GUI font will work nicely.

        _hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
        _fIsStock = sBaselineFont == 2;
    }

    if (_hFont)
    {
        if (!_fIsStock)
        {
            LOGFONT lf;

            GetObject(_hFont, sizeof(lf), &lf);

            lf.lfHeight = MulDivQuick( lf.lfHeight, 4 + sBaselineFont, 6 );
            lf.lfWidth  = 0;
            lf.lfOutPrecision |= OUT_TT_ONLY_PRECIS;

            _hFont = CreateFontIndirect( &lf );
        }
    }
    else
    {
        // We'd better cook up a font if all else fails.

        LOGFONT lf;

        DefaultFontInfoFromCodePage(codepage, &lf, pdci->_pDoc);

        lf.lfHeight = MulDivQuick( lf.lfHeight, 
                                   (4 + sBaselineFont) * pdci->GetResolution().cy, 
                                   6 * g_uiDisplay.GetResolution().cy );
        lf.lfWidth  = 0;
        lf.lfOutPrecision |= OUT_TT_ONLY_PRECIS;

        _hFont = CreateFontIndirect( &lf );
        _fIsStock = FALSE;
    }

    _hOldFont = (HFONT)SelectObject( hdc, _hFont );
}

CIntlFont::~CIntlFont()
{
    SelectObject( _hdc, _hOldFont );

    if (!_fIsStock)
    {
        DeleteObject( _hFont );
    }
}

//+-----------------------------------------------------------------------------
//
//  Function:   DefaultCodePageFromCharSet
//
//  Synopsis:   Map charset to codepage.
//
//------------------------------------------------------------------------------

CODEPAGE
DefaultCodePageFromCharSet(BYTE bCharSet, CODEPAGE uiFamilyCodePage)
{
    CODEPAGE cp = uiFamilyCodePage;
    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (bCharSet == g_aCPBitmapCPCharsetSid[i].bGDICharset)
        {
            cp = g_aCPBitmapCPCharsetSid[i].cp;
            break;
        }
    }
    return cp;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CharSetFromLangId
//
//  Synopsis:   Map lang ID to charset.
//
//------------------------------------------------------------------------------

BYTE
CharSetFromLangId(LANGID lang)
{
    BYTE bCharSet = DEFAULT_CHARSET;
    DWORD dwCPBitmap = CPBitmapFromLangID(lang);

    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (dwCPBitmap & g_aCPBitmapCPCharsetSid[i].dwCPBitmap)
        {
            bCharSet = g_aCPBitmapCPCharsetSid[i].bGDICharset;
            break;
        }
    }
    return bCharSet;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CharSetFromScriptId
//
//  Synopsis:   Map script ID to charset.
//
//------------------------------------------------------------------------------

BYTE
CharSetFromScriptId(SCRIPT_ID sid)
{
    BYTE bCharSet = DEFAULT_CHARSET;

    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (sid == g_aCPBitmapCPCharsetSid[i].sid)
        {
            bCharSet = g_aCPBitmapCPCharsetSid[i].bGDICharset;
            break;
        }
    }
    return bCharSet;
}

//+-----------------------------------------------------------------------------
//
//  Function:   ScriptIDFromCodePage
//
//  Synopsis:   Map code page to script id.
//
//------------------------------------------------------------------------------

SCRIPT_ID  
ScriptIDFromCodePage(CODEPAGE cp)
{
    SCRIPT_ID sid = sidDefault;

    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (cp == g_aCPBitmapCPCharsetSid[i].cp)
        {
            sid = g_aCPBitmapCPCharsetSid[i].sid;
            break;
        }
    }
    return sid;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CPBitmapFromLangIDSlow
//
//  Synopsis:   Map lang ID to codepages bitmap. (Slow version)
//
//------------------------------------------------------------------------------

DWORD 
CPBitmapFromLangIDSlow(LANGID lang)
{
    DWORD dwCPBitmap = 0;
    WORD sublang = SUBLANGID(lang);
    switch (PRIMARYLANGID(lang))
    {
    case LANG_CHINESE:
        dwCPBitmap = (sublang == SUBLANG_CHINESE_TRADITIONAL ? FS_CHINESETRAD : FS_CHINESESIMP);
        break;
    case LANG_KOREAN:
        dwCPBitmap = (sublang == SUBLANG_KOREAN ? FS_WANSUNG : FS_JOHAB);
        break;
    case LANG_SERBIAN:
        dwCPBitmap = (sublang == SUBLANG_SERBIAN_CYRILLIC ? FS_CYRILLIC : FS_LATIN2);
        break;
    case LANG_AZERI:
        dwCPBitmap = (sublang == SUBLANG_AZERI_CYRILLIC ? FS_CYRILLIC : FS_LATIN1);
        break;
    case LANG_UZBEK:
        dwCPBitmap = (sublang == SUBLANG_UZBEK_CYRILLIC ? FS_CYRILLIC : FS_LATIN1);
        break;
    default:
        Assert(FALSE);  // Should get data in fast vertion (FBSFromLangID)
    }
    return dwCPBitmap;
}

//+-----------------------------------------------------------------------------
//
//  Function:   CPBitmapFromWindowsCodePage
//
//  Synopsis:   Maps windows codepage to codepages bitmap.
//
//------------------------------------------------------------------------------

DWORD 
CPBitmapFromWindowsCodePage(CODEPAGE cp)
{
    DWORD cpbits = 0;
    int i = ARRAY_SIZE(g_aCPBitmapCPCharsetSid);
    while (i--)
    {
        if (cp == g_aCPBitmapCPCharsetSid[i].cp)
        {
            cpbits = g_aCPBitmapCPCharsetSid[i].dwCPBitmap;
            break;
        }
    }
    return cpbits;
}

const WCHAR g_achLatin1MappingInUnicodeControlArea[32] =
{
#ifndef UNIX
    0x20ac, // 0x80
    0x0081, // 0x81
    0x201a, // 0x82
    0x0192, // 0x83
    0x201e, // 0x84
    0x2026, // 0x85
    0x2020, // 0x86
    0x2021, // 0x87
    0x02c6, // 0x88
    0x2030, // 0x89
    0x0160, // 0x8a
    0x2039, // 0x8b
    0x0152, // 0x8c <min>
    0x008d, // 0x8d
    0x017d, // 0x8e
    0x008f, // 0x8f
    0x0090, // 0x90
    0x2018, // 0x91
    0x2019, // 0x92
    0x201c, // 0x93
    0x201d, // 0x94
    0x2022, // 0x95
    0x2013, // 0x96
    0x2014, // 0x97
    0x02dc, // 0x98
    0x2122, // 0x99 <max>
    0x0161, // 0x9a
    0x203a, // 0x9b
    0x0153, // 0x9c
    0x009d, // 0x9d
    0x017e, // 0x9e
    0x0178  // 0x9f
#else
    _T('?'),  // 0x80
    _T('?'),  // 0x81
    _T(','),  // 0x82
    0x00a6,   // 0x83
    _T('?'),  // 0x84
    0x00bc,   // 0x85
    _T('?'),  // 0x86
    _T('?'),  // 0x87
    0x00d9,   // 0x88
    _T('?'),  // 0x89
    _T('?'),  // 0x8a
    _T('<'),  // 0x8b
    _T('?'),  // 0x8c
    _T('?'),  // 0x8d
    _T('?'),  // 0x8e
    _T('?'),  // 0x8f
    _T('?'),  // 0x90
    0x00a2,   // 0x91
    0x00a2,   // 0x92
    0x00b2,   // 0x93
    0x00b2,   // 0x94
    0x00b7,   // 0x95
    _T('-'),  // 0x96
    0x00be,   // 0x97
    _T('~'),  // 0x98
    0x00d4,   // 0x99
    _T('s'),  // 0x9a
    _T('>'),  // 0x9b
    _T('?'),  // 0x9c
    _T('?'),  // 0x9d
    _T('?'),  // 0x9e
    0x0055    // 0x9f
#endif
};

// ############################################################## UniSid.cxx
//+-----------------------------------------------------------------------
//
//  g_aSidInfo
//
//  Script ID mapping to:
//  * charset
//  * representative of average char width for the script id
//
//------------------------------------------------------------------------
#define SPECIAL_CHARSET 3

const SidInfo g_aSidInfo[sidTridentLim] =
{
    { /* sidDefault        (0) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidMerge          (1) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidAsciiSym       (2) */ ANSI_CHARSET,        0x0078    },
    { /* sidAsciiLatin     (3) */ SPECIAL_CHARSET,     0x0078    },
    { /* sidLatin          (4) */ SPECIAL_CHARSET,     0x0078    },
    { /* sidGreek          (5) */ GREEK_CHARSET,       0x03c7    },
    { /* sidCyrillic       (6) */ RUSSIAN_CHARSET,     0x0445    },
    { /* sidArmenian       (7) */ DEFAULT_CHARSET,     0x0562    },
    { /* sidHebrew         (8) */ HEBREW_CHARSET,      0x05d0    },
    { /* sidArabic         (9) */ ARABIC_CHARSET,      0x0637    },
    { /* sidDevanagari    (10) */ DEFAULT_CHARSET,     0x0909    },
    { /* sidBengali       (11) */ DEFAULT_CHARSET,     0x0989    },
    { /* sidGurmukhi      (12) */ DEFAULT_CHARSET,     0x0a19    },
    { /* sidGujarati      (13) */ DEFAULT_CHARSET,     0x0a89    },
    { /* sidOriya         (14) */ DEFAULT_CHARSET,     0x0b09    },
    { /* sidTamil         (15) */ DEFAULT_CHARSET,     0x0b8e    },
    { /* sidTelugu        (16) */ DEFAULT_CHARSET,     0x0c05    },
    { /* sidKannada       (17) */ DEFAULT_CHARSET,     0x0c85    },
    { /* sidMalayalam     (18) */ DEFAULT_CHARSET,     0x0d17    },
    { /* sidThai          (19) */ THAI_CHARSET,        0x0e01    },
    { /* sidLao           (20) */ DEFAULT_CHARSET,     0x0e81    },
    { /* sidTibetan       (21) */ DEFAULT_CHARSET,     0x0f40    },
    { /* sidGeorgian      (22) */ DEFAULT_CHARSET,     0x10d0    },
    { /* sidHangul        (23) */ HANGUL_CHARSET,      0xac00    },
    { /* sidKana          (24) */ SHIFTJIS_CHARSET,    0x4e00    },
    { /* sidBopomofo      (25) */ CHINESEBIG5_CHARSET, 0x4e00    },
    { /* sidHan           (26) */ GB2312_CHARSET,      0x4e00    },
    { /* sidEthiopic      (27) */ DEFAULT_CHARSET,     0x1210    },
    { /* sidCanSyllabic   (28) */ DEFAULT_CHARSET,     0x1405    },
    { /* sidCherokee      (29) */ DEFAULT_CHARSET,     0x13bb    },
    { /* sidYi            (30) */ DEFAULT_CHARSET,     0xa000    },
    { /* sidBraille       (31) */ DEFAULT_CHARSET,     0x2909    },
    { /* sidRunic         (32) */ DEFAULT_CHARSET,     0x16ba    },
    { /* sidOgham         (33) */ DEFAULT_CHARSET,     0x1683    },
    { /* sidSinhala       (34) */ DEFAULT_CHARSET,     0x0d85    },
    { /* sidSyriac        (35) */ DEFAULT_CHARSET,     0x0717    },
    { /* sidBurmese       (36) */ DEFAULT_CHARSET,     0x1000    },
    { /* sidKhmer         (37) */ DEFAULT_CHARSET,     0x1780    },
    { /* sidThaana        (38) */ DEFAULT_CHARSET,     0x0784    },
    { /* sidMongolian     (39) */ DEFAULT_CHARSET,     0x1824    },
    { /* sidUserDefined   (40) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidSurrogateA    (41) */ DEFAULT_CHARSET,     0x4e00    },
    { /* sidSurrogateB    (42) */ DEFAULT_CHARSET,     0x4e00    },
    { /* sidAmbiguous     (43) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidEUDC          (44) */ DEFAULT_CHARSET,     0x0078    },
    { /* sidHalfWidthKana (45) */ SHIFTJIS_CHARSET,    0x4e00    },
    { /* sidCurrency      (46) */ SPECIAL_CHARSET,     0x0078    }
};

//
// We must not fontlink for sidEUDC -- GDI will handle
//

#define SCRIPT_BIT_CONST ScriptBit(sidEUDC)

//+----------------------------------------------------------------------------
//
//  Function:   UnUnifyHan, static
//
//  Synopsis:   Use a heuristic to best approximate the script actually
//              represented by sidHan.  This is necessary because of the
//              infamous Han-Unification brought upon us by the Unicode
//              consortium.
//
//              We prioritize the lcid if set.  This is set in HTML through
//              the use of the LANG attribute.  If this is not set, we
//              take the document codepage as reference.
//
//              The fallout case picks Japanese, as there is biggest market
//              share there today.
//
//  Returns:    Best guess script id.
//
//-----------------------------------------------------------------------------

SCRIPT_ID
UnUnifyHan(
    UINT uiFamilyCodePage,
    LCID lcid )
{
    if ( !lcid )
    {
        // No lang info.  Try codepages

        if (uiFamilyCodePage == CP_CHN_GB)
        {
            lcid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
        }
        else if (uiFamilyCodePage == CP_KOR_5601)
        {
            lcid = MAKELANGID(LANG_KOREAN, SUBLANG_NEUTRAL);
        }
        else if (uiFamilyCodePage == CP_TWN)
        {
            lcid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
        }
        else
        {
            lcid = MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL);
        }
    }

    LANGID lid = LANGIDFROMLCID(lcid);
    if (!IsFELang(lid))
        lid = MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL);
    return ScriptIDFromLangID(lid);
}

//+----------------------------------------------------------------------------
//
//  Function:   DefaultCodePageFromScript, static
//
//  Synopsis:   we return the best-guess default codepage based on the script
//              id passed.  It is a best-guess because scripts can cover
//              multiple codepages.
//
//  Returns:    Best-guess codepage for given information.
//              Also returns the ununified sid for sidHan.
//
//-----------------------------------------------------------------------------

CODEPAGE
DefaultCodePageFromScript(
    SCRIPT_ID * psid,   // IN/OUT
    CODEPAGE cpDoc,  // IN
    LCID lcid )         // IN
{
    AssertSz(psid, "Not an optional parameter.");
    AssertSz(cpDoc == WindowsCodePageFromCodePage(cpDoc),
             "Get an Internet codepage, expected a Windows codepage.");

    CODEPAGE cp;
    SCRIPT_ID sid = *psid;

    if (sid == sidMerge || sid == sidAmbiguous)
    {
        //
        // This is a hack -- the only time we should be called with sidMerge
        // is when the person asking about the font doesn't know what the sid
        // for the run is (e.g. treepos is non-text.)  In this event, we need
        // to pick a codepage which will give us the highest likelyhood of
        // being the correct one for ReExtTextOutW.
        //

        return cpDoc;
    }
    else if (cpDoc == CP_1250 && sid == sidDefault || sid == sidLatin)
    {
        // HACK (cthrash) CP_1250 (Eastern Europe) doesn't have it's own sid,
        // because its codepoints are covered by AsciiLatin, AsciiSym, and
        // Latin.  When printing, though, we may need to do a WC2MB (on a PCL
        // printer, for example) so we need the best approximation for the
        // actual codepage of the text.  In the simplest case, take the
        // document codepage over cp1252.

        cp = CP_1250;
    }
    else
    {
        // NB (cthrash) We assume the sidHan is the unified script for Han.
        // we use the usual heurisitics to pick amongst them.

        sid = (sid != sidHan) ? sid : UnUnifyHan( cpDoc, lcid );

        switch (sid)
        {
            default:            cp = CP_1252;       break;
            case sidGreek:      cp = CP_1253;       break;
            case sidCyrillic:   cp = CP_1251;       break;
            case sidHebrew:     cp = CP_1255;       break;
            case sidArabic:     cp = CP_1256;       break;
            case sidThai:       cp = CP_THAI;       break;
            case sidHangul:     cp = CP_KOR_5601;   break;
            case sidKana:       cp = CP_JPN_SJ;     break;
            case sidBopomofo:   cp = CP_TWN;        break;
            case sidHan:        cp = CP_CHN_GB;     break;
        }

        *psid = sid;
    }

    return cp;
}

//+----------------------------------------------------------------------------
//
//  Function:   DefaultCharSetFromScriptAndCharset/CodePage, static
//
//  Synopsis:   we return the best-guess default GDI charset based on the
//              script id passed.  We use the charformat charset is the tie-
//              breaker.
//
//              Note the sid should already been UnUnifyHan'd.
//
//  Returns:    Best-guess GDI charset for given information.
//
//-----------------------------------------------------------------------------

BYTE
DefaultCharSetFromScriptAndCharset(
    SCRIPT_ID sid,
    BYTE bCharSetCF )
{
    BYTE bCharSet = g_aSidInfo[sid]._bCharSet;

    if (bCharSet == SPECIAL_CHARSET)
    {
        if (   sid == sidLatin
            && (   bCharSetCF == TURKISH_CHARSET
                || bCharSetCF == ANSI_CHARSET
                || bCharSetCF == VIETNAMESE_CHARSET
                || bCharSetCF == BALTIC_CHARSET
                || bCharSetCF == EASTEUROPE_CHARSET
               )
           )
        {
            bCharSet = bCharSetCF;
        }
        else if (sid == sidHangul)
        {
            bCharSet = bCharSetCF == JOHAB_CHARSET
                       ? JOHAB_CHARSET
                       : HANGUL_CHARSET;
        }
        else
        {
            bCharSet = DEFAULT_CHARSET;
        }
    }

    return bCharSet;
}

//+----------------------------------------------------------------------------
//
//  Function:   DefaultCharSetFromScriptAndCodePage, static
//
//  Synopsis:   we return the best-guess default GDI charset based on the
//              script id passed and family codepage.
//
//              Note the sid should already been UnUnifyHan'd.
//
//  Returns:    Best-guess GDI charset for given information.
//
//-----------------------------------------------------------------------------

static const BYTE s_ab125xCharSets[] = 
{
    EASTEUROPE_CHARSET, // 1250
    RUSSIAN_CHARSET,    // 1251
    ANSI_CHARSET,       // 1252
    GREEK_CHARSET,      // 1253
    TURKISH_CHARSET,    // 1254
    HEBREW_CHARSET,     // 1255
    ARABIC_CHARSET,     // 1256
    BALTIC_CHARSET,     // 1257
    VIETNAMESE_CHARSET  // 1258
};

BYTE
DefaultCharSetFromScriptAndCodePage(
    SCRIPT_ID sid,
    UINT uiFamilyCodePage )
{
    BYTE bCharSet = g_aSidInfo[sid]._bCharSet;

    if (bCharSet == SPECIAL_CHARSET)
    {
        bCharSet = (uiFamilyCodePage >= 1250 && uiFamilyCodePage <= 1258)
                   ? s_ab125xCharSets[uiFamilyCodePage - 1250]
                   : ANSI_CHARSET;
    }

    return bCharSet;
}

//+-----------------------------------------------------------------------------
//
//  Function:   DefaultSidForCodePage
//
//  Returns:    The default SCRIPT_ID for a codepage.  For stock codepages, we
//              cache the answer.  For the rest, we ask MLANG.
//
//------------------------------------------------------------------------------

SCRIPT_ID
DefaultSidForCodePage( UINT uiFamilyCodePage )
{
    SCRIPT_ID sid = sidLatin;
#if DBG==1
    BOOL fCachedSidDbg = TRUE;
#endif

    switch (uiFamilyCodePage)
    {
        case CP_UCS_2:    sid = sidLatin; break;
        case CP_1250:     sid = sidLatin; break;
        case CP_1251:     sid = sidCyrillic; break;
        case CP_1252:     sid = sidLatin; break;
        case CP_1253:     sid = sidGreek; break;
        case CP_1254:     sid = sidLatin; break;
        case CP_1255:     sid = sidHebrew; break;
        case CP_1256:     sid = sidArabic; break;
        case CP_1257:     sid = sidLatin; break;
        case CP_1258:     sid = sidLatin; break;
        case CP_THAI:     sid = sidThai; break;
        case CP_JPN_SJ:   sid = sidKana; break;
        case CP_CHN_GB:   sid = sidHan; break;
        case CP_KOR_5601: sid = sidHangul; break;
        case CP_TWN:      sid = sidBopomofo; break;
        default:
        {
#if DBG==1
            fCachedSidDbg = FALSE;
#endif
            HRESULT hr = THR(mlang().CodePageToScriptID(uiFamilyCodePage, &sid));
            if (FAILED(hr))
            {
                sid = sidLatin;
            }
        }
        break;
    }
    // TODO (grzegorz): enable this code (removed only for performance testing)
#if NEVER
#if DBG==1
    if (fCachedSidDbg)
    {
        SCRIPT_ID sidDbg;
        HRESULT hr = THR(mlang().CodePageToScriptID(uiFamilyCodePage, &sidDbg));
        if (SUCCEEDED(hr))
        {
            if (   sidDbg == sidAsciiLatin
                && (   uiFamilyCodePage == CP_1250
                    || uiFamilyCodePage == CP_1252
                    || uiFamilyCodePage == CP_1254
                    || uiFamilyCodePage == CP_1257
                    || uiFamilyCodePage == CP_1258
                   )
               )
            {
                sidDbg = sidLatin;
            }
        }
        else
        {
            sid = sidLatin;
        }

        Assert(sid == sidDbg);
    }
#endif
#endif

    return sid;
}

//+----------------------------------------------------------------------------
//
//  Debug only code
//
//-----------------------------------------------------------------------------

#if DBG==1

const TCHAR * achSidNames[sidTridentLim] =
{
    _T("Default"),          // 0
    _T("Merge"),            // 1
    _T("AsciiSym"),         // 2
    _T("AsciiLatin"),       // 3
    _T("Latin"),            // 4
    _T("Greek"),            // 5
    _T("Cyrillic"),         // 6
    _T("Armenian"),         // 7
    _T("Hebrew"),           // 8
    _T("Arabic"),           // 9
    _T("Devanagari"),       // 10
    _T("Bengali"),          // 11
    _T("Gurmukhi"),         // 12
    _T("Gujarati"),         // 13
    _T("Oriya"),            // 14
    _T("Tamil"),            // 15
    _T("Telugu"),           // 16
    _T("Kannada"),          // 17
    _T("Malayalam"),        // 18
    _T("Thai"),             // 19
    _T("Lao"),              // 20
    _T("Tibetan"),          // 21
    _T("Georgian"),         // 22
    _T("Hangul"),           // 23
    _T("Kana"),             // 24
    _T("Bopomofo"),         // 25
    _T("Han"),              // 26
    _T("Ethiopic"),         // 27
    _T("CanSyllabic"),      // 28
    _T("Cherokee"),         // 29
    _T("Yi"),               // 30
    _T("Braille"),          // 31
    _T("Runic"),            // 32
    _T("Ogham"),            // 33
    _T("Sinhala"),          // 34
    _T("Syriac"),           // 35
    _T("Burmese"),          // 36
    _T("Khmer"),            // 37
    _T("Thaana"),           // 38
    _T("Mongolian"),        // 39
    _T("UserDefined"),      // 40
    _T("SurrogateA"),       // 41 *** Trident internal ***
    _T("SurrogateB"),       // 42 *** Trident internal ***
    _T("Ambiguous"),        // 43 *** Trident internal ***
    _T("EUDC"),             // 44 *** Trident internal ***
    _T("HalfWidthKana"),    // 45 *** Trident internal ***
    _T("Currency"),         // 46 *** Trident internal ***
};

//+----------------------------------------------------------------------------
//
//  Functions:  SidName
//
//  Returns:    Human-intelligible name for a script_id
//
//-----------------------------------------------------------------------------

const TCHAR *
SidName( SCRIPT_ID sid )
{
    return ( sid >= 0 && sid < sidTridentLim ) ? achSidNames[sid] : _T("#ERR");
}

//+----------------------------------------------------------------------------
//
//  Functions:  DumpSids
//
//  Synopsis:   Dump to the output window a human-intelligible list of names
//              of scripts coverted by the sids.
//
//-----------------------------------------------------------------------------

void
DumpSids( SCRIPT_IDS sids )
{
    SCRIPT_ID sid;

    for (sid=0; sid < sidTridentLim; sid++)
    {
        if (sids & ScriptBit(sid))
        {
            OutputDebugString(SidName(sid));
            OutputDebugString(_T("\r\n"));
        }
    }
}
#endif // DBG==1

static const BYTE s_aFESidsToCharSets[] = 
{                       // sidBopomofo sidKana sidHangul  
    GB2312_CHARSET,     //    0           0       0
    HANGUL_CHARSET,     //    0           0       1
    SHIFTJIS_CHARSET,   //    0           1       0
    HANGUL_CHARSET,     //    0           1       1
    CHINESEBIG5_CHARSET,//    1           0       0
    DEFAULT_CHARSET,    //    1           0       1       was HANGUL_CHARSET
    CHINESEBIG5_CHARSET,//    1           1       0
    DEFAULT_CHARSET     //    1           1       1       was HANGUL_CHARSET
};

BYTE
DefaultCharSetFromScriptsAndCodePage(
    SCRIPT_IDS sidsFace,
    SCRIPT_ID sid,
    UINT uiFamilyCodePage )
{
    BYTE bCharSet = DEFAULT_CHARSET;

    //
    // HACKHACK (grzegorz): most JA fonts claim to support sidHan and sidKana,
    // and some SCH fonts (like SimSun) claim to support sidHan and sidKana.
    // Hence there is no possibility to pickup the right charset.
    // So on SCH encoded page don't use font information as a hint to pick up 
    // the right charset, since for fonts supporting sidHan and sidKana we 
    // set charset to JA.
    //
    if (    sidsFace & ScriptBit(sid)
        &&  sidsFace & ScriptBit(sidHan)
        &&  uiFamilyCodePage != CP_CHN_GB)
    {
        LONG idx = (sidsFace & (ScriptBit(sidKana) | ScriptBit(sidBopomofo) | ScriptBit(sidHangul))) >> sidHangul;
        Assert(idx >= 0 && idx < 8);
        bCharSet = s_aFESidsToCharSets[idx];
    }
    if (bCharSet == DEFAULT_CHARSET)
    {
        bCharSet = DefaultCharSetFromScriptAndCodePage(sid, uiFamilyCodePage);
    }

    return bCharSet;
}


// ##############################################################
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\listhlp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       listhlp.cxx
//
//  Contents:   List helpers.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include "eli.hxx"
#endif

#ifndef X_EOLIST_HXX_
#define X_EOLIST_HXX_
#include "eolist.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

//+----------------------------------------------------------------------------
//
//  Function:   IsBlockListElement
//
//  Synopsis:   Callback used by SearchBranchForCriteria to determine whenever
//              a node is a block list element.
//
//-----------------------------------------------------------------------------

BOOL IsBlockListElement(
    CTreeNode * pNode, 
    void *pvData)
{
    return pNode->Element()->IsFlagAndBlock(TAGDESC_LIST);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsListItemNode
//
//  Synopsis:   Callback used by SearchBranchForCriteriaInStory to determine 
//              if a node is a list item (LI or display:list-item).
//
//-----------------------------------------------------------------------------

BOOL IsListItemNode(
    CTreeNode * pNode)
{
    return IsListItem(pNode, NULL);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsListItem
//
//  Synopsis:   Determines if a node is a list item (LI or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (pNode->Tag() == ETAG_LI)
        return TRUE;
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   IsBlockListItem
//
//  Synopsis:   Determines if a node is a block list item (LI or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsBlockListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    if (pNode->Tag() == ETAG_LI && pNode->_fBlockNess)
        return TRUE;
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   IsGenericListItem
//
//  Synopsis:   Determines if a node is a generic list item 
//              (LI, DD, DT or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsGenericListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (pNode->Element()->HasFlag(TAGDESC_LISTITEM))
        return TRUE;
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   IsGenericBlockListItem
//
//  Synopsis:   Determines if a node is a generic block list item 
//              (LI, DD, DT or display:list-item).
//              Valid pFF avoids calling GetFancyFormat [usefull in ComputeFormats]
//
//-----------------------------------------------------------------------------

BOOL IsGenericBlockListItem(
    CTreeNode * pNode, 
    const CFancyFormat * pFF)
{
    if (!pFF)
    {
        Assert(pNode->GetIFF() >= 0);
        pFF = pNode->GetFancyFormat();
    }
    if (pNode->Element()->HasFlag(TAGDESC_LISTITEM) && pNode->_fBlockNess)
        return TRUE;
    return pFF->IsListItem();
}

//+----------------------------------------------------------------------------
//
//  Function:   NumberOrBulletFromStyle
//
//  Synopsis:   Does the style type denote number or bullet type list?
//
//-----------------------------------------------------------------------------

CListing::LISTING_TYPE NumberOrBulletFromStyle(
    styleListStyleType listType)
{
    switch (listType)
    {
        case styleListStyleTypeNotSet:
        case styleListStyleTypeNone:
        case styleListStyleTypeDisc:
        case styleListStyleTypeCircle:
        case styleListStyleTypeSquare:
            return (CListing::BULLET);
            break;
    }
    return (CListing::NUMBERING);
}

//+------------------------------------------------------------------------
//
//  Member:     GetValidValue
//
//  Synopsis:   This is the main function which returns the list index value
//              for a list item. Its only called by the renderer.
//
//-------------------------------------------------------------------------

void GetValidValue(
    CTreeNode * pNodeListItem,
    CTreeNode * pNodeList,
    CMarkup * pMarkup,
    CElement * pElementFL,
    CListValue * pLV)
{
    const CParaFormat *pPF;

    Assert(pNodeListItem);
    Assert(pLV);

    // Delegate LI's to LI related calculator
    if (   pNodeListItem->Tag() == ETAG_LI
        && !pNodeListItem->GetFancyFormat()->IsListItem())
    {
        CLIElement * pLIElement = DYNCAST(CLIElement, pNodeListItem->Element());
        pLIElement->GetValidValue(pLV, pMarkup, pNodeListItem, pNodeList, pElementFL);
        return;
    }

    pPF = pNodeListItem->GetParaFormat();
    const CListing & listing = pPF->GetListing();

    pLV->_style  = listing.GetStyle();
    pLV->_lValue = 0;

    // If the current list items is an LI, and it has a 'value', use it.
    if (pNodeListItem->Tag() == ETAG_LI)
    {
        CLIElement * pLIElement = DYNCAST(CLIElement, pNodeListItem->Element());
        if (pLIElement->GetAAvalue() > 0)
        {
            pLV->_lValue = pLIElement->GetAAvalue();
        }
    }

    if (pLV->_lValue == 0)
    {
        LONG lStart  = 0;
        pLV->_lValue = 1;

        // pNodeList was deduced by the caller by calling FindMyListContainer()
        // If now this list item is not LI/has display:list-item, then 
        // then that node information is not useful. The pNodeList for
        // this item is the direct parent.
        pNodeList = pNodeListItem->Parent();

        // If containing element is a list element and it has starting number, use it.
        if (pNodeList->Tag() == ETAG_OL && IsBlockListElement(pNodeList, NULL))
        {
            COListElement * pOListElement = DYNCAST(COListElement, pNodeList->Element());
            if (pOListElement->GetAAstart() > 0)
            {
                lStart = pOListElement->GetAAstart();
            }
        }

        // For numbered list item retrieve the number.
        if (   CListing::NUMBERING == NumberOrBulletFromStyle(listing.GetStyle())
            && pNodeList)
        {
            CTreeNode * pNodeSibling;
            CChildIterator ci(pNodeList->Element(), pNodeListItem->Element());

            // Walk back siblings collection
            while ((pNodeSibling = ci.PreviousChild()) != NULL)
            {
                const CFancyFormat * pFFSibling = pNodeSibling->GetFancyFormat();

                if (   pFFSibling->_bDisplay != styleDisplayNone
                    && pNodeSibling->Tag() != ETAG_RAW_COMMENT)
                {
                    // If a sibling is a list item LI and it has a 'value', use it as a base number.
                    if (   pNodeSibling->Tag() == ETAG_LI
                        && pFFSibling->IsListItem())
                    {
                        CLIElement * pLIElement = DYNCAST(CLIElement, pNodeSibling->Element());
                        if (pLIElement->GetAAvalue() > 0)
                        {
                            pLV->_lValue += pLIElement->GetAAvalue();
                            break;
                        }
                    }

                    // Otherwise continue enumeraiton.
                    ++pLV->_lValue;
                }
            }

            // If we didn't find LI with a valid 'value' attribute, add list starting number.
            if (!pNodeSibling && lStart > 0)
            {
                pLV->_lValue += lStart - 1;
            }
        }
    }

    if (pLV->_style == styleListStyleTypeNotSet)
        pLV->_style  = styleListStyleTypeDisc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\numconv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       numconv.cxx
//
//  Contents:   Numeral String Conversions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#if defined(UNIX) || defined(_MAC)
/***
*wchar_t *_wcsrev(string) - reverse a wide-character string in place
*
*Purpose:
*       Reverses the order of characters in the string.  The terminating
*       null character remains in place (wide-characters).
*
*Entry:
*       wchar_t *string - string to reverse
*
*Exit:
*       returns string - now with reversed characters
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsrev (
        wchar_t * string
        )
{
        wchar_t *start = string;
        wchar_t *left = string;
        wchar_t ch;

        while (*string++)                 /* find end of string */
                ;
        string -= 2;

        while (left < string)
        {
                ch = *left;
                *left++ = *string;
                *string-- = ch;
        }

        return(start);
}

#endif // UNIX

//+----------------------------------------------------------------------
//
//  Function:   RomanNumberHelper( pn, nDivisor, szBuffer, szRomanLetter )
//
//              Computes the roman numeral for a single decimal-digit
//              equivalent.
//
//              *pn contains the current value.  We determine the string
//              that corresponds to a single decimal digit.
//
//              nDivisor is the power of 10 for which we are computing
//              the substring.
//
//              szBuffer is the pointer into the buffer into which the
//              string is written.
//
//              szRomanLetter is a three character buffer which contains
//              the 1-digit, the 5-digit, and the 10-digit, in that
//              order.  For example, when computing the unit position,
//              szRomanLetter is "ivx".
//
//  Returns:    The value of *pn is changed to the modulo of the original.
//              The roman 'digit' is written into szBuffer.
//              The updated string pointer into szBuffer is returned.
//
//-----------------------------------------------------------------------

static TCHAR * RomanNumberHelper(
    LONG *pn,
    LONG nDivisor,
    TCHAR * szBuffer,
    TCHAR * szRomanLetter )
{
    LONG digit = *pn / nDivisor;
    *pn %= nDivisor;

    if (digit > 4 && digit < 9)
        *szBuffer++ = szRomanLetter[1];

    switch (digit%5)
    {
        case 3:
            *szBuffer++ = szRomanLetter[0];
        case 2:
            *szBuffer++ = szRomanLetter[0];
        case 4:
        case 1:
            *szBuffer++ = szRomanLetter[0];
            break;
    }

    if (4 == digit)
        *szBuffer++ = szRomanLetter[1];
    else if (9 == digit)
        *szBuffer++ = szRomanLetter[2];

    return szBuffer;
}
                       
//+----------------------------------------------------------------------
//
//  Function:   RomanNumber( n, szBuffer, achRomanChars )
//
//              Convert a long value to its roman numeral equivalent.
//              We can process any value between 1 and 3999.
//              We call RomanNumberHelper() for each power of 10.
//
//  Returns:    A roman numeral string in achRomanChars[].
//
//-----------------------------------------------------------------------

static void RomanNumber(
    LONG    n,
    TCHAR * szBuffer,
    TCHAR * achRomanChars )
{
    // Emulate IE behavior -- numbers in excess of 3999 just render as
    // arabic numerals.  Netscape does weird module + offset; 4000 is
    // rendered as ii, etc.

    if (n < 1 || n > 3999)
    {
        NumberToNumeral(n, szBuffer);
    }
    else
    {
        TCHAR *p = szBuffer;

        p = RomanNumberHelper( &n, 1000, p, achRomanChars );
        p = RomanNumberHelper( &n, 100, p, achRomanChars + 3 );
        p = RomanNumberHelper( &n, 10, p, achRomanChars + 6 );
        p = RomanNumberHelper( &n, 1, p, achRomanChars + 9 );

        *p++ = _T('.');
        *p = _T('\0');
    }
}
                          
//+----------------------------------------------------------------------
//
//  Function:   NumberToRomanUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to it's roman numeral equivalent.
//              The letters used here are in lowercase.
//
//  Returns:    Returns a roman number in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToRomanLower(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    RomanNumber(n, achBuffer, _T("m??cdmxlcivx"));
}

//+----------------------------------------------------------------------
//
//  Function:   NumberToRomanUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to it's roman numeral equivalent.
//              The letters used here are in uppercase.
//
//  Returns:    Returns a roman number in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToRomanUpper(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    RomanNumber(n, achBuffer, _T("M??CDMXLCIVX"));
}

//+----------------------------------------------------------------------
//
//  Function:   AlphaNumber( n, szBuffer, chBase )
//
//              A helper function for NumberToRoman(Upper|Lower).
//              Pass in either 'a' or 'A' in chBase to get an
//              'alphabetic' number of n.
//
//              Zero are represented as @. (a hack.)
//              Negative numbers are represented as would decimal
//              numbers, ie with a preceeding minus sign (another hack.)
//
//  Returns:    Returns an 'alphabetic' number in szBuffer.
//
//-----------------------------------------------------------------------

static void AlphaNumber(
    LONG    n,
    TCHAR * szBuffer,
    TCHAR   chBase )
{
    TCHAR *p = szBuffer;

    if (n)
    {
        LONG m = abs(n);

        // It is easier to compute from the least-significant 'digit',
        // so we generate the string backwards, and then reverse it
        // at the end.
        
        *p++ = '.';

        while (m)
        {
            m--;
            *p++ = (TCHAR)(chBase + (m % 26));
            m /= 26;        
        }

        if (n < 0)
        {
            // A nerdly hack to represent negative numbers.

            *p++ = _T('-');
        }

        *p = _T('\0');

        _tcsrev(szBuffer);

        
    }
    else
    {
        // A nerdly hack to represent zero.

        *p++ = _T('@');
        *p++ = _T('.');
        *p++ = _T('\0');
    }
}
                          
//+----------------------------------------------------------------------
//
//  Function:   NumberToAlphaUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to a 'alphabetic' string.  An
//              alphabetic string is a,b,..z,aa,ab,..,ba,..,zz,aaa, etc.
//              The letters used here will be in lowercase.
//
//  Returns:    A string in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToAlphaLower(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    AlphaNumber(n, achBuffer, _T('a'));
}

//+----------------------------------------------------------------------
//
//  Function:   NumberToAlphaUpper( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to a 'alphabetic' string.  An
//              alphabetic string is A,B,..Z,AA,AB,..,BA,..,ZZ,AAA, etc.
//              The letters used here will be in uppercase.
//
//  Returns:    A string in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToAlphaUpper(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    AlphaNumber(n, achBuffer, _T('A'));
}

//+----------------------------------------------------------------------
//
//  Function:   NumberToNumeral( n, achBuffer[NUMCONV_STRLEN] )
//
//              Convert a long value to a numeric string.
//
//  Returns:    A string in achBuffer.
//
//-----------------------------------------------------------------------

void NumberToNumeral(LONG n, TCHAR achBuffer[NUMCONV_STRLEN])
{
    _ltot(n, achBuffer, 10);
    _tcscat(achBuffer, _T("."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\omrect.cxx ===
//=================================================================
//
//   File:      omrect.cxx
//
//  Contents:   COMRect and COMRectCollection classes
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OMRECT_HXX_
#define X_OMRECT_HXX_
#include "omrect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "omrect.hdl"

MtDefine(COMRect, ObjectModel, "COMRect")
MtDefine(COMRectCollection, ObjectModel, "COMRectCollections")
MtDefine(COMRectCollection_aryRects_pv, COMRectCollection, "COMRectCollection::::aryRects::pv")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COMRect::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLRect,                 // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+---------------------------------------------------------------
//
//  Member  : COMRect::COMRect(RECT *)
//
//  Sysnopsis : Constructs an COMRect instance given a rect pointer
//
//----------------------------------------------------------------

COMRect::COMRect(RECT *pRect)
{
    Assert(pRect);
    CopyRect(&_Rect, pRect);
}


//+---------------------------------------------------------------
//
//  Member  : COMRect::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COMRect::PrivateQueryInterface(REFIID iid, void **ppv)
{
    if(!ppv)
        return E_POINTER;
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLRect)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member  : COMRect::get_left
//
//  Sysnopsis : Returns the "left" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_left(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.left;

Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_left
//
//  Sysnopsis : Sets the "left" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_left(long lVal)
{
    _Rect.left = lVal;
    return SetErrorInfo(S_OK);
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::get_top
//
//  Sysnopsis : Returns the "top" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_top(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.top;
    
Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_top
//
//  Sysnopsis : Sets the "top" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_top(long lVal)
{
    _Rect.top = lVal;
    return SetErrorInfo(S_OK);
}


//+---------------------------------------------------------------
//
//  Member  : COMRect::get_right
//
//  Sysnopsis : Returns the "right" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_right(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.right;
    
Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_right
//
//  Sysnopsis : Sets the "right" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_right(long lVal)
{
    _Rect.right = lVal;
    return SetErrorInfo(S_OK);
}


//+---------------------------------------------------------------
//
//  Member  : COMRect::get_bottom
//
//  Sysnopsis : Returns the "bottom" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::get_bottom(long * plVal)
{
	HRESULT hr = S_OK;
    
	if(!plVal)
	{
        hr = E_POINTER;
		goto Cleanup;
	}

    *plVal = _Rect.bottom;
    
Cleanup:
	RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------
//
//  Member  : COMRect::put_bottom
//
//  Sysnopsis : Sets the "bottom" property of the rect
//
//----------------------------------------------------------------

HRESULT
COMRect::put_bottom(long lVal)
{
    _Rect.bottom = lVal;
    return SetErrorInfo(S_OK);
}


//
//============================================================================
//


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::~COMRectCollection
//
//----------------------------------------------------------------

COMRectCollection::~COMRectCollection()
{
    _aryRects.ReleaseAll();
}


//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COMRectCollection::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLRectCollection,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COMRectCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    if(!ppv)
        return E_POINTER;
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLRectCollection)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::length
//
//  Sysnopsis : Returns number of elements in the collection
//
//----------------------------------------------------------------

HRESULT
COMRectCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    // Simply return the array size
    *pLength = _aryRects.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::item
//
//  Sysnopsis : Returns rect at given index
//----------------------------------------------------------------

HRESULT
COMRectCollection::item(VARIANT * pvarIndex, VARIANT * pvarRet)
{
    HRESULT   hr = S_OK;
    CVariant  varArg;
    long      lIndex;

    if (!pvarRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // ECMA rule - return empty for access beyond array bounds
    V_VT(pvarRet) = VT_EMPTY;

    // first attempt ordinal access...
    hr = THR(varArg.CoerceVariantArg(pvarIndex, VT_I4));
    if (hr==S_OK)
    {
        lIndex = V_I4(&varArg);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItem(lIndex, pvarRet));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
COMRectCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryRects.EnumVARIANT(VT_DISPATCH,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::SetRects
//
//  Sysnopsis : Get the rects from given array of rects and save
//              them into the member array.
//
//----------------------------------------------------------------

HRESULT 
COMRectCollection::SetRects(CDataAry<RECT> *pSrcRect)
{
    HRESULT   hr = S_OK;
    int       nNumRects;
    COMRect * pOMRect;

    Assert(pSrcRect);
    nNumRects = pSrcRect->Size();
    Assert(nNumRects > 0);

    _aryRects.Grow(nNumRects);

    for(int i = 0; i < nNumRects; i++)
    {
        pOMRect = new COMRect(&(*pSrcRect)[i]);
        if (!pOMRect)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _aryRects[i] = pOMRect;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::FindByName
//
//  Sysnopsis : This function seraches for an item having given
//                name in the collection and returns its index.
//                It returns -1 if item is not found.
//              We do not support named items for rectangle 
//               collection so we always return a -1
//----------------------------------------------------------------
long 
COMRectCollection::FindByName(LPCTSTR pszName, BOOL fCaseSensitive)
{
    return -1;
}

//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::GetName
//
//  Sysnopsis : This virtual function returns the name of given item.
//              We do not support named collection access.
//----------------------------------------------------------------

LPCTSTR 
COMRectCollection::GetName(long lIdx)
{
    return NULL;
}


//+---------------------------------------------------------------
//
//  Member  : COMRectCollection::GetItem
//
//  Sysnopsis : Returns the item that has given order in the collection.
//              If the index is out of range returns S_FALSE.
//              If ppDisp is NULL only checks that range and returns
//               S_OK if index is in range, S_FALSE if out
//
//----------------------------------------------------------------

HRESULT 
COMRectCollection::GetItem( long lIndex, VARIANT *pvar )
{
    HRESULT hr;
    COMRect * pRect;

    if (lIndex < 0 || lIndex >= _aryRects.Size())
    {
        hr = S_FALSE;
		if(pvar)
			V_DISPATCH(pvar) = NULL;
        goto Cleanup;
    }

    if(!pvar)
    {
        // No ppDisp, caller wanted only to check for correct range
        hr = S_OK;
        goto Cleanup;
    }

    V_DISPATCH(pvar) = NULL;

    pRect = _aryRects[lIndex];
    Assert(pRect);
    hr = THR(pRect->PrivateQueryInterface(IID_IDispatch, (void **) &V_DISPATCH(pvar)));
    if (hr)
        goto Cleanup;

    V_VT(pvar) = VT_DISPATCH;
Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\datcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       datcache.cxx
//
//  Contents:   Data Cache (CDataCache class and related)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DATCACHE_HXX_
#define X_DATCACHE_HXX_
#include "datcache.hxx"
#endif

PerfDbgTag(tagDataCacheDisable, "DataCache", "Disable sharing entries (to find leaks)");
MtDefine(CDataCacheBase, Tree, "CDataCacheBase")
MtDefine(CDataCacheBaseMetrics, Metrics, "CDataCacheBase metrics");
MtDefine(CDataCacheBaseHits,  CDataCacheBaseMetrics, "CDataCacheBase hits")
MtDefine(CDataCacheBaseTotal, CDataCacheBaseMetrics, "CDataCacheBase total")

#define celGrow 8

#if DBG==1
#define TO_HASHING   30
#define FROM_HASHING 20
#else
#define TO_HASHING   200
#define FROM_HASHING 150
#endif

#if DBG==1
#define CheckFreeChain()\
            CheckFreeChainFn()
#else
#define CheckFreeChain()
#endif


// ===============================  CDataCacheBase  =================================


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::constructor
//
//  Synopsis:
//
//  Returns:
//
//-------------------------------------------------------------------------

CDataCacheBase::CDataCacheBase() : _HtCrcI()
{
    _pael = NULL;
    _cel = 0;
    _ielFirstFree = -1;
    _fSwitched = FALSE;
    _HtCrcI.SetCallBack(this, CompareIt);
    _celsInCache = 0;
#if DBG==1
    _cMaxEls     = 0;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Add
//
//  Synopsis:   Add a new DATA to the cache.
//
//  Arguments:  pvData - DATA to add to the cache
//              piel  - return index of DATA in the cache
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  Note:       This DO NOT addref the new data in the cache
//
//-------------------------------------------------------------------------

HRESULT CDataCacheBase::Add(const void * pvData, LONG *piel, BOOL fClone)
{
    HRESULT hr = S_OK;
    CDataCacheElem *pel;
    LONG iel;
    LONG ielRet = NULL;
    CDataCacheElem *pelRet;

    if (_ielFirstFree >= 0)             // Return first element of free list
    {
        ielRet = _ielFirstFree;

        hr = InitData(Elem(ielRet), pvData, fClone);
        if(hr)
            goto Cleanup;

        pelRet = Elem(ielRet);
        _ielFirstFree = pelRet->_ielNextFree;
    }
    else                                // All lower positions taken: need
    {                                   //  to add another celGrow elements
        pel = _pael;
        hr = MemRealloc(Mt(CDataCacheBase), (void **) & pel, (_cel + celGrow) * sizeof(CDataCacheElem));
        if(hr)
            goto Cleanup;
        MemSetName((pel, "CDataCacheBase data - %d elements", _cel + celGrow));
        _pael = pel;

        ielRet = _cel;
        pelRet = pel + ielRet;
        _cel += celGrow;

#if DBG==1
        pelRet->_pvData = NULL;
#endif

        hr = InitData(pelRet, pvData, fClone);
        if(hr)
        {
            // Put all added elements in free list
            iel = ielRet;
        }
        else
        {
            // Use first added element
            // Put next element and subsequent ones added in free list
            iel = ielRet + 1;
        }

        // Add non yet used elements to free list
        _ielFirstFree = iel;

        for(pel = Elem(iel); ++iel < _cel; pel++)
        {
            pel->_pvData = NULL;
            pel->_ielNextFree = iel;
        }

        // Mark last element in free list
        pel->_pvData = NULL;
        pel->_ielNextFree = -1;
    }

    if(!hr)
    {
        Assert(pelRet);
        Assert(pelRet->_pvData);
        DWORD dwCrc = ComputeDataCrc(pelRet->_pvData);
        pelRet->_dwCrc = dwCrc;
        pelRet->_cRef = 0;
        if (_fSwitched)
        {
#if DBG==1
            _HtCrcI.Insert(ULongToPtr(pelRet->_dwCrc), ULongToPtr(ielRet), pelRet->_pvData);
#else
            _HtCrcI.Insert(ULongToPtr(pelRet->_dwCrc), ULongToPtr(ielRet));
#endif
        }

        if(piel)
            *piel = ielRet;
    }

    _celsInCache++;
#if DBG == 1
    _cMaxEls = max(_cMaxEls, _celsInCache);
#endif

    if (  !_fSwitched
        && _celsInCache >= TO_HASHING
       )
    {
        CDataCacheElem *pel;
        LONG iel;
        HRESULT hr = S_OK;
        WHEN_DBG(LONG celsAdded = 0;)

        for (iel = 0, pel = Elem(0); iel < _cel; pel++, iel++)
        {
            if (pel->_pvData)
            {
#if DBG==1
                hr = _HtCrcI.Insert(ULongToPtr(pel->_dwCrc), ULongToPtr(iel), pel->_pvData);
#else
                hr = _HtCrcI.Insert(ULongToPtr(pel->_dwCrc), ULongToPtr(iel));
#endif
                if (hr != S_OK)
                {
                    _HtCrcI.ReInit();
                    break;
                }
                WHEN_DBG(celsAdded++;)
            }
        }
        if (hr == S_OK)
        {
            Assert(celsAdded == _celsInCache);
            _fSwitched = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Free(iel)
//
//  Synopsis:   Free up a DATA in the cache by moving it to the
//              free list
//
//  Arguments:  iel  - index of DATA to free in the cache
//
//  Returns:    none
//
//-------------------------------------------------------------------------

void CDataCacheBase::Free(LONG iel)
{
    CDataCacheElem * pElem = Elem(iel);

    Assert(pElem->_pvData);

    if (_fSwitched)
    {
        if (_celsInCache < FROM_HASHING)
        {
            _HtCrcI.ReInit();
            _fSwitched = FALSE;
        }
        else
        {
#if DBG==1
            LONG ielRemoved = (LONG)(LONG_PTR)_HtCrcI.Remove(ULongToPtr(pElem->_dwCrc), pElem->_pvData);
            Assert(ielRemoved == iel);
#else
            _HtCrcI.Remove(ULongToPtr(pElem->_dwCrc), pElem->_pvData);
#endif
        }
    }

    // Passivate data
    PassivateData(pElem);

    // Add it to free list
    pElem->_ielNextFree = _ielFirstFree;
    _ielFirstFree = iel;

    // Flag it's freed
    pElem->_pvData = NULL;

    _celsInCache--;

    Assert( _celsInCache >=0 );
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Free()
//
//  Synopsis:   Free up entire cache and deallocate memory
//
//-------------------------------------------------------------------------

void CDataCacheBase::Free()
{
#if DBG==1
    LONG   iel;
    static BOOL fAssertDone = FALSE;

    if (!fAssertDone)
    {
        for(iel = 0; iel < _cel; iel++)
        {
            if(Elem(iel)->_pvData != NULL)
            {
                TraceTag((tagError, "Cel : %d", iel));
                AssertSz(FALSE, "CDataCacheBase::Free() - one or more cells not Empty");
                // Don't put up more than one assert
                fAssertDone = TRUE;
                break;
            }
        }
    }
#endif

    MemFree(_pael);
    _HtCrcI.ReInit();

    _pael = NULL;
    _cel = 0;
    _ielFirstFree = -1;
    _celsInCache = 0;
    _fSwitched = FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::Find(iel)
//
//  Synopsis:   Find given DATA in the cache and returns its index
//
//  Arguments:  pvData  - data to lookup
//
//  Returns:    index of DATA in the cache, -1 if not found
//
//-------------------------------------------------------------------------
LONG CDataCacheBase::Find(const void * pvData) const
{
    DWORD dwCrc = ComputeDataCrc(pvData);
    void *pVal;
    LONG iel;

    if (_fSwitched)
    {
        if (((CHtPvPv*)&_HtCrcI)->LookupSlow(ULongToPtr(dwCrc), (void*)pvData, &pVal) == S_OK)
            iel = PtrToInt(pVal);
        else
            iel = -1;
    }
    else
    {
        for(iel = 0; iel < _cel; iel++)
        {
            CDataCacheElem * pElem = Elem(iel);
            if(pElem->_pvData && pElem->_dwCrc == dwCrc)
            {
                if(CompareData(pvData, pElem->_pvData))
                {
                    goto done;
                }
            }
        }
        iel = -1;
    }

    Assert(iel == FindSlow(pvData));
done:
    return iel;
}

#if DBG==1
LONG CDataCacheBase::FindSlow(const void * pvData) const
{
    LONG iel;
    DWORD dwCrc;

    CheckFreeChain();

    dwCrc = ComputeDataCrc(pvData);

    for(iel = 0; iel < _cel; iel++)
    {
        CDataCacheElem * pElem = Elem(iel);
        if(pElem->_pvData && pElem->_dwCrc == dwCrc)
        {
            if(CompareData(pvData, pElem->_pvData))
            {
                return iel;
            }
        }
    }
    return -1;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::CheckFreeChain(iel)
//
//  Synopsis:   Check validity of the free chain
//
//  Arguments:  iel  - index of DATA to free in the cache
//
//  Returns:    none
//
//-------------------------------------------------------------------------

#if DBG==1

void CDataCacheBase::CheckFreeChainFn() const
{
    LONG cel = 0;
    LONG iel = _ielFirstFree;

    while(iel > 0)
    {
        AssertSz(iel == -1 || iel <= _cel, "CDataCacheBase::CheckFreeChain() - Elem points to out of range elem");

        iel = Elem(iel)->_ielNextFree;

        if (++cel > _cel)
        {
            AssertSz(FALSE, "CDataCacheBase::CheckFreeChain() - Free chain seems to contain an infinite loop");
            return;
        }
    }
}

#endif


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::ReleaseData(iel)
//
//  Synopsis:   Decrement the ref count of DATA of given index in the cache
//              Free it if ref count goes to 0
//
//  Arguments:  iel  - index of DATA to release in the cache
//
//  Returns:    none
//
//-------------------------------------------------------------------------

void CDataCacheBase::ReleaseData(LONG iel)
{
    CheckFreeChain();

    Assert( iel >= 0 );
    Assert(Elem(iel)->_pvData);
    Assert(Elem(iel)->_cRef > 0);

    if(--(Elem(iel)->_cRef) == 0)         // Entry no longer referenced
        Free (iel);                         // Add it to the free chain
}

//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::CacheData(*pvData, *piel, *pfDelete, fClone)
//
//  Synopsis:   Cache new DATA. This looks up the DATA and if found returns
//              its index and addref it, otherwise adds it to the cache.
//
//  Arguments:  pvData - DATA to add to the cache
//              piel  - return index of DATA in the cache
//              pfDelete - returns whether or not to delete pvData on success
//              fClone - tells whether to clone or copy pointer
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-------------------------------------------------------------------------

HRESULT
CDataCacheBase::CacheData(const void *pvData, LONG *piel, BOOL *pfDelete, BOOL fClone)
{
    HRESULT hr = S_OK;
    LONG iel = Find(pvData);

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDataCacheDisable))
        iel = -1;
#endif

    if (pfDelete)
    {
        *pfDelete = FALSE;
    }

    if(iel >= 0)
    {
       MtAdd(Mt(CDataCacheBaseHits), 1, 0);
       Assert(Elem(iel)->_pvData);
       if (pfDelete)
       {
           *pfDelete = TRUE;
       }
    }
    else
    {
        hr = THR(Add(pvData, &iel, fClone));
        if(hr)
            goto Cleanup;
    }

    MtAdd(Mt(CDataCacheBaseTotal), 1, 0);
    AddRefData(iel);

    CheckFreeChain();

    if(piel)
    {
        *piel = iel;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDataCacheBase::CacheDataPointer(**ppvData, *piel)
//
//  Synopsis:   Caches new data via CacheData, but does not clone.
//              On success, it takes care of memory management of input data.
//
//  Arguments:  ppvData - DATA to add to the cache
//              piel  - return index of DATA in the cache
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-------------------------------------------------------------------------

HRESULT CDataCacheBase::CacheDataPointer(void **ppvData, LONG *piel) {
    BOOL fDelete;
    HRESULT hr;

    Assert(ppvData);
    hr = CacheData(*ppvData, piel, &fDelete, FALSE);
    if (!hr)
    {
        if (fDelete)
        {
            DeletePtr(*ppvData);
        }
        *ppvData = NULL;
    }
    RRETURN(hr);
}

BOOL CDataCacheBase::CompareIt(const void *pObject, const void *pvKeyPassedIn, const void *pvVal2)
{
    CDataCacheBase *pBase = (CDataCacheBase*)pObject;
    long index = (long)PtrToInt(pvVal2);
    return pBase->CompareData(pvKeyPassedIn, pBase->Elem(index)->_pvData);
}

#if DBG==1
extern void __cdecl WriteHelp(HANDLE hFile, TCHAR *format, ...);
extern void WriteString(HANDLE hFile, TCHAR *pszStr);

void DumpCharFormat(HANDLE hfile, int i, const CCharFormat * pCF)
{
    Assert(pCF);

    WriteHelp(hfile, _T("<<div class=c<0d>>\r\n"), i%5);
    WriteString(hfile, _T("<B class=cc>+</B><B class=ff style='display:none'>-</B>\r\n"));
    WriteHelp(hfile, _T("<<u><<b>CharFormat: <0d> (Crc:<1x>)<</b><</u><<br>\r\n"), i, pCF->ComputeCrc());

    WriteString(hfile, _T("<span class=c style='display:none'>\r\n"));

    WriteHelp(hfile, _T("<<table><<tr><<td rowspan=8><<b>Flags:<</b><0x><</td><</tr>\r\n"), (pCF->_wFlagsVar << 16 | pCF->_wFontSpecificFlagsVar));

    WriteHelp(hfile, _T("<<tr><<td><<b>Underline:<</b><0d><</td><<td><<b>NoBreak:<</b><1d><</td><<td><<b>NoBreakInner:<</b><2d><</td><<td><<b>StrikeOut:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fUnderline ? 1 : 0, pCF->_fNoBreak ? 1 : 0, pCF->_fNoBreakInner ? 1 : 0, pCF->_fStrikeOut ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>VisibilityHidden:<</b><0d><</td><<td><<b>Display:<</b><1d><</td><</tr>\r\n"),
                        pCF->_fVisibilityHidden ? 1 : 0, pCF->_fDisplayNone ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>Disabled:<</b><0d><</td><<td><<b>BgColor:<</b><1d><</td><<td><<b>BgImage:<</b><2d><</td><<td><<b>Overline:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fDisabled ? 1 : 0, pCF->_fHasBgColor ? 1 : 0, pCF->_fHasBgImage ? 1 : 0, pCF->_fOverline ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>Relative:<</b><0d><</td><<td><<b>ExplicitFace:<</b><1d><</td><<td>&nbsp;<</td><</tr>\r\n"),
                        pCF->_fRelative ? 1 : 0, pCF->_fExplicitFace ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>Bold:<</b><0d><</td><<td><<b>Italic:<</b><1d><</td><<td><<b>Sup:<</b><2d><</td><<td><<b>Sub:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fBold ? 1 : 0, pCF->_fItalic ? 1 : 0, pCF->_fSuperscript ? 1 : 0, pCF->_fSubscript ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>RTL:<</b><0d><</td><<td><<b>BidiEmbed:<</b><1d><</td><<td><<b>BidiOverride:<</b><2d><</td><</tr>\r\n"),
                        pCF->_fRTL ? 1 : 0, pCF->_fBidiEmbed ? 1 : 0, pCF->_fBidiOverride ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>BumpSizeDown:<</b><0d><</td><<td><<b>Password:<</b><1d><</td><<td><<b>Protected:<</b><2d><</td><<td><<b>SizeDontScale:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fBumpSizeDown ? 1 : 0, pCF->_fPassword ? 1 : 0, pCF->_fProtected ? 1 : 0, pCF->_fSizeDontScale ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>DownloadedFont:<</b><0d><</td><<td><<b>IsPrintDoc:<</b><1d><</td><<td><<b>SubSuperSized:<</b><2d><</td><<td><<b>Accelerator:<</b><3d><</td><</tr>\r\n"),
                        pCF->_fDownloadedFont ? 1 : 0, pCF->_fIsPrintDoc ? 1 : 0, pCF->_fSubSuperSized ? 1 : 0, pCF->_fAccelerator ? 1 : 0);


    WriteHelp(hfile, _T("<<tr><<td rowspan=5><</td><<td><<b>Weight:<</b><0d><</td><<td><<b>Kerning:<</b><1d><</td><<td><<b>Height:<</b><2d><</td><</tr>\r\n"),
                        pCF->_wWeight, pCF->_wKerning, pCF->_yHeight);

    WriteHelp(hfile, _T("<<tr><<td><<b>lcid:<</b><0d><</td><<td><<b>CharSet:<</b><1d><</td><<td><<b>PitchAndFamily:<</b><2d><</tr>\r\n"),
                        pCF->_lcid, pCF->_bCharSet, pCF->_bPitchAndFamily);

    WriteHelp(hfile, _T("<<tr><<td><<b>LetterSpacing:<</b><0d><</td><<td><<b>LineHeight:<</b><1d><</td><<td><<b>PadBord:<</b><2d><</td><<td><<b>SCBumpSizeDown:<</b><3d><</td><</tr>\r\n"),
                        pCF->_cuvLetterSpacing, pCF->_cuvLineHeight, pCF->_fPadBord, pCF->_fSCBumpSizeDown ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>TextColor:<</b><0x> <</td><<td><<b>CursorIdx:<</b><1d><</td><<td><<b>FaceName:<</b><2s><</td><<td><<b>TxtTransform:<</b><3d><</td><</tr>\r\n"),
                        pCF->_ccvTextColor, pCF->_bCursorIdx, pCF->GetFaceName(), pCF->_bTextTransform);

    WriteString(hfile, _T("</table></span></div>\r\n"));
}

void DumpParaFormat(HANDLE hfile, int i, const CParaFormat * pPF)
{
    Assert(pPF);

    WriteHelp(hfile, _T("<<div class=c<0d>>\r\n"), i%5);
    WriteString(hfile, _T("<B class=cc>+</B><B class=ff style='display:none'>-</B>\r\n"));
    WriteHelp(hfile, _T("<<u><<b>ParaFormat: <0d> (Crc:<1x>)<</b><</u><<br>\r\n"), i, pPF->ComputeCrc());

    WriteString(hfile, _T("<span class=c style='display:none'>\r\n"));

    WriteHelp(hfile, _T("<<table><<tr><<td rowspan=4><<b>Flags:<</b><0x><</td><</tr>\r\n"), pPF->_dwFlagsVar);

    WriteHelp(hfile, _T("<<tr><<td><<b>Pre: <0d><</td><<td><<b>TabStops: <1d><</td><<td><<b>CompactDL: <2d><</td><</tr>\r\n"),
                        pPF->_fPre, pPF->_fTabStops, pPF->_fCompactDL);

    WriteHelp(hfile, _T("<<tr><<td><<b>InclEOLWhite: <0d><</td><<td><<b>ResetDLLevel: <1d><</td><</tr>\r\n"),
                        pPF->_fInclEOLWhite, pPF->_fResetDLLevel);

    WriteHelp(hfile, _T("<<tr><<td rowspan=7><</td><<td><<b>BlockAlign: <0d><</td><<td><<b>TableVAlignment: <1d><</td><<td><<b>TabCount: <2d><</td><</tr>\r\n"),
                        pPF->_bBlockAlign, pPF->_bTableVAlignment, pPF->_cTabCount);

    WriteHelp(hfile, _T("<<tr><<td><<b>Listing: <0d><</td><<td><<b>NumberingStart: <1d><</td><<td><<b> ListPosition: <2d><</td><<td><<b>FontHeightTwips: <3d><</td><</tr>\r\n"),
                        pPF->_cListing, pPF->_lNumberingStart, pPF->_bListPosition, pPF->_lFontHeightTwips);

    WriteHelp(hfile, _T("<<tr><<td><<b>LeftIndentPoints: <0d><</td><<td><<b>LeftIndentPercent: <1d><</td><<td><<b>RightIndentPoints: <2d><</td><<td><<b>RightIndentPercent: <3d><</td><</tr>\r\n"),
                        pPF->_cuvLeftIndentPoints, pPF->_cuvLeftIndentPercent,
                        pPF->_cuvRightIndentPoints, pPF->_cuvRightIndentPercent);

    WriteHelp(hfile, _T("<<tr><<td><<b>NonBulletIndentPoints: <0d><</td><<td><<b>OffsetPoints: <1d><</td><<td><<b>ListyStyleType: <2d><</td><</tr>\r\n"),
                        pPF->_cuvNonBulletIndentPoints, pPF->_cuvOffsetPoints, pPF->GetListStyleType());

    WriteHelp(hfile, _T("<<tr><<td><<b>ImgCookie: <1d><</td><<td><<b>TextIndent: <2d><</td><<td><<b>InnerRTL: <2d><</td><<td><<b>OuterRTL: <3d><</td><</tr>\r\n"),
                        pPF->_lImgCookie, pPF->_cuvTextIndent,
                        pPF->HasRTL(TRUE) ? 1 : 0, pPF->HasRTL(FALSE) ? 1 : 0);

    WriteString(hfile, _T("</table></span></div>\r\n"));
}

void DumpFancyFormat(HANDLE hfile, int i, const CFancyFormat * pFF)
{
    Assert(pFF);

    WriteHelp(hfile, _T("<<div class=c<0d>>\r\n"), i%5);
    WriteString(hfile, _T("<B class=cc>+</B><B class=ff style='display:none'>-</B>\r\n"));
    WriteHelp(hfile, _T("<<u><<b>FancyFormat: <0d> (Crc:<1x>)<</b><</u><<br>\r\n"), i, pFF->ComputeCrc());

    WriteString(hfile, _T("<span class=c style='display:none'>\r\n"));

    WriteHelp(hfile, _T("<<table><<tr><<td rowspan=5><<b>Flags1:<</b><0x><</td><</tr>\r\n"), pFF->_dwFlagsVar1);

    WriteHelp(hfile, _T("<<tr><<td><<b>BgRepeatX:<</b><0d><</td><<td><<b>BgRepeatY:<</b><1d><</td><<td><<b>BgFixed:<</b><2d><</td><<td><<b>Relative:<</b><3d><</td><</tr>\r\n"),
        pFF->GetBgRepeatX() ? 1 : 0,
        pFF->GetBgRepeatY() ? 1 : 0,
        pFF->_fBgFixed ? 1 : 0,
        pFF->_fRelative ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderSoftEdges:<</b><0d><</td><<td><<b>BorderColorsSetUnique:<</b><1d><</td><<td><</td><<td><</td><</tr>\r\n"),
        pFF->_bd._bBorderSoftEdges ? 1 : 0,
        pFF->_bd._bBorderColorsSetUnique ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>ExplicitLeftMargin:<</b><0d><</td><<td><<b>ExplicitRightMargin:<</b><1d><</td><<td><<b>ExplicitTopMargin:<</b><2d>,  <</td><<td><<b>ExplicitBottomMargin:<</b><3d><</td><</tr>\r\n"),
        pFF->HasExplicitMargin(SIDE_LEFT) ? 1 : 0,
        pFF->HasExplicitMargin(SIDE_RIGHT) ? 1 : 0,
        pFF->HasExplicitMargin(SIDE_TOP) ? 1 : 0,
        pFF->HasExplicitMargin(SIDE_BOTTOM) ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>BlockNess:<</b><0d><</td><<td><<b>ShouldHaveLayout:<</b><1d><</td><<td><<b>AlignedLayout:<</b><2d><</td><<td><<b>CtrlAlignFromCSS:<</b><3d><</td><</tr>\r\n"),
        pFF->_fBlockNess ? 1 : 0,
        pFF->_fShouldHaveLayout ? 1 : 0,
        pFF->_fAlignedLayout ? 1 : 0,
        pFF->_fCtrlAlignFromCSS ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>HeightPercent:<</b><0d><</td><<td><<b>WidthPercent:<</b><1d><</td><<td><<b>ZParent:<</b><2d><</td><<td><<b>TableLayout:<</b><3d><</td><</tr>\r\n"),
        pFF->IsHeightPercent() ? 1 : 0,
        pFF->IsWidthPercent() ? 1 : 0,
        pFF->_fZParent ? 1 : 0,
        pFF->_bTableLayout);

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderCollapse:<</b><0d><</td><<td><<b>OverrideTablewideBorderDefault:<</b><1d><</td><<td><<b>Positioned:<</b><2d><</td><<td><<b>AutoPositioned:<</b><3d><</td><</tr>\r\n"),
        pFF->_bd._bBorderCollapse ? 1 : 0,
        pFF->_bd._fOverrideTablewideBorderDefault ? 1 : 0,
        pFF->_fPositioned ? 1 : 0,
        pFF->_fAutoPositioned ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>ScrollingParent:<</b><0d><</td><<td><</td><<td><<b>PercentHorzPadding:<</b><2d><</td><<td><<b>PercentVertPadding:<</b><3d><</td><</tr>\r\n"),
        pFF->_fScrollingParent ? 1 : 0,
        pFF->HasPercentHorzPadding() ? 1 : 0,
        pFF->HasPercentVertPadding() ? 1 : 0);

    WriteHelp(hfile, _T("<<tr><<td><<b>HasMargins:<</b><0d><</td><<td><<b>HasExpressions:<</b><1d><</td><<td><<b>HasNoWrap:<</b><2d><</td><<td><<b>ZIndex:<</b><3d><</td><</tr>\r\n"),
        pFF->_fHasMargins ? 1 : 0,
        pFF->_fHasExpressions ? 1 : 0,
        pFF->_fHasNoWrap ? 1 : 0,
        pFF->_lZIndex);

    WriteHelp(hfile, _T("<<tr><<td rowspan=14><</td><<td><<b>PaddingTop:<</b><0d><</td><<td><<b>PaddingRight:<</b><1d><</td><<td><<b>PaddingBottom:<</b><2d><</td><<td><<b>PaddingLeft:<</b><3d><</td><</tr>\r\n"),
        pFF->GetPadding(SIDE_TOP),
        pFF->GetPadding(SIDE_RIGHT),
        pFF->GetPadding(SIDE_BOTTOM),
        pFF->GetPadding(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>SpaceBefore:<</b><0d><</td><<td><<b>SpaceAfter:<</b><1d><</td><<td><<b>Width:<</b><2d><</td><<td><<b>Height:<</b><3d><</td><</tr>\r\n"),
        pFF->_cuvSpaceBefore,
        pFF->_cuvSpaceAfter,
        pFF->GetWidth(),
        pFF->GetHeight());

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderColorTop:<</b><0x> <</td><<td><<b>BorderColorRight:<</b><1x> <</td><<td><<b>BorderColorBottom:<</b><2x> <</td><<td><<b>BorderColorLeft:<</b><3x><</td><</tr>\r\n"),
        pFF->_bd.GetBorderColor(SIDE_TOP),
        pFF->_bd.GetBorderColor(SIDE_RIGHT),
        pFF->_bd.GetBorderColor(SIDE_BOTTOM),
        pFF->_bd.GetBorderColor(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderWidthTop:<</b><0d><</td><<td><<b>BorderWidthRight:<</b><1d><</td><<td><<b>BorderWidthBottom:<</b><2d><</td><<td><<b>BorderWidthLeft:<</b><3d><</td><</tr>\r\n"),
        pFF->_bd.GetBorderWidth(SIDE_TOP),
        pFF->_bd.GetBorderWidth(SIDE_RIGHT),
        pFF->_bd.GetBorderWidth(SIDE_BOTTOM),
        pFF->_bd.GetBorderWidth(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderColorLight:<</b><0x> <</td><<td><<b>BorderColorDark:<</b><1x> <</td><<td><<b>BorderColorHilight:<</b><2x> <</td><<td><<b>BorderColorShadow:<</b><3x><</td><</tr>\r\n"),
        pFF->_bd._ccvBorderColorLight,
        pFF->_bd._ccvBorderColorDark,
        pFF->_bd._ccvBorderColorHilight,
        pFF->_bd._ccvBorderColorShadow);

    WriteHelp(hfile, _T("<<tr><<td><<b>ClipTop:<</b><0d><</td><<td><<b>ClipRight:<</b><1d><</td><<td><<b>ClipBottom:<</b><2d><</td><<td><<b>ClipLeft:<</b><3d><</td><</tr>\r\n"),
        pFF->GetClip(SIDE_TOP),
        pFF->GetClip(SIDE_RIGHT),
        pFF->GetClip(SIDE_BOTTOM),
        pFF->GetClip(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>MarginLeft:<</b><0d><</td><<td><<b>MarginTop:<</b><1d><</td><<td><<b>MarginRight:<</b><2d><</td><<td><<b>MarginBottom:<</b><3d><</td><</tr>\r\n"),
        pFF->GetMargin(SIDE_LEFT),
        pFF->GetMargin(SIDE_TOP),
        pFF->GetMargin(SIDE_RIGHT),
        pFF->GetMargin(SIDE_BOTTOM));

    WriteHelp(hfile, _T("<<tr><<td><<b>BorderStyles(Top:<</b><0d><</td><<td><<b>Right:<</b><1d><</td><<td><<b>Bottom:<</b><2d><</td><<td><<b>Left:<</b><3d>)<</td><</tr>\r\n"),
        pFF->_bd.GetBorderStyle(SIDE_TOP),
        pFF->_bd.GetBorderStyle(SIDE_RIGHT),
        pFF->_bd.GetBorderStyle(SIDE_BOTTOM),
        pFF->_bd.GetBorderStyle(SIDE_LEFT));

    WriteHelp(hfile, _T("<<tr><<td><<b>Filters:<</b><0s><</td><<td><</td><</tr>\r\n"),
        pFF->_pszFilters ? pFF->_pszFilters : _T(""));

    WriteHelp(hfile, _T("<<tr><<td><<b>Top:<</b><0d><</td><<td><<b>Bottom:<</b><1d><</td><<td><<b>Left:<</b><2d><</td><<td><<b>Right:<</b><3d><</td><</tr>\r\n"),
        pFF->GetPosition(SIDE_TOP),
        pFF->GetPosition(SIDE_BOTTOM),
        pFF->GetPosition(SIDE_LEFT),
        pFF->GetPosition(SIDE_RIGHT));

    WriteHelp(hfile, _T("<<tr><<td><<b>BackColor:<</b><0d><</td><<td><<b>BgPosX:<</b><1d><</td><<td><<b>BgPosY:<</b><2d><</td><</tr>\r\n"),
        pFF->_ccvBackColor,
        pFF->GetBgPosX(),
        pFF->GetBgPosY());

    WriteHelp(hfile, _T("<<tr><<td><<b>Padding:<</b><0d><</td><<td><<b>StyleFloat:<</b><1d><</td><<td><</td><<td><<b>Rectangular:<</b><2d><</td><<td><<b>ImgCtxCookie:<</b><3d><</td><</tr>\r\n"),
        pFF->_iPEI,
        pFF->_bStyleFloat,
        pFF->_fRectangular,
        pFF->_lImgCtxCookie); // the doc's bgUrl-imgCtx cache

    WriteHelp(hfile, _T("<<tr><<td><<b>OverflowX:<</b><0d><</td><<td><<b>OverflowY:<</b><1d><</td><<td><<b>VerticalAlign:<</b><2d><</td><<td><<b>CSSVerticalAlign:<</b><3d><</td><</tr>\r\n"),
        pFF->GetOverflowX(),
        pFF->GetOverflowY(),
        pFF->GetVerticalAlign(),
        pFF->HasCSSVerticalAlign());

    WriteHelp(hfile, _T("<<tr><<td><<b>ControlAlign:<</b><0d><</td><<td><<b>PageBreaks:<</b><1d><</td><<td><<b>PositionType:<</b><2d><</td><<td><<b>Expandos:<</b><3d><</td><</tr>\r\n"),
        pFF->_bControlAlign,
        pFF->_bPageBreaks,
        pFF->_bPositionType,
        pFF->_iExpandos);

    WriteHelp(hfile, _T("<<tr><<td><<b>Display:<</b><0d><</td><<td><<b>Visibility:<</b><1d><</td><<td><<b>ClearLeft:<</b><2d><</td><<td><<b>ClearRight:<</b><3d><</td><</tr>\r\n"),
        pFF->_bDisplay,
        pFF->_bVisibility,
        pFF->_fClearLeft ? 1 : 0,
        pFF->_fClearRight ? 1 : 0);

    WriteString(hfile, _T("</table></span></div>\r\n"));
}

void DumpFormatCaches()
{
    CCharFormatCache  * pCFCache = TLS(_pCharFormatCache);
    CParaFormatCache  * pPFCache = TLS(_pParaFormatCache);
    CFancyFormatCache * pFFCache = TLS(_pFancyFormatCache);
    HANDLE              hfile    = CreateFile(_T("c:\\formatcache.htm"),
                                        GENERIC_WRITE | GENERIC_READ,
                                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

    if (hfile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    SetFilePointer( hfile, 0, 0, 0 );

    WriteString( hfile, _T("\
<HTML>\r\n\
<head>\r\n\
<style>\r\n\
div     { padding-left:10; padding-right:10; padding-top:3; padding-bottom:2 }\r\n\
div.root   { background-color:eeeeee }\r\n\
div.c0     { background-color:ffe8e8 }\r\n\
div.c1     { background-color:e8ffff }\r\n\
div.c2     { background-color:e8ffe8 }\r\n\
div.c3     { background-color:ffe8ff }\r\n\
div.c4     { background-color:e8e8ff }\r\n\
H4         { margin-bottom:0; margin-top:10; cursor: hand }\r\n\
u          { cursor: hand }\r\n\
</style>\r\n"));
    WriteString( hfile, _T("\
<script>\r\n\
function OnClick()\r\n\
{\r\n\
  var srcElem = event.srcElement;\r\n\
\r\n\
  while(srcElem && srcElem.tagName != 'DIV')\r\n\
  {\r\n\
     srcElem = srcElem.parentElement;\r\n\
  }\r\n\
\r\n\
  if(srcElem)\r\n\
  {\r\n\
    var elem = srcElem.children.tags('SPAN');\r\n\
    var elem2 = srcElem.children.tags('B');\r\n\
    \r\n\
    if(elem.length > 0 && elem[0].className == 'c')\r\n\
    {\r\n\
      if(elem2.length > 1 && elem2[0].className == 'cc' && elem2[1].className == 'ff')\r\n\
      {\r\n\
        if(elem[0].style.display == '')\r\n\
        {\r\n\
          elem2[0].style.display = '';\r\n\
          elem2[1].style.display = 'none';\r\n\
        }\r\n\
        else\r\n\
        {\r\n\
          elem2[0].style.display = 'none';\r\n\
          elem2[1].style.display = '';\r\n\
        }\r\n\
      }\r\n\
      \r\n\
      elem[0].style.display = elem[0].style.display == '' ? 'none' : '';\r\n\
    }\r\n\
  }\r\n\
}\r\n\
</script>\r\n"));
    WriteString( hfile, _T("\
</head>\r\n\
<body>\r\n\
<span class=rootspan onclick=OnClick()>\r\n\
<div class=foo><B class=cc>+</B><B class=ff style='display:none'>-</B><U><B>Char  Format Cache</B></U><br>\r\n\
  <span class=c style='display:none'>\r\n"));
    if(pCFCache)
    {
        for(int i = 0; i < pCFCache->Size(); i++)
        {
            const CCharFormat * pCF = pCFCache->ElemData(i);

            if(pCF)
                DumpCharFormat(hfile, i, pCF);
        }
    }
    WriteString( hfile, _T("\
  </span>\r\n\
</div>\r\n\
<div class=foo><B class=cc>+</B><B class=ff style='display:none'>-</B><U><B>Para  Format Cache</B></U><br>\r\n\
  <span class=c style='display:none'>\r\n"));

   if(pPFCache)
    {
        for(int i = 0; i < pPFCache->Size(); i++)
        {
            const CParaFormat * pPF =  pPFCache->ElemData(i);

            if(pPF)
                DumpParaFormat(hfile, i, pPF);
        }
    }

    WriteString( hfile, _T("\
  </span>\r\n\
</div>\r\n\
<div class=foo><B class=cc>+</B><B class=ff style='display:none'>-</B><U><B>Fancy  Format Cache</B></U><br>\r\n\
  <span class=c style='display:none'>\r\n"));
   if(pFFCache)
    {
        for(int i = 0; i < pFFCache->Size(); i++)
        {
            const CFancyFormat * pFF = pFFCache->ElemData(i);

            if(pFF)
                DumpFancyFormat(hfile, i, pFF);
        }
    }
    WriteString( hfile, _T("\
  </span>\r\n\
</div>\r\n\
</span>\r\n\
</body>\r\n\
</html>\r\n"));

    CloseHandle(hfile);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\propbag.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       propbag.cxx
//
//  Contents:   CPropertyBag
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

MtDefine(CPropertyBag, ObjectModel, "CPropertyBag")
MtDefine(CPropertyBag_aryProps_pv, CPropertyBag, "CPropertyBag::_aryProps::_pv")
MtDefine(CPropertyBagGetPropertyBagContents_pVar, Locals, "CPropertyBag::GetPropertyBagContents pVar->pbVal")
MtDefine(CPropertyBagGetPropertyBagContents_pch, Locals, "CPropertyBag::GetPropertyBagContents pch")

DeclareTag(tagPropBag, "Property Bag", "Property Bag methods")

//+---------------------------------------------------------------------------
//
//  Member:     PROPNAMEVALUE::Set
//
//  Synopsis:   Initialize the struct with a name value pair.
//
//----------------------------------------------------------------------------

HRESULT
PROPNAMEVALUE::Set(TCHAR *pchPropName, VARIANT *pVar)
{
    HRESULT hr = _cstrName.Set(pchPropName);
    if (hr)
        goto Cleanup;
        
    hr = THR(VariantCopy(&_varValue, pVar));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     PROPNAMEVALUE::Free
//
//  Synopsis:   Free memory associated with this name value pair.
//
//----------------------------------------------------------------------------

void
PROPNAMEVALUE::Free()
{
    _cstrName.Free();
    VariantClear(&_varValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::CPropertyBag
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

CPropertyBag::CPropertyBag()
{
    _ulRefs = 1;
    _aryProps.SetSize(0);
    _pElementExpandos = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::~CPropertyBag
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

CPropertyBag::~CPropertyBag()
{
    Clear();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Clear
//
//----------------------------------------------------------------------------

void
CPropertyBag::Clear()
{
    long            c;
    PROPNAMEVALUE * pprop;
    
    for (c = _aryProps.Size(), pprop = _aryProps; c > 0; c--, pprop++)
    {
        pprop->Free();
    }
    _aryProps.SetSize(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::QueryInterface
//
//  Synopsis:   per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyBag::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if (riid == IID_IPropertyBag ||
        riid == IID_IUnknown)
    {
        *ppv = (IPropertyBag *) this;
    }
    else if (riid == IID_IPropertyBag2)
    {
        *ppv = (IPropertyBag2 *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Read
//
//  Synopsis:   per IPropertyBag.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyBag::Read(LPCOLESTR pchPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    RRETURN (Read(pchPropName, pVar, pErrorLog, -1));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Read
//
//  Synopsis:   helper
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Read(LPCOLESTR pchPropName, VARIANT *pVar, IErrorLog *pErrorLog, long iLikelyIndex)
{
    HRESULT         hr = S_OK;
    PROPNAMEVALUE * pprop = NULL;
    VARTYPE         vt;
    
    // NOTE istvanc error log is not supported yet
    if (!pchPropName || !pVar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    TraceTag((tagPropBag, "IPropertyBag::Read name=%ls", pchPropName));

    vt = V_VT(pVar);

    // NOTE istvanc cannot deal with objects yet
    if (vt == VT_UNKNOWN)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // The Java VM (the one which does not know about IPropertyBag2)
    // calls Read with this hacked up string.  Call GetPropertyBagContents
    // in response
    //
    
    if (_tcsequal(pchPropName, _T("%%pbcontents%%")))
    {
        V_VT(pVar) = vt;
        hr = THR(GetPropertyBagContents(pVar, pErrorLog));
    }
    else
    {
        pprop = Find((TCHAR *)pchPropName, iLikelyIndex);
        if (!pprop)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (vt == VT_EMPTY)
        {
            vt = VT_BSTR;

            //
            // !!! (alexz) (anandra) (lylec) (cfranks)
            // We have to return variant of VT_BSTR for compatibility with IE3.01 and IE3.02.
            // Note that changing this to VT_I4 as IE3.00 did can have complications because
            // non-numeric string parameters can not be converted to VT_I4.
            //
        }

        //
        // Set the vt of the variant to VT_EMPTY.
        // There are controls that call in here with garbage values in the
        // the variant and VariantChangeType will choke.  Look at ie4 
        // bug 38350.  (anandra)
        //
    
        V_VT(pVar) = VT_EMPTY;

        // Do not change this to use VariantChangeTypeSpecial, due to IE3 compatability concerns
        hr = THR(VariantChangeTypeEx(pVar,
                                     &pprop->_varValue,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     vt));
        if (hr)
        {
            //
            // some controls rely on vt untouched after call to Read method of propbag.
            // If VariantChangeTypeEx succeeds in this code, then the variant remains untouched.
            // However, if VariantChangeTypeEx fails, then vt will be set to VT_EMPTY because we
            // cleared the variant. To preserve those controls who rely on untouched variant,
            // we restore here the type.
            // Control: marquee. IE4 Bug: 54109.
            // (alexz)

            V_VT(pVar) = vt;
            goto Cleanup;
        }
    }

    //
    // if we are in expandos loading mode, then, according the protocol, after reading each expando,
    // the expando is supposed to be removed from the element.
    //

    if (_pElementExpandos)
    {
        BSTR    bstrName;

        hr = THR(FormsAllocString(pchPropName, &bstrName));
        if (hr)
            goto Cleanup;

        hr = THR(_pElementExpandos->removeAttribute(bstrName, 0, NULL));

        FormsFreeString(bstrName);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Write
//
//  Synopsis:   per IPropertyBag.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyBag::Write(LPCOLESTR pchPropName, VARIANT *pVar)
{
    HRESULT         hr = S_OK;
    PROPNAMEVALUE * pprop = NULL;
    PROPNAMEVALUE   propNew;
    
    if (!pchPropName || !pVar)
        return E_POINTER;

    TraceTag((tagPropBag, "IPropertyBag::Write name=%ls", pchPropName));

    pprop = Find((TCHAR *)pchPropName);

    //
    // Add only newly encountered properties.  Ignore new values of
    // properties we've seen before (compat with IE 3.0).
    //
    
    if (pprop)
        goto Cleanup;
        
    hr = THR(_aryProps.AppendIndirect(&propNew, &pprop));
    if (hr)
        goto Cleanup;

    hr = THR(pprop->Set((TCHAR *)pchPropName, pVar));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Read
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Read(
    ULONG cProperties, 
    PROPBAG2 *pPB2, 
    IErrorLog *pErrorLog,
    VARIANT *pVar,
    HRESULT *phrError)
{
    long        i;
    HRESULT     hr;
    BOOL        fFail = FALSE;
    
    if (phrError)
    {
        //
        // Assume no errors
        //
        
        memset(phrError, S_OK, sizeof(HRESULT) * cProperties);
    }
        
    //
    // Temp implementation.  Delegate to IPropertyBag::Read
    //

    for (i = cProperties; i > 0; i--, pPB2++, pVar++)
    {
        VariantClear(pVar);
        
        V_VT(pVar) = pPB2->vt;

        hr = THR_NOTRACE(Read(pPB2->pstrName, pVar, pErrorLog, pPB2->dwHint));

        // mwatt we like not to assign the variant type until after the read,
        // However, the variant is used in the read. So instead I going to VariantInit if the read fails

        if (hr)
        {
            VariantInit(pVar);

            fFail = TRUE;
            if (phrError)
            {
                *(phrError + cProperties - i) = hr;
            }
        }
    }

    RRETURN((fFail) ? E_FAIL : S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Write
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Write(ULONG cProperties, PROPBAG2 *pPB2, VARIANT *pVar)
{
    long        i;
    BOOL        fFail = FALSE;
    HRESULT     hr;
    
    //
    // Temp implementation.  Delegate to IPropertyBag::Write
    //

    for (i = cProperties; i > 0; i--, pPB2++, pVar++)
    {
        hr = THR(Write(pPB2->pstrName, pVar));
        if (hr)
        {
            fFail = TRUE;
        }
    }

    RRETURN((fFail) ? E_FAIL : S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::CountProperties
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::CountProperties(ULONG *pcProp)
{
    if (!pcProp)
        RRETURN(E_POINTER);

    *pcProp = _aryProps.Size();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::GetPropertyInfo
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::GetPropertyInfo(
    ULONG iProperty,
    ULONG cProperties,
    PROPBAG2 *pPropBag,
    ULONG *pcProperties)
{
    PROPNAMEVALUE * pprop = NULL;
    HRESULT         hr = S_OK;
    long            i, iStop;
    
    //
    // Perform initializations
    //
    
    *pcProperties = 0;
    memset(pPropBag, 0, sizeof(PROPBAG2) * cProperties);
    
    if (iProperty >= (ULONG)_aryProps.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Figure out the number of PROPBAG2 structs to fill.  This
    // is the min of the number requested and the size of the array.
    //

    *pcProperties = min(cProperties, _aryProps.Size() - iProperty);
    
    //
    // For now only reply with PROPBAG2_TYPE_DATA
    //
    
    for (pprop = (PROPNAMEVALUE *)_aryProps + iProperty, i = iProperty, iStop = iProperty + *pcProperties; 
         i < iStop; 
         pprop++, i++, pPropBag++)
    {
        pPropBag->dwType = PROPBAG2_TYPE_DATA;
        pPropBag->vt = V_VT(&pprop->_varValue);
        pPropBag->cfType = CF_TEXT;
        pPropBag->pstrName = (TCHAR *)
            CoTaskMemAlloc((pprop->_cstrName.Length() +1) * sizeof(TCHAR));
        pPropBag->dwHint = i;
        if (!pPropBag->pstrName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(pPropBag->pstrName, pprop->_cstrName);
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::LoadObject
//
//  Synopsis:   Per IPropertyBag2
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::LoadObject(
    LPCOLESTR pstrName,
    DWORD dwHint,
    IUnknown *pUnkObject,
    IErrorLog *pErrorLog)
{
    RRETURN(E_NOTIMPL);
}


//======================================================================
//
// NOTE: istvanc from OHARE -> HACKHACK davidna 5/7/96 Beta1 Hack
//
// Called when PropertyBag::read() is called with the Property name set
// to "%%pbcontents%%"
//
// Put the contents in a block of memory as name & value pairs.
// Stored as char FAR * 's
// Return this in the callers Variant
//
// The storage goes like this:
// We have pointers to the name/value pairs following the
// the count (ULONG) of items (or pairs) in _pbcontent
//
//

//$ WIN64: CPropertyBag::GetPropertyBagContents constructs a buffer of counts and
//$ WIN64:   pointers to strings.  It assumes that sizeof(void *) == sizeof(ULONG).
//$ WIN64:   Appears that Java VM understands this format as well (%%pbcontents%%).

HRESULT 
CPropertyBag::GetPropertyBagContents(VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT         hr = S_OK;
    BYTE *          pbcontent = NULL;
    PROPNAMEVALUE * pprop;
    long            c;
    CVariant        Var;
    ULONG           cb;
    ULONG *         pul;
    
    DbgMemoryTrackDisable(TRUE);
    
    if (!pVar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Must be this type for this HACK!
    if (V_VT(pVar) != (VT_BYREF|VT_UI1))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_aryProps.Size())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // allocate storage for the count (ULONG/number of items)
    // plus each of the items or name/value pairs
    cb = sizeof(ULONG) + (sizeof(char *) * _aryProps.Size()) * 2;

    Assert(sizeof(ULONG) == sizeof(char *));

    pbcontent = new(Mt(CPropertyBagGetPropertyBagContents_pVar)) BYTE [cb];
    if (!pbcontent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    memset(pbcontent, 0, cb);

    pul = (ULONG *)pbcontent;

    // first ULONG is count of items
    c = _aryProps.Size();
    *pul++ = c;

    // Fill in the blanks
    for (pprop = _aryProps;
         c > 0;
         c--, pprop++)
    {
        VARIANT * pVar;
        char * pch;

        //  Convert to ansi 'cause Java Applets probably won't like BSTR's
        //   and they're our only users of this

        //
        // store a pointer to the name
        //
        cb = WideCharToMultiByte(CP_ACP, 0, pprop->_cstrName, -1, NULL, 0,
              NULL, NULL);

        pch = new(Mt(CPropertyBagGetPropertyBagContents_pch)) char[cb + 1];
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, pprop->_cstrName, -1, pch, cb,
            NULL, NULL);
        
        pch[cb] = 0;

        *pul++ = (ULONG)(ULONG_PTR)pch;

        // Now store a pointer to the value
        //
        if (pprop->_varValue.vt != VT_BSTR)
        {
            // Do not change this to use VariantChangeTypeSpecial, due to IE3 compatability concerns
            hr = VariantChangeTypeEx(&Var,
                                     &pprop->_varValue,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR);
            if (hr)
                goto Cleanup;
            pVar = &Var;
        }
        else
        {
            pVar = &pprop->_varValue;
        }

        //
        // store a pointer to the value
        //
        
        cb = WideCharToMultiByte(CP_ACP, 0, pVar->bstrVal,
          FormsStringLen(pVar->bstrVal), NULL, 0, NULL, NULL);
        
        pch = new(Mt(CPropertyBagGetPropertyBagContents_pch)) char[cb + 1];
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, pVar->bstrVal,
            FormsStringLen(pVar->bstrVal), pch, cb, NULL, NULL);

        pch[cb] = 0;

        *pul++ = (ULONG)(ULONG_PTR)pch;
    }

    // put in variant
    pVar->pbVal = pbcontent;

Cleanup:
    DbgMemoryTrackDisable(FALSE);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::AddProp
//
//  Synopsis:   Helper to add a given property and name value pair.
//              with count of chars in name & value.
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::AddProp(
    TCHAR *pchName, 
    int cchName, 
    TCHAR *pchValue, 
    int cchValue)
{
    HRESULT     hr;
    CStr        cstrName;
    CVariant    Var;

    Assert (pchName && (0 < cchName) && (0 <= cchValue));

    hr = THR(cstrName.Set (pchName, cchName));
    if (hr)
        goto Cleanup;

    if (cchValue > 0 && pchValue)
    {
        V_VT(&Var) = VT_BSTR;
        hr = THR(FormsAllocStringLen(pchValue, cchValue, &V_BSTR(&Var)));
        if (hr)
            goto Cleanup;
    }
    else
    {   // Zero length or NULL values are treated as VT_EMPTY:
        V_VT(&Var) = VT_EMPTY;
    }

    hr = THR(Write(cstrName, &Var));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::AddProp
//
//  Synopsis:   Helper to add a given property and name value pair.
//              These are null terminated strings.
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::AddProp(TCHAR *pchName, TCHAR *pchValue)
{
    RRETURN(AddProp(
        pchName, _tcslen(pchName),
        pchValue, _tcslen(pchValue)));
}

//----------------------------------------------------------------------------
//  Member:     CPropertyBag::FindAndSetProp
//
//  Synopsis:   Helper to change a property value after the property bag 
//              has been prepared
//----------------------------------------------------------------------------
HRESULT
CPropertyBag::FindAndSetProp( TCHAR *pchName, TCHAR *pchValue)
{
    HRESULT     hr;
    CStr        cstrName;
    CVariant    Var;

    Assert (pchName);

    PROPNAMEVALUE * pprop = NULL;
    int             cchName = _tcslen(pchName);
    int             cchValue= 0;
    
    if (pchValue)
        cchValue = _tcslen(pchValue);
    
    Assert (0 < cchName);

    hr = THR(cstrName.Set (pchName, cchName));
    if (hr)
        goto Cleanup;

    if (cchValue > 0)   //implies that pchValue!=NULL
    {
        V_VT(&Var) = VT_BSTR;
        hr = THR(FormsAllocStringLen(pchValue, cchValue, &V_BSTR(&Var)));
        if (hr)
            goto Cleanup;
    }
    else
    {   // Zero length or NULL values are treated as VT_EMPTY:
        V_VT(&Var) = VT_EMPTY;
    }

//
// TODO:(ferhane) Move this before the if statement above on the 5.x tree
//                  for perf.
//
    pprop = Find( pchName, 0);

    if (!pprop)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // free the old variant that was stored in the propertybag
    pprop->Free();

    hr = THR(pprop->Set(cstrName, &Var));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Save
//
//  Synopsis:   saves to pStreamWrBuff html-formatted param bag
//
//----------------------------------------------------------------------------

HRESULT
CPropertyBag::Save(CStreamWriteBuff * pStreamWrBuff)
{
    HRESULT         hr = S_OK;
    long            c;
    PROPNAMEVALUE * pprop;
    DWORD           dwOldBuffFlags;
    
    dwOldBuffFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    pStreamWrBuff->BeginPre();
    pStreamWrBuff->BeginIndent();

    for (c = _aryProps.Size(), pprop = _aryProps;
         c > 0; 
         c--, pprop++)
    {
        //
        // First try to convert this param into a string.
        //
        
        if (VT_BSTR != V_VT(&pprop->_varValue))
        {
            // Do not change this to use VariantChangeTypeSpecial, due to IE3 compatability concerns
            hr = VariantChangeTypeEx(&pprop->_varValue,
                                     &pprop->_varValue,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR);
            if (hr)
            {
                // a property in param bag could not be converted to string;
                // we still try to save other properties

                // NOTE: need to report this error to user somehow;
                // e.g., by putting a comment to html about failure to save
                // the property.   Also handle catastrophic failure such as out-of-mem
                // appropriately.

                hr = S_OK;  // so if this was the last property everyone continues merrily along.
                continue;
            }
        }

        hr = THR(pStreamWrBuff->NewLine());
        if (hr)
            break;

        hr = THR(pStreamWrBuff->Write(
                     pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML)
                        ? _T("<HTML:PARAM NAME=") : _T("<PARAM NAME=") )
                );
        if (hr)
            break;

        hr = THR(pStreamWrBuff->WriteQuotedText(pprop->_cstrName, TRUE));
        if (hr)
            break;

        hr = THR(pStreamWrBuff->Write(_T(" VALUE=")));
        if (hr)
            break;

        Assert(V_VT(&pprop->_varValue) == VT_BSTR);
        hr = THR(pStreamWrBuff->WriteQuotedText(
                V_BSTR(&pprop->_varValue), 
                TRUE));
        if (hr)
            break;

        hr = THR(pStreamWrBuff->Write(_T(">")));
        if (hr)
            break;
    }

    pStreamWrBuff->EndIndent();
    pStreamWrBuff->EndPre();
    pStreamWrBuff->RestoreFlags(dwOldBuffFlags);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyBag::Find
//
//  Synopsis:   Return struct of PROPNAMEVALUE of given name
//
//----------------------------------------------------------------------------

PROPNAMEVALUE *
CPropertyBag::Find(TCHAR *pchName, long iLikelyIndex)
{
    PROPNAMEVALUE * pprop;
    long            c;

    Assert(pchName);

    if (0 <= iLikelyIndex && iLikelyIndex < _aryProps.Size())
    {
        pprop = &_aryProps[iLikelyIndex];
        if (0 == _tcsicmp(pchName, pprop->_cstrName))
        {
            return pprop;
        }
    }

    for (c = _aryProps.Size(), pprop = _aryProps; c > 0; c--, pprop++)
    {
        if (0 == _tcsicmp(pchName, pprop->_cstrName))
        {
            // Found, so return it.
            return pprop;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\optshold.cxx ===
//=================================================================
//
//   File:      optshold.cxx
//
//  Contents:   COptionsHolder class
//
//  Classes:    COptionsHolder
//              CFontNameOptions
//              CFontSizeOptions
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#define _cxx_
#include "optshold.hdl"

MtDefine(COptionsHolder, ObjectModel, "COptionsHolder")
MtDefine(COptionsHolder_aryFontSizeObjects_pv, COptionsHolder, "COptionsHolder::_aryFontSizeObjects::_pv")
MtDefine(CFontNameOptions, ObjectModel, "CFontNameOptions")
MtDefine(CFontNameOptions_aryFontNames_pv, CFontNameOptions, "CFontNameOptions::_aryFontNames::_pv")
MtDefine(CFontSizeOptions, ObjectModel, "CFontSizeOptions")
MtDefine(CFontSizeOptions_aryFontSizes_pv, CFontSizeOptions, "CFontSizeOptions::_aryFontSize::_pv")

#define  START_OF_SAMPLE_STRINGS    0x0700

extern CGlobalCriticalSection   g_csFile;
extern TCHAR                    g_achSavePath[];
extern BSTR                     g_bstrFindText;

HRESULT
SetFindText(LPCTSTR bstr)
{
    LOCK_GLOBALS;

    FormsFreeString(g_bstrFindText);
    g_bstrFindText = NULL;
    RRETURN(FormsAllocString(bstr, &g_bstrFindText));
}


//+-------------------------------------------------------------------
//
//  Callbacks:   GetFont*Proc
//
//  These procedures are called by the EnumFontFamilies and EnumFont calls.
//  It fills the combobox with the font facename and the size
//
//--------------------------------------------------------------------

int CALLBACK
GetFontNameProc(LOGFONT FAR    * lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    // Do not show vertical fonts
    if (lParam && lplf->lfFaceName[0] != _T('@'))
        ((CFontNameOptions *)lParam)->AddName(lplf->lfFaceName);

    return TRUE;
}

int CALLBACK
GetFontSizeProc(LOGFONT FAR *    lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    if (lParam)
       ((CFontSizeOptions *)lParam)->AddSize(lplf->lfHeight);

    return TRUE;
}

//+----------------------------------------------------------------
//
//  member : classdesc
//
//  Synopsis : CBase Class Descriptor Structure
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COptionsHolder::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLOptionsHolder,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : CTOR
//
//+----------------------------------------------------------------

COptionsHolder::COptionsHolder(CWindow * pWindow) : super(), _pWindow(pWindow)
{
    Assert(pWindow);

    _pWindow->AddRef();
    _pFontNameObj=NULL;

    VariantInit(&_execArg);
    _hParentWnd = NULL;
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

COptionsHolder::~COptionsHolder()
{
    _aryFontSizeObjects.ReleaseAll();

    _pWindow->Release();
    ReleaseInterface(_pFontNameObj);

    VariantClear(&_execArg);
}

void
COptionsHolder::Passivate()
{
    IGNORE_HR(SetFindText(GetAAfindText()));

    super::Passivate();
}


//+---------------------------------------------------------------
//
//  Member  : COptionsHolder::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COptionsHolder::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLOptionsHolder)
        {
           *ppv = (IHTMLOptionsHolder *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+----------------------------------------------------------------
//
//  member : get_document
//
//  Synopsis : IHTMLOptionsHolder property. returns the document
//      member
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_document(IHTMLDocument2 ** ppDocDisp)
{
    HRESULT hr = S_OK;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDocDisp = NULL;

    hr = THR_NOTRACE(_pWindow->Document()->QueryInterface(IID_IHTMLDocument2,
                                            (void**) ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_unsecuredWindowOfDocument
//
//  Synopsis : IHTMLOptionsHolder property. returns the unsecured
//              window of the document
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_unsecuredWindowOfDocument(IHTMLWindow2 ** ppDocDisp)
{
    HRESULT         hr = S_OK;
    CWindow *       pWindow = NULL;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pWindow = _pWindow;
    Assert(pWindow);

    hr = THR_NOTRACE(pWindow->QueryInterface(IID_IHTMLWindow2,
                                            (void**)ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_fonts(IHTMLFontNamesCollection ** ppFontCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    LOGFONT lf;

    if (!ppFontCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFontCollection = NULL;
    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CFontNameOptions();
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ReleaseDC(hWndInPlace, hdc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // QI for an interface to return
    hr = THR_NOTRACE(_pFontNameObj->QueryInterface(
                                    IID_IHTMLFontNamesCollection,
                                    (void**)ppFontCollection));

    // We keep an additional ref because we cache the name collection obj

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : secureProtocolInfo
//
//  Synopsis : IHTMLOptionsHolder Property. returns a BSTR which 
//      describes the secure connection info. 
//      Empty string if current connection is insecure
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_secureConnectionInfo(BSTR * p)
{
    HRESULT hr = S_OK;
    BOOL bSuccess = FALSE;

    if ( p == NULL)
    {
        return E_POINTER;
    }
                
    if (CMarkup::HtmCtxHelper(_pWindow->_pMarkup) != NULL)
    {
        INTERNET_SECURITY_CONNECTION_INFO * pSCI = NULL;
        CMarkup::HtmCtxHelper(_pWindow->_pMarkup)->GetSecConInfo(&pSCI);

        if (!pSCI)
        {
            // Without benefit of INTERNET_SECURITY_CONNECTION_INFO, report "Encrypted."
            // if we believe the original source of the page to be secure
            
            TCHAR achMessage[FORMS_BUFLEN + 1];
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE sps;

            _pWindow->Doc()->GetRootSslState(FALSE, &sss, &sps);

            if (sss > SSL_SECURITY_MIXED)
            {
                if (!LoadString(GetResourceHInst(), IDS_SECURESOURCE, achMessage, ARRAY_SIZE(achMessage)))
                    return E_FAIL;

                *p = SysAllocString(achMessage);
                if (*p == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    bSuccess = TRUE;
                }
            }
        }
        
        if (pSCI != NULL && pSCI->fSecure)
        {
            // These are way beyond the sizes required for protocol & algorithm names (SSL 2.0, RC4, ...)
            // Assert's added in case the strings ever exceed the limit. 
            TCHAR achProtocol[32]; 
            TCHAR achAlgCipher[64];
            TCHAR achAlgExch[64];
            DWORD dwProtocol = ARRAY_SIZE(achProtocol);;
            DWORD dwAlgCipher = ARRAY_SIZE(achAlgCipher);
            DWORD dwAlgExch = ARRAY_SIZE(achAlgExch);
             
            if ( InternetSecurityProtocolToString(pSCI->dwProtocol, achProtocol, &dwProtocol, 0) && 
                 InternetAlgIdToString(pSCI->aiCipher, achAlgCipher, &dwAlgCipher, 0) &&
                 InternetAlgIdToString(pSCI->aiExch, achAlgExch, &dwAlgExch, 0)
               )
            {
                int idCipherQuality;
                
                if ( pSCI->dwCipherStrength < 56 )
                    idCipherQuality = IDS_SECURE_LOW;
                else if ( pSCI->dwCipherStrength < 128 )
                    idCipherQuality = IDS_SECURE_MEDIUM;
                else
                    idCipherQuality = IDS_SECURE_HIGH;
                
                TCHAR achSecurityInfo[256]; // This is way beyond what we can handle. 
                                
                hr = THR(Format(0,
                                achSecurityInfo,
                                ARRAY_SIZE(achSecurityInfo),
                                MAKEINTRESOURCE(IDS_SECURECONNECTIONINFO),
                                achProtocol,
                                achAlgCipher,
                                pSCI->dwCipherStrength,
                                GetResourceHInst(), idCipherQuality,
                                achAlgExch,
                                pSCI->dwExchStrength
                            ));

                if (SUCCEEDED(hr))
                {
                    *p = SysAllocString(achSecurityInfo);
                    if (*p == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        bSuccess = TRUE;
                    }
                }
            }
            else
            {
                DWORD dwError = GetLastError();
                // This implies the stack buffers we have allocated are not big enough!!
                Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }  /* if the connection was secure */
    } /* if we found a _pHtmCtx */

    // If we failed somewhere along the way. just allocate an empty string and return quietly. 
    if (!bSuccess)
    {
        *p = SysAllocString(_T(""));
        if (*p == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }                                                                                                                
                                         
    return hr;    
}



//+----------------------------------------------------------------
//
//  member : sizes
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole Collecion of
//      longs of the available sizes available for the given font
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::sizes( BSTR bstrFontName,
                       IHTMLFontSizesCollection ** ppOptsCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    CStr    strName;
    long    lIndex;

    if (!ppOptsCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    if (!bstrFontName || !SysStringLen(bstrFontName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lIndex = GetObjectLocation(bstrFontName);
    if (lIndex<0)
    {
        // some error happened
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If we don't have the sizes cached for this font....
    if (lIndex == _aryFontSizeObjects.Size())
    {
        CFontSizeOptions * pfsObject=NULL;

        // add a new one to the list
        hr = THR(_aryFontSizeObjects.EnsureSize(lIndex+1));
        if (hr)
            goto Cleanup;

        pfsObject = new CFontSizeOptions();
        if (!pfsObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pfsObject->_cstrFont.SetBSTR(bstrFontName);
        pfsObject->SetSize(0);

        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        EnumFonts( hdc, pfsObject->_cstrFont,
                   (FONTENUMPROC) GetFontSizeProc,
                   (LPARAM)pfsObject);
        ReleaseDC(hWndInPlace, hdc);

        _aryFontSizeObjects[lIndex] = pfsObject;
    }

        // QI for an interface to return
    hr = THR_NOTRACE(_aryFontSizeObjects[lIndex]->QueryInterface(
                                    IID_IHTMLFontSizesCollection,
                                    (void**)ppOptsCollection));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : openfiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::openfiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, FALSE)));
}

//+----------------------------------------------------------------
//
//  member : savefiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::savefiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, TRUE)));
}

//+----------------------------------------------------------------
//
//  member : OpenSaveFileDlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open or save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

#define VERIFY_VARARG_4BSTR(arg, var)           \
    switch(V_VT(&arg))                          \
    {                                           \
    case    VT_BSTR:                            \
        var = &arg;                             \
        break;                                  \
    case    VT_BYREF|VT_BSTR:                   \
        var = V_VARIANTREF(&arg);               \
        break;                                  \
    default:                                    \
        var = NULL;                             \
    }

HRESULT
COptionsHolder::OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName, BOOL fSaveFile)
{
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    VARIANT *       pvarInitFile;
    VARIANT *       pvarInitDir;
    VARIANT *       pvarFilter;
    VARIANT *       pvarTitle;
    OPENFILENAME    ofn;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    BSTR            bstrFile = 0;
    TCHAR           *pstrExt;
    TCHAR           achPath[MAX_PATH];

    VERIFY_VARARG_4BSTR(initFile, pvarInitFile);
    VERIFY_VARARG_4BSTR(initDir, pvarInitDir);
    VERIFY_VARARG_4BSTR(filter, pvarFilter);
    VERIFY_VARARG_4BSTR(title, pvarTitle);

    hr = THR(FormsAllocStringLen(NULL, MAX_PATH, &bstrFile));
    if (hr)
    {
        goto Cleanup;
    }

    if (pvarInitFile)
    {
        _tcscpy(bstrFile, V_BSTR(pvarInitFile));
    }
    else
    {
        *bstrFile = _T('\0');
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    Assert(_hParentWnd);
    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    // ofn.hwndOwner       = hWndInPlace;
    ofn.hwndOwner       = _hParentWnd;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
                            // no readonly checkbox, per request

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = bstrFile;     // file name buffer
    ofn.nMaxFile        = MAX_PATH;     // file name buffer size
    
    if (pvarInitDir)
    {
        ofn.lpstrInitialDir = V_BSTR(pvarInitDir);
    }

    if (pvarFilter)
    {
        BSTR    bstrFilter = V_BSTR(pvarFilter);
        TCHAR   *cp;

        for ( cp = bstrFilter; *cp; cp++ )
        {
            if ( *cp == _T('|') )
            {
                *cp = _T('\0');
            }
        }
        ofn.lpstrFilter = bstrFilter;
    }

    if (pvarTitle)
    {
        ofn.lpstrTitle = V_BSTR(pvarTitle);
    }

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = bstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt > bstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }

    if( pstrExt > bstrFile )
    {
        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');

                break;
            }
            pSearch += _tcslen(pSearch);
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    {
        LOCK_SECTION(g_csFile);

        _tcscpy(achPath, g_achSavePath);
        ofn.lpstrInitialDir = *achPath ? achPath : NULL;
    }

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (!fOK)
    {
        FormsFreeString(bstrFile);
        bstrFile = NULL;
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
#else //WINCE
        hr = E_FAIL;
#endif //WINCE
    }
    else
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName =_tcsrchr(g_achSavePath, _T('\\'));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }
        hr = S_OK;
    }

Cleanup:

    *pathName = bstrFile;

    return hr;
}

HRESULT
COptionsHolder::choosecolordlg( VARIANTARG initColor, long *rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    VARIANT *       pvarRGBColor;
    DWORD           dwResult;
    VARIANTARG      varArgTmp;

    hr = THR (VariantChangeTypeSpecial(&varArgTmp, &initColor, VT_I4));
    if (hr)
    {
        pvarRGBColor = NULL;
    }
    else
    {
        if (V_VT(&initColor) & VT_BYREF)
        {
            pvarRGBColor = V_VARIANTREF(&varArgTmp);
        }
        else
        {
            pvarRGBColor = &varArgTmp;
        }
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = _hParentWnd;
    structCC.lpCustColors    = aCColors;
    
    if (pvarRGBColor)
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = V_I4(pvarRGBColor);
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:

    *rgbColor = dwResult;

    RRETURN(SetErrorInfo( hr ));
#endif // WINCE
}

HRESULT
COptionsHolder::showSecurityInfo()
{
    HWND    hwnd = _hParentWnd;
    CDoc *  pDoc = _pWindow->Doc();

    if (!_hParentWnd)
        pDoc->GetWindow(&hwnd);
        
    InternetShowSecurityInfoByURL((TCHAR*)CMarkup::GetUrl(_pWindow->Markup()), hwnd);

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
COptionsHolder::isApartmentModel( IHTMLObjectElement* object, 
                                 VARIANT_BOOL * fApartment)
{
    HRESULT             hr = S_OK;
    IClientSecurity    *pCL = NULL;
    VARIANT_BOOL        vbRetVal = VB_FALSE;
    VARIANT             var;
    IOleCommandTarget  *pCT = NULL;

    VariantInit(&var);

    hr = THR(object->QueryInterface(IID_IOleCommandTarget, (void **) &pCT));
    if (hr)
        goto Cleanup;

    hr = THR(pCT->Exec((GUID *)&CGID_MSHTML, 
                        IDM_GETPUNKCONTROL, 
                        0, 
                        NULL, 
                        &var));
    if (hr)
        goto Cleanup;

    //
    //  QI IClientSecurity returns S_OK if the control is NOT 
    //  apartment model!
    //
    hr = var.punkVal->QueryInterface(IID_IClientSecurity, (void **) &pCL);
    if (!hr)
    {
        hr = S_OK;      // It really is OK.
        goto Cleanup;
    }

    vbRetVal = VB_TRUE;

Cleanup:
    ReleaseInterface(pCL);
    ReleaseInterface(pCT);

    *fApartment = vbRetVal;

    RRETURN( SetErrorInfo( S_OK ) );
}


HRESULT
COptionsHolder::getCharset(BSTR fontName, long * charset)
{
    HRESULT         hr = S_OK;
    LOGFONT         lf;
    UINT            uintResult = 0;
    HDC             hdc = NULL;
    HFONT           hfont = NULL, hfontOld = NULL;

    if (!charset)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *charset = 0;

    hdc = GetDC(NULL);
    if (!hdc)
        goto Cleanup;

    memset(&lf, 0, sizeof(lf));

    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality  = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    
    // If fontName is too long, we have to shorten it.
    _tcsncpy(lf.lfFaceName, fontName, LF_FACESIZE - 1);
    lf.lfFaceName[LF_FACESIZE - 1] = 0;
    
    hfont = CreateFontIndirect(&lf);
    if (!hfont)
        goto Cleanup;

    hfontOld = (HFONT) SelectObject(hdc, hfont);
    if (!hfontOld)
        goto Cleanup;

    uintResult = GetTextCharset(hdc);

    *charset = uintResult;

Cleanup:

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }

    if (hfont)
    {
        DeleteObject(hfont);
    }
    
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    RRETURN( SetErrorInfo( hr ) );
}



//+----------------------------------------------------------------
//
//  Member GetObjetLocation
//
//  Synopsis : helper function for sizes. this will search the
//      pointer array of size collections to see if this one
//      already exists. if not, size() is returned.
//
//-----------------------------------------------------------------

long
COptionsHolder::GetObjectLocation(BSTR strTargetFontName)
{
    long    lSize = _aryFontSizeObjects.Size();
    long    l;

    // Look for a free slot in the non-reserved part of the cache.
    for (l=0; l < lSize; ++l)
    {
        if (!FormsStringICmp(_aryFontSizeObjects[l]->_cstrFont,
                             strTargetFontName))
            break;
    }

    return l;
}


HRESULT
STDMETHODCALLTYPE COptionsHolder::put_execArg(VARIANT varExecArg)
{
    VariantClear(&_execArg);
    RRETURN(SetErrorInfo(VariantCopy(&_execArg, &varExecArg)));
}

HRESULT 
STDMETHODCALLTYPE COptionsHolder::get_execArg(VARIANT *pexecArg)
{
    HRESULT     hr;

    if (pexecArg == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantCopy(pexecArg, &_execArg);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontNameOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontNameOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontNamesCollection,  // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CFontNameOptions::~CFontNameOptions()
{
    CStr *  pcstr;
    long    i;

    for (i = _aryFontNames.Size(), pcstr = _aryFontNames;
         i > 0;
         i--, pcstr++)
    {
        pcstr->Free();
    }

    _aryFontNames.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontNamesCollection)
        {
           *ppv = (IHTMLFontNamesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::AddName(TCHAR * strFontName)
{
    HRESULT hr = S_OK;
    long    lIndex;
    long    lSizeAry = _aryFontNames.Size();

    // does this name already exist in the list
    for (lIndex = 0; lIndex < lSizeAry ; lIndex++)
    {
        if (_tcsiequal(strFontName, _aryFontNames[lIndex]))
            break;
    }

    // Not found, so add element to array.
    if (lIndex == lSizeAry)
    {
        CStr *pcstr;

        hr = THR(_aryFontNames.AppendIndirect(NULL, &pcstr));
        if (hr)
            goto Cleanup;

        hr = pcstr->Set(strFontName);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::length
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontNames.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::item
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::item(long lIndex, BSTR * pstrName)
{
    HRESULT   hr   = S_OK;

    if (!pstrName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontNames.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aryFontNames[lIndex].AllocBSTR(pstrName);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontNames.EnumVARIANT(VT_BSTR,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontSizeOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontSizeOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontSizesCollection,  // _piidDispinterface
    &s_apHdlDescs,                      // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontSizesCollection)
        {
           *ppv = (IHTMLFontSizesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::AddSize
//
//  Sysnopsis : adds the given size to the aryFontSizes
//          in ascending order.
//
//----------------------------------------------------------------
HRESULT
CFontSizeOptions::AddSize(long lFSize)
{
    HRESULT hr = S_OK;
    int     i, value, iSizeAry = _aryFontSizes.Size();

    for (i=0; i<iSizeAry; i++)
    {
        value = _aryFontSizes[i];

        // is it already in the list
        if (lFSize == value)
            goto Cleanup;

        // is it smaller than the thing we're looking at
        if (lFSize < value)
            break;
    }

    // it is not in the list and smaller than the value at index i
    // or i = iSizeAry and we want to tack this at the end.
    hr = THR(_aryFontSizes.Insert(i, lFSize));

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::length
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontSizes.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::item
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::item(long lIndex, long *plSize)
{
    HRESULT hr = S_OK;

    if (!plSize)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontSizes.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plSize = _aryFontSizes[lIndex];

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::_newEnum
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontSizes.EnumVARIANT(VT_I4,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\postdata.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

DeclareTag(tagFormEncoding, "Form", "Form submission encoding")

MtDefine(CPostData, Dwn, "CPostData")
MtDefine(CPostData_pv, CPostData, "CPostData::_pv")
MtDefine(CPostItem, Dwn, "CPostItem (vector)")
MtDefine(CPostItem_psz, CPostItem, "CPostItem::_pszAnsi/Wide")

// This is the number of characters we allocate by default on the stack
// for string buffers. Only if the number of characters in a string exceeds
// this will we need to allocate memory for string buffers.
#define STACK_ALLOCED_BUF_SIZE 64

// Helpers for Form Submit - copied from IE3 and modified approriately
//
static int x_hex_digit(int c)
{
    if (c >= 0 && c <= 9)
    {
        return c + '0';
    }
    if (c >= 10 && c <= 15)
    {
        return c - 10 + 'A';
    }
    return '0';
}



static const char s_achDisposition[] = "\r\nContent-Disposition: form-data; name=\"";

// MIME types constants
// Multipart/Form-Data are constructed in CreateHeader()
static const char s_achTextPlain[]  = "text/plain\r\n";
static const char s_achUrlEncoded[] = "application/x-www-form-urlencoded\r\n";



/*
   The following array was copied directly from NCSA Mosaic 2.2
 */
static const unsigned char isAcceptable[96] =
/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,    /* 2x   !"#$%&'()*+,-./  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,    /* 3x  0123456789:;<=>?  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,    /* 5x  PQRSTUVWXYZ[\]^_  */
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};   /* 7x  pqrstuvwxyz{\}~  DEL */

// Performs URL-encoding of null-terminated strings. Pass NULL in pbOut
// to find buffer length required. Note that '\0' is not written out.

int
URLEncode(unsigned char * pbOut, const char * pchIn)
{
    int     lenOut = 0;
    char *  pchOut = (char *)pbOut;

    Assert(pchIn);

    for (; *pchIn; pchIn++, lenOut++)
    {
        if (*pchIn == ' ')
        {
            if (pchOut)
                *pchOut++ = '+';
        }
        else if (*pchIn >= 32 && *pchIn <= 127 && isAcceptable[*pchIn - 32])
        {
            if (pchOut)
                *pchOut++ = (TCHAR)*pchIn;
        }
        else
        {
            if (pchOut)
                *pchOut++ = '%';
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit((*pchIn >> 4) & 0xf);
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit(*pchIn & 0xf);
        }
    }
    return lenOut;
}



// Support for internationalization
class CSubmitIntl : public CEncodeWriter
{
public:
    CSubmitIntl(CODEPAGE cp);
    HRESULT Convert(TCHAR * pchIn);
};

CSubmitIntl::CSubmitIntl(CODEPAGE cp)
    // just give a large enough block size
    : CEncodeWriter(NavigatableCodePage(cp), 256)
{
    TraceTag((tagFormEncoding, "%lx constructing CSubmitIntl with codepage %d", this, cp));
}



HRESULT
CSubmitIntl::Convert(TCHAR * pchIn)
{
    HRESULT hr=S_OK;
    int     cch;

    Assert(pchIn);

    // So MultiByteFromWideChar knows what to convert
    _pchBuffer = (TCHAR *)pchIn;
    _cchBuffer = _cchBufferMax = _tcslen(pchIn) + 1;

    hr = THR(MultiByteFromWideChar(FALSE, &cch));

    // Do this to prevent the destructor from trying to
    // free _pchBuffer
     _pchBuffer = NULL;
     _cchBuffer = _cchBufferMax = 0;

    return hr; 
}


//+---------------------------------------------------------------------------
//
//  Member:     CPostData::IsStringInCodePage
//
//  Synopsis:   Takes a wide char string and an code page and returns whether
//              all the charaters in the string are the code page
//
//----------------------------------------------------------------------------

BOOL 
CPostData::IsStringInCodePage(CODEPAGE cpMlang, LPCWSTR lpWideCharStr, int cchWideChar)
{
    BOOL        fRetVal = FALSE;
    HRESULT     hr = S_OK;
    DWORD       dwMode = 0;

    TraceTag((tagFormEncoding, "IsStringInCodePage called: cp: %d, str: %S", cpMlang, lpWideCharStr));

    if (IsStraightToUnicodeCodePage(cpMlang))
    {
        fRetVal = TRUE;
        goto Cleanup;
    }

    hr = THR(mlang().ConvertStringFromUnicodeEx(&dwMode, cpMlang,
                    (LPWSTR) lpWideCharStr, (UINT *) &cchWideChar, 
                    NULL, NULL, MLCONVCHARF_NOBESTFITCHARS, NULL));
    if (FAILED(hr))
        goto Cleanup;

    fRetVal = (hr == S_OK); // S_FALSE means some characters were outside the target codepage.

Cleanup: 
    TraceTag((tagFormEncoding, "IsStringInCodePage returning %d for %S", fRetVal, lpWideCharStr));
    return fRetVal;
}


CODEPAGE
CPostData::GetCP(CMarkup * pMarkup)
{
    if (_cp)
    {
        TraceTag((tagFormEncoding, "CPostData::GetCP returning %d", _cp));
        return _cp;
    }

    CSubmitIntl intl(_fUseUtf8 ? CP_UTF8 : pMarkup->GetCodePage());
    _cp = intl.GetCodePage();

    TraceTag((tagFormEncoding, "CPostData::GetCP returning %d", _cp));
    return _cp;

}

///////////////////////////////////////////////////////////////////////////////
//  CPostData

HRESULT
CPostData::AppendEscaped(const TCHAR * pszWide, CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;
    CODEPAGE    cp;
    long        cch = pszWide ? _tcslen(pszWide) : 0;

    if (!pszWide)
        return S_OK;

    // Internationalize to produce multi-byte stream
    Assert(pMarkup);
    if (_fUseCustomCodePage)
    {
        cp = _cpInit;
    }
    else
    {
        cp = (_fUseUtf8 ? CP_UTF8 : pMarkup->GetCodePage());
    }        
    CSubmitIntl intl(cp);

    // CSubmitIntl sometimes maps the doc's codepage to something else.
    // We must cache that cp for use in CFormElement::DoSubmit.
    _cp = intl.GetCodePage();

    if (!_fUseUtf8 && !IsStringInCodePage(_cp,
                        pszWide,
                        cch + 1) && !_fUseCustomCodePage)
    {
        DWORD       dwCodePages = 0;
        long        cchCodePages = 0;

        _fCharsetNotDefault = TRUE;
        TraceTag((tagFormEncoding, "CPostData::_fCharsetNotDefault set to TRUE"));

        hr = THR(mlang().GetStrCodePages(pszWide, cch, NULL, &dwCodePages, &cchCodePages));
        if (S_OK != hr)
            goto Cleanup;

        if (cch > cchCodePages)
        {
            _fCodePageError = TRUE;
            TraceTag((tagFormEncoding, "CPostData::_fCodePageError set to TRUE"));
        }

        _dwCodePages |= dwCodePages;
    }

    hr = THR(intl.Convert((TCHAR*)pszWide));
    if ( hr )
        RRETURN(hr);

    {
        // Now, do the URL encoding
        const char * pszAnsi = (char *)intl._pbBuffer;
        UINT cbOld = Size();

        switch ( _encType )
        {
            case htmlEncodingURL:
                {    
                    UINT cbLen = URLEncode(NULL, pszAnsi);
                    if (0 == cbLen)
                        goto Cleanup;

                    hr = THR(Grow(cbOld + cbLen));
                    if ( hr )
                        goto Cleanup;

                    URLEncode(Base()+cbOld, pszAnsi);
                }
                break;

            default:
                {
                    // TODO (laszlog, IE6 track bug 16):
                    // Snap in the RFC1522 encoder here when we have one.

                    hr = THR(Append(pszAnsi));
                }
                break;

        } // switch
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CPostData::Append(const char * pszAnsi)
{
    if (!pszAnsi || !pszAnsi[0])
        return S_OK;

    UINT cbOld = Size();
    UINT cbLen = strlen(pszAnsi);

    if (Grow(cbOld+cbLen) != S_OK)
        return E_OUTOFMEMORY;

    // don't copy '\0'
    memcpy((char *)Base() + cbOld, pszAnsi, cbLen);

    _fItemSeparatorIsLast = FALSE;
    return S_OK;
}

HRESULT
CPostData::Append(int num)
{
    char sz[256];

    wsprintfA(sz, "%d", num);
    return Append(sz);
}

HRESULT
CPostData::Terminate(BOOL fOverwriteLastChar)
{
    if (!fOverwriteLastChar || Size() == 0)
    {
        if (Grow(Size()+1) != S_OK)
            return E_OUTOFMEMORY;
    }
    (*this)[Size()-1] = 0;

    _fItemSeparatorIsLast = FALSE;
    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendUnicode
//
//  Synopsis:   Appends a filename in Unicode
//
//  Arguments:  pszWideFilename     points to the null-terminated filename
//
//  Note:       As it is used for a single Unicode filename
//              this Append routine copies the whole string
//              including the terminating wide NULL
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendUnicode(const TCHAR * pszWideFilename)
{
    UINT cbOld;
    UINT cbLen;

    Assert(_eCurrentKind == POSTDATA_FILENAME);
    Assert(pszWideFilename);

    cbOld = Size();
    cbLen = sizeof(TCHAR) * (1 + _tcslen(pszWideFilename));

    if ( S_OK != Grow(cbOld + cbLen) )
        return E_OUTOFMEMORY;

    memcpy((char*)Base()+cbOld, pszWideFilename, cbLen);

    _fItemSeparatorIsLast = FALSE;

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::CreateHeader
//
//  Synopsis:   Creates the 'Content-type:' header value. It also has the
//              side-effect of creating the multipart boundary string that
//              we use in multipart form submissions.
//
//---------------------------------------------------------------------------
HRESULT
CPostData::CreateHeader(void)
{
    switch ( _encType )
    {
        case htmlEncodingMultipart:
        {
            SYSTEMTIME time;

            GetLocalTime( &time );
            wsprintfA(_achBoundary,
                      "\r\n-----------------------------%x%x%x%x",  // CRLF removed from here
                      time.wYear,
                      time.wMilliseconds,
                      time.wSecond,
                      GetForegroundWindow());
    
            //  _achBoundary is the complete separator string written into the submit stream
            //  complete with the CRLF and double-hyphen "--" prefix
            //  the separator value proper is the string following that prefix;
            //  that's the string that goes into the multipart header.

            wsprintfA(_achEncoding,
                "multipart/form-data; boundary=%s\r\n",
                _achBoundary + 4 );

            Assert(1 + strlen(_achEncoding) <= sizeof(_achEncoding));
            break;
        }

        case htmlEncodingURL:
            Assert(sizeof(s_achUrlEncoded) <= sizeof(_achEncoding));
            memcpy(_achEncoding, s_achUrlEncoded, sizeof(s_achUrlEncoded));
            break;

        case htmlEncodingText:
            Assert(sizeof(s_achTextPlain) <= sizeof(_achEncoding));
            memcpy(_achEncoding, s_achTextPlain, sizeof(s_achUrlEncoded));
            break;
    }

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendItemSeparator
//
//  Synopsis:   Writes the item separator
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendItemSeparator()
{
    HRESULT hr = S_OK;

    Assert(_eCurrentKind == POSTDATA_LITERAL);

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {
                if ( ! _fItemSeparatorIsLast )
                {
                    _lLastItemSeparator = Size();

                    //  Don't prepend the CR/LF if this is the first item
                    if ( _lLastItemSeparator || _cItems )
                    {
                        hr = THR(Append(_achBoundary));
                        if ( hr )
                            goto Cleanup;
                    }
                    else
                    {
                        hr = THR(Append(_achBoundary+2));
                        if ( hr )
                            goto Cleanup;
                    }
                    hr = THR(Append(s_achDisposition));
                    if ( hr )
                        goto Cleanup;

                    _fItemSeparatorIsLast = TRUE;
                }
            }
            break;

        case htmlEncodingText:
            {
                if (( Size() > 0 )
                   && ( ! _fItemSeparatorIsLast ))
                {
                    _lLastItemSeparator = Size();

                    hr = THR(Append("\r\n"));
                    if ( hr )
                        goto Cleanup;

                    _fItemSeparatorIsLast = TRUE;
                }
            }
            break;

        case htmlEncodingURL:
            {
                if ( Size() > 0 && *(Base()+(Size() - 1)) != '&' )
                {
                    _lLastItemSeparator = Size();

                    hr = THR(Append("&"));
                    if ( hr )
                        goto Cleanup;

                    _fItemSeparatorIsLast = TRUE;
                }
            }
            break;

    } // switch

    _cbOld = Size();


Cleanup:
    RRETURN(hr);
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::RemoveLastItemSeparator
//
//  Synopsis:   Removes the separator appended after the last submit item
//
//---------------------------------------------------------------------------
HRESULT
CPostData::RemoveLastItemSeparator(void)
{
    Assert(_eCurrentKind == POSTDATA_LITERAL);

    if ( _fItemSeparatorIsLast )
    {
        Assert(_lLastItemSeparator <= Size());

        SetSize(_lLastItemSeparator);
        _fItemSeparatorIsLast = FALSE;
    }

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendValueSeparator
//
//  Synopsis:   Writes the separator between the name and the value
//              of the control
//
//  note:       This is an equal sign for URLEncoding and text/plain,
//              closing quote and a line break for multipart
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendValueSeparator()
{
    HRESULT hr=S_OK;

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {
                hr = THR(Append("\"\r\n\r\n"));
            }
            break;

        case htmlEncodingText:
        case htmlEncodingURL:
            {
                hr = THR(Append("="));
            }
            break;

    } // switch

    _fItemSeparatorIsLast = FALSE;

    RRETURN(hr);
}




//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendNameValuePair
//
//  Synopsis:   Appends a name-value submit pair to the submit stream
//              according to the current encoding
//
//  Arguments:  pchName     the name. If NULL->no submit.
//              pchValue    the value string
//              pDoc        the Doc. Used for Unicode->ANSI mapping
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendNameValuePair(LPCTSTR pchName, LPCTSTR pchValue, CMarkup * pMarkup)
{
    HRESULT hr;

    Assert(pMarkup);

    if ( ! pchName )
        return S_FALSE;

    hr = THR(AppendEscaped(pchName, pMarkup));
    if (hr)
        goto Cleanup;

    hr = THR(AppendValueSeparator());
    if (hr)
        goto Cleanup;

    hr = THR(AppendEscaped(pchValue, pMarkup));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendNameFilePair
//
//  Synopsis:   Appends a name-file submit pair to the submit stream
//              according to the current encoding
//              Called by the File Upload control
//
//  Arguments:  pchName     the name. If NULL->no submit.
//              pchFileName the filename string
//              pDoc        the Doc. Used for Unicode->ANSI mapping
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendNameFilePair(LPCTSTR pchName, LPCTSTR pchFileName, CMarkup * pMarkup)
{
    TCHAR * pszMimeType = NULL;
    HRESULT hr=S_OK;

    if ( ! pchName )
        return S_FALSE;

    Assert(pMarkup);

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {
                hr = THR(AppendEscaped(pchName, pMarkup));
                if (hr)
                    goto Cleanup;

                hr = THR(Append("\x22; filename=\""));
                if (hr)
                    goto Cleanup;

                if ( ! pchFileName )
                {
                    pchFileName = g_Zero.ach;
                }
#ifndef UNIX
                hr = THR(AppendEscaped(pchFileName, pMarkup));
#else
                {
                    TCHAR *pchFileNameLastPart = _tcsrchr(pchFileName,_T('/'));
                    if(pchFileNameLastPart)
                        hr = THR(AppendEscaped(pchFileNameLastPart+1, pDoc));
                    else
                        hr = THR(AppendEscaped(pchFileName, pDoc));
                }
#endif // !UNIX
                if (hr)
                    goto Cleanup;

                hr = THR(Append("\"\r\nContent-Type: "));
                if (hr)
                    goto Cleanup;

                //  Look up the file type in the MIME database
                //  or use the extension

        #if JOHANN_FIXED_URLMON_TO_SNIFF_FILENAME

                TCHAR achFileMoniker[FORMS_BUFLEN];

                _tcscpy(achFileMoniker, _T("file://"));
                _tcscat(achFileMoniker, pchFileName);

                hr = THR(FindMimeFromData(NULL,             // bind context - can be NULL                                     
                                          pchFileName,   // url - can be null                                              
                                          NULL,             // buffer with data to sniff - can be null (pwzUrl must be valid) 
                                          0,                // size of buffer                                                 
                                          NULL,             // proposed mime if - can be null                                 
                                          0,                // will be defined                                                
                                          &pszMimeType,     // the suggested mime                                             
                                          0));   
        #else
                //  Use the achFileMoniker for data buffering, it's large enough
                HANDLE hFile = INVALID_HANDLE_VALUE;
                ULONG cb;
                char achFileBuf[FORMS_BUFLEN];

                hFile = CreateFile(pchFileName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,                //  security descriptor
                                   OPEN_EXISTING,
                                   0,
                                   NULL);

                if ( hFile == INVALID_HANDLE_VALUE )
                {
                    hr = E_FAIL;
                    goto CloseFile;
                }

                if (FILE_TYPE_DISK != GetFileType(hFile))
                {
                    hr = E_FAIL;
                    goto CloseFile;
                }

                //  Here the file should be open and ripe for consumption
                cb = 0;
                if ( !ReadFile(hFile, achFileBuf, sizeof(achFileBuf), &cb, NULL) )
                {
                    hr = E_FAIL;
                    goto CloseFile;
                }


                hr = THR(FindMimeFromData(NULL,             // bind context - can be NULL                                     
                                          pchFileName,      // url - can be null                                              
                                          achFileBuf,       // buffer with data to sniff - can be null (pwzUrl must be valid) 
                                          cb,               // size of buffer                                                 
                                          NULL,             // proposed mime if - can be null                                 
                                          0,                // will be defined                                                
                                          &pszMimeType,     // the suggested mime                                             
                                          0));

        CloseFile:
                if ( hFile != INVALID_HANDLE_VALUE )
                {
                    Verify(CloseHandle(hFile));
                }
        #endif
                // must be 0
                // Change the EXE sniff from application/x-msdownload because it's better in this case
                
                if ( SUCCEEDED(hr) && StrCmpIC(pszMimeType, _T("application/x-msdownload")) != 0 )
                {
                    hr = THR(AppendEscaped(pszMimeType, pMarkup));
                    if (hr)
                        goto Cleanup;

                    hr = THR(Append("\r\n"));
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    hr = THR(Append("application/octet-stream\r\n"));
                    if (hr)
                        goto Cleanup;
                }



                //  Depending on the MIME type decide on the encoding
                //  If encoding is needed we'll do mime64

                //  Note: Neither Netscape 3 nor apparently IE3.02 do
                //        any encoding when sending binary stuff.
                //        They just send it straight up.

                //hr = pSubmitData->Append("Content-Transfer-Encoding: base64\r\n");
                //if (hr)
                //    goto Cleanup;

                // designates end of header
                hr = THR(Append("\r\n"));
                if (hr)
                    goto Cleanup;

                hr = THR(StartNewItem(POSTDATA_FILENAME));
                if (hr)
                    goto Cleanup;

                hr = THR(AppendUnicode(pchFileName));
                if (hr)
                    goto Cleanup;

                hr = THR(StartNewItem(POSTDATA_LITERAL));
                if (hr)
                    goto Cleanup;

            }
            break;

        case htmlEncodingText:
        case htmlEncodingURL:
            {
                hr = THR(AppendNameValuePair(pchName, pchFileName, pMarkup));
            }
            break;

    } // switch

Cleanup:
    CoTaskMemFree(pszMimeType);
    RRETURN1(hr, S_FALSE);

}

//+--------------------------------------------------------------------------
//
//  Method:     CPostData::AppendFooter
//
//  Synopsis:   Writes the footer for multipart
//
//---------------------------------------------------------------------------
HRESULT
CPostData::AppendFooter()
{
    HRESULT hr;

    switch ( _encType )
    {
        case htmlEncodingMultipart:
            {   
                hr = THR(Append(_achBoundary));
                if ( hr )
                    goto Cleanup;

                hr = THR(Append("--\r\n"));

                _fItemSeparatorIsLast = FALSE;
            }
            break;

        case htmlEncodingText:
            {
                hr = AppendItemSeparator();
            }
            break;

        default:
            {
                hr = S_OK;
            }
            break;

    } // switch

Cleanup:
    RRETURN(hr);
}



//+--------------------------------------------------------------------------
//
//  Method:     CPostData::Finish
//
//  Synopsis:   Wraps up the construction of the submit data
//
//---------------------------------------------------------------------------
HRESULT
CPostData::Finish(void)
{
    HRESULT hr;

    // Eat up any trailing '&'; no need to add the NULL terminator
    hr = THR(RemoveLastItemSeparator());
    if ( hr )
        goto Cleanup;

    hr = THR(AppendFooter());
    if ( hr )
        goto Cleanup;

    //  Flush the last string into its own memory block

    hr = THR(StartNewItem(POSTDATA_UNKNOWN));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+--------------------------------------------------------------
//
//  Member:     CPostData::StartNewItem
//
//  Synopsis:   Flushes the collected data into a string
//              The new Item type will be remembered
//              as new data is being collected.
//
//---------------------------------------------------------------
HRESULT
CPostData::StartNewItem(POSTDATA_KIND ekindNewItem)
{
    HRESULT hr = S_OK;
    CPostItem * pItem;

    //  Create the new chunk if there is any data
    //  Grow the descriptor array as needed

    pItem = new(Mt(CPostItem)) CPostItem[_cItems + 1];
    if ( ! pItem )
        goto MemoryError;

    memcpy(pItem, _pItems, _cItems * sizeof(*pItem) );

    delete [] _pItems;

    _pItems = pItem;

    pItem = _pItems + _cItems;

    _cItems++;

    //  Dump the current data into the Item, set the flag

    pItem->_ePostDataType = _eCurrentKind;

    if ( _eCurrentKind == POSTDATA_FILENAME )
    {
        TCHAR * pszWide;
        UINT ctchAlloc = 1 + _tcslen((TCHAR *)Base());

        pszWide = new(Mt(CPostItem_psz)) TCHAR [ ctchAlloc ];
        if ( ! pszWide )
            goto MemoryError;

        memcpy(pszWide, Base(), ctchAlloc * sizeof(TCHAR));

        pItem->_pszWide = pszWide;
    }
    else if ( _eCurrentKind == POSTDATA_LITERAL )
    {
        char * pszAnsi;

        pszAnsi = new(Mt(CPostItem_psz)) char[1 + Size()];
        if ( ! pszAnsi )
            goto MemoryError;

        memcpy(pszAnsi, Base(), Size());
        pszAnsi[Size()] = '\0';

        pItem->_pszAnsi = pszAnsi;
        pItem->_dwSize = Size();
    }

    //  Reset the data area

    _eCurrentKind = ekindNewItem;
    SetSize(0);
    _cbOld = 0;
    _lLastItemSeparator = 0;
    _fItemSeparatorIsLast = FALSE;

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+--------------------------------------------------------------
//
//  Member:     CPostData::DeleteAllData
//
//  Synopsis:   Deletes all the data in the post form
//
//---------------------------------------------------------------
void
CPostData::DeleteAllData()
{
    // Clear the form items
    _cItems = 0;

    delete [] _pItems;
    _pItems = 0;

    // Clear the data array
    DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\switches.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       switches.cxx
//
//  Contents:   Runtime switches
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

PerfDbgTag(tagSwitchSerialize,     "Switches", "Serialize pre-parser and post-parser")
PerfDbgTag(tagSwitchNoBgRecalc,    "Switches", "Disable background recalc")
PerfDbgTag(tagSwitchNoRecalcLines, "Switches", "Disable flow measuring")
PerfDbgTag(tagSwitchNoRenderLines, "Switches", "Disable flow rendering")
PerfDbgTag(tagSwitchNoImageCache,  "Switches", "Disable image caching")
PerfDbgTag(tagSwitchSyncDatabind,  "Switches", "Grab all databinding records at once")

#if defined(PRODUCT_PROF) || defined(USESWITCHES)

BOOL g_fSwitchSerialize     = FALSE;
BOOL g_fSwitchNoBgRecalc    = FALSE;
BOOL g_fSwitchNoRecalcLines = FALSE;
BOOL g_fSwitchNoRenderLines = FALSE;
BOOL g_fSwitchNoImageCache  = FALSE;
BOOL g_fSwitchSyncDatabind  = FALSE;
BOOL g_fSwitchUseTimers     = FALSE;
BOOL g_fSwitchUseImageTimer = FALSE;
BOOL g_fIsProfiling         = FALSE;
BOOL g_fSwitchNoGDIBatch    = FALSE;

CGlobalCriticalSection g_csTimers;
__int64          g_rgtSum[SWITCHES_TIMER_COUNT];
__int64          g_rgtStack[128];
int              g_rgiStack[128];
int              g_iStackDepth;
int              g_iTimerProfile = -1;
char *           g_rgpchNames[] = 
    { "Tokenize", "Parse", "ComputeFormats", "RecalcLines", "DecodeImage", "Paint", 
      "SBHeapAlloc", "SBHeapAllocClear", "SBHeapGetSize", "SBHeapFree", "SBHeapReAlloc", 
      "ProcHeapAlloc", "ProcHeapAllocClear", "ProcHeapGetSize", "ProcHeapFree", "ProcHeapReAlloc" };

void
InitRuntimeSwitchesFn()
{
#if defined(PRODUCT_PROF)
    char * pszSection = "profile";
#else
    char * pszSection = "retail";
#endif

    g_fSwitchSerialize     = GetPrivateProfileIntA(pszSection, "serialize",     FALSE, "mshtmdbg.ini");
    g_fSwitchNoBgRecalc    = GetPrivateProfileIntA(pszSection, "nobgrecalc",    FALSE, "mshtmdbg.ini");
    g_fSwitchNoRecalcLines = GetPrivateProfileIntA(pszSection, "norecalclines", FALSE, "mshtmdbg.ini");
    g_fSwitchNoRenderLines = GetPrivateProfileIntA(pszSection, "norenderlines", FALSE, "mshtmdbg.ini");
    g_fSwitchNoImageCache  = GetPrivateProfileIntA(pszSection, "noimagecache",  FALSE, "mshtmdbg.ini");
    g_fSwitchSyncDatabind  = GetPrivateProfileIntA(pszSection, "syncdatabind",  FALSE, "mshtmdbg.ini");
    g_fSwitchUseTimers     = GetPrivateProfileIntA(pszSection, "usetimers",     FALSE, "mshtmdbg.ini");
    g_fSwitchUseImageTimer = GetPrivateProfileIntA(pszSection, "useimagetimer", FALSE, "mshtmdbg.ini");
    g_fSwitchNoGDIBatch    = GetPrivateProfileIntA(pszSection, "nogdibatch",    FALSE, "mshtmdbg.ini");

#ifdef PRODUCT_PROF
    char ach[256];
    ach[0] = 0;
    GetPrivateProfileStringA(pszSection, "profiletimer", "", ach, ARRAY_SIZE(ach), "mshtmdbg.ini");
    g_fSwitchUseTimers = FALSE;
    for (int i = 0; i < ARRAY_SIZE(g_rgpchNames); ++i)
    {
        if (lstrcmpiA(ach, g_rgpchNames[i]) == 0)
        {
            g_iTimerProfile = i;
            g_fSwitchUseTimers = TRUE;
            break;
        }
    }
#endif
}

#endif

#ifdef SWITCHTIMERS_ENABLED

void
SwitchesBegTimer(int iTimer)
{
    if (!g_fSwitchUseTimers)
        return;

    if (iTimer == SWITCHES_TIMER_DECODEIMAGE && !g_fSwitchUseImageTimer)
        return;

    SuspendCAP();

    g_csTimers.Enter();

    int i = g_iStackDepth;

    if (i < ARRAY_SIZE(g_rgiStack))
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&g_rgtStack[i]);
        g_rgiStack[i] = iTimer;
        g_iStackDepth += 1;

#ifdef PRODUCT_PROF
        if (g_iTimerProfile >= 0)
        {
            if (g_fIsProfiling && iTimer != g_iTimerProfile)
            {
                StopCAP();
                g_fIsProfiling = FALSE;
            }
            else if (!g_fIsProfiling && iTimer == g_iTimerProfile)
            {
                StartCAP();
                g_fIsProfiling = TRUE;
            }
        }
#endif
    }

    g_csTimers.Leave();

    ResumeCAP();
}

void
SwitchesEndTimer(int iTimer)
{
    if (!g_fSwitchUseTimers)
        return;

    if (iTimer == SWITCHES_TIMER_DECODEIMAGE && !g_fSwitchUseImageTimer)
        return;

    SuspendCAP();

    g_csTimers.Enter();

    int i = g_iStackDepth;
    int j;

    if (i > 0)
    {
        i -= 1;
        __int64 * ptBeg = &g_rgtStack[i];
        int * piTimer = &g_rgiStack[i];
        __int64 tBeg, tEnd;

        for (j = i; j >= 0; --j, --ptBeg, --piTimer)
        {
            if (*piTimer == iTimer)
                break;
        }

        if (j >= 0)
        {
            tBeg = *ptBeg;

            if (j < i)
            {
                tEnd = *(ptBeg + 1);
                memmove(ptBeg, ptBeg + 1, (i - j) * sizeof(__int64));
                memmove(piTimer, piTimer + 1, (i - j) * sizeof(int));
            }
            else
            {
                QueryPerformanceCounter((LARGE_INTEGER *)&tEnd);
            }

            g_iStackDepth -= 1;

            tEnd -= tBeg;

            g_rgtSum[iTimer] += tEnd;

            for (--j, --ptBeg; j >= 0; --j, --ptBeg)
                *ptBeg += tEnd;
        }
    }

#ifdef PRODUCT_PROF
    if (g_iTimerProfile >= 0)
    {
        if (g_fIsProfiling && (g_iStackDepth == 0 || g_rgiStack[g_iStackDepth - 1] != g_iTimerProfile))
        {
            StopCAP();
            g_fIsProfiling = FALSE;
        }
        else if (!g_fIsProfiling && g_iStackDepth > 0 && g_rgiStack[g_iStackDepth - 1] == g_iTimerProfile)
        {
            StartCAP();
            g_fIsProfiling = TRUE;
        }
    }
#endif

    g_csTimers.Leave();

    ResumeCAP();
}

void
SwitchesGetTimers(char * pchBuf)
{
    char * pch = pchBuf;

    if (pch)
    {
        *pch = 0;

        if (!g_fSwitchUseTimers)
            return;

#if !defined(PRODUCT_PROF)
        __int64 tFreq;
        QueryPerformanceFrequency((LARGE_INTEGER *)&tFreq);

        for (int i = 0; i < SWITCHES_TIMER_COUNT; ++i)
        {
            if (g_rgtSum[i] == 0)
                continue;

            wsprintfA(pch, "%s=%ld ", g_rgpchNames[i], ((LONG)(g_rgtSum[i] * 1000L / tFreq)));
            pch += lstrlenA(pch);
        }
#endif
    }

    memset(g_rgtSum, 0, sizeof(g_rgtSum));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\shape.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       shape.cxx
//
//  Contents:   CShape - generic shape class implementation
//
//  Classes:    CShape
//
//---------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_DRAWINFO_HXX_
#include "drawinfo.hxx"
#define X_DRAWINFO_HXX_
#endif

DeclareTag(tagShape, "CShape", "CShape methods");
MtDefine(CShape, Utilities, "CShape")
MtDefine(CWigglyAry, Utilities, "CWigglyAry")
MtDefine(CWigglyAry_pv, Utilities, "CWigglyAry_pv")
MtDefine(CStateArray_pv, Utilities, "CStateArray_pv")
MtDefine(CVSegArray_pv, Utilities, "CVSegArray_pv")
MtDefine(CRectArray_pv, Utilities, "CRectArray_pv")

// Clipping drawing helpers
static void PatBltClipped(XHDC hDC, int x, int y, int dx, int dy, DWORD rop);
static void PatBltRectClipped(XHDC hDC, RECT * prc, int cThick, DWORD rop);

//+-------------------------------------------------------------------------
//
//  Method:     CShape::DrawFocus
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape to
//              indicate that this shape has the focus.
//
//--------------------------------------------------------------------------

void
CShape::DrawShape(CFormDrawInfo * pDI)
{
    POINT           pt;
    XHDC            hDC = pDI->GetDC() ;
    COLORREF        crOldBk, crOldFg ;
    CRect           rectBound;
    const SIZECOORD cThick = (_cThick) ? _cThick : ((g_fHighContrastMode) ? 2 : 1);

    GetBoundingRect(&rectBound);
    if (!rectBound.Intersects(*pDI->ClipRect()))
        return;

    crOldBk = SetBkColor (hDC, RGB (0,0,0)) ;
    crOldFg = SetTextColor (hDC, RGB(0xff,0xff,0xff)) ;

    GetViewportOrgEx (hDC, &pt) ;
    SetBrushOrgEx(hDC, POSITIVE_MOD(pt.x,8)+POSITIVE_MOD(rectBound.left, 8),
                       POSITIVE_MOD(pt.y,8)+POSITIVE_MOD(rectBound.top, 8), NULL);

    Draw(hDC, cThick);

    SetTextColor (hDC, crOldFg);
    SetBkColor   (hDC, crOldBk);
}



//+-------------------------------------------------------------------------
//
//  Method:     CRectShape::GetBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the region(s) enclosed by
//              this shape.
//
//--------------------------------------------------------------------------
void
CRectShape::GetBoundingRect(CRect * pRect)
{
    Assert(pRect);
    *pRect = _rect;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRectShape::OffsetShape
//
//  Synopsis:   Shifts the shape by the given amounts along x and y axes.
//
//--------------------------------------------------------------------------
void
CRectShape::OffsetShape(const CSize & sizeOffset)
{
    _rect.OffsetRect(sizeOffset);
}


//+-------------------------------------------------------------------------
//
//  Method:     CRectShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CRectShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    static short bBrushBits[8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55};

    HBITMAP         hbm;
    HBRUSH          hBrushOld;

    TraceTag((tagShape, "CRectShape::Draw"));

    hbm = CreateBitmap (8, 8, 1, 1, (LPBYTE)bBrushBits) ;
    if (hbm)
    {
        hBrushOld = (HBRUSH)SelectObject(hDC, CreatePatternBrush (hbm));
        if (hBrushOld)
        {
            PatBltRectClipped(hDC, &_rect, cThick, PATINVERT);
            DeleteObject(SelectObject(hDC, hBrushOld));
        }
        DeleteObject (hbm);
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CCircleShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CCircleShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    HBRUSH  hBrushOld;
    HPEN    hPenOld;
    int     nROPOld;

    TraceTag((tagShape, "CCircleShape::Draw"));

    // Select transparent brush to fill the circle
    nROPOld = SetROP2(hDC, R2_XORPEN);
    hPenOld = (HPEN)SelectObject(hDC, (HBRUSH)GetStockObject(WHITE_PEN));
    hBrushOld  = (HBRUSH)SelectObject(hDC, (HBRUSH)GetStockObject(HOLLOW_BRUSH));


    // TODO (MohanB) cThick ignored
    Ellipse(hDC, _rect.left, _rect.top, _rect.right, _rect.bottom);

    SelectObject(hDC, hBrushOld);
    SelectObject(hDC, hPenOld);
    SetROP2(hDC, nROPOld);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCircleShape::Set
//
//  Synopsis:   Set using center and radius
//
//--------------------------------------------------------------------------
void
CCircleShape::Set(POINTCOORD xCenter, POINTCOORD yCenter, SIZECOORD radius)
{
    _rect.SetRect(xCenter - radius, yCenter - radius, xCenter + radius, yCenter + radius);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetPolyBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the given polygon.
//
//--------------------------------------------------------------------------
void
GetPolyBoundingRect(CPointAry& aryPoint, CRect * pRect)
{
    UINT    c;
    POINT * pPt;

    Assert(pRect);
    pRect->SetRectEmpty();

    for (c = aryPoint.Size(), pPt = aryPoint; c > 0; c--, pPt++)
    {
        pRect->Union(*pPt);
    }

}

//+-------------------------------------------------------------------------
//
//  Method:     CPolyShape::GetBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the region(s) enclosed by
//              this shape.
//
//--------------------------------------------------------------------------
void
CPolyShape::GetBoundingRect(CRect * pRect)
{
    GetPolyBoundingRect(_aryPoint, pRect);
}

//+-------------------------------------------------------------------------
//
//  Method:     CPolyShape::OffsetShape
//
//  Synopsis:   Shifts the shape by the given amounts along x and y axes.
//
//--------------------------------------------------------------------------
void
CPolyShape::OffsetShape(const CSize & sizeOffset)
{
    CPoint *    ppt;
    long        cPoints;

    for(cPoints = _aryPoint.Size(), ppt = (CPoint *)&(_aryPoint[0]);
        cPoints > 0;
        cPoints--, ppt++)
    {
        *ppt += sizeOffset;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     DrawPoly
//
//  Synopsis:   Draw the boundary of the given polygon.
//
//--------------------------------------------------------------------------

void
DrawPoly(CPointAry & aryPoint, XHDC hDC, SIZECOORD cThick)
{
    POINT * ppt;
    UINT    c;
    HPEN    hPenOld;
    HBRUSH  hBrushOld;
    int     nROPOld;

    // Do we have enough points to draw a polygon ?
    if (aryPoint.Size() < 2)
        return;

    // TODO (MohanB) cThick ignored

    nROPOld = SetROP2(hDC, R2_XORPEN);
    hPenOld = (HPEN)SelectObject(hDC, (HBRUSH)GetStockObject(WHITE_PEN));
    hBrushOld  = (HBRUSH)SelectObject(hDC, (HBRUSH)GetStockObject(HOLLOW_BRUSH));

    MoveToEx(hDC, aryPoint[0].x, aryPoint[0].y, (POINT *)NULL);
    for(c = aryPoint.Size(), ppt = &(aryPoint[1]);
        c > 1;                  // c > 1, because we MoveTo'd the first pt
        ppt++, c--)
    {
        LineTo(hDC, ppt->x, ppt->y);
    }
    //
    // If there are only 2 points in the polygon, we don't want to draw
    // the same line twice and end up with nothing!
    //

    if(aryPoint.Size() != 2)
    {
        LineTo(hDC, aryPoint[0].x, aryPoint[0].y);

    }
    SelectObject(hDC, hBrushOld);
    SelectObject(hDC, hPenOld);
    SetROP2(hDC, nROPOld);
}


//+-------------------------------------------------------------------------
//
//  Method:     CPolyShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CPolyShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    TraceTag((tagShape, "CPolyShape::Draw"));

    DrawPoly(_aryPoint, hDC, cThick);

}


//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::~CWigglyShape
//
//  Synopsis:   Release the CRectShape objects in the array
//
//--------------------------------------------------------------------------
CWigglyShape::~CWigglyShape()
{
    UINT           c;
    CRectShape **  ppWiggly;

    for(c = _aryWiggly.Size(), ppWiggly = _aryWiggly; c > 0; c--, ppWiggly++)
    {
        delete *ppWiggly;
        *ppWiggly = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::GetBoundingRect
//
//  Synopsis:   Return the bounding rectangle of the region(s) enclosed by
//              this shape.
//
//--------------------------------------------------------------------------
void
CWigglyShape::GetBoundingRect(CRect * pRect)
{
    UINT           c;
    CRectShape **  ppWiggly;
    CRect          rectWiggly;

    Assert(pRect);
    pRect->SetRectEmpty();

    for(c = _aryWiggly.Size(), ppWiggly = _aryWiggly; c > 0; c--, ppWiggly++)
    {
        (*ppWiggly)->GetBoundingRect(&rectWiggly);
        pRect->Union(rectWiggly);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::OffsetShape
//
//  Synopsis:   Shifts the shape by the given amounts along x and y axes.
//
//--------------------------------------------------------------------------
void
CWigglyShape::OffsetShape(const CSize & sizeOffset)
{
    CRectShape ** ppWiggly;
    long          cWigglies;

    for(cWigglies = _aryWiggly.Size(), ppWiggly = _aryWiggly;
        cWigglies > 0;
        cWigglies--, ppWiggly++)
    {
        (*ppWiggly)->_rect.OffsetRect(sizeOffset);

    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::Draw
//
//  Synopsis:   Draw the boundary of the region(s) enclosed by this shape
//
//--------------------------------------------------------------------------

void
CWigglyShape::Draw(XHDC hDC, SIZECOORD cThick)
{
    static short bBrushBits[8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55};

    HBITMAP         hbm;
    HBRUSH          hBrushOld;

    TraceTag((tagShape, "CWigglyShape::Draw"));
    
    hbm = CreateBitmap (8, 8, 1, 1, (LPBYTE)bBrushBits) ;
    hBrushOld = (HBRUSH)SelectObject(hDC, CreatePatternBrush (hbm));


    // In the case there is just one rect, just draw the rect
    // This will be the majority of cases.
    if (_aryWiggly.Size() == 1)
    {
        _aryWiggly[0]->Draw(hDC, cThick);
    }
    else
    {
        DrawMultiple(hDC, cThick);
    }

    DeleteObject(SelectObject(hDC, hBrushOld));
    DeleteObject (hbm);
}


// here are some data structures used by DrawMultiple, below

DECLARE_CStackPtrAry(CRectArray, CRectShape *, 16, Mt(Mem), Mt(CRectArray_pv));

struct SWEEPSTATE { LONG cx;  LONG cDelta; };
DECLARE_CStackDataAry(CStateArray, SWEEPSTATE, 16, Mt(Mem), Mt(CStateArray_pv));

struct VSEGMENT { long cx;  CPoint ptTopLeft; };
DECLARE_CStackDataAry(CVSegArray, VSEGMENT, 16, Mt(Mem), Mt(CVSegArray_pv));


//+-------------------------------------------------------------------------
//
//  Method:     AddDelta (local helper)
//
//  Synopsis:   Add an (x, delta) pair to the given sweep state array.
//              Keep the array sorted in descending order by x, so that
//              looping through it backwards corresponds to left-to-right.
//
//--------------------------------------------------------------------------

static void
AddDelta(CStateArray *pary, LONG cx, LONG cDelta)
{
    int i;
    int n = pary->Size();

    for (i = 0;  i < n;  ++i)
    {
        if ((*pary)[i].cx <= cx)
            break;
    }

    if (i < n  &&  (*pary)[i].cx == cx)
    {
        // update delta for an existing x
        (*pary)[i].cDelta += cDelta;

        // if it's now zero, remove it
        if ((*pary)[i].cDelta == 0)
        {
            pary->Delete(i);
        }
    }
    else
    {
        // add a new x
        SWEEPSTATE s = {cx, cDelta};
        pary->InsertIndirect(i, &s);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWigglyShape::DrawMultiple
//
//  Synopsis:   When there's more than one rect, perform a sweep-line algorithm
//              to identify which edges (or pieces thereof) need to be drawn.
//              We only draw an edge where one side of the edge is outside all
//              the rects and the other is inside at least one.  We need to
//              handle cases where edges from different rects lie atop one
//              another.  We'll sweep a horizontal line from top to bottom.
//              At each step, we'll draw horizontal segments that lie on the
//              sweep line, identify and remember vertical segments that begin
//              on the sweep line, and draw vertical segments that end on
//              the sweep line.
//
//--------------------------------------------------------------------------

void
CWigglyShape::DrawMultiple(XHDC hDC, SIZECOORD cThick)
{
    int             i, j;
    CRectShape *    pWiggly;
    int             cWigglys = _aryWiggly.Size();

    // Step 1.  To prepare for the sweep-line loop, make two sorted lists of the
    // rects, one sorted by top edge, the other by bottom edge.

    CRectArray aryByTop;
    CRectArray aryByBottom;

    aryByTop.EnsureSize(cWigglys);
    aryByBottom.EnsureSize(cWigglys);
    for (i = 0;  i < cWigglys;  ++i)    // insertion sort
    {
        pWiggly = _aryWiggly[i];
        
        for (j = i-1;  j>=0 && aryByTop[j]->_rect.top > pWiggly->_rect.top;  --j)
        {
            aryByTop[j+1] = aryByTop[j];
        }
        aryByTop[j+1] = pWiggly;

        for (j = i-1;  j>=0 && aryByBottom[j]->_rect.bottom > pWiggly->_rect.bottom;  --j)
        {
            aryByBottom[j+1] = aryByBottom[j];
        }
        aryByBottom[j+1] = pWiggly;
    }

    // Step 2.  Initialize two arrays that hold the state of the sweep
    // line just before and just after the current y position.  The state is
    // represented by an array of (x, delta) pairs, one for each x-coordinate
    // where a vertical line crosses the sweep line.  The delta measures the
    // change in the number of enclosing rectangles as we cross from left to right.
    // Each array ends with a sentinel value (x = infinity) to make loops easy.

    CStateArray aryState1, aryState2;

    aryState1.SetSize(1);
    aryState1[0].cx = MAXLONG;

    aryState2.SetSize(1);
    aryState2[0].cx = MAXLONG;

    CStateArray *paryStateAbove = &aryState1;
    CStateArray *paryStateBelow = &aryState2;
    CStateArray *paryStateTemp;

    // Step 3.  Initialize (to empty) the list of visible vertical segments
    // that cross the sweep line.  Each edge is represented by its x coordinate,
    // plus the top-left point where we'll start drawing it once the sweep
    // line reaches its bottom.

    CVSegArray aryVSegments;
    VSEGMENT vseg;

    // Step 4.  Start the sweep line.

    int iTop = 0,  iBottom = 0;
    LONG x, y;

    while (iBottom < cWigglys)  // iBottom <= iTop, so this test is enough
    {
        Assert(iBottom <= iTop);

        // Step 5.  Advance sweep line to the next interesting y, namely the
        // smaller of the first remaining values in the "top" and "bottom"
        // lists.

        y = aryByBottom[iBottom]->_rect.bottom;
        if (iTop < cWigglys && y > aryByTop[iTop]->_rect.top)
            y = aryByTop[iTop]->_rect.top;

        // Step 6.  The sweep state just above y is the same as the state just
        // below the previous y.  Switch the roles of above and below.  To
        // prepare for computing the sweep state just below y,
        // copy the state just above it.

        paryStateTemp = paryStateAbove;
        paryStateAbove = paryStateBelow;
        paryStateBelow = paryStateTemp;

        paryStateBelow->Grow(paryStateAbove->Size());
        for (i = paryStateAbove->Size() - 1;  i >= 0;  --i)
        {
            (*paryStateBelow)[i] = (*paryStateAbove)[i];
        }

        // Step 7.  Change the state below y by accounting for the rects whose
        // top or bottom edge is at y.

        for ( ;  iTop < cWigglys && y == aryByTop[iTop]->_rect.top;  ++iTop)
        {
            AddDelta( paryStateBelow, aryByTop[iTop]->_rect.left,  +1 );
            AddDelta( paryStateBelow, aryByTop[iTop]->_rect.right, -1 );
        }

        for ( ;  iBottom < cWigglys && y == aryByBottom[iBottom]->_rect.bottom;  ++iBottom)
        {
            AddDelta( paryStateBelow, aryByBottom[iBottom]->_rect.left,  -1 );
            AddDelta( paryStateBelow, aryByBottom[iBottom]->_rect.right, +1 );
        }

        // Step 8.  Move left-to-right across the sweep line, stopping at each
        // x-coordinate mentioned in either state.

        int iAbove = paryStateAbove->Size() - 1;
        int iBelow = paryStateBelow->Size() - 1;
        LONG cRectsAbove = 0,  cRectsBelow = 0;
        LONG xStart = 0, yStart = 0;        // current horizontal segment

        for (;;)
        {
            x = (*paryStateAbove)[iAbove].cx;
            if (x > (*paryStateBelow)[iBelow].cx)
                x = (*paryStateBelow)[iBelow].cx;
            if (x == MAXLONG)
                break;

            // Step 9.  Determine whether each of the four quadrants around
            // (x,y) is inside or outside the region.  Encode the results
            // in a string of four bits where 1=inside, 0=outside.  The
            // bits, in msb-to-lsb order are: above-left, above-right,
            // below-left, below-right.

            unsigned u = ((cRectsAbove>0) <<3 ) | ((cRectsBelow>0) << 1);

            for ( ;  x == (*paryStateAbove)[iAbove].cx;  --iAbove)
            {
                cRectsAbove += (*paryStateAbove)[iAbove].cDelta;
            }

            for ( ;  x == (*paryStateBelow)[iBelow].cx;  --iBelow)
            {
                cRectsBelow += (*paryStateBelow)[iBelow].cDelta;
            }

            u |= ((cRectsAbove>0) << 2) | ((cRectsBelow>0) << 0);

            // Step 10.  The interesting part.  Depending on what's happening
            // near (x, y), start or stop visible segments.  The best way
            // to understand what to do is to simply draw the picture.  Words
            // don't help much.  Except to note that at corners, we always
            // give the corner to the horizontal segment.

            #define StartHorizontalSegment(x, cx, cy) \
                xStart = cx; \
                yStart = cy;

            #define EndHorizontalSegment(x, cx, cy) \
                PatBltClipped (hDC, \
                        xStart, yStart, \
                        cx-xStart, cy-yStart, \
                        PATINVERT);

            #define StartVerticalSegment(x, xx, yy) \
                vseg.cx = x; \
                vseg.ptTopLeft.x = xx; \
                vseg.ptTopLeft.y = yy; \
                aryVSegments.AppendIndirect(&vseg);

            #define EndVerticalSegment(x, xx, yy) \
                for (i=aryVSegments.Size()-1; i>=0; --i) \
                { \
                    if (x == aryVSegments[i].cx) \
                        break; \
                } \
                if (i >= 0) \
                { \
                    PatBltClipped (hDC, \
                            aryVSegments[i].ptTopLeft.x, aryVSegments[i].ptTopLeft.y, \
                            xx-aryVSegments[i].ptTopLeft.x, yy-aryVSegments[i].ptTopLeft.y, \
                            PATINVERT); \
                    aryVSegments.Delete(i); \
                }
                    
                
            switch (u)
            {
            case 0x0:   // 00/00    this shouldn't happen
            default:    //          this really shouldn't happen
                AssertSz(0, "This shouldn't happen");
                break;

            case 0x1:   // 00/01
                StartHorizontalSegment(x, x, y);
                StartVerticalSegment(x, x, y+cThick);
                break;

            case 0x3:   // 00/11
                break;

            case 0x2:   // 00/10
                EndHorizontalSegment(x, x, y+cThick);
                StartVerticalSegment(x, x-cThick, y+cThick);
                break;

            case 0x4:   // 01/00
                StartHorizontalSegment(x, x, y-cThick);
                EndVerticalSegment(x, x+cThick, y-cThick);
                break;

            case 0x5:   // 01/01
                break;

            case 0x6:   // 01/10
                EndHorizontalSegment(x, x, y+cThick);
                StartHorizontalSegment(x, x, y-cThick);
                EndVerticalSegment(x, x+cThick, y-cThick);
                StartVerticalSegment(x, x-cThick, y+cThick);
                break;

            case 0x7:   // 01/11
                EndHorizontalSegment(x, x+cThick, y+cThick);
                EndVerticalSegment(x, x+cThick, y);
                break;

            case 0x8:   // 10/00
                EndHorizontalSegment(x, x, y);
                EndVerticalSegment(x, x, y-cThick);
                break;

            case 0x9:   // 10/01
                EndHorizontalSegment(x, x, y);
                StartHorizontalSegment(x, x, y);
                EndVerticalSegment(x, x, y-cThick);
                StartVerticalSegment(x, x, y+cThick);
                break;

            case 0xA:   // 10/10
                break;

            case 0xB:   // 10/11
                StartHorizontalSegment(x, x-cThick, y);
                EndVerticalSegment(x, x, y);
                break;

            case 0xC:   // 11/00
                break;

            case 0xD:   // 11/01
                EndHorizontalSegment(x, x+cThick, y);
                StartVerticalSegment(x, x, y);
                break;

            case 0xE:   // 11/10
                StartHorizontalSegment(x, x-cThick, y-cThick);
                StartVerticalSegment(x, x-cThick, y);
                break;

            case 0xF:   // 11/11
                break;
            }
            
        } // for (;;) -- left-to-right scan across sweep line

        Assert(cRectsAbove == 0 && cRectsBelow == 0);

    } // while (iBottom < cWigglys) -- main sweep-line loop

    Assert(aryVSegments.Size() == 0);
}

//+-----------------------------------------------------------------------------
//
//  Method:     PatBltClipped
//
//  Synopsis:   Draw specified rectangle, as XHDC::PatBlt() do,
//              but clip it before drawing, if XHDC contains proper clipping data.
//
//  Arguments:  hDC     extended DC to draw in
//              x,y     rectangle left top (source coords)
//              dx,dy   rectangle size (source coords)
//              rop     rater operation code
//
//  Note:
//      there is a suspicion that XHDC should do clipping itself.
//      If it will be corrected so, this method can be removed, with changing
//      calls to PatBlt(XHDC...) (mikhaill 10/27/00, bug 6672)
//
//------------------------------------------------------------------------------

static void
PatBltClipped(XHDC hDC, int x, int y, int dx, int dy, DWORD rop)
{
    CRect const*  pClipRect = 0;
    {
        const CDispSurface *pSurface = hDC.pSurface();
        if (pSurface)
        {
            CDispClipTransform const* pTransform = ((CDispSurface*)pSurface)->GetTransform();
            if (pTransform)
            {
                pClipRect = &pTransform->GetClipRect();
            }
        }
    }

    CRect rc(x, y, x+dx, y+dy);
    if (pClipRect)
        rc.IntersectRect(*pClipRect);
    if (!rc.IsEmpty())
        PatBlt(hDC, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, rop);
}

//+-----------------------------------------------------------------------------
//
//  Method:     PatBltRectClipped
//
//  Synopsis:   Draw specified rectangle boundaries
//
//  Arguments:  hDC     extended DC to draw in
//              prc     rectangle to draw, in hDC source coords
//              cThick  boundary thickness
//              rop     rater operation code
//
//  Note:
//      This routine made by cut-and-paste from PatBltRect(), in order to add clipping.
//      If XHDC implementation will be corrected to provide clipping itself,
//      these two routines can be combined in single one.
//
//------------------------------------------------------------------------------

static void
PatBltRectClipped(XHDC hDC, RECT * prc, int cThick, DWORD rop)
{
    PatBltClipped(
            hDC,
            prc->left,
            prc->top,
            prc->right - prc->left,
            cThick,
            rop);

    PatBltClipped(
            hDC,
            prc->left,
            prc->bottom - cThick,
            prc->right - prc->left,
            cThick,
            rop);

    PatBltClipped(
            hDC,
            prc->left,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            rop);

    PatBltClipped(
            hDC,
            prc->right - cThick,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            rop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\strbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       strbuf.cxx
//
//  Contents:   CStreamWriteBuff
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

MtDefine(CStreamReadBuff,  Utilities, "CStreamReadBuff")
MtDefine(CStreamWriteBuff, Utilities, "CStreamWriteBuff")

extern const TCHAR* LookUpErTable(TCHAR ch, BOOL fCp1252);

BOOL ChrLower(TCHAR ch) { return _T('a') <= ch && ch <= _T('z'); } ;

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::CStreamWriteBuff
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------

CStreamWriteBuff::CStreamWriteBuff(IStream *pStm, CODEPAGE cp) :
                   CEncodeWriter( cp, WBUFF_SIZE )
{
    Assert(pStm);

    _pStm               = pStm;
    _pStm->AddRef( );

    _ichLastNewLine     = 0;        // index of the last newline char in the
                                    // wide char buffer
    _iLastValidBreak    = 0;        // index of the last valid break char in the
                                    // wide char buffer
    _cPreFormat         = 0;        // indicates the level of preformatted mode
    _cSuppress          = 0;        // level of suppression
    _cchIndent          = 0;        // no. of indentation chars at the begining
                                    // of the line
    _dwFlags            = WBF_ENTITYREF;
                                    // Turn on entity reference conversion mode.

    _pElementContext    = NULL;     // Element which we are saving (null if no
                                    // specific element)

    _fNeedIndent        = TRUE;     // Keep track of indent state

    _pExtendedTagTable  = NULL;

    WHEN_DBG( _fValidateDbg = TRUE );
}

HRESULT
CStreamWriteBuff::Init()
{
    HRESULT hr;
    WHEN_DBG( _fInited = TRUE );
    
    // Allocate a wide char buffer (this will allocate _nBlockSize wchars)
    hr = THR( PrepareToEncode() );
    if( hr )
        goto Cleanup;
    Assert( _pchBuffer );

    // Allocate a MB buffer (this may grow if necessary)
    hr = THR( MakeRoomForChars( _nBlockSize * 2 ) );
    if( hr )
        goto Cleanup;
    Assert( _pbBuffer );

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::~CStreamWriteBuff
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CStreamWriteBuff::~CStreamWriteBuff()
{
#if DBG==1
    if( _fValidateDbg )
    {
//        AssertSz(_cchIndent == 0, "Improper indentation");
//        AssertSz(_cPreFormat == 0, "Pre-formated block(s) not terminated");
        AssertSz(_cSuppress == 0, "Suppress mode not terminated");
    }
#endif // DBG

    Flush();
    _pStm->Release( );

    if (_pExtendedTagTable)
    {
        _pExtendedTagTable->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::Terminate
//
//  Synopsis:   Appends a null character at the end of the stream
//
//----------------------------------------------------------------------------
HRESULT CStreamWriteBuff::Terminate()
 {
    HRESULT hr = S_OK;

    Assert( _fInited );
    hr = FlushWBuffer(FALSE, FALSE);   // flush from wchar to multibyte
    if( hr )
        goto Cleanup;

    Assert( _pbBuffer != NULL );

    hr = WriteDirectToMultibyte('\0', 1);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::FlushMBBuffer()
//
//  Synopsis:   Flush the ansi buffer on to an IStream object.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::FlushMBBuffer()
{
    HRESULT hr = S_OK;

    Assert( _fInited );
    if (_pbBuffer && _cbBuffer)
    {
        hr = THR(_pStm->Write(_pbBuffer, _cbBuffer, NULL));

        _cbBuffer = 0;                           // reset index to 0
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::Write
//
//  Synopsis:   Write a string into the buffer
//
//  Arguments:  const   TCHAR *     output string
//                      int         length of the string
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::Write(const TCHAR *pch, int cch)
{
            HRESULT hr = S_OK;
    const   TCHAR*  pchER;      // entity reference
            TCHAR   chCur;
            TCHAR   chCR[20];   // character reference
            int     cchWAvail;
            int     nLen;
            // contain indentation
            int     cchIndent = (_cchIndent > 32) ? 32 : _cchIndent;
    const   BOOL    fCp1252 = (_uiWinCodepage == 1252);
    const   TCHAR   chNBSPMaybe = (   TestFlag(WBF_FOR_RTF_CONV)
                                   || TestFlag(WBF_SAVE_PLAINTEXT))
                                  ? WCH_NBSP : 0;
    const   BOOL    fVerbatim = _cPreFormat || TestFlag(WBF_SAVE_VERBATIM);

    Assert( _fInited );

    // Check if we are suppressing output
    if (_cSuppress)
        return S_OK;

    if( !TestFlag(WBF_FORMATTED) )
        cchIndent = 0;

    if ( !pch || !cch )
        return S_OK;

    if(cch < 0)
        cch = _tcslen(pch);

    chCR[0] = _T('#');

    while (cch)
    {
        if (_fNeedIndent)
        {
            _fNeedIndent = FALSE;

            if (!fVerbatim)
            {
                hr = THR(WriteDirectToMultibyte(' ', cchIndent));
                if (hr)
                    goto CleanUp;
            }
        }

        cchWAvail = _nBlockSize - _cchBuffer;
        AssertSz (_cchBuffer <= _nBlockSize, "CStreamWriteBuff::Wide Char Buffer overflow");

        chCur = *pch;
        pchER = NULL;

        // If we are in enitise mode and not saving in plaintext,
        // entitise the current char - otherwise, we may convert NBSPs to
        // spaces in two cases:
        // 1. if we're on a FE system and writing plaintext, since those
        //    charsets do not have a multibyte NBSP character.
        // 2. if we're saving for the rtf converter

        nLen = 1;

        if (chCur == chNBSPMaybe)
        {
            chCur = L' ';  // (cthrash) this is a bit of a hack.
        }
        else if (TestFlag(WBF_ENTITYREF) && !TestFlag(WBF_SAVE_PLAINTEXT))
        {
            BOOL fEntitize;

            if (IsAscii(chCur))
            {
                fEntitize =    (chCur == WCH_QUOTATIONMARK && !TestFlag(WBF_NO_DQ_ENTITY))
                            || (chCur == WCH_AMPERSAND     && !TestFlag(WBF_NO_AMP_ENTITY))
                            || (chCur == WCH_LESSTHAN      && !TestFlag(WBF_NO_LT_ENTITY))
                            || (chCur == WCH_GREATERTHAN   && !TestFlag(WBF_NO_LT_ENTITY))
                            || (chCur <  _T(' ')           &&  TestFlag(WBF_CRLF_ENTITY));
            }
            else 
            {
                fEntitize =    !TestFlag(WBF_NO_NAMED_ENTITIES)
                            && (   chCur == WCH_NBSP
                                || chCur == WCH_NONREQHYPHEN);
            }

            if (fEntitize)
            {
                // N.B. (johnv) If we do not have an entry in the entity table,
                // just let the character through as is.  Our superclass
                // CEncodeWriter will take care of entitizing characters not
                // available in the current character set.

                if (chCur < _T(' ') && TestFlag(WBF_CRLF_ENTITY))
                {
                    pchER = chCR;
                    _ultot(chCur, chCR + 1, 10);
                }
                else
                {
                    pchER = LookUpErTable(chCur, fCp1252);
                    Assert(pchER);
                }
                nLen = _tcslen(pchER) + 2; // for & and ;
            }
        }

        // If we do not have enough space in the wide char buffer,
        // move the contents from lastnewline to the end of the
        // buffer to the begining of the buffer
        while(cchWAvail < nLen + 1)
        {
            // If we did not find a place to break in the entire buffer
            // flush the entire buffer.
            if(!_ichLastNewLine)
            {
                // If we need to make space then we should have flushed
                // the line when we went over 80 chars.  We should never
                // have the case where we have a line under 80 chars and
                // we need to make space.
                Assert( _iLastValidBreak == 0 );

                // full buffer without a valid line break
                _iLastValidBreak = _cchBuffer;    // to flush the entire buffer

                hr = FlushWBuffer(FALSE, FALSE);
                if( hr )
                    goto CleanUp;

                _cchBuffer = 0;
                _ichLastNewLine = 0;
                _iLastValidBreak = 0;
                cchWAvail = _nBlockSize;

                Assert( cchWAvail >= nLen + 1 );
            }
            else
            {
                // move the memory from lastnewline
                _cchBuffer = _nBlockSize - _ichLastNewLine - cchWAvail;
                memmove(&_pchBuffer[0],
                        &_pchBuffer[_ichLastNewLine],
                        _cchBuffer * sizeof(TCHAR));
                _iLastValidBreak = _iLastValidBreak - _ichLastNewLine;
                _ichLastNewLine = 0;
                cchWAvail = _nBlockSize - _cchBuffer;
            }
        }

        // If we can break, and we are not saving pre formatted text
        // updated the valid break index.
        if(!TestFlag(WBF_NO_WRAP) && !_cPreFormat)
        {
            if (chCur == _T(' '))           // space is a valid break
            {
                _iLastValidBreak = _cchBuffer+1;
            }
        }

        // Ignore cariage returns and linefeed if we are not
        // are not saving preformatted text
        if(!_cPreFormat && !TestFlag(WBF_KEEP_BREAKS) &&
                (chCur == _T('\r') || chCur == _T('\n')))
        {
            _iLastValidBreak = _cchBuffer;

            pch++;
            cch--;
            continue;
        }

        // write the entitised string or char in to the wide char buffer.
        if(pchER)
        {
            _pchBuffer[_cchBuffer++] = _T('&');
            memcpy(&_pchBuffer[_cchBuffer], pchER, sizeof(TCHAR) *(nLen - 2));
            _cchBuffer += nLen - 2;
            _pchBuffer[_cchBuffer++] = _T(';');
        }
        else
        {
            _pchBuffer[_cchBuffer++] = chCur;

            // For preformatted we have written the \r, now we have to write \n
            //  (unless already present)
            // NOTE: \r's need \n's when saving from textarea (paulpark)
            if(chCur == _T('\r') && _cPreFormat)
            {
                if (!TestFlag(WBF_SAVE_VERBATIM) &&
                    (cch == 1 ||
                    (cch > 1 && pch[1] != _T('\n'))))
                {
                    _pchBuffer[_cchBuffer++] = _T('\n');
                }
                _iLastValidBreak = _cchBuffer;
                NewLine();
            }
        }

        // If we have more than 80 chars in the wide char buff,
        // and have seen a break, flush them to the ansi char buffer
        if(_ichLastNewLine != _iLastValidBreak &&
                _cchBuffer - _ichLastNewLine + cchIndent > 80)
        {
            hr = NewLine();
            if(hr)
                goto CleanUp;
        }

        cch--;
        pch++;
    }

CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::WriteDirectToMultibyte
//
//  Synopsis:   This function throws characters as is into the multibyte character,
//              unless we are writing out unicode, in which case we add a null
//              character after each byte.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::WriteDirectToMultibyte(CHAR ch, int iRepeat)
{
    HRESULT hr = S_OK;

    Assert( _fInited );

    // Make sure we have something to do
    if( _cSuppress || iRepeat <= 0 )
        return S_OK;

    if(     _cp == NATIVE_UNICODE_CODEPAGE 
        ||  _cp == NATIVE_UNICODE_CODEPAGE_BIGENDIAN )
    {
        // CONSIDER: support for NONNATIVE (UCS_4 on Win32) support
        WCHAR  tch = WCHAR(ch);
        WCHAR *pch;
        int    cch;

        // Shift for BIGENDIAN -- 8 for Win32, 24 for UNIX
        if (_cp == NATIVE_UNICODE_CODEPAGE_BIGENDIAN )
        {
#ifdef UNIX
            tch <<= 24;
#else
            tch <<= 8;
#endif
        }

        if (_cbBuffer + int(iRepeat * sizeof(TCHAR)) >= _cbBufferMax )
        {
            hr = FlushMBBuffer();
            if( hr )
                goto Cleanup;
        }

        Assert(_cbBufferMax - _cbBuffer >= int(iRepeat * sizeof(TCHAR)));

        cch = min( int((_cbBufferMax - _cbBuffer) / sizeof(TCHAR)), iRepeat);
        pch = (WCHAR *)(_pbBuffer + _cbBuffer);
        _cbBuffer += cch * sizeof(TCHAR);
        while(cch-- > 0)
        {
            *pch++ = tch;
        }
    }
    else
    {
        int cb;

        if (_cbBuffer + iRepeat >= _cbBufferMax)
        {
            hr = FlushMBBuffer();
            if( hr )
                goto Cleanup;
        }

        Assert(_cbBufferMax - _cbBuffer >= iRepeat);

        cb = min(_cbBufferMax - _cbBuffer, iRepeat);
        memset(_pbBuffer + _cbBuffer, ch, cb);
        _cbBuffer += cb;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::FlushWBuffer
//
//  Synopsis:   Writes the current line from wide char buffer to the ansi
//              buffer and write new line and spaces if there is any indentation
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::FlushWBuffer(BOOL fIndent, BOOL fNewLine)
{
    HRESULT hr = S_OK;
    int     nLineLength;
    int     cchIndent = (_cchIndent > 32) ? 32 : _cchIndent;

    Assert( _fInited );

    if( !TestFlag(WBF_FORMATTED) )
        cchIndent = 0;

    // new line is called explictly or when the number of chars in the
    // wide char buffer exceed 80.
    if(_cchBuffer - _ichLastNewLine + cchIndent > 80 &&
        _ichLastNewLine != _iLastValidBreak)
    {
        nLineLength = _iLastValidBreak  - _ichLastNewLine;
    }
    else
    {
        // line without a word break or in a pre
        nLineLength = _cchBuffer - _ichLastNewLine;
    }

    // convert wide char to ansi and save in the ansi buffer
    if(nLineLength)
    {
        int cch;

        if(int(sizeof(TCHAR) * nLineLength) > _cbBufferMax - _cbBuffer)
        {
            hr = THR( FlushMBBuffer( ) );
            if( hr )
                goto Cleanup;

            Assert( _pbBuffer != NULL );
        }

        {
            // N.B. (johnv) This will be cleaned up when this class gets
            // re-worked.
            TCHAR* pchBufferPtrSave = _pchBuffer;
            int    cchBufferSave = _cchBuffer;

            _cchBuffer  = nLineLength;
            _pchBuffer += _ichLastNewLine;

            hr = THR( MultiByteFromWideChar( TRUE, &cch ) );

            _pchBuffer = pchBufferPtrSave;
            _cchBuffer = cchBufferSave;

            // N.B. (johnv) Make sure _pchBuffer and _cchBuffer are restored
            // before cleaning up, or you may free invalid memory.
            if( hr )
                goto Cleanup;

        }
    }

    _ichLastNewLine += nLineLength;
    _iLastValidBreak = _ichLastNewLine;

    // If we are not in a preformatted block then write a carriage return,
    // linefeed and spaces for indentation if any.
    if (fNewLine)
    {
        if (!_cPreFormat && !TestFlag(WBF_SAVE_VERBATIM))
        {
            IGNORE_HR(WriteDirectToMultibyte('\r', 1));
            IGNORE_HR(WriteDirectToMultibyte('\n', 1));

            _fNeedIndent = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::WriteRule
//
//  Synopsis:   Writes a horizontal rule
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT CStreamWriteBuff::WriteRule()
{
    HRESULT hr = S_OK;
    int     cchIndent = (_cchIndent > 32) ? 32 : _cchIndent;

    Assert( _fInited );

    // Check to see if we are in suppress mode
    if (_cSuppress)
        return S_OK;

    if( !TestFlag(WBF_FORMATTED) )
        cchIndent = 0;

    hr = THR(WriteDirectToMultibyte('-', 80 - cchIndent));

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::Flush()
//
//  Synopsis:   Flush the contents of the stream buffer to the IStream object.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::Flush()
{
    HRESULT hr;

    Assert( _fInited );

    hr = FlushWBuffer(FALSE, FALSE);
    if(!hr)
    {
        hr = FlushMBBuffer();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::WriteQuotedText( TCHAR* pch )
//
//  Synopsis:   This function writes the specified text in either single or
//              double quotes.  If necessary, it entitizes the contents
//              of pch.  The rules are as follows:
//
//              1. If pch contains no single quotes or spaces, do not
//                 entitize, and output pch in double quotes.
//              2. If pch contains double quotes but no single quotes,
//                 do not entitize, and output pch in single quotes.
//              3. If pch contains both double and single quotes, output
//                 an entitized pch in double quotes.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::WriteQuotedText( const TCHAR * pch, BOOL fAlwaysQuote )
{
    HRESULT hr = S_OK;
    const TCHAR*  pbuf;
    BOOL    fHasDoubleQuotes = FALSE, fHasSingleQuotes = FALSE;

    Assert( _fInited );

    // First search for double quotes, single quotes, and characters less
    // than the space character.
    pbuf = pch;
    if( !*pbuf )
    {
        fAlwaysQuote = TRUE;
    }
    else
    {
        while( *pbuf )
        {
            if( *pbuf == _T('"') )
                fHasDoubleQuotes = TRUE;
            else if( *pbuf == _T('\'') )
                fHasSingleQuotes = TRUE;
            else if( *pbuf <= _T(' ') )
                fAlwaysQuote = TRUE;        // if we have spaces, we must quote
            else if( *pbuf == _T('<') || *pbuf == _T('>') )
                fAlwaysQuote = TRUE;        // if we have an ASP script, we must quote

            pbuf++;
        }
    }

    if( fAlwaysQuote || fHasDoubleQuotes || fHasSingleQuotes )
    {
        TCHAR   szQuote[2];
        DWORD   dwOldFlags = 0;
        DWORD   dwNewFlags = 0;
    
        if (fHasDoubleQuotes && !fHasSingleQuotes)
        {
            // Although IE5 26994 indicates we should never use single quotes,
            // IE5 53563 indicates we should use single quotes if double quotes are inside
            // the string; 53563 won, so we use single quotes (dbau)
            szQuote[0] = _T('\'');
            szQuote[1] = 0;
            dwNewFlags = WBF_ENTITYREF | WBF_CRLF_ENTITY | WBF_NO_WRAP | WBF_NO_LT_ENTITY | WBF_KEEP_BREAKS | WBF_NO_DQ_ENTITY;
        }
        else
        {
            szQuote[0] = _T('"');
            szQuote[1] = 0;
            // We should not be entitizing LT and GT, since ASP editing using VID counts on that.
            // Although it is not IE40 behavior, this is necessary for ASP editing. (ferhane)
            dwNewFlags = WBF_ENTITYREF | WBF_CRLF_ENTITY | WBF_NO_WRAP | WBF_NO_LT_ENTITY | WBF_KEEP_BREAKS;
        }

 
        hr = Write(szQuote, 1*sizeof(TCHAR), 0);
        if( hr )
            goto Cleanup;

        // Special entity rules when quoting
        dwOldFlags = SetFlags(dwNewFlags);

        hr = Write(pch, _tcslen(pch)*sizeof(TCHAR), 0);
        if( hr )
            goto Cleanup;

        RestoreFlags(dwOldFlags);

        hr = Write(szQuote, 1*sizeof(TCHAR), 0);
        if( hr )
            goto Cleanup;
    }
    else
    {
        // If we do not use quotes, we must entitize all quotes and LT/GT symbols

        DWORD dwOldFlags = SetFlags(WBF_ENTITYREF | WBF_CRLF_ENTITY | WBF_KEEP_BREAKS);

        hr = Write( pch, _tcslen(pch)*sizeof(TCHAR), 0 );

        RestoreFlags( dwOldFlags );
    }


Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::SaveNamespaceAttrPI
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::SaveNamespaceAttrPI(LPTSTR pchNamespace, LPTSTR pchUrn)
{
    HRESULT     hr;
    LPTSTR      pch_XmlNS;

    Assert( _fInited );
    Assert (pchNamespace);

    // if appears to be originally lower-case
    if (ChrLower(pchNamespace[0]))
    {
        pch_XmlNS = _T(" xmlns:");
    }
    else // if appears to be originally upper-case
    {
        pch_XmlNS = _T(" XMLNS:");
    }

    hr = THR(Write(pch_XmlNS));
    if (hr)
        goto Cleanup;

    hr = THR(Write(pchNamespace));
    if (hr)
        goto Cleanup;

    if (pchUrn)
    {
        hr = THR(Write(_T(" = \"")));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\"")));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::SaveNamespacePI
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::SaveNamespacePI(LPTSTR pchNamespace, LPTSTR pchUrn)
{
    HRESULT     hr;
    LPTSTR      pch_Xml_Namespace_Prefix;
    LPTSTR      pch_Urn;
    DWORD       dwOldFlags;

    Assert( _fInited );
    dwOldFlags = ClearFlags(WBF_ENTITYREF);

    // if appears to be originally lower-case
    if (ChrLower(pchNamespace[0]))
    {
        pch_Xml_Namespace_Prefix = _T("<?xml:namespace prefix = ");
        pch_Urn                  = _T(" ns = \"");
    }
    else // if appears to be originally upper-case
    {
        pch_Xml_Namespace_Prefix = _T("<?XML:NAMESPACE PREFIX = ");
        pch_Urn                  = _T(" NS = \"");
    }

    hr = THR(Write(pch_Xml_Namespace_Prefix));
    if (hr)
        goto Cleanup;

    hr = THR(Write(pchNamespace));
    if (hr)
        goto Cleanup;

    if (pchUrn && pchUrn[0])
    {
        hr = THR(Write(pch_Urn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\"")));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Write(_T(" />")));
    if (hr)
        goto Cleanup;

#if 0
    hr = THR(NewLine());
    if (hr)
        goto Cleanup;
#endif

    RestoreFlags(dwOldFlags);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::SaveImportPI
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::SaveImportPI(LPTSTR pchNamespace, LPTSTR pchUrn, LPTSTR pchImplementation, BOOL fDeclareNamespace)
{
    HRESULT     hr;
    DWORD       dwOldFlags;
    LPTSTR      pch_Import;
    LPTSTR      pch_Urn;
    LPTSTR      pch_Implementation;
    LPTSTR      pch_DeclareNamespace;

    Assert( _fInited );
    dwOldFlags = ClearFlags(WBF_ENTITYREF);

    // if appears to be originally lower-case
    if (ChrLower(pchNamespace[0]))
    {
        pch_Import           = _T("<?import namespace = ");
        pch_Urn              = _T("urn = \"");
        pch_Implementation   = _T("implementation = \"");
        pch_DeclareNamespace = _T("declareNamespace ");
    }
    else // if appears to be originally upper-case
    {
        pch_Import           = _T("<?IMPORT NAMESPACE = ");
        pch_Urn              = _T("URN = \"");
        pch_Implementation   = _T("IMPLEMENTATION = \"");
        pch_DeclareNamespace = _T("DECLARENAMESPACE ");
    }

    hr = THR(Write(pch_Import));
    if (hr)
        goto Cleanup;

    hr = THR(Write(pchNamespace));
    if (hr)
        goto Cleanup;

    hr = THR(Write(_T(" ")));
    if (hr)
        goto Cleanup;

    if (pchUrn)
    {
        hr = THR(Write(pch_Urn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\" ")));
        if (hr)
            goto Cleanup;
    }

    if (pchImplementation)
    {
        hr = THR(Write(pch_Implementation));
        if (hr)
            goto Cleanup;

        hr = THR(Write(pchImplementation));
        if (hr)
            goto Cleanup;

        hr = THR(Write(_T("\" ")));
        if (hr)
            goto Cleanup;
    }

    if (fDeclareNamespace)
    {
        hr = THR(Write(pch_DeclareNamespace));
        if (hr)
            goto Cleanup;
    }

    hr = THR(Write(_T("/>")));
    if (hr)
        goto Cleanup;

    RestoreFlags(dwOldFlags);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::EnsurePIsSaved
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::EnsurePIsSaved (CElement * pElement, CExtendedTagDesc * pTagDesc, DWORD dwDeclStyle)
{
    HRESULT     hr = S_OK;

    Assert( _fInited );
    Assert (pElement && pTagDesc);
    Assert (pTagDesc->IsValid() && pTagDesc->Namespace());

    if (    TestFlag(WBF_SAVE_FOR_PRINTDOC)
        ||  pTagDesc->IsPIRequired()        )
    {
        hr = THR(EnsurePIsSaved(
            pElement->Doc(), pElement->GetMarkup(),
            pTagDesc->Namespace(), pTagDesc->Urn(),
            pTagDesc->Implementation(),
            dwDeclStyle));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamWriteBuff::EnsurePIsSaved
//
//----------------------------------------------------------------------------

HRESULT
CStreamWriteBuff::EnsurePIsSaved (
    CDoc *              pDoc,
    CMarkup *           pMarkup,
    LPTSTR              pchNamespace,
    LPTSTR              pchUrn,
    LPTSTR              pchImplementation,
    DWORD               dwDeclStyle)
{
    HRESULT                 hr = S_OK;
    BOOL                    fNamespaceChange = TRUE;
    BOOL                    fImportPI;
    CExtendedTagNamespace * pNamespace = NULL;

    Assert( _fInited );
    Assert ( pDoc && pchNamespace );
    Assert( !TestFlag( WBF_FOR_TREESYNC ) );

    // If we're saving some generic element off in the ether, we have no markup, so
    // we don't make a tag table - we don't need one anyway.
    if( pMarkup )
    {
        if (!_pExtendedTagTable)
        {
            _pExtendedTagTable = new CExtendedTagTable(pDoc, pMarkup, /* fShareBooster = */FALSE);
            if (!_pExtendedTagTable)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        hr = THR(_pExtendedTagTable->EnsureNamespace(pchNamespace, pchUrn, &pNamespace, &fNamespaceChange));
        if (hr)
            goto Cleanup;

        Assert (pNamespace);
    }

    switch (dwDeclStyle)
    {
    case XMLNAMESPACEDECL_STD:

        if (fNamespaceChange)
        {
            hr = THR(SaveNamespaceAttrPI(pchNamespace, pchUrn));
            if (hr)
                goto Cleanup;
        }

        break;

    case XMLNAMESPACEDECL_TAG:
        if( fNamespaceChange )
        {
            hr = THR(SaveNamespacePI(pchNamespace, pchUrn));
            if( hr )
                goto Cleanup;
        }

        break;

    case XMLNAMESPACEDECL_IMPORT:

        fImportPI = fNamespaceChange;
        if (pchImplementation && pNamespace)
        {
            if (pNamespace->_cstrFactoryUrl.IsNull() ||
                0 != StrCmpIC(pNamespace->_cstrFactoryUrl, pchImplementation))
            {
                pNamespace->_cstrFactoryUrl.Free();

                hr = THR(pNamespace->_cstrFactoryUrl.Set(pchImplementation));
                if (hr)
                    goto Cleanup;

                fImportPI = TRUE;
            }
        }

        if (fImportPI)
        {
            hr = THR(SaveImportPI(pchNamespace, pchUrn, pchImplementation, /* fDeclareNamespace = */ fNamespaceChange));
            if (hr)
                goto Cleanup;
        }

        break;

    default:
        Assert (0 && "not implemented");
    }

Cleanup:

    RRETURN (hr);
}
//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::CStreamReadBuff
//
//  Synopsis:   Instantiates our class from a IStream pointer.
//
//  Returns:
//
//----------------------------------------------------------------------------

CStreamReadBuff::CStreamReadBuff( IStream* pIStream, CODEPAGE cp )
                    : _pStm( pIStream ),
                       CEncodeReader( cp, WBUFF_SIZE )
{
    Assert( pIStream );
    _pStm->AddRef( );
    _eof              = FALSE;
    _lastGetCharError = S_OK;
    _iIndex           = -1;
    _cchChunk         = 0;
}

CStreamReadBuff::~CStreamReadBuff( )
{
    _pStm->Release( );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::Get
//
//  Synopsis:   Copies at most cbBuffer bytes into pBuffer, but less if we encounter
//              end of file or an error first.  *pcbRead gets set to the number of
//              bytes copied.  No null termination.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::Get( TCHAR* pBuffer, int cchAvailable, int* pchRead )
{
    int lCharsToCopy;
    TCHAR* pBufCur = pBuffer;

    *pchRead = 0;

    if( _eof )
        RRETURN1( S_FALSE, S_FALSE );

    // Loop until we have exhausted the size of pBuffer or encounter an error/end of file
    while( cchAvailable > 0 && !_eof )
    {
        if( _iIndex < 0 || _iIndex >= _cchChunk )
        {
            // If the _iIndex is set to an invalid position, we need to read another chunk.
            HRESULT hr = ReadChunk( );
            if( hr )
            {
                if( !(*pchRead) )
                    // If we didn't read anything at all and get an error in ReadChunk return it.
                    RRETURN1( hr, S_FALSE );
                else
                    break;
            }
        }
        // Copy into pBuffer but be careful not to overflow it
        lCharsToCopy = min( cchAvailable, _cchChunk - _iIndex );
        memcpy( (void*)pBufCur, _achBuffer+_iIndex, lCharsToCopy * sizeof(TCHAR) );
        cchAvailable -= lCharsToCopy;
        _iIndex   += lCharsToCopy;
        *pchRead  += lCharsToCopy;
        pBufCur   += lCharsToCopy;
    }

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetLine
//
//  Synopsis:   Copies the next non-empty 'line' of text in the supplied buffer,
//              copying at most cchBuffer-1 bytes.  Null terminates the buffer.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetLine( TCHAR* pBuffer, int cchBuffer )
{
    HRESULT hr = S_OK;
    int  index = 0;

    if( _eof )
        RRETURN1( S_FALSE, S_FALSE );

    // Read until we get to end of file or to a cr or lf, copying into the buffer
    while( GetChar() != 0 && GetChar() != _T('\r') && GetChar() != _T('\n') &&
            index < cchBuffer - 1)
    {
        pBuffer[ index++ ] = GetChar( );
        hr = THR( Advance( ) );
        if( FAILED( hr ) )
            goto Cleanup;
    }

    pBuffer[ index ] = 0;

    // Skip over cr/lfs
    if( GetChar() == _T('\r') )
    {
        hr = THR( Advance( ) );
        if( FAILED( hr ) )
            goto Cleanup;
    }
    if( GetChar() == _T('\n') )
    {
        hr = THR( Advance( ) );
        if( FAILED( hr ) )
            goto Cleanup;
    }

Cleanup:
    // S_FALSE means we hit end of file, which is still ok.  This is different
    // than starting at the end of the file, where we want to return S_FALSE
    if( hr == S_FALSE )
        hr = S_OK;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::ReadChunk
//
//  Synopsis:   Reads a chunk of data from the stream at the current position,
//              and populates the _achBuffer and _abBuffer internal buffers.
//              Performs a MultiByteToWideChar conversion to fill _achBuffer
//              from _abBuffer, depending on the current mapping mode.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::ReadChunk( )
{
    ULONG cbRead;
    HRESULT hr = S_OK;

    if( _eof )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( PrepareToEncode( ) );
    if( hr )
        goto Cleanup;

    // Read a chunk from the stream

    Assert( _pbBuffer );
    Assert( _cbBuffer + BlockSize() <= _cbBufferMax );

    hr = _pStm->Read(_pbBufferPtr, BlockSize(), &cbRead);
    if( hr == S_FALSE )
    {
        Assert(cbRead == 0);
        cbRead = 0;
    }
    else if( hr )
        goto Cleanup;

    _cbBuffer += cbRead;
    _pbBufferPtr = _pbBuffer;

    // If we didn't read anything at all, we have an end of file condition
    if( cbRead == 0 )
    {
        _iIndex   = -1;
        _cchChunk = 0;
        _eof      = TRUE;
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( WideCharFromMultiByte( TRUE, &_cchChunk ) );
    if( hr )
        goto Cleanup;

    _achBuffer = _pchBuffer;
    _iIndex    = 0;

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::MakeRoomForChars
//
//  Synopsis:   Make sure we have enough room for at least 'cch' characters in
//              out wide char buffer.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::MakeRoomForChars(int cch)
{
    HRESULT hr = S_OK;

    if (!_pchBuffer)
    {
        // round up to block size multiple >= cch+1
        _cchBuffer = (cch + BlockSize()) & ~(BlockSize()-1);

        _pchBuffer = (TCHAR*)MemAlloc(Mt(CStreamReadBuff), _cchBuffer * sizeof(TCHAR));
        if (!_pchBuffer)
            return(E_OUTOFMEMORY);

        _pchEnd = _pchBuffer;
    }
    else
    {
        int cchCur  = (_pchEnd - _pchBuffer);
        int cchNeed = cchCur + cch;

        if (cchNeed >= _cchBuffer)
        {
            TCHAR *pchNewBuffer = _pchBuffer;

            cchNeed = (cchNeed + BlockSize() - 1) & ~(BlockSize()-1);

            hr = THR(MemRealloc(Mt(CStreamReadBuff), (void**)&pchNewBuffer, cchNeed * sizeof(TCHAR)));
            if (hr)
                goto Cleanup;

            _pchBuffer = pchNewBuffer;
            _pchEnd    = _pchBuffer + cchCur;
            _cchBuffer = cchNeed;
        }
    }

    CEncodeReader::MakeRoomForChars(cch);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetChar
//
//  Synopsis:   Returns the character at the current position in the stream,
//              or 0 if an error has occurred.
//
//  Returns:
//
//----------------------------------------------------------------------------

TCHAR
CStreamReadBuff::GetChar( )
{
    if( _eof )
        return 0;

    // If we are not within range, advance to get there
    if( _iIndex < 0 || _iIndex >= _cchChunk )
    {
        HRESULT hr = Advance( );
        if( hr )
        {
            _lastGetCharError = hr;
            return 0;
        }
    }

    return _achBuffer[ _iIndex ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::Advance
//
//  Synopsis:   Move the current position one character to the right.  Note that
//              Advance() when the chunk buffer is empty will keep us at position
//              zero.
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT
CStreamReadBuff::Advance( )
{
    if( _eof || _lastGetCharError )
        RRETURN1( S_FALSE, S_FALSE );

    if( _iIndex < 0 || _iIndex >= _cchChunk - 1)
    {
        HRESULT hr = ReadChunk( );
        if( hr )
            RRETURN1( hr, S_FALSE );
    }
    else
        ++_iIndex;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::SetPosition
//
//  Synopsis:   Set the current stream position to the supplied absolute offset.
//              If mode==STREAM_SEEK_CUR, lPosition is relative to the current
//              position in the file.  mode==STREAM_SEEK_SET, lPosition is
//              absolute.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::SetPosition( LONG lPosition, DWORD dwOrigin )
{
    LARGE_INTEGER liPosition;
    HRESULT hr;

#ifdef UNIX
    QUAD_PART(liPosition) = (LONGLONG)lPosition;
#else
    liPosition.QuadPart = (LONGLONG)lPosition;
#endif

    hr = _pStm->Seek( liPosition, dwOrigin, NULL );
    if( hr )
        RRETURN( hr );

    _iIndex   = -1;       // Signal Read routines that we need to read again
    _eof      = FALSE;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetPosition
//
//  Synopsis:   Find the current absolue position as a long.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetPosition( LONG* plPositionRet )
{
    HRESULT hr;
    ULARGE_INTEGER lPosition;
    LARGE_INTEGER   zero = { 0, 0 };

    // Get our current position in the stream
    hr = _pStm->Seek( zero, STREAM_SEEK_CUR, &lPosition );
    if( hr )
        RRETURN( hr );

#ifdef UNIX
    *plPositionRet = (LONG) U_QUAD_PART(lPosition);
#else
    *plPositionRet = (LONG) lPosition.QuadPart;
#endif

    // Adjust for any characters we have not yet eaten from the chunk buffer
    if( _iIndex >= 0 && _iIndex < _cchChunk )
        *plPositionRet -= _cchChunk - _iIndex;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetStringValue
//
//  Synopsis:   Look for Tag:Value, and copy Value into pString (though at most
//              cchString-1) if you find it.  Otherwise pString will be empty.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetStringValue( TCHAR* pTag, TCHAR* pString, int cchString )
{
    HRESULT hr;
    TCHAR buffer[ 256 ];
    int  cbTag;

    pString[0] = 0;

    // Read in a line from the stream
    hr = GetLine( buffer, ARRAY_SIZE( buffer ) );
    if( hr )
        RRETURN( hr );

    cbTag = _tcsclen( pTag );

    // Make sure the tag matches
    if( memcmp( pTag, buffer, cbTag * sizeof(TCHAR) ) )
        RRETURN1( S_FALSE, S_FALSE );

    // Make sure we have a semicolon after in
    if( buffer[cbTag] != _T(':') )
        RRETURN1( S_FALSE, S_FALSE );

    // Copy contents after the colon into pString
    int n;
    for( n = 0; n < cchString - 1 && buffer[ cbTag + n + 1]; ++n )
        pString[ n ]  = buffer[ cbTag + n + 1 ];

    pString[ n ] = 0;

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamReadBuff::GetLongValue
//
//  Synopsis:   Same as GetStringValue, except returns a number.
//
//  Returns:    Returns S_OK, if successful else the error
//
//----------------------------------------------------------------------------

HRESULT
CStreamReadBuff::GetLongValue( TCHAR* pTag, LONG* pLong )
{
    TCHAR numberAsString[ 33 ];
    HRESULT hr;

    // Simply call GetString value and then convert what it returns to a long
    hr = GetStringValue( pTag, numberAsString, ARRAY_SIZE(numberAsString) );
    if( hr )
    {
        *pLong = 0;
        RRETURN1( hr, S_FALSE );
    }
    else
    {
        IGNORE_HR(ttol_with_error( numberAsString, pLong));
        RRETURN( S_OK );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\uniprop.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIPROP.CXX -- Miscellaneous Unicode partition properties
 *
 *
 *  Owner: <nl>
 *      Michael Jochimsen <nl>
 *
 *  History: <nl>
 *      11/30/98     mikejoch created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__UNIPROP_H_
#define X__UNIPROP_H_
#include "uniprop.h"
#endif

const UNIPROP s_aPropBitsFromCharClass[CHAR_CLASS_MAX] =
{
    // CC               fNeedsGlyphing  fCombiningMark  fZeroWidth  fWhiteBetweenWords  fMoveByCluster
    /* WOB_   1*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOPP   2*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOPA   2*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOPW   2*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HOP_   3*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOP_   4*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOP5   5*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOQW   6*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AOQW   7*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOQ_   8*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCB_   9*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCPP  10*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCPA  10*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCPW  10*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HCP_  11*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCP_  12*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCP5  13*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCQW  14*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ACQW  15*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCQ_  16*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ARQW  17*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCSA  18*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HCO_  19*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WC__  20*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCS_  20*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WC5_  21*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WC5S  21*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKS_  22*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKSM  23*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WIM_  24*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSSW  25*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WSS_  26*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WHIM  27*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKIM  28*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKSL  29*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKS_  30*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKSC  30*/   {   FALSE,          TRUE,           TRUE,       TRUE,               FALSE,  },
    /* WHS_  31*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQFP  32*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQFA  32*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WQE_  33*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WQE5  34*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKCC  35*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKC_  36*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCP  37*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCA  37*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCW  37*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOC_  38*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOCS  38*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOC5  39*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOC6  39*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AHPW  40*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEP  41*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPAR  41*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HPE_  42*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPE_  43*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPES  43*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPE5  44*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NISW  45*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AISW  46*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQCS  47*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQCW  47*/   {   FALSE,          FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NQCC  47*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NPTA  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPNA  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEW  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEH  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPEV  48*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* APNW  49*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* HPEW  50*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPR_  51*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQEP  52*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQEW  52*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQNW  52*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AQEW  53*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AQNW  53*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AQLW  53*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WQO_  54*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSBL  55*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WSP_  56*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WHI_  57*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKA_  58*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WKA_  59*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASNW  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASEW  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASRN  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASEN  60*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ALA_  61*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AGR_  62*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ACY_  63*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WID_  64*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WPUA  65*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHG_  66*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WHG_  67*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WCI_  68*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOI_  69*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOI_  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOIC  70*/   {   FALSE,          TRUE,           TRUE,       TRUE,               FALSE,  },
    /* WOIL  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOIS  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WOIT  70*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSEN  71*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSET  71*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSNW  71*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASAN  72*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ASAE  72*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NDEA  73*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WD__  74*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLLA  75*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* WLA_  76*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NWBL  77*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NWZW  77*/   {   FALSE,          FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPLW  78*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NPZW  78*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPF_  78*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPFL  78*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NPNW  78*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* APLW  79*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* APCO  79*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* ASYW  80*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHYP  81*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHYW  81*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* AHYW  82*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAPA  83*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NQMP  84*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSLS  85*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSF_  86*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSBS  86*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NSBB  86*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLA_  87*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLQ_  88*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLQN  88*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NLQC  88*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ALQ_  89*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* ALQN  89*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGR_  90*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGRN  90*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGQ_  91*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGQN  91*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCY_  92*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCYP  93*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NCYC  93*/   {   FALSE,          TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NAR_  94*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAQL  95*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAQN  95*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHB_  96*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHBC  96*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NHBW  96*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHBR  96*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NASR  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAAR  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAAC  97*/   {   TRUE,           TRUE,           TRUE,       TRUE,               FALSE,  },
    /* NAAD  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAED  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NANW  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAEW  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NAAS  97*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NHI_  98*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NHIN  98*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NHIC  98*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NHID  98*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBE_  99*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NBEC  99*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NBED  99*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBET  99*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGM_ 100*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NGMC 100*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NGMD 100*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGJ_ 101*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NGJC 101*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NGJD 101*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOR_ 102*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NORC 102*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NORD 102*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTA_ 103*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NTAC 103*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NTAD 103*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTE_ 104*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NTEC 104*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NTED 104*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NKD_ 105*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NKDC 105*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NKDD 105*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NMA_ 106*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NMAC 106*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NMAD 106*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTH_ 107*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   },
    /* NTHC 107*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   },
    /* NTHD 107*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  },
    /* NTHT 107*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   },
    /* NLO_ 108*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   },
    /* NLOC 108*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   },
    /* NLOD 108*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  },
    /* NTI_ 109*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   },
    /* NTIC 109*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   },
    /* NTID 109*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NTIN 109*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGE_ 110*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NGEQ 111*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBO_ 112*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBSP 113*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NBSS 113*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOF_ 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOBS 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOEA 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NONA 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NONP 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOEP 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NONW 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOEW 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOLW 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOCO 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOSP 114*/   {   TRUE,           FALSE,          TRUE,       TRUE,               FALSE,  },
    /* NOEN 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOBN 114*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NET_ 115*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ethiopic
    /* NETP 115*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ethiopic
    /* NETD 115*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ethiopic
    /* NCA_ 116*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Canadian Syllabics
    /* NCH_ 117*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Cherokee
    /* WYI_ 118*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Yi
    /* WYIN 118*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Yi
    /* NBR_ 119*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NRU_ 120*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* NOG_ 121*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ogham
    /* NOGS 121*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ogham
    /* NOGN 121*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Ogham
    /* NSI_ 122*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, // Check on Sinhala
    /* NSIC 122*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, // Check on Sinhala
    /* NTN_ 123*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, // Check on Thaana
    /* NTNC 123*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, // Check on Thaana
    /* NKH_ 124*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   }, // Check on Khmer
    /* NKHC 124*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   }, // Check on Khmer
    /* NKHD 124*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  }, // Check on Khmer
    /* NKHT 124*/   {   TRUE,           FALSE,          FALSE,      FALSE,              FALSE,  }, // Check on Khmer
    /* NBU_ 125*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   }, // Check on Burmese/Myanmar
    /* NBUC 125*/   {   TRUE,           TRUE,           TRUE,       FALSE,              TRUE,   }, // Check on Burmese/Myanmar
    /* NBUD 125*/   {   TRUE,           FALSE,          FALSE,      FALSE,              TRUE,   }, // Check on Burmese/Myanmar
    /* NSY_ 126*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, 
    /* NSYP 126*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, 
    /* NSYC 126*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, 
    /* NSYW 126*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, 
    /* NMO_ 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               TRUE,   }, // Check on Mongolian
    /* NMOC 127*/   {   TRUE,           TRUE,           TRUE,       TRUE,               TRUE,   }, // Check on Mongolian
    /* NMOD 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Mongolian
    /* NMOB 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Mongolian
    /* NMON 127*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Check on Mongolian
    /* NHS_ 128*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // High Surrogate
    /* WHT_ 129*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // High Surrogate
    /* LS__ 130*/   {   TRUE,           FALSE,          FALSE,      TRUE,               FALSE,  }, // Low Surrogate
    /* XNW_ 131*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
    /* XNWA 131*/   {   FALSE,          FALSE,          FALSE,      TRUE,               FALSE,  },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\unidir.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File: unipart.cxx
//
//  This is a generated file.  Do not modify by hand.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#ifndef X__UNIDIR_H
#define X__UNIDIR_H
#include "unidir.h"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//  Generating script: unidir_make_cxx.pl
//  Generated on Mon Dec  4 20:07:03 2000


const DIRCLS s_aDirClassFromCharClass[CHAR_CLASS_MAX] =
{
    NEU, // WOB_
    NEU, // NOPP
    NEU, // NOPA
    NEU, // NOPW
    NEU, // HOP_
    NEU, // WOP_
    NEU, // WOP5
    NEU, // NOQW
    NEU, // AOQW
    NEU, // WOQ_
    NEU, // WCB_
    NEU, // NCPP
    NEU, // NCPA
    NEU, // NCPW
    NEU, // HCP_
    NEU, // WCP_
    NEU, // WCP5
    NEU, // NCQW
    NEU, // ACQW
    NEU, // WCQ_
    NEU, // ARQW
    CSP, // NCSA
    NEU, // HCO_
    NEU, // WC__
    CSP, // WCS_
    NEU, // WC5_
    CSP, // WC5S
    LTR, // NKS_
    NEU, // WKSM
    LTR, // WIM_
    NEU, // NSSW
    NEU, // WSS_
    LTR, // WHIM
    LTR, // WKIM
    LTR, // NKSL
    LTR, // WKS_
    CBN, // WKSC
    LTR, // WHS_
    NEU, // NQFP
    NEU, // NQFA
    NEU, // WQE_
    NEU, // WQE5
    NEU, // NKCC
    NEU, // WKC_
    CSP, // NOCP
    NEU, // NOCA
    NEU, // NOCW
    NEU, // WOC_
    CSP, // WOCS
    CSP, // WOC5
    NEU, // WOC6
    NEU, // AHPW
    CSP, // NPEP
    LTR, // NPAR
    NEU, // HPE_
    NEU, // WPE_
    CSP, // WPES
    CSP, // WPE5
    NEU, // NISW
    NEU, // AISW
    WSP, // NQCS
    NEU, // NQCW
    CBN, // NQCC
    ETM, // NPTA
    NEU, // NPNA
    ETM, // NPEW
    ETM, // NPEH
    ETM, // NPEV
    NEU, // APNW
    ETM, // HPEW
    ETM, // WPR_
    ETM, // NQEP
    ETM, // NQEW
    NEU, // NQNW
    ETM, // AQEW
    NEU, // AQNW
    LTR, // AQLW
    ETM, // WQO_
    WSP, // NSBL
    WSP, // WSP_
    LTR, // WHI_
    LTR, // NKA_
    LTR, // WKA_
    NEU, // ASNW
    ETM, // ASEW
    LTR, // ASRN
    ENM, // ASEN
    LTR, // ALA_
    LTR, // AGR_
    LTR, // ACY_
    LTR, // WID_
    LTR, // WPUA
    LTR, // NHG_
    LTR, // WHG_
    LTR, // WCI_
    NEU, // NOI_
    NEU, // WOI_
    CBN, // WOIC
    LTR, // WOIL
    ESP, // WOIS
    ETM, // WOIT
    ENM, // NSEN
    ETM, // NSET
    NEU, // NSNW
    LTR, // ASAN
    ENM, // ASAE
    ENM, // NDEA
    ENM, // WD__
    LTR, // NLLA
    LTR, // WLA_
    WSP, // NWBL
    NEU, // NWZW
    LTR, // NPLW
    NEU, // NPZW
    RTL, // NPF_
    LTR, // NPFL
    NEU, // NPNW
    LTR, // APLW
    CBN, // APCO
    NEU, // ASYW
    NEU, // NHYP
    NEU, // NHYW
    NEU, // AHYW
    NEU, // NAPA
    NEU, // NQMP
    ESP, // NSLS
    SEG, // NSF_
    WSP, // NSBS
    BLK, // NSBB
    LTR, // NLA_
    LTR, // NLQ_
    NEU, // NLQN
    UNK, // NLQC
    NEU, // ALQ_
    NEU, // ALQN
    LTR, // NGR_
    NEU, // NGRN
    LTR, // NGQ_
    NEU, // NGQN
    LTR, // NCY_
    CBN, // NCYP
    CBN, // NCYC
    LTR, // NAR_
    LTR, // NAQL
    NEU, // NAQN
    RTL, // NHB_
    CBN, // NHBC
    ETM, // NHBW
    RTL, // NHBR
    CSP, // NASR
    ARA, // NAAR
    CBN, // NAAC
    ANM, // NAAD
    ENM, // NAED
    NEU, // NANW
    ETM, // NAEW
    ARA, // NAAS
    LTR, // NHI_
    LTR, // NHIN
    CBN, // NHIC
    LTR, // NHID
    LTR, // NBE_
    CBN, // NBEC
    LTR, // NBED
    ETM, // NBET
    LTR, // NGM_
    CBN, // NGMC
    LTR, // NGMD
    LTR, // NGJ_
    CBN, // NGJC
    LTR, // NGJD
    LTR, // NOR_
    CBN, // NORC
    LTR, // NORD
    LTR, // NTA_
    CBN, // NTAC
    LTR, // NTAD
    LTR, // NTE_
    CBN, // NTEC
    LTR, // NTED
    LTR, // NKD_
    CBN, // NKDC
    LTR, // NKDD
    LTR, // NMA_
    CBN, // NMAC
    LTR, // NMAD
    LTR, // NTH_
    CBN, // NTHC
    LTR, // NTHD
    ETM, // NTHT
    LTR, // NLO_
    CBN, // NLOC
    LTR, // NLOD
    LTR, // NTI_
    CBN, // NTIC
    LTR, // NTID
    NEU, // NTIN
    LTR, // NGE_
    LTR, // NGEQ
    LTR, // NBO_
    CSP, // NBSP
    WSP, // NBSS
    SEG, // NOF_
    BLK, // NOBS
    ETM, // NOEA
    NEU, // NONA
    NEU, // NONP
    NEU, // NOEP
    NEU, // NONW
    ETM, // NOEW
    LTR, // NOLW
    CBN, // NOCO
    FMT, // NOSP
    ENM, // NOEN
    NEU, // NOBN
    LTR, // NET_
    LTR, // NETP
    LTR, // NETD
    LTR, // NCA_
    LTR, // NCH_
    LTR, // WYI_
    NEU, // WYIN
    NEU, // NBR_
    LTR, // NRU_
    LTR, // NOG_
    WSP, // NOGS
    NEU, // NOGN
    LTR, // NSI_
    CBN, // NSIC
    ARA, // NTN_
    CBN, // NTNC
    LTR, // NKH_
    CBN, // NKHC
    LTR, // NKHD
    ETM, // NKHT
    LTR, // NBU_
    CBN, // NBUC
    LTR, // NBUD
    ARA, // NSY_
    ARA, // NSYP
    CBN, // NSYC
    NEU, // NSYW
    LTR, // NMO_
    CBN, // NMOC
    LTR, // NMOD
    NEU, // NMOB
    NEU, // NMON
    LTR, // NHS_
    LTR, // WHT_
    LTR, // LS__
    UNK, // XNW_
    UNK, // XNWA
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\textxfrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       textxfrm.cxx
//
//  Contents:   CSS Text Transformation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_H_
#define X_STYLE_H_
#include <style.h>
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X_UNIWBK_H_
#define X_UNIWBK_H_
#include "uniwbk.h"
#endif

#define CHARCAST(ch) (LPTSTR)(DWORD_PTR)(WORD)(ch)

//+----------------------------------------------------------------------------
//
// Function:    TransformText
//
// Synopsis:    CSS Attribute TextTransform.  Takes an input string and
//              performs capitalization based on bTextTransform, as
//              was specified in the style.
//
//    Note:     Will assert unless a transform is needed.  (This is for
//              optimization.)
//
//-----------------------------------------------------------------------------

const TCHAR *
TransformText(
    CStr &str,
    const TCHAR * pch,
    LONG cchIn,
    BYTE bTextTransform,
    TCHAR chPrev )
{
    HRESULT hr = S_OK;
    const TCHAR * pchRet = pch;

    Assert(pch);

    // Don't call it unless you need a transform done.
    Assert( (bTextTransform != styleTextTransformNotSet) && (bTextTransform != styleTextTransformNone) );

    if (cchIn > 0)
    {
        hr = str.Set(pch, cchIn);
        if (hr)
            goto Cleanup;

        switch (bTextTransform)
        {
        case styleTextTransformLowercase:
            CharLower(str);
            break;

        case styleTextTransformUppercase:
            CharUpper(str);
            break;

        case styleTextTransformCapitalize:
            {
                TCHAR *pszChar = str;
                while (*pszChar)
                {
                    if (IsWordBreakBoundaryDefault(chPrev, *pszChar))
                        *pszChar = (TCHAR)CharUpper(CHARCAST(*pszChar));

                    chPrev = *pszChar;
                    pszChar++;
                }
            }
            break;

        default:
            Assert(FALSE);
            break;
        }

        pchRet = str;
    }

Cleanup:
    return pchRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\uniwbk.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module UNIWBK.CXX -- Unicode Word-breaking classes
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *
 *  History: <nl>
 *      06/19/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__UNIWBK_H_
#define X__UNIWBK_H_
#include "uniwbk.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TXTDEFS_H
#define X__TXTDEFS_H
#include <txtdefs.h>
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

const WBKCLS awbkclsWordBreakClassFromCharClass[]=
{
    // CC           wbkcls
    /* WOB_   1*/   wbkclsPunctSymb,
    /* NOPP   2*/   wbkclsPunctSymb,
    /* NOPA   2*/   wbkclsPunctSymb,
    /* NOPW   2*/   wbkclsPunctSymb,
    /* HOP_   3*/   wbkclsPunctSymb,
    /* WOP_   4*/   wbkclsPunctSymb,
    /* WOP5   5*/   wbkclsPunctSymb,
    /* NOQW   6*/   wbkclsPunctSymb,
    /* AOQW   7*/   wbkclsPunctSymb,
    /* WOQ_   8*/   wbkclsPunctSymb,
    /* WCB_   9*/   wbkclsPunctSymb,
    /* NCPP  10*/   wbkclsPunctSymb,
    /* NCPA  10*/   wbkclsPunctSymb,
    /* NCPW  10*/   wbkclsPunctSymb,
    /* HCP_  11*/   wbkclsPunctSymb,
    /* WCP_  12*/   wbkclsPunctSymb,
    /* WCP5  13*/   wbkclsPunctSymb,
    /* NCQW  14*/   wbkclsPunctSymb,
    /* ACQW  15*/   wbkclsPunctSymb,
    /* WCQ_  16*/   wbkclsPunctSymb,
    /* ARQW  17*/   wbkclsPunctInText,
    /* NCSA  18*/   wbkclsPunctSymb,
    /* HCO_  19*/   wbkclsPunctSymb,
    /* WC__  20*/   wbkclsPunctSymb,
    /* WCS_  20*/   wbkclsPunctSymb,
    /* WC5_  21*/   wbkclsPunctSymb,
    /* WC5S  21*/   wbkclsPunctSymb,
    /* NKS_  22*/   wbkclsKanaFollow,
    /* WKSM  23*/   wbkclsKanaFollow,
    /* WIM_  24*/   wbkclsIdeoW,
    /* NSSW  25*/   wbkclsPunctSymb,
    /* WSS_  26*/   wbkclsPunctSymb,
    /* WHIM  27*/   wbkclsHiragana,
    /* WKIM  28*/   wbkclsKatakanaW,
    /* NKSL  29*/   wbkclsKatakanaN,
    /* WKS_  30*/   wbkclsKatakanaW,
    /* WKSC  30*/   wbkclsKatakanaW,
    /* WHS_  31*/   wbkclsHiragana,
    /* NQFP  32*/   wbkclsPunctSymb,
    /* NQFA  32*/   wbkclsPunctSymb,
    /* WQE_  33*/   wbkclsPunctSymb,
    /* WQE5  34*/   wbkclsPunctSymb,
    /* NKCC  35*/   wbkclsKanaDelim,
    /* WKC_  36*/   wbkclsKanaDelim,
    /* NOCP  37*/   wbkclsPunctSymb,
    /* NOCA  37*/   wbkclsPunctSymb,
    /* NOCW  37*/   wbkclsPunctSymb,
    /* WOC_  38*/   wbkclsPunctSymb,
    /* WOCS  38*/   wbkclsPunctSymb,
    /* WOC5  39*/   wbkclsPunctSymb,
    /* WOC6  39*/   wbkclsPunctSymb,
    /* AHPW  40*/   wbkclsPunctInText,
    /* NPEP  41*/   wbkclsPunctSymb,
    /* NPAR  41*/   wbkclsPunctSymb,
    /* HPE_  42*/   wbkclsPunctSymb,
    /* WPE_  43*/   wbkclsPunctSymb,
    /* WPES  43*/   wbkclsPunctSymb,
    /* WPE5  44*/   wbkclsPunctSymb,
    /* NISW  45*/   wbkclsPunctSymb,
    /* AISW  46*/   wbkclsPunctSymb,
    /* NQCS  47*/   wbkclsPunctInText,
    /* NQCW  47*/   wbkclsPunctInText,
    /* NQCC  47*/   wbkclsPunctInText,
    /* NPTA  48*/   wbkclsPrefix,
    /* NPNA  48*/   wbkclsPrefix,
    /* NPEW  48*/   wbkclsPrefix,
    /* NPEH  48*/   wbkclsPrefix,
    /* NPEV  48*/   wbkclsPrefix,
    /* APNW  49*/   wbkclsPrefix,
    /* HPEW  50*/   wbkclsPrefix,
    /* WPR_  51*/   wbkclsPrefix,
    /* NQEP  52*/   wbkclsPostfix,
    /* NQEW  52*/   wbkclsPostfix,
    /* NQNW  52*/   wbkclsPostfix,
    /* AQEW  53*/   wbkclsPostfix,
    /* AQNW  53*/   wbkclsPostfix,
    /* AQLW  53*/   wbkclsPostfix,
    /* WQO_  54*/   wbkclsPostfix,
    /* NSBL  55*/   wbkclsSpaceA,
    /* WSP_  56*/   wbkclsSpaceA,
    /* WHI_  57*/   wbkclsHiragana,
    /* NKA_  58*/   wbkclsKatakanaN,
    /* WKA_  59*/   wbkclsKatakanaW,
    /* ASNW  60*/   wbkclsPunctSymb,
    /* ASEW  60*/   wbkclsPunctSymb,
    /* ASRN  60*/   wbkclsPunctSymb,
    /* ASEN  60*/   wbkclsPunctSymb,
    /* ALA_  61*/   wbkclsAlpha,
    /* AGR_  62*/   wbkclsAlpha,
    /* ACY_  63*/   wbkclsAlpha,
    /* WID_  64*/   wbkclsIdeoW,
    /* WPUA  65*/   wbkclsIdeoW,
    /* NHG_  66*/   wbkclsHangul,
    /* WHG_  67*/   wbkclsHangul,
    /* WCI_  68*/   wbkclsIdeoW,
    /* NOI_  69*/   wbkclsIdeoW,
    /* WOI_  70*/   wbkclsIdeoW,
    /* WOIC  70*/   wbkclsIdeoW,
    /* WOIL  70*/   wbkclsIdeoW,
    /* WOIS  70*/   wbkclsIdeoW,
    /* WOIT  70*/   wbkclsIdeoW,
    /* NSEN  71*/   wbkclsSuperSub,
    /* NSET  71*/   wbkclsSuperSub,
    /* NSNW  71*/   wbkclsSuperSub,
    /* ASAN  72*/   wbkclsSuperSub,
    /* ASAE  72*/   wbkclsSuperSub,
    /* NDEA  73*/   wbkclsDigitsN,
    /* WD__  74*/   wbkclsDigitsW,
    /* NLLA  75*/   wbkclsAlpha,
    /* WLA_  76*/   wbkclsLatinW,
    /* NWBL  77*/   wbkclsSpaceA,
    /* NWZW  77*/   wbkclsSpaceA,
    /* NPLW  78*/   wbkclsPunctInText,
    /* NPZW  78*/   wbkclsPunctInText,
    /* NPF_  78*/   wbkclsPunctInText,
    /* NPFL  78*/   wbkclsPunctInText,
    /* NPNW  78*/   wbkclsPunctInText,
    /* APLW  79*/   wbkclsPunctInText,
    /* APCO  79*/   wbkclsPunctInText,
    /* ASYW  80*/   wbkclsPunctInText,
    /* NHYP  81*/   wbkclsPunctSymb,
    /* NHYW  81*/   wbkclsPunctSymb,
    /* AHYW  82*/   wbkclsPunctSymb,
    /* NAPA  83*/   wbkclsPunctInText,
    /* NQMP  84*/   wbkclsPunctSymb,
    /* NSLS  85*/   wbkclsPostfix,
    /* NSF_  86*/   wbkclsTab,
    /* NSBS  86*/   wbkclsTab,
    /* NSBB  86*/   wbkclsTab,
    /* NLA_  87*/   wbkclsAlpha,
    /* NLQ_  88*/   wbkclsAlpha,
    /* NLQN  88*/   wbkclsAlpha,
    /* NLQC  88*/   wbkclsAlpha,
    /* ALQ_  89*/   wbkclsAlpha,
    /* ALQN  89*/   wbkclsAlpha,
    /* NGR_  90*/   wbkclsAlpha,
    /* NGRN  90*/   wbkclsAlpha,
    /* NGQ_  91*/   wbkclsAlpha,
    /* NGQN  91*/   wbkclsAlpha,
    /* NCY_  92*/   wbkclsAlpha,
    /* NCYP  93*/   wbkclsAlpha,
    /* NCYC  93*/   wbkclsAlpha,
    /* NAR_  94*/   wbkclsAlpha,
    /* NAQL  95*/   wbkclsAlpha,
    /* NAQN  95*/   wbkclsAlpha,
    /* NHB_  96*/   wbkclsAlpha,
    /* NHBC  96*/   wbkclsAlpha,
    /* NHBW  96*/   wbkclsAlpha,
    /* NHBR  96*/   wbkclsAlpha,
    /* NASR  97*/   wbkclsAlpha,
    /* NAAR  97*/   wbkclsAlpha,
    /* NAAC  97*/   wbkclsAlpha,
    /* NAAD  97*/   wbkclsDigitsN,
    /* NAED  97*/   wbkclsDigitsN,
    /* NANW  97*/   wbkclsAlpha,
    /* NAEW  97*/   wbkclsAlpha,
    /* NAAS  97*/   wbkclsAlpha,
    /* NHI_  98*/   wbkclsAlpha,
    /* NHIN  98*/   wbkclsAlpha,
    /* NHIC  98*/   wbkclsAlpha,
    /* NHID  98*/   wbkclsDigitsN,
    /* NBE_  99*/   wbkclsAlpha,
    /* NBEC  99*/   wbkclsAlpha,
    /* NBED  99*/   wbkclsDigitsN,
    /* NBET  99*/   wbkclsPunctSymb,
    /* NGM_ 100*/   wbkclsAlpha,
    /* NGMC 100*/   wbkclsAlpha,
    /* NGMD 100*/   wbkclsDigitsN,
    /* NGJ_ 101*/   wbkclsAlpha,
    /* NGJC 101*/   wbkclsAlpha,
    /* NGJD 101*/   wbkclsDigitsN,
    /* NOR_ 102*/   wbkclsAlpha,
    /* NORC 102*/   wbkclsAlpha,
    /* NORD 102*/   wbkclsDigitsN,
    /* NTA_ 103*/   wbkclsAlpha,
    /* NTAC 103*/   wbkclsAlpha,
    /* NTAD 103*/   wbkclsDigitsN,
    /* NTE_ 104*/   wbkclsAlpha,
    /* NTEC 104*/   wbkclsAlpha,
    /* NTED 104*/   wbkclsDigitsN,
    /* NKD_ 105*/   wbkclsAlpha,
    /* NKDC 105*/   wbkclsAlpha,
    /* NKDD 105*/   wbkclsDigitsN,
    /* NMA_ 106*/   wbkclsAlpha,
    /* NMAC 106*/   wbkclsAlpha,
    /* NMAD 106*/   wbkclsDigitsN,
    /* NTH_ 107*/   wbkclsAlpha,
    /* NTHC 107*/   wbkclsAlpha,
    /* NTHD 107*/   wbkclsDigitsN,
    /* NTHT 107*/   wbkclsPunctSymb,
    /* NLO_ 108*/   wbkclsAlpha,
    /* NLOC 108*/   wbkclsAlpha,
    /* NLOD 108*/   wbkclsDigitsN,
    /* NTI_ 109*/   wbkclsAlpha,
    /* NTIC 109*/   wbkclsAlpha,
    /* NTID 109*/   wbkclsDigitsN,
    /* NTIN 109*/   wbkclsPunctSymb,
    /* NGE_ 110*/   wbkclsAlpha,
    /* NGEQ 111*/   wbkclsAlpha,
    /* NBO_ 112*/   wbkclsAlpha,
    /* NBSP 113*/   wbkclsSpaceA,
    /* NBSS 113*/   wbkclsSpaceA,
    /* NOF_ 114*/   wbkclsPunctSymb,
    /* NOBS 114*/   wbkclsPunctSymb,
    /* NOEA 114*/   wbkclsPunctSymb,
    /* NONA 114*/   wbkclsPunctSymb,
    /* NONP 114*/   wbkclsPunctSymb,
    /* NOEP 114*/   wbkclsPunctSymb,
    /* NONW 114*/   wbkclsPunctSymb,
    /* NOEW 114*/   wbkclsPunctSymb,
    /* NOLW 114*/   wbkclsPunctSymb,
    /* NOCO 114*/   wbkclsPunctSymb,
    /* NOSP 114*/   wbkclsPunctSymb,
    /* NOEN 114*/   wbkclsPunctSymb,
    /* NOBN 114*/   wbkclsPunctSymb,
    /* NET_ 115*/   wbkclsAlpha,
    /* NETP 115*/   wbkclsPunctSymb,
    /* NETD 115*/   wbkclsAlpha,
    /* NCA_ 116*/   wbkclsAlpha,
    /* NCH_ 117*/   wbkclsAlpha,
    /* WYI_ 118*/   wbkclsIdeoW,
    /* WYIN 118*/   wbkclsIdeoW,
    /* NBR_ 119*/   wbkclsAlpha,
    /* NRU_ 120*/   wbkclsAlpha,
    /* NOG_ 121*/   wbkclsAlpha,
    /* NOGS 121*/   wbkclsAlpha,
    /* NOGN 121*/   wbkclsAlpha,
    /* NSI_ 122*/   wbkclsAlpha,
    /* NSIC 122*/   wbkclsAlpha,
    /* NTN_ 123*/   wbkclsAlpha,
    /* NTNC 123*/   wbkclsAlpha,
    /* NKH_ 124*/   wbkclsAlpha,
    /* NKHC 124*/   wbkclsAlpha,
    /* NKHD 124*/   wbkclsDigitsN,
    /* NKHT 124*/   wbkclsPunctSymb,
    /* NBU_ 125*/   wbkclsAlpha,
    /* NBUC 125*/   wbkclsAlpha,
    /* NBUD 125*/   wbkclsAlpha,
    /* NSY_ 126*/   wbkclsAlpha,
    /* NSYP 126*/   wbkclsPunctSymb,
    /* NSYC 126*/   wbkclsAlpha,
    /* NSYW 126*/   wbkclsAlpha,    
    /* NMO_ 127*/   wbkclsAlpha,
    /* NMOC 127*/   wbkclsAlpha,
    /* NMOD 127*/   wbkclsDigitsN,
    /* NMOB 127*/   wbkclsPunctSymb,
    /* NMON 127*/   wbkclsPunctSymb,
    /* NHS_ 128*/   wbkclsAlpha,
    /* WHT_ 129*/   wbkclsAlpha,
    /* LS__ 130*/   wbkclsAlpha,
    /* XNW_ 131*/   wbkclsPunctSymb,
    /* XNWA 131*/   wbkclsPunctSymb,
};

#define PACKEDWORDBREAKLENGTH 3
enum
{
    WORDBREAK_DEFAULT   = 0x1,
    WORDBREAK_KOREAN    = 0x2,
    WORDBREAK_PROOF     = 0x4,
};

#ifndef _MAC
struct PACKEDWORDBREAKBITS
{
    LONGLONG i1 :3;
    LONGLONG i2 :3;
    LONGLONG i3 :3;
    LONGLONG i4 :3;
    LONGLONG i5 :3;
    LONGLONG i6 :3;
    LONGLONG i7 :3;
    LONGLONG i8 :3;
    LONGLONG i9 :3;
    LONGLONG i10:3;
    LONGLONG i11:3;
    LONGLONG i12:3;
    LONGLONG i13:3;
    LONGLONG i14:3;
    LONGLONG i15:3;
    LONGLONG i16:3;
    LONGLONG i17:3;
    LONGLONG i18:3;
};
#endif //_MAC
  
// Note the indices (enum wbkcls) really are 0-base, but the comments are
// written to reflect the spec, which is 1 based.
const BYTE aWordBreakBits[wbkclsLim][wbkclsLim] =
{
   // 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
    { 0, 7, 7, 7, 3, 7, 7, 0, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 1  PunctSymb 
    { 7, 0, 0, 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7 }, // 2  KanaFollow
    { 7, 0, 0, 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7 }, // 3  KatakanaW 
    { 7, 0, 7, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7 }, // 4  Hiragana  
    { 3, 7, 7, 7, 3, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 5  Tab       
    { 7, 0, 0, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7 }, // 6  KanaDelim 
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7 }, // 7  Prefix    
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 8  Postfix
    { 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 9  SpaceA    
    { 3, 7, 7, 7, 7, 7, 7, 3, 7, 0, 7, 0, 0, 0, 7, 7, 7, 7 }, // 10 Alpha     
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 7, 7, 0, 7, 7, 1, 7 }, // 11 IdeoW     
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7 }, // 12 SuperSub  
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 0, 0, 0, 7, 7, 7, 7 }, // 13 DigitsN   
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 0, 7, 0, 0, 0, 0, 7, 0, 0 }, // 14 PunctInText
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 0, 7, 0, 0, 7, 0, 0 }, // 15 DigitsW   
    { 7, 0, 7, 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7 }, // 16 KatakanaN 
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 0, 7, 0, 0, 7, 0, 7 }, // 17 Hangul    
    { 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 0, 7, 0, 0, 7, 7, 0 }, // 18 LatinW    
};

#if 0
const BYTE aWordBreakBits[wbkclsLim][wbkclsLim] =
{
   //18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1    // After/Before
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 0, 7, 7, 3, 7, 7, 7, 0 }, // 1  PunctSymb
    { 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7, 0, 0, 7 }, // 2  KanaFollow
    { 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7, 0, 0, 7 }, // 3  KatakanaW
    { 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 0, 7, 0, 7 }, // 4  Hiragana
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 3, 7, 7, 7, 3 }, // 5  Tab
    { 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 0, 0, 7 }, // 6  KanaDelim
    { 7, 7, 7, 0, 7, 0, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 7  Prefix
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 8  Postfix
    { 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7 }, // 9  SpaceA
    { 7, 7, 7, 7, 0, 0, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 7, 3 }, // 10 Alpha
    { 7, 1, 7, 7, 0, 7, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 11 IdeoW
    { 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }, // 12 SuperSub
    { 7, 7, 7, 7, 0, 0, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 13 DigitsN
    { 0, 0, 7, 0, 0, 0, 0, 7, 0, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 14 PunctInText
    { 0, 0, 7, 0, 0, 7, 0, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 15 DigitsW
    { 7, 7, 0, 7, 0, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7, 7, 0, 7 }, // 16 KatakanaN
    { 7, 0, 7, 0, 0, 7, 0, 1, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 17 Hangul
    { 0, 7, 7, 0, 0, 7, 0, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7 }, // 18 LatinW
};
#endif // 0
    
    
BOOL
IsWordBreakBoundaryDefault( WCHAR chBefore, WCHAR chAfter )
{
    const CHAR_CLASS ccBefore = CharClassFromCh(chBefore);
    const CHAR_CLASS ccAfter  = CharClassFromCh(chAfter);
    const WBKCLS wbkclsBefore = WordBreakClassFromCharClass(ccBefore);
    const WBKCLS wbkclsAfter  = WordBreakClassFromCharClass(ccAfter);

#if 0
    // Find appropriate row
    return ((*(LONGLONG *)(aWordBreakBits+wbkclsBefore)) >> 
                // Shift over to appropriate column
                ( wbkclsAfter * PACKEDWORDBREAKLENGTH ) & 
                    // Mask off the correct level
                    ( IsKoreanSelectionMode() ? WORDBREAK_KOREAN : WORDBREAK_DEFAULT ) );
#endif // 0
    return ( aWordBreakBits[wbkclsBefore][wbkclsAfter] & 
        ( IsKoreanSelectionMode() ? WORDBREAK_KOREAN : WORDBREAK_DEFAULT ) );
}

BOOL
IsProofWordBreakBoundary( WCHAR chBefore, WCHAR chAfter )
{
    const CHAR_CLASS ccBefore   = CharClassFromCh( chBefore );
    const CHAR_CLASS ccAfter    = CharClassFromCh( chAfter );
    const WBKCLS wbkclsBefore   = WordBreakClassFromCharClass( ccBefore );
    const WBKCLS wbkclsAfter    = WordBreakClassFromCharClass( ccAfter );

#if 0
    return ((*(DWORD *)( aWordBreakBits+wbkclsBefore )) >>
                ( wbkclsAfter * PACKEDWORDBREAKLENGTH ) & WORDBREAK_PROOF );
#endif 0
    return ( aWordBreakBits[wbkclsBefore][wbkclsAfter] & WORDBREAK_PROOF );    
}

//+----------------------------------------------------------------------------
//
//  Function:   WordBreakClassFromCharClass
//
//  Synopsis:   Given a character class, this function returns the proper
//              word breaking class.
//
//-----------------------------------------------------------------------------

WBKCLS
WordBreakClassFromCharClass(CHAR_CLASS cc)
{
    Assert(cc >=0 && cc < CHAR_CLASS_MAX);

    return awbkclsWordBreakClassFromCharClass[cc];
}

//+----------------------------------------------------------------------------
//
//  Function:   IsURLBreak
//
//  Synopsis:   Given a character, find out if URL should break at this point
//
//-----------------------------------------------------------------------------
BOOL
IsURLBreak(WCHAR wch)
{
    if (IsValidWideChar(wch))
    {
        WBKCLS  wbkcls = WordBreakClassFromCharClass(CharClassFromCh(wch));

        if (wbkcls == wbkclsSpaceA)
            return TRUE;

        //
        // See RAID bug 1242 -- MSKK does not want CJK in URLs. 
        // so we break at CJK except for Hangul.  This should
        // be changed in the future to consider Kinsoku as 
        // well. Also, we should indeed include CJK in URLs
        // however limit the number of characters  as Office does. 
        //
        if (wch >= 0x03000 && wbkcls != wbkclsHangul)
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\recalc.cxx ===
// ---------------------------------------------------------
//
// Microsoft Trident
// Copyright Microsoft corporation 1998
//
// File: recalc.cxx
//
// The Trident recalc engine: CRecalcEngine
//
// ---------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECALC_H
#define X_RECALC_H
#include "recalc.h"
#endif

#ifndef X_RECALC_HXX_
#define X_RECALC_HXX_
#include "recalc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

MtDefine(Recalc, Mem, "Recalc")
MtDefine(CRecalcEngine, Recalc, "CRecalcEngine")
MtDefine(CRecalcObject, Recalc, "CRecalcObject")
MtDefine(CRecalcProperty, Recalc, "CRecalcProperty")

#ifndef RECALC_USE_SCRIPTDEBUG
MtDefine(CScriptAuthorHolder, Recalc, "CScriptAuthorHolder")
#endif

DeclareTag(tagRecalcEngine, "Recalc Engine", "Recalc Engine trace")
DeclareTag(tagRecalcMemory, "Recalc Memory", "Track recalc memory use")
DeclareTag(tagRecalcDump, "Recalc Dump", "Enable dumping of recalc graph")
DeclareTag(tagRecalcEval, "Recalc Eval", "Trace expression evaluation in recalc")

ExternTag(tagRecalcStyle);

#if DBG == 1
unsigned CRecalcProperty::s_serialNumber = 0;
unsigned CRecalcObject::s_serialNumber = 0;
unsigned CRecalcEngine::s_serialNumber = 0;
#ifndef RECALC_USE_SCRIPTDEBUG
unsigned CScriptAuthorHolder::s_serialNumber = 0;
#endif
#endif

#ifndef RECALC_USE_SCRIPTDEBUG
//---------------------------------------------------------------
//
// Method:      CScriptAuthorHolder::CScriptAuthorHolder
//
// Description: the constructor
//
//---------------------------------------------------------------
CScriptAuthorHolder::CScriptAuthorHolder()
{
#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcMemory, "Constructing CScriptAuthorHolder # %d p=%08x", _serialNumber, this));
#endif
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::~CScriptAuthorHolder
//
// Description: the destroyer
//
//---------------------------------------------------------------}
CScriptAuthorHolder::~CScriptAuthorHolder()
{
    Assert(_pScriptAuthor == 0);
    TraceTag((tagRecalcMemory, "Destroying CScriptAuthorHolder # %d p=%08x", _serialNumber, this));
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::Init
//
// Description: Initialize the holder, actually CoCreates the engine
//
//---------------------------------------------------------------
HRESULT
CScriptAuthorHolder::Init(LPOLESTR szLanguage)
{
    CLSID clsid;
    HRESULT hr;
    CStr strTemp;

    hr = THR(_sLanguage.Set(szLanguage));
    if (hr)
        goto Cleanup;

    hr = THR(strTemp.Set(_sLanguage));
    if (hr)
        goto Cleanup;

    hr = THR(strTemp.Append(_T(" Author")));
    if (hr)
        goto Cleanup;

    hr = THR(CLSIDFromProgID(strTemp, &clsid));
    if (hr)
        goto Cleanup;

    hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScriptAuthor, (LPVOID *)&_pScriptAuthor));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::Compare
//
// Description: Are you the right engine for me?
//
//---------------------------------------------------------------
BOOL
CScriptAuthorHolder::Compare(LPOLESTR szLanguage)
{
    return (_tcsicmp(szLanguage, _sLanguage) == 0);
}

//---------------------------------------------------------------
//
// Function:    CScriptAuthorHolder::Detach
//
// Description: 'Hallo, my name is Diego Montoya, you killed my
//              father, prepare to die.'  Time to free all resources
//
//---------------------------------------------------------------
void
CScriptAuthorHolder::Detach()
{
    TraceTag((tagRecalcMemory, "Destroying CScriptAuthorHolder # %d p=%08x", _serialNumber, this));

    ClearInterface(&_pScriptAuthor);
}

#endif

//---------------------------------------------------------------
//
// Function:    CreateRecalcEngine(IUnknown
//
// Description: A helper used by our class factory to get things going
//
//---------------------------------------------------------------
STDMETHODIMP
CreateRecalcEngine(IUnknown *pUnkOuter, IUnknown **ppUnk)
{
    HRESULT hr;

    Assert(ppUnk);

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
        *ppUnk = 0;
    }
    else
    {
        *ppUnk = static_cast<IUnknown *>(static_cast<IRecalcEngine *>(new CRecalcEngine()));
        hr = *ppUnk ? S_OK : E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::CRecalcEngine
//
// Description: The constructor
//
//---------------------------------------------------------------}
CRecalcEngine::CRecalcEngine() : _ulRefs(1)
{
    _iFoundLast = -1;
    _pUnkFoundLast = 0;

#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcDetail, "Constructing CRecalcEngine # %d p=%08x", _serialNumber, this));
#endif
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::~CRecalcEngine
//
// Description: The destructor
//
//---------------------------------------------------------------}
CRecalcEngine::~CRecalcEngine()
{
    TraceTag((tagRecalcDetail, "Destroying CRecalcEngine # %d p=%08x", _serialNumber, this));
    Assert(_objects.Size() == 0);
    Assert(_ulRefs == 0);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::QueryInterface
//
// Description: IUnknown::QueryInterface
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (ppv == NULL)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IRecalcEngine *)this, IUnknown)
        QI_INHERITS((IRecalcEngine *)this, IRecalcEngine)
        QI_INHERITS(this, IObjectWithSite)
    default:
        if (IsEqualIID(iid, CLSID_CRecalcEngine))
        {
            *ppv = this;
            return S_OK;
        }
    }
    if (*ppv == NULL)
        RRETURN(E_NOINTERFACE);

    (*(IRecalcEngine **)ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::AddRef
//
// Description: IUnknown::AddRef
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcEngine::AddRef()
{
    return ++_ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::Release
//
// Description: IUnknown::Release
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcEngine::Release()
{
    Assert(_ulRefs > 0);

    unsigned long ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        Assert(_pHost == 0 && "Recalc Engine Released before SetSite(NULL)");
        Assert(_objects.Size() == 0);
#ifndef RECALC_USE_SCRIPTDEBUG
        Assert(_authors.Size() == 0);
#endif
        delete this;
    }
    return ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::Detach
//
// Description: Blows away all objects, unwinding any ref loops as we go
//
//---------------------------------------------------------------
void
CRecalcEngine::Detach()
{
    CRecalcObject **ppObject;
#ifndef RECALC_USE_SCRIPTDEBUG
    CScriptAuthorHolder **ppAuthor;
#endif

    int i;

    for (i = _objects.Size() , ppObject = _objects; i > 0 ; i-- , ppObject++)
    {
        (*ppObject)->Detach();
        (*ppObject)->Release();
    }
    _objects.DeleteAll();

#ifndef RECALC_USE_SCRIPTDEBUG
    for (i = _authors.Size() , ppAuthor = _authors ; i > 0 ; i-- , ppAuthor++)
    {
        (*ppAuthor)->Detach();
        delete (*ppAuthor);
    }
    _authors.DeleteAll();
#endif
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::SetSite
//
// Description: IObjectWithSite::SetSite
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::SetSite(IUnknown *pUnk)
{
    HRESULT hr;

    // We only expect to be called twice:
    // once at setup (!_pUnk && pUnk) and
    // once at teardown (_pUnk && !pUnk).
    //
    Assert((!_pHost && pUnk) || (_pHost && !pUnk));

    if (_pHost)
    {
        Detach();
        ClearInterface(&_pHost);
        WHEN_DBG(ClearInterface(&_pDebugHost);)
    }

    Assert(_objects.Size() == 0);
#ifndef RECALC_USE_SCRIPTDEBUG
    Assert(_authors.Size() == 0);
#endif

    if (pUnk)
    {
        hr = THR(pUnk->QueryInterface(IID_IRecalcHost, (LPVOID *)&_pHost));
#if DBG == 1
        if (SUCCEEDED(hr))
            pUnk->QueryInterface(IID_IRecalcHostDebug, (LPVOID *)&_pDebugHost);
#endif
    }
    else
        hr = S_OK;

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::GetSite
//
// Description: IObjectWithSite::GetSite
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::GetSite(REFIID riid, LPVOID *ppUnk)
{
    if (ppUnk == 0)
        RRETURN(E_INVALIDARG);
    *ppUnk = 0;
    if (!_pHost)
        RRETURN(E_FAIL);

    RRETURN(_pHost->QueryInterface(riid, ppUnk));
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::RemoveObject
//
// Description: Removes an object from the recalc engine
//
//---------------------------------------------------------------
void
CRecalcEngine::RemoveObject(CRecalcObject *pObject, BOOL fRemoveDependencies /* = FALSE */)
{
    int i = _objects.Find(pObject);
    if (i >= 0)
    {
        _objects[i]->Detach(fRemoveDependencies);

        // fRemoveDependencies may cause other objects to be deleted
        // so we need to recompute the index
        if (fRemoveDependencies)
        {
            i = _objects.Find(pObject);
            Assert (i >= 0);
        }
 
        _objects.ReleaseAndDelete(i);
    }
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::RecalcAll
//
// Description: IRecalcEngine::RecalcAll
//
//              Recalculates all dirty expressions.  Ignores dirty
//              state if fForce is set.
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::RecalcAll(BOOL fForce)
{
    HRESULT hr = S_OK;
    int i;

    TraceTag((tagRecalcEngine, "CRecalcEngine::RecalcAll(%d)", fForce));

    // Find any properties with dirty dependencies and update them.
    // Although resolving dependencies can change the graph (by adding
    // new property objects), none of the new objects should require
    // dependency checking

    WHEN_DBG(int cDirtyDeps = _dirtyDeps.Size());

    _fInDeps = TRUE;
    for (i = 0 ; i < _dirtyDeps.Size() ; i++)
    {
        _dirtyDeps[i]->UpdateDependencies();
    }

    _fInDeps = FALSE;

    Assert(cDirtyDeps == _dirtyDeps.Size());

    _dirtyDeps.DeleteAll();

    _fInRecalc = TRUE;

    // Now find anyone who needs recalc
    for (i = 0; i < _objects.Size(); i++)
    {
        hr = THR(_objects[i]->RecalcAll(fForce));
        if (hr)
            break;
    }

    _fInRecalc = FALSE;

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::SetExpression
//
// Description: IRecalcEngine::SetExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::SetExpression(IUnknown *pUnk, DISPID dispid, LPOLESTR szExpression, LPOLESTR szLanguage)
{
    CRecalcProperty *pProperty = 0;
    HRESULT hr;

    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

#if DBG == 1
    if (_fInRecalc)
        TraceTag((tagRecalcEngine, "SetExpression while in recalc: %ls", szExpression));

    if (_fInDeps)
        TraceTag((tagRecalcEngine, "SetExpression while in recalc deps: %ls", szExpression));
#endif

    hr = THR(FindProperty(pUnk, dispid, TRUE, &pProperty));
    if (hr)
        goto Cleanup;

    hr = THR(pProperty->SetExpression(szExpression, szLanguage));
    if (hr)
        goto Cleanup;

Cleanup:
    if (hr)
    {
        if (pProperty)
            pProperty->DeleteIfEmpty();
    }

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::GetExpression
//
// Description: IRecalcEngine::GetExpression
//
// Returns:     S_OK or S_FALSE
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::GetExpression(IUnknown *pUnk, DISPID dispid, BSTR *pstrExpression, BSTR *pstrLanguage)
{
    CRecalcProperty *pProperty = NULL;

    HRESULT hr = THR(FindProperty(pUnk, dispid, FALSE, &pProperty));
    if (!hr)
    {
        hr = THR(pProperty->GetExpression(pstrExpression, pstrLanguage));
    }

    if (hr == S_FALSE)
    {
        *pstrExpression = 0;
        *pstrLanguage = 0;
    }
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::ClearExpression
//
// Description: IRecalcEngine::ClearExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::ClearExpression(IUnknown *pUnk, DISPID dispid)
{
    CRecalcProperty *pProperty = NULL;

    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

    HRESULT hr = THR(FindProperty(pUnk, dispid, FALSE, &pProperty));
    if (!hr)
    {
        hr = THR(pProperty->ClearExpression());
    }

    RRETURN1(hr, S_FALSE);
}


//---------------------------------------------------------------
//
// Function:    CRecalcEngine::BeginStyle
//
// Description: IRecalcEngine::BeginStyle
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::BeginStyle(IUnknown *pUnk)
{
    HRESULT hr = E_INVALIDARG;
    CRecalcObject *pObject;

    Assert(!_fInRecalc);

    hr = THR(FindObject(pUnk, TRUE, &pObject));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->BeginStyle());
    if (hr)
        goto Cleanup;
Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::BeginStyle
//
// Description: IRecalcEngine::EndStyle
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcEngine::EndStyle(IUnknown *pUnk)
{
    HRESULT hr = E_INVALIDARG;
    CRecalcObject *pObject;

    hr = THR(FindObject(pUnk, FALSE, &pObject));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->EndStyle());
    if (hr)
        goto Cleanup;
Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------
//
// Function:    CRecalcEngine::Find
//
// Description: Find an object by pUnk (returns the index)
//
//---------------------------------------------------------------
int
CRecalcEngine::Find(IUnknown *pUnk)
{
    TraceTag((tagRecalcDetail, "Looking for %08x", pUnk));

    CRecalcObject **ppObject;
    int i;

    if ((pUnk == _pUnkFoundLast) && (_iFoundLast < _objects.Size()) && (_objects[_iFoundLast]->GetUnknown() == pUnk))
        return _iFoundLast;

    for (i = _objects.Size() , ppObject = _objects ; i > 0 ; i-- , ppObject++)
    {
        if ((*ppObject)->GetUnknown() == pUnk)
        {
            TraceTag((tagRecalcDetail, "Found at index %d", ppObject - _objects));
            _iFoundLast = i;
            _pUnkFoundLast = pUnk;

            return ppObject - _objects;
        }
    }

    return -1;
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::FindObject
//
// Description: Finds an object (by _pUnk), optionally creating it if not found
//
//---------------------------------------------------------------
HRESULT
CRecalcEngine::FindObject(IUnknown *pUnk, BOOL fCreate, CRecalcObject **ppObject, unsigned *pIndex)
{
    HRESULT hr = S_FALSE;

    CRecalcObject *pObject = 0;
    int i = Find(pUnk);
    
    if (i >= 0)
    {
        pObject = _objects[i];
        hr = S_OK;
    }
    else if (fCreate)
    {
        pObject = new CRecalcObject(this, pUnk);
        if (!pObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_objects.Append(pObject));
        if (hr)
        {
            ClearInterface(&pObject);
            goto Cleanup;
        }

        Assert(_objects.Size() > 0);

        i = _objects.Size() - 1;

        Assert(_objects[i] == pObject);
    }

Cleanup:
    *ppObject = pObject;
    if (pIndex)
        *pIndex = i;
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcEngine::FindProperty
//
// Description: Find a property (optionally creating the object
//              the property along the way
//
//---------------------------------------------------------------
HRESULT
CRecalcEngine::FindProperty(IUnknown *pUnk, DISPID dispid, BOOL fCreate, CRecalcProperty **ppProperty)
{
    Assert(ppProperty);
    HRESULT hr;

    CRecalcProperty *pProperty = 0;
    CRecalcObject *pObject = 0;

    hr = THR(FindObject(pUnk, fCreate, &pObject));
    if (!hr)
    {
        Assert(pObject);
        hr = THR(pObject->FindProperty(dispid, fCreate, &pProperty));
        if (!hr)
        {
            *ppProperty = pProperty;

            hr = S_OK;
        }
    }

    RRETURN1(hr, S_FALSE);
}

#ifndef RECALC_USE_SCRIPTDEBUG
//---------------------------------------------------------------
//
// Function:    CRecalcEngine::GetScriptAuthor
//
// Description: A helper to get the IActiveScriptAuthor interface
//
//---------------------------------------------------------------
HRESULT
CRecalcEngine::GetScriptAuthor(LPOLESTR szLanguage, IActiveScriptAuthor **ppScriptAuthor)
{
    Assert(ppScriptAuthor);

    HRESULT hr ;

    CScriptAuthorHolder **ppScriptHolder;
    int i;

    for (i = _authors.Size() , ppScriptHolder = _authors ; i > 0 ; i-- , ppScriptHolder++)
    {
        if ((*ppScriptHolder)->Compare(szLanguage))
        {
            *ppScriptAuthor = (*ppScriptHolder)->ScriptAuthor();
            RRETURN(S_OK);
        }
    }

    CScriptAuthorHolder *psh = new CScriptAuthorHolder();
    if (!psh)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = THR(psh->Init(szLanguage));
    if (hr)
        goto Error;

    hr = THR(_authors.Append(psh));
    if (hr)
        goto Error;

    *ppScriptAuthor = psh->ScriptAuthor();

Cleanup:
    RRETURN(hr);
Error:
    if (psh)
    {
        psh->Detach();
        delete psh;
    }
    goto Cleanup;
}

#endif

HRESULT
CRecalcEngine::AddDependencyUpdateRequest(CRecalcProperty *pProperty)
{
    Assert(!_fInDeps);
    GetHost()->RequestRecalc();
    RRETURN(_dirtyDeps.Append(pProperty));
}

HRESULT
CRecalcEngine::RemoveDependencyUpdateRequest(CRecalcProperty *pProperty)
{
    RRETURN(_dirtyDeps.DeleteByValue(pProperty) ? S_OK : E_INVALIDARG);
}


//---------------------------------------------------------------------------------------
//
// CRecalcObject
//

//---------------------------------------------------------------
//
// Function:    CRecalcObject::CRecalcObject
//
// Description: The constructor
//
// Notes:       CRecalcObject lifetime is controlled by refcount
//              However, its lifetime in the recalc engine is
//              controlled by the number of properties.  When the
//              number of properties drops to zero, the object
//              removes itself from the engine.  When the engine
//              releases the object it should go away.  Errant
//              holders of IPropertyNotifySink will cause the
//              CRecalcObject to live on.
//
//---------------------------------------------------------------
CRecalcObject::CRecalcObject(CRecalcEngine *pEngine, IUnknown *pUnk) : _pEngine(pEngine) , _pUnk(pUnk) , _ulRefs(1)
{
    Assert(_pUnk);
    Assert(_pEngine);

#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcMemory, "Constructing CRecalcObject # %d p=%08x", _serialNumber, this));

    GetDebugHost()->GetObjectInfo(_pUnk, 0, &_bstrID, 0, &_bstrTag);

    if (_bstrID == 0)
        _bstrID = SysAllocString(_T("{no-id}"));

    if (_bstrTag == 0)
        _bstrTag = SysAllocString(_T("{no-tag}"));

#endif

    _iFoundLast = -1;
    _dispidFoundLast = DISPID_UNKNOWN;

    _pUnk->AddRef();
    if (THR(ConnectSink(_pUnk, IID_IPropertyNotifySink, (IPropertyNotifySink *)this, &_dwCookie)) == S_OK)
        _fGotSink = TRUE;

}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::~CRecalcObject
//
// Description: The destructor
//
//---------------------------------------------------------------}
CRecalcObject::~CRecalcObject()
{
    TraceTag((tagRecalcMemory, "Destroying CRecalcObject # %d p=%08x", _serialNumber, this));
    Assert(_properties.Size() == 0);
    Assert(_pUnk == 0);
    Assert(!_fGotSink);
    Assert(_ulRefs == 0);
#if DBG == 1
    FormsFreeString(_bstrID);
    FormsFreeString(_bstrTag);
#endif
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::Detach
//
// Description: Time to cleanup and release all resources.
//
//---------------------------------------------------------------
void
CRecalcObject::Detach(BOOL fRemoveDependencies /* = FALSE */)
{
    TraceTag((tagRecalcMemory, "Detaching CRecalcObject # %d p=%08x", _serialNumber, this));

    Assert(_pUnk);
    Assert(_pEngine);

    int i;
    CRecalcProperty **ppProperty;

    for (i = _properties.Size() , ppProperty = _properties ; i > 0 ; i-- , ppProperty++)
    {
        if (fRemoveDependencies)
        {
            _fDoingStyle = TRUE;  // this is to prevent the object itself from being deleted
            IGNORE_HR((*ppProperty)->RemoveAllDependencies());
            IGNORE_HR((*ppProperty)->CleanupDependents());
            _fDoingStyle = FALSE;
        }

        delete (*ppProperty);
    }

    _properties.DeleteAll();

    if (_fGotSink)
    {
        IGNORE_HR(DisconnectSink(_pUnk, IID_IPropertyNotifySink, &_dwCookie));
        Assert(_dwCookie == 0);
        _fGotSink = FALSE;
    }

    ClearInterface(&_pUnk);
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::QueryInterface
//
// Description: IUnknown::QueryInterface
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcObject::QueryInterface(REFIID iid, LPVOID *ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPropertyNotifySink *)this, IUnknown)
        QI_INHERITS(this, IPropertyNotifySink)
    }
    if (*ppv == NULL)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::AddRef
//
// Description: IUnknown::AddRef
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcObject::AddRef()
{
    return ++_ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::Release
//
// Description: IUnknown::Release
//
//---------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRecalcObject::Release()
{
    Assert(_ulRefs > 0);

    unsigned long ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::OnChanged
//
// Description: IPropertyNotifySink::OnChanged
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcObject::OnChanged(DISPID dispid)
{
    Assert(_properties.Size());

    CRecalcProperty *pProperty = 0;
    if (FindProperty(dispid, FALSE, &pProperty) == S_OK)
    {
        Assert(pProperty);
        pProperty->OnChanged();
    }
    RRETURN(S_OK);
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::OnRequestEdit
//
// Description: IPropertyNotifySink::OnRequestEdit
//
//---------------------------------------------------------------
STDMETHODIMP
CRecalcObject::OnRequestEdit(DISPID dispid)
{
    // Don't care
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::FindProperty
//
// Description: Find a property by dispid, optionally create it
//
//---------------------------------------------------------------
HRESULT
CRecalcObject::FindProperty(DISPID dispid, BOOL fCreate, CRecalcProperty **ppProperty)
{
    HRESULT hr = S_FALSE;

    CRecalcProperty *pProperty = 0;
    int i = Find(dispid);

    if (i >= 0)
    {
        pProperty = _properties[i];
        hr = S_OK;
    }
    else if (fCreate)
    {
        hr = THR(CRecalcProperty::CreateProperty(this, dispid, &pProperty));
        if (hr)
            goto Cleanup;

        Assert(pProperty);

        hr = THR(_properties.Append(pProperty));
        if (hr)
            goto Cleanup;
Cleanup:
        if (hr && pProperty)
        {
            pProperty->DeleteIfEmpty();
            pProperty = 0;
        }

    }

    *ppProperty = pProperty;
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::Find
//
// Description: Find a property by dispid
//
//---------------------------------------------------------------
int
CRecalcObject::Find(DISPID dispid)
{
    CRecalcProperty **ppProperty;
    unsigned i;

    if ((dispid == _dispidFoundLast) && (_iFoundLast < _properties.Size()) && (_properties[_iFoundLast]->GetDispid() == dispid))
        return _iFoundLast;

    for (i = _properties.Size() , ppProperty = _properties ; i > 0 ; i-- , ppProperty++)
    {
        if ((*ppProperty)->GetDispid() == dispid)
        {
            return ppProperty - _properties;
        }
    }
    return -1;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::RecalcAll
//
// Description: Recalc all of your properties
//              Only properties with no dependents are recalc'd.
//              They will in turn call their dependencies before
//              trying to eval.  Depth first traversal of a tree
//---------------------------------------------------------------
HRESULT
CRecalcObject::RecalcAll(BOOL fForce)
{
    int i;

    TraceTag((tagRecalcEngine, "RecalcAll: object: %ls", GetID()));

    //
    // Because SetExpression (or worse, removeExpression) could
    // be called during recalc, we iterate the old fashioned way.
    // At worst we'll 
    // Iterating using the index ensures that additions to the
    // recalc dep graph doesn't cause any problems.  (SetExpression can 
    // be called during recalc).  This 
    //
    //
    for (i = 0 ; i < _properties.Size() ; i++)
    {
        CRecalcProperty *pProperty = _properties[i];

        if (pProperty->IsTopLevel())
        {
            // Just because one expression fails doesn't mean we should
            // stop trying others.
            //
            // NOTE: (michaelw) It would be nice if I know if the user
            // has said "No" when asked if they want to keep running
            // scripts.
            //
            IGNORE_HR(pProperty->Eval(fForce));
        }
    }

    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::RemoveProperty
//
// Description: This property is no longer needed
//
//---------------------------------------------------------------
void
CRecalcObject::RemoveProperty(CRecalcProperty *pProperty)
{
    int i = _properties.Find(pProperty);

    if (i >= 0)
    {
        delete _properties[i];
        _properties.Delete(i);

        if (!_fDoingStyle && (_properties.Size() == 0))
            _pEngine->RemoveObject(this);
    }
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::BeginStyle
//
// Description: Any calls to SetExpression are for style props
//
//---------------------------------------------------------------
HRESULT
CRecalcObject::BeginStyle()
{
    Assert(!_fDoingStyle);

    _fDoingStyle = TRUE;
#if DBG == 1
    for (int i = 0 ; i < _properties.Size() ; i++)
        if (_properties[i]->IsStyleProp())
            Assert(!_properties[i]->CheckAndClearStyleSet());
#endif
    return S_OK;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::EndStyle
//
// Description: After all the style expressions have been set,
//              remove anything left over
//
//---------------------------------------------------------------
HRESULT
CRecalcObject::EndStyle()
{
    Assert(_fDoingStyle);

    // Because we are removing elements from the arraw as we go,
    // This array is enumerated using an index only.

    for (int i = _properties.Size() - 1 ; i >= 0 ; i--)
    {
        CRecalcProperty *pProp = _properties[i];

        if (pProp->IsStyleProp() && !pProp->CheckAndClearStyleSet())
        {
            TraceTag((tagRecalcStyle, "Removing style expression: _pUnk: %08x _dispid: %08x _expr: %ls", pProp->GetUnknown(), pProp->GetDispid(), pProp->GetExpression()));
            IGNORE_HR(pProp->ClearExpression());
        }
    }

    _fDoingStyle = FALSE;

    if (_properties.Size() == 0)
        _pEngine->RemoveObject(this);

    return S_OK;
}


//---------------------------------------------------------------------------------------------------
//
// CRecalcProperty::CreateProperty
//
// The only place where property objects get created.
//
// This function ensures that the property is properly constructed and initialized.
//
// It may need to create the canonical property at the same time.
//
//---------------------------------------------------------------------------------------------------


HRESULT CRecalcProperty::CreateProperty(CRecalcObject *pObject, DISPID dispid, CRecalcProperty **ppProperty)
{
    CRecalcProperty *pProperty = 0;
    CRecalcProperty *pPropertyCanonical = 0;
    IUnknown *pUnkCanonical = NULL;
    DISPID dispidCanonical;

    HRESULT hr;

    pProperty = new CRecalcProperty(pObject, dispid);
    if (!pProperty)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(GetCanonicalProperty(pObject->GetUnknown(), dispid, &pUnkCanonical, &dispidCanonical));
    if (hr == S_FALSE)
    {
        // This property is not aliased
        hr = S_OK;
    }
    else
    {
        // The property is aliased, find and create it's canonical property

        pProperty->_fAlias = TRUE;

        hr = THR(pObject->GetEngine()->FindProperty(pUnkCanonical, dispidCanonical, TRUE, &pPropertyCanonical));
        if (hr)
            goto Cleanup;

        hr = THR(pPropertyCanonical->AddAlias(pProperty));
        if (hr)
            goto Cleanup;

        pProperty->_pPropertyCanonical = pPropertyCanonical;
    }

Cleanup:
    if (hr)
    {
        if (pPropertyCanonical)
            pPropertyCanonical->DeleteIfEmpty();
        if (pProperty)
            pProperty->DeleteIfEmpty();

        *ppProperty = 0;
    }
    else
        *ppProperty = pProperty;

    ReleaseInterface(pUnkCanonical);
    RRETURN(hr);
}


//-----------------------------------------------
//
// Method:      CRecalcProperty::CRecalcProperty
//
// Description: Constructor
//
//-----------------------------------------------
CRecalcProperty::CRecalcProperty(CRecalcObject *pObject, DISPID dispid) : _pObject(pObject) , _dispid(dispid)
{
#if DBG == 1
    _serialNumber = s_serialNumber++;
    TraceTag((tagRecalcMemory, "Constructing CRecalcProperty # %d p=%08x", _serialNumber, this));
    GetDebugHost()->GetObjectInfo(GetUnknown(), _dispid, NULL, &_bstrName, NULL);

    if (_bstrName == 0)
        _bstrName = SysAllocString(_T("{no-name}"));

#endif

    _fNoNotify = !_pObject->GotSink();

}

//-----------------------------------------------
//
// Method:      CRecalcProperty::
//
// Description: Destructor
//
//-----------------------------------------------
CRecalcProperty::~CRecalcProperty()
{
    TraceTag((tagRecalcMemory, "Destroying CRecalcProperty # %d p=%08x", _serialNumber, this));

    if (_fDirtyDeps)
        GetEngine()->RemoveDependencyUpdateRequest(this);

    ClearInterface(&_pdispThis);
    ClearInterface(&_pdispExpression);
#if DBG == 1
    FormsFreeString(_bstrName);
#endif
}


//-----------------------------------------------
//
// Method:      CRecalcProperty::OnChanged
//
// Description: IPropertyNotifySink::OnChanged (as delegated by CRecalcObject)
//
//-----------------------------------------------

void
CRecalcProperty::OnChanged()
{
    TraceTag((tagRecalcDetail, "OnChange() this: %08x _pUnk: %08x _dispid: %08x has changed", this, _pObject->GetUnknown(), _dispid));

    if (_fSetValue)
    {
        // This is an expected prop change.
#if DBG == 1
        _cChanged++;
#endif
    }
/*
 * No more automatic removal of expressions!
 *
 * Although this is the "right" way, it isn't
 * practical to make it work for all cases.
 * The case where a property is set to its 
 * current value doesn't always fire a prop
 * change so we would behave very inconsistently.
 *
    else if (HasExpression())
    {
        ClearExpression();
    }
*/
    else
    {
        SetDirty(TRUE);
    }
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::SetDirty
//
// Description: We're dirty.  Tell our dependents and request a recalc
//
//-----------------------------------------------
void
CRecalcProperty::SetDirty(BOOL fDirty, BOOL fRequestRecalc)
{
    if (_fSetDirty)
    {
        TraceTag((tagRecalcEngine, "SetDirty detected circularity"));
        _fCircular = TRUE;

        return;
    }

    if (IsAlias())
    {
        _pPropertyCanonical->SetDirty(fDirty, fRequestRecalc);

        return;
    }

    // Canonicalize the incoming BOOL and make it an unsigned
    unsigned ufDirty = !!fDirty;

    if (ufDirty != _fDirty)
    {
        _fDirty = ufDirty;

        if (ufDirty)
        {
            Assert(!_fSetDirty);
            _fSetDirty = TRUE;

            NotifyDependents();

            Assert(_fSetDirty);
            _fSetDirty = FALSE;

            if (fRequestRecalc)
                GetHost()->RequestRecalc();
        }
    }
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::NotifyDependents
//
// Description: Tell our dependents that we're dirty
//
//---------------------------------------------------------------
void
CRecalcProperty::NotifyDependents()
{
    int i;
    CRecalcProperty **ppProperty;

    Assert(IsCanonical());

    for (i = _dependents.Size() , ppProperty = _dependents ; i > 0 ; i-- , ppProperty++)
        (*ppProperty)->SetDirty(TRUE, FALSE);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::
//
// Description: Are we needed anymore?
//
//-----------------------------------------------
void
CRecalcProperty::DeleteIfEmpty()
{
    //
    // Any dependents?  Any dependencies?  Any aliases?  An Expression?
    //
    // It is possible for _dependencies.Size() == 0 and _dependencyNames.Size() != 0
    // This happens when there are unresolved names.  We will stick around hoping, waiting...
    //
    if (_dependencyNames.Size() + _dependents.Size() + _dependencies.Size() + _aliases.Size() + _sExpression.Length() == 0)
    {
        if (IsAlias())
        {
            _pPropertyCanonical->RemoveAlias(this);
        }

        _pObject->RemoveProperty(this);
    }
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::AddDependent
//
// Description: Add's a property to the list of dependents.
//              Dependents will be notified whenever this
//              property changes.
//
// Returns:     S_OK        everything is fine
//              S_FALSE     added ok but can't notify on prop change
//
//-----------------------------------------------
HRESULT
CRecalcProperty::AddDependent(CRecalcProperty *pProperty, BOOL *pfNoNotify)
{
    Assert(pProperty);
    Assert(pfNoNotify);

    HRESULT hr;

    *pfNoNotify = _fNoNotify;

    Assert(IsCanonical());

    if (_dependents.Find(pProperty) >= 0)
        hr = S_OK;
    else
    {
        hr = _dependents.Append(pProperty);
    }

    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::RemoveDependent
//
// Description: Someone doesn't depend on us anymore
//
//-----------------------------------------------
HRESULT
CRecalcProperty::RemoveDependent(CRecalcProperty *pProperty)
{
    HRESULT hr;

    Assert(IsCanonical());

    if (_dependents.DeleteByValue(pProperty))
    {
        hr = S_OK;
        DeleteIfEmpty();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}

//---------------------------------------------------
//
// Method:      CRecalcProperty::AddAlias
//
// Description: Add an alias to the list of known aliases
//
//---------------------------------------------------
HRESULT
CRecalcProperty::AddAlias(CRecalcProperty *pProperty)
{
    Assert(pProperty);

   if (_aliases.Find(pProperty) >= 0)
        return S_OK;

    RRETURN(_aliases.Append(pProperty));
}


//---------------------------------------------------
//
// Method:      CRecalcProperty::RemoveAlias
//
// Description: Remove an alias to the list of known aliases
//
//---------------------------------------------------
HRESULT
CRecalcProperty::RemoveAlias(CRecalcProperty *pProperty)
{
    Assert(pProperty);

    if (!_aliases.DeleteByValue(pProperty))
        RRETURN(E_INVALIDARG);

    DeleteIfEmpty();

    return S_OK;
}


//-----------------------------------------------
//
// Method:      CRecalcProperty::AddDependency
//
// Description: We depend on some other property.
//
//-----------------------------------------------
HRESULT
CRecalcProperty::AddDependency(IDispatch *pDispatch, DISPID dispid)
{
    CRecalcProperty *pProperty = NULL;
    IUnknown *pUnkDepend = 0;
    DISPID dispidDepend;
    BOOL fNoNotify;
    HRESULT hr;
    int i;

    // First try to get the canonical property
    hr = THR(GetCanonicalProperty((IUnknown *)pDispatch, dispid, &pUnkDepend, &dispidDepend));
    if (FAILED(hr))
        goto Cleanup;
    else if (hr == S_FALSE)
    {
        // This property isn't aliased, use the pUnk
        dispidDepend = dispid;
        hr = THR(pDispatch->QueryInterface(IID_IUnknown, (LPVOID *)&pUnkDepend));
        if (hr)
            goto Cleanup;
    }

    // Do we already have this dependency?

    for (i = 0 ; i < _dependencies.Size() ; i++)
    {
        if ((_dependencies[i]->GetUnknown() == pUnkDepend) && (_dependencies[i]->_dispid == dispidDepend))
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    // We don't already have this dependency, time to add it.

    hr = THR(GetEngine()->FindProperty(pUnkDepend, dispidDepend, TRUE, &pProperty));
    if (hr)
        goto Cleanup;

    hr = THR(_dependencies.Append(pProperty));
    if (hr)
        goto Cleanup;

    hr = THR(pProperty->AddDependent(this, &fNoNotify));
    if (hr)
        goto Cleanup;

    if (fNoNotify)
        _fNoNotify = TRUE;

Cleanup:
    ReleaseInterface(pUnkDepend);

    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::RemoveDependency
//
// Description: Remove the dependency for this property
//
//-----------------------------------------------
HRESULT
CRecalcProperty::RemoveDependency(CRecalcProperty *pProperty)
{
    HRESULT hr;

    if (_dependencies.DeleteByValue(pProperty))
    {
        hr = S_OK;
        DeleteIfEmpty();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::CleanupDependents
//
// Description: Tell our dependents that we're gone - they shouldn't count on us
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::CleanupDependents()
{
    HRESULT hr = S_OK;
    int i;
    CRecalcProperty **ppProperty;

    for (i = _dependents.Size() , ppProperty = _dependents ; i > 0 ; i-- , ppProperty++)
    {
        hr = THR((*ppProperty)->RemoveDependency(this));
        if (hr)
            goto Cleanup;    
    }

    _dependents.DeleteAll();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------
//
// Function:    CRecalcProperty::RemoveAllDependencies
//
// Description: Clean out the bunch of them, we depend on nobody!
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::RemoveAllDependencies()
{
    HRESULT hr = S_OK;
    int i;
    CRecalcProperty **ppProperty;

    for (i = _dependencies.Size() , ppProperty = _dependencies ; i > 0 ; i-- , ppProperty++)
    {
        hr = THR((*ppProperty)->RemoveDependent(this));
        if (hr)
            goto Cleanup;
    }

    _dependencies.DeleteAll();

    _fNoNotify = !_pObject->GotSink();
Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::ClearExpression
//
// Description: Clear's the expression, may delete the object
//
//-----------------------------------------------
HRESULT
CRecalcProperty::ClearExpression()
{
    Assert(!GetEngine()->InRecalc());
    // Tell the host to remove the attribute value
    GetHost()->RemoveValue(GetUnknown(), _dispid);
    HRESULT hr = clearExpressionHelper();
    if (hr)
        goto Cleanup;

    DeleteIfEmpty();

Cleanup:
    RRETURN(hr);
}

HRESULT
CRecalcProperty::clearExpressionHelper()
{
    Assert(!_fSetDirty);
    Assert(!_fSetValue);
    Assert(!_fInEval);
    Assert(!GetEngine()->InRecalc());

    HRESULT hr = THR(RemoveAllDependencies());
    if (hr)
        goto Cleanup;

    _dependencyNames.DeleteAll();

    _sExpression.Free();
    _sLanguage.Free();
    _sExpressionNames.Free();

    _fError = FALSE;

    ClearInterface(&_pdispExpression);
    ClearInterface(&_pdispThis);

    _fCircular = FALSE;

    if (IsAlias())
        _pPropertyCanonical->_pPropertyExpression = NULL;
    else
        _pPropertyExpression = NULL;

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::EvalExpression
//
// Description: The real McCoy.  This is where all
//              the magic happens.  This is it.  Hold on
//              to your socks.
//
//-----------------------------------------------
HRESULT
CRecalcProperty::EvalExpression(VARIANT *pv)
{
    HRESULT hr;
    CExcepInfo  excepinfo;
    DISPPARAMS dispParams;

    Assert((LPOLESTR)_sExpression);

    if (_pdispExpression)
    {
        if (_pdispThis)     // We actually have a _pDEXExpression
        {
            DISPID dispidThis = DISPID_THIS;
            VARIANTARG  vThis;

            dispParams.rgvarg = &vThis;
            dispParams.rgdispidNamedArgs = &dispidThis;
            dispParams.cArgs = 1;
            dispParams.cNamedArgs = 1;

            V_VT(&vThis) = VT_DISPATCH;
            V_DISPATCH(&vThis) = _pdispThis;

            hr = THR(_pDEXExpression->InvokeEx(DISPID_VALUE,
                                          0,
                                          DISPATCH_METHOD,
                                          &dispParams,
                                          pv,
                                          &excepinfo,
                                          NULL));
        }
        else
        {
            dispParams = g_Zero.dispparams;
            hr = THR(_pdispExpression->Invoke(DISPID_VALUE,
                                          IID_NULL,
                                          0,
                                          DISPATCH_METHOD,
                                          &dispParams,
                                          pv,
                                          &excepinfo,
                                          NULL));
        }
    }
    else
    {
        hr = THR(GetHost()->EvalExpression(_pObject->GetUnknown(), _dispid, _sExpression, _sLanguage, pv));
    }
#if DBG == 1
    CVariant vStr;

    vStr.CoerceVariantArg(pv, VT_BSTR);

    TraceTag((tagRecalcEval, "%ls returned %ls", (LPOLESTR)_sExpression, V_BSTR(&vStr)));
#endif
    RRETURN(hr);
}

//---------------------------------------------------
//
// Method:      CRecalcProperty::Eval
//
// Description: This ensures that a property is up to date
//              This method should be called for any dependencies
//              Before actuallying evaluating the expression on a property
//
//              This method will also ensure that the computed value is
//              put into the OM
//
//              Circularity is detected but tolerated
//
//---------------------------------------------------
HRESULT
CRecalcProperty::Eval(BOOL fForce)
{
    HRESULT hr = S_OK;
    CVariant v;
    int i;

    TraceTag((tagRecalcEval, "%ls.%ls", _pObject->GetID(), _bstrName));

    //
    // Catch circularity
    //
    // For the cases where the circularlity is implicit (inner relationships between
    // properties) or hidden (global references to properties inside function calls), _fInEval
    // is used to dynamically detect circularity.
    //
    if (_fInEval)
    {
        TraceTag((tagRecalcEval, "bailing due to circularity", _pObject->GetID(), _bstrName));
        hr = S_OK;
        goto Cleanup;
    }

    // If we're trying to evaluate a property that doesn't have an expression
    // it must be canonical (because we only put dependencies on canonical properties)
    // In some cases, the real expression is on another object, in which case we eval
    // that object.  Otherwise we're done.
    if (_sExpression.IsNull())
    {
        // Aliases shouldn't be dependencies or top level evals.
        Assert(IsCanonical());

        // If we're looking at this object and we're not the one with the expression, go do the expression 
        if (_pPropertyExpression)
        {
            TraceTag((tagRecalcEval, "evaluating alias"));
            hr = THR(_pPropertyExpression->Eval(fForce));
        }

        goto Cleanup;
    }

    _fInEval = TRUE;

    Assert(!_sExpression.IsNull());

    //
    // This property has an expression.  Now we need to make sure all its dependencies
    // have been evaluated first.
    //
    // This loop needs to handle the possibility that some properties will go away
    // I actually think this is a pretty rare case but if all expressions are somehow
    // cleared as a result of evaluating one of them then the entire recalc graph could
    // be destroyed.

#if DBG == 1
    if (_dependencies.Size())
        TraceTag((tagRecalcEval, "Evaluating dependencies"));
#endif
    for (i = 0 ; i < _dependencies.Size() ; i++)
    {
        // Just because a dependency fails doesn't mean we should
        IGNORE_HR(_dependencies[i]->Eval(fForce));
    }

    if (_fDirtyDeps || fForce || (IsAlias() ? _pPropertyCanonical->_fDirty : _fDirty) || _fNoNotify || _fUnresolved)
    {
        // Now actually evaluate our expression

        hr = THR(EvalExpression(&v));

        if (hr)
        {
            // The expression eval failed for some reason.
            _fError = TRUE;
            hr = S_OK;          // gobble the error
            goto Cleanup;
        }

        else
        {
            _fError = FALSE;
            hr = THR(SetValue(&v, fForce));
            if (hr)
                goto Cleanup;
        }
    }

    TraceTag((tagRecalcEval, "%ls.%ls done\n", _pObject->GetID(), _bstrName));
Cleanup:
    SetDirty(FALSE);

    _fInEval = FALSE;
    RRETURN(hr);
}

//-----------------------------------------------
//
// Method:      CRecalcProperty::SetExpression
//
// Description: Assigns an expression to a property
//
// REVIEW michaelw  Needs more error handling
//
//-----------------------------------------------
HRESULT
CRecalcProperty::SetExpression(LPCOLESTR szExpression, LPCOLESTR szLanguage)
{
    HRESULT hr;
    IDispatchEx *pDEXExpression = 0;
    CRecalcProperty *pPropertyExpression = 0;

    Assert(!GetEngine()->InRecalc());

    if (!szExpression || !szLanguage)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pPropertyExpression = IsAlias() ? _pPropertyCanonical->_pPropertyExpression : _pPropertyExpression;

    if (pPropertyExpression && pPropertyExpression != this)
    {
        // There is already an expression on this property group and it isn't on this property

        TraceTag((tagRecalcEngine, "SetExpression: you can't have two expressions on a property group"));
        hr = E_FAIL;
        goto Cleanup;
    }

    _fStyleProp = _pObject->InStyle();
    if (_fStyleProp)
    {
        _fStyleSet = TRUE;
    }

    // Quickly ignore the case where the expression and language are the same
    if ((_tcscmp(szExpression, _sExpression) == 0) && (_tcscmp(szLanguage, _sLanguage) == 0))
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = clearExpressionHelper();
    if (hr)
        goto Cleanup;

    hr = THR(_sExpression.Set(szExpression));
    if (hr)
        goto Cleanup;

    hr = THR(_sLanguage.Set(szLanguage));
    if (hr)
        goto Cleanup;

    hr = THR(GetHost()->CompileExpression(_pObject->GetUnknown(), _dispid, _sExpression, _sLanguage, &_pdispExpression, &_pdispThis));
    if (hr == S_OK)
    {
        hr = THR(_pdispExpression->QueryInterface(IID_IDispatchEx, (LPVOID *)&pDEXExpression));
        if (hr == E_NOINTERFACE)
        {
            ClearInterface(&_pdispThis);
        }
        else if (hr)
            goto Cleanup;
        else
        {
            ClearInterface(&_pdispExpression);
            _pDEXExpression = pDEXExpression;
        }
    }

    hr = THR(ParseExpressionDependencies());
    if (hr)
        goto Cleanup;

    _fDirtyDeps = TRUE;

    hr = THR(GetEngine()->AddDependencyUpdateRequest(this));
    if (hr)
        goto Cleanup;

    if (IsAlias())
        _pPropertyCanonical->_pPropertyExpression = this;
    else
        _pPropertyExpression = this;

Cleanup:
    if (hr)
        IGNORE_HR(clearExpressionHelper());
    RRETURN(hr);
}

HRESULT
CRecalcProperty::GetExpression(BSTR *pstrExpression, BSTR *pstrLanguage)
{
    Assert(!_fSetDirty);
    Assert(!_fSetValue);
    Assert(!_fInEval);

    HRESULT hr;

    if (_sExpression.IsNull())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(_sExpression.AllocBSTR(pstrExpression));
    if (hr)
        goto Cleanup;

    hr = THR(_sLanguage.AllocBSTR(pstrLanguage));
    if (hr)
    {
        SysFreeString(*pstrExpression);
        *pstrExpression = 0;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::ParseExpressionDependencies
//
// Description: Extract out identifiers from an expression.  Cool stuff.
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::ParseExpressionDependencies()
{
    SOURCE_TEXT_ATTR *pAttr = NULL, *pA;
    WCHAR *pch = 0;
    WCHAR *pchEnd = 0;
    HRESULT hr;
#ifndef RECALC_USE_SCRIPTDEBUG
    IActiveScriptAuthor *pScriptAuthor = 0;
#endif

    TraceTag((tagRecalcInfo, "ParseExpressionDependencies %08x (%d) \"%ls\"", this, _serialNumber, (LPOLESTR)_sExpression));
    if (_sExpression.Length() == 0)
        return S_OK;

    hr = THR(_sExpressionNames.Set(_sExpression));
    if (hr)
        goto Cleanup;

    pAttr = new SOURCE_TEXT_ATTR[_sExpressionNames.Length()];
    if (!pAttr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#ifndef RECALC_USE_SCRIPTDEBUG
    hr = THR(GetEngine()->GetScriptAuthor(_sLanguage, &pScriptAuthor));
    if (hr)
        goto Cleanup;

    hr = THR(pScriptAuthor->GetScriptTextAttributes(_sExpressionNames, _sExpressionNames.Length(), NULL, GETATTRTYPE_DEPSCAN, pAttr));
    if (hr)
        goto Cleanup;

#else
    hr = THR(GetHost()->GetScriptTextAttributes(_sLanguage, _sExpressionNames, _sExpressionNames.Length(), NULL, GETATTRTYPE_DEPSCAN | GETATTRFLAG_THIS, pAttr));
    if (hr)
        goto Cleanup;
#endif

    //
    // Start finding identifiers.  Only simple names (no array refs) are allowed
    //
    pch = _sExpressionNames;
    pchEnd = pch + _sExpressionNames.Length();
    pA = pAttr;
    while (pch < pchEnd)
    {
        if ((*pA == SOURCETEXT_ATTR_IDENTIFIER) || (*pA == SOURCETEXT_ATTR_THIS))
        {
            WCHAR *pchBegin = pch;

            while (pch < pchEnd && (*pA == SOURCETEXT_ATTR_IDENTIFIER || *pA == SOURCETEXT_ATTR_THIS || *pA == SOURCETEXT_ATTR_MEMBERLOOKUP))
            {
                if (*pA == SOURCETEXT_ATTR_MEMBERLOOKUP)
                    *pch = _T('.');
                pch++;
                pA++;
            }

            *pch = 0;

            TraceTag((tagRecalcDetail, "Got identifier: \"%ls\"", pchBegin));
            hr = THR(_dependencyNames.Append(pchBegin));
            if (hr)
                goto Cleanup;
        }
        pch++;
        pA++;
    }
Cleanup:
    if (pAttr)
        delete [] pAttr;
    return hr;
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::UpdateDependencies
//
// Description: We've got a bunch of identifiers, resolve them to
//              actual object/dispid pairs and then setup the
//              dependencies.
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::UpdateDependencies()
{
    IDispatch *pDispatch = 0;
    DISPID dispid;
    HRESULT hr = S_OK;
    int i;
    LPOLESTR *psz;

    _fUnresolved = FALSE;

    Assert(_fDirtyDeps);
    _fDirtyDeps = FALSE;

    for (i = _dependencyNames.Size() , psz = _dependencyNames ; i > 0 ; i-- , psz++)
    {
        hr = THR(GetHost()->ResolveNames(_pdispThis ? _pdispThis : _pObject->GetUnknown(), _dispid, 1, psz, &pDispatch, &dispid));
        if (!hr)
        {
            hr = THR(AddDependency(pDispatch, dispid));

            ClearInterface(&pDispatch);

            if (hr)
                goto Cleanup;
        }
        else
        {
            _fUnresolved = TRUE;
            hr = S_OK;
            // Silently swallow the error
        }
    }

    _fCircular = FALSE;

    SetDirty(TRUE);
    if (_fCircular)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::SetValue
//
// Description: Stuff a value into a property without blowing the
//              expression away.
//
//---------------------------------------------------------------
HRESULT
CRecalcProperty::SetValue(VARIANT *pv, BOOL fForce)
{
    Assert(pv);
    Assert(_fSetValue == FALSE);

    HRESULT hr = S_OK;

    if (fForce || !IsVariantEqual(&_vCurrent, pv))
    {
        _fSetValue = TRUE;

#if DBG == 1
        _cChanged = 0;
#endif

        hr = THR(GetHost()->SetValue(_pObject->GetUnknown(), _dispid, pv, _fStyleProp));
        Assert(_fSetValue);
        _fSetValue = FALSE;

        if (hr)
            goto Cleanup;

#if DBG == 1
        if (_cChanged != 1)
            TraceTag((tagRecalcDetail, "\n\n!!!!!!!!!!     Received %d change notifications after put\n\n", _cChanged));
        _cChanged = 0;
#endif

        hr = THR(VariantCopy(&_vCurrent, pv));
        if (hr)
        {
            VariantClear(&_vCurrent);
            goto Cleanup;
        }
    }

Cleanup:
    Assert(_fSetValue == FALSE);
    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::CheckAndClearStyleSet
//
// Description: Checks to see if the styleSet bit has been set
//              Clears after the check
//
//---------------------------------------------------------------
BOOL
CRecalcProperty::CheckAndClearStyleSet()
{
    BOOL fStyleSet = _fStyleSet;
    _fStyleSet = FALSE;
    return fStyleSet;
}


//---------------------------------------------------
//
// Function:        GetCanonicalProperty
//
// Description:     Helper function to get the canonical
//                  property from a particular punk/dispid.
//                  Does "all" the work of QI'ing and so forth
//
//---------------------------------------------------
HRESULT
GetCanonicalProperty(IUnknown *pUnk, DISPID dispid, IUnknown **ppUnkCanonical, DISPID *pdispidCanonical)
{
    HRESULT hr;
    IRecalcProperty *pRecalcProperty;


    hr = pUnk->QueryInterface(IID_IRecalcProperty, (LPVOID *)&pRecalcProperty);
    if (hr == E_NOINTERFACE)
    {
        *ppUnkCanonical = 0;
        *pdispidCanonical = DISPID_UNKNOWN;
        hr = S_FALSE;
    }
    else if (SUCCEEDED(hr))
    {
        hr = THR(pRecalcProperty->GetCanonicalProperty(dispid, ppUnkCanonical, pdispidCanonical));
        pRecalcProperty->Release();
    }

    RRETURN1(hr, S_FALSE);
}

#if DBG == 1
//---------------------------------------------------------------
//
// Function:    int CRecalcEngine::
//
// Description: Debug dump
//
//---------------------------------------------------------------

void RecalcDumpVariant(LPOLESTR szName, VARIANT *pv)
{
    CVariant v;

    v.CoerceVariantArg(pv, VT_BSTR);

    if (V_VT(&v) == VT_ERROR)
        RecalcDumpFormat(_T("<0s>=[error]"), szName);
    else if (V_VT(&v) == VT_EMPTY)
        RecalcDumpFormat(_T("<0s>=[null]"), szName);
    else if (V_VT(&v) == VT_BSTR)
        RecalcDumpFormat(_T("<0s>=<1s> "), szName, V_BSTR(&v));
    else
        RecalcDumpFormat(_T("<0s>=[???] "), szName);
}

HANDLE g_hfileRecalcDump = INVALID_HANDLE_VALUE;

BOOL RecalcDumpOpen()
{
    if (g_hfileRecalcDump == INVALID_HANDLE_VALUE)
    {
        g_hfileRecalcDump = CreateFile(_T("c:\\recalcdump.htm"),
                                            GENERIC_WRITE | GENERIC_READ,
                                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                                            NULL,
                                            OPEN_ALWAYS,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL);

        if (g_hfileRecalcDump == INVALID_HANDLE_VALUE)
            return FALSE;

        DWORD dwSize = GetFileSize(g_hfileRecalcDump, 0);

        if (dwSize == 0)
            r_p(_T("<html><head><link rel=stylesheet type=text/css href=recalcdump.css></head>\n"));
        else
            SetFilePointer( g_hfileRecalcDump, GetFileSize( g_hfileRecalcDump, 0 ), 0, 0 );
    }

    return TRUE;
}

void __cdecl RecalcDumpFormat(LPOLESTR szFormat, ...)
{
    va_list arg;

    va_start(arg, szFormat);

    WriteHelpV(g_hfileRecalcDump, szFormat, &arg);
}

int CRecalcEngine::Dump(DWORD dwFlags)
{
    int i;

    r_pf((_T("\t<<div id=e<0d>>Recalc Engine\n"), _serialNumber));
    r_p(_T("\t\t<div class=recalcmembers>"));
    r_pb(_fInRecalc);
    r_pb(_fRecalcRequested);
    r_pb(_fInDeps);
    r_p(_T(">\n"));

    for (i = 0 ; i < _objects.Size() ; i++)
    {
        _objects[i]->Dump(dwFlags);
    }

    r_p(_T("</div></BODY></HTML>\n"));

    return 0;
}

//---------------------------------------------------------------
//
// Function:    CRecalcObject::
//
// Description: Dump interesting stuff for debugging
//
//---------------------------------------------------------------
int
CRecalcObject::Dump(DWORD dwFlags)
{
    int i;

    r_pf((_T("\t\t<<div class=recalcobject id=o<0d>>Object o<0d> <1s>\n "), _serialNumber, _bstrID));
    r_p(_T("\t\t\t<div class=recalcmembers>Members"));
    r_p(_T("\t\t\t\t<div class=recalcvalues>"));
    r_ps(_bstrID);
    r_ps(_bstrTag);
    r_pb(_fGotSink);
    r_pb(_fDoingStyle);
    r_pb(_fInRecalc);
    r_p(_T("</div>\n"));
    r_p(_T("\t\t\t</div>\n"));

    for (i = 0 ; i < _properties.Size() ; i++)
    {
        _properties[i]->Dump(dwFlags);
    }
    r_p(_T("</div>"));
    return 0;
}

//---------------------------------------------------------------
//
// Function:    CRecalcProperty::TraceDump
//
// Description: Dump stuff
//
//---------------------------------------------------------------
int CRecalcProperty::Dump(DWORD dwFlags)
{
    r_pf((_T("\t\t\t<<div class=recalcproperty id=p<0d>>Property p<0d> <1s>.<2s>"), _serialNumber, _pObject->GetID(), _bstrName));
    r_p(_T("\t\t\t\t<div class=recalcmembers>Members\n"));
    r_p(_T("\t\t\t\t\t<div class=recalcvalues>"));

    r_ps(_bstrName);
    r_pn(_dispid);

    r_pb(_fDirty);
    r_pb(_fInEval);
    r_pb(_fSetValue);
    r_pb(_fCircular);
    r_pb(_fSetDirty);
    r_pb(_fStyleSet);
    r_pb(_fAlias);

    if (!_sExpression.IsNull())
    {
        r_ps(_sExpression);
        r_pv(&_vCurrent);
        r_ps(_sLanguage);
    }

    if (IsAlias())
    {
        r_pf((_T("canonical=p<0d> "), _pPropertyCanonical->_serialNumber));
    }
    else if (_pPropertyExpression)
    {
        r_pf((_T("aliasexp=p<0d> "), _pPropertyExpression->_serialNumber));
    }
    r_p(_T("\t\t\t\t\t</div>\n"));
    r_p(_T("\t\t\t\t</div>\n"));

    int i;

    if (_dependencyNames.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcdependencies>DependencyNames: <0d>\n"), _dependencyNames.Size()));

        for (i = 0 ; i < _dependencyNames.Size() ; i++)
            r_pf((_T("\t\t\t\t<<span class=recalcdependencyName><0s><</span><<br>\n"), (LPOLESTR)_dependencyNames[i]));

        r_p(_T("\t\t\t\t</div>\n"));
    }

    if (_dependencies.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcdependencies>Dependencies: <0d>\n"), _dependencies.Size()));

        for (i = 0 ; i < _dependencies.Size() ; i++)
            r_pf((_T("\t\t\t\t\t<<a class=recalcdependency href=#p'<0d>'>p<0d><</a><<br>\n"), (LPOLESTR)UIntToPtr(_dependencies[i]->_serialNumber)));

        r_p(_T("\t\t\t\t</div>\n"));
    }

    if (_dependents.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcdependents>Dependents: <0d>\n"), _dependents.Size()));

        for (i = 0 ; i < _dependents.Size() ; i++)
            r_pf((_T("\t\t\t\t\t<<a class=recalcdependent href=#p'<0d>'>p<0d><</a><<br>\n"), (LPOLESTR)UIntToPtr(_dependents[i]->_serialNumber)));
        r_p(_T("\t\t\t\t</div>\n"));
    }

    if (_aliases.Size())
    {
        r_pf((_T("\t\t\t\t<<div class=recalcaliases>Aliases: <0d>\n"), _aliases.Size()));

        for (i = 0 ; i < _aliases.Size() ; i++)
            r_pf((_T("\t\t\t\t\t<<a class=recalcalias href=#p'<0d>'>p<0d><</a><<br>\n"), (LPOLESTR)UIntToPtr(_aliases[i]->_serialNumber)));

        r_p(_T("\t\t\t\t</div>\n"));
    }

    r_p(_T("</div>\n"));
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\view\focus.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Adorner.HXX
//
// Contents:    Implementation of CAdorner class
//
//  An Adorner provides the addition of  'non-content-based' nodes in the display tree
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef _X_FOCUS_HXX_
#define _X_FOCUS_HXX_
#include "focus.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifdef FOCUS_BEHAVIOR

MtDefine(CFocusBehavior,  Layout, "CFocusBehavior")

STDMETHODIMP
CFocusBehavior::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementBehavior *)this, IUnknown);
    QI_INHERITS(this, IElementBehavior);
    QI_INHERITS(this, IHTMLPainter);
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        return E_NOINTERFACE;
}

CFocusBehavior::~CFocusBehavior()
{
    if (_pElement)
        SetElement(NULL, 0);

    Assert(_pView->_pFocusBehavior == NULL);

    ClearInterface(&_pBehaviorSite);
    ClearInterface(&_pPaintSite);

    delete _pShape;
    return pElement;
}

STDMETHODIMP
CFocusBehavior::GetPainterInfo(HTML_PAINTER_INFO *pInfo)
{
    pInfo->lFlags = HTMLPAINTER_TRANSPARENT | HTMLPAINTER_HITTEST | HTMLPAINTER_NOSAVEDC;
    pInfo->lZOrder = HTMLPAINT_ZORDER_ABOVE_FLOW;
    SetRect(&pInfo->rcExpand, 0, 0, 0, 0);
    pInfo->iidDrawObject = NULL;

    return S_OK;
}

void
CFocusBehavior::UpdateShape()
{
    // TODO (michaelw) This code was copied from adorneres and doesn't have a hope of actually working
    // Close but no cigar.  This code assumes that we can actually have a rendering behavior on an element
    // that doesn't have a layout.  Ha ha ha ha!
    Assert( _pElement );

    delete _pShape;

    _fDirtyShape = FALSE;

    CDoc *      pDoc = _pView->Doc();
    CDocInfo    dci(pDoc->_dciRender);

    if (    (_pElement->HasMarkupPtr() && _pElement->GetMarkup()->IsMarkupTrusted())
        &&  (   (_pElement->_etag == ETAG_SPAN && DYNCAST(CSpanElement, _pElement)->GetAAnofocusrect())
             || (_pElement->_etag == ETAG_DIV && DYNCAST(CDivElement, _pElement)->GetAAnofocusrect())))
    {
        _pShape = NULL;
    }
    else
    {
        _pElement->GetFocusShape( _iDivision, &dci, &_pShape );

        // Shapes come back in COORDSYS_FLOWCONTENT whilst the behavior is in COORDSYS_CONTENT
        // We need to get the offset and convert

        if (_pShape)
        {
            CLayout *pLayout = _pElement->GetUpdatedLayout();

            Assert(pLayout);

            RECT rcContent;
            RECT rcFlow;

            pLayout->GetClientRect(&rcFlow, COORDSYS_FLOWCONTENT);
            pLayout->GetClientRect(&rcContent, COORDSYS_CONTENT);

            CSize size(_rcBounds.left + rcContent.left - rcFlow.left, _rcBounds.top + rcContent.top - rcFlow.top);

            _pShape->OffsetShape(size);
        }
    }
}

STDMETHODIMP
CFocusBehavior::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    if (_rcBounds != rcBounds)
    {
        _rcBounds = rcBounds;
        UpdateShape();
    }
    else if (_fDirtyShape)
            UpdateShape();

    if (_pShape)
    {
        // TODO (michaelw) This should change to the xhdc passed in via the pvDrawObject (sambent needs to do this)
        XHDC xhdc(hdc, NULL);
        _pShape->Draw(xhdc, 1);
    }

    return S_OK;
}

void
CFocusBehavior::SetElement(CElement *pElement, long iDivision)
{
    if (_pElement)
    {
        if (_pPaintSite)
            _pPaintSite->InvalidateRect(NULL);

        VARIANT_BOOL fResultDontCare;
        _pElement->removeBehavior(_lCookie, &fResultDontCare);
        _lCookie = 0;   // For sambent
        _pElement = 0;
    }

    if (pElement)
    {
        Assert( _pView->IsInState(CView::VS_OPEN) );
        Assert( pElement );
        Assert( pElement->IsInMarkup() );

        if (pElement->HasMasterPtr())
        {
            pElement = pElement->GetMasterPtr();
        }

        // If this element is a checkbox or a radio button, use the associated
        // label element if one exists for drawing the focus shape.
        else if (   pElement->Tag() == ETAG_INPUT
                 && DYNCAST(CInput, pElement)->IsOptionButton())
        {
            CLabelElement * pLabel = pElement->GetLabel();
            if (pLabel)
            {
                pElement = pLabel;
            }
        }

        VARIANT v;

        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = (IUnknown *)(IElementBehavior *)this;

        HRESULT hr = pElement->addBehavior(L"", &v, &_lCookie);

        if (!hr)
        {
            _pElement = pElement;
            _iDivision = iDivision;
            ShapeChanged();
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\xmlns.cxx ===
//+---------------------------------------------------------------------
//
//  File:       xmlns.cxx
//
//  Classes:    CXmlNamespaceTable, CXmlUrnAtomTable
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(XML,                                  Mem,                "XML");
MtDefine(CXmlNamespaceTable,                   XML,                "CXmlNamespaceTable");
MtDefine(CXmlUrnAtomTable,                     XML,                "CXmlUrnAtomTable");

MtDefine(CXmlNamespaceTable_CItemsArray,       CXmlNamespaceTable, "CXmlNamespaceTable::CItemsArray");

EXTERN_C const GUID SID_SXmlNamespaceMapping;
EXTERN_C const GUID CGID_XmlNamespaceMapping;
#define XMLNAMESPACEMAPPING_GETURN 1

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CXmlNamespaceTable::CItem
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::CItem::Clear
//
//-------------------------------------------------------------------------

void
CXmlNamespaceTable::CItem::Clear()
{
    _cstr.Free();
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CXmlNamespaceTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable constructor
//
//-------------------------------------------------------------------------

CXmlNamespaceTable::CXmlNamespaceTable (CDoc * pDoc)
{
    _ulRefs = 1;
    _pDoc = pDoc;
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable destructor
//
//-------------------------------------------------------------------------

CXmlNamespaceTable::~CXmlNamespaceTable ()
{
    int     c;
    CItem * pItem;

    for (pItem = _aryItems, c = _aryItems.Size(); 0 < c; pItem++, c--)
    {
        pItem->Clear();
    }
    _aryItems.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::QueryInterface(REFIID iid, void** ppv)
{
    if (!ppv)
        RRETURN(E_POINTER);

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IOleCommandTarget)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::Init
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::Init()
{
    HRESULT     hr;

    hr = THR(RegisterNamespace(COMPONENT_NAMESPACE, COMPONENT_URN, XMLNAMESPACETYPE_ATTR));
    if (hr)
        goto Cleanup;

    _urnAtomComponent = 0;

#if DBG == 1
    LPTSTR pchUrnComponent;
    Assert (_pDoc->_pXmlUrnAtomTable);
    Assert (S_OK == THR(_pDoc->_pXmlUrnAtomTable->GetUrn(_urnAtomComponent, &pchUrnComponent)));
    Assert (0 == StrCmp(COMPONENT_URN, pchUrnComponent));
#endif

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::FindItem
//
//-------------------------------------------------------------------------

CXmlNamespaceTable::CItem *
CXmlNamespaceTable::FindItem(LPTSTR pch)
{
    int         c;
    CItem *     pItem;

    // check cached value
    if (_pLastItem)
    {
        if (0 == StrCmpIC(_pLastItem->_cstr, pch))
            return _pLastItem;
    }

    // do the search
    for (pItem = _aryItems, c = _aryItems.Size(); 0 < c; pItem++, c--)
    {
        Assert (!pItem->_cstr.IsNull());
        if (pItem != _pLastItem && 0 == StrCmpIC(pItem->_cstr, pch))
        {
            // succeeded
            _pLastItem = pItem;
            return pItem;
        }
    }

    // failed
    _pLastItem = NULL;
    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::EnsureItem
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::EnsureItem(LPTSTR pch, CItem ** ppItem, BOOL * pfNew)
{
    HRESULT     hr = S_OK;

    (*ppItem) = FindItem(pch);

    if (!(*ppItem))
    {
        (*ppItem) = _aryItems.Append();
        if (!(*ppItem))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        (*ppItem)->_atom = -1;
        (*ppItem)->_type = XMLNAMESPACETYPE_NULL;

        hr = THR((*ppItem)->_cstr.Set(pch));
        if (hr)
            goto Cleanup;

        if (pfNew)
        {
            *pfNew = TRUE;
        }
    }
    else
    {
        if (pfNew)
        {
            *pfNew = FALSE;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::RegisterNamespace
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::RegisterNamespace(
    LPTSTR pchNamespace, LPTSTR pchUrn, XMLNAMESPACETYPE namespaceType, BOOL * pfChangeDetected)
{
    HRESULT             hr;
    CItem *             pItem;
    CXmlUrnAtomTable *  pUrnAtomTable;

    //
    // startup
    //

    Assert (pchNamespace && pchNamespace[0]);   // namespace should be present and non-empty

    if (pchUrn && 0 == pchUrn[0])               // don't allow empty urns
        pchUrn = NULL;

    //
    // ensure table and item in the table
    //

    hr = THR(_pDoc->EnsureXmlUrnAtomTable(&pUrnAtomTable));
    if (hr)
        goto Cleanup;

    hr = THR(EnsureItem(pchNamespace, &pItem, /* pfNew = */pfChangeDetected));
    if (hr)
        goto Cleanup;

    pItem->_type = namespaceType;

    //
    // setup urn
    //

    if (pchUrn)
    {
        LPTSTR  pchCurrentUrn;

        if (-1 != pItem->_atom)         // if currently the namespace maps to a urn
        {
            hr = THR(pUrnAtomTable->GetUrn(pItem->_atom, &pchCurrentUrn));
            if (hr)
                goto Cleanup;

            if (0 == StrCmpIC(pchUrn, pchCurrentUrn))   // if the urn this namespace currently maps to is the same as requested
                goto Cleanup;                           // done - nothing more todo
        }

        // Assert (pchUrn is different from urn specified in pItem);

        hr = THR(pUrnAtomTable->EnsureUrnAtom(pchUrn, &pItem->_atom));
        if (hr)
            goto Cleanup;

        if (pfChangeDetected)
        {
            *pfChangeDetected = TRUE;
        }
    }


Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::IsXmlSprinkle
//
//-------------------------------------------------------------------------

ELEMENT_TAG
CXmlNamespaceTable::IsXmlSprinkle (LPTSTR pchNamespace)
{
    CItem * pItem = FindItem(pchNamespace);

    if (pItem)
    {
        if (pItem->_atom == _urnAtomComponent)
        {
            return ETAG_GENERIC_BUILTIN;
        }
        else
        {
            return ETAG_GENERIC;
        }
    }

    return ETAG_UNKNOWN;
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::GetUrnAtom
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::GetUrnAtom(LPTSTR pchNamespace, LONG * pAtom)
{
    CItem *     pItem = FindItem(pchNamespace);

    Assert (pAtom);

    *pAtom = pItem ? pItem->_atom : -1;

    RRETURN (S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::GetUrn
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::GetUrn(LONG urnAtom, LPTSTR * ppchUrn)
{
    HRESULT     hr = S_OK;

    Assert (ppchUrn);

    if (-1 != urnAtom)
    {
        Assert (_pDoc->_pXmlUrnAtomTable);      // should have been ensured when we stored urnAtom

        hr = THR(_pDoc->_pXmlUrnAtomTable->GetUrn(urnAtom, ppchUrn));
    }
    else
    {
        *ppchUrn = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::GetUrn
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::GetUrn(LPTSTR pchNamespace, LPTSTR * ppchUrn)
{
    HRESULT     hr;
    LONG        urnAtom;

    hr = GetUrnAtom(pchNamespace, &urnAtom);
    if (hr)
        goto Cleanup;

    hr = THR(GetUrn(urnAtom, ppchUrn));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::SaveNamespaceAttrs
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::SaveNamespaceAttrs (CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT     hr = S_OK;
    int         c;
    CItem *     pItem;
    LPTSTR      pchUrn;

    for (pItem = _aryItems, c = _aryItems.Size(); 0 < c; pItem++, c--)
    {
        if (XMLNAMESPACETYPE_ATTR == pItem->_type)
        {
            if (_urnAtomComponent == pItem->_atom &&
                0 == StrCmpIC(COMPONENT_NAMESPACE, pItem->_cstr))
                continue;

            if (-1 != pItem->_atom)
            {
                Assert (_pDoc->_pXmlUrnAtomTable);

                hr = THR(_pDoc->_pXmlUrnAtomTable->GetUrn (pItem->_atom, &pchUrn));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                pchUrn = NULL;
            }

            hr = THR(pStreamWriteBuff->EnsurePIsSaved(
                _pDoc, NULL, pItem->_cstr, pchUrn, NULL, XMLNAMESPACEDECL_STD));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlNamespaceTable::Exec
//
//-------------------------------------------------------------------------

HRESULT
CXmlNamespaceTable::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANT *       pvarArgIn,
    VARIANT *       pvarArgOut)
{
    HRESULT     hr;

    if (!pguidCmdGroup)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsEqualGUID(CGID_XmlNamespaceMapping, *pguidCmdGroup))
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case XMLNAMESPACEMAPPING_GETURN:

            if (!pvarArgOut ||                                              // if no out arg or
                !pvarArgIn ||                                               // no in arg or
                VT_BSTR != V_VT(pvarArgIn) ||                               // in arg is not a string or
                !V_BSTR(pvarArgIn) || 0 == ((LPTSTR)V_BSTR(pvarArgIn))[0])  // the string is empty
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            {
                LPTSTR  pchUrn;

                hr = THR(GetUrn(V_BSTR(pvarArgIn), &pchUrn));
                if (hr)
                    goto Cleanup;

                V_VT  (pvarArgOut) = VT_BSTR;
                if (pchUrn)
                {
                    hr = THR(FormsAllocString(pchUrn, &V_BSTR(pvarArgOut)));
                }
                else
                {
                    V_BSTR(pvarArgOut) = NULL;
                    hr = S_OK;
                }
            }

            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CXmlUrnAtomTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CXmlUrnAtomTable constructor
//
//-------------------------------------------------------------------------

CXmlUrnAtomTable::CXmlUrnAtomTable ()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlUrnAtomTable destructor
//
//-------------------------------------------------------------------------

CXmlUrnAtomTable::~CXmlUrnAtomTable ()
{
    Free();
}

//+------------------------------------------------------------------------
//
//  Member:     CXmlUrnAtomTable::EnsureUrnAtom
//
//-------------------------------------------------------------------------

HRESULT
CXmlUrnAtomTable::EnsureUrnAtom(LPTSTR pchUrn, LONG * pAtom)
{
    HRESULT     hr;

    Assert (pAtom);

    hr = THR(AddNameToAtomTable(pchUrn, pAtom));

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\view\adorner.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Adorner.HXX
//
// Contents:    Implementation of CAdorner class
//
//  An Adorner provides the addition of  'non-content-based' nodes in the display tree
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef _X_ADORNER_HXX_
#define _X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

DeclareTagOther(tagAdornerShow,    "AdornerShow",    "Fill adorners with a hatched brush")
DeclareTag(tagFocusAdornerChange, "AdornerChange", "Trace focus adorner changes")

MtDefine(CElementAdorner, Layout, "CElementAdorner")
MtDefine(CFocusAdorner,   Layout, "CFocusAdorner")

const int GRAB_INSET = 4;

//+====================================================================================
//
//  Member:     CAdorner, ~CAdorner
//
//  Synopsis:   Constructor/desctructor for CAdorner
//
//  Arguments:  pView    - Associated CView
//              pElement - Associated CElement
//
//------------------------------------------------------------------------------------

CAdorner::CAdorner( CView * pView, CElement * pElement )
{
    Assert( pView );

    _cRefs     = 1;
    _pView     = pView;
    _pDispNode = NULL;
    _pElement  = pElement && pElement->HasMasterPtr()
                    ? pElement->GetMasterPtr()
                    : pElement;

    Assert( !_pElement
        ||  _pElement->IsInMarkup() );
}

CAdorner::~CAdorner()
{
    Assert( !_cRefs );
    DestroyDispNode();
}


//+====================================================================================
//
// Method:EnsureDispNode
//
// Synopsis: Creates a display leaf node suitable for 'Adornment'
//
//------------------------------------------------------------------------------------

VOID
CAdorner::EnsureDispNode()
{
    Assert( _pElement );
    Assert( _pView );
    Assert( _pView->IsInState(CView::VS_OPEN) );

    CTreeNode* pTreeNode = _pElement->GetFirstBranch();

    if ( !_pDispNode && pTreeNode)
    {
        _pDispNode = (CDispNode *)CDispLeafNode::New(this, DISPEX_EXTRACOOKIE | DISPEX_USERTRANSFORM);

        if ( _pDispNode )
        {
            _pDispNode->SetExtraCookie( GetDispCookie() );
            _pDispNode->SetLayerType( GetDispLayer() );
            _pDispNode->SetOwned(TRUE);
        }
    }

    if (    _pDispNode
        &&  !_pDispNode->HasParent() )
    {
        CNotification   nf;

        nf.ElementAddAdorner( _pElement );
        nf.SetData((void *)this);

        _pElement->SendNotification( &nf );
    }
}


//+====================================================================================
//
// Method:GetBounds
//
// Synopsis: Return the bounds of the adorner in global coordinates
//
//------------------------------------------------------------------------------------

void
CAdorner::GetBounds(
    CRect * prc) const
{
    Assert( prc );

    if ( _pDispNode )
    {
        _pDispNode->GetClientRect( prc, CLIENTRECT_CONTENT );
        _pDispNode->TransformRect( *prc, COORDSYS_FLOWCONTENT, prc, COORDSYS_GLOBAL );
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+====================================================================================
//
// Method:  GetRange
//
// Synopsis: Retrieve the cp range associated with an adorner
//
//------------------------------------------------------------------------------------

void
CAdorner::GetRange(
    long *  pcpStart,
    long *  pcpEnd) const
{
    Assert( pcpStart );
    Assert( pcpEnd );

    if ( _pElement && _pElement->GetFirstBranch() )
    {
        long    cch;

        _pElement->GetRange( pcpStart, &cch );

        *pcpEnd = *pcpStart + cch;
    }
    else
    {
        *pcpStart =
        *pcpEnd   = 0;
    }
}


//+====================================================================================
//
// Method:  All CDispClient overrides
//
//------------------------------------------------------------------------------------

void
CAdorner::GetOwner(
    CDispNode const* pDispNode,
    void ** ppv)
{
    Assert(pDispNode);
    Assert(ppv);
    *ppv = NULL;
}

void
CAdorner::DrawClient(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         cookie,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

void
CAdorner::DrawClientBackground(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

void
CAdorner::DrawClientBorder(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

void
CAdorner::DrawClientScrollbar(
    int whichScrollbar,
    const RECT* prcBounds,
    const RECT* prcRedraw,
    LONG contentSize,
    LONG containerSize,
    LONG scrollAmount,
    CDispSurface *pSurface,
    CDispNode *pDispNode,
    void *pClientData,
    DWORD dwFlags)
{
    AssertSz(0, "Unexpected/Unimplemented method called in CAdorner");
}

void
CAdorner::DrawClientScrollbarFiller(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

BOOL
CAdorner::HitTestContent(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData,
    BOOL fDeclinedByPeer)
{
    return FALSE;
}

BOOL
CAdorner::HitTestFuzzy(
    const POINT *pptHitInBoxCoords,
    CDispNode *pDispNode,
    void *pClientData)
{
    return FALSE;
}

BOOL
CAdorner::HitTestScrollbar(
    int whichScrollbar,
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
    return FALSE;
}

BOOL
CAdorner::HitTestScrollbarFiller(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
    return FALSE;
}

BOOL
CAdorner::HitTestBorder(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
    return FALSE;
}

LONG
CAdorner::GetZOrderForSelf(CDispNode const* pDispNode)
{
    return 0;
}

LONG
CAdorner::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    Assert(pDispNode1);
    Assert(pDispNode2);
    Assert(pDispNode1 == _pDispNode);
    Assert(_pElement);

    //
    // Try to compare the 2 disp nodes - by asking the view
    //
    long result = _pView->CompareZOrder( pDispNode1, pDispNode2);
    if ( result != 0 )
        return result;

    //
    // TODO - comparison of elements is fairly meaningless 
    // Long term fix is to make Adorner Z-Index controllable by external interface
    // 
    
    CElement *  pElement = ::GetDispNodeElement(pDispNode2);

    //
    //  Compare element z-order
    //  If the same element is associated with both display nodes,
    //  then the second display node is probably the element itself
    //

    return _pElement != pElement
                ? _pElement->CompareZOrder(pElement)
                : 1;
}

void
CAdorner::HandleViewChange(
    DWORD flags,
    const RECT* prcClient,  // global coordinates
    const RECT* prcClip,    // global coordinates
    CDispNode* pDispNode)
{
    AssertSz(0, "Unexpected/Unimplemented method called in CAdorner");
}

BOOL
CAdorner::ProcessDisplayTreeTraversal(
                        void *pClientData)
{
    return TRUE;
}

void
CAdorner::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

DWORD
CAdorner::GetClientPainterInfo( CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    return 0;
}

void
CAdorner::DrawClientLayers(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    AssertSz(0, "CAdorner- unexpected and unimplemented method called");
}

#if DBG==1
void
CAdorner::DumpDebugInfo(
    HANDLE hFile,
    long level,
    long childNumber,
    CDispNode const* pDispNode,
    void* cookie)
{
    WriteHelp(hFile, _T("<<tag>Adorner on <0s><</tag>\r\n"),
            GetElement()
                ? GetElement()->TagName()
                : _T("Range"));
}
#endif

//+====================================================================================
//
//  Member:     DestroyDispNode
//
//  Synopsis:   Destroy the adorner display node (if any)
//
//------------------------------------------------------------------------------------

void
CAdorner::DestroyDispNode()
{
    if ( _pDispNode )
    {
        Assert( _pView );
        Assert( _pView->IsInState(CView::VS_OPEN) );    
        _pDispNode->Destroy();
        _pDispNode = NULL;
    }
}


#if DBG==1
//+====================================================================================
//
//  Member:     ShowRectangle
//
//  Synopsis:   Fill the adorner rectangle with a hatched brush
//
//  Arguments:  pDI - Pointer to CFormDrawInfo to use
//
//------------------------------------------------------------------------------------

void
CAdorner::ShowRectangle(
    CFormDrawInfo * pDI)
{
    static COLORREF s_aclr[] =  {
                                RGB( 255,   0,   0 ),
                                RGB(   0, 255,   0 ),
                                RGB( 255, 255,   0 ),
                                RGB(   0, 255, 255 ),
                                };

    if ( IsTagEnabled( tagAdornerShow ) )
    {
        XHDC    hdc    = pDI->GetDC();
        int     bkMode = ::SetBkMode( hdc, TRANSPARENT );
        HBRUSH  hbrPat = ::CreateHatchBrush( HS_DIAGCROSS, s_aclr[ (((ULONG)(ULONG_PTR)this) >> 8) & 0x00000003 ] );
        HBRUSH  hbrOld;

        hbrOld = (HBRUSH) SelectObject( hdc, hbrPat );
        ::PatBlt( hdc, pDI->_rc.left, pDI->_rc.top, pDI->_rc.Width(), pDI->_rc.Height(), PATCOPY );
        ::DeleteObject( ::SelectObject( hdc, hbrOld ) );
        ::SetBkMode( hdc, bkMode );
    }
}
#endif


//+====================================================================================
//
//  Member:     CElementAdorner, ~CElementAdorner
//
//  Synopsis:   Constructor/desctructor for CElementAdorner
//
//  Arguments:  pView    - Associated CView
//              pElement - Associated CElement
//
//------------------------------------------------------------------------------------

CElementAdorner::CElementAdorner( CView* pView, CElement* pElement )
    : CAdorner( pView, pElement )
{
    Assert( pView );
    Assert( pElement );
}

CElementAdorner::~CElementAdorner()
{
    SetSite( NULL );
}

//+====================================================================================
//
// Method: PositionChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CElementAdorner::PositionChanged( const CSize * psize )
{
    Assert( _pView->IsInState(CView::VS_OPEN) );

    if ( _pIElementAdorner )
    {
        if ( !psize )
        {
            HRESULT hr = S_OK;
            CPoint ptElemPos;
            POINT ptAdornerPos ;

            CLayout* pLayout = _pElement->GetUpdatedNearestLayout();
            Assert( pLayout );

            pLayout->GetPosition( &ptElemPos, COORDSYS_GLOBAL );

            hr = THR( _pIElementAdorner->GetPosition( (POINT*) & ptElemPos,  & ptAdornerPos ) );

            if ( ! hr )
            {
                EnsureDispNode();

                _pDispNode->TransformPoint(ptAdornerPos, COORDSYS_GLOBAL, &ptElemPos, COORDSYS_PARENT );
                _pDispNode->SetPosition( ptElemPos );
            }
        }
        else
        {
            if ( ! _pDispNode )
            {
                EnsureDispNode();
                Assert( _pDispNode );
            }
            
            CPoint  pt = _pDispNode->GetPosition();

            pt += *psize;

            _pDispNode->SetPosition( pt );
        }

        IGNORE_HR( _pIElementAdorner->OnPositionSet());        
    }
}

//+====================================================================================
//
// Method: ShapeChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CElementAdorner::ShapeChanged()
{
    Assert( _pView->IsInState(CView::VS_OPEN) );

    if ( _pIElementAdorner )
    {
        HRESULT hr = S_OK;

        CLayout* pLayout =  _pElement->GetUpdatedNearestLayout();
        Assert( pLayout );
        CSize elemSize;
        SIZE szAdorner ;

        pLayout->GetApparentSize( &elemSize );

        hr = THR( _pIElementAdorner->GetSize( (SIZE*) &elemSize, & szAdorner ));
        if ( ! hr )
        {
            elemSize.cx = szAdorner.cx;
            elemSize.cy = szAdorner.cy;

            EnsureDispNode();

            _pDispNode->SetSize( elemSize , NULL, TRUE );
        }
    }
}


//+====================================================================================
//
// Method: UpdateAdorner
//
// Synopsis: Brute-force way of updating an adorners position
//
//------------------------------------------------------------------------------------


void 
CElementAdorner::UpdateAdorner()
{
    CNotification   nf;
    long cpStart, cpEnd ;
    
    GetRange( & cpStart, & cpEnd );        
    nf.MeasuredRange(cpStart, cpEnd - cpStart);
    _pView->Notify(&nf); 
}

//+====================================================================================
//
// Method: ScrollIntoView
//
// Synopsis: Scroll the Adorner into view
//
//------------------------------------------------------------------------------------


void 
CElementAdorner::ScrollIntoView()
{
    if ( _pDispNode )
        _pDispNode->ScrollIntoView(SP_MINIMAL, SP_MINIMAL );
}


//+====================================================================================
//
// Method: Draw
//
// Synopsis: Wraps call to IElementAdorner.Draw - to allow adorner
//           to draw.
//
//------------------------------------------------------------------------------------

void
CElementAdorner::DrawClient(
            const RECT *   prcBounds,
            const RECT *   prcRedraw,
            CDispSurface * pDispSurface,
            CDispNode *    pDispNode,
            void *         cookie,
            void *         pClientData,
            DWORD          dwFlags)
{
    if ( _pIElementAdorner )
    {
        Assert(pClientData);

        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds( pDI, prcBounds, prcRedraw, pDispSurface );

        WHEN_DBG( ShowRectangle( pDI ) );

        // TODO (donmarsh) -- this is a temporary hack until MichaelW's checkin
        // implements adorners as behaviors, and this all just goes away.
        CSize sizeTranslate = g_Zero.size;  // keep compiler happy
        HDC hdc = 0;                        // keep compiler happy
        if (pDI->GetDC().GetTranslatedDC(&hdc, &sizeTranslate))
        {
            pDI->_rc.OffsetRect(sizeTranslate);
            IGNORE_HR( _pIElementAdorner->Draw(hdc, (RECT*) & pDI->_rc ));
        }
    }
}


static HTC
AdornerHTIToHTC ( ADORNER_HTI eAdornerHTC )
{
    HTC eHTC = HTC_NO;

    switch( eAdornerHTC )
    {

    case ADORNER_HTI_TOPBORDER :
        eHTC = HTC_TOPBORDER;
        break;

    case ADORNER_HTI_LEFTBORDER:
        eHTC = HTC_LEFTBORDER;
        break;

    case ADORNER_HTI_BOTTOMBORDER:
        eHTC = HTC_LEFTBORDER ;
        break;

    case ADORNER_HTI_RIGHTBORDER :
        eHTC = HTC_RIGHTBORDER;
        break;
        
    case ADORNER_HTI_TOPLEFTHANDLE:
        eHTC = HTC_TOPLEFTHANDLE;
        break;
            
    case ADORNER_HTI_LEFTHANDLE:
        eHTC = HTC_LEFTHANDLE       ;
        break;
    case ADORNER_HTI_TOPHANDLE:
        eHTC = HTC_TOPHANDLE ;
        break;
        
    case ADORNER_HTI_BOTTOMLEFTHANDLE:
        eHTC = HTC_BOTTOMLEFTHANDLE ;
        break;

    case ADORNER_HTI_TOPRIGHTHANDLE:
        eHTC = HTC_TOPRIGHTHANDLE   ;
        break;
        
    case ADORNER_HTI_BOTTOMHANDLE:
        eHTC = HTC_BOTTOMHANDLE ;
        break;
        
    case ADORNER_HTI_RIGHTHANDLE:
        eHTC = HTC_RIGHTHANDLE ;
        break;
        
    case ADORNER_HTI_BOTTOMRIGHTHANDLE:
        eHTC = HTC_BOTTOMRIGHTHANDLE ;
        break;

    }

    return eHTC;
}

//+====================================================================================
//
// Method: HitTestContent
//
// Synopsis: IDispClient - hit test point. Wraps call to IElementAdorner.HitTestPoint
//
//------------------------------------------------------------------------------------

BOOL
CElementAdorner::HitTestContent(
            const POINT *  pptHit,
            CDispNode *    pDispNode,
            void *         pClientData,
            BOOL           fDeclinedByPeer)
{
    BOOL fDidWeHitAdorner = FALSE;
    ADORNER_HTI eAdornerHTI = ADORNER_HTI_NONE;
    
    if (    _pIElementAdorner
        &&  _pElement->IsInMarkup() )
    {
        CRect myRect;
        HRESULT hr = S_OK;

        _pDispNode->GetClientRect( &myRect, CLIENTRECT_CONTENT );

        hr = THR( _pIElementAdorner->HitTestPoint(
                                                    const_cast<POINT*> (pptHit),
                                                    (RECT*) ( const_cast<CRect*> (&myRect)),
                                                    & fDidWeHitAdorner,
                                                    & eAdornerHTI ));
        if (  ( ! hr ) && ( fDidWeHitAdorner ))
        {
            //
            // If we hit the adorner, we fix the node of hit test info to
            // be that of the element we adorn.
            //
            CHitTestInfo *  phti = (CHitTestInfo *)pClientData;
            phti->_htc = AdornerHTIToHTC( eAdornerHTI );
            phti->_pNodeElement = _pElement->GetFirstBranch();
        }
    }

    return fDidWeHitAdorner;
}


//+====================================================================================
//
// Method: GetZOrderForSelf
//
// Synopsis: IDispClient - get z-order.
//
//------------------------------------------------------------------------------------

LONG
CElementAdorner::GetZOrderForSelf(CDispNode const* pDispNode)
{
    return LONG_MAX;
}

//+====================================================================================
//
//  Member:     CFocusAdorner, ~CFocusAdorner
//
//  Synopsis:   Constructor/desctructor for CFocusAdorner
//
//  Arguments:  pView    - Associated CView
//              pElement - Associated CElement
//
//------------------------------------------------------------------------------------

CFocusAdorner::CFocusAdorner( CView* pView )
    : CAdorner( pView )
{
    Assert( pView );
}

CFocusAdorner::~CFocusAdorner()
{
    delete _pShape;
}

//+====================================================================================
//
// Method:  EnsureDispNode
//
// Synopsis: Ensure the display node is created and properly inserted in the display tree
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::EnsureDispNode()
{
    Assert( _pElement );
    if (!_pView->IsInState(CView::VS_OPEN) )
    {
        _pView->OpenView();
    }

    if ( _pShape )
    {
        CTreeNode * pTreeNode = _pElement->GetFirstBranch();

        if ( !_pDispNode && pTreeNode)
        {
            _dnl = _pElement->GetFirstBranch()->IsPositionStatic()
                        ? DISPNODELAYER_FLOW
                        : _pElement->GetFirstBranch()->GetCascadedzIndex() >= 0
                                ? DISPNODELAYER_POSITIVEZ
                                : DISPNODELAYER_NEGATIVEZ;
            _adl = _dnl == DISPNODELAYER_FLOW
                        ? ADL_TOPOFFLOW
                        : ADL_ONELEMENT;
        }

        if (    !_pDispNode
            ||  !_pDispNode->HasParent() )
        {
            super::EnsureDispNode();

            if (_pDispNode)
            {
                _pDispNode->SetAffectsScrollBounds(FALSE);
            }
        }
    }

    else
    {
        DestroyDispNode();
    }
}


//+====================================================================================
//
// Method:  EnsureFocus
//
// Synopsis: Ensure focus display node exists and is properly inserted in the display tree
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::EnsureFocus()
{
    Assert( _pElement );
    if (    _pShape
        &&  (   !_pDispNode
            ||  !_pDispNode->HasParent() ) )
    {
        EnsureDispNode();
    }
}


//+====================================================================================
//
// Method:  SetElement
//
// Synopsis: Set the associated element
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::SetElement( CElement * pElement, long iDivision )
{
    Assert( _pView && _pView->IsInState(CView::VS_OPEN) );
    Assert( pElement );
    Assert( pElement->IsInMarkup() );

    if ( pElement->Tag() == ETAG_INPUT
            && DYNCAST(CInput, pElement)->GetType() == htmlInputFile)
    {
        // force shape change
        _pElement = NULL;
    }

    if (    pElement  != _pElement
        ||  iDivision != _iDivision)
    {
        _pElement  = pElement;
        _iDivision = iDivision;

        DestroyDispNode();
        ShapeChanged();
    }

}

//+====================================================================================
//
// Method: PositionChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::PositionChanged( const CSize * psize )
{
    Assert( _pElement );
    Assert( _pElement->GetFirstBranch() );
    Assert( _pView->IsInState(CView::VS_OPEN) );

    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_INDENT, "(CFocusAdorner::PositionChanged() - size(cx:%d cy:%d)", psize ? psize->cx : 0, psize ? psize->cy : 0 ));

    if ( _pDispNode )
    {
        CLayout *   pLayout     = _pElement->GetUpdatedNearestLayout();
        CTreeNode * pTreeNode   = _pElement->GetFirstBranch();
        BOOL        fRelative   = pTreeNode->GetCharFormat()->_fRelative;
        CDispNode * pDispParent = _pDispNode->GetParentNode();
        CDispNode * pDispNode   = NULL;

        Assert  ( _pShape );

        //
        //  Get the display node which contains the element with focus
        //  (If the focus display node is not yet anchored in the display tree, pretend the element
        //   is not correct as well. After the focus display node is anchored, this routine will
        //   get called again and can correctly associate the display nodes at that time.)
        //

        if ( pDispParent )
        {
// TODO: Move this logic down into GetElementDispNode (passing a flag so that GetElementDispNode
//         can distinguish between "find nearest" and "find exact" with this call being a "find nearest"
//         and virtually all others being a "find exact" (brendand)
            CElement *  pDisplayElement = NULL;

            if (    !pTreeNode->IsPositionStatic()
                ||  _pElement->ShouldHaveLayout() )
            {
                pDisplayElement = _pElement;
            }
            else if ( !fRelative )
            {
                pDisplayElement = pLayout->ElementOwner();
            }
            else
            {
                CTreeNode * pDisplayNode = pTreeNode->GetCurrentRelativeNode( pLayout->ElementOwner() );

                Assert( pDisplayNode );     // This should never be NULL, but be safe anyway
                if ( pDisplayNode )
                {
                    pDisplayElement = pDisplayNode->Element();
                }
            }

            Assert( pDisplayElement );      // This should never be NULL, but be safe anyway
            if ( pDisplayElement )
            {
                pDispNode = pLayout->GetElementDispNode( pDisplayElement );
            }
        }


        //
        //  Verify that the display node which contains the element with focus and the focus display node
        //  are both correctly anchored in the display tree (that is, have a common parent)
        //  (If they do not, this routine will get called again once both get correctly anchored
        //   after layout is completed)
        //

        if ( pDispNode )
        {
            CDispNode * pDispNodeTemp;

            for ( pDispNodeTemp = pDispNode;
                    pDispNodeTemp
                &&  pDispNodeTemp != pDispParent;
                pDispNodeTemp = pDispNodeTemp->GetParentNode() );

            if ( !pDispNodeTemp )
            {
                pDispNode = NULL;
            }

            Assert( !pDispNode
                ||  pDispNodeTemp == pDispParent );
        }

        if ( pDispNode )
        {
            if ( !_fTopLeftValid )
            {
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - _fTopLeftValid NOT valid (currently %d,%d)", _ptTopLeft.x, _ptTopLeft.y ));

                CRect   rc;
    
                _pShape->GetBoundingRect( &rc );
                _ptTopLeft = rc.TopLeft();
                _pShape->OffsetShape( -_ptTopLeft.AsSize() );

                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - offset shape by new topleft" ));
    
                if (    !_pElement->ShouldHaveLayout()
                    &&  fRelative )
                {
                    CPoint  ptOffset;
                    
                    _pElement->GetUpdatedParentLayout()->GetFlowPosition( pDispNode, &ptOffset );
                    _ptTopLeft -= ptOffset.AsSize();
                }
                
                _fTopLeftValid = TRUE;
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - _fTopLeftValid now valid (%d,%d)", _ptTopLeft.x, _ptTopLeft.y ));
            }

            Assert(pDispParent != NULL);
            
            // calculate user transform for adorner.  Get the total
            // transform for the adorned node, and multiply by the
            // inverse of the total transform for the adorner node.
            CDispTransform transform;
            CDispTransform transformAdorner;
            CSize sizeOffset = _ptTopLeft.AsSize();

            // psize is only valid if the element doesn't have layout (bug #105637)
            if ( psize && !_pElement->ShouldHaveLayout() )
            {
                sizeOffset += *psize;
                _ptTopLeft += *psize;
            }

            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - using _fTopLeftValid (%d,%d)", _ptTopLeft.x, _ptTopLeft.y ));

            pDispNode->GetNodeTransform(&transform, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
            pDispParent->GetNodeTransform(&transformAdorner, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);

#if DBG == 1
            if (transform.GetWorldTransform()->IsOffsetOnly())
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorned dispnode 0x%x, transform offset %d,%d", pDispNode, transform.GetWorldTransform()->GetOffsetOnly().cx, transform.GetWorldTransform()->GetOffsetOnly().cy ));
            else
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorned dispnode 0x%x, complex transform", pDispNode ));

            if (transformAdorner.GetWorldTransform()->IsOffsetOnly())
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Parent dn of adorner 0x%x, transform offset %d,%d", pDispParent, transformAdorner.GetWorldTransform()->GetOffsetOnly().cx, transformAdorner.GetWorldTransform()->GetOffsetOnly().cy ));
            else
                TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Parent dn of adorner 0x%x, complex transform", pDispParent ));

            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorner dn 0x%x, old t:%d, l:%d", _pDispNode, _pDispNode->GetPosition().x, _pDispNode->GetPosition().y ));
#endif

            transform.AddPreOffset( sizeOffset );
            transform.AddPostTransform(transformAdorner);
            _pDispNode->SetUserTransform(&transform);
            _pDispNode->SetPosition(g_Zero.pt);


            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::PositionChanged() - Adorner dn 0x%x, new t:%d, l:%d", _pDispNode, _pDispNode->GetPosition().x, _pDispNode->GetPosition().y ));
        }

        //
        //  If the display node containing the element with focus is not correctly placed in the display
        //  tree, remove the focus display node as well to prevent artifacts
        //

        else
        {
            _pView->ExtractDispNode(_pDispNode);
        }
    }

    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_OUTDENT, ")CFocusAdorner::PositionChanged())" ));
}

//+====================================================================================
//
// Method: ShapeChanged
//
// Synopsis: Hit the Layout for the size you should be and ask your adorner for it to give
//           you your position based on this
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::ShapeChanged()
{
    Assert( _pView->IsInState(CView::VS_OPEN) );
    Assert( _pElement );

    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_INDENT, "(CFocusAdorner::ShapeChanged()" ));

    delete _pShape;
    _pShape = NULL;

    _fTopLeftValid = FALSE;

    CDoc *      pDoc = _pView->Doc();
    CDocInfo    dci(pDoc->_dciRender);
    CShape *    pShape;
    BOOL        fIWasDestroyed = FALSE;

    if (    (_pElement->HasMarkupPtr() && _pElement->GetMarkup()->IsMarkupTrusted())
        &&  (   (_pElement->_etag == ETAG_SPAN && DYNCAST(CSpanElement, _pElement)->GetAAnofocusrect())
             || (_pElement->_etag == ETAG_DIV && DYNCAST(CDivElement, _pElement)->GetAAnofocusrect())))
    {
        pShape = NULL;
    }
    else
    {
        //(dmitryt) IE6/18891. After making OnScroll to fire asyncronously,
        // I've got a crash here. _pElement->GetFocusShape will call get_scrollTop 
        // and other OM, so potentially will destroy/replace the adorner we are in now. 
        // Inserting AddRef/Release and check to avoid crash.
        AddRef();

        _pElement->GetFocusShape( _iDivision, &dci, &pShape );

        fIWasDestroyed = 
            (   !pDoc->GetView()->_pFocusAdorner 
             || pDoc->GetView()->_pFocusAdorner != this);

        Release();
    }

    if(fIWasDestroyed)
    {
        delete pShape;
    }
    else
    {
        if ( pShape )
        {
            CRect       rc;

            pShape->GetBoundingRect( &rc );

            if ( rc.IsEmpty() )
            {
                delete pShape;
            }
            else
            {
                if (_pShape)
                {
                    delete _pShape;
                    _pShape = NULL;
                }

                _pShape = pShape;
            }
        }
        
        EnsureDispNode();

        if ( _pDispNode )
        {
            CRect   rc;

            Assert( _pShape );

            _pShape->GetBoundingRect( &rc );
            _pDispNode->SetSize( rc.Size(), NULL, TRUE );

            TraceTagEx((tagFocusAdornerChange, TAG_NONAME, "CFA::ShapeChanged() - setting dn 0x%x to size(cx:%d cy:%d)", _pDispNode, rc.right-rc.left, rc.bottom-rc.top ));
        }
    }
    
    TraceTagEx((tagFocusAdornerChange, TAG_NONAME|TAG_OUTDENT, ")CFocusAdorner::ShapeChanged()" ));
}

//+====================================================================================
//
// Method: Draw
//
// Synopsis: Wraps call to IElementAdorner.Draw - to allow adorner
//           to draw.
//
//------------------------------------------------------------------------------------

void
CFocusAdorner::DrawClient(
            const RECT *   prcBounds,
            const RECT *   prcRedraw,
            CDispSurface * pDispSurface,
            CDispNode *    pDispNode,
            void *         cookie,
            void *         pClientData,
            DWORD          dwFlags)
{
    Assert( _pElement );
    if (  _pElement &&  !_pElement->IsEditable( TRUE )
        &&  _pView->Doc()->HasFocus()
        &&  !(_pView->Doc()->_wUIState & UISF_HIDEFOCUS))
    {
        Assert(pClientData);

        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds( pDI, prcBounds, prcRedraw, pDispSurface );

        WHEN_DBG( ShowRectangle( pDI ) );

        _pShape->DrawShape( pDI );
    }
}

//+====================================================================================
//
// Method: GetZOrderForSelf
//
// Synopsis: IDispClient - get z-order.
//
//------------------------------------------------------------------------------------

LONG
CFocusAdorner::GetZOrderForSelf(CDispNode const* pDispNode)
{
    Assert( _pElement );
    Assert( !_pElement->GetFirstBranch()->IsPositionStatic() );
    Assert( _dnl != DISPNODELAYER_FLOW );
    return _pElement->GetFirstBranch()->GetCascadedzIndex();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\srv\stdafx.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.CXX
//
//  Contents:   Source file that includes pre-compiled header stuff
//
//-------------------------------------------------------------------------

#include "headers.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\srv\server.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      server.cxx
//
//  Contents:   Server App object implementation
//
//  Classes:    CServerApp
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif



//+----------------------------------------------------------------------------
//
// Method: constructor
//
//+----------------------------------------------------------------------------
CServerApp::CServerApp() :
    _lRef(1),
    _hTrident(NULL),
    _TridentNormalizeUA(NULL),
    _TridentGetDLText(NULL)
{
}


//+----------------------------------------------------------------------------
//
// Method: destructor
//
//+----------------------------------------------------------------------------
CServerApp::~CServerApp()
{
    Assert(0 == _lRef);
}


//+----------------------------------------------------------------------------
//
// Method: ReleaseApp
//
//+----------------------------------------------------------------------------
LONG
CServerApp::ReleaseApp()
{
    LONG        lRef = InterlockedDecrement(&_lRef);

    if (!lRef)
    {
        delete g_pApp;
        g_pApp = NULL;
    }

    return _lRef;
}

//+----------------------------------------------------------------------------
//
// Method: AddRefApp
//
//+----------------------------------------------------------------------------
HRESULT
CServerApp::AddRefApp()
{
    HRESULT     hr = S_OK;

    if (g_pApp)
    {
        InterlockedIncrement(&(g_pApp->_lRef));
        goto Cleanup;
    }

    g_pApp = new CServerApp;
    if (NULL == g_pApp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = g_pApp->Initialize();

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: Initialize
//
//+----------------------------------------------------------------------------
HRESULT
CServerApp::Initialize(void)
{
    HRESULT     hr = E_NOTIMPL;

    _hTrident = LoadLibraryEx(_T("MSHTML.DLL"), NULL, 0);
    if (_hTrident == NULL) 
        goto Cleanup;

    _TridentNormalizeUA = (TridentNormalizeUACall)GetProcAddress(_hTrident, "SvrTri_NormalizeUA");
    _TridentGetDLText = (TridentGetDLTextCall)GetProcAddress(_hTrident, "SvrTri_GetDLText");

    if (_TridentNormalizeUA == NULL || _TridentGetDLText == NULL) 
        goto Cleanup;

    //  TODO (tomfakes) Get this url from somewhere else
    lstrcpyA(_szExtensionUrl, "/Trident/mshtmsrv.dll?u=");

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: IsHTMLCached
//
//+----------------------------------------------------------------------------
BOOL
CServerApp::IsHTMLCached(LPSTR pszUrl)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\time.inc ===
# BUGBUG : move to W4 eventually
WARNING_LEVEL=W3

# include common.inc in mshtml
!include $(ROOT)\common.inc

# optimize for the ppro/pII
!if $(386)
X86_CPU_OPTIMIZATION = /G6
!endif

SRCROOT=$(ROOT)\src
TIMEROOT=$(SRCROOT)\time
TIMEIDLROOT=$(TIMEROOT)\idl\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)

ATLDIR=$(BASEDIR)\public\sdk\inc\atl21
ATLINCLUDE=$(ATLDIR)

DATIME_INC_DIRS= \
    $(SRCROOT); \
    $(TIMEROOT)\include; \
    $(ATLINCLUDE); \
    $(TIMEROOT); \
    $(SRCROOT)\include; \
    $(TIMEROOT)\idlproxy\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY); \
    $(TIMEIDLROOT); \
    $(SRCROOT)\core\include; \
    $(ROOT)\lib$(BUILD_ALT_DIR); \
    $(BASEDIR)\public\sdk\amovie; \
    $(ROOT)\external\inc; \
    $(BASEDIR)\public\internal\shell\inc; \
    $(ROOT)\inetcore\published\inc; \
    $(ROOT)\src\f3\include

CONDITIONAL_INCLUDES= \
    $(CONDITIONAL_INCLUDES) \
    list \
    map \
    vector \
    exception \
    set \
    thunk.h

C_DEFINES = $(C_DEFINES) /DOLD_TIME_ENGINE=1

USE_STATIC_ATL=1
USE_STL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\srv\filter.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      filter.cxx
//
//  Contents:   Http Filter object implementation
//
//  Classes:    CHttpFilter
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif


DWORD   CIISFilter::s_dwNotifyFlags = 
        SF_NOTIFY_ORDER_DEFAULT |
        SF_NOTIFY_PREPROC_HEADERS |
        SF_NOTIFY_URL_MAP;

ULONG   CIISFilter::s_ulTotalRequests = 0;
ULONG   CIISFilter::s_ulRequestsFoundInCache = 0;
ULONG   CIISFilter::s_ulRequestsToTrident = 0;

//+----------------------------------------------------------------------------
//
// Method: GetVersion
//
//+----------------------------------------------------------------------------
BOOL
CIISFilter::GetVersion(HTTP_FILTER_VERSION *pVer)
{
    BOOL        fRet = TRUE;
    DWORD       dwCurrentVersion = HTTP_FILTER_REVISION;    // Bug in httpfilt.h

    if (pVer->dwServerFilterVersion < dwCurrentVersion)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    pVer->dwFilterVersion       = dwCurrentVersion;
    strcpy(pVer->lpszFilterDesc, "MSHTMSRV 1.0");

    pVer->dwFlags = s_dwNotifyFlags;

Cleanup:
    return fRet;
}


//+----------------------------------------------------------------------------
//
// Method: Terminate
//
//+----------------------------------------------------------------------------
BOOL
CIISFilter::Terminate(DWORD)
{
    Assert(g_pApp);
    g_pApp->ReleaseApp();

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Method: FilterProc
//
//+----------------------------------------------------------------------------
DWORD           
CIISFilter::FilterProc(HTTP_FILTER_CONTEXT *pctx, DWORD dwNotifType, LPVOID pvNotification)
{
    DWORD       dwRet;
    HRESULT     hr = S_OK;

    // Only handle the notifications we registered for
    Assert((dwNotifType & s_dwNotifyFlags) == dwNotifType);
    Assert(g_pApp);

    switch (dwNotifType)
    {
    case SF_NOTIFY_PREPROC_HEADERS:
        hr = THR(PreProcHeaders(pctx, (HTTP_FILTER_PREPROC_HEADERS *) pvNotification));
        if (hr)
            goto Cleanup;

        break;

    case SF_NOTIFY_URL_MAP:
        hr = THR(UrlMap(pctx, (HTTP_FILTER_URL_MAP *) pvNotification));
        if (hr)
            goto Cleanup;

        break;

    default:
        Assert(FALSE);
        break;
    }

Cleanup:
    if (!hr)
    {
        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
    else
    {
        dwRet = SF_STATUS_REQ_ERROR;
        SetLastError(hr);
    }

    return dwRet;
}


//+----------------------------------------------------------------------------
//
// Method: PreProcHeaders
//
//+----------------------------------------------------------------------------
HRESULT         
CIISFilter::PreProcHeaders(HTTP_FILTER_CONTEXT *pContext, HTTP_FILTER_PREPROC_HEADERS *pPreProc)
{
    HRESULT         hr = E_FAIL;    // TODO (tomfakes) better error code?
    CHAR            chUserAgent[256];
    DWORD           dwUA;
    ULONG           ulSize;
    BOOL            fRet;
        
    ulSize = sizeof(chUserAgent);
    fRet = pPreProc->GetHeader(pContext, "HTTP_USER_AGENT:", chUserAgent, &ulSize);
    if (!fRet) 
    {
        chUserAgent[0] = '\0';
    }

    // normalize UA
    fRet = g_pApp->NormalizeUA(chUserAgent, &dwUA);
    if (!fRet)
        goto Cleanup;

    if (dwUA != USERAGENT_IE5)
    {
        CHAR            chUrl[MAX_URL_LENGTH];
        ULONG           ulSize;
        BOOL            fRet;
        
        ulSize = sizeof(chUrl);
        fRet = pPreProc->GetHeader(pContext, "url", chUrl, &ulSize);
        if (!fRet) 
        {
            chUrl[0] = '\0';
        }

        //
        // Only do this stuff for HTML files, don't intercept ISAPI or CGI or ASP...
        //
        if (IsStaticHTMLFile(chUrl))
        {
            // If the HTML is cached, we need to make that call here.
            if (g_pApp->IsHTMLCached(chUrl))
            {
                //
                // TODO Redirect to the cached HTML
                //
                s_ulRequestsFoundInCache++;
            }
            else
            {
                //
                // Redirect to the Extension to invoke Trident
                //
                long    lExtLen = lstrlenA(g_pApp->GetExtensionUrl());

                ulSize++;       // Catch the trailing \0
                Assert((ulSize + lExtLen) < MAX_URL_LENGTH);
                memmove(chUrl +  lExtLen, chUrl, ulSize);
                memcpy(chUrl, (LPBYTE) g_pApp->GetExtensionUrl(), lExtLen);

                fRet = pPreProc->SetHeader(pContext, "url", chUrl);
                if (!fRet)
                    goto Cleanup;

                s_ulRequestsToTrident++;
            }
        }
    }
    // else - do nothing, there will be no re-direct and no cache lookup

    hr = S_OK;
    s_ulTotalRequests++;

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: UrlMap
//
//  This method can only be used to map physical paths of the same type, ie
//  static file to static file.  This method is only used in the case where
//  we find the item in the cache and need to return the path to that file
//  as the physical file for this url
//
//+----------------------------------------------------------------------------
HRESULT         
CIISFilter::UrlMap(HTTP_FILTER_CONTEXT *pContext, HTTP_FILTER_URL_MAP *pUrlMap)
{
    HRESULT         hr = S_OK;

//Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: IsStaticHTMLFile
//
//+----------------------------------------------------------------------------
BOOL
CIISFilter::IsStaticHTMLFile(LPCSTR pszUrl)
{
    //TODO (tomfakes) Make this a better test
    if (strncmp(pszUrl, g_pApp->GetExtensionUrl(), lstrlenA(g_pApp->GetExtensionUrl())))
        return FALSE;
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: animattr.cpp
//
//  Contents: ITIMEAnimationElement attributes
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "animelm.h"
#include "tokens.h"
#include "attr.h"

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TAE CTIMEAnimationBase

                // Function Name // Class   // Attr Accessor      // COM put_ fn     // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(TAE_Accumulate,    TAE,     GetAccumulateAttr,    put_accumulate,    get_accumulate,    VT_BSTR);
TIME_PERSIST_FN(TAE_Additive,      TAE,     GetAdditiveAttr,      put_additive,      get_additive,      VT_BSTR);
TIME_PERSIST_FN(TAE_AttributeName, TAE,     GetAttributeNameAttr, put_attributeName, get_attributeName, VT_BSTR);
TIME_PERSIST_FN(TAE_By,            TAE,     GetByAttr,            put_by,            get_by,            VARIANT);
TIME_PERSIST_FN(TAE_CalcMode,      TAE,     GetCalcModeAttr,      put_calcMode,      get_calcMode,      VT_BSTR);
TIME_PERSIST_FN(TAE_From,          TAE,     GetFromAttr,          put_from,          get_from,          VARIANT);
TIME_PERSIST_FN(TAE_KeySplines,    TAE,     GetKeySplinesAttr,    put_keySplines,    get_keySplines,    VT_BSTR);
TIME_PERSIST_FN(TAE_KeyTimes,      TAE,     GetKeyTimesAttr,      put_keyTimes,      get_keyTimes,      VT_BSTR);
TIME_PERSIST_FN(TAE_Origin,        TAE,     GetOriginAttr,        put_origin,        get_origin,        VT_BSTR);
TIME_PERSIST_FN(TAE_Path,          TAE,     GetPathAttr,          put_path,          get_path,          VARIANT);
TIME_PERSIST_FN(TAE_TargetElement, TAE,     GetTargetElementAttr, put_targetElement, get_targetElement, VT_BSTR);
TIME_PERSIST_FN(TAE_To,            TAE,     GetToAttr,            put_to,            get_to,            VARIANT);
TIME_PERSIST_FN(TAE_Values,        TAE,     GetValuesAttr,        put_values,        get_values,        VARIANT);
TIME_PERSIST_FN(TAE_Type,          TAE,     GetTypeAttr,          put_type,          get_type,          VT_BSTR);
TIME_PERSIST_FN(TAE_SubType,       TAE,     GetSubtypeAttr,       put_subType,       get_subType,       VT_BSTR);
TIME_PERSIST_FN(TAE_Mode,          TAE,     GetModeAttr,          put_mode,          get_mode,          VT_BSTR);
TIME_PERSIST_FN(TAE_FadeColor,     TAE,     GetFadeColorAttr,     put_fadeColor,     get_fadeColor,     VT_BSTR);

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMEAnimationBase)
                           // Attr Name         // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_ACCUMULATE,       TAE_Accumulate )
    PERSISTENCE_MAP_ENTRY( WZ_ADDITIVE,         TAE_Additive )
    PERSISTENCE_MAP_ENTRY( WZ_ATTRIBUTENAME,    TAE_AttributeName  )
    PERSISTENCE_MAP_ENTRY( WZ_BY,               TAE_By )
    PERSISTENCE_MAP_ENTRY( WZ_CALCMODE,         TAE_CalcMode )
    PERSISTENCE_MAP_ENTRY( WZ_FROM,             TAE_From )
    PERSISTENCE_MAP_ENTRY( WZ_KEYSPLINES,       TAE_KeySplines )
    PERSISTENCE_MAP_ENTRY( WZ_KEYTIMES,         TAE_KeyTimes )
    PERSISTENCE_MAP_ENTRY( WZ_ORIGIN,           TAE_Origin )
    PERSISTENCE_MAP_ENTRY( WZ_PATH,             TAE_Path )
    PERSISTENCE_MAP_ENTRY( WZ_TARGETELEMENT,    TAE_TargetElement )
    PERSISTENCE_MAP_ENTRY( WZ_TO,               TAE_To )
    PERSISTENCE_MAP_ENTRY( WZ_VALUES,           TAE_Values )
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,             TAE_Type )
    PERSISTENCE_MAP_ENTRY( WZ_SUBTYPE,          TAE_SubType )
    PERSISTENCE_MAP_ENTRY( WZ_MODE,             TAE_Mode )
    PERSISTENCE_MAP_ENTRY( WZ_FADECOLOR,        TAE_FadeColor )

END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\view\view.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       view.cxx
//
//  Contents:   CView and related classes
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WRAPDEFS_H_
#define X_WRAPDEFS_H_
#include "wrapdefs.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_HTMLLYT_HXX_
#define X_HTMLLYT_HXX_
#include "htmllyt.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_VIEW_HXX_
#define X_VIEW_HXX_
#include "view.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef _X_ADORNER_HXX_
#define _X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef _X_FOCUS_HXX
#define _X_FOCUS_HXX_
#include "focus.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

#ifndef X_ICADD_H_
#define X_ICADD_H_
typedef LONG NTSTATUS;      // from <ntdef.h> - needed by winsta.h
#include <winsta.h>
#include <icadd.h>
#endif

ExternTag(tagNoOffScr);
ExternTag(tagOscFullsize);
ExternTag(tagOscTinysize);
ExternTag(tagNoTile);
ExternTag(tagLayoutTasks);

DeclareTag(tagView, "View: General trace", "Trace view processing");
DeclareTag(tagViewRender, "View: Render trace", "Trace RenderView processing");
DeclareTag(tagOscForceDDBanding, "Display: Force offscreen",  "Force banding when using DirectDraw")
DeclareTag(tagViewHwndChange, "View", "trace changes to HWNDs");
DeclareTag(tagNoSmoothScroll, "Scroll", "disable smooth scrolling");
DeclareTag(tagViewInvalidate, "View", "invalidation");
DeclareTag(tagFilterFakeSource, "Filter", "Don't render the source disp tree")
DeclareTag(tagFilterPaintScreen, "Filter", "Paint source to the screen in Draw")
DeclareTag(tagLowResPrinter, "Layout: LowRes", "Use low-res virtual printer");
DeclareTag(tagViewTreeOpen, "View", "trace VF_TREEOPEN");

PerfDbgTag(tagCViewEnsure,      "View", "Trace CView::EnsureView")
PerfDbgTag(tagChildWindowOrder, "ChildWindowOrder", "Count child windows reordered")

MtDefine(CView,                  Layout, "CView")
MtDefine(CView_aryTaskMisc_pv,   Layout, "CView::_aryTaskMisc::_pv")
MtDefine(CView_aryTaskLayout_pv, Layout, "CView::_aryTaskLayout::_pv")
MtDefine(CView_aryTaskEvent_pv,  Layout, "CView::_aryTaskEvent::_pv")

MtDefine(CView_arySor_pv,        Layout, "CView::_arySor::_pv")
MtDefine(CView_aryTransition_pv, Layout, "CView::_aryTransition::_pv")
MtDefine(CView_aryWndPos_pv,     Layout, "CView::_aryWndPos::_pv")
MtDefine(CView_aryWndRgn_pv,     Layout, "CView::_aryWndRgn::_pv")
MtDefine(CView__aryClippingOuterHwnd_pv, Layout, "CView::aryClippingOuterHwnd::pv")
MtDefine(CView_aryAdorners_pv,   Layout, "CView::_aryAdorners::_pv")
MtDefine(CViewDispClient,        Layout, "CViewDispClient")
MtDefine(CView_aryHWND_pv,       Layout, "CView::pAryHWND::_pv")

// number of lines in default offscreen buffer
const long  s_cBUFFERLINES = 150;

#if DBG==1
#define MARKRECURSION(grf)  { if (IsLockSet(VL_RENDERINPROGRESS) || !IsLockSet(VL_UPDATEINPROGRESS) || !(grf & LAYOUT_INPAINT)) _fDEBUGRecursion = TRUE; }
#define CHECKRECURSION()    { if (_fDEBUGRecursion) { AssertSz(!_fDEBUGRecursion, "CView::EnsureView was recursively entered from this point"); _fDEBUGRecursion = FALSE; } }
#define CLEARRECURSION()    _fDEBUGRecursion = FALSE
void    DumpRegion(HRGN hrgn);
void    DumpClipRegion(HDC hdc);
void    DumpHDC(HDC hdc);
#else
#define MARKRECURSION(grf)
#define CHECKRECURSION()
#define CLEARRECURSION()
#endif

#define IsRangeCrossRange(a1, a2, b1, b2) (((a2) >= (b1)) && ((a1) <= (b2)))

//+---------------------------------------------------------------------------
//
//  Member:     Getxxxxx
//
//  Synopsis:   Return _pv properly type-casted
//
//----------------------------------------------------------------------------

CElement *
CViewTask::GetElement() const
{
    return DYNCAST(CElement, _pElement);
}

CLayout *
CViewTask::GetLayout() const
{
    return DYNCAST(CLayout, _pLayout);
}

DISPID
CViewTask::GetEventDispID() const
{
    return (DISPID) _dispidEvent;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetSourceIndex
//
//  Synopsis:   Return the source index for the object associated with a task
//
//----------------------------------------------------------------------------

long
CViewTask::GetSourceIndex() const
{
    Assert(_vtt == VTT_LAYOUT);
    return GetLayout()->ElementOwner()->GetSourceIndex();
}


//+---------------------------------------------------------------------------
//
//  Member:     GetOwner
//
//  Synopsis:   Return display node owner
//
//----------------------------------------------------------------------------

void
CViewDispClient::GetOwner(
    CDispNode const* pDispNode,
    void **     ppv)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    Assert(pDispNode);
    Assert(pDispNode == View()->_pDispRoot);
    Assert(ppv);
    *ppv = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClient
//
//  Synopsis:   Draw client content
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClient(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         cookie,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientBackground
//
//  Synopsis:   Draw background
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientBackground(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    Assert(pDispNode);
    Assert(pDispNode == View()->_pDispRoot);
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    View()->RenderBackground(pDI);
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientBorder
//
//  Synopsis:   Draw border
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientBorder(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientScrollbar
//
//  Synopsis:   Draw scrollbar
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientScrollbar(
    int            iDirection,
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    long           contentSize,
    long           containerSize,
    long           scrollAmount,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientScrollbarFiller
//
//  Synopsis:   Draw scrollbar
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientScrollbarFiller(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestScrollbar
//
//  Synopsis:   Hit test the scrollbar
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestScrollbar(
    int            iDirection,
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     HitTestScrollbarFiller
//
//  Synopsis:   Hit test the scrollbar filler
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestScrollbarFiller(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     HitTestContent
//
//  Synopsis:   Hit test the display node
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestContent(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData,
    BOOL           fDeclinedByPeer)
{
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     HitTestFuzzy
//
//  Synopsis:   Hit test the display node
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestFuzzy(
    const POINT *  pptHitInBoxCoords,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestBorder
//
//  Synopsis:   Hit test the display node
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::HitTestBorder(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     ProcessDisplayTreeTraversal
//
//  Synopsis:   Process display tree traversal
//
//----------------------------------------------------------------------------

BOOL
CViewDispClient::ProcessDisplayTreeTraversal(
    void *         pClientData)
{
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetZOrderForSelf
//
//  Synopsis:   Return z-index
//
//----------------------------------------------------------------------------

LONG
CViewDispClient::GetZOrderForSelf(CDispNode const* pDispNode)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CompareZOrder
//
//  Synopsis:   Compare the z-order of a display node with this display node
//
//----------------------------------------------------------------------------

LONG
CViewDispClient::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
    return -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to a change in position
//
//----------------------------------------------------------------------------

void
CViewDispClient::HandleViewChange(
    DWORD          flags,
    const RECT *   prcClient,
    const RECT *   prcClip,
    CDispNode *    pDispNode)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     NotifyScrollEvent
//
//  Synopsis:   Respond to a change in scroll position
//
//----------------------------------------------------------------------------

void
CViewDispClient::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClientPainterInfo
//
//  Synopsis:   Return rendering layer information flags
//
//----------------------------------------------------------------------------

DWORD
CViewDispClient::GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawClientLayers
//
//  Synopsis:   Render a layer
//
//----------------------------------------------------------------------------

void
CViewDispClient::DrawClientLayers(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    AssertSz(FALSE, "Illegal CDispClient method called on view");
}


//+---------------------------------------------------------------------------
//
//  Member:     GetServiceProvider
//
//  Synopsis:   return the client's service provider (refcounted)
//
//----------------------------------------------------------------------------

IServiceProvider *
CViewDispClient::GetServiceProvider()
{
    IServiceProvider *pSP = NULL;

    IGNORE_HR(Doc()->QueryInterface(IID_IServiceProvider, (void**)&pSP));

    return pSP;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     DumpDebugInfo
//
//  Synopsis:   Dump debugging information
//
//----------------------------------------------------------------------------

void
CViewDispClient::DumpDebugInfo(
    HANDLE           hFile,
    long             level,
    long             childNumber,
    CDispNode const* pDispNode,
    void *           cookie)
{
    WriteString(hFile, _T("<tag>Active View</tag>\r\n"));
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     Invalidate
//
//  Synopsis:   Forward invalidate to appropriate receiver
//
//  Arguments:  prcInvalid - The invalid rect (if rgnInvalid is NULL)
//              rgnInvalid - The invalid region
//              fSynchronousRedraw  - draw synchronously before returning
//              fInvalChildWindows  - invalidate child windows
//
//----------------------------------------------------------------------------

void
CViewDispClient::Invalidate(
    const CRect*    prcInvalid,
    HRGN            rgnInvalid,
    BOOL            fSynchronousRedraw,
    BOOL            fInvalChildWindows)
{
    if (View()->GetLayoutFlags() & LAYOUT_FORCE)
        fSynchronousRedraw = FALSE;

    if (rgnInvalid)
    {
        View()->Invalidate(rgnInvalid, fSynchronousRedraw, fInvalChildWindows);
    }
    else if (prcInvalid)
    {
        View()->Invalidate(prcInvalid, fSynchronousRedraw, fInvalChildWindows);
    }
    else if (fSynchronousRedraw)
    {
        View()->PostRenderView(TRUE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     ScrollRect
//
//  Synopsis:   Scroll pixels on screen
//
//----------------------------------------------------------------------------

void
CViewDispClient::ScrollRect(
    const CRect& rcgScroll,
    const CSize& sizegScrollDelta,
    CDispScroller* pScroller)
{
    View()->ScrollRect(rcgScroll, sizegScrollDelta, pScroller);
}


//+---------------------------------------------------------------------------
//
//  Member:     OpenViewForRoot
//
//  Synopsis:   Open the view (called only by disp root)
//
//----------------------------------------------------------------------------

void
CViewDispClient::OpenViewForRoot()
{
    View()->OpenView();
}


//+---------------------------------------------------------------------------
//
//  Member:     CView/~CView
//
//  Synopsis:   Constructor/Destructor
//
//----------------------------------------------------------------------------

CView::CView()
{
#ifdef DEADCODE
    _iZoomFactor = 100;
#endif
    ClearRanges();
}

CView::~CView()
{
    delete _pAryHwnd;
    Assert(_pDispRoot == NULL);
    Assert(_aryTaskMisc.Size() == 0);
    Assert(_aryTaskLayout.Size() == 0);
    Assert(_aryTaskEvent.Size() == 0);
    Assert(!HasInvalid());
}


//+---------------------------------------------------------------------------
//
//  Member:     Initialize
//
//  Synopsis:   Initialize the view
//
//  Arguments:  pDoc - Pointer to owning CDoc
//
//----------------------------------------------------------------------------

void
CView::Initialize(
    CDoc *  pDoc,
    SIZEL & szlDefault) // himetric
{
    Assert(pDoc);
    Assert(!_dciDefaultMedia._pDoc);
    Assert(!_pDispRoot);

    // initialize CDocInfo for all resolutions
#if DBG==1
    // allow using different device resolution for debugging purposes
    if (!IsTagEnabled(tagLowResPrinter))
    {
        AssertSz(g_uiVirtual.GetResolution().cx == 16384, "Changing virtual printer to high resolution!");
        g_uiVirtual.SetResolution(16384, 16384);
    }
    else
    {
        AssertSz(g_uiVirtual.GetResolution().cx == 300, "Changing virtual printer to low resolution!");
        g_uiVirtual.SetResolution(300, 300);
    }

#endif

    _dciVirtualPrinter.SetUnitInfo(&g_uiVirtual);
    _dciVirtualPrinter._pDoc = pDoc;
    
    _dciDefaultMedia.SetUnitInfo(&g_uiDisplay);
    _dciDefaultMedia._pDoc = pDoc;
}


//+---------------------------------------------------------------------------
//
//  Member:     Activate
//
//  Synopsis:   Activate the view
//
//----------------------------------------------------------------------------

HRESULT
CView::Activate()
{
    Assert(IsInitialized());
    Assert(!_pDispRoot);
    Assert(!_pLayout);
    Assert(!_pDispRoot);

    TraceTagEx((tagView, TAG_NONAME,
           "View : Activate"));

    _pDispRoot = CDispRoot::New(&_client, &_client);

    if (_pDispRoot)
    {
        //
        //  Mark the view active and open it
        //

        SetFlag(VF_ACTIVE);

        Verify(OpenView());

        //
        //  Initialize the display tree
        //

        _pDispRoot->SetOwned();
        _pDispRoot->SetLayerFlow();
        _pDispRoot->SetBackground(TRUE);
        _pDispRoot->SetOpaque(TRUE);
        if (Doc()->_fActiveDesktop)
            _pDispRoot->DisableObscureProcessing();

        //
        //  Allocate display contexts
        //  
        
        _pDrawContext = new CDispDrawContext(TRUE);
        _pRecalcContext = new CDispRecalcContext();
        
        //
        //  Enable the recalc engine
        //  NOTE: This is a workaround that stops recalc from running until
        //        the view is around.  When the OM is robust enough to handle
        //        no view documents then this should be removed.
        //

        Doc()->suspendRecalc(FALSE);
    }

    RRETURN (_pDispRoot
                ? S_OK
                : E_FAIL);
}


//+---------------------------------------------------------------------------
//
//  Member:     Deactivate
//
//  Synopsis:   Deactivate a view
//
//----------------------------------------------------------------------------

void
CView::Deactivate()
{
    TraceTagEx((tagView, TAG_NONAME,
           "View : Deactivate"));

    Unload();

    if (_pDispRoot)
    {
        Assert(_pDispRoot->GetObserver() == (CDispObserver *)(&_client));

        // TODO (donmarsh) -- theoretically, DestroyTreeWithPrejudice should
        // be faster than Destroy.  However, the last time I checked (11/06/98),
        // unloadchk reported only a 0.2% perf improvement, and that's not
        // enough to risk a change like this.
        //_pDispRoot->DestroyTreeWithPrejudice();
        _pDispRoot->Destroy();
        _pDispRoot = NULL;
    }
    
    delete _pDrawContext;
    _pDrawContext = NULL;
    
    delete _pRecalcContext;
    _pRecalcContext = NULL;
    
    ReleaseRenderSurface();
    ReleaseOffscreenBuffer();

    _grfFlags = 0;

    Assert(!_grfLocks);
}


//+---------------------------------------------------------------------------
//
//  Member:     Unload
//
//  Synopsis:   Unload a view
//
//----------------------------------------------------------------------------

void
CView::Unload()
{
    Assert(!IsActive() || _pDispRoot);

    TraceTagEx((tagView, TAG_NONAME,
           "View : Unload"));

    if (IsActive())
    {
        EndDeferSetWindowPos(0, TRUE);
        EndDeferSetWindowRgn(0, TRUE);
        EndDeferSetObjectRects(0, TRUE);
        EndDeferTransition(0, TRUE);

        EnsureDisplayTreeIsOpen();

#ifdef ADORNERS
        DeleteAdorners();
#endif

#ifdef FOCUS_BEHAVIOR
        if (_pFocusBehavior)
        {
            CFocusBehavior *pFocusBehavior = _pFocusBehavior;
            _pFocusBehavior = 0;
            delete _pFocusBehavior;
        }
#endif

        _aryTaskMisc.DeleteAll();
        _aryTaskLayout.DeleteAll();
        _aryTaskEvent.DeleteAll();


        if (_pDispRoot)
        {
            _pDispRoot->Unload();
        }

        ClearRanges();
        ClearInvalid();
        CloseView(LAYOUT_SYNCHRONOUS);
    }

    Assert(!HasTasks());
    Assert(!HasInvalid());

    TraceTag((tagViewTreeOpen, "%x -TreeOpen (Unload)  was %d",
                this, IsFlagSet(VF_TREEOPEN)));

    _pLayout   = NULL;
    _grfFlags &= VF_ACTIVE | VF_TREEOPEN;
    _grfLayout = 0;

    CLEARRECURSION();
}


//+---------------------------------------------------------------------------
//
//  Member:     ExtractDispNode
//
//  Synopsis:   remove the given node from the display tree
//
//  Arguments:  pDispNode   - the node to remove
//
//----------------------------------------------------------------------------

void
CView::ExtractDispNode(CDispNode * pDispNode)
{
    Assert(_pDispRoot);
    if (_pDispRoot)
        _pDispRoot->ExtractNode(pDispNode);
}


//+---------------------------------------------------------------------------
//
//  Member:     ExtractDispNodes
//
//  Synopsis:   remove the given nodes from the display tree
//
//  Arguments:  pDispNodeStart  - the first node to remove
//              pDispNodeStop   - the last node to remove
//
//----------------------------------------------------------------------------

void
CView::ExtractDispNodes(CDispNode * pDispNodeStart, CDispNode * pDispNodeStop)
{
    Assert(_pDispRoot);
    if (_pDispRoot)
        _pDispRoot->ExtractNodes(pDispNodeStart, pDispNodeStop);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureView
//
//  Synopsis:   Ensure the view is ready for rendering
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//  Returns:    TRUE if processing completed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::EnsureView(DWORD grfLayout)
{
    Assert(IsInitialized());

    PerfDbgLog(tagCViewEnsure, this, "+CView::EnsureView");

    if (IsActive())
    {
        TraceTagEx((tagView, TAG_NONAME,
               "View : EnsureView - Enter"));

        //  A note on recursive entry to EnsureView:
        //  This can happen anytime something causes us to crank our windows message queue, or
        //  (much less likely) we are synchronously called into - ex: ActiveX control.
        //  The CHECK/MARK recursion should cause an assert whenever the recursive call comes from
        //  a place we did not expect - it will most likely be legal, but needs to be examined.
        //  Currently examined & allowed states:
        //  1.  If the recursion occured from a WM_PAINT generated by an earlier call
        //      to EnsureView, return success (so rendering continues).
        //  2.  Script may fire an EnsureViewCallback that is processed because it fires a
        //      modal dialog box or explicitly calls (as with ElementFromPoint).
        
        if (    IsLockSet(VL_ENSUREINPROGRESS)
            ||  IsLockSet(VL_RENDERINPROGRESS)
            ||  IsInState (VS_BLOCKED)
            )
        {
            BOOL    fReturn;

            //
            // we do allow recursion, thus we don't need the assert
            //
            // MARKRECURSION(grfLayout);

            fReturn = (    grfLayout & LAYOUT_INPAINT
                       && IsLockSet(VL_UPDATEINPROGRESS)
                       && !IsLockSet(VL_ACCUMULATINGINVALID)
                       && !IsFlagSet(VF_BLOCKED_FOR_OM)
                      )
                            ? TRUE
                            : FALSE;

            TraceTagEx((tagView, TAG_NONAME,
                   "View : EnsureView  - Exit(%S), Skipped processing",
                   fReturn
                        ? _T("TRUE")
                        : _T("FALSE")));

            PerfDbgLog(tagCViewEnsure, this, "-CView::EnsureView - Exit 1");

            return fReturn;
        }

        //
        //  Add flags left by asynchronous requests
        //

        Assert(!(grfLayout & LAYOUT_TASKFLAGS));
        Assert(!(_grfLayout & LAYOUT_TASKFLAGS));

        grfLayout |= _grfLayout;
        _grfLayout = 0;

        //
        //  If processing synchronously, delete any outstanding asynchronous requests
        //  (Asynchronous requests remove the posted message when dispatched)
        //

        PerfDbgLog(tagCViewEnsure, this, "+CloseView");
        CloseView(grfLayout);
        PerfDbgLog(tagCViewEnsure, this, "-CloseView");
        grfLayout &= ~LAYOUT_SYNCHRONOUS;

        //
        //  If there is no work to do, exit immediately
        //

        BOOL    fSizingNeeded = !IsSized(GetRootLayout());

        if (    !fSizingNeeded
            &&  !(_grfFlags & (VF_TREEOPEN | VF_NEEDSRECALC | VF_FORCEPAINT))
            &&  !HasTasks()
            &&  !HasDeferred()
            &&  Doc()->_aryPendingFilterElements.Size() == 0
            &&  !HasInvalid()
            &&  !(grfLayout & LAYOUT_SYNCHRONOUSPAINT)
            &&  !(grfLayout & LAYOUT_FORCE))
        {
            Assert((grfLayout & ~(  LAYOUT_NOBACKGROUND
                                |   LAYOUT_INPAINT
                                |   LAYOUT_DEFEREVENTS
                                |   LAYOUT_DEFERENDDEFER
                                |   LAYOUT_DEFERINVAL
                                |   LAYOUT_DEFERPAINT)) == 0);
            Assert(!IsDisplayTreeOpen());

            TraceTagEx((tagView, TAG_NONAME,
                   "View : EnsureView - Exit(TRUE)"));

            PerfDbgLog(tagCViewEnsure, this, "-CView::EnsureView - Exit 2");

            return TRUE;
        }

        //
        //  Ensure the view
        //

        {
            CView::CLock    lockEnsure(this, VL_ENSUREINPROGRESS);

            //
            //  Update the view (if requested)
            //

            {
                CView::CLock    lockUpdate(this, VL_UPDATEINPROGRESS);

                //
                //  Perform layout and accumulate invalid rectangles/region
                //

                {
                    CView::CLock    lockInvalid(this, VL_ACCUMULATINGINVALID);

                    //
                    //  Process tasks in the following order:
                    //      1) Ensure the display tree is open (so it can be changed)
                    //      2) Transition any waiting objects
                    //      3) Execute pending recalc tasks (which could post events and layout tasks)
                    //      4) Execute pending asynchronous events (which could post layout tasks)
                    //      5) Ensure focus is up-to-date (which may post layout tasks)
                    //      6) Ensure the root layout is correctly sized (which may override pending layout tasks)
                    //      7) Execute pending measure/positioning layout tasks (which can size and move adorners)
                    //      8) Update adorners
                    //      9) Execute pending adorner layout tasks
                    //     10) Close the display tree (which may generate invalid regions and deferred requests)
                    //
                    //  TODO: This routine needs to first process foreground tasks (and it should process all foreground
                    //          tasks regardless how much time has passed?) and then background tasks. If too much time
                    //          has passed and tasks remain, it should then post a background view closure to complete the
                    //          work. (brendand)
                    //

                    {
                        CView::CLock    lockLayout(this, VL_TASKSINPROGRESS);

                        PerfDbgLog(tagCViewEnsure, this, "+EnsureDisplayTreeIsOpen");
                        EnsureDisplayTreeIsOpen();
                        PerfDbgLog(tagCViewEnsure, this, "-EnsureDisplayTreeIsOpen");

                        PerfDbgLog(tagCViewEnsure, this, "+EndDeferTransition");
                        EndDeferTransition(grfLayout);
                        PerfDbgLog(tagCViewEnsure, this, "-EndDeferTransition");

                        // Take care of any pending expression requests
                        PerfDbgLog(tagCViewEnsure, this, "+ExecuteExpressionTasks");
                        Doc()->ExecuteExpressionTasks();
                        PerfDbgLog(tagCViewEnsure, this, "-ExecuteExpressionTasks");

                        // Recompute all dirty expressions
                        // Also clear the VF_NEEDSRECALC - it will be set back along with
                        // a call to PostCloseView in case we had something to recompute
                        PerfDbgLog(tagCViewEnsure, this, "+EngineRecalcAll");
                        ClearFlag(VF_NEEDSRECALC);
                        Doc()->_recalcHost.EngineRecalcAll(FALSE);
                        PerfDbgLog(tagCViewEnsure, this, "-EngineRecalcAll");

// NOTE (mikhaill 4/21/00) -- this extra lock, VL_EXECUTINGEVENTTASKS, (disabled with slashes)
// appeared during bug #101879 inspecting. The matter is we sometimes can't execute client's
// requests. In particular, when client is called from ExecuteEventTasks() and handle event
// by direct (unbuffered) way, and calls mshtml for changing markup tree data, then asking for
// geometry data assumed to be affected by these changes, we can't provide the calculations
// because we are still inside EnsureView(). The following additional re-locking intended
// to bypass it.
// But luckily (or unfortunately?) this change, in spite of making client more happy, did not
// fix the bug's case, so was disabled in order to keep this well-tested core code undisturbed.
// However, maybe we'll need to re-enable it later.
                        
// 
//                    if (!IsLockSet(VL_EXECUTINGEVENTTASKS))
//                    {
//                        CView::CLock lockEventTasks(this, VL_EXECUTINGEVENTTASKS,
//                                                          VL_ENSUREINPROGRESS |
//                                                          VL_UPDATEINPROGRESS |
//                                                          VL_ACCUMULATINGINVALID);


                        PerfDbgLog(tagCViewEnsure, this, "+ExecuteEventTasks");
                        ExecuteEventTasks(grfLayout);
                        PerfDbgLog(tagCViewEnsure, this, "-ExecuteEventTasks");
//                    }

                        Doc()->ExecuteFilterTasks();

                        EnsureFocus();
        
                        PerfDbgLog(tagCViewEnsure, this, "+EnsureSize");
                        EnsureSize(grfLayout);
                        PerfDbgLog(tagCViewEnsure, this, "-EnsureSize");
                        grfLayout &= ~LAYOUT_FORCE;

                        PerfDbgLog(tagCViewEnsure, this, "+CView::ExecuteLayoutTasks(LAYOUT_MEASURE)");
                        ExecuteLayoutTasks(grfLayout | LAYOUT_MEASURE);
                        PerfDbgLog(tagCViewEnsure, this, "-CView::ExecuteLayoutTasks(LAYOUT_MEASURE)");

                        PerfDbgLog(tagCViewEnsure, this, "+CView::ExecuteLayoutTasks(LAYOUT_POSITION)");
                        ExecuteLayoutTasks(grfLayout | LAYOUT_POSITION);
                        PerfDbgLog(tagCViewEnsure, this, "-CView::ExecuteLayoutTasks(LAYOUT_POSITION)");

#ifdef ADORNERS
                        PerfDbgLog(tagCViewEnsure, this, "+CView::ExecuteLayoutTasks(LAYOUT_ADORNERS)");
                        UpdateAdorners(grfLayout);
                        ExecuteLayoutTasks(grfLayout | LAYOUT_ADORNERS);
                        PerfDbgLog(tagCViewEnsure, this, "-CView::ExecuteLayoutTasks(LAYOUT_ADORNERS)");
#endif

#if DBG == 1
                        // Make sure that no tasks were left lying around
                        for (int i = 0 ; i < _aryTaskLayout.Size() ; i++)
                        {
                            CViewTask vt = _aryTaskLayout[i];
                            Assert(vt.IsFlagSet(LAYOUT_TASKDELETED));
                        }
#endif

                        _aryTaskLayout.DeleteAll();


                        PerfDbgLog(tagCViewEnsure, this, "+CloseDisplayTree");
                        CloseDisplayTree();
                        PerfDbgLog(tagCViewEnsure, this, "-CloseDisplayTree");
                        Assert(!IsDisplayTreeOpen());
                    }

                    //
                    //  Process remaining deferred requests and, if necessary, adjust HWND z-ordering
                    //

                    PerfDbgLog(tagCViewEnsure, this, "+EndDeferSetWindowPos");
                    EndDeferSetWindowPos(grfLayout);
                    PerfDbgLog(tagCViewEnsure, this, "-EndDeferSetWindowPos");

                    PerfDbgLog(tagCViewEnsure, this, "+EndDeferSetObjectRects");
                    EndDeferSetObjectRects(grfLayout);
                    PerfDbgLog(tagCViewEnsure, this, "-EndDeferSetObjectRects");

                    PerfDbgLog(tagCViewEnsure, this, "+EndDeferSetWindowRgn");
                    EndDeferSetWindowRgn(grfLayout);
                    PerfDbgLog(tagCViewEnsure, this, "-EndDeferSetWindowRgn");

                    if (IsFlagSet(VF_DIRTYZORDER))
                    {
                        ClearFlag(VF_DIRTYZORDER);
                        PerfDbgLog(tagCViewEnsure, this, "+FixWindowZOrder");
                        FixWindowZOrder();
                        PerfDbgLog(tagCViewEnsure, this, "-FixWindowZOrder");
                    }
                }

                //
                //  Publish the accumulated invalid rectangles/region
                //

                PublishInvalid(grfLayout);

                //
                //  If requested and not in WM_PAINT handling, render the view (by forcing a WM_PAINT)
                //

                if (    !(grfLayout & (LAYOUT_INPAINT | LAYOUT_DEFERPAINT))
                    &&  (   IsFlagSet(VF_FORCEPAINT)
                        ||  grfLayout & LAYOUT_SYNCHRONOUSPAINT))
                {
                    TraceTagEx((tagView, TAG_NONAME,
                           "View : EnsureView  - Calling UpdateForm"));

                    PerfDbgLog(tagCViewEnsure, this, "+UpdateForm");
                    Doc()->UpdateForm();
                    PerfDbgLog(tagCViewEnsure, this, "-UpdateForm");
                }
                ClearFlag(VF_FORCEPAINT);
            }

            //
            //  Update the caret position
            //
            
            CLayout  * pLayout = GetRootLayout();

            if (    pLayout
                &&  (!pLayout->IsDisplayNone())
                &&  (   fSizingNeeded
                    ||  HasDirtyRange()))
            {
                CCaret * pCaret = Doc()->_pCaret;
                
                if (pCaret)
                {
                    BOOL    fVisible;
                    
                    pCaret->IsVisible(&fVisible);
                    if (fVisible)
                    {
                        CMarkup  *pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();               
                        LONG cp = pCaret->GetCp(NULL);
                        
                        if (  fSizingNeeded || pLayoutMarkup != pCaret->GetMarkup()
                            ||  (   cp >= _cpStartMeasured
                                &&  cp <= _cpEndMeasured)
                            ||  (   cp >= _cpStartTranslated
                                &&  cp <= _cpEndTranslated))
                        {
                            PerfDbgLog(tagCViewEnsure, this, "+UpdateCaret");
                            pCaret->UpdateCaret(FALSE, FALSE);            
                            PerfDbgLog(tagCViewEnsure, this, "-UpdateCaret");
                        }
                    }
                }
            }
            ClearRanges();
        }
    }

#ifndef NO_ETW_TRACING
    // Send event to ETW if it is enabled by the shell.
    if (g_pHtmPerfCtl &&
        (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT)) {
        g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_LAYOUT,
                               (TCHAR *)Doc()->GetPrimaryUrl());
    }
#endif

    TraceTagEx((tagView, TAG_NONAME,
           "View : EnsureView - Exit(TRUE)"));

    PerfDbgLog(tagCViewEnsure, this, "-CView::EnsureView - Exit 3");

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetViewPosition, SetViewPosition
//              
//  Synopsis:   Get/Set the position at which display tree content will be rendered
//              in its host coordinates (used for device offsets when printing).
//              
//  Arguments:  pt      point in host coordinates
//              
//----------------------------------------------------------------------------

void
CView::GetViewPosition(
    CPoint *    ppt)
{
    Assert(ppt);

    *ppt = _pDispRoot
                ? _pDispRoot->GetRootPosition()
                : g_Zero.pt;
}

void
CView::SetViewPosition(
    const POINT &   pt)
{
    if (IsActive())
    {
        OpenView();
        _pDispRoot->SetRootPosition(pt);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     SetViewOffset
//              
//  Synopsis:   Set the view offset, which shifts displayed content (used by
//              printing to display a series of pages with content effectively
//              scrolled between pages).
//              
//  Arguments:  sizeOffset      offset where positive values display content
//                              farther to the right and bottom
//              
//----------------------------------------------------------------------------

BOOL
CView::SetViewOffset(
    const SIZE &    sizeOffset)
{
    if (IsActive())
    {
        OpenView();
        return _pDispRoot->SetContentOffset(sizeOffset);
    }
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  CVIew::BlockViewForOM
//
//----------------------------------------------------------------------------
void        
CView::BlockViewForOM(BOOL fBlock)
{
    if (fBlock)
    {
        SetFlag(VF_BLOCKED_FOR_OM);
    }
    else
    {
        ClearFlag(VF_BLOCKED_FOR_OM);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     EraseBackground
//              
//  Synopsis:   Draw background and border
//              
//  Arguments:  pDI      - Draw context
//              hrgnDraw - Region to draw (if not NULL)
//              prcDraw  - Rect to draw (if not NULL)
//              fEraseChildWindow   if TRUE, we are erasing the background of
//                                  a child window (the IE Label control)
//              
//----------------------------------------------------------------------------

void
CView::EraseBackground(
    CFormDrawInfo * pDI,
    HRGN            hrgnDraw,
    const RECT *    prcDraw,
    BOOL            fEraseChildWindow)
{
    CLayout  * pLayout = GetRootLayout();

    if (pLayout)
    {   
        CMarkup  * pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();
        if(pLayoutMarkup->Document())
        {
            CDocument * pDocument = pLayoutMarkup->Document();
            {
                if(pDocument->HasPageTransitionInfo() && pDocument->GetPageTransitionInfo()->
                              GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_APPLIED)
                {
                    return;
                }
            }
        }
    }

    if (IsActive())
    {
        Assert(!IsLockSet(VL_RENDERINPROGRESS));
        Assert( hrgnDraw
            ||  prcDraw);

        // WARNING (donmarsh) -- we were hitting this lock when we had a
        // windowless Java applet on a page that was trying to do a 
        // page transition -- yikes!  Unfortunately, if we let this go
        // through, we will almost certainly crash, as the Display Tree
        // does not expect to be reentered while it is in the middle of
        // drawing.
        if (IsLockSet(VL_RENDERINPROGRESS))
            return;

#if DBG==1
        if (prcDraw)
        {
            TraceTagEx((tagView, TAG_NONAME,
                   "View : EraseBackground - HDC(0x%x), RECT(%d, %d, %d, %d)",
                   pDI->_hdc,
                   prcDraw->left,
                   prcDraw->top,
                   prcDraw->right,
                   prcDraw->bottom));
        }
        else if (hrgnDraw)
        {
            RECT rc;
            int rgnType = ::GetRgnBox(hrgnDraw, &rc);

            TraceTagEx((tagView, TAG_NONAME,
                   "View : EraseBackground - HDC(0x%x), HRNG bounds(%d, %d, %d, %d)",
                   pDI->_hdc,
                   rgnType == NULLREGION ? "NULLREGION" :
                   rgnType == SIMPLEREGION ? "SIMPLEREGION" :
                   rgnType == COMPLEXREGION ? "COMPLEXREGION" : "ERROR",
                   rc.left,
                   rc.top,
                   rc.right,
                   rc.bottom));
        }
        else
        {
            TraceTagEx((tagView, TAG_NONAME,
                   "View : EraseBackground - HDC(0x%x), No HRGN or rectangle was passed!",
                   pDI->_hdc));
        }
#endif

        Assert(!pDI->_hdc.IsEmpty());
        
        if (!pDI->_hdc.IsEmpty())
        {
            CView::CLock    lock(this, VL_RENDERINPROGRESS);
            XHDC            hdc = pDI->_hdc;

            AssertSz(hdc.pSurface() == NULL, "is surface information being lost?");
            SetRenderSurface(hdc, NULL);
            
            if (_pRenderSurface != NULL)
            {
                CPaintCaret hc(Doc()->_pCaret);
                POINT       ptOrg = g_Zero.pt;
                
                pDI->_hdc = NULL;
    
                ::GetViewportOrgEx(hdc, &ptOrg);
    
                _pDrawContext->SetDispSurface(_pRenderSurface);
                _pDrawContext->SetToIdentity();

#ifdef DEADCODE
                //  If we have a document zoom factor, hit it.
                if (_iZoomFactor != 100)
                {
                    AssertSz(0, "Debug Me: document zoom != 100%");
                    _pDrawContext->GetClipTransform().GetWorldTransform()->AddScaling(_iZoomFactor/100.0, _iZoomFactor/100.0);
                }
#endif
                
                _pDispRoot->EraseBackground(_pRenderSurface, _pDrawContext, (void*)pDI, hrgnDraw, prcDraw, fEraseChildWindow);
    
                ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
        
                pDI->_hdc = hdc;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderBackground
//
//  Synopsis:   Render the background of the view
//
//  Arguments:  pDI - Current CFormDrawInfo
//
//----------------------------------------------------------------------------

void
CView::RenderBackground(
    CFormDrawInfo * pDI)
{
    if (IsActive())
    {
        Assert(pDI);
        Assert(pDI->GetDC() != NULL);

        PatBltBrush(pDI->GetDC(), &pDI->_rcClip, PATCOPY, Doc()->_pOptionSettings->crBack());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderElement
//
//  Synopsis:   Render the element (and all its children) onto the passed HDC
//
//  Arguments:  pElement - the element to render
//              pContext - the display draw context (non-null if this is a filter callback)
//              hdc - HDC on to which to render the element
//              punkDrawObject - if non-null, takes precedence over hdc
//              prcBounds - bounding rect
//              prcUpdate - rect that needs drawing
//              lDrawLayers - layers that need drawing
//
//  Notes:      For now this will assume no clip region and draw at 0, 0
//              Later on we may want to allow the caller to specify an offset
//              and a clip rect/region.
//
//----------------------------------------------------------------------------

HRESULT
CView::RenderElement(
        CElement *          pElement,
        CDispDrawContext*   pContext,
        HDC                 hdc,
        IUnknown *          punkDrawObject,
        RECT *              prcBounds,
        RECT *              prcUpdate,
        LONG                lDrawLayers)
{
    Assert(hdc != NULL || punkDrawObject != NULL);

    HRESULT                 hr                  = S_OK;
    BOOL                    fPaletteSwitched    = FALSE;
    bool                    fPassMatrix         = false;
    IDirectDrawSurface *    pDDS                = NULL;
    CDispSurface *          pDispSurface        = NULL;
    CLayoutContext *        pLayoutContext      = pContext
                                                  ? pContext->GetLayoutContext() 
                                                  : NULL;
    MAT                     matrix;

    WHEN_DBG(POINT pt;)

    // the only draw object we support is DirectDrawSurface
    if (punkDrawObject)
    {
        Assert(hdc == NULL);

        if (OK(punkDrawObject->QueryInterface(IID_IDirectDrawSurface, (void**)&pDDS)))
        {
            pDDS->GetDC(&hdc);
        }
    }

    // Can't do anything if there's nowhere to draw.

    if (hdc == NULL)
    {
        hr = E_FAIL;

        goto Cleanup;
    }

    Assert(!punkDrawObject || pDDS);

    pElement->Doc()->GetPalette(hdc, NULL, &fPaletteSwitched);

    // Set up the surface where we'll draw.

    if (!pContext || pContext->GetDispSurface()->GetRawDC() != hdc)
    {
        pDispSurface = pDDS ? new CDispSurface(pDDS)
                            : new CDispSurface(hdc);

        if (pDispSurface == NULL)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        if (pDDS)
        {
            // If we're drawing to a direct draw surface and we're print media, 
            // we need to set up a transform to scale down the drawing to 
            // pixels instead of the printer measurement scale.  This supports
            // drawing the unfiltered element for the filter behavior.

            if ( pLayoutContext
                && (pLayoutContext != GUL_USEFIRSTLAYOUT)
                && (pLayoutContext->GetMedia() & mediaTypePrint))
            {
                matrix.eM11 =   (float)g_uiDisplay.GetResolution().cx 
                              / (float)g_uiVirtual.GetResolution().cx;
                matrix.eM12 = 0.0F;
                matrix.eM21 = 0.0F;
                matrix.eM22 =   (float)g_uiDisplay.GetResolution().cy 
                              / (float)g_uiVirtual.GetResolution().cy;
                matrix.eDx  = 0.0F;
                matrix.eDy  = 0.0F;

                fPassMatrix = true;
            }
            else if (g_uiDisplay.IsDeviceScaling())
            {
                matrix.eM11 =   FIXED_PIXELS_PER_INCH 
                              / (float)g_uiDisplay.GetResolution().cx;
                matrix.eM12 = 0.0F;
                matrix.eM21 = 0.0F;
                matrix.eM22 =   FIXED_PIXELS_PER_INCH 
                              / (float)g_uiDisplay.GetResolution().cy;
                matrix.eDx  = 0.0F;
                matrix.eDy  = 0.0F;

                fPassMatrix = true;
            }
        }
    }

    WHEN_DBG(GetViewportOrgEx(hdc, &pt);)

#if DBG == 1

    if (IsTagEnabled(tagFilterFakeSource))
    {
        SaveDC(hdc);

        HBRUSH  hbrush  = CreateHatchBrush(HS_DIAGCROSS, RGB(0, 255, 0));
        HPEN    hpen    = CreatePen(PS_SOLID, 2, RGB(0, 255, 255));

        SelectBrush(hdc, hbrush);
        SelectPen(hdc, hpen);
        Rectangle(hdc, prcBounds->left, prcBounds->top, prcBounds->right, prcBounds->bottom);
        
        SetTextColor(hdc, RGB(255, 0, 0));
        SetBkMode(hdc, TRANSPARENT);

        TCHAR *sz = _T("This text was rendered instead of the filtered element, it is primarily to test filters");

        DrawText(hdc, sz, -1, prcBounds, DT_CENTER | DT_WORDBREAK);

        RestoreDC(hdc, -1);
    }
    else
    {

#endif

    if (pContext)
    {
        // This is a draw call in response to our Draw on the filter.
        // Get the layout context from CDispDrawContext and pass it
        // to the GetUpdatedLayout to get the correct one of the 
        // multiple layouts
        CLayout *   pLayout = pElement->GetUpdatedLayout(pContext->GetLayoutContext());

        Assert(pLayout);

        CDispNode *pDispNode = pLayout->GetElementDispNode();

        Assert(pDispNode);

        pDispNode->DrawNodeForFilter(pContext, pDispSurface,
                                     fPassMatrix ? &matrix : NULL, lDrawLayers);
    }
    else
    {
        // This is an out of band call, typically done by a transition when Apply is called.  We need to
        // enlist the help of the view.

        POINT ptOrg;

        ::SetViewportOrgEx(hdc, 0, 0, &ptOrg);

        RenderElement(pElement, NULL, lDrawLayers, pDispSurface, TRUE,
                      fPassMatrix ? &matrix : NULL);

        ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
    }

#if DBG == 1

    }

    if (IsTagEnabled(tagFilterPaintScreen))
    {
        HDC hdcScreen = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        if (hdcScreen)
        {
            CRect rc(*prcBounds);
            CSize size = rc.Size();

            BitBlt(hdcScreen, 0, 0, size.cx, size.cy, hdc, prcBounds->left, prcBounds->top, BLACKNESS);
            BitBlt(hdcScreen, 0, 0, size.cx, size.cy, hdc, prcBounds->left, prcBounds->top, SRCCOPY);  

            DeleteDC(hdcScreen);
        }
    }

#endif

    if (hdc && fPaletteSwitched)
    {
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    }

Cleanup:

    delete pDispSurface;

    ReleaseInterface(pDDS);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderElement
//
//  Synopsis:   Render the element (and all its children) onto the passed HDC
//
//  Arguments:  pElement - the element to render
//              hdc - HDC on to which to render the element
//              pDispSurface - surface on to which to render the element
//                  (if not NULL, takes precedence over hdc)
//              fIgnoreUserClip - artificially remove user clip during this render
//
//              2001/04/12 mcalkins:
//              pMatrix - Added this argument, only used when filters call to
//                        have the element drawn in response to a call to
//                        Apply() the filter.
//
//  Notes:      For now this will assume no clip region and draw at 0, 0
//              Later on we may want to allow the caller to specify an offset
//              and a clip rect/region.
//
//----------------------------------------------------------------------------

HRESULT
CView::RenderElement(
    CElement *      pElement,
    HDC             hdc,
    long            lDrawLayers,     /* = FILTER_DRAW_ALLLAYERS */
    CDispSurface *  pDispSurface,    /* = NULL                  */
    BOOL            fIgnoreUserClip, /* = FALSE                 */
    MAT *           pMatrix          /* = NULL                  */)
{
    Assert(pElement != NULL);
    Assert(hdc != NULL || pDispSurface != NULL);

    if (pDispSurface)
    {
        hdc = pDispSurface->GetRawDC();
    }

    if (IsActive() && hdc != NULL)
    {
        CLayout *pLayout = pElement->GetUpdatedNearestLayout(); // find the appropriate layout

        TraceTagEx((tagView, TAG_NONAME,
               "View : RenderElement - HDC(0x%x), Element(0x%x, %S)",
               hdc,
               pElement,
               pElement->TagName()));

        if (    !IsSized(GetRootLayout())
            ||  (_grfFlags & (VF_TREEOPEN | VF_NEEDSRECALC))
            ||  HasTasks()
            ||  (_grfLayout & LAYOUT_FORCE))
        {
            if (    IsLockSet(VL_ACCUMULATINGINVALID)
                ||  IsLockSet(VL_RENDERINPROGRESS))
            {
                pElement->Invalidate();
                RRETURN(E_UNEXPECTED);
            }
            
            EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_DEFEREVENTS | LAYOUT_DEFERPAINT);
        }

        CView::CLock    lock(this, VL_RENDERINPROGRESS);

        CDispNode *pDispNode = pLayout->GetElementDispNode();

        // If this node isn't in the display tree, don't draw anything.

        if (!pDispNode || !pDispNode->GetRootNode() || !pDispNode->GetRootNode()->IsDispRoot())
        {
            RRETURN(S_OK);
        }

        // Save the DC always
        if(!SaveDC(hdc))
            RRETURN(GetLastWin32Error());

        //TODO (dmitryt): we have to review this busines with CFormDrawInfo and DospSurface both 
        //        wrapping HDC and CDispDrawContext and DispSurface both having 
        //        transforms and clip rects. I think CDispSurface should only have normalized DC
        //        (or GDI+ pointer) and CDispDrawContext should have clip and transform.
        //        It would be good to eliminate CFormDrawInfo at all.
        CFormDrawInfo DI;

        DI.Init(pElement, XHDC(hdc, NULL));
        DI._hdc = NULL;             
        DI._fInplacePaint = FALSE; //to force select and olecontrols to draw 
        DI._fIsMetafile   = (GetDeviceCaps(hdc,TECHNOLOGY) == DT_METAFILE);

       //create and set context...
       //try to init all fields because constructor does not do it.
        CDispDrawContext context(FALSE); //we can be drawing something that is not in view
        
        context.SetClientData(&DI);
        context.SetFirstDrawNode(pDispNode);
        context.SetRootNode(_pDispRoot);
        context._fBypassFilter = TRUE;
        
        //initialize context transformation...
        context.GetClipTransform().SetToIdentity();

        //equalize resolutions (1" in the output device should be 1" on the default device)
        CSize sizeInch;
        sizeInch.cx = GetDeviceCaps(hdc, LOGPIXELSX);
        sizeInch.cy = GetDeviceCaps(hdc, LOGPIXELSY);

        // Find layout resolution of the parent. Display transformation currently
        // set in the display node is computed to translate from inner resolution to 
        // outer (parent) resolution, plus it takes in account any additional transformations.
        // We want to keep transformations (e.g. rotation), but we want to scale from parent's
        // media to output device media.
        CLayoutContext const * pContainingLayoutContext = pLayout->HasLayoutContext()        
                                                        ? pLayout->LayoutContext()
                                                        : NULL;
                         
        mediaType mediaLayout = pContainingLayoutContext 
                              ? pContainingLayoutContext->GetMedia() 
                              : mediaTypeNotSet;
                              
        CDocInfo const * pdciParent = GetMeasuringDevice(mediaLayout);
        
        if (sizeInch != pdciParent->GetResolution())
        {
            CDispTransform dispTrans;
            CWorldTransform *pWorldTrans = dispTrans.GetWorldTransform();

            AssertSz(pdciParent->IsDeviceIsotropic(), "Only isotropic measurement devices are supported.");

            pWorldTrans->AddScaling((FLOAT) sizeInch.cx / pdciParent->GetResolution().cx,
                                    (FLOAT) sizeInch.cy / pdciParent->GetResolution().cy);

            context.GetClipTransform().AddPostTransform(dispTrans);
        }

#ifdef DEADCODE
        //add "view zoom". 
        if (_iZoomFactor != 100)
            context.GetClipTransform().GetWorldTransform()->AddScaling(_iZoomFactor/100.0, _iZoomFactor/100.0);                                 
#endif

        //remove origin from DC and add it to context's transform
        CSize szOffset(0,0);
        SetViewportOrgEx(hdc,0,0,&(szOffset.AsPoint()));
        context.AddPostOffset(szOffset);
        
        //account for offset inside container (bounds)
        CRect bounds = pDispNode->GetBounds();
        szOffset.AsPoint() = bounds.TopLeft();
        context.AddPreOffset(-szOffset);

        //set clip and redraw region
        context.ForceClipRect(bounds);

// NOTE (mikhaill) -- something is totaly incorrect in CDispSurface::_prgn handling.
// Which coordinates it should be expessed in? I hope - device coordinates. If so, following
// rcgClip calculations is incorrect. If not - we should change CDispSurface::SetClip() routine
#if 0 //weird clip rgn
        CRect rcgClip;
        context.GetClipTransform().Transform(bounds, &rcgClip);  // to global coords
        CRegion rgngClip(rcgClip);
        context.SetRedrawRegion(&rgngClip);
#else //weird clip rgn
        {
            CRect rc(0, 0, ::GetDeviceCaps(hdc, HORZRES), ::GetDeviceCaps(hdc, VERTRES));
            // alternative way: int r1 = GetClipBox(hdc, &rc);
            CRegion rg(rc);
            context.SetRedrawRegion(&rg);
        }
#endif //weird clip rgn

        //create surface and connect it to context
        CDispSurface *pSurfaceNew = NULL;
        if (pDispSurface == NULL)
        {
            pSurfaceNew = new CDispSurface(hdc);
            pDispSurface = pSurfaceNew;
        }
        context.SetDispSurface(pDispSurface);

        //do the thing
        // we ignore user clip during Apply() of a transition, so that
        // the "before" picture is fully available at Play() time (bug 96041)
#if 0
        // Bug 104556 (mikhaill) -- we should ignore not only user clip,
        // but also user transform. The previous code is kept
        // for reference under this #if 0.
        BOOL fHadUserClip = pDispNode->HasUserClip();

        if (fIgnoreUserClip)
        {
            pDispNode->SetFlag(CDispNode::s_hasUserClip, FALSE);
        }

        _pDispRoot->DrawNode(pDispNode, pDispSurface, &context, lDrawLayers);
        pDispNode->SetFlag(CDispNode::s_hasUserClip, fHadUserClip);
#else
        if (fIgnoreUserClip)
        {
            pDispNode->DrawNodeForFilter(&context, pDispSurface, pMatrix, lDrawLayers);
        }
        else
        {
            _pDispRoot->DrawNode(pDispNode, pDispSurface, &context, lDrawLayers);
        }
#endif

        delete pSurfaceNew;

        RestoreDC(hdc, -1);
    
        RRETURN(S_OK);
    }

    RRETURN(E_UNEXPECTED);
}


//+---------------------------------------------------------------------------
//
//  Member:     RenderView
//
//  Synopsis:   Render the view onto the passed HDC
//              
//  Arguments:  pDI      - Draw context
//              hrgnDraw - Region to draw (if not NULL)
//              prcDraw  - Rect to draw (if not NULL)
//              pClientScale - ptr to array or two scale coefficients,
//                             for X and Y correspondingly. If ptr is zero,
//                             both coefs are treated as 1.
//
//  Note:       pClientScale argument added as a patch to fix bug #106814
//              (mikhaill 4/6/00)
//----------------------------------------------------------------------------

void
CView::RenderView(
    CFormDrawInfo * pDI,
    HRGN            hrgnDraw,
    const RECT *    prcDraw,
    float const*    pClientScale /* = 0 */)
{   
    if (IsActive())
    {
        Assert(!IsLockSet(VL_ACCUMULATINGINVALID));
        Assert(!IsLockSet(VL_RENDERINPROGRESS));
        Assert( hrgnDraw
            ||  prcDraw);

        TraceTagEx((tagView, TAG_NONAME,
               "View : RenderView - Enter"));

#if DBG==1
        if (prcDraw)
        {
            TraceTagEx((tagViewRender, TAG_NONAME,
                   "View : RenderView - HDC(0x%x), RECT(%d, %d, %d, %d)",
                   pDI->_hdc,
                   prcDraw->left,
                   prcDraw->top,
                   prcDraw->right,
                   prcDraw->bottom));
        }
        else if (hrgnDraw)
        {
            RECT rc;
            int rgnType = ::GetRgnBox(hrgnDraw, &rc);

            TraceTagEx((tagViewRender, TAG_NONAME,
                   "View : RenderView - HDC(0x%x), HRNG(%s) bounds(%d, %d, %d, %d)",
                   pDI->_hdc.GetDebugDC(),
                   rgnType == NULLREGION ? "NULLREGION" :
                   rgnType == SIMPLEREGION ? "SIMPLEREGION" :
                   rgnType == COMPLEXREGION ? "COMPLEXREGION" : "ERROR",
                   rc.left,
                   rc.top,
                   rc.right,
                   rc.bottom));
        }
        else
        {
            TraceTagEx((tagViewRender, TAG_NONAME,
                   "View : RenderView - HDC(0x%x), No HRGN or rectangle was passed!",
                   pDI->_hdc.GetDebugDC()));
        }
#endif       

        CLayout  * pLayout = GetRootLayout();

        if (pLayout)
        {   
            CMarkup  * pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();
            if(pLayoutMarkup->Document())
            {
                CDocument * pDocument = pLayoutMarkup->Document();
                {
                    if(pDocument->HasPageTransitionInfo() && pDocument->GetPageTransitionInfo()->
                                  GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_APPLIED)
                    {
                        return;
                    }
                }
            }
        }

        if (    IsLockSet(VL_ACCUMULATINGINVALID)
            ||  IsLockSet(VL_RENDERINPROGRESS))
        {
            if (IsLockSet(VL_ACCUMULATINGINVALID))
            {
                SetFlag(VF_FORCEPAINT);
            }
        }

        else if (!pDI->_hdc.IsEmpty())
        {
            CView::CLock    lock(this, VL_RENDERINPROGRESS);
            XHDC            hdc = pDI->_hdc;

            SetRenderSurface(hdc, NULL);
            
            if (_pRenderSurface != NULL)
            {
                CPaintCaret     pc( Doc()->_pCaret );
                
#if DBG==1
                if (IsTagEnabled(tagViewRender))
                {
                    DumpHDC(hdc.GetDebugDC());
                }
#endif

                pDI->_hdc = NULL;
                
                _pDrawContext->SetDispSurface(_pRenderSurface);
                _pDrawContext->SetToIdentity();

                if (pClientScale)
                {
                    CDispTransform dispTrans;
                    CWorldTransform *pWorldTrans = dispTrans.GetWorldTransform();


                    //pWorldTrans->AddScaling(pClientScale[0], pClientScale[1]);
                    //hack isotropic
                    float scale = min(pClientScale[0], pClientScale[1]);
                    pWorldTrans->AddScaling(scale, scale);

                    _pDrawContext->GetClipTransform().AddPostTransform(dispTrans);
                }

#ifdef DEADCODE
                //  If we have a document zoom factor, hit it.
                if (_iZoomFactor != 100)
                {
                    AssertSz(0, "Debug Me: document zoom != 100%");
                    _pDrawContext->GetClipTransform().GetWorldTransform()->AddScaling(_iZoomFactor/100.0, _iZoomFactor/100.0);
                }
#endif
    
                //
                //  Update the buffer size
                //  (We need to set this information each time in case something has changed.
                //   Fortunately, it won't do any real work until it absolutely has to)
                //

                SetOffscreenBuffer(
                    Doc()->GetPalette(), 
                    Doc()->_bufferDepth, 
                    (Doc()->_cSurface > 0), 
                    (Doc()->_c3DSurface > 0), 
                    WantOffscreenBuffer(),
                    AllowOffscreenBuffer());
                                                
                _pDispRoot->DrawRoot(
                    _pRenderSurface,
                    _pOffscreenBuffer,
                    _pDrawContext,
                    (void*)pDI,
                    hrgnDraw,
                    prcDraw);
    
                pDI->_hdc = hdc;
    
                SetFlag(VF_HASRENDERED);
            }
        }

        TraceTagEx((tagView, TAG_NONAME,
               "View : RenderView - Exit"));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     HitScrollInset
//
//  Synopsis:   Find the top-most scroller that contains the given hit point
//              near its edge, and is capable of scrolling in that direction.
//
//  Arguments:  pptHit       - Point to test
//              pdwScrollDir - Returns the direction(s) that this scroller
//                             can scroll in
//
//  Returns:    CDispScroller that can scroll, NULL otherwise
//
//----------------------------------------------------------------------------

CDispScroller *
CView::HitScrollInset(
    CPoint *    pptHit,
    DWORD *     pdwScrollDir)
{
    return IsActive()
                ? _pDispRoot->HitScrollInset(*pptHit, pdwScrollDir)
                : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestPoint
//
//  Synopsis:   Initiate a hit-test through the display tree
//
//  Arguments:  pMessage   - CMessage for which to hit test
//              ppTreeNode - Where to return CTreeNode of hit element
//              grfFlags   - HT_xxxx flags
//
//  Returns:    HTC_xxx value
//
//----------------------------------------------------------------------------

HTC
CView::HitTestPoint(
    CMessage *      pMessage,
    CTreeNode **    ppTreeNode,
    DWORD           grfFlags)
{
    if (!IsActive())
        return HTC_NO;

    CDispNode * pDispNode = NULL;
    COORDINATE_SYSTEM   cs = COORDSYS_BOX;
    POINT       ptContent = g_Zero.pt;
    HTC         htc       = HitTestPoint(
                                pMessage->pt,
                                &cs,
                                NULL,
                                grfFlags,
                                &pMessage->resultsHitTest,
                                ppTreeNode,
                                ptContent,
                                &pDispNode,
                                &pMessage->pLayoutContext,
                                &pMessage->pElementEventTarget,
                                &pMessage->lBehaviorCookie,
                                &pMessage->lBehaviorPartID);

    //
    //  Save content coordinate point and associated CDispNode
    //

    pMessage->SetContentPoint(ptContent, pDispNode);
    pMessage->coordinateSystem = cs;

    return htc;
}


//+---------------------------------------------------------------------------
//
//  Member:     HitTestPoint
//
//  Synopsis:   Initiate a hit-test through the display tree
//
//  Arguments:  pt         - POINT to hit test
//              pcs        - Coordinate system for the point
//              pElement   - The CElement start hittesting at (if NULL, start at the root)
//              grfFlags   - HT_xxxx flags
//              phtr       - Pointer to a HITTESTRESULTS
//              ppTreeNode - Where to return CTreeNode of hit element
//              ptContent  - Hit tested point in content coordinates
//              ppDispNode - Display node that was hit
//
//  Returns:    HTC_xxx value
//
//----------------------------------------------------------------------------

HTC
CView::HitTestPoint(
    const POINT         &pt,
    COORDINATE_SYSTEM * pcs,
    CElement *          pElement,
    DWORD               grfFlags,
    HITTESTRESULTS *    pHTRslts,
    CTreeNode **        ppTreeNode,
    POINT               &ptContent,
    CDispNode **        ppDispNode,
    CLayoutContext **   ppLayoutContext,
    CElement **         ppElementEventTarget /* = NULL */,
    LONG *              plBehaviorCookie /* = NULL */,
    LONG *              plBehaviorPartID /* = NULL */)
{
    Assert(ppTreeNode);
    Check(!IsLockSet(VL_ACCUMULATINGINVALID));

    if (    !IsActive()
        ||  IsLockSet(VL_ACCUMULATINGINVALID))
        return HTC_NO;

    CPoint          ptHit(pt);
    CHitTestInfo    hti;
    CDispNode *     pDispNode = NULL;

    //
    //  TODO: The fuzzy border should be used whenever the container of is
    //          in edit-mode. For now, only use it when the document itself
    //          is in design-mode. (donmarsh)
    //

    long            cFuzzyBorder = Doc()->DesignMode()
                                        ? 7
                                        : 0;

    //
    //  Ensure the view is up-to-date so the hit-test is accurate
    //

    if (    !IsSized(GetRootLayout())
        ||  (_grfFlags & (VF_TREEOPEN | VF_NEEDSRECALC))
        ||  HasTasks()
        ||  (_grfLayout & LAYOUT_FORCE))
    {
        if (    IsLockSet(VL_ENSUREINPROGRESS)
            ||  IsLockSet(VL_RENDERINPROGRESS))
            return HTC_NO;

        EnsureView(LAYOUT_DEFEREVENTS | LAYOUT_DEFERPAINT);
    }

    //
    //  Construct the default CHitTestInfo
    //

    hti._htc          = HTC_NO;
    hti._phtr         = pHTRslts;
    hti._pNodeElement = *ppTreeNode;
    hti._pDispNode    = NULL;
    hti._ptContent    = g_Zero.pt;
    hti._grfFlags     = grfFlags;
    hti._pLayoutContext = NULL;
    hti._ppElementEventTarget = ppElementEventTarget;
    hti._plBehaviorCookie = plBehaviorCookie;
    hti._plBehaviorPartID = plBehaviorPartID;

    //
    //  Determine the starting display node
    //  NOTE: This must be obtained after calling EnsureView since pending layout
    //        can change the display nodes associated with a element
    //

    if (pElement)
    {
        CLayout *   pLayout = pElement->GetUpdatedNearestLayout();

        if (pLayout)
        {
            pDispNode = pLayout->GetElementDispNode(pElement);
        }
    }

    if (!pDispNode)
    {
        pDispNode = _pDispRoot;
    }

    //
    //  Find the hit
    //

    pDispNode->HitTest(&ptHit, pcs, &hti, !!(grfFlags & HT_VIRTUALHITTEST), cFuzzyBorder);

    //
    //  Save content coordinate point and associated CDispNode
    //

    if (!hti._pNodeElement)
    {
        Assert(!hti._pDispNode);

        CElement *  pElement = CMarkup::GetCanvasElementHelper(Doc()->PrimaryMarkup());

        if (pElement && (!pElement->IsDisplayNone()))
        {
            hti._htc          = HTC_YES;
            hti._pNodeElement = pElement->GetFirstBranch();

            if (hti._phtr)
            {
                hti._phtr->_fWantArrow = TRUE;
            }
        }
    }
    // TODO (MohanB) Need to re-visit this. Hack for frames so that we return BODY instead
    // of the root as the element hit
    else if (   hti._pNodeElement->Tag() == ETAG_ROOT 
             && hti._pNodeElement->Element()->HasMasterPtr())
    {
        CElement * pElement = (hti._pNodeElement->GetMarkup()) 
                                ? hti._pNodeElement->GetMarkup()->GetCanvasElement()
                                : NULL;

        if (pElement)
        {
            hti._pNodeElement = pElement->GetFirstBranch();
        }
    }

    ptContent   = hti._ptContent;
    *ppDispNode = hti._pDispNode;
    *ppTreeNode = hti._pNodeElement;
    *ppLayoutContext = hti._pLayoutContext;

    return hti._htc;
}


//+---------------------------------------------------------------------------
//
//  Member:     Invalidate
//
//  Synopsis:   Invalidate the view
//
//  Arguments:  prcInvalid         - Invalid rectangle
//              rgn                - Invalid region
//              fSynchronousRedraw - TRUE to redraw synchronously
//              fInvalChildWindows - TRUE to invalidate child windows
//
//----------------------------------------------------------------------------

void
CView::Invalidate(
    const CRect *   prcInvalid,
    BOOL            fSynchronousRedraw,
    BOOL            fInvalChildWindows,
    BOOL            fPostRender)
{
    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI())
    {
        if (!prcInvalid)
        {
            prcInvalid = (CRect *)&_pDispRoot->GetBounds();
        }

        TraceTag((tagViewInvalidate, "Invalidate - rc(%d, %d, %d, %d)",
               prcInvalid->left,
               prcInvalid->top,
               prcInvalid->right,
               prcInvalid->bottom
               ));

        //
        //  For a few sections of various other strategies for tracking invalid rectangles pls see the SHIST.
        //  They were discarded since they, at this time, did not provide a performance benefit and were more complex
        //

        //
        //  Maintain a small number of invalid rectangles
        //
        
        if (_cInvalidRects < MAX_INVALID)
        {
            //
            //  Ignore the rectangle if contained within another
            //

            for (int i = 0; i < _cInvalidRects; i++)
            {
                if (_aryInvalidRects[i].Contains(*prcInvalid))
                    break;
            }

            if (i >= _cInvalidRects)
            {
                _aryInvalidRects[_cInvalidRects++] = *prcInvalid;
            }
        }

        //
        //  If too many arrive, union the rectangle into that which results in the least growth
        //

        else
        {
            CRect   rc;
            long    i, iBest;
            long    c, cBest;

            iBest = 0;
            cBest = MINLONG;

            for (i=0; i < MAX_INVALID; i++)
            {
                rc = _aryInvalidRects[i];
                c  = rc.FastArea();

                rc.Union(*prcInvalid);
                c -= rc.FastArea();

                if (c > cBest)
                {
                    iBest = i;
                    cBest = c;

                    if (!cBest)
                        break;
                }
            }

            Assert(iBest >= 0 && iBest < MAX_INVALID);

            if (cBest)
            {
                _aryInvalidRects[iBest].Union(*prcInvalid);
            }
        }

        //
        //  Note if child HWNDs need invalidation
        //

        if (fInvalChildWindows)
        {
            SetFlag(VF_INVALCHILDWINDOWS);
        }

        //
        //  If not actively accumulating invalid rectangles/region,
        //  ensure that the view will eventually render
        //

        if(fPostRender)
            PostRenderView(fSynchronousRedraw);
    }
}

void
CView::Invalidate(
    const CRegion&  rgn,
    BOOL            fSynchronousRedraw,
    BOOL            fInvalChildWindows)
{
    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI())
    {
        //
        //  If the region is a rectangle, forward and return
        //

        if (!rgn.IsComplex())
        {
            RECT rc;
            rgn.GetBounds(&rc);
            Invalidate(&rc, fSynchronousRedraw, fInvalChildWindows);
            return;
        }

#if DBG==1
        if (IsTagEnabled(tagViewInvalidate))
        {
            TraceTag((tagViewInvalidate, "Invalidate region"));
            DumpRegion(rgn);
        }
#endif

        //
        //  Collect the invalid region
        //

        _rgnInvalid.Union(rgn);

        //
        //  Note if child HWNDs need invalidation
        //

        if (fInvalChildWindows)
        {
            SetFlag(VF_INVALCHILDWINDOWS);
        }

        //
        //  If not actively accumulating invalid rectangles/region,
        //  ensure that the view will eventually render
        //

        PostRenderView(fSynchronousRedraw);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     InvalidateBorder
//
//  Synopsis:   Invalidate a border around the edge of the view
//
//  Arguments:  cBorder - Border width to invalidate
//
//-----------------------------------------------------------------------------

void
CView::InvalidateBorder(
    long    cBorder)
{
    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI()
        &&  cBorder)
    {
        CSize   size;

        GetViewSize(&size);

        CRect   rc(size);
        CRect   rcBorder;

        rcBorder = rc;
        rcBorder.right = rcBorder.left + cBorder;
        Invalidate(&rcBorder);

        rcBorder = rc;
        rcBorder.bottom = rcBorder.top + cBorder;
        Invalidate(&rcBorder);

        rcBorder = rc;
        rcBorder.left = rcBorder.right - cBorder;
        Invalidate(&rcBorder);

        rcBorder = rc;
        rcBorder.top = rcBorder.bottom - cBorder;
        Invalidate(&rcBorder);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a notification
//
//  Arguments:  pnf - Notification sent
//
//-----------------------------------------------------------------------------

void
CView::Notify(
    CNotification * pnf)
{
    if (IsActive())
    {
        switch (pnf->Type())
        {
        case NTYPE_MEASURED_RANGE:
            AccumulateMeasuredRange(pnf->Cp(0), pnf->Cch(LONG_MAX));
            break;

        case NTYPE_TRANSLATED_RANGE:
            AccumulateTranslatedRange(pnf->DataAsSize(), pnf->Cp(0), pnf->Cch(LONG_MAX));
            break;

        case NTYPE_ELEMENT_SIZECHANGED:
        case NTYPE_ELEMENT_POSITIONCHANGED:
#ifdef ADORNERS
            if (HasAdorners())
            {
                long    iAdorner;
                BOOL    fShapeChange = pnf->IsType(NTYPE_ELEMENT_SIZECHANGED);

                Assert(!pnf->Element()->IsPositionStatic());

                for (iAdorner = GetAdorner(pnf->Element());
                    iAdorner >= 0;
                    iAdorner = GetAdorner(pnf->Element(), iAdorner+1))
                {
                    if (fShapeChange)
                    {
                        _aryAdorners[iAdorner]->ShapeChanged();
                    }
                    else
                    {
                        _aryAdorners[iAdorner]->PositionChanged();
                    }
                }
            }
#endif
            break;

        case NTYPE_ELEMENT_ENSURERECALC:
            EnsureSize(_grfLayout);
            _grfLayout &= ~LAYOUT_FORCE;
            break;

        case NTYPE_ELEMENT_RESIZE:
        case NTYPE_ELEMENT_RESIZEANDREMEASURE:
                Verify(OpenView());
                if (    pnf->Element()->GetMarkup()
                    &&  pnf->Element() == pnf->Element()->GetMarkup()->GetCanvasElement() )
            {
                pnf->Element()->DirtyLayout(pnf->LayoutFlags());
            }
            ClearFlag(VF_SIZED);
            break;

        case NTYPE_DISPLAY_CHANGE:
        case NTYPE_VIEW_ATTACHELEMENT:
        case NTYPE_VIEW_DETACHELEMENT:
            Verify(OpenView());
            ClearFlag(VF_SIZED);
            ClearFlag(VF_ATTACHED);
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     AddLayoutTask
//
//  Synopsis:   Add a layout view task
//
//  Arguments:  pLayout   - CLayout to invoke
//              grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

HRESULT
CView::AddLayoutTask(
    CLayout *   pLayout,
    DWORD       grfLayout)
{
    Assert(!((grfLayout & ~(LAYOUT_FORCE | LAYOUT_SYNCHRONOUSPAINT)) & LAYOUT_NONTASKFLAGS));
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    if (!IsActive())
        return S_OK;

    Assert(pLayout);
    Assert(pLayout->ElementOwner());
    Assert(!pLayout->ElementOwner()->IsPassivating());
    Assert(!pLayout->ElementOwner()->IsPassivated());
    Assert(!pLayout->ElementOwner()->IsDestructing());

    HRESULT hr = AddTask(pLayout, CViewTask::VTT_LAYOUT, (grfLayout & LAYOUT_TASKFLAGS));

    if (SUCCEEDED(hr))
    {
        grfLayout  &= ~LAYOUT_FORCE;
        _grfLayout |= grfLayout & LAYOUT_NONTASKFLAGS;

        TraceTagEx((tagLayoutTasks, TAG_NONAME,
                    "Layout Task: Added to view for ly=0x%x [e=0x%x,%S sn=%d] by CView::AddLayoutTask()",
                    pLayout,
                    pLayout->ElementOwner(),
                    pLayout->ElementOwner()->TagName(),
                    pLayout->ElementOwner()->_nSerialNumber));

        if (_grfLayout & LAYOUT_SYNCHRONOUS)
        {
            EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_SYNCHRONOUSPAINT);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveEventTasks
//
//  Synopsis:   Remove all event tasks for the passed element
//
//  Arguments:  pElement - The element whose tasks are to be removed
//
//----------------------------------------------------------------------------

void
CView::RemoveEventTasks(
    CElement *  pElement)
{
    Assert(IsActive() || !_aryTaskEvent.Size());
    Assert(pElement);
    Assert(pElement->_fHasPendingEvent);

    if (IsActive())
    {
        int cTasks = _aryTaskEvent.Size();
        int iTask;

        for (iTask = 0; iTask < cTasks; )
        {
            if (_aryTaskEvent[iTask]._pElement == pElement)
            {
                _aryTaskEvent.Delete(iTask);
                cTasks--;
            }
            else
            {
                iTask++;
            }
        }
    }

    pElement->_fHasPendingEvent = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     RequestRecalc
//
//  Synopsis:   Request a call into the recalc engine
//
//----------------------------------------------------------------------------
void
CView::RequestRecalc()
{
    if (IsActive())
    {
        SetFlag(VF_NEEDSRECALC);
        PostCloseView();
    }
}

#ifdef ADORNERS
//+---------------------------------------------------------------------------
//
//  Member:     CreateAdorner
//
//  Synopsis:   Create an adorner
//
//  Arguments:  adt      - The type of adorner to create
//              pElement - The element associated with the adorner
//
//                  -or-
//
//              cpStart  - The starting cp associated with the adorner
//              cpEnd    - The ending cp associated with the adorner
//
//----------------------------------------------------------------------------

CAdorner *
CView::CreateAdorner(
    CElement *  pElement)
{
    if (!IsActive())
        return NULL;

    CAdorner *  pAdorner;

    pAdorner = new CElementAdorner(this, pElement);

    if (    pAdorner
        &&  !SUCCEEDED(AddAdorner(pAdorner)))
    {
        pAdorner->Destroy();
        pAdorner = NULL;
    }

    return pAdorner;
}

CAdorner *
CView::CreateAdorner(
    long        cpStart,
    long        cpEnd)
{
    AssertSz(FALSE, "Range adorners are not yet supported");
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveAdorners
//
//  Synopsis:   Remove all adorners associated with an element
//
//  Arguments:  pElement - CElement associated with the adorner
//
//----------------------------------------------------------------------------

void
CView::RemoveAdorners(
    CElement * pElement)
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (    IsActive()
        &&  _aryAdorners.Size())
    {
        long    iAdorner;

        for (iAdorner = GetAdorner(pElement);
            iAdorner >= 0;
            iAdorner = GetAdorner(pElement, iAdorner))
        {
            RemoveAdorner(_aryAdorners[iAdorner], FALSE);
        }

        if (pElement->CurrentlyHasAnyLayout())
        {
            pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->SetIsAdorned(FALSE);
        }
    }
}

#endif


//+---------------------------------------------------------------------------
//
//  Member:     EndDeferred
//
//  Synopsis:   End all deferred requests
//              NOTE: This routine is meant only for callers outside of CView.
//                    CView should call the underlying routines directly.
//
//----------------------------------------------------------------------------

void
CView::EndDeferred()
{
    Assert(!IsLockSet(VL_ENSUREINPROGRESS));
    Assert(!IsLockSet(VL_RENDERINPROGRESS));

    EndDeferSetWindowPos();
    EndDeferSetObjectRects();
    EndDeferSetWindowRgn();
    EndDeferTransition();

    if (IsFlagSet(VF_DIRTYZORDER))
    {
        ClearFlag(VF_DIRTYZORDER);
        FixWindowZOrder();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetObjectRects, EndDeferSetObjectRects, SetObjectRectsHelper
//
//  Synopsis:   Collect, defer, and execute SetObjectRects requests
//
//----------------------------------------------------------------------------

void
CView::DeferSetObjectRects(
    IOleInPlaceObject * pInPlaceObject,
    const RECT *        prcObj,
    const RECT *        prcClip,
    HWND                hwnd,
    BOOL                fInvalidate)
{
    Assert(IsActive() || !_arySor.Size());

    if (    !IsActive()
        ||  pInPlaceObject == NULL)
        return;

    TraceTag((tagViewHwndChange, "defer SOR %x Client: %ld %ld %ld %ld  Clip: %ld %ld %ld %ld",
                    pInPlaceObject,
                    prcObj->left, prcObj->top, prcObj->right, prcObj->bottom,
                    prcClip->left, prcClip->top, prcClip->right, prcClip->bottom));

    //
    //  Scan array for matching entry
    //  If one is found, update it; Otherwise, append a new entry
    //
    int i;
    SOR * psor;

    for (i = _arySor.Size(), psor = &(_arySor[0]); i > 0; i--, psor++)
    {
        if (psor->hwnd == hwnd && psor->pInPlaceObject == pInPlaceObject)
        {
            psor->rc              = *prcObj;
            psor->rcClip          = *prcClip;
            psor->fInvalidate     = psor->fInvalidate || fInvalidate;
            break;
        }
    }

    //
    //  No match was found, append a new entry
    //

    if (i <= 0)
    {
        if (_arySor.EnsureSize(_arySor.Size() + 1) == S_OK)
        {
            psor = &_arySor[_arySor.Size()];
            psor->pInPlaceObject  = pInPlaceObject;
            pInPlaceObject->AddRef();
            psor->rc              = *prcObj;
            psor->rcClip          = *prcClip;
            psor->hwnd            = hwnd;
            psor->fInvalidate     = fInvalidate;
            _arySor.SetSize(_arySor.Size() + 1);
        }
        else
        {
            CServer::CLock Lock(Doc(), SERVERLOCK_BLOCKPAINT | SERVERLOCK_IGNOREERASEBKGND);
            SetObjectRectsHelper(pInPlaceObject, prcObj, prcClip, hwnd, fInvalidate);
        }
    }
}

void
CView::EndDeferSetObjectRects(
    DWORD   grfLayout,
    BOOL    fIgnore)
{

    SOR *   psor;
    int     i;

    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_arySor.Size());

    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_arySor.Size())
        return;

    {
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

        for (i = _arySor.Size(), psor = &(_arySor[0]); i > 0; i--, psor++)
        {
            if (!fIgnore)
            {
                SetObjectRectsHelper(psor->pInPlaceObject,
                                     &psor->rc, &psor->rcClip, psor->hwnd,
                                     psor->fInvalidate);
            }

            psor->pInPlaceObject->Release();
        }
    }

    _arySor.DeleteAll();
}


// used to enumerate children of a suspected clipping outer window
struct INNERWINDOWTESTSTRUCT
{
    HWND    hwndParent;
    CView * pView;
    CRect   rc;
};


    // this callback checks each of the children of a particular
    // outer window.  If the child is positioned in the given place
    // (namely the client rect), we'll mark the parent as a clipping
    // outer window.  It's called from SetObjectRectsHelper, below.
BOOL CALLBACK
TestInnerWindow(HWND hwndChild, LPARAM lparam)
{
    INNERWINDOWTESTSTRUCT *piwts = (INNERWINDOWTESTSTRUCT *)lparam;
    CRect rcActual;

    piwts->pView->GetHWNDRect(hwndChild, &rcActual);
    if (rcActual == piwts->rc)
    {
        piwts->pView->AddClippingOuterWindow(piwts->hwndParent);
        return FALSE;
    }
    return TRUE;
}


void
CView::SetObjectRectsHelper(
    IOleInPlaceObject * pInPlaceObject,
    const RECT *        prcObj,
    const RECT *        prcClip,
    HWND                hwnd,
    BOOL                fInvalidate)
{
    CRect rcWndBefore(0,0,0,0);
    CRect rcWndAfter(0,0,0,0);
    HRGN hrgnBefore=NULL, hrgnAfter;

    if (hwnd)
    {
        hrgnBefore = ::CreateRectRgnIndirect(&g_Zero.rc);
        if (hrgnBefore)
            ::GetWindowRgn(hwnd, hrgnBefore);
        GetHWNDRect(hwnd, &rcWndBefore);
    }

    TraceTag((tagViewHwndChange, "SOR %x Client: %ld %ld %ld %ld  Clip: %ld %ld %ld %ld  inv: %d",
                    hwnd,
                    prcObj->left, prcObj->top, prcObj->right, prcObj->bottom,
                    prcClip->left, prcClip->top, prcClip->right, prcClip->bottom,
                    fInvalidate));

    {
        CView::CLockWndRects lock(this, NULL, pInPlaceObject);
        IGNORE_HR(pInPlaceObject->SetObjectRects(ENSUREOLERECT(prcObj),
                                             ENSUREOLERECT(prcClip)));
    }

    // MFC controls change the HWND to the rcClip instead of the rcObj,
    // but they don't change the Window region accordingly.  We try to
    // detect that, and make the right change for them (bug 75218).

    // only do this if it looks like SetObjectRects moved the position
    if (hwnd)
        GetHWNDRect(hwnd, &rcWndAfter);
    if (hwnd && rcWndBefore != rcWndAfter)
    {
        CSize sizeOffset = rcWndBefore.TopLeft() - rcWndAfter.TopLeft();
        BOOL fPendingCall = FALSE;

        // SetObjectRects moved the window.  Any SetWindowRgn calls
        // were set up with the old window position in mind, and need to
        // be adjusted.  Do so now.

        // First adjust pending SetWindowRgn calls.
        for (int i = _aryWndRgn.Size()-1;  i >= 0;  --i)
        {
            if (hwnd == _aryWndRgn[i].hwnd)
            {
                fPendingCall = TRUE;
                if (_aryWndRgn[i].hrgn)
                {
                    ::OffsetRgn(_aryWndRgn[i].hrgn, sizeOffset.cx, sizeOffset.cy);
                }
                else
                {
                    _aryWndRgn[i].rc.OffsetRect(sizeOffset);
                }
            }
        }

        // Now adjust calls that have already happened (if none were pending)
        if (!fPendingCall && hrgnBefore)
        {
            hrgnAfter = ::CreateRectRgnIndirect(&g_Zero.rc);
            if (hrgnAfter)
            {
                CRect rcRegion;

                ::GetWindowRgn(hwnd, hrgnAfter);
                ::GetRgnBox(hrgnAfter, &rcRegion);

                WHEN_DBG(CRegionRects rrBefore(hrgnBefore));
                WHEN_DBG(CRegionRects rrAfter(hrgnAfter));

                // if the position moved but the region didn't, move the region
                if (EqualRgn(hrgnBefore, hrgnAfter) && !rcRegion.IsEmpty())
                {
                    ::OffsetRgn(hrgnAfter, sizeOffset.cx, sizeOffset.cy);
                    ::SetWindowRgn(hwnd, hrgnAfter, FALSE);

                    TraceTag((tagViewHwndChange, "move window rgn for %x by %ld %ld",
                                hwnd, sizeOffset.cy, sizeOffset.cx));
                }
                else
                {
                    ::DeleteObject(hrgnAfter);
                }
            }
        }

#if 0
        // this is commented out to resolve SE Bug 22181 where extraneous
        // repaints were occuring when iframes containing a mfc control overlapped.

        // if SetObjectRects moved the position to the clipping rect, we
        // may want to mark the hwnd so that we move it we can move it directly
        // to the clipping rect in the future.
        if (rcWndAfter == *prcClip && rcWndAfter != *prcObj)
        {
            INNERWINDOWTESTSTRUCT iwts;

            iwts.hwndParent = hwnd;
            iwts.pView = this;
            iwts.rc = *prcObj;
            
            EnumChildWindows(hwnd, TestInnerWindow, (LPARAM)&iwts);
        }
#endif
    }

    if (hrgnBefore)
    {
        ::DeleteObject(hrgnBefore);
    }

    if (hwnd && fInvalidate)
    {
        ::InvalidateRect(hwnd, NULL, FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     IsChangingRectsFor
//
//  Synopsis:   See if we're in the middle of a SetObjectRects call for
//              the given control.  We want to ignore certain callbacks
//              in this case (see COleSite::CClient::OnPosRectChange)
//
//----------------------------------------------------------------------------


BOOL
CView::IsChangingRectsFor(HWND hwnd, IOleInPlaceObject * pInPlaceObject) const
{
    CView::CLockWndRects *pLock;

    for (pLock = _pLockWndRects;  pLock;  pLock = pLock->Next())
    {
        if (pLock->IsFor(hwnd, pInPlaceObject))
            return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetHWNDRect, AddClippingOuterWindow, RemoveClippingOuterWindow,
//              IndexOfClippingOuterWindow
//
//  Synopsis:   Some controls (MFC controls, prominently) implement clipping
//              by a pair of windows:  an outer window set to the clip rect
//              and an inner window set to the content rect.  These routines
//              help detect such HWNDs, so that we can move them to their
//              real positions and avoid flicker.
//
//----------------------------------------------------------------------------


void
CView::GetHWNDRect(HWND hwnd, CRect *prcWndActual) const
{    
    Assert(Doc());
    Assert(prcWndActual);
    
    CInPlace* pInPlace = Doc()->_pInPlace;

    if (pInPlace && hwnd)
    {
        HWND hwndParent = pInPlace->_hwnd;

        if (hwndParent)
        {
            ::GetWindowRect(hwnd, prcWndActual);
            CPoint ptActual(prcWndActual->TopLeft());
            ::ScreenToClient(hwndParent, &ptActual);
            prcWndActual->MoveTo(ptActual);   // change to parent window coords.
        }
        else
        {
            *prcWndActual = g_Zero.rc;
        }
    }
    else
    {
        *prcWndActual = g_Zero.rc;
    }
}


void
CView::AddClippingOuterWindow(HWND hwnd)
{
    if (!IsClippingOuterWindow(hwnd))
    {
        _aryClippingOuterHwnd.AppendIndirect(&hwnd);
        TraceTag((tagViewHwndChange, "hwnd %x marked as MFC control", hwnd));
    }
}


void
CView::RemoveClippingOuterWindow(HWND hwnd)
{
    _aryClippingOuterHwnd.DeleteByValueIndirect(&hwnd);
}


int
CView::IndexOfClippingOuterWindow(HWND hwnd)
{
    return _aryClippingOuterHwnd.FindIndirect(&hwnd);
}


//+---------------------------------------------------------------------------
//
//  Member:     HideClippedWindow, UnHideClippedWindow
//
//  Synopsis:   When a window is totally obscured by IFRAMEs, we send it a
//              HideWindow message.  We remember windows in this state,
//              so that if something 
//
//----------------------------------------------------------------------------

void
CView::HideClippedWindow(HWND hwnd)
{
    _aryHwndHidden.AppendIndirect(&hwnd);
}


void
CView::UnHideClippedWindow(HWND hwnd)
{
    _aryHwndHidden.DeleteByValueIndirect(&hwnd);
}


void
CView::CleanupWindow(HWND hwnd)
{
    RemoveClippingOuterWindow(hwnd);
    UnHideClippedWindow(hwnd);
}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetWindowPos, EndDeferSetWindowPos
//
//  Synopsis:   Collect, defer, and execute SetWindowPos requests
//
//----------------------------------------------------------------------------

void
CView::DeferSetWindowPos(
    HWND         hwnd,
    const RECT * prc,
    UINT         uFlags,
    const RECT * prcInvalid)
{
    Assert(IsActive() || !_aryWndPos.Size());

    if (!IsActive())
        return;

#if DBG==1
    if (prcInvalid)
        TraceTag((tagViewHwndChange, "defer SWP %x Rect: %ld %ld %ld %ld  Flags: %x  Inval: %ld %ld %ld %ld",
                    hwnd,
                    prc->left, prc->top, prc->right, prc->bottom,
                    uFlags,
                    prcInvalid->left, prcInvalid->top, prcInvalid->right, prcInvalid->bottom));
    else
        TraceTag((tagViewHwndChange, "defer SWP %x Rect: %ld %ld %ld %ld  Flags: %x  Inval: null",
                    hwnd,
                    prc->left, prc->top, prc->right, prc->bottom,
                    uFlags));
#endif

#ifndef _MAC
    if (hwnd)
    {
        WND_POS *   pWndPos;

        //
        //  Add to invalid area
        //

        // TODO (donmarsh) -- not used right now, and including region.hxx
        // in view.hxx makes region development difficult.
#ifdef NEVER

        if (prcInvalid)
        {
            _rgnInvalid.Union(*prcInvalid);
        }
#endif

        // always no z-order change... this is handled by FixWindowZOrder
        uFlags |= SWP_NOZORDER;

        //
        //  Scan array for matching entry
        //  If one is found, update it; Otherwise, append a new entry
        //

#if 1 // TODO (donmarsh) - this seems to be superfluous code that causes bugs, about to remove
        int i;
        for (i = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); i > 0; i--, pWndPos++)
        {
            if (pWndPos->hwnd == hwnd)
            {
                pWndPos->rc = *prc;

                //
                //  Reset flags
                //  (Always keep the flags that include either SWP_SHOWWINDOW or SWP_HIDEWINDOW)
                //

                if (    (uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW))
                    ||  !(pWndPos->uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW)))
                {
                    //  NOTE: If ever not set, SWP_NOREDRAW is ignored
                    if (    (uFlags & SWP_NOREDRAW)
                        &&  !(pWndPos->uFlags & SWP_NOREDRAW))
                    {
                        uFlags &= ~SWP_NOREDRAW;
                    }

                    pWndPos->uFlags = uFlags;
                }

                break;
            }
        }

        //
        //  No match was found, append a new entry
        //

        if (i <= 0)
#endif
        {
            pWndPos = _aryWndPos.Append();

            if (pWndPos != NULL)
            {
                pWndPos->hwnd   = hwnd;
                pWndPos->rc     = *prc;
                pWndPos->uFlags = uFlags;
                pWndPos->uViewFlags = 0;
            }
        }
    }
#endif // _MAC
}

void
CView::EndDeferSetWindowPos(
    DWORD   grfLayout,
    BOOL    fIgnore)
{
    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_aryWndPos.Size());

    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_aryWndPos.Size())
        return;

#ifndef _MAC
    if (!fIgnore)
    {
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

        const int cLockArraySize = 8;
        CLockWndRects aryLockStack[cLockArraySize];
        const BOOL fAllocateLocks = (_aryWndPos.Size() > cLockArraySize);
        
        CLockWndRects *aryLock = NULL;
        CLockWndRects *pLock = _pLockWndRects;
        CLockWndRects *pLockWndRectsOrig = _pLockWndRects;
        int iLock = 0;

        WND_POS *   pWndPos;
        HDWP        hdwpShowHide = NULL;
        HDWP        hdwpOther    = NULL;
        HDWP        hdwp;
        int         cShowHideWindows = 0;
        int         i, j;

        //  First look at all windows that have previously been hidden
        //  due to clipping (e.g. by obscuring IFRAMEs), to amend the
        //  arguments to SetWindowPos.

        for (i = _aryHwndHidden.Size()-1; i>=0; --i)
        {
            for (j = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); j > 0; j--, pWndPos++)
            {
                if (_aryHwndHidden[i] == pWndPos->hwnd)
                {
                    // remember that the hwnd is on the hidden list
                    pWndPos->uViewFlags |= SWPVF_HIDDEN;

                    // if we want to hide the window by clipping...
                    if (pWndPos->uViewFlags & SWPVF_HIDE)
                    {
                        // hiddden by clipping overrides showing
                        if (pWndPos->uFlags & SWP_SHOWWINDOW)
                            pWndPos->uFlags = (pWndPos->uFlags & (~SWP_SHOWWINDOW)) | SWP_HIDEWINDOW;

                        // hidden by layout overrides hidden by clipping
                        else if (pWndPos->uFlags & SWP_HIDEWINDOW)
                            UnHideClippedWindow(pWndPos->hwnd);
                    }

                    // if we don't want to hide the window by clipping...
                    else
                    {
                        // no longer hidden
                        UnHideClippedWindow(pWndPos->hwnd);

                        // if layout thinks it's visible, show it
                        if (!(pWndPos->uFlags & (SWP_SHOWWINDOW | SWP_HIDEWINDOW)))
                            pWndPos->uFlags |= SWP_SHOWWINDOW;
                    }
                }
            }
        }

        //
        //  Since positioning requests and SWP_SHOW/HIDEWINDOW requests cannot be safely mixed,
        //  process first all positioning requests followed by all SWP_SHOW/HIDEWINDOW requests
        //

        for (i = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); i > 0; i--, pWndPos++)
        {
            // if this is the initial request to hide the window by clipping...
            if ((pWndPos->uViewFlags & (SWPVF_HIDE|SWPVF_HIDDEN)) == SWPVF_HIDE)
            {
                // add to hidden list (unless layout is doing the hiding)
                if (!(pWndPos->uFlags & SWP_HIDEWINDOW))
                    HideClippedWindow(pWndPos->hwnd);

                // hide the window
                pWndPos->uFlags = (pWndPos->uFlags & (~SWP_SHOWWINDOW)) | SWP_HIDEWINDOW;
            }

            if (pWndPos->uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW))
            {
                cShowHideWindows++;
            }
        }

        //
        //  Allocate deferred structures large enough for each set of requests
        //

        if (cShowHideWindows > 0)
        {
            hdwpShowHide = ::BeginDeferWindowPos(cShowHideWindows);
            if (!hdwpShowHide)
                goto Cleanup;
        }

        if (cShowHideWindows < _aryWndPos.Size())
        {
            hdwpOther = ::BeginDeferWindowPos(_aryWndPos.Size() - cShowHideWindows);
            if (!hdwpOther)
                goto Cleanup;
        }

        //
        //  Collect and issue the requests
        //

        Assert( cShowHideWindows <= 0
            ||  hdwpShowHide != NULL);
        Assert( cShowHideWindows >= _aryWndPos.Size()
            ||  hdwpOther != NULL);

        aryLock = fAllocateLocks ? new CLockWndRects[ _aryWndPos.Size() ]
                                 : aryLockStack;
        
        for (i = _aryWndPos.Size(), pWndPos = &(_aryWndPos[0]); i > 0; i--, pWndPos++)
        {
            //
            // The window cached by DeferSetWindowPos may be destroyed
            // before we come here.
            //
            if (!IsWindow(pWndPos->hwnd))
                continue;

            pLock = aryLock[iLock++].Lock(pWndPos->hwnd, pLock);

            TraceTag((tagViewHwndChange, "SWP %x Rect: %ld %ld %ld %ld  Flags: %x",
                    pWndPos->hwnd,
                    pWndPos->rc.left, pWndPos->rc.top, pWndPos->rc.right, pWndPos->rc.bottom,
                    pWndPos->uFlags));

            if (pWndPos->uFlags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW))
            {
                hdwp = ::DeferWindowPos(hdwpShowHide,
                                        pWndPos->hwnd,
                                        NULL,
                                        pWndPos->rc.left,
                                        pWndPos->rc.top,
                                        pWndPos->rc.Width(),
                                        pWndPos->rc.Height(),
                                        pWndPos->uFlags);

                if (!hdwp)
                    goto Cleanup;

                hdwpShowHide = hdwp;
            }
            else
            {
                hdwp = ::DeferWindowPos(hdwpOther,
                                        pWndPos->hwnd,
                                        NULL,
                                        pWndPos->rc.left,
                                        pWndPos->rc.top,
                                        pWndPos->rc.Width(),
                                        pWndPos->rc.Height(),
                                        pWndPos->uFlags);

                if (!hdwp)
                    goto Cleanup;

                hdwpOther = hdwp;
            }
        }

    Cleanup:
        _pLockWndRects = pLock;

        if (hdwpOther != NULL)
        {
            ::EndDeferWindowPos(hdwpOther);
        }

        if (hdwpShowHide != NULL)
        {
            ::EndDeferWindowPos(hdwpShowHide);
        }

        if (fAllocateLocks)
            delete [] aryLock;
        _pLockWndRects = pLockWndRectsOrig;

        _aryWndPos.DeleteAll();

        //
        // perform deferred invalidation
        //

        // TODO: Not used right now, and including region.hxx
        // in view.hxx makes region development difficult.
#ifdef NEVER
        if (!_rgnInvalid.IsEmpty())
        {
            Assert(_pDispRoot != NULL);
            _pDispRoot->InvalidateRoot(_rgnInvalid);
            _rgnInvalid.SetEmpty();
        }
#endif
    }

#endif // _MAC
}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetWindowRgn, EndDeferWindowRgn
//
//  Synopsis:   Collect, defer, and execute SetWindowRgn requests
//
//----------------------------------------------------------------------------

void
CView::DeferSetWindowRgn(
    HWND            hwnd,
    const RECT *    prc,
    BOOL            fRedraw)
{
    Assert(prc);
    Assert(IsActive() || !_aryWndRgn.Size());

    if (!IsActive())
        return;

    TraceTag((tagViewHwndChange, "SWRgn (defer) %x Rect: %ld %ld %ld %ld  Redraw: %d",
            hwnd,
            prc->left, prc->top, prc->right, prc->bottom,
            fRedraw));

    int i;
    WND_RGN * pwrgn;

    //
    //  Scan array for matching entry
    //  If one is found, update it; Otherwise, append a new entry
    //

    for (i = _aryWndRgn.Size(), pwrgn = &(_aryWndRgn[0]); i > 0; i--, pwrgn++)
    {
        if (pwrgn->hwnd == hwnd)
        {
            pwrgn->hrgn    = NULL;
            pwrgn->rc      = *prc;
            pwrgn->fRedraw = pwrgn->fRedraw || fRedraw;
            break;
        }
    }

    //
    //  No match was found, append a new entry
    //

    if (i <= 0)
    {
        if (_aryWndRgn.EnsureSize(_aryWndRgn.Size() + 1) == S_OK)
        {
            pwrgn = &_aryWndRgn[_aryWndRgn.Size()];

            pwrgn->hrgn    = NULL;
            pwrgn->hwnd    = hwnd;
            pwrgn->rc      = *prc;
            pwrgn->fRedraw = fRedraw;

            _aryWndRgn.SetSize(_aryWndRgn.Size() + 1);
        }
        else
        {
            TraceTag((tagViewHwndChange, "SWRgn %x Rect: %ld %ld %ld %ld  Redraw: %d",
                hwnd,
                prc->left, prc->top, prc->right, prc->bottom,
                fRedraw));
           ::SetWindowRgn(hwnd, ::CreateRectRgnIndirect(prc), fRedraw);
        }
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     DeferSetWindowRgn, EndDeferWindowRgn
//
//  Synopsis:   Collect, defer, and execute SetWindowRgn requests
//
//----------------------------------------------------------------------------

static const CRect s_rcUseRegion(1,-2,3,-4);

void
CView::DeferSetWindowRgn(
    HWND            hwnd,
    HRGN            hrgn,
    const CRect*    prc,
    BOOL            fRedraw)
{
    Assert(IsActive() || !_aryWndRgn.Size());

    if (!IsActive())
        return;

    TraceTag((tagViewHwndChange, "defer SWRgn %x Rgn: %x  Redraw: %d",
            hwnd,
            hrgn,
            fRedraw));

    int i;
    WND_RGN * pwrgn;

    //
    //  If there's a pending SetObjectRects for this window, update its
    //  clip rect.  This eliminates some flashing (bug 108347).
    //

    if (prc)
    {
        SOR * psor;

        for (i = _arySor.Size(), psor = &(_arySor[0]); i > 0; i--, psor++)
        {
            if (psor->hwnd == hwnd)
            {
                CRect rcClip = *prc;
                rcClip.OffsetRect(psor->rc.left, psor->rc.top);
                psor->rcClip = rcClip;

                // if we're hiding the window completely, set the HIDEWINDOW bit
                if (prc->IsEmpty())
                {
                    int j;
                    WND_POS * pwp;

                    for (j=_aryWndPos.Size(), pwp = &(_aryWndPos[0]);
                         j > 0;
                         --j, ++pwp)
                    {
                        if (pwp->hwnd == hwnd)
                        {
                            pwp->uViewFlags |= SWPVF_HIDE;
                        }
                    }
                }
                break;
            }
        }
    }

    //
    //  Scan array for matching entry
    //  If one is found, update it; Otherwise, append a new entry
    //

    for (i = _aryWndRgn.Size(), pwrgn = &(_aryWndRgn[0]); i > 0; i--, pwrgn++)
    {
        if (pwrgn->hwnd == hwnd)
        {
            pwrgn->hrgn    = hrgn;
            pwrgn->rc      = s_rcUseRegion;
            pwrgn->fRedraw = pwrgn->fRedraw || fRedraw;
            break;
        }
    }

    //
    //  No match was found, append a new entry
    //

    if (i <= 0)
    {
        if (_aryWndRgn.EnsureSize(_aryWndRgn.Size() + 1) == S_OK)
        {
            pwrgn = &_aryWndRgn[_aryWndRgn.Size()];

            pwrgn->hrgn    = hrgn;
            pwrgn->hwnd    = hwnd;
            pwrgn->rc      = s_rcUseRegion;
            pwrgn->fRedraw = fRedraw;

            _aryWndRgn.SetSize(_aryWndRgn.Size() + 1);
        }
        else
        {
            TraceTag((tagViewHwndChange, "SWRgn %x Rgn: %x  Redraw: %d",
                hwnd,
                hrgn,
                fRedraw));
           ::SetWindowRgn(hwnd, hrgn, fRedraw);
        }

    }
}



void
CView::EndDeferSetWindowRgn(
    DWORD   grfLayout,
    BOOL    fIgnore)
{
    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_aryWndRgn.Size());
        
    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_aryWndRgn.Size())
        return;

    // prevent reentry of Display Tree if the following calls cause
    // a WM_ERASEBKGND message to be sent
    CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
    WND_RGN *   pwrgn;
    int         i;

    for (   i = _aryWndRgn.Size()-1, pwrgn = &(_aryWndRgn[_aryWndRgn.Size()-1]);
            i >= 0;
            i--, pwrgn--)
    {
        if (!fIgnore)
        {
            if (pwrgn->hrgn || pwrgn->rc == s_rcUseRegion)
            {
#if DBG == 1
                if (IsTagEnabled(tagViewHwndChange))
                {
                    TraceTag((tagViewHwndChange, "SWRgn End  %x Rgn: %x  Redraw: %u",
                        pwrgn->hwnd, pwrgn->hrgn, pwrgn->fRedraw));

                    extern void DumpRegion(HRGN);
                    DumpRegion(pwrgn->hrgn);
                }
#endif
               ::SetWindowRgn(pwrgn->hwnd, pwrgn->hrgn, pwrgn->fRedraw);
            }
            else
            {
                TraceTag((tagViewHwndChange, "SWRgn End %x Rect: %ld %ld %ld %ld  Redraw: %d",
                    pwrgn->hwnd,
                    pwrgn->rc.left, pwrgn->rc.top, pwrgn->rc.right, pwrgn->rc.bottom,
                    pwrgn->fRedraw));

                ::SetWindowRgn(pwrgn->hwnd, ::CreateRectRgnIndirect(&pwrgn->rc), pwrgn->fRedraw);
            }

            if(GetProp(pwrgn->hwnd, VBCTRLHOOK_PROPNAME) == VBCTRLHOOK_FILTERED)
            {
                // Since we have set the right clip and the message we were supposed to filter
                // out has arrived we can remove the hook.
                RemoveVBControlClipHook(pwrgn->hwnd);
            }
             _aryWndRgn.Delete(i);
        }
        else 
        {
            if (pwrgn->hrgn)
            {
                ::DeleteObject(pwrgn->hrgn);
            }
            if(GetProp(pwrgn->hwnd, VBCTRLHOOK_PROPNAME))
            {
                RemoveVBControlClipHook(pwrgn->hwnd);
            }
            _aryWndRgn.Delete(i);
        }
    }
}


void
CView::SetWindowRgn(HWND hwnd, const RECT * prc, BOOL fRedraw)
{
    TraceTag((tagViewHwndChange, "SWRgn %x Rect: %ld %ld %ld %ld  Redraw: %d",
        hwnd,
        prc->left, prc->top, prc->right, prc->bottom,
        fRedraw));

    Verify(::SetWindowRgn(hwnd, ::CreateRectRgnIndirect(prc), fRedraw));
    CancelDeferSetWindowRgn(hwnd);
}


void
CView::SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL fRedraw)
{
#if DBG == 1
    if (IsTagEnabled(tagViewHwndChange))
    {
        TraceTag((tagViewHwndChange, "SWRgn %x Rgn: %x  Redraw: %u",
            hwnd, hrgn, fRedraw));

        extern void DumpRegion(HRGN);
        DumpRegion(hrgn);
    }
#endif

    Verify(::SetWindowRgn(hwnd, hrgn, fRedraw));
    CancelDeferSetWindowRgn(hwnd);
}


void
CView::CancelDeferSetWindowRgn(HWND hwnd)
{
    for (int i = _aryWndRgn.Size()-1;  i >= 0;  --i)
    {
        if (hwnd == _aryWndRgn[i].hwnd)
        {
            if (_aryWndRgn[i].hrgn)
            {
                ::DeleteObject(_aryWndRgn[i].hrgn);
            }
            
            _aryWndRgn.Delete(i);
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     DeferTransition, EndDeferTransition
//
//  Synopsis:   Collect, defer, and execute Transition requests
//
//----------------------------------------------------------------------------

void
CView::DeferTransition(
    COleSite *          pOleSite)
{
    INSTANTCLASSINFO * pici;
    
    Assert(pOleSite);
    Assert(IsActive() || !_aryTransition.Size());

    if (!IsActive())
        return;

    pici = pOleSite->GetInstantClassInfo();
    
    if (pici && _aryTransition.EnsureSize(_aryTransition.Size() + 1) == S_OK
        && !(pici->dwCompatFlags & COMPAT_INPLACEACTIVATESYNCHRONOUSLY))
    {
        TRANSITIONTO_INFO * ptinfo = &_aryTransition[_aryTransition.Size()];

        ptinfo->pOleSite = pOleSite;

        // make sure we will have the COleSite when we return to process 
        // the posted EndDeferTransition call
        pOleSite->SubAddRef();

        _aryTransition.SetSize(_aryTransition.Size() + 1);
    }
    else
    {
        IGNORE_HR(pOleSite->TransitionToBaselineState(Doc()->State()));
    }

    PostEndDeferTransition();
}

void
CView::EndDeferTransition(
    DWORD   grfLayout,
    BOOL    fIgnore)
{
    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_aryTransition.Size());

    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_aryTransition.Size())
        return;

    if (!fIgnore)
    {
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

        //
        //  Transition each waiting object
        //  (Re-entrancy can re-alloc _aryTransition so always reference from the index)
        //

        for (int i = 0 ; i < _aryTransition.Size() ; i++)
        {
            TRANSITIONTO_INFO *ptinfo = &_aryTransition[i];

            if (ptinfo->pOleSite)
            {
                COleSite *pOleSite = ptinfo->pOleSite;
                ptinfo->pOleSite = 0;

                // Transition to whatever is the best state to transition to
                if (!pOleSite->IsPassivated() && !pOleSite->IsPassivating() && 
                    (pOleSite->State() < pOleSite->BaselineState(Doc()->State())))
                {
                    pOleSite->TransitionToBaselineState(Doc()->State());
                }

                // release the reference we added in the CView::DeferTransition
                pOleSite->SubRelease();
            }
        }
    }

    _aryTransition.DeleteAll();
}


//+---------------------------------------------------------------------------
//
//  Member:     SetFocus
//
//  Synopsis:   Set or clear the association between the focus adorner and
//              an element
//
//  Arguments:  pElement  - Element which has focus (may be NULL)
//              iDivision - Subdivision of the element which has focus
//
//----------------------------------------------------------------------------

void
CView::SetFocus(
    CElement *  pElement,
    long        iDivision)
{
    if (!IsActive())
        return;

    // TODO (donmarsh) -- we fail if we're in the middle of drawing.  Soon
    // we will have a better mechanism for deferring requests that are made
    // in the middle of rendering.
    if (!OpenView())
        return;

    if (pElement)
    {        
        CTreeNode * pNode =  pElement->GetFirstBranch();

        if (!pNode 
            ||  pNode->IsVisibilityHidden()
            ||  pNode->IsDisplayNone())
        {
            pElement = NULL;
        }        
    }

#ifdef FOCUS_ADORNER
    if (pElement)
    {
        if (!_pFocusAdorner)
        {
            _pFocusAdorner = new CFocusAdorner(this);

            if (    _pFocusAdorner
                &&  !SUCCEEDED(AddAdorner(_pFocusAdorner)))
            {
                _pFocusAdorner->Destroy();
                _pFocusAdorner = NULL;
            }
        }

        if (_pFocusAdorner)
        {
            BOOL fDestroyAdorner = FALSE;

            Assert( IsInState(CView::VS_OPEN) );
            Assert( pElement && pElement->IsInMarkup() );
   
            // check if element takes focus
            if (pElement->GetAAhideFocus())
            {        
                fDestroyAdorner = TRUE;      
            }

            if (pElement->HasMasterPtr())
            {
                pElement = pElement->GetMasterPtr();      
            }
            // If this element is a checkbox or a radio button, use the associated
            // label element if one exists for drawing the focus shape.
            else if (   pElement->Tag() == ETAG_INPUT
                     && DYNCAST(CInput, pElement)->IsOptionButton())
            {
                CLabelElement * pLabel = pElement->GetLabel();
                if (pLabel)
                {
                    if (pLabel->GetAAhideFocus())
                        fDestroyAdorner = TRUE;      
                    else
                        pElement = pLabel;
                }
            }

            if(fDestroyAdorner)
            {
                RemoveAdorner(_pFocusAdorner, FALSE);
                _pFocusAdorner = NULL;
                pElement = NULL;
            }
            else            
                _pFocusAdorner->SetElement(pElement, iDivision);
        }
    }

#endif

#ifdef FOCUS_BEHAVIOR
    if (pElement)
    {
        if (!_pFocusBehavior)
        {
            _pFocusBehavior = new CFocusBehavior(this);
        }

        if (_pFocusBehavior)
        {
            _pFocusBehavior->SetElement(pElement, iDivision);
        }
    }
    else if (_pFocusBehavior)
    {
        _pFocusBehavior->SetElement(NULL, 0);
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     InvalidateFocus
//
//  Synopsis:   Invalidate the focus shape (if any)
//
//----------------------------------------------------------------------------

void
CView::InvalidateFocus() const
{
    if (!IsActive())
        return;

#ifdef FOCUS_ADORNER
    _bUpdateFocusAdorner = TRUE;
#endif

#ifdef FOCUS_BEHAVIOR
    if (_pFocusBehavior)
        _pFocusBehavior->ShapeChanged();
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     GetViewSize
//
//  Synopsis:   Returns the current size of the view
//
//  Arguments:  psize - Returns the size
//
//----------------------------------------------------------------------------

void
CView::GetViewSize(
    CSize * psize) const
{
    Assert(psize);

    if (IsActive())
    {
        *psize = _pDispRoot->GetSize();
    }
    else
    {
        *psize = g_Zero.size;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     SetViewSize
//
//  Synopsis:   Set the size of the view
//
//  Arguments:  size - New view size (in device pixels)
//
//----------------------------------------------------------------------------

void
CView::SetViewSize(const CSize& size)
{
    Assert(!IsLockSet(VL_RENDERINPROGRESS));

    if (IsActive())
    {
        CSize   sizeCurrent;

        GetViewSize(&sizeCurrent);

        if (size != sizeCurrent)
        {            
            if (OpenView())
            {
                //
                //  Set the new size
                //
                _pDispRoot->SetSize(size, NULL, FALSE);
                ClearFlag(VF_SIZED);
                
                if (Doc()->_state >= OS_INPLACE)
                {
                    CLayout *   pLayout = GetRootLayout();
                    
                    if (pLayout && pLayout->ElementOwner()->GetMarkup()->Window()->_fFiredOnLoad && !pLayout->IsDisplayNone())
                    {

                        //
                        // Invalidate possible Z-children positioned on bottom or right sides
                        // (Root layout is always a z-parent)
                        //
                        pLayout->ElementOwner()->SendNotification(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS);

                        //
                        //  Queue a resize event
                        //
                        AddEventTask(pLayout->ElementOwner(), DISPID_EVMETH_ONRESIZE);
                    }
                }
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     OpenView
//
//  Synopsis:   Prepare the view for changes (e.g., open the display tree)
//
//  Returns:    TRUE if the view was successfully opened, FALSE if we are in
//              the middle of rendering
//
//----------------------------------------------------------------------------

BOOL
CView::OpenView(
    BOOL    fBackground,
    BOOL    fPostClose,
    BOOL    fResetTree)
{
    if (!IsActive())
        return TRUE;

    Assert( !IsLockSet(VL_TASKSINPROGRESS)
        ||  IsFlagSet(VF_TREEOPEN));

    if (    (   IsLockSet(VL_ENSUREINPROGRESS)
            &&  !IsLockSet(VL_TASKSINPROGRESS))
        ||  IsLockSet(VL_RENDERINPROGRESS))
        return FALSE;

    if (fResetTree)
    {
        CloseDisplayTree();
    }

    EnsureDisplayTreeIsOpen();

    if (    fPostClose
        &&  !IsLockSet(VL_TASKSINPROGRESS))
    {
        PostCloseView(fBackground);
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CloseView
//
//  Synopsis:   Perform all work necessary to close the view
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::CloseView(
    DWORD   grfLayout)
{
    if (IsFlagSet(VF_PENDINGENSUREVIEW))
    {
        if (grfLayout & LAYOUT_SYNCHRONOUS)
        {
            GWKillMethodCall(this,
                             ONCALL_METHOD(CView,
                                           EnsureViewCallback,
                                           ensureviewcallback),
                             0);

            ClearFlag(VF_PENDINGENSUREVIEW);

            if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONVIEWD))
                g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONVIEWD, (IUnknown*)(IPrivateUnknown*)Doc());
        }
    }

    if (IsFlagSet(VF_PENDINGTRANSITION))
    {
        if (    grfLayout & LAYOUT_SYNCHRONOUS
            &&  !(grfLayout & LAYOUT_DEFERENDDEFER))
        {
            GWKillMethodCall(this,
                             ONCALL_METHOD(CView,
                                           EndDeferTransitionCallback,
                                           enddefertransitioncallback),
                             0);
            ClearFlag(VF_PENDINGTRANSITION);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     PostCloseView
//
//  Synopsis:   Ensure a close view event is posted
//
//              The view is closed whenever EnsureView is called. EnsureView is
//              called for WM_PAINT handling, from the global window (for queued
//              background work or all work on pages without a frame rate), and
//              in response to the draw timer.
//
//              Background closures always occur through a message posted to
//              the global window.
//
//  Arguments:  fBackground - Close the view in the background
//              fEvent      - this is only passed in TRUE by Addtask for Events.
//                            this is necessary because events like onresize and
//                            onlayoutcomplete, and onscroll are going to be 
//                            posted during ensureview's reign in the 
//                            ExecuteLayoutTasks(MEASURE) and so we HAVE to make 
//                            sure that a post close view is queue so that they 
//                            will fire. without this, it is upto chance (and the
//                            luck of the draw( window message) as to when ensureView
//                            will be called next.
//
//----------------------------------------------------------------------------

void
CView::PostCloseView(BOOL  fBackground, /* == FALSE */
                     BOOL  fEvent       /* == FALSE */)
{
    if (    IsActive()
        &&  !IsFlagSet(VF_PENDINGENSUREVIEW)
        &&  (   fEvent 
             || !IsLockSet(VL_ACCUMULATINGINVALID))
        )
    {
        HRESULT hr;

        hr = GWPostMethodCall(this,
                              ONCALL_METHOD(CView,
                                            EnsureViewCallback,
                                            ensureviewcallback),
                              0, FALSE, "CView::EnsureViewCallback");
        SetFlag(VF_PENDINGENSUREVIEW);

        if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONVIEWQ))
            g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONVIEWQ, (IUnknown*)(IPrivateUnknown*)Doc());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     PostRenderView
//
//  Synopsis:   Ensure rendering will take place
//
//  Arguments:  fSynchronousRedraw - Render synchronously (if possible)
//
//----------------------------------------------------------------------------

void
CView::PostRenderView(
    BOOL    fSynchronousRedraw)
{
    //
    //  For normal documents, ensure rendering will occur
    //  (Assume rendering will occur for print documents)
    //

    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI())
    {
        TraceTagEx((tagView, TAG_NONAME,
               "View : PostRenderView"));

        //
        //  If a synchronouse render is requested, then
        //      1) If about to render, ensure rendering occurs after publishing the invalid rectangles/region
        //      2) If not rendering, force a immediate WM_PAINT
        //      3) Otherwise, drop the request
        //         (Requests that arrive while rendering are illegal)
        //

        if (fSynchronousRedraw)
        {
            if (IsLockSet(VL_ACCUMULATINGINVALID))
            {
                TraceTagEx((tagView, TAG_NONAME,
                       "View : PostRenderView - Setting VF_FORCEPAINT"));

                SetFlag(VF_FORCEPAINT);
            }

            else if (   !IsLockSet(VL_UPDATEINPROGRESS)
                    &&  !IsLockSet(VL_RENDERINPROGRESS))
            {
                TraceTagEx((tagView, TAG_NONAME,
                       "View : PostRenderView - Calling DrawSynchronous"));

                DrawSynchronous();
            }
        }

        //
        //  For asynchronous requests, just note that the view needs closing
        //

        else
        {
            TraceTagEx((tagView, TAG_NONAME,
                   "View : PostRenderView - Calling PostCloseView"));

            PostCloseView();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     PostEndDeferTransition
//
//  Synopsis:   Ensure a call to EndDeferTransition is posted
//
//----------------------------------------------------------------------------

void
CView::PostEndDeferTransition()
{
    if (    IsActive()
        &&  !IsFlagSet(VF_PENDINGTRANSITION)
        &&  !Doc()->IsPrintDialogNoUI())
    {
        HRESULT hr;

        hr = GWPostMethodCall(this,
                              ONCALL_METHOD(CView,
                                            EndDeferTransitionCallback,
                                            enddefertransitioncallback),
                              0, FALSE, "CView::EndDeferTransitionCallback");
        SetFlag(VF_PENDINGTRANSITION);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawSynchronous
//
//  Synopsis:   Force a synchronous draw of the accumulated invalid areas
//
//  Arguments:  hdc - HDC into which to render
//
//----------------------------------------------------------------------------

void
CView::DrawSynchronous()
{
    Assert( !IsLockSet(VL_ACCUMULATINGINVALID)
        &&  !IsLockSet(VL_UPDATEINPROGRESS)
        &&  !IsLockSet(VL_RENDERINPROGRESS));
    Assert( !HasInvalid()
        ||  !Doc()->IsPrintDialogNoUI());

    TraceTagEx((tagView, TAG_NONAME,
           "View : DrawSynchronous"));

    if (HasInvalid())
    {
        CRect rcBounds;
            _rgnInvalid.GetBounds(&rcBounds);
        TraceTagEx((tagView, TAG_NONAME,
               "View : DrawSynchronous - HasInvalid of (%d, %d, %d, %d)",
               rcBounds.left,
               rcBounds.top,
               rcBounds.right,
               rcBounds.bottom));

        TraceTagEx((tagView, TAG_NONAME,
               "View : DrawSynchronous - Calling UpdateForm"));

        //
        //  Ensure all nested ActiveX/APPLETs receive pending SetObjectRects
        //  before receiving a WM_PAINT
        //  (This is necessary since Windows sends WM_PAINT to child HWNDs
        //   before their parent HWND. Since we delay sending SetObjectRects
        //   until we receive our own WM_PAINT, not forcing it through now
        //   causes it to come after the child HWND has painted.)
        //
        
        EnsureView();

        Doc()->UpdateForm();
    }

    TraceTagEx((tagView, TAG_NONAME,
           "View : DrawSynchronous - Exit"));
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureFocus
//
//  Synopsis:   Ensure the focus adorner is properly initialized
//
//----------------------------------------------------------------------------

void
CView::EnsureFocus()
{
#ifdef FOCUS_ADORNER
    if (    IsActive()
        &&  _pFocusAdorner)
    {
        _pFocusAdorner->EnsureFocus();

        CHECKRECURSION();
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureSize
//
//  Synopsis:   Ensure the top layout is in-sync with the current
//              device (not necessarily the view)
//
//  Arguments:  grfLayout - Current LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::EnsureSize(DWORD grfLayout)
{
    if (IsActive())
    {
        //
        //  Size the top level element to the view and start the CalcSize
        //   

        CLayout *   pLayout = GetRootLayout();

        if (     pLayout
            &&  !pLayout->IsDisplayNone())
        {
            //
            //  If LAYOUT_FORCE is set, re-size and re-attach the layout
            //

            if (grfLayout & LAYOUT_FORCE)       //  Force a resize & reattach
            {
                _pLayout = NULL;
            }

            if (_pLayout != pLayout)            //  Layout does not match.  Resize & reattach.
            {
                _pLayout = pLayout;
                ClearFlag(VF_SIZED);
                ClearFlag(VF_ATTACHED);
            }

            //
            //  Make sure current top layouts are sync'ed with view size
            //

            if (!IsSized(pLayout))
            {
                CSize      size;
                CCalcInfo   CI(&_dciDefaultMedia, pLayout);
        
                GetViewSize(&size);

                CI.SizeToParent((SIZE *)&size);
                CI._grfLayout = grfLayout | LAYOUT_MEASURE;
                CI._sizeParentForVert = CI._sizeParent;
             
                //  NOTE: Used only by CDoc::GetDocCoords
                if (IsFlagSet(VF_FULLSIZE))
                {
                    CI._smMode = SIZEMODE_FULLSIZE;
                }

                pLayout->CalcSize(&CI, (SIZE *)&size);
                
                SetFlag(VF_SIZED);
            }

            CHECKRECURSION();

            //
            //  If the current layout is not attached, attach it
            //

            if (!IsAttached(pLayout))
            {
                CDispNode * pDispNode;

                //
                //  Remove the previous top-most layout (if it exists)
                //

                Assert(_pDispRoot->CountChildren() <= 1);
                pDispNode = _pDispRoot->GetFirstChildNode();

                if (pDispNode)
                {
                    ExtractDispNode(pDispNode);
                }

                //
                //  Insert the current top-most layout
                //
                pDispNode = pLayout->GetElementDispNode();
                Assert(pDispNode);  // Canvas should *always* have a display node.

                if (pDispNode)
                {
                    pDispNode->SetPosition(g_Zero.pt);
                    _pDispRoot->InsertChildInFlow(pDispNode);


                    SetFlag(VF_ATTACHED);                
                }
            }

            CHECKRECURSION();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureViewCallback
//
//  Synopsis:   Process a posted call to EnsureView
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::EnsureViewCallback(DWORD_PTR dwContext)
{
    DWORD grfLayout = (DWORD)dwContext;
    // We need to ref the document because all external holders of the doc
    // could go away during EnsureView.  E.g., EnsureView may cause embedded
    // controls to transition state; that gives external code a chance to
    // execute, and they may release all refs to the doc.
    CServer::CLock Lock( Doc() );

    Assert(IsInitialized());
    Assert(IsActive());

    // GlobalWndOnMethodCall() will have cleared the callback entry in its array;
    // now clear the flag to keep its meaning sync'ed up.
    ClearFlag( VF_PENDINGENSUREVIEW );

    if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONVIEWD))
        g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONVIEWD, (IUnknown*)(IPrivateUnknown*)Doc());

    if (!EnsureView(grfLayout))
    {
        // Something in the middle of EnsureView like a script induced dialog box has
        // made us process window messages and pull this off.  We *can't* repost, because
        // it'll just get pulled off again and we'll spin.  If we can't go away happy, at
        // least we can go away valid.  Clear recursion flag to stop ASSERT.  (greglett)
        CLEARRECURSION();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     EndDeferTransitionCallback
//
//  Synopsis:   Process a posted call to EndDeferTransition
//
//----------------------------------------------------------------------------

void
CView::EndDeferTransitionCallback(DWORD_PTR dwContext)
{
    // We need to ref the document because all external holders of the doc
    // could go away during EnsureView.  E.g., EnsureView may cause embedded
    // controls to transition state; that gives external code a chance to
    // execute, and they may release all refs to the doc.
    CServer::CLock Lock( Doc() );

    Assert(IsInitialized());
    Assert(IsActive());

    // GlobalWndOnMethodCall() will have cleared the callback entry in its array;
    // now clear the flag to keep its meaning sync'ed up.
    ClearFlag( VF_PENDINGTRANSITION );

    EndDeferTransition();
}


//+---------------------------------------------------------------------------
//
//  Member:     FixWindowZOrder
//
//  Synopsis:   Fix Z order of child windows.
//
//  Arguments:  none
//              
//----------------------------------------------------------------------------

void
CView::FixWindowZOrder()
{
    if (IsActive())
    {
        CWindowOrderInfo windowOrderInfo;
        _pDispRoot->TraverseInViewAware((void*)&windowOrderInfo);
        windowOrderInfo.SetWindowOrder(&_pAryHwnd);
    }
}

CView::CWindowOrderInfo::CWindowOrderInfo()
{
    _pAryHwndNew = new (Mt(CView_aryHWND_pv)) CAryHWND;
    if (_pAryHwndNew)
    {
        _pAryHwndNew->EnsureSize(30);
    }

#if DBG==1 || defined(PERFTAGS)
    _cWindows = 0;
#endif
}

void
CView::CWindowOrderInfo::AddWindow(HWND hwnd)
{
    if (_pAryHwndNew)
    {
        HWND* pHwnd = _pAryHwndNew->Append();
        if (pHwnd != NULL)
            *pHwnd = hwnd;
    }

    TraceTag((tagChildWindowOrder, "add hwnd %x", hwnd));

#if DBG==1 || defined(PERFTAGS)
    _cWindows++;
#endif
}

void
CView::CWindowOrderInfo::SetWindowOrder(CAryHWND **ppAryHwnd)
{
    CAryHWND *pAryHwndOld = *ppAryHwnd;
    int iNew;
    const int sizeNew = _pAryHwndNew->Size();
    BOOL fBeginDeferWindowPosCalled = FALSE;
    HDWP hdwp = NULL;

    // for each HWND on the new list
    for (iNew=0;  iNew < sizeNew;  ++iNew)
    {
        HWND hwndPredNew = (iNew == 0) ? HWND_TOP : (*_pAryHwndNew)[iNew-1];

        TraceTag((tagChildWindowOrder, "change pred of %x to %x",
                (*_pAryHwndNew)[iNew], hwndPredNew));

        // start the notification, if this is the first changed HWND
        if (!fBeginDeferWindowPosCalled)
        {
            hdwp = ::BeginDeferWindowPos(30);
            fBeginDeferWindowPosCalled = TRUE;
        }

        if (hdwp)
        {
            hdwp = ::DeferWindowPos(
                    hdwp,
                    (*_pAryHwndNew)[iNew],
                    hwndPredNew,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
        }
        else
        {
            ::SetWindowPos(
                    (*_pAryHwndNew)[iNew],
                    hwndPredNew,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
        }
    }

    // finish the notification (if it was started at all)
#ifndef _MAC
    if (fBeginDeferWindowPosCalled && hdwp)
    {
        ::EndDeferWindowPos(hdwp);
    }
#endif

    // replace the old list with the new
    delete pAryHwndOld;
    *ppAryHwnd = _pAryHwndNew;
    _pAryHwndNew = NULL;

#if DBG==1 || defined(PERFTAGS)
    PerfDbgLog1(tagChildWindowOrder, this, "CView::CWindowOrderInfo::SetWindowOrder, %d windows", _cWindows);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     GetRootLayout
//
//  Synopsis:   Return the top-most layout of the associated CMarkup
//
//  Returns:    CLayout of the top-most element client (if available), NULL otherwise
//
//----------------------------------------------------------------------------

CLayout *
CView::GetRootLayout() const
{
    CElement *  pElement;
    
    pElement = CMarkup::GetCanvasElementHelper(Doc()->PrimaryMarkup());

    return pElement
                ? pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )
                : NULL;
}
//+---------------------------------------------------------------------------
//
//  Member:     ScrollRect
//
//  Synopsis:   Scroll pixels on screen
//
//  Arguments:  rcgScroll        - Rectangle that scrolled
//              sizegScrollDelta - Amount of the scroll
//
//----------------------------------------------------------------------------

void
CView::ScrollRect(
    const CRect&    rcgScroll,
    const CSize&    sizegScrollDelta,
    CDispScroller*  pScroller)
{
    TraceTagEx((tagView, TAG_NONAME,
           "View : ScrollRect - rc(%d, %d, %d, %d), delta(%d, %d)",
           rcgScroll.left,
           rcgScroll.top,
           rcgScroll.right,
           rcgScroll.bottom,
           sizegScrollDelta.cx,
           sizegScrollDelta.cy));

    Assert(Doc());
    
    HWND hwnd;
    HRGN hrgng;
    HDC scrollDC;
    
    if (!AllowScrolling() || (_grfLayout & LAYOUT_FORCE))
        goto JustInvalidate;
    
    hwnd = Doc()->GetHWND();
    if (!hwnd)
        goto JustInvalidate;

    // create region for invalid region created as a result of scrolling
    hrgng = ::CreateRectRgnIndirect(&g_Zero.rc);
    if (!hrgng)
        goto JustInvalidate;

    // get HDC to scroll
    scrollDC = ::GetDCEx(hwnd, NULL, DCX_CACHE|DCX_CLIPSIBLINGS);
    if (!scrollDC)
    {
        ::DeleteObject(hrgng);
        goto JustInvalidate;
    }
    Doc()->GetPalette(scrollDC);

    // adjust any invalid area we are holding that intersects the scroll rect
    if (HasInvalid())
    {
        CRegion rgngAdjust(rcgScroll);

        MergeInvalid();

        rgngAdjust.Intersect(_rgnInvalid);

        if (!rgngAdjust.IsEmpty())
        {
            _rgnInvalid.Subtract(rcgScroll);
            rgngAdjust.Offset(sizegScrollDelta);
            rgngAdjust.Intersect(rcgScroll);
            _rgnInvalid.Union(rgngAdjust);
        }
    }

    // the invalid area that was already published to Windows may need to be
    // adjusted too.  Get the update region for our window, mask it by the
    // rect that is being scrolled, and adjust it.
    if (::GetUpdateRgn(hwnd, hrgng, FALSE) != NULLREGION)
    {
        CRegion rgngUpdate(hrgng);
        rgngUpdate.Offset(sizegScrollDelta);
        rgngUpdate.Intersect(rcgScroll);
        Invalidate(rgngUpdate);
        ::ValidateRect(hwnd, (RECT*) &rcgScroll);
    }
    
    // make sure we don't have any clip region, or ScrollDC won't report
    // the correct invalid region
    ::SelectClipRgn(scrollDC, NULL);


    // do the scroll
    Verify(::ScrollDC(
        scrollDC, 
        sizegScrollDelta.cx, sizegScrollDelta.cy,
        &rcgScroll, &rcgScroll, hrgng, NULL));

    // invalidate area revealed by scroll
    Invalidate(hrgng, TRUE, TRUE);

    if (_pDispRoot->IsObscuringPossible())
    {
        CView::CEnsureDisplayTree edt(this);
        _pDispRoot->RequestRecalc();
        CLayout  * pLayout = GetRootLayout();
        CMarkup  *pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();
        Doc()->WaitForRecalc(pLayoutMarkup);
    }


    ::DeleteObject(hrgng);


    // release the HDC
    Verify(::ReleaseDC(hwnd, scrollDC));
    
    return;
    
JustInvalidate:
    Invalidate(rcgScroll, TRUE, TRUE);
}


//+---------------------------------------------------------------------------
//
//  Member:     ClearInvalid
//
//  Synopsis:   Clear accumulated invalid rectangles/region
//
//----------------------------------------------------------------------------

void
CView::ClearInvalid()
{
    if (IsActive())
    {
        ClearFlag(VF_INVALCHILDWINDOWS);
        _cInvalidRects = 0;
        _rgnInvalid.SetEmpty();
    }

    Assert(!HasInvalid());
}


//+---------------------------------------------------------------------------
//
//  Member:     PublishInvalid
//
//  Synopsis:   Push accumulated invalid rectangles/region into the
//              associated device (HWND)
//
//  Arguments:  grfLayout - Current LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::PublishInvalid(
    DWORD   grfLayout)
{
    if (IsActive())
    {
        CPoint  pt;

        MergeInvalid();

        if (!(grfLayout & LAYOUT_DEFERINVAL))
        {
            GetViewPosition(&pt);

            if (_rgnInvalid.IsComplex())
            {
                if (pt != g_Zero.pt)
                {
                    _rgnInvalid.Offset(pt.AsSize());
                }
            
                HRGN hrgn = _rgnInvalid.GetRegionForever();
                if(hrgn)
                {
                    Doc()->Invalidate(NULL, NULL, hrgn, (IsFlagSet(VF_INVALCHILDWINDOWS)
                                                      ? INVAL_CHILDWINDOWS
                                                                : 0));
                    //NOTE (mikhaill) -- something seem to be incorrect inside CDoc::Invalidate():
                    //some branches keep hrgn, and others just use and forget. So following deletion
                    //also can be incorrect
                    ::DeleteObject(hrgn);
                }
            }

            else if (!_rgnInvalid.IsEmpty())
            {
                CRect rcInvalid;
                    _rgnInvalid.GetBounds(&rcInvalid);

                rcInvalid.OffsetRect(pt.AsSize());

                Doc()->Invalidate(&rcInvalid, NULL, NULL, (IsFlagSet(VF_INVALCHILDWINDOWS)
                                                            ? INVAL_CHILDWINDOWS
                                                            : 0));
            }

            ClearInvalid();
        }
    }

    Assert( grfLayout & LAYOUT_DEFERINVAL
        ||  !HasInvalid());
}


//+---------------------------------------------------------------------------
//
//  Member:     MergeInvalid
//
//  Synopsis:   Merge the collected invalid rectangles/region into a
//              single CRegion object
//
//----------------------------------------------------------------------------

void
CView::MergeInvalid()
{
    if (_cInvalidRects)
    {
#if 1
        //
        //  Create the invalid region
        //  (If too many invalid rectangles arrived during initial load,
        //   union them all into a single rectangle)
        //

        if (    _cInvalidRects == MAX_INVALID
            &&  !IsFlagSet(VF_HASRENDERED))
        {
            CRect   rcUnion(_aryInvalidRects[0]);
            CRect   rcView;

            TraceTag((tagViewInvalidate, "merging inval rects, start with (%d, %d, %d, %d)",
                    rcUnion.left, rcUnion.top, rcUnion.right, rcUnion.bottom));

            for (int i = 1; i < _cInvalidRects; i++)
            {
                TraceTag((tagViewInvalidate, "  merge (%d, %d, %d, %d)",
                    _aryInvalidRects[i].left,
                    _aryInvalidRects[i].top,
                    _aryInvalidRects[i].right,
                    _aryInvalidRects[i].bottom
                    ));

                rcUnion.Union(_aryInvalidRects[i]);
            }

            GetViewRect(&rcView);
            rcUnion.IntersectRect(rcView);

            TraceTag((tagViewInvalidate, "add to inval region (%d, %d, %d, %d)",
                    rcUnion.left, rcUnion.top, rcUnion.right, rcUnion.bottom));

            _rgnInvalid.Union(rcUnion);
        }
        else
        {
            for (int i = 0; i < _cInvalidRects; i++)
            {
                TraceTag((tagViewInvalidate, "add to inval region (%d, %d, %d, %d)",
                    _aryInvalidRects[i].left,
                    _aryInvalidRects[i].top,
                    _aryInvalidRects[i].right,
                    _aryInvalidRects[i].bottom
                    ));

                _rgnInvalid.Union(_aryInvalidRects[i]);
            }
        }
#else
        //
        //  Strategy 3 (see CView::Invalidate): Always build a region from the individual rectangles
        //

        for (int i = 1; i < _cInvalidRects; i++)
        {
            _rgnInvalid.Union(_aryInvalidRects[i]);
        }
#endif

        _cInvalidRects = 0;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     OpenDisplayTree
//
//  Synopsis:   Open the display tree (if it exists)
//
//----------------------------------------------------------------------------

void
CView::OpenDisplayTree()
{
    Assert(IsActive() || !IsFlagSet(VF_TREEOPEN));

    if (IsActive())
    {
        // clients may call back during rendering.  We assume they are doing
        // something safe (like reading width or height of an element).
        if (IsLockSet(VL_RENDERINPROGRESS))
            return;
        
        Assert( (IsFlagSet(VF_TREEOPEN)  && _pDispRoot->DisplayTreeIsOpen())
            ||  (!IsFlagSet(VF_TREEOPEN) && !_pDispRoot->DisplayTreeIsOpen()));

        if (!IsFlagSet(VF_TREEOPEN))
        {
            SetFlag(VF_TREEOPEN);
            TraceTag((tagViewTreeOpen, "TID:%x %x +TreeOpen", GetCurrentThreadId(), this));
            _pDispRoot->OpenDisplayTree();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CloseDisplayTree
//
//  Synopsis:   Close the display tree
//
//----------------------------------------------------------------------------

void
CView::CloseDisplayTree()
{
    Assert(IsActive() || !IsFlagSet(VF_TREEOPEN));

    if (IsActive())
    {
        Assert( (IsFlagSet(VF_TREEOPEN) && _pDispRoot->DisplayTreeIsOpen())
            ||  (!IsFlagSet(VF_TREEOPEN) && !_pDispRoot->DisplayTreeIsOpen()));

        if (IsFlagSet(VF_TREEOPEN))
        {
            CServer::CLock lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
            //dmitryt: here the context resets to initial state.
            //         ToDo: set context to initial layout->device matrix instead of SetToIdentity
            _pRecalcContext->SetToIdentity();

            _pDispRoot->CloseDisplayTree(_pRecalcContext);
            ClearFlag(VF_TREEOPEN);
            TraceTag((tagViewTreeOpen, "TID:%x %x -TreeOpen", GetCurrentThreadId(), this));
        }

        CHECKRECURSION();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     WantOffscreenBuffer
//
//  Synopsis:   Determine if an offscreen buffer should be used
//
//  Returns:    TRUE if an offscreen buffer should be used, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::WantOffscreenBuffer() const
{
    return !(   (Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_OFFSCREEN)
            ||  (   g_pHtmPerfCtl
                &&  (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_OFFSCREEN))
            ||  !IsFlagSet(VF_HASRENDERED)
            ||  (!Doc()->_pOptionSettings->fForceOffscreen &&
                    g_fTerminalServer && !g_fTermSrvClientSideBitmaps)
            );
}


//+---------------------------------------------------------------------------
//
//  Member:     AllowOffscreenBuffer
//
//  Synopsis:   Determine if an offscreen buffer can be used
//              NOTE: This should override all other checks (e.g., WantOffscreenBuffer)
//
//  Returns:    TRUE if an offscreen buffer can be used, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::AllowOffscreenBuffer() const
{
#if DBG == 1
    static int g_fDisallowOffscreenBuffer = 0;
#endif
        return (!Doc()->IsPrintDialogNoUI()
#if DBG == 1
               && !IsPerfDbgEnabled(tagNoOffScr)
               && !g_fDisallowOffscreenBuffer
#endif
        );
}

//+---------------------------------------------------------------------------
//
//  Member:     AllowScrolling
//
//  Synopsis:   Determine if scrolling of the DC is allowed
//
//  Returns:    TRUE if scrolling is allowed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::AllowScrolling() const
{
    return  !Doc()->IsPrintDialogNoUI()
        &&  !g_fInHomePublisher98;
}


//+---------------------------------------------------------------------------
//
//  Member:     AllowSmoothScrolling
//
//  Synopsis:   Determine if smooth scrolling is allowed
//
//  Returns:    TRUE if smooth scrolling is allowed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::AllowSmoothScrolling() const
{
    return  Doc()->_pOptionSettings->fSmoothScrolling
        WHEN_DBG( && !IsTagEnabled(tagNoSmoothScroll) )
        &&  !g_fTerminalServer
        &&  AllowScrolling();
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     DumpDisplayTree
//
//  Synopsis:   Dump the display tree
//
//----------------------------------------------------------------------------

void
CView::DumpDisplayTree() const
{
    if (IsActive())
    {
        _pDispRoot->DumpDisplayTree();
    }
}
#endif


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     IsDisplayTreeOpen
//
//  Synopsis:   Check if the display tree is open
//
//----------------------------------------------------------------------------

BOOL
CView::IsDisplayTreeOpen() const
{
    return (    IsActive()
            &&  _pDispRoot
            &&  _pDispRoot->DisplayTreeIsOpen());
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     AddTask
//
//  Synopsis:   Add a task to the view-task queue
//
//  Arguments:  pv        - Object to call
//              vtt       - Task type
//              grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

HRESULT
CView::AddTask(
    void *                  pv,
    CViewTask::VIEWTASKTYPE vtt,
    DWORD                   grfLayout,
    LONG                    lData, 
    DWORD                   dwExtra)
{
    if (!IsActive())
        return S_OK;

    CViewTask       vt(pv, vtt, lData, grfLayout, dwExtra);
    CAryVTasks *    pTaskList = GetTaskList(vtt);
    int             i;
    HRESULT         hr;

    AssertSz(Doc(), "View used while CDoc is not inplace active");
    AssertSz(_pDispRoot, "View used while CDoc is not inplace active");
    Assert(!(grfLayout & LAYOUT_NONTASKFLAGS));
    Assert(!(grfLayout & LAYOUT_TASKDELETED));

    i = vtt != CViewTask::VTT_EVENT
            ? FindTask(pTaskList, vt)
            : -1;
        
        if (i < 0)
        {
            hr = pTaskList->AppendIndirect(&vt);
            
            if (SUCCEEDED(hr))
        {
            PostCloseView(vt.IsFlagSet(LAYOUT_BACKGROUND), 
                          (vtt == CViewTask::VTT_EVENT));
        }
        }
        else
        {
            CViewTask * pvt = &(*pTaskList)[i];
            
            pvt->AddFlags(grfLayout);
            Assert(!(pvt->IsFlagsSet(LAYOUT_BACKGROUND | LAYOUT_PRIORITY)));
            
            hr = S_OK;
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     ExecuteLayoutTasks
//
//  Synopsis:   Execute pending layout tasks in document source order
//
//  Arguments:  grfLayout - Collections of LAYOUT_xxxx flags
//
//  Returns:    TRUE if all tasks were processed, FALSE otherwise
//
//----------------------------------------------------------------------------

#pragma warning(disable:4706)           // Assignment within a conditional

BOOL
CView::ExecuteLayoutTasks(
    DWORD   grfLayout)
{
    Assert(IsActive());

    CViewTask * pvtTask;
    DWORD       fLayout = (grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagLayoutTasks, TAG_NONAME|TAG_INDENT, "(CView::ExecuteLayoutTasks [%s]", ((fLayout & LAYOUT_MEASURE) ? "MEASURE" : ((fLayout & LAYOUT_POSITION) ? "POSITION" : "ADORNER" )) ));

    while (pvtTask = GetNextTaskInSourceOrder(CViewTask::VTT_LAYOUT, fLayout))
    {
        Assert(pvtTask->IsType(CViewTask::VTT_LAYOUT));
        Assert(pvtTask->GetLayout());
        Assert(!(pvtTask->GetFlags() & LAYOUT_NONTASKFLAGS));
        Assert(!pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

        //
        //  Mark task has having completed the current LAYOUT_MEASURE/POSITION/ADORNERS pass
        //

        pvtTask->_grfLayout &= ~fLayout;

        //
        //  Execute the task
        //

        pvtTask->GetLayout()->DoLayout(grfLayout);

        CHECKRECURSION();
    }

    if (fLayout & LAYOUT_ADORNERS)
    {
        _aryTaskLayout.DeleteAll();
    }

    TraceTagEx((tagLayoutTasks, TAG_NONAME|TAG_OUTDENT, ")CView::ExecuteLayoutTasks - %d tasks remaining", _aryTaskLayout.Size() ));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     ExecuteEventTasks
//
//  Synopsis:   Execute pending event-firing tasks in receiving order
//
//  Arguments:  grfLayout - Collections of LAYOUT_xxxx flags
//
//  Returns:    TRUE if all tasks were processed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::ExecuteEventTasks(DWORD grfLayout)
{
    Assert(IsActive());

    if (grfLayout & LAYOUT_DEFEREVENTS)
        return (_aryTaskEvent.Size() == 0);

    CElement *      pElement;
    CAryVTaskEvent  aryTaskEvent;
    CViewTask *     pvtTask;
    int             cTasks;

    aryTaskEvent.Copy(_aryTaskEvent, FALSE);
    _aryTaskEvent.DeleteAll();

    PerfDbgLog1(tagCViewEnsure, this, "Firing %d tasks", aryTaskEvent.Size());

    //
    //  Ensure the elements stay for the duration of all pending events
    //  (The reference count is increment once per-pending event)
    //


    cTasks = aryTaskEvent.Size();
    for (pvtTask = &((CAryVTaskEvent &) aryTaskEvent)[0];
        cTasks;
        pvtTask++, cTasks--)
    {
        Assert(pvtTask->GetElement());

        pElement = pvtTask->GetElement();
        pElement->AddRef();
        pElement->_fHasPendingEvent = FALSE;
    }

    //
    //  Fire the events and release the hold on the elements
    //

    cTasks = aryTaskEvent.Size();
    for (pvtTask = &((CAryVTaskEvent &) aryTaskEvent)[0];
        cTasks;
        pvtTask++, cTasks--)
    {
        Assert(pvtTask->IsType(CViewTask::VTT_EVENT));
        Assert(pvtTask->GetElement());
        Assert(!pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

        pElement = pvtTask->GetElement();

        switch (pvtTask->GetEventDispID())
        {
            // Specila dispid for remeasure requests that come in
            // while executing position/adorner tasks.
        case STDPROPID_XOBJ_WIDTH:
            PerfDbgLog(tagCViewEnsure, this, "+RemeasureElement");
            pElement->RemeasureElement();
            PerfDbgLog2(tagCViewEnsure, this, "-RemeasureElement(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            break;

        case DISPID_EVMETH_ONSCROLL:
            pElement->Fire_onscroll();
            break;

        case DISPID_EVMETH_ONMOVE:
            PerfDbgLog(tagCViewEnsure, this, "+Fire onmove");
            pElement->Fire_onmove();
            PerfDbgLog2(tagCViewEnsure, this, "-Fire onmove(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            break;

        case DISPID_EVMETH_ONRESIZE:
            if (    Doc()->_state >= OS_INPLACE
                &&  Doc()->_pWindowPrimary->_fFiredOnLoad )
            {
                if (    pElement == Doc()->PrimaryMarkup()->GetCanvasElement()
                    &&  Doc()->_pWindowPrimary)
                {
                    PerfDbgLog(tagCViewEnsure, this, "+Fire window oresize");
                    Doc()->_pWindowPrimary->Fire_onresize();
                    PerfDbgLog(tagCViewEnsure, this, "-Fire window oresize");
                }
                else
                {
                    PerfDbgLog(tagCViewEnsure, this, "+Fire oresize");
                    pElement->Fire_onresize();
                    PerfDbgLog2(tagCViewEnsure, this, "-Fire oresize(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
                }
            }
            break;

        case DISPID_EVMETH_ONLAYOUTCOMPLETE:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onlayoutcomplete");
                pElement->Fire_onlayoutcomplete(FALSE);
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onlayoutcomplete(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;

        case DISPID_EVMETH_ONLINKEDOVERFLOW:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onlayoutcomplete");
                pElement->Fire_onlayoutcomplete(TRUE, pvtTask->GetExtra());
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onlayoutcomplete(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;

        case DISPID_EVMETH_ONPAGE:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onpage");
                pElement->Fire_onpage();
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onpage(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"" ? pElement->GetIdentifier() : L"");
            }
            break;

        case DISPID_EVMETH_ONMULTILAYOUTCLEANUP:
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onmultilayoutcleanup");
                pElement->SendNotification( NTYPE_MULTILAYOUT_CLEANUP );
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onmultilayoutcleanup(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;
        case DISPID_EVMETH_ONPROPERTYCHANGE:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                HRESULT     hr;
                BSTR        strName = NULL;

                PerfDbgLog(tagCViewEnsure, this, "+Fire onpropertychange");
                hr = THR_NOTRACE(pElement->GetMemberName(pvtTask->GetExtra(), &strName));
                if (hr)
                {
                    strName = NULL;
                }

                if (strName)
                {
                    pElement->Fire_onpropertychange(strName);
                    SysFreeString(strName);
                }
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onpropertychange(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;

        default:
            break;
        }

        CHECKRECURSION();

        pElement->Release();
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     FindTask
//
//  Synopsis:   Locate a task in the task array
//
//  Arguments:  vt  - Task to remove
//
//  Returns:    If found, index of task in task array
//              Otherwise, -1
//
//----------------------------------------------------------------------------

#pragma warning(default:4706)           // Assignment within a conditional

int
CView::FindTask(
    const CAryVTasks *  pTaskList,
    const CViewTask &   vt) const
{
    int     i;
    BOOL    fExactMatch = !!vt.GetObject();

    Assert(IsActive() || !(pTaskList->Size()));

    if (!IsActive())
        return -1;

    for (i = pTaskList->Size()-1; i >= 0; i--)
    {
        const CViewTask & vtCur = ((CAryVTasks &)(*pTaskList))[i];

        if (vtCur.IsFlagSet(LAYOUT_TASKDELETED))
            continue;
        
        //  If the _pv field is supplied, look for an exact match
        if (fExactMatch)
        {
            if (vt == vtCur)
                break;
        }

        //  Otherwise, match only on task type
        else
        {
            if (vt.IsType(vtCur))
                break;
        }
    }

    return i;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetTask
//
//  Synopsis:   Retrieve the a specific task from the appropriate task queue
//
//  Arguments:  vt - CViewTask to retrieve
//
//  Returns:    CViewTask pointer if found, NULL otherwise
//
//----------------------------------------------------------------------------

CViewTask *
CView::GetTask(
    const CViewTask & vt) const
{
    CAryVTasks *    paryTasks = GetTaskList(vt.GetType());
    int             iTask     = FindTask(paryTasks, vt);

    Assert(IsActive() || iTask < 0);
    Assert(iTask < 0 || !((* paryTasks)[iTask]).IsFlagSet(LAYOUT_TASKDELETED));

    return iTask >= 0
                ? &((* paryTasks)[iTask])
                : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetNextTask
//
//  Synopsis:   Retrieve the next task of the specified task type
//
//  Arguments:  vtt       - VIEWTASKTYPE to search for
//
//  Returns:    CViewTask pointer if found, NULL otherwise
//
//----------------------------------------------------------------------------

CViewTask *
CView::GetNextTask(
    CViewTask::VIEWTASKTYPE vtt ) const
{
    CViewTask *     pvtTask = NULL;
    CAryVTasks *    pTaskList = GetTaskList(vtt);
    int             cTasks;

    cTasks = pTaskList->Size();

    Assert(IsActive() || !cTasks);

    if (cTasks)
    {
        for (pvtTask = &((CAryVTasks &)(* pTaskList))[0];
             cTasks && (pvtTask->IsFlagSet(LAYOUT_TASKDELETED) || !pvtTask->IsType(vtt));
             pvtTask++, cTasks--);
    }

    Assert(cTasks <= 0 || !pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

    return (cTasks > 0
                ? pvtTask
                : NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetNextTaskInSourceOrder
//
//  Synopsis:   Retrieve the next task, in document source order, of the
//              specified task type
//
//  Arguments:  vtt       - VIEWTASKTYPE to search for
//              grfLayout - LAYOUT_MEASURE/POSITION/ADORNERS filter
//
//  Returns:    CViewTask pointer if found, NULL otherwise
//
//----------------------------------------------------------------------------

CViewTask *
CView::GetNextTaskInSourceOrder(
    CViewTask::VIEWTASKTYPE vtt,
    DWORD                   grfLayout) const
{
    CViewTask *     pvtTask   = NULL;
    CAryVTasks *    pTaskList = GetTaskList(vtt);
    int             cTasks;

    cTasks = pTaskList->Size();

    Assert(IsActive() || !cTasks);

    if (cTasks > 1)
    {
        CViewTask * pvt;
        int         si, siTask;

        siTask = INT_MAX;

        for (pvt = &((CAryVTasks &)(* pTaskList))[0]; cTasks; pvt++, cTasks--)
        {
            if (    !pvt->IsFlagSet(LAYOUT_TASKDELETED)
                &&  pvt->IsFlagsSet(grfLayout)
                &&  pvt->IsType(vtt))
            {
                Assert(pvt->GetObject());

                si = pvt->GetSourceIndex();
                if (si < siTask)
                {
                    siTask  = si;
                    pvtTask = pvt;
                }
            }
        }
    }
    else if (   cTasks
            &&  !((CAryVTasks &)(* pTaskList))[0].IsFlagSet(LAYOUT_TASKDELETED)
            &&  ((CAryVTasks &)(* pTaskList))[0].IsFlagsSet(grfLayout)
            &&  ((CAryVTasks &)(* pTaskList))[0].IsType(vtt))
    {
        Assert(cTasks == 1);
        pvtTask = &((CAryVTasks &)(* pTaskList))[0];
    }

    Assert(!pvtTask || !pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

    return pvtTask;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveTask
//
//  Synopsis:   Remove a task from the view-task queue
//
//              NOTE: This routine is safe to call with non-existent tasks
//
//  Arguments:  iTask - Index of task to remove, -1 the task is non-existent
//
//----------------------------------------------------------------------------

void
CView::RemoveTask(
    CAryVTasks * pTaskList, int iTask)
{
    Assert(IsActive() || !(pTaskList->Size()));

    if (iTask >= 0 && iTask < pTaskList->Size())
    {
        if (    pTaskList != &_aryTaskLayout
            ||  !IsLockSet(VL_TASKSINPROGRESS))
        {
            pTaskList->Delete(iTask);
        }
        else
        {
            (*pTaskList)[iTask]._grfLayout |= LAYOUT_TASKDELETED;
        }
    }
}

#ifdef ADORNERS
//+---------------------------------------------------------------------------
//
//  Member:     AddAdorner
//
//  Synopsis:   Add a CAdorner to the list of adorners
//
//              Adorners are kept in order by their start cp. If two (or more)
//              have the same start cp, they are sorted by their end cp.
//
//  Arguments:  pAdorner - CAdorner to add
//
//----------------------------------------------------------------------------

HRESULT
CView::AddAdorner(
    CAdorner *  pAdorner)
{
    long    cpStartNew, cpEndNew;
    long    iAdorner, cAdorners;
    HRESULT hr = E_FAIL;

    if (IsActive())
    {
        Assert(pAdorner);

        pAdorner->GetRange(&cpStartNew, &cpEndNew);

        iAdorner  = 0;
        cAdorners = _aryAdorners.Size();

        if (cAdorners)
        {
            CAdorner ** ppAdorner;
            long        cpStart, cpEnd;

            for (ppAdorner = &(_aryAdorners[0]);
                iAdorner < cAdorners;
                iAdorner++, ppAdorner++)
            {
                (*ppAdorner)->GetRange(&cpStart, &cpEnd);

                if (    cpStartNew < cpStart
                    ||  (   cpStartNew == cpStart
                        &&  cpEndNew   <  cpEnd))
                    break;
            }
        }

        Assert(iAdorner <= cAdorners);

        hr = _aryAdorners.InsertIndirect(iAdorner, &pAdorner);

        if (SUCCEEDED(hr))
        {
            CElement *  pElement = pAdorner->GetElement();

            Verify(OpenView());
            Assert( cpEndNew >= cpStartNew );
            AccumulateMeasuredRange( cpStartNew , (cpEndNew - cpStartNew) );


            if (    pElement
                &&  pElement->ShouldHaveLayout())
            {
                pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->SetIsAdorned(TRUE);
            }
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     DeleteAdorners
//
//  Synopsis:   Delete and remove all adorners
//
//----------------------------------------------------------------------------

void
CView::DeleteAdorners()
{
    long    iAdorner  = 0;
    long    cAdorners = _aryAdorners.Size();

    Assert(IsActive() || !cAdorners);

    if (cAdorners)
    {
        CAdorner ** ppAdorner;

        for (ppAdorner = &(_aryAdorners[0]);
            iAdorner < cAdorners;
            iAdorner++, ppAdorner++)
        {
            (*ppAdorner)->Destroy();
        }

        _aryAdorners.DeleteAll();

        _pFocusAdorner = NULL;
    }

    Assert(!_pFocusAdorner);
}

//+---------------------------------------------------------------------------
//
//  Member:     GetAdorner
//
//  Synopsis:   Find the next adorner associated with the passed element
//
//  Arguments:  pElement  - CElement associated with the adorner
//              piAdorner - Index at which to begin the search
//
//  Returns:    Index of adorner if found, -1 otherwise
//
//----------------------------------------------------------------------------

long
CView::GetAdorner(
    CElement *  pElement,
    long        iAdorner) const
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (!IsActive())
        return -1;

    long    cAdorners = _aryAdorners.Size();

    Assert(iAdorner >= 0);

    if (iAdorner < cAdorners)
    {
        CAdorner ** ppAdorner;

        for (ppAdorner = &(((CAryAdorners &)_aryAdorners)[iAdorner]);
            iAdorner < cAdorners;
            iAdorner++, ppAdorner++)
        {
            if ((*ppAdorner)->GetElement() == pElement)
                break;
        }
    }

    return iAdorner < cAdorners
                ? iAdorner
                : -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveAdorner
//
//  Synopsis:   Remove the specified adorner
//
//  Arguments:  pAdorner - CAdorner to remove
//
//----------------------------------------------------------------------------

void
CView::RemoveAdorner(
    CAdorner *  pAdorner,
    BOOL        fCheckForLast)
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (IsActive())
    {
        CElement *  pElement = pAdorner->GetElement();

        Assert(IsInState(VS_OPEN));

        if (_aryAdorners.DeleteByValueIndirect(&pAdorner))
        {
            pAdorner->Destroy();
        }

        if (    fCheckForLast
            &&  pElement
            &&  pElement->CurrentlyHasAnyLayout())
        {
            pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->SetIsAdorned(HasAdorners(pElement));
        }
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     CBiew::CompareZOrder
//
//  Synopsis:   Compare the z-order of two display nodes
//
//  Arguments:  pDispNode1 - Display node owned by this display client
//              pDispNode2 - Display node to compare against
//
//  Returns:    Greater than zero if pDispNode1 is greater
//              Less than zero if pDispNode1 is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------

//
// TO BE USED FOR ADORNER COMPARISONS ONLY. Otherwise we return 0.
//

long        
CView::CompareZOrder(CDispNode const* pDispNode1, CDispNode const* pDispNode2)
{
    int i;
    int indexDisp1 = -1;
    int indexDisp2 = -1;
    
    for ( i = 0; i < _aryAdorners.Size(); i ++ )
    {
        if ( _aryAdorners[i]->GetDispNode() == pDispNode1)
        {
            indexDisp1 = i;
            if ( indexDisp2 != - 1)
                break;
        }

        if ( _aryAdorners[i]->GetDispNode() == pDispNode2)
        {
            indexDisp2 = i;
            if ( indexDisp1 != - 1)
                break;
        }        
    }

    if ( indexDisp1 != -1 && indexDisp2 != -1 )
    {
        return indexDisp1 <= indexDisp2 ? 1 : - 1;
    }
    else
        return 0;
}

#endif // ADORNERS

//+---------------------------------------------------------------------------
//
//  Member:     AccumulateMeasuredRanged
//
//  Synopsis:   Accumulate the measured range
//
//  Arguments:  cp  - First character of the range
//              cch - Number of characters in the range
//
//----------------------------------------------------------------------------

void
CView::AccumulateMeasuredRange(
    long    cp,
    long    cch)
{
    if (IsActive())
    {
        long    cpEnd = cp + cch;

        Assert(IsInState(VS_OPEN));

        if (_cpStartMeasured < 0)
        {
            _cpStartMeasured = cp;
            _cpEndMeasured   = cpEnd;
        }
        else
        {
            _cpStartMeasured = min(_cpStartMeasured, cp);
            _cpEndMeasured   = max(_cpEndMeasured,   cpEnd);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     AccumulateTranslatedRange
//
//  Synopsis:   Accumulate the translated range
//
//  Arguments:  size - Amount of translation
//              cp   - First character of the range
//              cch  - Number of characters in the range
//
//----------------------------------------------------------------------------

void
CView::AccumulateTranslatedRange(
    const CSize &   size,
    long            cp,
    long            cch)
{
    if (IsActive())
    {
        long    cpEnd = cp + cch;

        Assert(IsInState(VS_OPEN));

        if (_cpStartTranslated < 0)
        {
            _cpStartTranslated = cp;
            _cpEndTranslated   = cpEnd;
            _sizeTranslated    = size;
        }
        else
        {
            _cpStartTranslated = min(_cpStartTranslated, cp);
            _cpEndTranslated   = max(_cpEndTranslated,   cpEnd);

            if (_sizeTranslated != size)
            {
                _sizeTranslated = g_Zero.size;
            }
        }
    }
}

#ifdef ADORNERS
//+---------------------------------------------------------------------------
//
//  Member:     UpdateAdorners
//
//  Synopsis:   Notify the adorners within the measured and translated ranges
//              possible size/position changes
//
//  Arguments:  grfLayout - Current LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::UpdateAdorners(
    DWORD   grfLayout)
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (!IsActive())
        return;

    Assert( _cpStartMeasured <  0
        ||  _cpEndMeasured   >= 0);
    Assert(_cpStartMeasured <= _cpEndMeasured);
    Assert( _cpStartTranslated <  0
        ||  _cpEndTranslated   >= 0);
    Assert(_cpStartTranslated <= _cpEndTranslated);

    // <bug 33937 cure>
    // This addition can force _pFocusAdorner to be handled twice.
    // Optimization is discarded in favor of smaller code change.
    if (_bUpdateFocusAdorner)
    {
        _bUpdateFocusAdorner = FALSE;
        if(_pFocusAdorner)
        {
            _pFocusAdorner->ShapeChanged();
            _pFocusAdorner->PositionChanged();
        }
    }
    // </bug 33937 cure>

    //
    //  If adorners and a dirty range exists, update the affected adorners
    //

    if (    _aryAdorners.Size()
        &&  HasDirtyRange())
    {
        long        iAdorner;
        long        cAdorners;
        long        cpStart, cpEnd;
        long        cpFirst, cpLast;
        CAdorner ** ppAdorner;

        //
        // TODO marka - profile this sometime. Is it worth maintaining array of adorners sorted by cp ?
        // 
        
        cAdorners = _aryAdorners.Size();

        cpFirst = LONG_MAX;
        cpLast = LONG_MIN;

        for(long i = 0; i < cAdorners; i++)
        {
            _aryAdorners[i]->GetRange(&cpStart, &cpEnd);
    
            cpFirst = min(cpFirst, cpStart);
            cpLast  = max(cpLast, cpEnd);
        }

        //
        //  If a measured range intersects the adorners, update the affected adorners
        //

        if (    HasMeasuredRange() 
            && IsRangeCrossRange(cpFirst, cpLast, _cpStartMeasured, _cpEndMeasured))
        {
            //
            //  Find the first adorner to intersect the range
            //

            cpStart = LONG_MAX;
            cpEnd   = LONG_MIN;

            iAdorner  = 0;
            cAdorners = _aryAdorners.Size();

            for (ppAdorner = &(_aryAdorners[iAdorner]);
                iAdorner < cAdorners;
                iAdorner++, ppAdorner++)
            {
                (*ppAdorner)->GetRange(&cpStart, &cpEnd);

                if (cpEnd >= _cpStartMeasured)
                    break;
            }

            //
            //  Notify all adorners that intersect the range
            //

            cAdorners -= iAdorner;

            if (cAdorners)
            {
                // bug 99829, the adorener is at the end of the document
                // so cpStart and _cpEndMeasured are equal.
                while (cpStart <= _cpEndMeasured)
                {
                    (*ppAdorner)->ShapeChanged();
                    (*ppAdorner)->PositionChanged();

                    CHECKRECURSION();

                    cAdorners--;
                    if (!cAdorners)
                        break;

                    ppAdorner++;
                    (*ppAdorner)->GetRange(&cpStart, &cpEnd);
                }
            }
        }

        //
        //  If a translated range intersects the adorners, update the affected adorners
        //

        if (    HasTranslatedRange()
            && IsRangeCrossRange(cpFirst, cpLast, _cpStartTranslated, _cpEndTranslated))
        {
            CSize * psizeTranslated;

            //
            //  If a measured range exists,
            //  shrink the translated range such that they do not overlap
            //

            if (HasMeasuredRange())
            {
                if (_cpEndMeasured <= _cpEndTranslated)
                {
                    _cpStartTranslated = max(_cpStartTranslated, _cpEndMeasured);
                }

                if (_cpStartMeasured >= _cpStartTranslated)
                {
                    _cpEndTranslated = min(_cpEndTranslated, _cpStartMeasured);
                }

                //
                // marka - Translated can be < Measured range
                //
                if ( ( _cpEndTranslated < _cpEndMeasured ) &&
                     ( _cpStartTranslated > _cpStartMeasured ) )
                {
                    _cpEndTranslated = 0;
                    _cpStartTranslated = 0;
                }
            }

            if (_cpStartTranslated < _cpEndTranslated)
            {
                //
                //  Find the first adorner to intersect the range
                //

                cpStart = LONG_MAX;
                cpEnd   = LONG_MIN;

                iAdorner  = 0;
                cAdorners = _aryAdorners.Size();

                psizeTranslated = _sizeTranslated != g_Zero.size
                                        ? &_sizeTranslated
                                        : NULL;

                for (ppAdorner = &(_aryAdorners[iAdorner]);
                    iAdorner < cAdorners;
                    iAdorner++, ppAdorner++)
                {
                    (*ppAdorner)->GetRange(&cpStart, &cpEnd);

                    if (cpStart >= _cpStartTranslated)
                        break;
                }

                //
                //  Notify all adorners that intersect the range
                //

                cAdorners -= iAdorner;

                if (cAdorners)
                {
                    while (cpStart < _cpEndTranslated)
                    {
                        (*ppAdorner)->PositionChanged(psizeTranslated);

                        CHECKRECURSION();

                        cAdorners--;
                        if (!cAdorners)
                            break;

                        ppAdorner++;
                        (*ppAdorner)->GetRange(&cpStart, &cpEnd);
                    }
                }
            }
        }
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SetRenderSurface
//
//  Synopsis:   Set destination rendering surface.
//
//  Arguments:  hdc         DC destination
//              pSurface    IDirectDrawSurface
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CView::SetRenderSurface(
        const XHDC& hdc,
        IDirectDrawSurface *pDDSurface)
{
    if (_pRenderSurface)
        delete _pRenderSurface;
    _pRenderSurface = NULL;
    
    if (!hdc.IsEmpty())
        _pRenderSurface = new CDispSurface(hdc);
    else if (pDDSurface)
        _pRenderSurface = new CDispSurface(pDDSurface);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SetOffscreenBuffer
//              
//  Synopsis:   The primary place of policy regarding our offscreen buffering
//              The only other policy is in the CDispSurface->IsCompat that
//              determines if a cached surface is acceptable.
//              
//  Arguments:  
//              
//  Notes:      fWantOffscreen indicates that the document (and host) want offscreen buffering
//              fAllowOffscreen indicates that the document (and host) will allow offscreen buffering
//              
//----------------------------------------------------------------------------
void
CView::SetOffscreenBuffer(HPALETTE hpal, short bufferDepth, BOOL fDirectDraw, BOOL fTexture, BOOL fWantOffscreen, BOOL fAllowOffscreen)
{
    PerfDbgExtern(tagOscUseDD);
    PerfDbgExtern(tagNoTile);
    PerfDbgExtern(tagOscFullsize);
    PerfDbgExtern(tagOscTinysize);
    PerfDbgExtern(tagNoOffScr);

    Assert(_pRenderSurface != NULL);
    
    // If the host won't allow offscreen buffering then we won't do it
    if (!fAllowOffscreen)
    {
        ReleaseOffscreenBuffer();
        return;
    }

    HDC hdc = _pRenderSurface->GetRawDC();

    short bufferDepthDestination = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    if (bufferDepth == -1)
        fDirectDraw = TRUE;

    if (bufferDepth <= 0)
        bufferDepth = bufferDepthDestination;

#if DBG == 1
    if (IsTagEnabled(tagOscUseDD))
        fDirectDraw = TRUE;
#endif

    if (bufferDepth != bufferDepthDestination)
    {
        fDirectDraw = TRUE;     // GDI can't buffer at a bit depth different from the destination
        fWantOffscreen = TRUE;
    }
    else if (fDirectDraw && !_pRenderSurface->VerifyGetSurfaceFromDC())
        fWantOffscreen = TRUE;

    // If we can avoid buffering, we should

    if (!fWantOffscreen)
    {
        ReleaseOffscreenBuffer();
        return;
    }

    // We are definitely going to buffer offscreen
    // Now we determine the size of the buffer

    CSize sizeBuffer = _pDispRoot->GetSize();

    //
    // If we're using DD then we don't tile.  This is mostly because DA and filters don't handle
    // banding very well.  We really need a new status bit that indicates poor tiling support
    //

#ifndef MAC
    if (!fDirectDraw)
        sizeBuffer.cy = s_cBUFFERLINES;
#endif

#if DBG == 1
    if (IsTagEnabled(tagOscFullsize))
    {
        sizeBuffer.cy = _pDispRoot->GetSize().cy;
    }
    else if (IsPerfDbgEnabled(tagOscTinysize))
    {
        sizeBuffer.cy = 8;
    }
    else if (fDirectDraw && IsTagEnabled(tagOscForceDDBanding))
    {
        sizeBuffer.cy = s_cBUFFERLINES;
    }
#endif

    Assert(sizeBuffer.cx > 0 && sizeBuffer.cy > 0);

    if (!_pOffscreenBuffer || !_pOffscreenBuffer->IsCompat(sizeBuffer.cx, sizeBuffer.cy, bufferDepth, hpal, fDirectDraw, fTexture))
    {
        ReleaseOffscreenBuffer();

        // if we get this far under TerminalServer, ask whether it supports
        // a big enough client-side bitmap before proceeding.  This code
        // came from the TerminalServer folks.

        if (g_fTerminalServer && !fDirectDraw &&
            !Doc()->_pOptionSettings->fForceOffscreen &&
            ! ( _pRenderSurface->GetRawDC() == _hdcTSBufferFailed &&
                sizeBuffer == _sizeTSBufferFailed )
            )
        {
            ICA_DEVICE_BITMAP_INFO info;
            INT rc, bSucc;

            info.cx = sizeBuffer.cx;
            info.cy = sizeBuffer.cy;

            bSucc = ExtEscape(
                        _pRenderSurface->GetRawDC(),
                        ESC_GET_DEVICEBITMAP_SUPPORT,
                        sizeof(info),
                        (LPSTR)&info,
                        sizeof(rc),
                        (LPSTR)&rc
                        );

            // if TS won't support the client-side bitmap for the buffer,
            // remember the DC and size so we don't keep making the same
            // doomed call.

            if (!bSucc || !rc)
            {
                _hdcTSBufferFailed = _pRenderSurface->GetRawDC();
                _sizeTSBufferFailed = sizeBuffer;
                return;
            }
            else
            {
                _hdcTSBufferFailed = NULL;
            }
        }

        _pOffscreenBuffer = _pRenderSurface->CreateBuffer(
            sizeBuffer.cx, 
            sizeBuffer.cy, 
            bufferDepth,
            hpal, 
            fDirectDraw,
            fTexture);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CView::ReleaseOffscreenBuffer
//
//  Synopsis:   Release the buffer used to perform offscreen rendering.
//
//  Arguments:  none
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CView::ReleaseOffscreenBuffer()
{
    delete _pOffscreenBuffer;
    _pOffscreenBuffer = NULL;
}

                
//+---------------------------------------------------------------------------
//
//  Member:     CView::ReleaseRenderSurface
//
//  Synopsis:   Release the surface used for rendering.
//
//  Arguments:  none
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CView::ReleaseRenderSurface()
{
    delete _pRenderSurface;
    _pRenderSurface = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CView::SmoothScroll
//
//  Synopsis:   Set new scroll offset smoothly if appropriate.
//
//  Arguments:  offset          new scroll offset
//              fScrollBits     TRUE if we should try to scroll bits on screen
//
//  Notes:
//
//----------------------------------------------------------------------------

#define MAX_SCROLLS 50

BOOL
CView::SmoothScroll(
        const SIZE& offset,
        CLayout * pLayout,
        BOOL fScrollBits,
        LONG lScrollTime)
{
    CDispNode        * pDispNode;
    CDispScroller    * pScroller = NULL;
    BOOL               fReturn = TRUE;

    pDispNode = pLayout->GetElementDispNode();
    if(!(pDispNode && pDispNode->IsScroller()))
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    pScroller = CDispScroller::Cast(pDispNode);

    // determine if smooth scrolling is enabled
    if (fScrollBits 
        && AllowSmoothScrolling() 
        && lScrollTime > 0 
        && pScroller->IsInView() 
        && pScroller->IsVisibleBranch())
    {
        CSize scrollDelta(offset + pScroller->GetScrollOffsetInternal());
        int axis = (scrollDelta.cx != 0 ? 0 : 1);
        LONG cScrolls = min((long)MAX_SCROLLS, (long)abs(scrollDelta[axis]));
        LONG cScrollsDone = 0;
        CSize perScroll(g_Zero.size);
        CSize sizeScrollRemainder = scrollDelta;
        DWORD dwStart = GetTickCount(), dwTimer;
    
        while (cScrolls > 0)
        {
            perScroll[axis] = sizeScrollRemainder[axis] / (cScrolls--);
            sizeScrollRemainder[axis] -= perScroll[axis];

            if (!pScroller->SetScrollOffset(
                    perScroll - pScroller->GetScrollOffsetInternal(), fScrollBits))
            {
                fReturn = FALSE;
                goto Cleanup;
            }

            // Calling SetScrollOffset may replace the pDispNode, so get it again
            pDispNode = pLayout->GetElementDispNode();
            if(!(pDispNode && pDispNode->IsScroller()))
            {
                fReturn = FALSE;
                goto Cleanup;
            }
            pScroller = CDispScroller::Cast(pDispNode);

            // Obtain new cScrolls.
            dwTimer = GetTickCount();
            cScrollsDone++;
            if (cScrolls && dwTimer != dwStart)
            {
                // See how many cScrolls we have time for by dividing the remaining time
                // by duration of last scroll, but don't increase the number (only speed up).
                LONG cSuggestedScrolls = MulDivQuick(cScrollsDone, lScrollTime - (dwTimer - dwStart), dwTimer - dwStart);
                if (cSuggestedScrolls <= 1)
                    cScrolls = 1;
                else if (cSuggestedScrolls < cScrolls)
                    cScrolls = cSuggestedScrolls;
            }
        }
        Assert(sizeScrollRemainder[axis] == 0);
    }
    else
    {
        fReturn = pScroller->SetScrollOffset(offset, fScrollBits);
    }


Cleanup:
    return fReturn;
}


CView::CEnsureDisplayTree::CEnsureDisplayTree(
    CView * pView)
{
    Assert(pView);
    _pView     = pView;
    _fTreeOpen =  TRUE;

    LONG cnt = InterlockedIncrement((LONG*)&(_pView->_cEnsureDisplayTree));
    if (cnt == 1 || (_pView->GetDisplayTree() && !_pView->GetDisplayTree()->DisplayTreeIsOpen()) )
    {
        if(cnt == 1)
        {
            _fTreeOpen = pView->IsFlagSet(VF_TREEOPEN);
        }
        _pView->EnsureDisplayTreeIsOpen();
    }
}


CView::CEnsureDisplayTree::~CEnsureDisplayTree()
{
    Assert(_pView);
    Assert(_pView->_cEnsureDisplayTree > 0);

    LONG cnt = InterlockedDecrement((LONG*)&(_pView->_cEnsureDisplayTree));
    if (cnt == 0 )
    {
        if(!_fTreeOpen)
        {
            _pView->CloseDisplayTree();
        }
    }
    else if(!_pView->IsFlagSet(VF_TREEOPEN))
    {
        _pView->EnsureDisplayTreeIsOpen();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CView::GetMessageHookProc
//
//  Synopsis:     This is the callback for GetMessage hook (see comments at
//              CreateVBControlClipHook). It fiters out one certain message and
//              sets a special state property on window indicating that it
//              can remove the hook.
//  Arguments: 
//----------------------------------------------------------------------------

static LRESULT CALLBACK 
GetMessageHookProc(int  nCode, WPARAM  wParam, LPARAM  lParam)
{
    MSG             * msg;
    THREADSTATE *   pts;

    pts = GetThreadState();
    if(pts == NULL)
        return 0;

    if(nCode < 0)
        return CallNextHookEx(pts->_hHookHandle, nCode, wParam, lParam);

    Assert(HC_ACTION == nCode);

    msg = (MSG *)lParam;
    
    if(GetProp(msg->hwnd, VBCTRLHOOK_PROPNAME) == VBCTRLHOOK_SET)
    {
        // This is a VB control window
        if(msg->message == VBCTRLHOOK_MSGTOFILTER)
        {
            // Change the message to WM_NULL so that it is ignored
            msg->message = WM_NULL;
            SetProp(msg->hwnd, VBCTRLHOOK_PROPNAME, VBCTRLHOOK_FILTERED);
        }
    }

     return CallNextHookEx(pts->_hHookHandle, nCode, wParam, lParam);
}



//+---------------------------------------------------------------------------
//
//  Member:     CView::CreateVBControlClipHook
//
//  Synopsis:     Installs a GetMessage hook on the thread in order to capture the
//              message some VB controls post to themselves that resets their window
//              clip to the whole window (IE6 bug 13321).
//                The window is also marked with a special property indicating that
//              the window needs filtering of the message.
//                If we already have a hook in place the function just addrefs it and
//  Arguments:  hwnd - the control window that is filtered
//----------------------------------------------------------------------------

HHOOK
CView::CreateVBControlClipHook(HWND hwnd)
{
    THREADSTATE *   pts;

    pts = GetThreadState();
    if(pts == NULL)
        return 0;

    Assert(pts->_cHookRequests >= 0);

    SetProp(hwnd, VBCTRLHOOK_PROPNAME, VBCTRLHOOK_SET);

    if(pts->_cHookRequests == 0)
    {
        pts->_hHookHandle = SetWindowsHookEx(WH_GETMESSAGE, GetMessageHookProc, NULL, GetCurrentThreadId());
    }

    pts->_cHookRequests++;
    
    Assert(pts->_hHookHandle);

    return pts->_hHookHandle;
}


//+---------------------------------------------------------------------------
//
//  Member:     CView::RemoveVBControlClipHook
//
//  Synopsis:     Decrements the refcount on the GetMessage hook (see comments at
//              CreateVBControlClipHook). If the refcount is 0 removes the GetMessage hook.
//                Should be called only for windows that use the hook.
//  Arguments:  hwnd - the control window that is filtered
//----------------------------------------------------------------------------

BOOL
CView::RemoveVBControlClipHook(HWND hwnd)
{
    THREADSTATE  * pts;
    BOOL           fRet = TRUE;

    pts = GetThreadState();
    if(pts == NULL)
        return FALSE;

    Assert(pts->_cHookRequests > 0);

    Verify(RemoveProp(hwnd, VBCTRLHOOK_PROPNAME));

    pts->_cHookRequests--;
    if(pts->_cHookRequests == 0)
    {
        fRet  = UnhookWindowsHookEx(pts->_hHookHandle);
        pts->_hHookHandle = NULL;
    }

    return fRet;
}





#if DBG==1
//+------------------------------------------------------------------------
//
//  Function:   DumpRegion
//
//  Synopsis:   Write region to debug output
//
//-------------------------------------------------------------------------

void
DumpRegion(
    HRGN    hrgn)
{
    if (hrgn == NULL)
        return;

    struct REGIONDATA
    {
        RGNDATAHEADER   rdh;
        RECT            arc[128];
    } data;

    RGNDATA *pData;
    DWORD dwSize = ::GetRegionData(hrgn, 0, NULL);

    if (dwSize <= sizeof(data))
    {
        pData = (RGNDATA *)&data;
        dwSize = sizeof(data);
    }
    else
    {
        pData = (RGNDATA *) new BYTE[dwSize];
    }

    if (::GetRegionData(hrgn, dwSize, pData) > 0)
    {
        REGIONDATA *p = (REGIONDATA*)pData;

        TraceTagEx((0, TAG_NONAME, "    HRGN(0x%x) iType(%d) nCount(%d) nRgnSize(%d) rcBound(%d,%d,%d,%d)",
                hrgn,
                p->rdh.iType,
                p->rdh.nCount,
                p->rdh.nRgnSize,
                p->rdh.rcBound.left,
                p->rdh.rcBound.top,
                p->rdh.rcBound.right,
                p->rdh.rcBound.bottom));

        for (DWORD i = 0; i < p->rdh.nCount; i++)
        {
            TraceTagEx((0, TAG_NONAME, "        rc(%d,%d,%d,%d)",
                p->arc[i].left,
                p->arc[i].top,
                p->arc[i].right,
                p->arc[i].bottom));
        }
    }
    else
    {
        TraceTag((0, "    HRGN(0x%x): Buffer too small", hrgn));
    }

    if (pData != (RGNDATA *)&data)
    {
        delete pData;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   DumpClipRegion
//
//  Synopsis:   Write clip region of hdc to debug output
//
//-------------------------------------------------------------------------

void
DumpClipRegion(
    HDC    hdc)
{
    HRGN    hrgn = ::CreateRectRgn(0,0,0,0);
    RECT    rc;

    if (hrgn)
    {
        switch (::GetClipRgn(hdc, hrgn))
        {
        case 1:
            DumpRegion(hrgn);
            break;

        case 0:
            switch (::GetClipBox(hdc, &rc))
            {
            case SIMPLEREGION:
                TraceTagEx((0, TAG_NONAME, "HDC(0x%x) has SIMPLE clip region rc(%d,%d,%d,%d)",
                        hdc,
                        rc.left,
                        rc.top,
                        rc.right,
                        rc.bottom));
                break;

            case COMPLEXREGION:
                TraceTagEx((0, TAG_NONAME, "HDC(0x%x) has COMPLEX clip region rc(%d,%d,%d,%d)",
                        hdc,
                        rc.left,
                        rc.top,
                        rc.right,
                        rc.bottom));
                break;

            default:
                TraceTagEx((0, TAG_NONAME, "HDC(0x%x) has NO clip region", hdc));
                break;
            }
            break;

        default:
            TraceTagEx((0, TAG_NONAME, "HDC(0x%x) Aaack! Error obtaining clip region", hdc));
            break;
        }

        ::DeleteObject(hrgn);
    }
}

//+------------------------------------------------------------------------
//
//  Function:   DumpHDC
//
//  Synopsis:   Write info about hdc to debug output
//
//-------------------------------------------------------------------------

void
DumpHDC(HDC hdc)
{
    if (hdc)
    {
        POINT ptOrig;

        ::GetViewportOrgEx(hdc, &ptOrig);

        TraceTagEx((0, TAG_NONAME, "HDC(0x%x) origin at (%ld,%ld)",
                        hdc, ptOrig.x, ptOrig.y));

        DumpClipRegion(hdc);
    }
    else
    {
        TraceTagEx((0, TAG_NONAME, "HDC(0x%x) is null"));
    }
}
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\srv\mshtmsrv.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      mshtmlsrv.cxx
//
//  Contents:   MSHTML Server Side Application Object and DLL entry points
//
//  Classes:    CServerApp
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif


DeclareTag(tagIISCalls, "TridentOnServer", "Raw IIS Calls");

//
// Misc stuff to keep the linker happy
//
DWORD               g_dwFALSE = 0;          // Used for assert to fool the compiler
EXTERN_C HANDLE     g_hProcessHeap = NULL;  // g_hProcessHeap is set by the CRT in dllcrt0.c
HINSTANCE           g_hInstance = NULL;

CServerApp        * g_pApp = NULL;


//+----------------------------------------------------------------------------
//
// Function: DllMain
//
//+----------------------------------------------------------------------------
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{

    return TRUE;    
}

//+----------------------------------------------------------------------------
//
// IIS Filter Entry Points
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function: GetFilterVersion
//
//+----------------------------------------------------------------------------
BOOL WINAPI GetFilterVersion(HTTP_FILTER_VERSION *pVer)
{
    HRESULT     hr;

    TraceTag((tagIISCalls, "GetFilterVersion, Server Version: %08lX", pVer->dwServerFilterVersion));

    hr = THR(CServerApp::AddRefApp());
    if (!hr)
        return g_pApp->GetIISFilter()->GetVersion(pVer);
    else
        return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function: HttpFilterProc
//
//+----------------------------------------------------------------------------
DWORD WINAPI HttpFilterProc(HTTP_FILTER_CONTEXT *pfc, DWORD dwNotifType, LPVOID pvNotification)
{
    TraceTag((tagIISCalls, "HttpFilterProc"));

    Assert(g_pApp);
    return g_pApp->GetIISFilter()->FilterProc(pfc, dwNotifType, pvNotification);
}


//+----------------------------------------------------------------------------
//
// Function: TerminateFilter
//
//+----------------------------------------------------------------------------
BOOL WINAPI TerminateFilter(DWORD dwFlags)
{
    TraceTag((tagIISCalls, "TerminateFilter"));

    Assert(g_pApp);
    return g_pApp->GetIISFilter()->Terminate(dwFlags);
}


//+----------------------------------------------------------------------------
//
// IIS Extension Entry Points
//
//+----------------------------------------------------------------------------

/*---------------------------------------------------------------------*
GetExtensionVersion

*/
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pextver) 
{
    HRESULT     hr;

    TraceTag((tagIISCalls, "GetExtensionVersion"));

    hr = THR(CServerApp::AddRefApp());
    if (!hr)
        return g_pApp->GetIISExtension()->GetVersion(pextver);
    else
        return FALSE;
}

/*---------------------------------------------------------------------*
TerminateExtension

*/

BOOL __stdcall TerminateExtension(DWORD flag) 
{
    TraceTag((tagIISCalls, "TerminateExtension"));
    Assert(g_pApp);
	return g_pApp->GetIISExtension()->Terminate(flag);
}

/*---------------------------------------------------------------------*
HttpExtensionProc

*/

DWORD __stdcall HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB) 
{
    TraceTag((tagIISCalls, "HttpExtensionProc"));

    Assert(g_pApp);
	return g_pApp->GetIISExtension()->ExtensionProc(pECB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\srv\ext.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      ext.cxx
//
//  Contents:   Http Extension object implementation
//
//  Classes:    CHttpExtension
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif

//+----------------------------------------------------------------------------
//
// Method: GetVersion
//
//+----------------------------------------------------------------------------
BOOL
CIISExtension::GetVersion(HSE_VERSION_INFO *pVer)
{
    BOOL        fRet = TRUE;

 	pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
	strcpy(pVer->lpszExtensionDesc, "MSHTMSRV 1.0");

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Method: Terminate
//
//+----------------------------------------------------------------------------
BOOL
CIISExtension::Terminate(DWORD)
{
    Assert(g_pApp);
    g_pApp->ReleaseApp();

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Method: ExtensionProc
//
//+----------------------------------------------------------------------------
DWORD           
CIISExtension::ExtensionProc(LPEXTENSION_CONTROL_BLOCK pECB)
{
    DWORD       dwRet = HSE_STATUS_SUCCESS;

    // special request to dump the debug info
    if (lstrcmpA(pECB->lpszQueryString, "debug") == 0) 
    {
        DumpDebugInfo(pECB);
        goto Cleanup;
    }


Cleanup:
    return dwRet;
}


//+----------------------------------------------------------------------------
//
// Method: ReportError
//
//+----------------------------------------------------------------------------
void 
CIISExtension::ReportError(LPEXTENSION_CONTROL_BLOCK pECB, CHAR *errorText, CHAR *status) 
{
    if (status == NULL) {
        status = "500 Server Error";
    }

	(*pECB->ServerSupportFunction)(
		pECB->ConnID,
		HSE_REQ_SEND_RESPONSE_HEADER,
		status,
		NULL,
		(LPDWORD)"Content-Type: text/html\r\n\r\n"
		);

	static const char ErrorFormat[] = 
		"<HTML><HEAD><TITLE>MSHTML ISAPI Error</TITLE></HEAD><BODY>\r\n"
		"<H1>%s</H1><P><B>MSHTML ISAPI Error</B></P>\r\n"
		"<P>%s.</P>\r\n</BODY></HTML>";

	DWORD errorBufferSize = sizeof(ErrorFormat) + 256;
	CHAR errorBuffer[2048];
	wsprintfA(errorBuffer, ErrorFormat, status, errorText);
	DWORD errorBytes = strlen(errorBuffer);

	(*pECB->WriteClient)(
		pECB->ConnID,
		(LPVOID)errorBuffer,
		(LPDWORD)&errorBytes,
		0
		);
}


//+----------------------------------------------------------------------------
//
// Method: DumpDebugInfo
//
//+----------------------------------------------------------------------------
void 
CIISExtension::DumpDebugInfo(LPEXTENSION_CONTROL_BLOCK pECB) 
{
	(*pECB->ServerSupportFunction)(
		pECB->ConnID,
		HSE_REQ_SEND_RESPONSE_HEADER,
		"200 OK",
		NULL,
		(LPDWORD)"Content-Type: text/html\r\n\r\n"
		);

    char buf[256];

#define WRITEBUF()  { DWORD n = strlen(buf); \
                      (*pECB->WriteClient)(pECB->ConnID, buf, &n, 0); }

    // header

    wsprintfA(buf, "<HTML><HEAD><TITLE>MSHISAPI Statistics</TITLE></HEAD>\r\n");
    WRITEBUF();

    wsprintfA(buf, "<BODY><H2>MSHISAPI Statistics</H2>\r\n");
    WRITEBUF();

    // filter requests

    wsprintfA(buf, "<H3>Filter Requests:</H3><UL>\r\n");
    WRITEBUF();

    wsprintfA(buf, "<LI>Total number of requests: <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulTotalRequests);
    WRITEBUF();

    wsprintfA(buf, "<LI>Number of requests resolved from cache: <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulRequestsFoundInCache);
    WRITEBUF();

    wsprintfA(buf, "<LI>Number of requests passed to Trident: <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulRequestsToTrident);
    WRITEBUF();

    wsprintfA(buf, "<LI>Number of requests passed through (Client is IE5): <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulTotalRequests - 
                    (g_pApp->GetIISFilter()->s_ulRequestsFoundInCache + 
                     g_pApp->GetIISFilter()->s_ulRequestsToTrident));
    WRITEBUF();

    wsprintfA(buf, "</UL>\r\n\r\n");
    WRITEBUF();

    // tail

    wsprintfA(buf, "\r\n\r\n</BODY></HTML>");
    WRITEBUF();

#undef WRITEBUF
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animcolor.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animcolor.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMCOLOR_H
#define _ANIMCOLOR_H

#include "colorutil.h"
#include "animbase.h"

//+-------------------------------------------------------------------------------------
//
// CTIMEColorAnimation
//
//--------------------------------------------------------------------------------------

class CTIMEColorAnimation : 
    public CComCoClass<CTIMEColorAnimation, &CLSID_TIMEColorAnimation>,
    public CTIMEAnimationBase
{

public:

    CTIMEColorAnimation();
    virtual ~CTIMEColorAnimation();

    DECLARE_AGGREGATABLE(CTIMEColorAnimation);
    DECLARE_REGISTRY(CLSID_TIMEColorAnimation,
                     LIBID __T(".TIMEColorAnimation.1"),
                     LIBID __T(".TIMEColorAnimation"),
                     0,
                     THREADFLAGS_BOTH);
    
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    STDMETHOD(get_from)(VARIANT * val);
    STDMETHOD(put_from)(VARIANT val);
    
    STDMETHOD(get_to)(VARIANT * val);
    STDMETHOD(put_to)(VARIANT val);

    STDMETHOD(get_by)(VARIANT * val);
    STDMETHOD(put_by)(VARIANT val);

    STDMETHOD(put_values)(VARIANT val);

    STUB_INVALID_ATTRIBUTE(BSTR, origin)
    STUB_INVALID_ATTRIBUTE(VARIANT, path)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

protected :

    virtual void OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void GetFinalByValue(VARIANT *pvarValue);
    virtual void UpdateStartValue (VARIANT *pvarNewStartValue);
    virtual void DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue);
    virtual void DoAccumulation (VARIANT *pvarValue);
    virtual HRESULT CanonicalizeValue (VARIANT *pvarOriginal, VARTYPE *pvtOld);
    virtual HRESULT UncanonicalizeValue (VARIANT *pvarOriginal, VARTYPE vtOld);
    virtual void UpdateCurrentBaseline (const VARIANT *pvarCurrent);
    virtual rgbColorValue GetRGBAnimationRange();

private:

    bool    hasEmptyStartingPoint (void);
    HRESULT fallbackToDiscreteCalculation (VARIANT *pvarValue);

    virtual HRESULT calculateDiscreteValue(VARIANT *pvarValue);
    virtual HRESULT calculateLinearValue (VARIANT *pvarValue);
    virtual HRESULT calculateSplineValue (VARIANT *pvarValue);
    virtual HRESULT calculatePacedValue (VARIANT *pvarValue);

    void CalculateTotalDistance();
    double CalculateDistance(rgbColorValue a, rgbColorValue b);

    HRESULT VariantToRGBColorValue (VARIANT *pvarIn, rgbColorValue *prgbValue);

    rgbColorValue CreateByValue(const rgbColorValue & rgbCurrent);
    void AdditiveColor(VARIANT *pVar, bool bPart);
    

    rgbColorValue   m_rgbTo;
    rgbColorValue   m_rgbFrom;
    rgbColorValue   m_rgbBy;
    rgbColorValue  *m_prgbValues;
    rgbColorValue   m_rgbAdditive;

    bool            m_byNegative;
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEColorAnimation"); }
#endif

}; // CTIMEColorAnimation


#endif /* _ANIMCOLOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animbase.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animbase.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMBASE_H
#define _ANIMBASE_H

#include "timeelmimpl.h"
#include "..\tags\bodyelm.h"

#define CALCMODE_DISCRETE       0
#define CALCMODE_LINEAR         1
#define CALCMODE_SPLINE         2
#define CALCMODE_PACED          3
#define ORIGIN_ELEMENT          1
#define ORIGIN_PARENT           2
#define ORIGIN_DEFAULT          (ORIGIN_ELEMENT)
#define PROPERTYPUT             true
#define PROPERTYGET             false


typedef enum DATATYPES
{
    PATH,
    VALUES,
    TO,
    BY,
    NONE,
    RESET
}enum_dataTypes;


struct SplinePoints
{
    // control points
    double x1;
    double y1;
    double x2;
    double y2;

    // these are samples used for interpolation of the x spline
    double s1;
    double s2;
    double s3;
    double s4;
};


struct AnimPropState
{
    //
    // NOTE: new properties need to be initialized in CTIMEAnimationBase::CTIMEAnimationBase()
    //

    bool fDisableAnimation; // Should animation be disabled?
    bool fForceCalcModeDiscrete;

    // can interpolate?
    bool fInterpolateValues;
    bool fInterpolateFrom;
    bool fInterpolateTo;
    bool fInterpolateBy;

    // syntax errors
    bool fBadBy;
    bool fBadTo;
    bool fBadFrom;
    bool fBadValues;
    bool fBadKeyTimes;

    // whether prop has been set
    bool fAccumulate;
};


// The animation element derives from IAnimationFragmentSite.  
interface IAnimationFragmentSite : public IUnknown
{
    STDMETHOD(NotifyOnGetValue) (BSTR bstrAttributeName, 
                                 VARIANT varOriginal, VARIANT varCurrentValue, 
                                 VARIANT *pvarValue) = 0;
    STDMETHOD(NotifyOnDetachFromComposer) (void) = 0;
    STDMETHOD(NotifyOnGetElement) (IDispatch **ppidispAnimationElement) = 0;
}; 

class CAnimationFragment;

//+-------------------------------------------------------------------------------------
//
// CTIMEAnimationBase
//
//--------------------------------------------------------------------------------------

class
__declspec(uuid("1ad9817f-c206-46a2-b974-7c549a8228c7")) 
ATL_NO_VTABLE
CTIMEAnimationBase :
    public CTIMEElementImpl<ITIMEAnimationElement2, &IID_ITIMEAnimationElement2>,
    public ISupportErrorInfoImpl<&IID_ITIMEAnimationElement>,
    public IConnectionPointContainerImpl< CTIMEAnimationBase>,
    public IPersistPropertyBag2,
    public IAnimationFragmentSite,
    public IPropertyNotifySinkCP< CTIMEAnimationBase>
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMEAnimationBase();
    virtual ~CTIMEAnimationBase();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEAnimationBase"); }
#endif

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // ITIMEAnimationElement
    //

    STDMETHOD(get_attributeName)(BSTR * attrib);
    STDMETHOD(put_attributeName)(BSTR attrib);

    STDMETHOD(get_from)(VARIANT * val);
    STDMETHOD(put_from)(VARIANT val);
    
    STDMETHOD(get_to)(VARIANT * val);
    STDMETHOD(put_to)(VARIANT val);

    STDMETHOD(get_by)(VARIANT * val);
    STDMETHOD(put_by)(VARIANT val);

    STDMETHOD(get_values)(VARIANT * val);
    STDMETHOD(put_values)(VARIANT val);

    STDMETHOD(get_keyTimes)(BSTR * val);
    STDMETHOD(put_keyTimes)(BSTR val);

    STDMETHOD(get_keySplines)(BSTR * val);
    STDMETHOD(put_keySplines)(BSTR val);

    STDMETHOD(get_targetElement)(BSTR * target);
    STDMETHOD(put_targetElement)(BSTR target);

    STDMETHOD(get_calcMode)(BSTR * calcmode);
    STDMETHOD(put_calcMode)(BSTR calcmode);

    STDMETHOD(get_additive)(BSTR * val);
    STDMETHOD(put_additive)(BSTR val);

    STDMETHOD(get_accumulate)(BSTR * val);
    STDMETHOD(put_accumulate)(BSTR val);

    STUB_INVALID_ATTRIBUTE(BSTR, origin)
    STUB_INVALID_ATTRIBUTE(VARIANT, path)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

    //
    // IAnimationFragmentSite
    // 
    STDMETHOD(NotifyOnGetElement)(IDispatch **pidispElement);
    STDMETHOD(NotifyOnGetValue)(BSTR bstrAttributeName, 
                                VARIANT varOrigonal, VARIANT varCurrentValue, 
                                VARIANT *pvarValue);
    STDMETHOD(NotifyOnDetachFromComposer)(void);

    //
    // IPersistPropertyBag2
    // 

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)(void) { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)(void) { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // Persistence helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void);

    //
    // Event Handlers
    //

    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnSync(double dbllastTime, double & dblnewTime);
    virtual void OnUnload();
    virtual void OnTEPropChange(DWORD tePropType);

    //
    // QI Map
    //

    BEGIN_COM_MAP(CTIMEAnimationBase)
        COM_INTERFACE_ENTRY(ITIMEAnimationElement)
        COM_INTERFACE_ENTRY(ITIMEAnimationElement2)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    //
    // Connection Point to allow IPropertyNotifySink
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMEAnimationBase)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // Notification Helpers
    //

    void NotifyPropertyChanged(DISPID dispid);

    //
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    //

    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEAnimationBase* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);

    //
    // Needed by CBvrBase
    //

    void * GetInstance() { return (ITIMEAnimationElement *) this; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo) { return GetTI(GetUserDefaultLCID(), ppInfo); }

    //
    // GetXXXAttr Accessors
    //

    CAttr<LPWSTR> & GetAttributeNameAttr()  { return m_SAAttribute; }
    CAttr<LPWSTR> & GetTargetElementAttr()  { return m_SATarget; }
    CAttr<LPWSTR> & GetValuesAttr()         { return m_SAValues; }
    CAttr<LPWSTR> & GetKeyTimesAttr()       { return m_SAKeyTimes; }
    CAttr<LPWSTR> & GetKeySplinesAttr()     { return m_SAKeySplines; }
    CAttr<LPWSTR> & GetAccumulateAttr()     { return m_SAAccumulate; }
    CAttr<LPWSTR> & GetAdditiveAttr()       { return m_SAAdditive; }
    CAttr<int>    & GetCalcModeAttr()       { return m_IACalcMode; }
    CAttr<void*>  & GetFromAttr()           { return m_VAFrom; }
    CAttr<void*>  & GetToAttr()             { return m_VATo; }
    CAttr<void*>  & GetByAttr()             { return m_VABy; }    
    CAttr<LPWSTR> & GetPathAttr()           { return m_SAPath; }
    CAttr<int>    & GetOriginAttr()         { return m_IAOrigin; }
    CAttr<LPWSTR> & GetTypeAttr()           { return m_SAType; }
    CAttr<LPWSTR> & GetSubtypeAttr()        { return m_SASubtype; }
    CAttr<LPWSTR> & GetModeAttr()           { return m_SAMode; }
    CAttr<LPWSTR> & GetFadeColorAttr()      { return m_SAFadeColor; }
    
    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------
    virtual bool ValidateByValue (const VARIANT *pvarBy);
    virtual bool ValidateValueListItem (const VARIANT *pvarValueItem);

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //
    //
    //

    virtual double CalculateProgressValue(bool fForceDiscrete);
    virtual int CalculateCurrentSegment(bool fForceDiscrete);
    virtual void  resetAnimate();
    virtual HRESULT calculateDiscreteValue(VARIANT *pvarValue);
    virtual HRESULT calculateLinearValue (VARIANT *pvarValue);
    virtual HRESULT calculateSplineValue (VARIANT *pvarValue);
    virtual HRESULT calculatePacedValue (VARIANT *pvarValue);
    virtual void resetValue (VARIANT *pvarValue);
    virtual void CalculateTotalDistance();
    virtual void initAnimate (void);
    virtual void endAnimate (void);
    virtual void SetInitialState (void);
    virtual void SetFinalState (void);
    virtual void OnFirstUpdate (VARIANT *pvarValue);
    virtual void OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess);
    virtual void GetFinalByValue(VARIANT *pvarValue);
    virtual double GetAnimationRange();

    virtual HRESULT CalculateValue (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void UpdateStartValue (VARIANT *pvarNewStartValue);
    virtual void UpdateCurrentBaseline (const VARIANT *pvarCurrent);
    virtual void PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual HRESULT DoFill (VARIANT *pvarValue);
    virtual void DoAccumulation (VARIANT *pvarValue);

    virtual HRESULT addToComposerSite (IHTMLElement2 *pielemTarget);    
    virtual HRESULT removeFromComposerSite (void);   

    HRESULT FindAnimationTarget (IHTMLElement ** ppielemTarget);
    
    double CalculateBezierProgress(const SplinePoints & sp, double cp);
    double KeySplineBezier(double x1, double x2, double cp);
    void SampleKeySpline(SplinePoints & sp);
    bool ConvertToPixels(VARIANT *pvarValue);

    virtual HRESULT CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld);
    virtual HRESULT UncanonicalizeValue (VARIANT *pvarValue, VARTYPE vtOld);
    virtual void DetermineAdditiveEffect (void);
    virtual void DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue);

    void  validateData();
    void  initScriptEngine();
    float getCurrentValue();
    void updateDataToUse(DATATYPES dt);

    HRESULT CreateFragmentHelper (void);

    virtual void ValidateState();
    bool DisableAnimation() { return m_AnimPropState.fDisableAnimation; }

    //
    // Misc. methods
    //

    HRESULT Error();
    virtual bool NeedSyncCB() { return true; }

    virtual bool QueryNeedFirstUpdate (void)
        { return m_bNeedFirstUpdate; }
    virtual bool QueryNeedFinalUpdate (void)
        { return m_bNeedFinalUpdate; }

    bool IsTargetVML(void)
        { return m_bVML; }
    
#ifdef TEST_ENUMANDINSERT // pauld
    HRESULT TestEnumerator (void);
    HRESULT TestInsert (void);
    HRESULT InsertEnumRemove (int iSlot);
#endif // TEST_ENUMANDINSERT

#ifdef TEST_REGISTERCOMPFACTORY // pauld
    HRESULT TestCompFactoryRegister (BSTR bstrAttribName);
#endif // TEST_REGISTERCOMPFACTORY

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    // XML Attributes
    CAttr<LPWSTR>               m_SAAttribute;
    CAttr<LPWSTR>               m_SATarget;
    CAttr<LPWSTR>               m_SAValues;
    CAttr<LPWSTR>               m_SAKeyTimes;
    CAttr<LPWSTR>               m_SAKeySplines;
    CAttr<LPWSTR>               m_SAAccumulate;
    CAttr<LPWSTR>               m_SAAdditive;
    CAttr<int>                  m_IACalcMode;
    CAttr<void*>                m_VAFrom; // Place holder for m_varFrom
    CAttr<void*>                m_VATo;   // Place holder for m_varTo
    CAttr<void*>                m_VABy;   // Place holder for m_varBy
    CAttr<LPWSTR>               m_SAPath;
    CAttr<int>                  m_IAOrigin;
    CAttr<LPWSTR>               m_SAType;
    CAttr<LPWSTR>               m_SASubtype;
    CAttr<LPWSTR>               m_SAMode;
    CAttr<LPWSTR>               m_SAFadeColor;

    // Internal Variables
    CComVariant                 m_varBaseline;
    CComVariant                 m_varCurrentBaseline;
    CComVariant                 m_varTo;
    CComVariant                 m_varFrom;
    CComVariant                 m_varBy;
    // these three are used to store copies to be returned by get_from/to/by
    // as the previous three are local copies that are modified (108725)
    CComVariant                 m_varDOMTo;
    CComVariant                 m_varDOMFrom;
    CComVariant                 m_varDOMBy;
    CComVariant                 m_varLastValue;
    CComVariant                 m_varStartValue;
    bool                        m_bFrom;
    bool                        m_bAdditive;
    bool                        m_bAdditiveIsSum;
    bool                        m_bAccumulate;
    bool                        m_bNeedAnimInit;
    bool                        m_fPropsLoaded;
    bool                        m_bNeedFinalUpdate;
    bool                        m_bNeedFirstUpdate;
    bool                        m_bNeedStartUpdate;
    bool                        m_bVML;
    CComPtr<IHTMLElementCollection> m_spEleCol;
    CComPtr<IHTMLDocument3>     m_spDoc3;
    CComPtr<IHTMLDocument2>     m_spDoc2;
    int                         m_numValues;
    LPOLESTR                   *m_ppstrValues;
    int                         m_numKeyTimes;
    double                     *m_pdblKeyTimes;
    int                         m_numKeySplines;
    SplinePoints               *m_pKeySplinePoints;
    double                      m_dblTotalDistance;
    bool                        m_bNeedToSetInitialState;
    AnimPropState               m_AnimPropState;

    DATATYPES                       m_dataToUse;
    CComPtr<IAnimationComposerSite> m_spCompSite;
    CComObject<CAnimationFragment>  *m_spFragmentHelper;

private:

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    // Persistence map
    static TIME_PERSISTENCE_MAP PersistenceMap[];

}; // CTIMEAnimationBase

//+---------------------------------------------------------------------------------
//  CTIMEAnimationBase inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
HRESULT WINAPI
CTIMEAnimationBase::InternalQueryInterface(CTIMEAnimationBase* pThis,
                                              const _ATL_INTMAP_ENTRY* pEntries,
                                              REFIID iid,
                                              void** ppvObject)
{ 
    return BaseInternalQueryInterface(pThis,
                                      (void *) pThis,
                                      pEntries,
                                      iid,
                                      ppvObject); 
}

#endif /* _ANIMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animcomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcomp.h"
#include "tokens.h"
#include "fragenum.h"
#include "targetpxy.h"

const LPOLESTR WZ_DETACH_METHOD = L"DetachFromComposer";
const unsigned NUM_GETVALUE_ARGS = 3;

DeclareTag(tagAnimationComposer, "SMIL Animation", 
           "CAnimationComposerBase methods");

DeclareTag(tagAnimationComposerUpdate, "SMIL Animation", 
           "CAnimationComposerBase composition updates");

DeclareTag(tagAnimationComposerError, "SMIL Animation", 
           "CAnimationComposerBase composition errors");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::CAnimationComposerBase
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerBase::CAnimationComposerBase (void) :
    m_wzAttributeName(NULL),
    m_pcTargetProxy(NULL),
    m_bInitialComposition(true),
    m_bCrossAxis(false)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::CAnimationComposerBase()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::~CAnimationComposerBase
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerBase::~CAnimationComposerBase (void)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::~CAnimationComposerBase()",
              this));

    IGNORE_HR(PutAttribute(NULL));   
    Assert(0 == m_fragments.size());
    DetachFragments();
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::get_attribute
//
//  Overview:  Query the composer for the animated attribute's name
//
//  Arguments: pointer to a bstr for the attribute name
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::get_attribute (BSTR *pbstrAttributeName)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::get_attribute()",
              this));

    HRESULT hr;

    if (NULL == pbstrAttributeName)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pbstrAttributeName = ::SysAllocString(m_wzAttributeName);

    // Make sure to isolate the out of memory condition.  If we 
    // have a NULL m_szAttributeName member we would expect a NULL
    // out param.  That's not an error condition.
    if ((NULL == (*pbstrAttributeName) ) && 
        (NULL != m_wzAttributeName))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN2(hr, E_INVALIDARG, E_OUTOFMEMORY);
} // CAnimationComposerBase::get_attribute

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::PutAttribute
//
//  Overview:  Set the composer's animated attribute
//
//  Arguments: attribute name
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerBase::PutAttribute (LPCWSTR wzAttributeNameIn)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::put_attribute(%ls)",
              this, wzAttributeNameIn));

    HRESULT hr;
    LPWSTR wzAttributeName = NULL;

    if (NULL != wzAttributeNameIn)
    {
        wzAttributeName = CopyString(wzAttributeNameIn);
        if (NULL == wzAttributeName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    if (NULL != m_wzAttributeName)
    {
        delete [] m_wzAttributeName;
    }
    m_wzAttributeName = wzAttributeName;

    hr = S_OK;
done :
    RRETURN1(hr, E_OUTOFMEMORY);
} // CAnimationComposerBase::PutAttribute

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposerInit
//
//  Overview:  Tells the composer to initialize itself
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::ComposerInit (IDispatch *pidispHostElem, BSTR bstrAttributeName)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::ComposerInit(%p, %ls)",
              this, pidispHostElem, bstrAttributeName));

    HRESULT hr;

    hr = THR(PutAttribute(bstrAttributeName));
    if (FAILED(hr))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(CTargetProxy::Create(pidispHostElem, m_wzAttributeName, &m_pcTargetProxy));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pcTargetProxy);

    hr = S_OK;
done :
    
    if (FAILED(hr))
    {
        IGNORE_HR(ComposerDetach());
    }

    RRETURN2(hr, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposerBase::ComposerInit

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposerInitFromFragment
//
//  Overview:  Tells the composer to initialize itself - the base
//             class implementation is just a callthrough to ComposerInit
//
//  Returns:   re - ComposerInit
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::ComposerInitFromFragment (IDispatch *pidispHostElem, 
                                                  BSTR bstrAttributeName, 
                                                  IDispatch *)
{
    return ComposerInit(pidispHostElem, bstrAttributeName);
} // CAnimationComposerBase::ComposerInitFromFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::DetachFragment
//
//  Overview:  Tells the composer to detach from a fragment
//
//  Arguments: The fragment's dispatch
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerBase::DetachFragment (IDispatch *pidispFragment)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::DetachFragment(%p)",
              this, pidispFragment));

    // Make all calls to the fragments using IDispatch
    // This one-liner is a method in case we need to 
    // package up info to pump back to the fragments in the future.
    IGNORE_HR(CallMethod(pidispFragment, WZ_DETACH_METHOD));
} // CAnimationComposerBase::DetachFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::DetachFragments
//
//  Overview:  Tells the composer to detach from all of its fragments
//
//  Arguments: none
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerBase::DetachFragments (void)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::DetachFragments()",
              this));

    FragmentList listFragmentsToDetach;

    // Copy the fragment list so that we can tolerate 
    // reentrancy on it.
    for (FragmentList::iterator i = m_fragments.begin(); 
         i != m_fragments.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listFragmentsToDetach.push_back(*i);
    }

    // Do not allow any failure to abort the detach cycle.
    for (i = listFragmentsToDetach.begin(); 
         i != listFragmentsToDetach.end(); i++)
    {
        DetachFragment(*i);
    }

    for (i = listFragmentsToDetach.begin(); 
         i != listFragmentsToDetach.end(); i++)
    {
        // This release is for the reference from the 
        // copied list.
        IGNORE_RETURN((*i)->Release());
    }
              
    m_fragments.clear();

} // CAnimationComposerBase::DetachFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposerDetach
//
//  Overview:  Tells the composer to detach all external references
//
//  Arguments: none
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::ComposerDetach (void)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::ComposerDetach()",
              this));

    HRESULT hr;

    // Detach might have been called under an error condition.
    // We should tolerate a NULL target proxy.

    if (NULL != m_pcTargetProxy)
    {
        IGNORE_HR(m_pcTargetProxy->Detach());
        m_pcTargetProxy->Release();
        m_pcTargetProxy = NULL;
    }

    // Let go of all of the fragments.
    DetachFragments();

    // Clean up data members.
    IGNORE_HR(m_VarInitValue.Clear());
    IGNORE_HR(m_VarLastValue.Clear());
    IGNORE_HR(PutAttribute(NULL));   

    hr = S_OK;
    RRETURN(hr);
} // CAnimationComposerBase::ComposerDetach

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposeFragmentValue
//
//  Overview:  Pull the fragment values -- allowing each to compose into 
//             the prior ones.
//
//  Arguments: none
//
//  Returns:   S_OK, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerBase::ComposeFragmentValue (IDispatch *pidispFragment, VARIANT varOriginal, VARIANT *pvarValue)
{
    HRESULT hr;
    DISPPARAMS dp;
    VARIANTARG rgva[NUM_GETVALUE_ARGS];
    LPWSTR wzMethodName = const_cast<LPWSTR>(WZ_FRAGMENT_VALUE_PROPERTY_NAME);
    DISPID dispidGetValue = 0;

    ZeroMemory(&dp, sizeof(dp));
    ZeroMemory(&rgva, sizeof(rgva));

    hr = THR(::VariantCopy(&(rgva[0]), pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::VariantCopy(&(rgva[1]), &varOriginal));
    if (FAILED(hr))
    {
        goto done;
    }

    rgva[2].vt = VT_BSTR;
    rgva[2].bstrVal = ::SysAllocString(m_wzAttributeName);
    if (0 != StrCmpW(V_BSTR(&(rgva[2])), m_wzAttributeName))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    dp.rgvarg = rgva;
    dp.cArgs = NUM_GETVALUE_ARGS;
    dp.cNamedArgs = 0;

    hr = THR(pidispFragment->GetIDsOfNames(IID_NULL, &wzMethodName, 1, 
                                           LCID_SCRIPTING, &dispidGetValue));
    if (FAILED(hr))
    {
        goto done;
    }

    // Wipe out prior content so we do not leak.
    IGNORE_HR(::VariantClear(pvarValue));

    hr = THR(pidispFragment->Invoke(dispidGetValue, IID_NULL, 
                                    LCID_SCRIPTING, 
                                    DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                                    &dp, pvarValue, NULL, NULL));
    if (FAILED(hr))
    {
        TraceTag((tagAnimationComposerError,
                  "CAnimationComposerBase(%p)::ComposeFragmentValue(hr = %X) error returned from fragment's get_value call",
                  this, hr));
        goto done;
    }

    hr = S_OK;

done :

    ::VariantClear(&(rgva[0]));
    ::VariantClear(&(rgva[1]));
    ::VariantClear(&(rgva[2]));

    RRETURN(hr);
} // CAnimationComposerBase::ComposeFragmentValue

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::UpdateFragments
//
//  Overview:  Tells the composer to cycle through all fragments and 
//             update the animated attribute.
//
//  Arguments: none
//
//  Returns:   S_OK, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::UpdateFragments (void)
{
    TraceTag((tagAnimationComposerUpdate,
              "CAnimationComposerBase(%p)::UpdateFragments() for %ls",
              this, m_wzAttributeName));

    HRESULT hr = S_OK;
    CComVariant varValue;

    if (NULL == m_pcTargetProxy)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // Get the initial current value of the target.
    if (m_VarInitValue.vt == VT_EMPTY)
    {
        m_bInitialComposition = true;
        hr = THR(m_pcTargetProxy->GetCurrentValue(&m_VarInitValue));
        if (FAILED(hr))
        {
            // @@ Need custom error message
            hr = E_UNEXPECTED;
            goto done;
        }
    }
    hr = varValue.Copy(&m_VarInitValue);
    if (FAILED(hr))
    {
        // @@ Need custom error message
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = PreprocessCompositionValue(&varValue);
    if (FAILED(hr))
    {
        goto done;
    }

    // Poll the fragments for their updates.
    // We do not want to abort the update when
    // a single fragment reports a failure.
    {
        FragmentList listFragmentsToUpdate;

        // Copy the fragment list so that we can tolerate 
        // reentrant add/insert/remove.
        for (FragmentList::iterator i = m_fragments.begin(); 
             i != m_fragments.end(); i++)
        {
            IGNORE_RETURN((*i)->AddRef());
            listFragmentsToUpdate.push_back(*i);
        }

        for (i = listFragmentsToUpdate.begin(); 
             i != listFragmentsToUpdate.end(); i++)
        {
            CComVariant varCopy;
            HRESULT hrTemp;

            hrTemp = THR(varCopy.Copy(&varValue));
            if (FAILED(hrTemp))
            {
                continue;
            }
            
            hrTemp = ComposeFragmentValue(*i, m_VarInitValue, &varCopy);
            if (FAILED(hrTemp))
            {
                continue;
            }

            hrTemp = THR(varValue.Copy(&varCopy));
            if (FAILED(hrTemp))
            {
                continue;
            }
        }

        // Get rid of the copied list.
        for (i = listFragmentsToUpdate.begin(); 
             i != listFragmentsToUpdate.end(); i++)
        {
            IGNORE_RETURN((*i)->Release());
        }
        listFragmentsToUpdate.clear();
    }
    if (NULL != m_pcTargetProxy) // Only update if one or more fragments has begun
    {
        hr = PostprocessCompositionValue(&varValue);
        if (FAILED(hr))
        {
            goto done;
        }
        if (m_VarLastValue == varValue)
        {
            // Value is not different ... don't update.
            goto done;
        }

        // We need to make sure that we hit the zero when we transition accross axis in order to 
        // be completely sure that we draw correctly.  In some cases when an Property goes from positive to 
        // negative draw stops, so we need to make sure that we hit the zero or we will end up with artifacts
        // left on the screen.
        if ((V_VT(&varValue) == VT_R8) &&
            (V_VT(&m_VarLastValue) == VT_R8))
        {
            if (((V_R8(&varValue) < 0) && (V_R8(&m_VarLastValue) > 0)) ||
                ((V_R8(&varValue) > 0) && (V_R8(&m_VarLastValue) < 0)))
            {
                CComVariant pVar;
                V_VT(&pVar) = VT_R8;
                V_R8(&pVar) = 0;
                hr = THR(m_pcTargetProxy->Update(&pVar));
                if (FAILED(hr))
                {
                    hr = E_UNEXPECTED;
                    goto done;
                }
                m_VarLastValue.Copy(&pVar);
            }
        }
        // Write the new value back to the target.
        hr = THR(m_pcTargetProxy->Update(&varValue));
        if (FAILED(hr))
        {
            hr = E_UNEXPECTED;
            goto done;
        }
        m_VarLastValue.Copy(&varValue);
    }

    hr = S_OK;
done :
    m_bInitialComposition = false;
    RRETURN1(hr, E_UNEXPECTED);
} // CAnimationComposerBase::UpdateFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::AddFragment
//
//  Overview:  Add a fragment to the composer's internal data structures
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::AddFragment (IDispatch *pidispNewAnimationFragment)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::AddFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr;

    IGNORE_RETURN(pidispNewAnimationFragment->AddRef());
    // @@ Need to handle memory error.
    m_fragments.push_back(pidispNewAnimationFragment);

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_UNEXPECTED);
} // CAnimationComposerBase::AddFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::InsertFragment
//
//  Overview:  Insert a fragment to the composer's internal data structures,
//             at the specified position.
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::InsertFragment (IDispatch *pidispNewAnimationFragment, VARIANT varIndex)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::InsertFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr;
    CComVariant varIndexLocal;

    // Massage the index into an expected format.
    // Eventually we might permit people to pass 
    // in id's, but that is overkill now.
    hr = THR(varIndexLocal.Copy(&varIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeTypeEx(&varIndexLocal, &varIndexLocal, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
    if (FAILED(hr))
    {
        goto done;
    }

    // An out of range value translates to an append.
    if ((m_fragments.size() > V_UI4(&varIndexLocal)) &&
        (0 <= V_I4(&varIndexLocal)))
    {
        FragmentList::iterator i = m_fragments.begin();         

        for (int iSlot = 0; iSlot < V_I4(&varIndexLocal); i++, iSlot++); //lint !e722
        IGNORE_RETURN(pidispNewAnimationFragment->AddRef());
        // @@ Need to handle memory error.
        m_fragments.insert(i, pidispNewAnimationFragment);
    }
    else
    {
        hr = AddFragment(pidispNewAnimationFragment);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = S_FALSE;
    }

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_UNEXPECTED);
} // CAnimationComposerBase::InsertFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::RemoveFragment
//
//  Overview:  Remove a fragment from the composer's internal data structures
//
//  Arguments: the dispatch of the fragment
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::RemoveFragment (IDispatch *pidispOldAnimationFragment)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::RemoveFragment(%p)",
              this,
              pidispOldAnimationFragment));

    HRESULT hr;

    for (FragmentList::iterator i = m_fragments.begin(); 
         i != m_fragments.end(); 
         i++)
    {
        if(MatchElements(*i, pidispOldAnimationFragment))
        {
            // We do not issue a notification to the fragment
            // when remove is called.  Presumably the fragment 
            // already knows.

            // We don't want to let a release on the (*i) 
            // be the final release for the sink object.
            CComPtr<IDispatch> spdispOld = (*i);
            IGNORE_RETURN(spdispOld.p->Release());
            m_fragments.remove(spdispOld);
            break;
        }
    }

    // If we did not find the fragment in our list, return S_FALSE.
    if (m_fragments.end() == i)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, S_FALSE);
} // CAnimationComposerBase::RemoveFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::EnumerateFragments
//
//  Overview:  Provide an enumerator for our fragments
//
//  Arguments: The outgoing enumerator
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::EnumerateFragments (IEnumVARIANT **ppienumFragments)
{
    HRESULT hr;

    if (NULL == ppienumFragments)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = CFragmentEnum::Create(*this, ppienumFragments);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done : 
    RRETURN1(hr, E_INVALIDARG);
} // CAnimationComposerBase::EnumerateFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::GetNumFragments
//
//  Overview:  Return the number of fragments in this composer
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::GetNumFragments (long *plFragmentCount)
{
    HRESULT hr;

    if (NULL == plFragmentCount)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *plFragmentCount = GetFragmentCount();

    hr = S_OK;
done : 
    RRETURN1(hr, E_INVALIDARG);
} // GetNumFragments

////////////////////////////////////////////////////////////////////////// 
//      Enumerator helper methods.
////////////////////////////////////////////////////////////////////////// 

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::GetFragmentCount
//
//  Overview:  Return the number of fragments in this composer
//
//------------------------------------------------------------------------
unsigned long
CAnimationComposerBase::GetFragmentCount (void) const
{
    return m_fragments.size();
} // CAnimationComposerBase::GetFragmentCount

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::GetFragment
//
//  Overview:  Retrieve a fragment from the composer's internal data structures
//
//  Arguments: the dispatch of the fragment
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerBase::GetFragment (unsigned long ulIndex, IDispatch **ppidispFragment)
{
    HRESULT hr;

    // Make sure we're in range.
    if (((GetFragmentCount() <= ulIndex) ) ||
        (NULL == ppidispFragment))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    {
        // Cycle the iterator until we find the right one.
        FragmentList::iterator i = m_fragments.begin();         
        for (unsigned long ulSlot = 0; ulSlot < ulIndex; i++, ulSlot++); //lint !e722
        IGNORE_RETURN((*i)->AddRef());
        *ppidispFragment = (*i);
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // CAnimationComposerBase::GetFragment 

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::PreprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::PreprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::PreprocessCompositionValue()",
              this));

    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // PreprocessCompositionValue

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::PostprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::PostprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::PostprocessCompositionValue()",
              this));
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // PostprocessCompositionValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animcomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Animation Composer base class.

*******************************************************************************/

#pragma once

#ifndef _ANIMCOMP_H
#define _ANIMCOMP_H

typedef std::list<IDispatch*> FragmentList;
class CTargetProxy;

class __declspec(uuid("DC357A35-DDDF-4288-B17B-1A826CDCB354"))
ATL_NO_VTABLE CAnimationComposerBase
    : public CComObjectRootEx<CComSingleThreadModel>,
      public IAnimationComposer2
{
  public:
    CAnimationComposerBase();
    virtual ~CAnimationComposerBase();

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposerBase"); }
#endif

    // IAnimationComposer methods/props
    STDMETHOD(get_attribute) (BSTR *pbstrAttributeName);
    STDMETHOD(ComposerInit) (IDispatch *pidispHostElem, BSTR bstrAttributeName);
    STDMETHOD(ComposerDetach) (void);
    STDMETHOD(UpdateFragments) (void);
    STDMETHOD(AddFragment) (IDispatch *pidispNewAnimationFragment);
    STDMETHOD(InsertFragment) (IDispatch *pidispNewAnimationFragment, VARIANT varIndex);
    STDMETHOD(RemoveFragment) (IDispatch *pidispOldAnimationFragment);
    STDMETHOD(EnumerateFragments) (IEnumVARIANT **ppienumFragments);
    STDMETHOD(GetNumFragments) (long *fragmentCount);

    // IAnimationComposer2 methods
    STDMETHOD(ComposerInitFromFragment) (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                                         IDispatch *pidispFragment);

    BEGIN_COM_MAP(CAnimationComposerBase)
        COM_INTERFACE_ENTRY(IAnimationComposer2)
        COM_INTERFACE_ENTRY(IAnimationComposer)
    END_COM_MAP();

    // These methods convert the animated value from its native format
    // to the composed format and back again.  This allows us to animate
    // color out of gamut.
    STDMETHOD(PreprocessCompositionValue) (VARIANT *pvarValue);
    STDMETHOD(PostprocessCompositionValue) (VARIANT *pvarValue);

    // Enumerator helper methods.
    unsigned long GetFragmentCount (void) const;
    HRESULT GetFragment (unsigned long ulIndex, IDispatch **ppidispFragment);

    // Internal Methods
  protected:

    HRESULT PutAttribute (LPCWSTR wzAttributeName);
    HRESULT CreateTargetProxy (IDispatch *pidispComposerSite, IAnimationComposer *pcComp);
    void DetachFragments (void);
    void DetachFragment (IDispatch *pidispFragment);
    bool MatchFragments (IDispatch *pidispOne, IDispatch *pidispTwo);
    HRESULT ComposeFragmentValue (IDispatch *pidispFragment, VARIANT varOriginal, VARIANT *pvarValue);

  // Data
  protected:

    LPWSTR          m_wzAttributeName;
    FragmentList    m_fragments;
    CTargetProxy   *m_pcTargetProxy;
    CComVariant     m_VarInitValue;
    CComVariant     m_VarLastValue;
    bool            m_bInitialComposition;
    bool            m_bCrossAxis;

};

#endif /* _ANIMCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animcolor.cpp ===
// Coloranim.cpp
//

#include "headers.h"
#include "animcolor.h"

#define SUPER CTIMEAnimationBase

DeclareTag(tagAnimationColor, "SMIL Animation", 
           "CTIMEColorAnimation methods");

DeclareTag(tagAnimationColorInterpolate, "SMIL Animation", 
           "CTIMEColorAnimation interpolation");

DeclareTag(tagAnimationColorAdditive, "SMIL Animation", 
           "CTIMEColorAnimation additive animation methods");

static const LPWSTR s_cPSTR_NEGATIVE = L"-";

#define PART_ONE 0
#define PART_TWO 1

///////////////////////////////////////////////////////////////
//  Name: CTIMEColorAnimation
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMEColorAnimation::CTIMEColorAnimation()
: m_prgbValues(NULL),
  m_byNegative(false)
{
    m_rgbTo.red = 0.0;
    m_rgbTo.green = 0.0;
    m_rgbTo.blue = 0.0;

    m_rgbFrom       = m_rgbTo;
    m_rgbBy         = m_rgbTo;
    m_rgbAdditive   = m_rgbTo;
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMEColorAnimation
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMEColorAnimation::~CTIMEColorAnimation()
{
    delete [] m_prgbValues;
} 

///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    HRESULT hr;
    
    // Set the Caclmode to discrete since that is all that set supports 
    hr = THR(SUPER::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: VariantToRGBColorValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::VariantToRGBColorValue (VARIANT *pvarIn, rgbColorValue *prgbValue)
{
    HRESULT hr;

    if (VT_EMPTY == V_VT(pvarIn))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (VT_BSTR != V_VT(pvarIn))
    {
        hr = VariantChangeTypeEx(pvarIn, pvarIn, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    Assert(VT_BSTR == V_VT(pvarIn));

    hr = RGBStringToRGBValue(V_BSTR(pvarIn), prgbValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // VariantToRGBColorValue


///////////////////////////////////////////////////////////////
//  Name: get_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::get_to(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varTo);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_to(VARIANT val)
{
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt;

    // Clear the attribute
    m_varTo.Clear();
    m_VATo.Reset(NULL);
    m_rgbTo.red = 0;
    m_rgbTo.green = 0;
    m_rgbTo.blue = 0;
    dt = RESET; 

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // store off local copy
    hr = VariantCopy(&m_varTo, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder to mark it as set
    m_VATo.SetValue(NULL);

    hr = VariantToRGBColorValue(&m_varTo, &m_rgbTo);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    dt = TO;

    hr = S_OK;
done:
    m_AnimPropState.fInterpolateTo = fCanInterpolate;

    m_AnimPropState.fBadTo = FAILED(hr) ? true : false;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_TO);

    RRETURN(hr);
} // put_to


///////////////////////////////////////////////////////////////
//  Name: get_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::get_from(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varFrom);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_from(VARIANT val)
{
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;

    // Clear the attribute
    m_varFrom.Clear();
    m_VAFrom.Reset(NULL);
    m_rgbFrom.red = 0;
    m_rgbFrom.green = 0;
    m_rgbFrom.blue = 0;
    m_bFrom = false;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // store off local copy
    hr = VariantCopy(&m_varFrom, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder to mark it as set
    m_VAFrom.SetValue(NULL);

    // Validate the color
    hr = VariantToRGBColorValue(&m_varFrom, &m_rgbFrom);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    m_bFrom = true;

    hr = S_OK;
done:
    m_AnimPropState.fBadFrom = FAILED(hr) ? true : false;

    m_AnimPropState.fInterpolateFrom = fCanInterpolate;

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_FROM);

    RRETURN(hr);
} // put_from


///////////////////////////////////////////////////////////////
//  Name: get_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::get_by(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varBy);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_by(VARIANT val)
{
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt;

    // Clear the attribute
    m_varBy.Clear();
    m_VABy.Reset(NULL);
    m_rgbBy.red = 0;
    m_rgbBy.green = 0;
    m_rgbBy.blue = 0;
    dt = RESET; 

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // store off local copy
    hr = VariantCopy(&m_varBy, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VABy.SetValue(NULL);

    // Try to get us to a colorPoint ... somehow..
    hr = VariantToRGBColorValue(&m_varBy, &m_rgbBy);
    if (FAILED(hr))
    { 
        // Need to handle the negative case...
        if ((m_varBy.vt == VT_BSTR) &&
            (StrCmpNIW(m_varBy.bstrVal, s_cPSTR_NEGATIVE, 1) == 0))
        {
            LPOLESTR Temp;
            CComVariant varTemp;
            
            Temp = CopyString(m_varBy.bstrVal);
            if (Temp == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            varTemp.vt = VT_BSTR;
            varTemp.bstrVal = SysAllocString(Temp+1);
            if(Temp)
            {
                delete [] Temp;
                Temp = NULL;
            }
            hr = VariantToRGBColorValue(&varTemp, &m_rgbBy);
            if (FAILED(hr))
            {
                fCanInterpolate = false;
                goto done;
            }
            m_byNegative = true;
        }
        else
        {
            fCanInterpolate = false;
            goto done;
        }
    }

    dt = BY;

    hr = S_OK;
done:
    m_AnimPropState.fBadBy = FAILED(hr) ? true : false;
    
    m_AnimPropState.fInterpolateBy = fCanInterpolate;

    updateDataToUse(dt);
    
    ValidateState();
 
    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_BY);

    RRETURN(hr);
} // put_by


///////////////////////////////////////////////////////////////
//  Name: put_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_values(VARIANT val)
{
    HRESULT hr = E_FAIL;
    int i = 0, count = 0;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    dTemp = m_dataToUse;

    // reset internal state
    delete [] m_prgbValues;
    m_prgbValues = NULL;

    // delegate to base class
    hr = SUPER::put_values(val);    
    if (FAILED(hr))
    {
        goto done;
    }

    // restore animation-type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // check for an empty string
    if (m_numValues == 0)
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    // allocate internal storage
    m_prgbValues = NEW rgbColorValue[m_numValues];
    if(m_prgbValues == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // parse the values
    {
        CComVariant varVal;

        for (i=0; i < m_numValues; i++)
        {
            V_VT(&varVal) = VT_BSTR;
            V_BSTR(&varVal) = SysAllocString(m_ppstrValues[i]);
            // If the allocation fails, fall out and return an error
            if (NULL == V_BSTR(&varVal))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            hr = VariantToRGBColorValue(&varVal, &(m_prgbValues[i]));
            if (FAILED(hr))
            {
                fCanInterpolate = false;
                goto done;
            }
            count++;
            varVal.Clear();
        }
    }

    dt = VALUES;

    // check for invalid attribute
    if (count < 1)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_AnimPropState.fBadValues = true;
        delete [] m_prgbValues;
        m_prgbValues = NULL;
    }
    else
    {
        m_AnimPropState.fBadValues = false;
    }

    m_AnimPropState.fInterpolateValues = fCanInterpolate;

    updateDataToUse(dt);

    CalculateTotalDistance();

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_values


///////////////////////////////////////////////////////////////
//  Name: UpdateStartValue
//
//  Abstract: Refresh the m_varStartValue, doing any necessary type conversion.
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::UpdateStartValue (VARIANT *pvarNewStartValue)
{
    m_varStartValue.Clear();
    THR(m_varStartValue.Copy(pvarNewStartValue));
} // UpdateStartValue 

///////////////////////////////////////////////////////////////
//  Name: UpdateCurrentBaseTime
//
//  Abstract: Examine the current base time, and update it if 
//            we're doing baseline+to animation (the spec calls
//            this hybrid additive).
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::UpdateCurrentBaseline (const VARIANT *pvarCurrent)
{
    // Are we doing hybrid additive animation?
    if (   (TO == m_dataToUse)
        && (!m_bFrom))
    {
        // Filter out the initial call (when last-value hasn't been set.
        if (VT_EMPTY != V_VT(&m_varLastValue))
        {
            CComVariant varCurrent;
            CComVariant varLast;

            // Make sure we're all speaking in the same format (vector)
            HRESULT hr = THR(varCurrent.Copy(pvarCurrent));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = EnsureVariantVectorFormat(&varCurrent);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = THR(varLast.Copy(&m_varLastValue));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = EnsureVariantVectorFormat(&varLast);
            if (FAILED(hr))
            {
                goto done;
            }

            if (!IsColorVariantVectorEqual(&varLast, &varCurrent))
            {
                THR(::VariantCopy(&m_varCurrentBaseline, &varCurrent));
#if (0 && DBG)
                {
                    CComVariant varNewBaseline;
                    RGBVariantVectorToRGBVariantString(&varCurrent, &varNewBaseline);
                    TraceTag((tagAnimationColorAdditive, 
                              "CTIMEColorAnimation(%p)::UpdateCurrentBaseTime(%ls)", 
                              this, V_BSTR(&varNewBaseline)));
                }
#endif
            }
        }
    }

done :
    return;
} // UpdateCurrentBaseTime


///////////////////////////////////////////////////////////////
//  Name: GetRGBAnimationRange
//
//  Abstract: Get the end point of the animation function over the
//            simple duration
//
///////////////////////////////////////////////////////////////
rgbColorValue 
CTIMEColorAnimation::GetRGBAnimationRange()
{
    rgbColorValue rgbReturnVal = {0.0, 0.0, 0.0};

    switch (m_dataToUse)
    {
        case VALUES:
            {
                if (!m_AnimPropState.fInterpolateValues)
                {
                    goto done;
                }

                if (m_numValues < 1)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    rgbReturnVal = m_prgbValues[0];
                }
                else
                {
                    rgbReturnVal = m_prgbValues[m_numValues - 1];
                }
            }
            break;

        case BY:
            {
                rgbColorValue rgbFrom = {0.0, 0.0, 0.0};

                if (m_bFrom)
                {
                    if (!m_AnimPropState.fInterpolateFrom)
                    {
                        goto done;
                    }

                    rgbFrom = m_rgbFrom;
                }

                if (!m_AnimPropState.fInterpolateBy)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    rgbReturnVal = rgbFrom;
                }
                else
                {
                    rgbReturnVal = CreateByValue(rgbFrom);
                }
            }
            break;

        case TO:
            {
                if (!m_AnimPropState.fInterpolateTo)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    if (m_bFrom)
                    {
                        if (!m_AnimPropState.fInterpolateFrom)
                        {
                            goto done;
                        }

                        rgbReturnVal = m_rgbFrom;
                    }

                    // For "to" animations (i.e. no "from"), accumulation is disabled, 
                    // so we do not need to handle it.
                }
                else
                {
                    rgbReturnVal = m_rgbTo;
                }
            }
            break;
        
        default:
            break;
    }

done:
    return rgbReturnVal;
}


///////////////////////////////////////////////////////////////
//  Name: DoAccumulation
//
//  Abstract: Perform the per-tick accumulation
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::DoAccumulation (VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;
    rgbColorValue rgbCurrColor = {0.0, 0.0, 0.0};

    // get the animation range
    rgbColorValue rgbAnimRange = GetRGBAnimationRange();

    // get the number of iterations elapsed
    long lCurrRepeatCount = GetMMBvr().GetCurrentRepeatCount();

    if ((VT_R8 | VT_ARRAY) == V_VT(pvarValue))
    {
        IGNORE_HR(RGBVariantVectorToRGBValue(pvarValue, &rgbCurrColor));
    }
    else
    {
        hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    rgbCurrColor.red += (rgbAnimRange.red * lCurrRepeatCount);
    rgbCurrColor.green += (rgbAnimRange.green * lCurrRepeatCount);
    rgbCurrColor.blue += (rgbAnimRange.blue * lCurrRepeatCount);

    IGNORE_HR(RGBValueToRGBVariantVector(&rgbCurrColor, pvarValue));

done:
    return;
} // DoAccumulation 


///////////////////////////////////////////////////////////////
//  Name: OnFinalUpdate
//
//  Abstract: Called when this fragment updates the value for the final time.
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;

    SUPER::OnFinalUpdate(pvarCurrent, pvarValue);    

    // If we need to send an updated value back to the 
    // composer, make sure to convert to the composition
    // format.  This happens when we shove in the fill 
    // value (still in the native string format).
    if ((VT_BSTR == V_VT(pvarValue)) &&
        (NULL != V_BSTR(pvarValue)))
    {
        hr = THR(RGBVariantStringToRGBVariantVectorInPlace(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_varLastValue.Copy(pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

done :
    return;
} // OnFinalUpdate

///////////////////////////////////////////////////////////////
//  Name: hasEmptyStartingPoint
//
//  Abstract: Does this fragment have a valid starting value?
//    
///////////////////////////////////////////////////////////////
bool
CTIMEColorAnimation::hasEmptyStartingPoint (void)
{
    return (   (VT_BSTR == V_VT(&m_varStartValue)) 
            && (IsColorUninitialized(V_BSTR(&m_varStartValue)))
           );
} // hasEmptyStartingPoint

///////////////////////////////////////////////////////////////
//  Name: fallbackToDiscreteCalculation
//
//  Abstract: If we find that we cannot perform a continuous 
//            calculation, we should fall back to a discrete one.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::fallbackToDiscreteCalculation (VARIANT *pvarValue)
{
    HRESULT hr;

    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = calculateDiscreteValue(pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // fallbackToDiscreteCalculation


///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculateDiscreteValue (VARIANT *pvarValue)
{
    HRESULT hr;

    // If there's no initial value,  
    // we need to set up the destination 
    // variable.
    if (hasEmptyStartingPoint())
    {
        if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
        {
            hr = THR(CreateInitialRGBVariantVector(pvarValue));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    switch ( m_dataToUse)
    {
        case VALUES:
            {
                int curSeg = CalculateCurrentSegment(true);

                hr = RGBStringToRGBVariantVector (m_ppstrValues[curSeg], pvarValue);
                if (FAILED(hr))
                {
                    goto done;
                }
                TraceTag((tagAnimationColorInterpolate,
                          "CTIMEColorAnimation(%lx)::discrete(%10.4lf) : value[%d] =%ls",
                          this, GetMMBvr().GetProgress(), curSeg, m_ppstrValues[curSeg]));
            }
            break;

        case BY:
            {
                rgbColorValue rgbNewBy;

                // get "from" value
                if (m_bFrom)
                {
                    // Add "by" value only if second half of interval
                    if (GetMMBvr().GetProgress() >= 0.5)
                    {
                        rgbNewBy = CreateByValue(m_rgbFrom);
                    }
                    else
                    {
                        // just use from value
                        rgbNewBy = m_rgbFrom;
                    }
                }
                else
                {
                    // just use by value
                    rgbNewBy = m_rgbBy;
                }
                
                hr = RGBValueToRGBVariantVector (&rgbNewBy, pvarValue);
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            break;

        case TO:
            {
                if (m_bFrom && (GetMMBvr().GetProgress() < 0.5))
                {
                    // use the from value
                    hr = RGBValueToRGBVariantVector(&m_rgbFrom, pvarValue);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
                else
                {
                    // use the to value
                    hr = RGBStringToRGBVariantVector (V_BSTR(&m_varTo), pvarValue);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }

                TraceTag((tagAnimationColorInterpolate,
                          "CTIMEColorAnimation(%lx)::discrete(%10.4lf) : to=%ls",
                          this, GetMMBvr().GetProgress(), V_BSTR(&m_varTo)));
            }
            break;
        
        default:
            break;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}  // calculateDiscreteValue


///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculateLinearValue (VARIANT *pvarValue)
{
    HRESULT hr = S_OK;
    double        dblProgress = 0.0;
    rgbColorValue rgbColor = {0};
    CComVariant cVar;
    
    // If there's no basis for interpolation, try 
    // doing a discrete animation.
    if (hasEmptyStartingPoint())
    {
        hr = fallbackToDiscreteCalculation(pvarValue);
        goto done;
    }

    dblProgress = GetMMBvr().GetProgress();

    if (m_dataToUse == VALUES)
    {
        double curProgress = CalculateProgressValue(false);
        int    curSeg      = CalculateCurrentSegment(false);

        rgbColor.red = InterpolateValues(m_prgbValues[curSeg].red, m_prgbValues[curSeg+1].red, curProgress);
        rgbColor.green = InterpolateValues(m_prgbValues[curSeg].green, m_prgbValues[curSeg+1].green, curProgress);
        rgbColor.blue = InterpolateValues(m_prgbValues[curSeg].blue, m_prgbValues[curSeg+1].blue, curProgress);
    }
    else if (TO == m_dataToUse)
    {
        rgbColorValue rgbFrom;

        if (m_bFrom)
        {
            rgbFrom = m_rgbFrom;
        }
        else
        {
            IGNORE_HR(RGBVariantVectorToRGBValue (&m_varCurrentBaseline, &rgbFrom));            
        }

        rgbColor.red = InterpolateValues(rgbFrom.red, m_rgbTo.red, dblProgress);
        rgbColor.green = InterpolateValues(rgbFrom.green, m_rgbTo.green, dblProgress);
        rgbColor.blue = InterpolateValues(rgbFrom.blue, m_rgbTo.blue, dblProgress);
    }
    else if (BY == m_dataToUse)
    {
        rgbColorValue rgbFrom;
        rgbColorValue rgbTo;

        if (m_bFrom)
        {
            rgbFrom = m_rgbFrom;
        }
        else
        {
            rgbFrom.red = 0.0;
            rgbFrom.green = 0.0;
            rgbFrom.blue = 0.0;
        }

        rgbTo = CreateByValue(rgbFrom);

        rgbColor.red = InterpolateValues(rgbFrom.red, rgbTo.red, dblProgress);
        rgbColor.green = InterpolateValues(rgbFrom.green, rgbTo.green, dblProgress);
        rgbColor.blue = InterpolateValues(rgbFrom.blue, rgbTo.blue, dblProgress);
    }
   
    TraceTag((tagAnimationColorInterpolate,
              "CTIMEColorAnimation(%lx)::linear() : progress(%lf) %lf %lf %lf",
              this, dblProgress, rgbColor.red, rgbColor.green, rgbColor.blue));

    hr = RGBValueToRGBVariantVector(&rgbColor, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculateSplineValue (VARIANT *pvarValue)
{
    HRESULT hr;

    // If there's no basis for interpolation, try 
    // doing a discrete animation.
    if (hasEmptyStartingPoint())
    {
        hr = fallbackToDiscreteCalculation(pvarValue);
        goto done;
    }
    
    if (VALUES == m_dataToUse)
    {
        rgbColorValue   rgbColor;
        double          dblTimeProgress = CalculateProgressValue(false);
        int             curSeg          = CalculateCurrentSegment(false);

        if (   (NULL == m_pKeySplinePoints) 
            || (m_numKeySplines <= curSeg))
        {
            hr = E_FAIL;
            goto done;
        }

        // compute spline progess and interpolate
        {
            double dblSplineProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg],dblTimeProgress);

            rgbColor.red = InterpolateValues(m_prgbValues[curSeg].red, m_prgbValues[curSeg+1].red, dblSplineProgress);
            rgbColor.green = InterpolateValues(m_prgbValues[curSeg].green, m_prgbValues[curSeg+1].green, dblSplineProgress);
            rgbColor.blue = InterpolateValues(m_prgbValues[curSeg].blue, m_prgbValues[curSeg+1].blue, dblSplineProgress);

            TraceTag((tagAnimationColorInterpolate,
                      "CTIMEColorAnimation(%lx)::spline : time progress(%lf) spline progress(%lf) %lf %lf %lf",
                      this, dblTimeProgress, dblSplineProgress, rgbColor.red, rgbColor.green, rgbColor.blue));
        }

        hr = RGBValueToRGBVariantVector(&rgbColor, pvarValue);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = calculateLinearValue(pvarValue);
        if (FAILED(hr))
        {
            goto done;
        }
    }


    hr = S_OK;
done :
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculatePacedValue (VARIANT *pvarValue)
{
    HRESULT         hr = S_OK;
    double          dblCurDistance;
    double          dblLastDistance = 0.0;
    double          dblSegLength;
    double          dblDistance;
    double          dblProgress;
    int             i;
    rgbColorValue   rgbColor;
    CComVariant     svarTemp;

    // If there's no basis for interpolation, try 
    // doing a discrete animation.
    if (hasEmptyStartingPoint())
    {
        hr = fallbackToDiscreteCalculation(pvarValue);
        goto done;
    }

    // This only makes sense if you are using m_dataToUse == VALUES
    if (    (m_dataToUse != VALUES)
        ||  (   (VALUES == m_dataToUse)
             && (1 == m_numValues)))
    {
        hr = THR(calculateLinearValue(pvarValue));
        goto done;
    }

    // how much distance should we have traveled?
    dblCurDistance = InterpolateValues(0.0, 
                                       m_dblTotalDistance, 
                                       GetMMBvr().GetProgress());

    // find current segment
    for (i = 1, dblDistance = 0.0; 
         (i < m_numValues)  
         && (dblDistance <= dblCurDistance);
         i++)
    {
        dblLastDistance = dblDistance;
        dblDistance += CalculateDistance(m_prgbValues[i-1], m_prgbValues[i]); 
    }

    // adjust the index
    i = (i <= 1) ? 1 : i - 1;

    // get the length of the last segment
    dblSegLength = CalculateDistance(m_prgbValues[i-1], m_prgbValues[i]); 
    if (0 == dblSegLength)
    {
        goto done;
    }

    // get the normalized progress in the segment
    dblProgress = (dblCurDistance - dblLastDistance) / dblSegLength;

    rgbColor.red = InterpolateValues(m_prgbValues[i-1].red, m_prgbValues[i].red, dblProgress);
    rgbColor.green = InterpolateValues(m_prgbValues[i-1].green, m_prgbValues[i].green, dblProgress);
    rgbColor.blue = InterpolateValues(m_prgbValues[i-1].blue, m_prgbValues[i].blue, dblProgress);
  
    TraceTag((tagAnimationColorInterpolate,
              "CTIMEColorAnimation(%p):: paced : progress(%lf) %lf %lf %lf",
              this, GetMMBvr().GetProgress(), 
              rgbColor.red, rgbColor.green, rgbColor.blue));

    hr = RGBValueToRGBVariantVector(&rgbColor, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: CalculateDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEColorAnimation::CalculateDistance(rgbColorValue a, rgbColorValue b)
{
    double deltaR,deltaG,deltaB;

    deltaR = a.red - b.red;
    deltaG = a.green - b.green;
    deltaB = a.blue - b.blue;
    return(sqrt((double)((deltaR*deltaR) + (deltaG*deltaG) + (deltaB*deltaB))));
}


///////////////////////////////////////////////////////////////
//  Name: CalculateTotalDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::CalculateTotalDistance()
{
    int index;

    m_dblTotalDistance = 0.0;

    if (    (NULL == m_prgbValues)
        ||  (m_numValues < 2))
    {
        goto done;
    }

    for (index=1; index < m_numValues; index++)
    {
        m_dblTotalDistance += CalculateDistance(m_prgbValues[index-1], m_prgbValues[index]);
    }

done:
    return;
}


///////////////////////////////////////////////////////////////
//  Name: CreateByValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
rgbColorValue
CTIMEColorAnimation::CreateByValue(const rgbColorValue & rgbCurrent)
{
    rgbColorValue rgbNew;

    rgbNew.red = rgbCurrent.red + (m_byNegative?(-m_rgbBy.red):(m_rgbBy.red));
    rgbNew.green = rgbCurrent.green + (m_byNegative?(-m_rgbBy.green):(m_rgbBy.green));
    rgbNew.blue = rgbCurrent.blue + (m_byNegative?(-m_rgbBy.blue):(m_rgbBy.blue));

    return rgbNew;
}

///////////////////////////////////////////////////////////////
//  Name: DoAdditive
//
//  Abstract: Add the offset value into the composition's in/out param.
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue)
{
    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Detected additive animation",
              this, GetID()?GetID():L""));

    rgbColorValue rgbOrig;
    rgbColorValue rgbCurrent;
    HRESULT hr;

    // get RGB value for first arg
    if ((VT_ARRAY | VT_R8) == V_VT(pvarOrig))
    {
        hr = THR(RGBVariantVectorToRGBValue (pvarOrig, &rgbOrig));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (VT_BSTR == V_VT(pvarOrig))
    {
        hr = THR(RGBStringToRGBValue(V_BSTR(pvarOrig), &rgbOrig));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // get RGB value for second arg
    if ((VT_ARRAY | VT_R8) == V_VT(pvarValue))
    {
        hr = THR(RGBVariantVectorToRGBValue (pvarValue, &rgbCurrent));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (VT_BSTR == V_VT(pvarValue))
    {
        hr = THR(RGBStringToRGBValue (V_BSTR(pvarValue), &rgbCurrent));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // No need to convert to xyz as the matrices reduce to 
    // simple vector addition (r0+r1 g0+g1 b0+b1)
    // Also need to make sure to handle the negative 'by' case.

    rgbCurrent.red += rgbOrig.red;
    rgbCurrent.green += rgbOrig.green;
    rgbCurrent.blue += rgbOrig.blue;

    // Ensure we have a variant vector
    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(RGBValueToRGBVariantVector(&rgbCurrent, pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Orig=(%lf, %lf, %lf)", 
              this, GetID()?GetID():L"", rgbOrig.red, rgbOrig.blue, rgbOrig.green));

    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Curr=(%lf, %lf, %lf)", 
              this, GetID()?GetID():L"", rgbCurrent.red, rgbCurrent.blue, rgbCurrent.green));

    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Added=(%lf, %lf, %lf)", 
              this, GetID()?GetID():L"", rgbCurrent.red, rgbCurrent.blue, rgbCurrent.green));

done :
    return;
} // DoAdditive

///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::CanonicalizeValue (VARIANT *pvarOriginal, VARTYPE *pvtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UncanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::UncanonicalizeValue (VARIANT *pvarOriginal, VARTYPE vtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // UncanonicalizeValue


///////////////////////////////////////////////////////////////
//  Name: GetFinalByValue
//
//  Abstract: Get the final state of the BY animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::GetFinalByValue(VARIANT *pvarValue)
{
    rgbColorValue rgbNewBy;

    VariantClear(pvarValue);

    Assert(BY == m_dataToUse);

    if (m_bFrom)
    {
        // Add "by" value to "from" value
        rgbNewBy = CreateByValue(m_rgbFrom);
    }
    else
    {
        // just use by value
        rgbNewBy = m_rgbBy;
    }
    
    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        HRESULT hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    IGNORE_HR(RGBValueToRGBVariantVector (&rgbNewBy, pvarValue));

done:
    return;
} // GetFinalByValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: animelm.cpp
 *
 * Abstract: Simple animation of Elements
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "animfrag.h"
#include "animelm.h"
#include "animutil.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  
DeclareTag(tagAnimationTimeElm, "SMIL Animation", "CTIMEAnimationBase methods")
DeclareTag(tagAnimationTimeElmTest, "SMIL Animation", "CTIMEAnimationBase introspection")
DeclareTag(tagAnimationBaseValue, "SMIL Animation", "CTIMEAnimationBase composition callbacks")
DeclareTag(tagAnimationBaseValueAdditive, "SMIL Animation", "CTIMEAnimationBase additive animation")
DeclareTag(tagAnimationBaseState, "SMIL Animation", "CTIMEAnimationBase composition state changes")
DeclareTag(tagAnimationBaseOnChanged, "SMIL Animation", "CTIMEAnimationBase OnChanged method")
DeclareTag(tagAnimationTimeEvents, "SMIL Animation", "time events")
DeclareTag(tagAnimationFill, "SMIL Animation", "fill detection")
DeclareTag(tagAnimAccumulate, "SMIL Animation", "CTIMEAnimationBase Accumulation")

#define DEFAULT_ATTRIBUTE     NULL
#define DEFAULT_ADDITIVE      false
#define DEFAULT_ACCUMULATE    false
#define DEFAULT_TARGET        NULL
#define DEFAULT_KEYTIMES      NULL
#define DEFAULT_VALUES        NULL
#define DEFAULT_CALCMODE      CALCMODE_LINEAR
#define DEFAULT_ORIGIN        ORIGIN_DEFAULT
#define DEFAULT_PATH          NULL
#define DEFAULT_KEYSPLINES    NULL

#define NUMBER_KEYSPLINES     4
#define VALUE_NOT_SET         -999.998

static const LPWSTR s_cPSTR_SEMI_SEPARATOR  = L";";
static const LPWSTR s_cPSTR_SPACE_SEPARATOR = L" ";

long g_LOGPIXELSX = 0;
long g_LOGPIXELSY = 0;

///////////////////////////////////////////////////////////////
//  Name: CTIMEAnimationBase
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMEAnimationBase::CTIMEAnimationBase()
: m_bNeedAnimInit(true),
  m_spFragmentHelper(NULL),
  m_SAAttribute(DEFAULT_ATTRIBUTE),
  m_bAdditive(DEFAULT_ADDITIVE),
  m_bAdditiveIsSum(DEFAULT_ADDITIVE),
  m_bAccumulate(DEFAULT_ACCUMULATE),
  m_SATarget(DEFAULT_TARGET),
  m_SAValues(DEFAULT_VALUES),
  m_SAKeyTimes(DEFAULT_KEYTIMES),
  m_IACalcMode(DEFAULT_CALCMODE),
  m_SAPath(DEFAULT_PATH),
  m_IAOrigin(DEFAULT_ORIGIN),
  m_SAType(NULL),
  m_SASubtype(NULL),
  m_SAMode(NULL),
  m_SAFadeColor(NULL),
  m_VAFrom(NULL),
  m_VATo(NULL),
  m_VABy(NULL),
  m_bFrom(false),
  m_bNeedFirstUpdate(false),
  m_bNeedFinalUpdate(false),
  m_bNeedStartUpdate(false),
  m_bVML(false),
  m_fPropsLoaded(false),
  m_numValues(0),
  m_numKeyTimes(0),
  m_ppstrValues(NULL),
  m_pdblKeyTimes(NULL),
  m_dataToUse(NONE),
  m_dblTotalDistance(0.0),
  m_numKeySplines(0),
  m_pKeySplinePoints(NULL),
  m_SAKeySplines(DEFAULT_KEYSPLINES),
  m_SAAdditive(NULL),
  m_SAAccumulate(NULL),
  m_bNeedToSetInitialState(true)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::CTIMEAnimationBase()",
              this));

    m_AnimPropState.fDisableAnimation = false;
    m_AnimPropState.fForceCalcModeDiscrete = false;

    m_AnimPropState.fInterpolateValues = true;
    m_AnimPropState.fInterpolateFrom = true;
    m_AnimPropState.fInterpolateTo = true;
    m_AnimPropState.fInterpolateBy = true;

    m_AnimPropState.fBadBy = false;
    m_AnimPropState.fBadTo = false;
    m_AnimPropState.fBadFrom = false;
    m_AnimPropState.fBadValues = false;
    m_AnimPropState.fBadKeyTimes = false;

    m_AnimPropState.fAccumulate = false;
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMEAnimationBase
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMEAnimationBase::~CTIMEAnimationBase()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::~CTIMEAnimationBase()",
              this));
    
    int i;

    if (m_ppstrValues)
    {
        for (i = 0; i <m_numValues;i++)
        {
            delete [] m_ppstrValues[i];
        }
        delete [] m_ppstrValues;
    }
    if (m_pdblKeyTimes)
    {
        delete [] m_pdblKeyTimes;
    }
    if (m_pKeySplinePoints)
    {
        delete [] m_pKeySplinePoints;
    }

    delete [] m_SAAttribute.GetValue();
    delete [] m_SATarget.GetValue();
    delete [] m_SAValues.GetValue();
    delete [] m_SAKeyTimes.GetValue();
    delete [] m_SAKeySplines.GetValue();
    delete [] m_SAAccumulate.GetValue();
    delete [] m_SAAdditive.GetValue();
    delete [] m_SAPath.GetValue();
} 

///////////////////////////////////////////////////////////////
//  Name: CreateFragmentHelper
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::CreateFragmentHelper (void)
{
    HRESULT hr;

    if (m_spFragmentHelper != NULL)
    {
        IGNORE_RETURN(m_spFragmentHelper->Release());
    }

    hr = THR(CComObject<CAnimationFragment>::CreateInstance(&m_spFragmentHelper));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    IGNORE_RETURN(m_spFragmentHelper->AddRef());

    hr = m_spFragmentHelper->SetFragmentSite(this);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        m_spFragmentHelper->Release();
        m_spFragmentHelper = NULL;
    }

    RRETURN(hr);
} // CreateFragmentHelper

///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    CComPtr<IHTMLWindow2>   pWindow2;
    CComPtr<IHTMLScreen>    pScreen;
    CComPtr<IHTMLScreen2>   pScreen2;

    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Init()",
              this));

    HRESULT hr = E_FAIL; 
    CComPtr <IDispatch> pDocDisp;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }     

    hr = THR(GetElement()->get_document(&pDocDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&m_spDoc2));
    if (FAILED(hr))
    {
        goto done;
    }

    initScriptEngine();

    //get all elements in the document
    hr = THR(m_spDoc2->get_all(&m_spEleCol));
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument3, (void**)&m_spDoc3));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateFragmentHelper();
    if (FAILED(hr))
    {
        goto done;
    }

    if (g_LOGPIXELSX == 0 || g_LOGPIXELSY == 0)
    {
        hr = m_spDoc2->get_parentWindow(&pWindow2);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = pWindow2->get_screen(&pScreen);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = THR(pScreen->QueryInterface(IID_IHTMLScreen2, (void**)&pScreen2));
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = pScreen2->get_logicalXDPI(&g_LOGPIXELSX);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = pScreen2->get_logicalYDPI(&g_LOGPIXELSY);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }
    }

    hr = S_OK;

done:
    RRETURN(hr);

defaultDPI:
    AssertSz(FALSE, "Failed to determine logical DPI.  Using default 96 dpi.");
    g_LOGPIXELSX = 96;
    g_LOGPIXELSY = 96;
    goto done;
}


///////////////////////////////////////////////////////////////
//  Name: Error
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::Error()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Error()",
              this));
    
    LPWSTR  str = TIMEGetLastErrorString();
    HRESULT hr  = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEAnimationBase, &__uuidof(CTIMEAnimationBase)>::Error(str, IID_ITIMEAnimationElement, hr);
        delete [] str;
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: Notify
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Notify()",
              this));

    HRESULT hr = THR(CTIMEElementBase::Notify(event, pVar));

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: Detach
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::Detach()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Detach()",
              this));

    IGNORE_RETURN(NotifyOnDetachFromComposer());
    if (m_spFragmentHelper != NULL)
    {
        m_spFragmentHelper->SetFragmentSite(NULL);
        IGNORE_RETURN(m_spFragmentHelper->Release());
        m_spFragmentHelper = NULL;
    }

    THR(CTIMEElementBase::Detach());
  
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyOnGetElement
//
//  Abstract: Get the fragment's element dispatch.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::NotifyOnGetElement (IDispatch **ppidispElement)
{
    HRESULT hr;

    if (NULL == ppidispElement)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *ppidispElement = GetElement();
    Assert(NULL != (*ppidispElement));
    IGNORE_RETURN((*ppidispElement)->AddRef());

    hr = S_OK;
done :
    RRETURN(hr);
} // NotifyOnGetElement


///////////////////////////////////////////////////////////////
//  Name: UpdateStartValue
//
//  Abstract: Refresh the m_varStartValue
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::UpdateStartValue (VARIANT *pvarNewStartValue)
{
    if (m_bNeedStartUpdate)
    {
        m_varStartValue.Clear();
        m_varStartValue.Copy(pvarNewStartValue);
        ConvertToPixels(&m_varStartValue);
        m_bNeedStartUpdate = false;
    }
} // UpdateStartValue 


///////////////////////////////////////////////////////////////
//  Name: GetAnimationRange
//
//  Abstract: Get the end point of the animation function over the
//            simple duration
//
///////////////////////////////////////////////////////////////
double 
CTIMEAnimationBase::GetAnimationRange()
{
    double dblReturnVal = 0.0;
    HRESULT hr = E_FAIL;
    CComVariant svarReturnVal(0.0);

    switch (m_dataToUse)
    {
        case VALUES:
            {
                if (!m_AnimPropState.fInterpolateValues)
                {
                    goto done;
                }

                if (m_numValues > 0)
                {
                    if (GetAutoReverse())
                    {
                        svarReturnVal = m_ppstrValues[0];
                    }
                    else
                    {
                        svarReturnVal = m_ppstrValues[m_numValues - 1];
                    }

                    if (NULL == svarReturnVal .bstrVal)
                    {
                        goto done;
                    }
                }
            }
            break;

        case TO:
            {
                if (!m_AnimPropState.fInterpolateTo)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    if (m_bFrom)
                    {
                        if (!m_AnimPropState.fInterpolateFrom)
                        {
                            goto done;
                        }
                    
                        hr = VariantCopy(&svarReturnVal , &m_varFrom);
                        if (FAILED(hr))
                        {
                            goto done;
                        }
                    }

                    // For "to" animations (i.e. no "from"), accumulation is disabled, 
                    // so we do not need to handle it.
                }
                else
                {
                    hr = VariantCopy(&svarReturnVal , &m_varTo);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
            }
            break;

        case BY:
            {
                double dblFrom = 0.0;

                if (!m_AnimPropState.fInterpolateBy)
                {
                    goto done;
                }

                if (m_bFrom)
                {
                    CComVariant svarFrom;
                    
                    if (!m_AnimPropState.fInterpolateFrom)
                    {
                        goto done;
                    }

                    hr = VariantCopy(&svarFrom, &m_varFrom);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                
                    if (ConvertToPixels(&svarFrom))
                    {
                        dblFrom = V_R8(&svarFrom);
                    }
                }

                if (GetAutoReverse())
                {
                    svarReturnVal = dblFrom;
                }
                else
                {
                    hr = VariantCopy(&svarReturnVal , &m_varBy);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    if (ConvertToPixels(&svarReturnVal))
                    {
                        V_R8(&svarReturnVal) += dblFrom;
                    }
                }
            }
            break;

        default:
            break;
    } // switch

    if (ConvertToPixels(&svarReturnVal))
    {
        dblReturnVal = V_R8(&svarReturnVal );
    }

done:
    return dblReturnVal;
}

///////////////////////////////////////////////////////////////
//  Name: DoAccumulation
//
//  Abstract: 
//    
///////////////////////////////////////////////////////////////
void 
CTIMEAnimationBase::DoAccumulation (VARIANT *pvarValue)
{
    if (VT_R8 != V_VT(pvarValue))
    {
        if (!ConvertToPixels(pvarValue))
        {
            goto done;
        }
    }

    // offset the current value with the accumulated iterations
    if (VT_R8 == V_VT(pvarValue))
    {
        // get the animation range
        double dblAnimRange = GetAnimationRange();

        // get the number of iterations elapsed
        long lCurrRepeatCount = GetMMBvr().GetCurrentRepeatCount();

        V_R8(pvarValue) += dblAnimRange * lCurrRepeatCount;

        TraceTag((tagAnimAccumulate, "CTIMEAnimationBase(%p, %ls)::DoAccumulation range=%lf currRepeatCount=%d",
            this, GetID(), dblAnimRange, lCurrRepeatCount));
    }

done:
    return;
} // DoAccumulation


///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract: Convert a variant into canonical form (BSTR or R8).
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld)
{
    HRESULT hr;

    // Preprocess the data into a canonical form
    // for this fragment - that is either a
    // BSTR or a VT_R8.
    if ((VT_R8 != V_VT(pvarValue)) && (VT_BSTR != V_VT(pvarValue)))
    {
        // VT_R8 is the closest thing we have to a canonical form for composition
        // and interpolation.
        *pvtOld = V_VT(pvarValue);
        hr = THR(::VariantChangeTypeEx(pvarValue, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UncanonicalizeValue
//
//  Abstract: Convert a variant from canonical form (BSTR or R8)
//            into its original form.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::UncanonicalizeValue (VARIANT *pvarValue, VARTYPE vtOld)
{
    HRESULT hr;

    if (VT_EMPTY != vtOld)
    {
        hr = THR(::VariantChangeTypeEx(pvarValue, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, vtOld));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // UncanonicalizeValue


///////////////////////////////////////////////////////////////
//  Name: ValidateState
//
//  Abstract: Checks state of properties. Determines whether:
//              1. Animation should be disabled
//              2. CalcMode should be forced to "discrete"
//            
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::ValidateState()
{
    bool fIsValid = false;

    // see which attributes have been set
    bool fValues         = ((VALUES == m_dataToUse) || m_AnimPropState.fBadValues);
    bool fKeyTimes       = (m_AnimPropState.fBadKeyTimes || m_pdblKeyTimes || m_numKeyTimes);
    bool fKeySplines     = (m_pKeySplinePoints || m_numKeySplines);
    bool fCalcModeSpline = (CALCMODE_SPLINE == m_IACalcMode);
    bool fCalcModeLinear = (CALCMODE_LINEAR == m_IACalcMode);
    bool fCalcModePaced  = (CALCMODE_PACED  == m_IACalcMode);
    bool fTo             = (m_AnimPropState.fBadTo || (TO == m_dataToUse));

    //
    // The order of checking is important. For an attribute below to be valid, all attributes
    // checked before it must be valid.
    //

    // Validate from/by/to (ignored if "values" is specified)
    if (!fValues)
    {
        if (m_AnimPropState.fBadFrom || m_AnimPropState.fBadTo)
        {
            goto done;
        }

        // validate "by" (ignored if "to" is specified)
        if (!fTo && m_AnimPropState.fBadBy)
        {
            goto done;
        }

        // check if we need to default to calcMode="discrete" 
        if (    (!m_AnimPropState.fInterpolateFrom)
            ||  (!m_AnimPropState.fInterpolateTo)
            ||  (   (!fTo)
                 && (!m_AnimPropState.fInterpolateBy)))
        {
            m_AnimPropState.fForceCalcModeDiscrete = true;
        }
        else
        {
            m_AnimPropState.fForceCalcModeDiscrete = false;
        }
    }
    else
    {
        // Validate values
        if (m_AnimPropState.fBadValues || !m_ppstrValues || !m_numValues)
        {
            goto done;
        }

        // check if we need to default to calcMode="discrete" 
        if (    (m_numValues < 2)
            ||  (false == m_AnimPropState.fInterpolateValues))
        {
            m_AnimPropState.fForceCalcModeDiscrete = true;
        }
        else
        {
            m_AnimPropState.fForceCalcModeDiscrete = false;
        }
    }

    // validate keyTimes
    if (!fCalcModePaced)
    {
        // validate keyTimes 
        if (fKeyTimes)
        {
            if (m_AnimPropState.fBadKeyTimes || !m_pdblKeyTimes || !m_numKeyTimes)
            {
                goto done;
            }
            else if ((fCalcModeLinear || fCalcModeSpline)
                    && (1 != m_pdblKeyTimes[m_numKeyTimes - 1]))
            {
                goto done;
            }

            // Not worth putting in a virtual function since m_dataToUse is aware of paths
            if (PATH != m_dataToUse)
            {
                if (!fValues)
                {
                    goto done;
                }
                else if (m_numKeyTimes != m_numValues)
                {
                    goto done;
                }
            }
        }
    }

    // validate CalcMode="spline"
    if (fCalcModeSpline)
    {
        if (!fKeySplines || !fKeyTimes)
        {
            goto done;
        }
        else if (m_numKeySplines != (m_numKeyTimes - 1))
        {
            goto done;
        }
    }

    // validate accumulate
    if (    (TO == m_dataToUse)
        &&  (!m_bFrom))
    {
        // Accumulate ignored for "to" animations (i.e. no "from" specified)
        m_bAccumulate = false;
    }
    else
    {
        // use the accumulate value that was set
        m_bAccumulate = m_AnimPropState.fAccumulate;
    }

    fIsValid = true;
done:
    m_AnimPropState.fDisableAnimation = !(fIsValid);
} // ValidateState

///////////////////////////////////////////////////////////////
//  Name: UpdateCurrentBaseTime
//
//  Abstract: Examine the current base time, and update it if 
//            we're doing baseline+to animation (the spec calls
//            this hybrid additive).
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::UpdateCurrentBaseline (const VARIANT *pvarCurrent)
{
    // Are we doing hybrid additive animation?
    if (   (TO == m_dataToUse)
        && (!m_bFrom))
    {
        // Filter out the initial call (when last-value hasn't been set.
        if (VT_EMPTY != V_VT(&m_varLastValue))
        {
            bool bNeedUpdate = false;

            if (V_VT(&m_varLastValue) == V_VT(pvarCurrent))
            {
                // Has the baseline value changed since we updated it last?
                // We really only care about canonicalized values (R8 or BSTR)
                if (VT_R8 == V_VT(&m_varLastValue))
                {
                    bNeedUpdate = (V_R8(pvarCurrent) != V_R8(&m_varLastValue));
                }
                else if (VT_BSTR == V_VT(&m_varLastValue))
                {
                    bNeedUpdate = (0 != StrCmpW(V_BSTR(pvarCurrent), V_BSTR(&m_varLastValue)));
                }
            }
            else
            {
                bNeedUpdate = true;
            }

            if (bNeedUpdate)
            {
                THR(::VariantCopy(&m_varCurrentBaseline, const_cast<VARIANT *>(pvarCurrent)));
            }
        }
    }
} // UpdateCurrentBaseTime

///////////////////////////////////////////////////////////////
//  Name: CalculateValue
//
//  Abstract: Do interpolation and postprocessing.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::CalculateValue (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;

    if (m_AnimPropState.fForceCalcModeDiscrete)
    {
        hr = calculateDiscreteValue(pvarValue);
    }
    else
    {
        switch(m_IACalcMode)
        {
            case CALCMODE_DISCRETE :
                hr = calculateDiscreteValue(pvarValue);
                break;

            case CALCMODE_LINEAR :
                hr = calculateLinearValue(pvarValue);
                break;

            case CALCMODE_SPLINE :
                hr = calculateSplineValue(pvarValue);
                break;

            case CALCMODE_PACED :
                hr = calculatePacedValue(pvarValue);
                break;
        
            default :
                break;
        }
    }

    PostprocessValue(pvarCurrent, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CalculateValue

///////////////////////////////////////////////////////////////
//  Name: DoAdditive
//
//  Abstract: Add the offset value into the composition's in/out param.
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue)
{
    if (VT_R8 != V_VT(pvarValue))
    {
        if (!ConvertToPixels(pvarValue))
        {
            goto done;
        }
    }

    Assert(VT_R8 == V_VT(pvarValue));
    if (VT_R8 == V_VT(pvarValue))
    {
        CComVariant varCurrentCopy;
        HRESULT hr = THR(varCurrentCopy.Copy(pvarOrig));

        if (FAILED(hr))
        {
            goto done;
        }

        // Need to translate this into numeric form, in
        // order to perform the addition.
        if (!ConvertToPixels(&varCurrentCopy))
        {
            TraceTag((tagAnimationBaseValueAdditive,
                      "CTIMEAnimationBase(%p)::DoAdditive() : Failed to convert current value of type %X to numeric form",
                      this, V_VT(&varCurrentCopy)));
            goto done;
        }

        TraceTag((tagAnimationBaseValueAdditive,
                  "CTIMEAnimationBase(%p)::DoAdditive(calculated value is %lf, previous current value is %lf)",
                  this, V_R8(pvarValue), V_R8(&varCurrentCopy)));
        V_R8(pvarValue) += V_R8(&varCurrentCopy);
    }

done :
    return;
} // DoAdditive

///////////////////////////////////////////////////////////////
//  Name: DoFill
//
//  Abstract: Handle the fill interval.
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEAnimationBase::DoFill (VARIANT *pvarValue)
{
    HRESULT hr;

    if (IsOn() && m_varLastValue.vt != VT_EMPTY && m_timeAction.IsTimeActionOn())
    {
#if DBG
        {
            CComVariant varLast;
            varLast.Copy(&m_varLastValue);
            varLast.ChangeType(VT_R8);
            TraceTag((tagAnimationFill,
                      "CTIMEAnimationBase(%p, %ls) detected fill to %lf",
                      this, GetID(), V_R8(&varLast)));
        }
#endif

        VariantCopy(pvarValue,&m_varLastValue);
        m_bNeedToSetInitialState = true;
    }
    else if (m_bNeedToSetInitialState)
    {
#if DBG
        {
            CComVariant varBase;
            varBase.Copy(&m_varBaseline);
            varBase.ChangeType(VT_R8);
            TraceTag((tagAnimationFill,
                      "CTIMEAnimationBase(%p, %ls) applying initial value %lf",
                      this, GetID(), V_R8(&varBase)));
        }
#endif
        VariantCopy(pvarValue,&m_varBaseline);
        m_bNeedToSetInitialState = false;
        SetFinalState();
    }
    else
    {
        // Fail on the case that we have never started..
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_FAIL);
} // DoFill

///////////////////////////////////////////////////////////////
//  Name: PostprocessValue
//
//  Abstract: Apply additive, accumulate passes and save the value.
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    if (m_bAdditive)
    {
        DoAdditive(pvarCurrent, pvarValue);
    }
    if (m_bAccumulate)
    {
        DoAccumulation(pvarValue);
    }
    THR(::VariantCopy(&m_varLastValue, pvarValue));

    TraceTag((tagAnimAccumulate, "CTIMEAnimationBase(%p, %ls)::PostprocessValue m_varLastValue=%lf",
        this, GetID(), V_R8(&m_varLastValue)));

} // PostprocessValue

///////////////////////////////////////////////////////////////
//  Name: NotifyOnGetValue
//
//  Abstract: Compose the new value of the in/out variant
//            according to our interpolation logic.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::NotifyOnGetValue (BSTR, 
                                      VARIANT varOriginal, VARIANT varCurrentValue, 
                                      VARIANT *pvarInOutValue)
{
    HRESULT hr = S_OK;
    VARTYPE vtOrigType = VT_EMPTY;

    // Do we have work to do?
    if (NONE == m_dataToUse)
    {
        hr = E_FAIL;
        goto done;
    }

    // Check if we need to do anything
    if (DisableAnimation())
    {
        hr = E_FAIL;
        goto done;
    }
    
    // Check first and final states
    // Checking the final state first permits
    // a reset to trigger a final state followed
    // by initial ... this is what needs to happen 
    // during a restart.

    hr = THR(::VariantCopy(pvarInOutValue, &varCurrentValue));
    vtOrigType = V_VT(pvarInOutValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CanonicalizeValue(pvarInOutValue, &vtOrigType);
    if (FAILED(hr))
    {
        goto done;
    }

    if (QueryNeedFinalUpdate())
    {
        OnFinalUpdate(&varCurrentValue, pvarInOutValue);
        hr = S_OK;
        goto done;
    }
    else if (QueryNeedFirstUpdate())
    {
        OnFirstUpdate(pvarInOutValue);
    }
    
    // If we're not playing, apply the fill
    if (IsActive())
    {
        UpdateStartValue(&varOriginal);
        UpdateCurrentBaseline(&varCurrentValue);
        m_varLastValue.Copy(pvarInOutValue);
        hr = CalculateValue(&varCurrentValue, &m_varLastValue);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(::VariantCopy(pvarInOutValue, &m_varLastValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = DoFill(pvarInOutValue);
        goto done;
    }

    hr = S_OK;
done :

    // Postprocess the from canonical form
    // to its original type.
    hr = UncanonicalizeValue(pvarInOutValue, vtOrigType);

    RRETURN(hr);
} // NotifyOnGetValue

///////////////////////////////////////////////////////////////
//  Name: NotifyOnDetachFromComposer
//
//  Abstract: Let go of any refs to the composer site.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEAnimationBase::NotifyOnDetachFromComposer (void)
{
    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstrAttribName;

        bstrAttribName = m_SAAttribute;
        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->RemoveFragment(bstrAttribName, m_spFragmentHelper));
        IGNORE_RETURN(m_spCompSite.Release()); //lint !e792
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // NotifyOnDetachFromComposer

///////////////////////////////////////////////////////////////
//  Name: SetInitialState
//
//  Abstract: set an initial internal state
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::SetInitialState (void)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::SetInitialState()",
              this));

    m_bNeedFirstUpdate = true;
    m_bNeedFinalUpdate = false;
} // SetInitialState

///////////////////////////////////////////////////////////////
//  Name: SetFinalState
//
//  Abstract: set an final internal state
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::SetFinalState (void)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::SetFinalState()",
              this));

    m_bNeedFinalUpdate = true;
} // SetFinalState

///////////////////////////////////////////////////////////////
//  Name: OnFirstUpdate
//
//  Abstract: save the baseline value of the animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnFirstUpdate (VARIANT *pvarValue)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::OnFirstUpdate()",
              this));

    m_varStartValue.Clear();
    m_bNeedStartUpdate = true;
    THR(m_varBaseline.Copy(pvarValue));
    THR(m_varCurrentBaseline.Copy(pvarValue));

    m_bNeedFirstUpdate = false;

#if DBG

    if (VT_BSTR == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value of %ls",
                  this, V_BSTR(pvarValue)));
    }
    else if (VT_R4 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value of %f",
                  this, V_R4(pvarValue)));
    }
    else if (VT_R8 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value of %lf",
                  this, V_R8(pvarValue)));
    }
    else 
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value in variant of type %X",
                  this, V_VT(pvarValue)));
    }
#endif
} // OnFirstUpdate

///////////////////////////////////////////////////////////////
//  Name: OnFinalUpdate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::OnFinalUpdate()",
              this));

    HRESULT hr = E_FAIL;
    bool bNeedPostprocess = false;

    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p, %ls)::OnFinalUpdate() - progress = %lf",
              this,
              GetID()?GetID():L"",
              GetMMBvr().GetProgress()));

    // Ended before we hit progress value of 1, and we want to apply a fill.
    if ((GetMMBvr().GetProgress() != 1) && NeedFill())
    {
        VariantClear(pvarValue);
        hr = THR(::VariantCopy(pvarValue, &m_varLastValue));
        if (FAILED(hr))
        {
            goto done;
        }  
    }
    // Ended when we hit progress value of 1, and we want to apply a fill.
    else if (NeedFill() &&
            (m_dataToUse != NONE))
    {
        bool fDontPostProcess = false;

        GetFinalValue(pvarValue, &fDontPostProcess);

        if (!fDontPostProcess)
        {
            bNeedPostprocess = true;
        }
    }
    // reset the animation - no fill.
    else
    {
        resetValue(pvarValue);
        // Indicate that we don't need to perform 
        // the additive work.
        if (!QueryNeedFirstUpdate())
        {
            endAnimate();
        }
    }

    if (bNeedPostprocess)
    {
        PostprocessValue(pvarCurrent, pvarValue);
    }

done :

#if DBG
    if (VT_BSTR == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is %ls",
                  this, m_SAAttribute, V_BSTR(pvarValue)));
    }
    else if (VT_R4 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is %f",
                  this, m_SAAttribute, V_R4(pvarValue)));
    }
    else if (VT_R8 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is %lf",
                  this, m_SAAttribute, V_R8(pvarValue)));
    }
    else 
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is variant of type %X",
                  this, m_SAAttribute, V_VT(pvarValue)));
    }
#endif

    m_bNeedFinalUpdate = false;
} // OnFinalUpdate

///////////////////////////////////////////////////////////////
//  Name: OnBegin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p, %ls)::OnBegin()",
              this,
              GetID()?GetID():L""));

    if(m_bNeedAnimInit)
    {
        initAnimate();
    }

    SetInitialState();
    CTIMEElementBase::OnBegin(dblLocalTime, flags);
    
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: OnEnd
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnEnd(double dblLocalTime)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p, %ls)::OnEnd()",
              this,
              GetID()?GetID():L""));

    SetFinalState();
    CTIMEElementBase::OnEnd(dblLocalTime);
}


///////////////////////////////////////////////////////////////
//  Name: resetValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::resetValue(VARIANT *pvarValue)
{
    if (m_varBaseline.vt != VT_EMPTY)
    {
        Assert(NULL != pvarValue);
        IGNORE_HR(THR(::VariantCopy(pvarValue, &m_varBaseline)));
        IGNORE_HR(THR(::VariantCopy(&m_varCurrentBaseline, &m_varBaseline)));
    }
}


///////////////////////////////////////////////////////////////
//  Name: OnReset
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p)::OnReset(%lf, %#X)",
              this, dblLocalTime, flags));

    CTIMEElementBase::OnReset(dblLocalTime, flags);
}


///////////////////////////////////////////////////////////////
//  Name: OnTEPropChange
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnTEPropChange(DWORD tePropType)
{
    CTIMEElementBase::OnTEPropChange(tePropType);

    if ((tePropType & TE_PROPERTY_ISON) != 0)
    {
        // check if we need to be added to the composer
        // This condition is true only when an animation is in
        // the fill region but is not added to the composer.
        if (    m_bNeedAnimInit
            &&  m_mmbvr->IsOn()
            &&  (!(m_mmbvr->IsActive()))
            &&  NeedFill()) 
        {
            TraceTag((tagAnimationTimeEvents,
                      "CTIMEAnimationBase(%p, %ls)::OnTEPropChange() - Inited Animation",
                      this,
                      GetID()?GetID():L""));
            // Add ourselves because we need to be ticked in this condition.
            initAnimate();

            // need to recalc our final state to ensure correct fill value
            m_bNeedFinalUpdate = true;
        }
    }
} // OnTEPropChange


///////////////////////////////////////////////////////////////
//  Name: OnUnload
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnUnload()
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p)::OnUnload()",
              this));

    CTIMEElementBase::OnUnload();
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEAnimationBase::NotifyPropertyChanged, CBaseBvr
//
//  Synopsis:   Make sure to force any in-progress animations to initialize when
//              a property changes.
//
//  Arguments:  DISPID of the changed property (passed to the superclass implementation.
//
//  Returns:    
//
//------------------------------------------------------------------------------------
void 
CTIMEAnimationBase::NotifyPropertyChanged(DISPID dispid)
{
    CTIMEElementImpl<ITIMEAnimationElement2, &IID_ITIMEAnimationElement2>::NotifyPropertyChanged(dispid);

    // If we're already initialized, make sure to force a restart.
    if (m_fPropsLoaded)
    {
        resetAnimate();
    }

done :
    return;
} // NotifyPropertyChanged

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEAnimationBase::OnPropertiesLoaded, CBaseBvr
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEAnimationBase::OnPropertiesLoaded(void)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p)::OnPropertiesLoaded()",
              this));

    HRESULT hr;
    // Once we've read the properties in, 
    // set up the timeline.  This is immutable
    // in script.

    hr = CTIMEElementBase::OnPropertiesLoaded();
    m_fPropsLoaded = true;

done:
    RRETURN(hr);
} // OnPropertiesLoaded


///////////////////////////////////////////////////////////////
//  Name: GetConnectionPoint
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEAnimationBase::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

///////////////////////////////////////////////////////////////
//  Name: get_attributename
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEAnimationBase::get_attributeName(BSTR *attrib)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(attrib);

    if (m_SAAttribute.GetValue())
    {
        *attrib = SysAllocString(m_SAAttribute.GetValue());
        if (NULL == *attrib)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_attributename
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_attributeName(BSTR attrib)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(attrib);

    // This will clean out the old value.
    // We need to can the old composer et al.
    if (NULL != m_SAAttribute.GetValue())
    {
        endAnimate();
    }

    delete [] m_SAAttribute.GetValue();
    m_SAAttribute.Reset(DEFAULT_ATTRIBUTE);

    m_SAAttribute.SetValue(CopyString(attrib));
    if (NULL == m_SAAttribute.GetValue())
    {
        hr = E_OUTOFMEMORY;
    }

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ATTRIBUTENAME);

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_targetElement
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEAnimationBase::get_targetElement (BSTR *target)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(target);

    if (m_SATarget.GetValue())
    {
        *target = SysAllocString(m_SATarget.GetValue());
        if (NULL == *target)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_targetElement
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_targetElement (BSTR target)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(target);

    delete [] m_SATarget.GetValue();
    m_SATarget.Reset(DEFAULT_TARGET);

    m_SATarget.SetValue(CopyString(target));
    if (NULL == m_SATarget.GetValue())
    {
        hr = E_OUTOFMEMORY;
    }

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_TARGETELEMENT);

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: put_keytimes
  //
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_keyTimes(BSTR val)
{
    HRESULT hr = E_FAIL;  
    CComVariant varTemp;
    int i;
    CPtrAry<STRING_TOKEN*> aryTokens;
    OLECHAR *sString = NULL;
    OLECHAR sTemp[INTERNET_MAX_URL_LENGTH];

    CHECK_RETURN_NULL(val);

    m_AnimPropState.fBadKeyTimes = false;

    // reset the attribute
    delete [] m_SAKeyTimes.GetValue();
    m_SAKeyTimes.Reset(DEFAULT_KEYTIMES);

    if (m_pdblKeyTimes)
    {
        delete [] m_pdblKeyTimes;
        m_pdblKeyTimes = NULL;
    }

    // store off the values
    m_SAKeyTimes.SetValue(CopyString(val));
    if (m_SAKeyTimes.GetValue() == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Parse out the values.....
    sString = CopyString(val);
    if (sString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = ::StringToTokens(sString, s_cPSTR_SEMI_SEPARATOR, &aryTokens);
    m_numKeyTimes = aryTokens.Size();
    if (FAILED(hr) ||
        m_numKeyTimes == 0)
    {
        goto done;
    }

    m_pdblKeyTimes = NEW double [m_numKeyTimes];
    if (NULL == m_pdblKeyTimes)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    for(i = 0; i < m_numKeyTimes; i++)
    {
        if (INTERNET_MAX_URL_LENGTH <= (lstrlenW(sString+aryTokens.Item(i)->uIndex) + 2))
        {
            hr = E_INVALIDARG;
            m_numKeyTimes = i;
            goto done;
        }
        StrCpyNW(sTemp,sString+aryTokens.Item(i)->uIndex,aryTokens.Item(i)->uLength+1);
        varTemp = sTemp;
        hr = VariantChangeTypeEx(&varTemp,&varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if(FAILED(hr))
        {
            m_numKeyTimes = i;
            goto done;
        }
        m_pdblKeyTimes[i] = V_R8(&varTemp);
    }
    
    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_KEYTIMES);

    if (m_pdblKeyTimes)
    {
        // verify key times are in increasing order
        bool fIncreasingOrder = true;
        for(int index = 1; index < m_numKeyTimes; index++)
        {
            if (m_pdblKeyTimes[index - 1] > m_pdblKeyTimes[index])
            {
               fIncreasingOrder = false;
               break;
            }
        }

        // check whether keytimes are in increasing order, first keyTime is 0 
        // and last keyTime is less than or equal to 1
        if (    (!fIncreasingOrder)
            ||  (m_pdblKeyTimes[0] != 0)
            ||  (m_pdblKeyTimes[m_numKeyTimes - 1] > 1))
        {
            // delete the keytimes and say that they are invalid.
            delete [] m_pdblKeyTimes;
            m_pdblKeyTimes = NULL;
            m_numKeyTimes = 0;
            m_AnimPropState.fBadKeyTimes = true;
        }
    }

    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    if (sString != NULL)
    {
        delete [] sString;
    }

    ValidateState();

    RRETURN(hr);
} // put_keyTimes


///////////////////////////////////////////////////////////////
//  Name: get_keytimes
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_keyTimes(BSTR * val)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(val);

    if (m_SAKeyTimes.GetValue())
    {
        *val = SysAllocString(m_SAKeyTimes.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: ValidateValueListItem
//
///////////////////////////////////////////////////////////////
bool
CTIMEAnimationBase::ValidateValueListItem (const VARIANT *pvarValueItem)
{
    return ConvertToPixels(const_cast<VARIANT *>(pvarValueItem));
} // ValidateValueListItem


///////////////////////////////////////////////////////////////
//  Name: put_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_values(VARIANT val)
{
    HRESULT                 hr = E_FAIL;
    CComVariant             svarTemp;
    int                     i;
    CPtrAry<STRING_TOKEN*>  aryTokens;
    LPWSTR                  pstrValues = NULL;
    bool                    fCanInterpolate = true; 
    DATATYPES dt;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    delete [] m_SAValues.GetValue();
    m_SAValues.Reset(DEFAULT_VALUES);

    // Clear and reset internal state
    if (m_ppstrValues)
    {
        for (i = 0; i <m_numValues;i++)
        {
            delete [] m_ppstrValues[i];
        }
        delete [] m_ppstrValues;
        m_ppstrValues = NULL;
    }
    m_numValues = 0;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    // convert to BSTR
    hr = THR(svarTemp.Copy(&val));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(VariantChangeTypeEx(&svarTemp, &svarTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        goto done;
    }

    // Store the new attribute string
    pstrValues = CopyString(V_BSTR(&svarTemp));
    if (NULL == pstrValues)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    m_SAValues.SetValue(pstrValues);

    // Tokenize the values
    hr = THR(::StringToTokens(pstrValues, s_cPSTR_SEMI_SEPARATOR , &aryTokens));
    m_numValues = aryTokens.Size();
    if (FAILED(hr)) 
    {
        goto done;
    }

    // check for an empty string
    if (0 == m_numValues)
    {
        hr = S_OK;
        goto done;
    }

    // create array of values
    m_ppstrValues = NEW LPOLESTR [m_numValues];
    if (NULL == m_ppstrValues)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ZeroMemory(m_ppstrValues, sizeof(LPOLESTR) * m_numValues);

    // parse the values
    for (i = 0; i < m_numValues; i++)
    {
        UINT uTokLength = aryTokens.Item(i)->uLength;
        UINT uIndex = aryTokens.Item(i)->uIndex;

        // alloc a string to hold the token
        m_ppstrValues[i] = NEW OLECHAR [uTokLength + 1];
        if (NULL == m_ppstrValues[i])
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // NULL terminate the string
        m_ppstrValues[i][uTokLength] = NULL;

        // copy the token value
        StrCpyNW(m_ppstrValues[i], 
                 pstrValues + uIndex, 
                 uTokLength + 1); 

        // Check to see if we can interpolate
        if (fCanInterpolate)
        {
            svarTemp = m_ppstrValues[i];
            if (NULL != svarTemp.bstrVal)
            {
                if (!ValidateValueListItem(&svarTemp))
                {
                    fCanInterpolate = false;
                }
                svarTemp.Clear();
            }
        }
    }

    dt = VALUES;
    
    hr = S_OK;
done:
    if (FAILED(hr))
    {
        for (i = 0; i < m_numValues; i++)
        {
            delete [] m_ppstrValues[i];
        }
        delete [] m_ppstrValues;
        m_ppstrValues = NULL;
    }

    updateDataToUse(dt);

    m_AnimPropState.fInterpolateValues = fCanInterpolate;

    CalculateTotalDistance();
    
    ValidateState();

    DetermineAdditiveEffect();

    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_VALUES);

    // do not delete pstrValues! Its memory is re-used by m_SAValues.
    
    
    RRETURN(hr);
} // put_values


///////////////////////////////////////////////////////////////
//  Name: get_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_values(VARIANT * pvarVal)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_NULL(pvarVal);

    VariantInit(pvarVal);

    if (m_SAValues.GetValue())
    {
        V_BSTR(pvarVal) = SysAllocString(m_SAValues.GetValue());
        if (NULL == V_BSTR(pvarVal))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            V_VT(pvarVal) = VT_BSTR;
        }
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: put_keysplines
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_keySplines(BSTR val)
{
    HRESULT hr = E_FAIL;
    CPtrAry<STRING_TOKEN*> aryTokens;
    CPtrAry<STRING_TOKEN*> aryTokens2;
    OLECHAR *sString = NULL;
    OLECHAR sTemp[INTERNET_MAX_URL_LENGTH];
    OLECHAR sTemp2[INTERNET_MAX_URL_LENGTH];
    CComVariant varValue;
    int i;

    CHECK_RETURN_NULL(val);

    delete [] m_SAKeySplines.GetValue();
    m_SAKeySplines.Reset(DEFAULT_KEYSPLINES);

    delete [] m_pKeySplinePoints;
    m_pKeySplinePoints = NULL;
    m_numKeySplines = 0;

    m_SAKeySplines.SetValue(CopyString(val));
    if (m_SAKeySplines.GetValue() == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_KEYSPLINES); 
    
    // Parse out the values.....
    sString = CopyString(val);
    if (sString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // tokenize the values
    hr = ::StringToTokens(sString, s_cPSTR_SEMI_SEPARATOR, &aryTokens);
    m_numKeySplines = aryTokens.Size();
    if (FAILED(hr) ||
        m_numKeySplines == 0)
    {
        goto done;
    }

    m_pKeySplinePoints = NEW SplinePoints [m_numKeySplines];
    if (NULL == m_pKeySplinePoints)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    for (i=0; i< m_numKeySplines; i++)
    {
        if (INTERNET_MAX_URL_LENGTH <= (lstrlenW(sString+aryTokens.Item(i)->uIndex) + 2))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        StrCpyNW(sTemp,sString+aryTokens.Item(i)->uIndex,aryTokens.Item(i)->uLength+1);

        hr = ::StringToTokens(sTemp, s_cPSTR_SPACE_SEPARATOR, &aryTokens2);
        if (FAILED(hr) ||
            aryTokens2.Size() != NUMBER_KEYSPLINES) // We must have four values or there is an error
        {
            hr = E_FAIL;
            goto done;
        }

        // fill in the Data...
        if (INTERNET_MAX_URL_LENGTH <= (lstrlenW(sTemp+aryTokens2.Item(0)->uIndex) + 2))
        {
            hr = E_INVALIDARG;
            goto done;
        }
        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(0)->uIndex,aryTokens2.Item(0)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].x1 = V_R8(&varValue);

        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(1)->uIndex,aryTokens2.Item(1)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].y1 = V_R8(&varValue);

        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(2)->uIndex,aryTokens2.Item(2)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].x2 = V_R8(&varValue);

        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(3)->uIndex,aryTokens2.Item(3)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].y2 = V_R8(&varValue);
        
        // Create samples for linear interpolation
        SampleKeySpline(m_pKeySplinePoints[i]);

        IGNORE_HR(::FreeStringTokenArray(&aryTokens2));
    }

    hr = S_OK;
done:
    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    if (sString != NULL)
    {
        delete [] sString;
    }
    if (FAILED(hr))
    {
        // free memory
        delete [] m_pKeySplinePoints;
        m_pKeySplinePoints = NULL;

        m_numKeySplines = 0;

        IGNORE_HR(::FreeStringTokenArray(&aryTokens2));
    }

    ValidateState();

    RRETURN(hr);
} // put_keySplines


///////////////////////////////////////////////////////////////
//  Name: get_keysplines
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_keySplines(BSTR * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(val);

    if (m_SAKeySplines.GetValue())
    {
        *val = SysAllocString(m_SAKeySplines.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: DetermineAdditiveEffect
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::DetermineAdditiveEffect (void)
{
    // by w/o from implies additive
    if (   (BY == m_dataToUse)
        && (VT_EMPTY != V_VT(&m_varBy))
        && (VT_EMPTY == V_VT(&m_varFrom)))
    {
        m_bAdditive = true;
    }
    // to w/o from overrides the additive=sum effect.
    else if (   (TO == m_dataToUse)
             && (VT_EMPTY != V_VT(&m_varTo))
             && (VT_EMPTY == V_VT(&m_varFrom)))
    {
        m_bAdditive = false;
    }
    // 
    else
    {
        m_bAdditive = m_bAdditiveIsSum;
    }
} // DetermineAdditiveEffect


///////////////////////////////////////////////////////////////
//  Name: put_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_from(VARIANT val)
{
    HRESULT hr = E_FAIL;

    // reset this attribute
    m_VAFrom.Reset(NULL);
    m_varDOMFrom.Clear();
    m_varFrom.Clear();
    m_bFrom = false;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = VariantCopy(&m_varDOMFrom,&val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VAFrom.SetValue(NULL);

    hr = VariantCopy(&m_varFrom,&val);
    if (FAILED(hr))
    {
        goto done;
    }

    if (ConvertToPixels(&m_varFrom))
    {
        m_AnimPropState.fInterpolateFrom = true;
    }
    else
    {
        m_AnimPropState.fInterpolateFrom = false;
    }

    m_bFrom = true;

    hr = S_OK;
done:
    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_FROM);

    RRETURN(hr);
} // put_from


///////////////////////////////////////////////////////////////
//  Name: get_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_from(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varDOMFrom);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_to(VARIANT val)
{
    HRESULT hr = E_FAIL;
    DATATYPES dt;

    // reset this attribute
    dt = RESET;
    m_VATo.Reset(NULL);
    m_varDOMTo.Clear();
    m_varTo.Clear();

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = VariantCopy(&m_varDOMTo, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VATo.SetValue(NULL);

    hr = VariantCopy(&m_varTo, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    if (ConvertToPixels(&m_varTo))
    {
        m_AnimPropState.fInterpolateTo = true;
    }
    else
    {
        m_AnimPropState.fInterpolateTo = false;
    }

    dt = TO;

    hr = S_OK;
done:
    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_TO);

    RRETURN(hr);
} // put_to


///////////////////////////////////////////////////////////////
//  Name: get_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_to(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varDOMTo);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: ValidateByValue
//
///////////////////////////////////////////////////////////////
bool
CTIMEAnimationBase::ValidateByValue (const VARIANT *pvarBy)
{
    bool fRet = true;

    if (!ConvertToPixels(const_cast<VARIANT *>(pvarBy)))
    {
        m_AnimPropState.fInterpolateBy = false;
    }
    else
    {
        m_AnimPropState.fInterpolateBy = true;
    }

    return fRet;
} // ValidateByValue


///////////////////////////////////////////////////////////////
//  Name: put_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_by(VARIANT val)
{
    HRESULT hr = S_OK;;
    DATATYPES dt;

    // reset this attribute
    dt = RESET;
    m_VABy.Reset(NULL);
    m_varDOMBy.Clear();
    m_varBy.Clear();

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = VariantCopy(&m_varDOMBy, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VABy.SetValue(NULL);

    hr = VariantCopy(&m_varBy, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!ValidateByValue(&m_varBy))
    {
        goto done;
    }

    dt = BY;

    hr = S_OK;
done:
    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_BY);
    
    RRETURN(hr);
} // put_by


///////////////////////////////////////////////////////////////
//  Name: get_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_by(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varDOMBy);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_additive
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_additive(BSTR val)
{
    HRESULT hr = S_OK;
    LPOLESTR szAdditive = NULL;

    CHECK_RETURN_NULL(val);

    m_bAdditive = false;
    m_bAdditiveIsSum = false;
     
    delete [] m_SAAdditive.GetValue();
    m_SAAdditive.Reset(NULL);

    m_SAAdditive.SetValue(CopyString(val));
    if (m_SAAdditive == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    szAdditive = TrimCopyString(val);
    if (szAdditive == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_ADDITIVE_SUM, szAdditive))
    {
        m_bAdditive = true;
        m_bAdditiveIsSum = true;
    }

    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ADDITIVE);

    delete [] szAdditive;

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_additive
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_additive(BSTR * val)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(val);

    if (m_SAAdditive.GetValue())
    {
        *val = SysAllocString(m_SAAdditive.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_accumulate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_accumulate(BSTR val)
{
    HRESULT hr = S_OK;
    LPOLESTR szAccumulate = NULL;

    CHECK_RETURN_NULL(val);

    m_bAccumulate = false;

    delete [] m_SAAccumulate.GetValue();
    m_SAAccumulate.Reset(NULL);

    m_SAAccumulate.SetValue(CopyString(val));
    if (m_SAAccumulate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    szAccumulate = TrimCopyString(val);
    if (szAccumulate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_ADDITIVE_SUM, szAccumulate))
    {
        m_bAccumulate = true;
    }

    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ACCUMULATE);

    m_AnimPropState.fAccumulate = m_bAccumulate;

    ValidateState();

    delete [] szAccumulate;
 
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_accumulate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_accumulate(BSTR * val)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(val);

    if (m_SAAccumulate.GetValue())
    {
        *val = SysAllocString(m_SAAccumulate.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_calcmode
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_calcMode(BSTR calcmode)
{
    HRESULT hr = S_OK;
    LPOLESTR szCalcMode = NULL;

    CHECK_RETURN_NULL(calcmode);

    m_IACalcMode.Reset(DEFAULT_CALCMODE);

    szCalcMode = TrimCopyString(calcmode);
    if (NULL == szCalcMode)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_CALCMODE_DISCRETE, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_DISCRETE);
    }
    else if (0 == StrCmpIW(WZ_CALCMODE_LINEAR, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_LINEAR);
    }
    else if (0 == StrCmpIW(WZ_CALCMODE_SPLINE, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_SPLINE);
    }
    else if (0 == StrCmpIW(WZ_CALCMODE_PACED, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_PACED);
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_CALCMODE);

    if (szCalcMode != NULL)
    {
        delete [] szCalcMode;
    }

    ValidateState();

    RRETURN(hr);
} // put_calcMode


///////////////////////////////////////////////////////////////
//  Name: get_calcmode
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_calcMode(BSTR * calcmode)
{
    HRESULT hr = S_OK;
    LPWSTR wszCalcmodeString = WZ_NONE;

    CHECK_RETURN_NULL(calcmode);

    switch(m_IACalcMode)
    {
        case CALCMODE_DISCRETE :
            wszCalcmodeString = WZ_CALCMODE_DISCRETE;
            break;
        case CALCMODE_LINEAR :
            wszCalcmodeString = WZ_CALCMODE_LINEAR;
            break;
        case CALCMODE_SPLINE :
            wszCalcmodeString = WZ_CALCMODE_SPLINE;
            break;
        case CALCMODE_PACED :
            wszCalcmodeString = WZ_CALCMODE_PACED;
            break;
        default:
            wszCalcmodeString = WZ_CALCMODE_LINEAR;
    }

    *calcmode = SysAllocString(wszCalcmodeString);
    if (NULL == *calcmode)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: initScriptEngine
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void CTIMEAnimationBase::initScriptEngine()
{

    HRESULT hr;
   
    CComPtr<IHTMLWindow2>   pWindow2;
    CComVariant             vResult;
    CComBSTR                bstrScript(L"2+2");
    CComBSTR                bstrJS(L"JScript");

    if (bstrScript == NULL ||
        bstrJS     == NULL)
    {
        goto done;
    }

    hr = m_spDoc2->get_parentWindow(&pWindow2);
    if (FAILED(hr))
    {
        goto done;
    }

    pWindow2->execScript(bstrScript,bstrJS,&vResult);

done: 
    return;
}



///////////////////////////////////////////////////////////////
//  Name: resetAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::resetAnimate()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::resetAnimate()",
              this));
    // Need to reload to set up correct target / attribute.
    
    m_bNeedAnimInit = true;
    m_varBaseline.Clear();
    m_varCurrentBaseline.Clear();
    initAnimate();
}

///////////////////////////////////////////////////////////////
//  Name: removeFromComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::removeFromComposerSite (void)
{
    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstrAttribName;

        bstrAttribName = m_SAAttribute;

        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->RemoveFragment(bstrAttribName, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // removeFromComposerSite

///////////////////////////////////////////////////////////////
//  Name: endAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::endAnimate (void)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::endAnimate()",
              this));

    if (m_spCompSite != NULL)
    {
        IGNORE_HR(removeFromComposerSite());
        m_spCompSite.Release();
    }
    m_bNeedAnimInit = true;
} // endAnimate

#ifdef TEST_REGISTERCOMPFACTORY // pauld

HRESULT
CTIMEAnimationBase::TestCompFactoryRegister (BSTR bstrAttribName)
{
    HRESULT hr;
    CComVariant varFactory;

    // Need to force the desired branch in the debugger.
    if (false)
    {
        // Register our composer factory by classid.
        V_VT(&varFactory) = VT_BSTR;
        V_BSTR(&varFactory) = ::SysAllocString(L"{EA627651-F84E-46b8-8FE4-21650FA09ED9}");

        hr = THR(m_spCompSite->RegisterComposerFactory(&varFactory));
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (false)
    {
        CComPtr<IAnimationComposerFactory> spCompFactory;

        // Or - register our composer factory by IUnknown.
        hr = THR(::CoCreateInstance(CLSID_AnimationComposerFactory, 
                                    NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IAnimationComposerFactory, 
                                    reinterpret_cast<void **>(&spCompFactory)));
        if (FAILED(hr))
        {
            goto done;
        }
        
        // AddRef because we're stuffing this into a CComVariant, which will decrement
        // the refcount on exit.
        V_VT(&varFactory) = VT_UNKNOWN;
        V_UNKNOWN(&varFactory) = spCompFactory;
        V_UNKNOWN(&varFactory)->AddRef();

        hr = THR(m_spCompSite->RegisterComposerFactory(&varFactory));
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // TestCompFactoryRegister

#endif // TEST_REGISTERCOMPFACTORY

#ifdef TEST_ENUMANDINSERT

static void
Introspect (VARIANT *pvarItem)
{
    CComVariant varID;

    Assert(VT_DISPATCH == V_VT(pvarItem));
    TraceTag((tagAnimationTimeElmTest,
              "Introspect : item %p ",
              V_DISPATCH(pvarItem)));
done :
    return;
}

static void
Enumerate (IEnumVARIANT *pienum)
{
    HRESULT hr = S_OK;
    ULONG celtReturned = 0;

    while (hr == S_OK)
    {
        CComVariant varItem;

        hr = pienum->Next(1, &varItem, &celtReturned);
        if (S_OK != hr)
        {
            break;
        }

        Introspect(&varItem);
        VariantClear(&varItem);
    }

done :
    return;
}

HRESULT
CTIMEAnimationBase::TestEnumerator (void)
{
    HRESULT hr;
    CComBSTR bstrAttribName = static_cast<LPWSTR>(m_SAAttribute);
    CComPtr<IEnumVARIANT> spEnum;

    TraceTag((tagAnimationTimeElmTest,
              "Testing enumerator code"));
    hr = THR(m_spCompSite->EnumerateFragments(bstrAttribName, &spEnum));
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    // OBJECTIVE : Test all of the enumerator entry points.
    // Try looping through the fragments (Next).
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating all items "));
    Enumerate(spEnum);

    // Reset 
    // Skip to the end and retrieve the last item
    // Try walking off the end.
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spEnum->Skip(100);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from item 100"));
    Enumerate(spEnum);

    // Reset 
    // Retrieve the first item
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from beginning again"));
    Enumerate(spEnum);

    // Skip to middle
    // Retrieve a middle element
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spEnum->Skip(1);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from item 2 "));
    Enumerate(spEnum);

    // Reset
    // Retrieve a bunch of items
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    {
        VARIANT rgVars[0x100];
        ULONG ulGot = 0;
        
        hr = spEnum->Next(0x100, rgVars, &ulGot);
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
        TraceTag((tagAnimationTimeElmTest,
                  "Getting a bunch of items  tried for %u got %u",
                   0x100, ulGot));
        for (unsigned long j = 0; j < ulGot; j++)
        {
            Introspect(&(rgVars[j]));
            ::VariantClear(&(rgVars[j]));
        }
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from last item"));
    Enumerate(spEnum);

    // Clone the list
    // Iterate through cloned list from middle
    // Reset and iterate from the beginning
    {
        CComPtr<IEnumVARIANT> spenum2;

        TraceTag((tagAnimationTimeElmTest,
                  "Cloning enumerator"));
        hr = spEnum->Clone(&spenum2);
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
        TraceTag((tagAnimationTimeElmTest,
                  "Enumerating clone from last item"));
        Enumerate(spenum2);
        hr = spenum2->Reset();
        if (FAILED(hr))
        {
            goto done;
        }
        TraceTag((tagAnimationTimeElmTest,
                  "Enumerating clone from beginning"));
        Enumerate(spenum2);
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // TestEnumerator

HRESULT
CTIMEAnimationBase::InsertEnumRemove (int iSlot)
{
    HRESULT hr;

    CComBSTR bstrName = static_cast<LPWSTR>(m_SAAttribute);
    CComVariant varIndex;
    CComPtr<IEnumVARIANT> spEnum;

    V_VT(&varIndex) = VT_I4;
    V_I4(&varIndex) = iSlot;

    hr = m_spCompSite->InsertFragment(bstrName, this, varIndex);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spCompSite->EnumerateFragments(bstrName, &spEnum));
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationTimeElmTest,
              "Inserted new item at position %d -- current list is : ", iSlot));
    Enumerate(spEnum);

    Assert(m_spFragmentHelper != NULL);
    hr = m_spCompSite->RemoveFragment(bstrName, m_spFragmentHelper);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}

HRESULT
CTIMEAnimationBase::TestInsert (void)
{
    HRESULT hr;

    // OBJECTIVE : Test the insertion code
    // Insert at beginning
    hr = InsertEnumRemove(0);
    if (FAILED(hr))
    {
        goto done;
    }

    // Insert in the middle
    hr = InsertEnumRemove(1);
    if (FAILED(hr))
    {
        goto done;
    }

    // Insert with invalid index
    hr = InsertEnumRemove(-1);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // TestInsert

#endif // TEST_ENUMANDINSERT

///////////////////////////////////////////////////////////////
//  Name: addToComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::addToComposerSite (IHTMLElement2 *pielemTarget)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::ensureComposerSite(%p)",
              this, pielemTarget));

    HRESULT hr;
    CComPtr<IDispatch> pidispSite;

    hr = removeFromComposerSite();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_SAAttribute == NULL)
    {
        TraceTag((tagAnimationTimeElm,
                  "CTIMEAnimationBase(%p)::addToComposerSite() : attributeName has not been set - ignoring fragment",
                  this));
        hr = S_FALSE;
        goto done;
    }

    // Do we have work to do?
    if (NONE == m_dataToUse)
    {
        hr = S_FALSE;
        goto done;
    }    

    if (m_spCompSite == NULL)
    {
        hr = THR(EnsureComposerSite(pielemTarget, &pidispSite));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pidispSite->QueryInterface(IID_TO_PPV(IAnimationComposerSite, 
                                                       &m_spCompSite)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

#ifdef TEST_REGISTERCOMPFACTORY // pauld
    TestCompFactoryRegister(m_SAAttribute);
#endif // TEST_REGISTERCOMPFACTORY

#ifdef TEST_ENUMANDINSERT
    TestInsert();
#endif // TEST_ENUMANDINSERT

    {
        CComBSTR bstrAttribName;
        
        bstrAttribName = m_SAAttribute;
        if (bstrAttribName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->AddFragment(bstrAttribName, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
    }

#ifdef TEST_ENUMANDINSERT
    hr = TestEnumerator();
#endif // TEST_ENUMANDINSERT

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(removeFromComposerSite());
    }

    RRETURN2(hr, E_OUTOFMEMORY, S_FALSE);
} // CTIMEAnimationBase::addToComposerSite

///////////////////////////////////////////////////////////////
//  Name: FindTarget
//
//  Abstract: Get a reference to our animation target
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::FindAnimationTarget (IHTMLElement ** ppielemTarget)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::initAnimate()",
              this));

    HRESULT hr = E_FAIL;
    CComPtr<IDispatch> pdisp;
    CComPtr<IHTMLElement> phtmle;

    Assert(NULL != ppielemTarget);

    if (m_SATarget)
    {
        if(m_spEleCol)
        {
            CComPtr <IDispatch> pSrcDisp;
            CComVariant vName;
            CComVariant vIndex;

            vName.vt      = VT_BSTR;
            vName.bstrVal = SysAllocString(m_SATarget);
            vIndex.vt     = VT_I2;
            vIndex.iVal   = 0;
            hr = THR(m_spEleCol->item(vName, vIndex, &pSrcDisp));
            if (FAILED(hr) ||
                pSrcDisp == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        
            hr = THR(pSrcDisp->QueryInterface(IID_TO_PPV(IHTMLElement, ppielemTarget)));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    { 
        phtmle = GetElement();

        hr = phtmle->get_parentElement(ppielemTarget);

        // 2001/04/18 mcalkins  IE6.0 Bug 25804
        //
        // CElement::get_parentElement can return a NULL pointer and also
        // return S_OK.

        if (   (NULL == *ppielemTarget)
            && (SUCCEEDED(hr)))
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            goto done;
        }        
    }

    hr = S_OK;

done:

    RRETURN(hr);
} // CTIMEAnimationBase::FindAnimationTarget 

///////////////////////////////////////////////////////////////
//  Name: initAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::initAnimate()
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::initAnimate()",
              this));

    HRESULT                     hr = E_FAIL;
    CComPtr<IHTMLElement>       phtmle;
    CComPtr<IHTMLElement2>      phtmle2;
    CComPtr<IDispatch>          pElmDisp;
    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;
    
    endAnimate();

    // Check to see if we are supposed to play animations.
    Assert(GetBody());
    GetBody()->ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
    if (!fPlayAnimations)
    {
        goto done;
    }

    hr = FindAnimationTarget(&phtmle);
    if (SUCCEEDED(hr))
    {
        CComPtr<IHTMLElement2> phtmle2;
        
        Assert(phtmle != NULL);
        hr = THR(phtmle->QueryInterface(IID_TO_PPV(IHTMLElement2, &phtmle2)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = addToComposerSite (phtmle2);
        if (FAILED(hr))
        {
            goto done;
        }

        // See if we are going to be animating VML or not.
        hr = THR(phtmle->QueryInterface(IID_IDispatch, (void**)&pElmDisp));
        if (FAILED(hr))
        {
            goto done;
        }
        m_bVML = IsVMLObject(pElmDisp);     
        m_bNeedAnimInit = false;
    }

    
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: updateDataToUse
//
//  Abstract: allows setting the animation type in priority order.
//            RESET is used indicate a need to recompute the data to use
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::updateDataToUse(DATATYPES dt)
{
    if (RESET == dt)
    {
        //
        // NOTE: All the if statements need to be evaluated
        //

        // if "path" has been cleared, revert to "values"
        if (    (PATH == m_dataToUse)
            &&  (!m_SAPath.IsSet()))
        {
            m_dataToUse = VALUES;
        }

        // if "values" has been cleared, revert to "to"
        if (    (VALUES == m_dataToUse)
            &&  (!m_SAValues.IsSet()))
        {
            m_dataToUse = TO;
        }
        
        // if "to" has been cleared, revert to "by"
        if (    (TO == m_dataToUse)
            &&  (!m_VATo.IsSet()))
        {
            m_dataToUse = BY;
        }

        // if "to" has been cleared, revert to "by"
        if (    (BY == m_dataToUse)
            &&  (!m_VABy.IsSet()))
        {
            m_dataToUse = NONE;
        }
    }
    else if (dt < m_dataToUse)
    {
        m_dataToUse = dt;
    }
}


///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::calculateDiscreteValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    Assert(NULL != pvarValue);

    switch ( m_dataToUse)
    {
        case VALUES:
            {
                CComVariant varTemp;
                int curSeg = CalculateCurrentSegment(true);
            
                varTemp.vt = VT_BSTR;
                varTemp.bstrVal = SysAllocString(m_ppstrValues[curSeg]);
                hr = THR(::VariantCopy(pvarValue, &varTemp));
                if (FAILED(hr))
                {
                    goto done;
                }
                TraceTag((tagAnimationBaseValue,
                          "CTIMEAnimationBase(%p)::calculateDiscreteValue(%ls) segment is %d progress is %lf ",
                          this, V_BSTR(pvarValue), curSeg, GetMMBvr().GetProgress()));
            }
            break;

        case TO:
            {
                if (m_bFrom && (GetMMBvr().GetProgress() < 0.5))
                {
                    CComVariant varFrom;
                    VARTYPE vtDummy = VT_EMPTY;

                    hr = VariantCopy(&varFrom,&m_varFrom);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = CanonicalizeValue(&varFrom, &vtDummy);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = THR(::VariantCopy(pvarValue, &varFrom));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
                else
                {
                    hr = THR(::VariantCopy(pvarValue, &m_varTo));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }

                TraceTag((tagAnimationBaseValue,
                          "CTIMEAnimationBase(%p)::calculateDiscreteValue(to value)",
                          this));
            }
            break;

        case BY:
            {
                if (!ConvertToPixels(pvarValue) || 
                    !ConvertToPixels(&m_varBy))
                {
                    goto done;
                }

                if (m_bFrom)
                {
                    CComVariant varFrom;
                    VARTYPE vtDummy = VT_EMPTY;

                    hr = VariantCopy(&varFrom,&m_varFrom);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = CanonicalizeValue(&varFrom, &vtDummy);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    // copy "from"
                    hr = THR(::VariantCopy(pvarValue, &varFrom));
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    // if in second half of interval
                    if (GetMMBvr().GetProgress() >= 0.5)
                    {
                        // increment "by"
                        Assert(V_VT(&m_varBy)== VT_R8);

                        V_R8(pvarValue) += V_R8(&m_varBy);
                    }
                }
                else
                {
                    hr = THR(::VariantCopy(pvarValue, &m_varBy));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }

                TraceTag((tagAnimationBaseValue,
                          "CTIMEAnimationBase(%p, %ls)::calculateDiscreteValue(%lf) for %ls.%ls",
                          this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));
            }
            break;

        case PATH:
        case NONE:
        default:
            break;

    }

    hr = S_OK;
done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::calculateLinearValue(VARIANT *pvarValue)
{
    HRESULT     hr = S_OK;
    CComVariant varVal;
    double dblReturnVal;

    if (m_dataToUse == VALUES)
    {
        double curProgress = CalculateProgressValue(false);
        int    curSeg      = CalculateCurrentSegment(false);

        Assert(m_ppstrValues && ((curSeg + 1) <= (m_numValues - 1)));

        if (!m_ppstrValues[curSeg] || !m_ppstrValues[curSeg + 1])
        {
            goto done;
        }

        CComVariant svarFrom(m_ppstrValues[curSeg]);
        CComVariant svarTo(m_ppstrValues[curSeg + 1]);

        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            goto done;
        }

        dblReturnVal = InterpolateValues(svarFrom.dblVal,  
                                         svarTo.dblVal,
                                         curProgress);
    }
    else
    {
        CComVariant varData;
        double dblFrom = 0;
        double dblToOffset = 0;
                   
        if (m_bFrom)
        {
            CComVariant varFrom;
            VARTYPE vtDummy = VT_EMPTY;

            hr = VariantCopy(&varFrom,&m_varFrom);
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CanonicalizeValue(&varFrom, &vtDummy);
            dblFrom = V_R8(&varFrom);
        }
        else if (TO == m_dataToUse)
        {
            if (VT_R8 != V_VT(&m_varCurrentBaseline))
            {
                if (!ConvertToPixels(&m_varCurrentBaseline))
                {
                    hr = E_UNEXPECTED;
                    goto done;
                }
            }
            dblFrom = V_R8(&m_varCurrentBaseline);
        }
                        
        if (TO == m_dataToUse)
        {
            hr = VariantCopy(&varData, &m_varTo);
        }
        else if (BY == m_dataToUse) 
        {
            hr = VariantCopy(&varData, &m_varBy);
            dblToOffset = dblFrom;
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }

        if (FAILED(hr) || (!ConvertToPixels(&varData)))
        {
            goto done;
        }
        Assert(V_VT(&varData) == VT_R8);     

        dblReturnVal = InterpolateValues(dblFrom, dblToOffset + V_R8(&varData), (GetMMBvr().GetProgress()));
    }
    
    THR(::VariantClear(pvarValue));
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = dblReturnVal; 

    TraceTag((tagAnimationBaseValue,
              "CTIMEAnimationBase(%p, %ls)::calculateLinearValue(%lf) for %ls.%ls",
              this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));

    hr = S_OK;
done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEAnimationBase::calculateSplineValue(VARIANT *pvarValue)
{
    HRESULT     hr = S_OK;
    CComVariant varVal;
    CComVariant varRes;
    double dblReturnVal = 0.0;

    V_VT(&varRes) = VT_R8;

    if (m_pKeySplinePoints == NULL)
    {
        goto done;
    }

    if (m_dataToUse == VALUES)
    {
        int    curSeg      = CalculateCurrentSegment(false);
        double curProgress = CalculateProgressValue(false);

        curProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg],curProgress);

        CComVariant svarFrom(m_ppstrValues[curSeg]);
        CComVariant svarTo(m_ppstrValues[curSeg + 1]);

        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            goto done;
        }

        dblReturnVal = InterpolateValues(svarFrom.dblVal,  
                                         svarTo.dblVal,
                                         curProgress);
    }
    else
    {
        double curProgress = CalculateBezierProgress(m_pKeySplinePoints[0],GetMMBvr().GetProgress());
        CComVariant varData;
        double dblFrom = 0;
        double dblToOffset = 0;
                   
        if (m_bFrom)
        {
            CComVariant varFrom;
            VARTYPE vtDummy = VT_EMPTY;

            hr = VariantCopy(&varFrom,&m_varFrom);
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CanonicalizeValue(&varFrom, &vtDummy);
            dblFrom = V_R8(&varFrom);
        }
        else if (TO == m_dataToUse)
        {
            if (VT_R8 != V_VT(&m_varCurrentBaseline))
            {
                if (!ConvertToPixels(&m_varCurrentBaseline))
                {
                    hr = E_UNEXPECTED;
                    goto done;
                }
            }
            dblFrom = V_R8(&m_varCurrentBaseline);
        }
                        
        if (TO == m_dataToUse)
        {
            hr = VariantCopy(&varData, &m_varTo);
        }
        else if (BY == m_dataToUse) 
        {
            hr = VariantCopy(&varData, &m_varBy);
            dblToOffset = dblFrom;
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }

        if (FAILED(hr) || (!ConvertToPixels(&varData)))
        {
            goto done;
        }
        Assert(V_VT(&varData) == VT_R8);     

        dblReturnVal = InterpolateValues(dblFrom, dblToOffset + V_R8(&varData), curProgress);
    }
    
    THR(::VariantClear(pvarValue));
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = dblReturnVal; 

    TraceTag((tagAnimationBaseValue,
              "CTIMEAnimationBase(%p, %ls)::calculateSplineValue(%lf) for %ls.%ls",
              this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));

    hr = S_OK;
done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::calculatePacedValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;
    CComVariant varData, varRes;
    CComVariant svarFrom, svarTo;
    double dblDistance =0.0;
    double pDistance;
    double curDisanceTraveled = 0.0;
    int i;

    // This only makes sense if you are using m_dataToUse == VALUES
    if (m_dataToUse != VALUES)
    {
        hr = THR(calculateLinearValue(pvarValue));
        goto done;
    }

    curDisanceTraveled = InterpolateValues(0.0, 
                                           m_dblTotalDistance, 
                                           GetMMBvr().GetProgress());

    i=1;
    dblDistance = 0.0;
    pDistance   = 0.0;
    do
    {
        pDistance = dblDistance;
        if (m_ppstrValues[i-1] == NULL || m_ppstrValues[i] == NULL)
        {
            dblDistance = 0.0;
            goto done;
        }

        svarFrom = m_ppstrValues[i - 1];
        svarTo = m_ppstrValues[i];

        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            goto done;
        }

        dblDistance += fabs(svarFrom.dblVal - svarTo.dblVal); 
        i++;
    }
    while (dblDistance < curDisanceTraveled);
    
    i = (i < 2)?1:i-1;

    // how far are we into the segment
    svarFrom = m_ppstrValues[i - 1];
    svarTo = m_ppstrValues[i];

    if (    (NULL == svarFrom.bstrVal)
        ||  (NULL == svarTo.bstrVal)
        ||  (!ConvertToPixels(&svarFrom))
        ||  (!ConvertToPixels(&svarTo)))
    {
        goto done;
    }

    dblDistance = fabs(svarFrom.dblVal - svarTo.dblVal); 

    if (dblDistance == 0)
    {
        goto done;
    }

    dblDistance = (curDisanceTraveled - pDistance)/dblDistance;

    dblDistance =  InterpolateValues(svarFrom.dblVal,
                                     svarTo.dblVal, 
                                     dblDistance); 

    V_VT(&varRes) = VT_R8;
    V_R8(&varRes) = dblDistance; 
    hr = THR(::VariantCopy(pvarValue, &varRes));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationBaseValue,
              "CTIMEAnimationBase(%p, %ls)::calculatePacedValue(%lf) for %ls.%ls",
              this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));

    hr = S_OK;
done:

    RRETURN(hr);
}
   

///////////////////////////////////////////////////////////////
//  Name: CalculateProgressValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEAnimationBase::CalculateProgressValue(bool fForceDiscrete)
{
    double segDur       = 0.0;
    double curProgress  = 0.0;
    int    curSeg       = 0;
    CComVariant varTemp;

    double curTime = GetMMBvr().GetSimpleTime();

    curSeg = CalculateCurrentSegment(fForceDiscrete);

    if (m_numKeyTimes == m_numValues &&
        GetMMBvr().GetSimpleDur() != TIME_INFINITE)
    {
        // We have corresponding times for the values...
        segDur  = (m_pdblKeyTimes[curSeg+1] - m_pdblKeyTimes[curSeg] ) * GetMMBvr().GetSimpleDur();
        double pt = (m_pdblKeyTimes[curSeg] * GetMMBvr().GetSimpleDur());
        curTime = curTime - pt;
        if(curTime < 0)
        {
            curTime = 0;
        }

        curProgress = curTime/segDur;
    }
    else 
    {
        // Only use values. 
        if ( m_numValues == 1)
        {
            segDur = GetMMBvr().GetSimpleDur();
        }
        else
        {
            segDur = GetMMBvr().GetSimpleDur() / (m_numValues-1);
        }
        if (segDur != 0)
        {
            double timeInSeg = curTime;

            if (curTime >= segDur)
            {
                int segOffset = (int) (curTime/segDur);
                if (segOffset == 0)
                { 
                    segOffset = 1;
                }
                timeInSeg = curTime - (segDur * segOffset);
            }
            curProgress = timeInSeg / segDur;
        }
    }

    
    return curProgress;
} 


///////////////////////////////////////////////////////////////
//  Name: CalculateCurrentSegment
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
int
CTIMEAnimationBase::CalculateCurrentSegment(bool fForceDiscrete)
{
    double segDur = 0.0;
    int    curSeg = 0;                       
    bool fDiscrete = fForceDiscrete
                     || (CALCMODE_DISCRETE == m_IACalcMode.GetValue());

    if (m_numKeyTimes == m_numValues  &&
        GetMMBvr().GetSimpleDur() != TIME_INFINITE)
    {
        if (fDiscrete)
        {
            // adjust for last segment
            curSeg = m_numKeyTimes - 1;
        }

        // We have corresponding times for the values...
        for(int i=0; i < m_numKeyTimes;i++)
        {
            if (m_pdblKeyTimes[i] > (GetMMBvr().GetProgress()))
            {
                curSeg = i;
                if(curSeg != 0)
                {
                    curSeg -= 1;
                }
                break;
            }
        }
    }
    else 
    {
        // Only use values. 
        if ( m_numValues == 1)
        {
            segDur = GetMMBvr().GetSimpleDur();
        }
        else
        {
            if (fDiscrete)
            {
                segDur = GetMMBvr().GetSimpleDur() / (m_numValues);
            }
            else
            {
                segDur = GetMMBvr().GetSimpleDur() / (m_numValues - 1);
            }
        }

        curSeg = (int) (GetMMBvr().GetSimpleTime() / segDur);
    }
    
    // adjust for the last tick
    if (curSeg == m_numValues)
    {
        curSeg --;
    }

    return curSeg;
} 


///////////////////////////////////////////////////////////////
//  Name: CalculateTotalDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::CalculateTotalDistance()
{
    m_dblTotalDistance = 0.0;
    CComVariant svarFrom, svarTo;
    int i;

    for (i=1; i < m_numValues; i++)
    {
        svarFrom = m_ppstrValues[i - 1];
        svarTo = m_ppstrValues[i];

        // need to change the below 0 to origval..
        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            m_dblTotalDistance = 0.0;
            goto done;
        }

        m_dblTotalDistance += fabs(svarFrom.dblVal - svarTo.dblVal); 
    }
done:
    return;
}


void
CTIMEAnimationBase::SampleKeySpline(SplinePoints & sp)
{
    // sample at 4 equi-spaced points
    sp.s1 = KeySplineBezier(sp.x1, sp.x2, 0.2);
    sp.s2 = KeySplineBezier(sp.x1, sp.x2, 0.4);
    sp.s3 = KeySplineBezier(sp.x1, sp.x2, 0.6);
    sp.s4 = KeySplineBezier(sp.x1, sp.x2, 0.8);
}


///////////////////////////////////////////////////////////////
//  Name: CalculateBezierProgress
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double 
CTIMEAnimationBase::CalculateBezierProgress(const SplinePoints & sp, double cp)
{
    //
    // First solve the equation x(t) = cp, where x(t) is the cubic bezier function 
    // Then evaluate y(t1) where t1 is the root of the above equation
    // 
    // Approximate the x- spline with 4 line segments that are found by 
    // subdiving the parameter into 4 equal intervals
    //
    double x1 = 0.0;
    double x2 = 1.0;
    double t1 = 0.0;
    double t2 = 1.0;

    if (cp < sp.s3)
    {
        if (cp < sp.s2)
        {
            if (cp < sp.s1)
            {
                x2 = sp.s1;
                t2 = 0.2;
            }
            else
            {
                x1 = sp.s1;
                x2 = sp.s2;
                t1 = 0.2;
                t2 = 0.4;
            }
        }
        else
        {
            x1 = sp.s2;
            x2 = sp.s3;
            t1 = 0.4;
            t2 = 0.6;
        }
    }
    else
    {
        if (cp < sp.s4)
        {
            x1 = sp.s3;
            x2 = sp.s4;
            t1 = 0.6;
            t2 = 0.8;
        }
        else
        {
            x1 = sp.s4;
            t1 = 0.8;

        }
    }

    // get the value of t at x = cp
    t1 = InterpolateValues(t1, t2, (cp - x1) / (x2 - x1));
    
    return KeySplineBezier(sp.y1, sp.y2, t1);
} // CalculateBezierProgress


// optimized for start-value = 0 and end-value = 1, so we just need the control points
inline
double
CTIMEAnimationBase::KeySplineBezier(double x1, double x2, double cp)
{
    //
    // dilipk: reduce number of multiplies using Horner's rule
    //

    double cpm1, cp3;
    
    cpm1 = 1 - cp;
    cp3 = cp * cp * cp;

    return(3 * cp * cpm1 * cpm1 * x1 + 3 * cp * cp * cpm1 * x2 + cp3);
}


#if (0 && DBG) 

// This computes Exact bezier progress for KeySplines. This is slower than the above inexact computation.
// Keeping this around for benchmarking the above approximation method.

// need to link with libc.lib if this block is enabled
#include "math.h"

///////////////////////////////////////////////////////////////
//  Name: CalculateBezierProgressExact
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double 
CTIMEAnimationBase::CalculateBezierProgressExact(SplinePoints s, double progress)
{
    double cpm1, cp3, cp = progress, result = 0.0;

    Assert(progress <= 1.0 && progress >= 0.0);

    //
    // First solve the equation x(t) = progress, where x(t) is the cubic bezier function 
    // Then evaluate y(t1) where t1 is the root of the above equation
    // 
    // Though cubic equations can have 3 roots, the SMIL spec constrains the end points to be
    // 0,0 and 1,1 and the control points to lie within the end points' bounding rectangle
    // so we are guaranteed a single-valued function in the interval [0, 1]
    //
    // We need to solve for all roots and choose the root that lies in the interval [0, 1]
    //

    // polynomial is of the form --- a3*x^3 + a2*x^2 + a1*x + a0 

    double a0 = -1 * progress;
    double a1 = 3 * s.x1;
    double a2 = 3 * (s.x2 - 2 * s.x1);
    double a3 = 1 + 3 * (s.x1 - s.x2);

    if (0.0 == a3)
    {
        if (0.0 == a2)
        {
            if (0.0 == a1)
            {
                // this is a constant polynomial

                // we should never get here, but if we do
                // just skip this part of the computation
                cp = progress;
            }
            else
            {
                // this is a linear polynomial

                cp = -1 * a0 / a1;
            }
        }
        else
        {
            // this is a quadratic polynomial

            double D = a1 * a1 - 4 * a2 * a0;

            // switch on the Discriminant
            if (D < 0.0)
            {
                // there are no real roots

                // we should never get here, but if we do
                // just skip this part of the computation
                cp = progress;
            }
            else if (0.0 == D)
            {
                // there is one repeating root

                cp = -1 * a1 / (2 * a2);
            }
            else
            {
                // there are two distinct roots

                double sqrtD = sqrt(D);

                cp = (-1 * a1 + sqrtD) / (2 * a2);

                if (cp > 1.0 || cp < 0.0)
                {
                    cp = (-1 * a1 - sqrtD) / (2 * a2);
                }
            }
        }
    }
    else
    {
        // this is a cubic polynomial

        a0 /= a3;
        a1 /= a3;
        a2 /= a3;

        double a2by3 = a2 / 3;

        double Q = ((3 * a1) - (a2 * a2)) / 9;
        double R = ((9 * a2 * a1) - (27 * a0) - (2 * a2 * a2 *a2)) / 54;

        double D = (Q * Q * Q) + (R * R);

        // switch on Discriminant
        if (D > 0)
        {
            // There is only one root

            double sqrtD = sqrt(D);

            // pow does not handle cube roots of negative numbers, so work around...
            int mult = (R + sqrtD < 0 ? -1 : 1);
            double S = mult * pow((mult * (R + sqrtD)), (1.0/3.0));

            mult = (R < sqrtD ? -1 : 1);
            double T = mult * pow((mult * (R - sqrtD)), (1.0/3.0));

            cp = S + T - a2by3; 
        }
        else if (0.0 == D)
        {
            // there are two roots

            int mult = (R < 0 ? -1 : 1);
            double S = mult * pow((mult * R), (1.0/3.0));

            cp = 2 * S - a2by3; 

            if (cp > 1.0 || cp < 0.0)
            {
                cp -= 3 * S;
            }
        }
        else
        {
            // there are three roots

            double theta = acos(R / sqrt(-1 * Q * Q * Q));
            double pi = 22.0 / 7.0;
            double sqrtQ2 = 2 * sqrt(-1 * Q);

            cp = sqrtQ2 * cos(theta / 3) - a2by3;

            if (cp > 1.0 || cp < 0.0)
            {
                cp = sqrtQ2 * cos((theta + 2 * pi) / 3) - a2by3;

                if (cp > 1.0 || cp < 0.0)
                {
                    cp = sqrtQ2 * cos((theta + 4 * pi) / 3) - a2by3;
                }
            }
        }
    }

    if (cp > 1.0 || cp < 0.0)
    {
        // Since a root should always exist for valid keySpline values (i.e. between 0,0 and 1,1)
        // this should never happen theoretically. But in case of floating point error
        // revert to progress
        cp = progress;
    }

    cpm1 = 1 - cp;
    cp3 = cp * cp * cp;

    result = 3*cp*cpm1*cpm1*s.y1 + 3*cp*cp*cpm1*s.y2 + cp3;

done:
    return result;
} // CalculateBezierProgressExact

#endif // if 0 && DBG

///////////////////////////////////////////////////////////////
//  Name: OnSync
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::OnSync() dbllastTime = %g dblnewTime = %g",
              this, dbllastTime, dblnewTime));
}


///////////////////////////////////////////////////////////////
//  Name: OnResume
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnResume(double dblLocalTime)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::OnResume()",
              this));

    CTIMEElementBase::OnResume(dblLocalTime);
} 

///////////////////////////////////////////////////////////////
//  Name: OnPause
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnPause(double dblLocalTime)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::OnPause()",
              this));

    CTIMEElementBase::OnPause(dblLocalTime);
}

STDMETHODIMP
CTIMEAnimationBase::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr = THR(::TimeLoad(this, CTIMEAnimationBase::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Load(pPropBag, pErrorLog));
done:
    return hr;
}

STDMETHODIMP
CTIMEAnimationBase::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = THR(::TimeSave(this, CTIMEAnimationBase::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));
done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: CompareValuePairs
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
static int __cdecl
CompareValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((VALUE_PAIR*)pv1)->wzName,
                    ((VALUE_PAIR*)pv2)->wzName);
} 

///////////////////////////////////////////////////////////////
//  Name: ConvertToPixels
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool
CTIMEAnimationBase::ConvertToPixels(VARIANT *pvarValue)
{
    int  pixelPerInchVert, pixelPerInchHoriz, pixelFactor;
    LPOLESTR szTemp  = NULL;
    HDC hdc;
    double dblVal = VALUE_NOT_SET;
    HRESULT hr;
    bool bReturn = false;

    pixelPerInchHoriz=pixelPerInchVert=0;
   
    // see if we can just do a straight converstion.
    hr = VariantChangeTypeEx(pvarValue,pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
    if (SUCCEEDED(hr))
    {
        bReturn = true;
        goto done;
    }

    if (pvarValue->vt != VT_BSTR)
    {
        // no conversion to do...just return.
        bReturn = true;
        goto done;
    }
    
    // see if the bstr is empty
    if (ocslen(pvarValue->bstrVal) == 0)
    {
        SysFreeString(pvarValue->bstrVal);
        V_VT(pvarValue)= VT_R8;
        V_R8(pvarValue) = 0;
        bReturn = true;
        goto done;
    }


    szTemp = CopyString(pvarValue->bstrVal);
    if (NULL == szTemp)
    {
        goto done;
    }

    hdc = GetDC(NULL);
    if (NULL != hdc)
    {
        pixelPerInchHoriz = g_LOGPIXELSX;
        pixelPerInchVert  = g_LOGPIXELSY;
        ReleaseDC(NULL, hdc);
    }


    // Determine the PixelFactor based on what the target is...
    {
        VALUE_PAIR valName;
        valName.wzName = m_SAAttribute;

        VALUE_PAIR * pValPair = (VALUE_PAIR*)bsearch(&valName,
                                              rgPropOr,
                                              SIZE_OF_VALUE_TABLE,
                                              sizeof(VALUE_PAIR),
                                              CompareValuePairsByName);

        if (NULL == pValPair)
            pixelFactor = (pixelPerInchVert + pixelPerInchHoriz) /2;
        else
            pixelFactor = pValPair->bValue == HORIZ ? pixelPerInchHoriz : pixelPerInchVert;
    }


    {
        // See if we have PIXELS
        if (ConvertToPixelsHELPER(szTemp, PX, 1.0, 1.0f, &dblVal))
        {
            bReturn = true;
            goto done;
        }
     
        // Try to convert to Pixels.
        int i;
        for(i=0; i< (int)SIZE_OF_CONVERSION_TABLE;i++)
        {
            if (ConvertToPixelsHELPER(szTemp, rgPixelConv[i].wzName, rgPixelConv[i].dValue, (float) pixelFactor, &dblVal))
            {
                bReturn = true;
                goto done;
            }
        }
    }

done:
    if (dblVal != VALUE_NOT_SET)
    {
        ::VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = dblVal;
    }
    if (szTemp)
    {
        delete [] szTemp;
    }
    return bReturn;
}

void
CTIMEAnimationBase::GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess)
{
    HRESULT hr = S_OK;
    CComVariant inValue;
    
    *pfDontPostProcess = false;

    inValue.Copy(pvarValue);
    
    if (GetAutoReverse())
    {
        VariantClear(pvarValue);
        hr = THR(::VariantCopy(pvarValue, &m_varLastValue));
        if (FAILED(hr))
        {
            goto done;
        }
        
        *pfDontPostProcess = true;
    }
    else if (m_dataToUse == VALUES)
    {
        ::VariantClear(pvarValue);
        V_VT(pvarValue) = VT_BSTR;
        V_BSTR(pvarValue) = SysAllocString(m_ppstrValues[m_numValues-1]);
    }
    else if (m_dataToUse == BY)
    {
        GetFinalByValue(pvarValue);
    }
    else if (m_dataToUse == TO)
    {
        hr = THR(::VariantCopy(pvarValue, &m_varTo));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
done:
    return;
}


void
CTIMEAnimationBase::GetFinalByValue(VARIANT *pvarValue)
{
    VariantClear(pvarValue);

    if (m_bFrom)
    {
        VariantCopy(pvarValue, &m_varFrom);
        if (!ConvertToPixels(pvarValue))
        {
            goto done;
        }
    }
    else
    {
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = 0;
    }
    
    if (!ConvertToPixels(&m_varBy))
    {
        goto done;
    }      

    Assert(V_VT(pvarValue) == VT_R8);
    Assert(V_VT(&m_varBy)   == VT_R8);

    V_R8(pvarValue)+= V_R8(&m_varBy);

done:
    return;
} // GetFinalByValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animfilter.cpp ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\src\animfilter.cpp
//
//  Classes:    CTIMEFilterAnimation
//
//  History:
//  2000/08/24  mcalkins    Created.
//  2000/09/20  pauld       Hooked up fragment to specialized filter composer.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "animfilter.h"

DeclareTag(tagAnimationFilter, "SMIL Animation", 
           "CTIMEFilterAnimation methods");

DeclareTag(tagAnimationFilterInterpolate, "SMIL Animation", 
           "CTIMEFilterAnimation interpolation");

DeclareTag(tagAnimationFilterAdditive, "SMIL Animation", 
           "CTIMEFilterAnimation additive animation methods");

#define TRANSITION_KEY_DELIMITER    (L":")

#define PART_ONE 0
#define PART_TWO 1

#define DEFAULT_TRANSITIONFILTER_DURATION 1.0

static const int g_iDefaultFrom = 0;
static const int g_iDefaultTo   = 1;

//+-----------------------------------------------------------------------------
//
//  Method: CTIMEFilterAnimation::CTIMEFilterAnimation
//
//------------------------------------------------------------------------------
CTIMEFilterAnimation::CTIMEFilterAnimation()
{
}
//  Method: CTIMEFilterAnimation::CTIMEFilterAnimation


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEFilterAnimation::~CTIMEFilterAnimation
//
//------------------------------------------------------------------------------
CTIMEFilterAnimation::~CTIMEFilterAnimation()
{
    if (m_SAType.IsSet())
    {
        delete [] m_SAType.GetValue();
        m_SAType.Reset(NULL);
    }

    if (m_SASubtype.IsSet())
    {
        delete [] m_SASubtype.GetValue();
        m_SASubtype.Reset(NULL);
    }

    if (m_SAMode.IsSet())
    {
        delete [] m_SAMode.GetValue();
        m_SAMode.Reset(NULL);
    }

    if (m_SAFadeColor.IsSet())
    {
        delete [] m_SAFadeColor.GetValue();
        m_SAFadeColor.Reset(NULL);
    }
} 
//  Method: CTIMEFilterAnimation::~CTIMEFilterAnimation


//+-----------------------------------------------------------------------------
//
// CTIMEFilterAnimation::Init
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEFilterAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagAnimationFilter,
              "CTIMEFilterAnimation(%p)::Init()",
              this));

    HRESULT hr = CTIMEAnimationBase::Init(pBehaviorSite);

    m_SAType.InternalSet(WZ_DEFAULT_TRANSITION_TYPE);
    m_SASubtype.InternalSet(WZ_DEFAULT_TRANSITION_SUBTYPE);

    hr = S_OK;
done :
    RRETURN(hr);
}
// CTIMEFilterAnimation::Init


///////////////////////////////////////////////////////////////
//
//  Name: CTIMEFilterAnimation::AssembleFragmentKey
//
//  Synopsis : The composer site uses each fragments 
//             the attributeName property as a key.  We 
//             need to put information that makes this particular
//             transition distinct into the attributeName.
//             By and large, these will be the union of our properties
//             and parameters (from our param children's name/value
//             pairs governing this transition's visual qualities
//
///////////////////////////////////////////////////////////////
HRESULT
CTIMEFilterAnimation::AssembleFragmentKey (void)
{
    HRESULT hr = S_OK;

    // Bundle up the type and subtype attributes and stuff them into the 
    // (non-queryable) attributeName object.
    // ## ISSUE - we must intellegently handle subType defaults.
    // ## ISSUE - we should include the param tag values as a part of the fragment key.
    if (m_SAType.GetValue())
    {
        int iCount = lstrlenW(m_SAType.GetValue());

        iCount += lstrlenW(TRANSITION_KEY_DELIMITER);
        if (m_SASubtype.GetValue())
        {
            iCount += lstrlenW(m_SASubtype.GetValue());
        }
        iCount += lstrlenW(TRANSITION_KEY_DELIMITER);
        if (m_SAMode.GetValue())
        {
            iCount += lstrlenW(m_SAMode.GetValue());
        }
        iCount += lstrlenW(TRANSITION_KEY_DELIMITER);
        if (m_SAFadeColor.GetValue())
        {
            iCount += lstrlenW(m_SAFadeColor.GetValue());
        }

        {
            LPWSTR wzAttributeName = NEW WCHAR[iCount + 1];

            if (NULL != wzAttributeName)
            {
                StrCpyW(wzAttributeName, m_SAType.GetValue());
                StrCatW(wzAttributeName, TRANSITION_KEY_DELIMITER);
                // Only need to set the subtype when using a non-default type.
                if ( (m_SAType.IsSet()) && (m_SASubtype.IsSet()) )
                {
                    StrCatW(wzAttributeName, m_SASubtype.GetValue());
                }
                StrCatW(wzAttributeName, TRANSITION_KEY_DELIMITER);
                if (m_SAMode.IsSet())
                {
                    StrCatW(wzAttributeName, m_SAMode.GetValue());
                }
                StrCatW(wzAttributeName, TRANSITION_KEY_DELIMITER);
                if (m_SAFadeColor.IsSet())
                {
                    StrCatW(wzAttributeName, m_SAFadeColor.GetValue());
                }

                m_SAAttribute.SetValue(wzAttributeName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CTIMEFilterAnimation::AssembleFragmentKey


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEFilterAnimation::EnsureAnimationFunction
//
//  Synopsis:   Make sure that the transitionFilter element has at 
//              least a default animation function if none is supplied.
//
//  Arguments:  None
//
//------------------------------------------------------------------------------
void
CTIMEFilterAnimation::EnsureAnimationFunction (void)
{
    if ((NONE == m_dataToUse) && (!DisableAnimation()))
    {
        CComVariant varFrom(g_iDefaultFrom);
        CComVariant varTo(g_iDefaultTo);
        
        IGNORE_HR(put_from(varFrom));
        IGNORE_HR(put_to(varTo));
    }

    if (!m_FADur.IsSet())
    {
        CComVariant varDefaultDur(DEFAULT_TRANSITIONFILTER_DURATION);

        IGNORE_HR(put_dur(varDefaultDur));
    }

    // Do not override a declared function
} // CTIMEFilterAnimation::EnsureAnimationFunction


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEFilterAnimation::OnLoad
//
//  Synopsis:   Called when the window.onload event has fired.  We will need to 
//              sniff out our target, and set a flag telling it to expect a filter.
//
//  Arguments:  None
//
//------------------------------------------------------------------------------
void
CTIMEFilterAnimation::OnLoad (void)
{
    CComPtr<IHTMLElement> spElem;
    CComPtr<ITIMEElement> spTimeElem;
    CComPtr<ITIMETransitionSite> spTransSite;

    TraceTag((tagAnimationFilter,
              "CTIMEFilterAnimation(%p)::OnLoad()",
              this));

    CTIMEAnimationBase::OnLoad();

    HRESULT hr = THR(FindAnimationTarget(&spElem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(FindTIMEInterface(spElem, &spTimeElem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spTimeElem->QueryInterface(IID_TO_PPV(ITIMETransitionSite, &spTransSite)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spTransSite->InitTransitionSite());
    if (FAILED(hr))
    {
        goto done;
    }

done :
    return;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEFilterAnimation::OnPropertiesLoaded
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties.  We will use the type/subtype 
//              tuple to assemble a value that we'll pass up to the composer, 
//              to identify the type of transition.
//
//  Arguments:  None
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEFilterAnimation::OnPropertiesLoaded(void)
{
    TraceTag((tagAnimationFilter,
              "CTIMEFilterAnimation(%p)::OnPropertiesLoaded()",
              this));

    HRESULT hr = CTIMEAnimationBase::OnPropertiesLoaded();

    if (FAILED(hr))
    {
        goto done;
    }

    hr = AssembleFragmentKey();
    if (FAILED(hr))
    {
        goto done;
    }

    EnsureAnimationFunction();

    hr = S_OK;
done:
    RRETURN(hr);
} // OnPropertiesLoaded

///////////////////////////////////////////////////////////////
//  Name: get_type
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_type(BSTR *pbstrType)
{
    return getStringAttribute (m_SAType, pbstrType);
} // get_type

///////////////////////////////////////////////////////////////
//  Name: put_type
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_type(BSTR bstrType)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_TYPE, 
                              bstrType, m_SAType, 
                              WZ_DEFAULT_TRANSITION_TYPE);
} // put_type

///////////////////////////////////////////////////////////////
//  Name: get_subType
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_subType(BSTR *pbstrSubtype)
{
    return getStringAttribute (m_SASubtype, pbstrSubtype);
} // get_subType


///////////////////////////////////////////////////////////////
//  Name: put_subType
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_subType(BSTR bstrSubtype)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_SUBTYPE, 
                              bstrSubtype, m_SASubtype, 
                              WZ_DEFAULT_TRANSITION_SUBTYPE);
} // put_subType


///////////////////////////////////////////////////////////////
//  Name: get_mode
//
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_mode(BSTR *pbstrMode)
{
    return getStringAttribute (m_SAMode, pbstrMode);
} // get_mode


///////////////////////////////////////////////////////////////
//  Name: put_mode
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_mode(BSTR bstrMode)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_MODE, 
                              bstrMode, m_SAMode, 
                              WZ_DEFAULT_TRANSITION_MODE);
} // put_mode


///////////////////////////////////////////////////////////////
//  Name: get_fadeColor
//
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_fadeColor (BSTR *pbstrFadeColor)
{
    return getStringAttribute (m_SAFadeColor, pbstrFadeColor);
} // get_fadeColor


///////////////////////////////////////////////////////////////
//  Name: put_fadeColor
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_fadeColor(BSTR bstrFadeColor)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_FADECOLOR, 
                              bstrFadeColor, m_SAFadeColor, 
                              WZ_DEFAULT_TRANSITION_SUBTYPE);
} // put_fadeColor


///////////////////////////////////////////////////////////////
//  Name: getStringAttribute
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::getStringAttribute (const CAttr<LPWSTR> & refStringAttr, BSTR *pbstrStringAttr)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(pbstrStringAttr);

    if (refStringAttr.GetValue())
    {
        *pbstrStringAttr = SysAllocString(refStringAttr.GetValue());
        if (NULL == (*pbstrStringAttr))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
} // getStringAttribute


///////////////////////////////////////////////////////////////
//  Name: putStringAttribute
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::putStringAttribute (DISPID dispidProperty, 
                                          BSTR bstrStringAttr, 
                                          CAttr<LPWSTR> & refStringAttr, 
                                          LPCWSTR wzDefaultValue)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(bstrStringAttr);

    // This will clean out the old value.
    // We need to can the old composer et al.
    if (NULL != refStringAttr.GetValue())
    {
        endAnimate();
    }

    if (refStringAttr.IsSet())
    {
        delete [] refStringAttr.GetValue();
        refStringAttr.Reset(const_cast<LPWSTR>(wzDefaultValue));
    }

    refStringAttr.SetValue(CopyString(bstrStringAttr));
    if (NULL == refStringAttr.GetValue())
    {
        hr = E_OUTOFMEMORY;
    }

    NotifyPropertyChanged(dispidProperty);
    RRETURN(hr);
} // putStringAttribute


///////////////////////////////////////////////////////////////
//  Name: GetParameters
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::GetParameters (VARIANT *pvarParams)
{
    return E_NOTIMPL;
} // GetParameters

///////////////////////////////////////////////////////////////
//  Name: RangeCheckValue
//
///////////////////////////////////////////////////////////////
bool
CTIMEFilterAnimation::RangeCheckValue (const VARIANT *pvarValueItem)
{
    bool fRet = false;

    if (VT_R8 == V_VT(pvarValueItem))
    {
        if ((0.0 <= V_R8(pvarValueItem)) && (1.0 >= V_R8(pvarValueItem)) )
        {
            fRet = true;
        }
    }

    return fRet;
} // RangeCheckValue

///////////////////////////////////////////////////////////////
//  Name: ValidateByValue
//
///////////////////////////////////////////////////////////////
bool
CTIMEFilterAnimation::ValidateByValue (const VARIANT *pvarBy)
{
    bool fRet = CTIMEAnimationBase::ValidateByValue(pvarBy);

    if (fRet)
    {
        fRet = RangeCheckValue(pvarBy);
    }

    if (!fRet)
    {
        m_AnimPropState.fBadBy = true;
    }

    return fRet;
} // ValidateByValue


///////////////////////////////////////////////////////////////
//  Name: ValidateValueListItem
//
//  Synopsis : Range check our value list items
//
///////////////////////////////////////////////////////////////
bool
CTIMEFilterAnimation::ValidateValueListItem (const VARIANT *pvarValueItem)
{
    bool fRet = CTIMEAnimationBase::ValidateValueListItem(pvarValueItem);

    if (fRet)
    {
        fRet = RangeCheckValue(pvarValueItem);
    }

    if (!fRet)
    {
        m_AnimPropState.fBadValues = true;
    }

    return fRet;
} // ValidateValueListItem


///////////////////////////////////////////////////////////////
//  Name: addToComposerSite
//
///////////////////////////////////////////////////////////////
HRESULT
CTIMEFilterAnimation::addToComposerSite (IHTMLElement2 *pielemTarget)
{
    HRESULT hr = E_FAIL;

    // We do not want to set this up unless 
    // the animation is valid.  If we apply the 
    // filter when we do not mean to, we'll get 
    // incorrect results.
    if (!DisableAnimation())
    {
        hr = THR(CTIMEAnimationBase::addToComposerSite(pielemTarget));
    }

    RRETURN2(hr, E_FAIL, S_FALSE);
} // addToComposerSite
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animelm.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animelm.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMELM_H
#define _ANIMELM_H

#include "animbase.h"


class
ATL_NO_VTABLE
CTIMEAnimationElement :
    public CComCoClass<CTIMEAnimationElement, &CLSID_TIMEAnimation>,
    public CTIMEAnimationBase
{

public:
    CTIMEAnimationElement() {;}
    virtual ~CTIMEAnimationElement() {;}

    DECLARE_AGGREGATABLE(CTIMEAnimationElement);
    DECLARE_REGISTRY(CLSID_TIMEAnimation,
                     LIBID __T(".TIMEAnimation.1"),
                     LIBID __T(".TIMEAnimation"),
                     0,
                     THREADFLAGS_BOTH);
private:
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEAnimationElement"); }
#endif

};

#endif /* _ANIMELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animfrag.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: animfrag.h
//
//  Contents: TIME Animation fragment helper class
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMFRAG_H
#define _ANIMFRAG_H

#include "animbase.h"

// The fragment is the helper class employed by the element as an 
// alternate dispatch implementation for communication between the 
// composer and the animation element.
class
ATL_NO_VTABLE
CAnimationFragment :
      public CComObjectRootEx<CComSingleThreadModel>,
      public ITIMEDispatchImpl<IAnimationFragment, &IID_IAnimationFragment>,
      public ISupportErrorInfoImpl<&IID_IAnimationFragment>
{

public:

    CAnimationFragment (void);
    virtual ~CAnimationFragment (void);

    DECLARE_NOT_AGGREGATABLE(CAnimationFragment)

    HRESULT SetFragmentSite (IAnimationFragmentSite *piFragmentSite);

    //
    // IAnimationFragment
    // 
    STDMETHOD(get_element) (IDispatch **ppidispAnimationElement);
    STDMETHOD(get_value) (BSTR bstrAttributeName, VARIANT varOriginal, VARIANT varCurrent, VARIANT *pvarValue);
    STDMETHOD(DetachFromComposer) (void);

    BEGIN_COM_MAP(CAnimationFragment)
        COM_INTERFACE_ENTRY(IAnimationFragment)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP();

private:
        
    CComPtr<IAnimationFragmentSite> m_spFragmentSite;

#if DBG
    const _TCHAR * GetName (void) { return __T("CAnimationFragment"); }
#endif

};

#endif /* _ANIMFRAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animfrag.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Fragment Implementation

*******************************************************************************/


#include "headers.h"
#include "animfrag.h"

DeclareTag(tagAnimationFragment, "SMIL Animation", "CAnimationFragment methods")

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::CAnimationFragment
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFragment::CAnimationFragment (void)
{
    TraceTag((tagAnimationFragment,
              "CAnimationFragment(%lx)::CAnimationFragment()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::~CAnimationFragment
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFragment::~CAnimationFragment (void)
{
    TraceTag((tagAnimationFragment,
              "CAnimationFragment(%lx)::~CAnimationFragment()",
              this));
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::SetFragmentSite
//
//  Overview:  sets a reference to the owning fragment site
//
//  Arguments: fragment site
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CAnimationFragment::SetFragmentSite (IAnimationFragmentSite *piFragmentSite)
{
    TraceTag((tagAnimationFragment,
              "CAnimationFragment(%lx)::SetFragmentSite(%lx)",
              this, piFragmentSite));

    HRESULT hr;

    m_spFragmentSite = piFragmentSite;

    hr = S_OK;
done :
    RRETURN(hr);
} // SetFragmentSite

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::get_value
//
//  Overview:  This is the query from the composer for the animated 
//             attribute's current value.
//
//  Arguments: animated attribute name, its original value, its current value
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFragment::get_value (BSTR bstrAttributeName, 
                               VARIANT varOriginal, VARIANT varCurrentValue,
                               VARIANT *pvarValue)
{
    HRESULT hr;

    if (m_spFragmentSite)
    {
        hr = m_spFragmentSite->NotifyOnGetValue(bstrAttributeName, 
                                                varOriginal, varCurrentValue, 
                                                pvarValue);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done : 
    RRETURN(hr);
} // get_value

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::DetachFromComposer
//
//  Overview:  This is the notification from the composer telling the fragment to 
//             detach itself.
//             
//  Arguments: None 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFragment::DetachFromComposer (void)
{
    HRESULT hr;

    if (m_spFragmentSite)
    {
        hr = m_spFragmentSite->NotifyOnDetachFromComposer();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done : 
    RRETURN(hr);
} // get_value

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::get_element
//
//  Overview:  This is the query from the composer for the animated 
//             element's dispatch.
//             
//  Arguments: None 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFragment::get_element (IDispatch **ppidispAnimationElement)
{
    HRESULT hr;

    if (m_spFragmentSite)
    {
        hr = m_spFragmentSite->NotifyOnGetElement(ppidispAnimationElement);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done : 
    RRETURN(hr);
} // get_element
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animmotion.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\animmotion.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMMOTION_H
#define _ANIMMOTION_H

#include "animbase.h"
#include "smilpath.h"

//+-------------------------------------------------------------------------------------
//
// CTIMEMotionAnimation
//
//--------------------------------------------------------------------------------------

class CTIMEMotionAnimation : 
    public CComCoClass<CTIMEMotionAnimation, &CLSID_TIMEMotionAnimation>,
    public CTIMEAnimationBase
{

 public:

    CTIMEMotionAnimation();
    virtual ~CTIMEMotionAnimation();
   
    DECLARE_AGGREGATABLE(CTIMEMotionAnimation);
    DECLARE_REGISTRY(CLSID_TIMEMotionAnimation,
                     LIBID __T(".TIMEMotionAnimation.1"),
                     LIBID __T(".TIMEMotionAnimation"),
                     0,
                     THREADFLAGS_BOTH);
                     
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    // Overrides
    STDMETHOD(put_from)(VARIANT val);
    STDMETHOD(put_to)(VARIANT val);
    STDMETHOD(put_by)(VARIANT val);
    STDMETHOD(put_values)(VARIANT val);
    STDMETHOD(get_origin)(BSTR * val);
    STDMETHOD(put_origin)(BSTR val);
    STDMETHOD(get_path)(VARIANT * path);
    STDMETHOD(put_path)(VARIANT path);

    // Overrides to prevent get/put of invalid attributes
    STUB_INVALID_ATTRIBUTE(BSTR,attributeName)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

    //
    // IAnimationFragmentSite
    // 
    STDMETHOD(NotifyOnGetValue)(BSTR bstrAttributeName, 
                                VARIANT varOriginal, VARIANT varCurrent, 
                                VARIANT *pvarValue);
    STDMETHOD(NotifyOnDetachFromComposer) (void);

    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);

 protected :

    virtual HRESULT removeFromComposerSite (void);   
    virtual HRESULT addToComposerSite (IHTMLElement2 *pielemTarget);
    virtual HRESULT CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld);
    virtual void DetermineAdditiveEffect (void);
    virtual void ValidateState();
    virtual double GetAnimationRange();
    
 private:

    HRESULT calculateDiscreteValue (VARIANT *pvarValue);    
    HRESULT calculateLinearValue (VARIANT *pvarValue);      
    HRESULT calculateSplineValue (VARIANT *pvarValue);      
    HRESULT calculatePacedValue (VARIANT *pvarValue);      
    HRESULT QueryAttributeForTopLeft (LPCWSTR wzAttributeName);
    virtual void UpdateStartValue (VARIANT *pvarNewStartValue);
    virtual HRESULT DoFill (VARIANT *pvarValue);
    virtual void PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue);

    void resetValue (VARIANT *pvarValue);

    virtual void SetInitialState (void);
    virtual void SetFinalState (void);

    virtual bool QueryNeedFirstUpdate (void)
        { return m_bAnimatingLeft?m_bNeedFirstLeftUpdate:m_bNeedFirstTopUpdate; }

    virtual bool QueryNeedFinalUpdate (void)
        { return m_bAnimatingLeft?m_bNeedFinalLeftUpdate:m_bNeedFinalTopUpdate; }
    virtual void OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void OnFirstUpdate (VARIANT *pvarValue);

    void CalculateTotalDistance();
    double CalculateDistance(POINTF a, POINTF b);

    // path stuff
    HRESULT SetSMILPath(CTIMEPath ** pPath, long numPath, long numMoveTo);
    POINTF InterpolatePath();
    POINTF InterpolatePathPaced();

    double CalculatePointDistance(POINTF p1, POINTF p2);
    HRESULT ParsePair(VARIANT val, POINTF *outPT);
    float GetCorrectLeftTopValue(POINTF fPoint);
    void  PutCorrectLeftTopValue(VARIANT pVar ,POINTF &fPointDest);
    void  PutCorrectLeftTopValue(double val ,POINTF &fPointDest);
    void  PutCorrectLeftTopValue(POINTF fPointSrc ,POINTF &fPointDest);
    void  GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess);
    virtual void resetAnimate (void);
    virtual void endAnimate (void);
    virtual void UpdateCurrentBaseline (const VARIANT *pvarCurrent);

 private:

    bool m_bBy;
    bool m_bTo;
    bool m_bFrom;

    bool m_bNeedFirstLeftUpdate;
    bool m_bNeedFinalLeftUpdate;
    bool m_bNeedFirstTopUpdate;
    bool m_bNeedFinalTopUpdate;
    bool m_bLastSet;
    bool m_bNeedBaselineUpdate;

    POINTF m_pointTO;
    POINTF m_pointFROM;
    POINTF m_pointBY;
    POINTF m_pointLast;
    POINTF m_pointCurrentBaseline;
    POINTF m_ptOffsetParent;

    SplinePoints m_pSplinePoints;
    POINTF *m_pPointValues;
    
    bool m_bAnimatingLeft;

    CComVariant m_varLeftOrig;
    CComVariant m_varTopOrig;

    CComPtr<ISMILPath> m_spPath;

        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEMotionAnimation"); }
#endif

    
}; // CTIMEMotionAnimation

#endif /* _ANIMMOTION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animmotion.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: animmotion.cpp
 *
 * Abstract: Simple animation of Elements
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "animfrag.h"
#include "animmotion.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagMotionAnimationTimeElm, "SMIL Animation", "CTIMEMotionAnimation methods")
DeclareTag(tagMotionAnimationTimeValue, "SMIL Animation", "CTIMEMotionAnimation composition callbacks")
DeclareTag(tagMotionAnimationTimeValueAdditive, "SMIL Animation", "CTIMEMotionAnimation additive updates")
DeclareTag(tagMotionAnimationPath, "SMIL Animation", "CTIMEMotionAnimation Path")

#define DEFAULT_ORIGIN        ORIGIN_DEFAULT
#define DEFAULT_PATH          NULL

static const LPWSTR s_cPSTR_COMMA_SEPARATOR = L",";

#define SUPER CTIMEAnimationBase

///////////////////////////////////////////////////////////////
//  Name: CTIMEMotionAnimation
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMEMotionAnimation::CTIMEMotionAnimation() :
  m_bBy(false),
  m_bTo(false),
  m_bFrom(false),
  m_bNeedFirstLeftUpdate(false),
  m_bNeedFinalLeftUpdate(false),
  m_bNeedFirstTopUpdate(false),
  m_bNeedFinalTopUpdate(false),
  m_pPointValues(NULL),
  m_bLastSet(false),
  m_bNeedBaselineUpdate(false),
  m_bAnimatingLeft(false)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::CTIMEMotionAnimation()",
              this));
    
    m_ptOffsetParent.x = 0.0;
    m_ptOffsetParent.y = 0.0;
    m_pointTO.x               = m_pointTO.y               = 0;
    m_pointFROM.x             = m_pointFROM.y             = 0;
    m_pointBY.x               = m_pointBY.y               = 0;
    m_pointLast.x             = m_pointLast.y             = 0;
    m_pointCurrentBaseline.x  = m_pointCurrentBaseline.y  = 0;
    m_pSplinePoints.x1 = m_pSplinePoints.y1 = m_pSplinePoints.x2 = m_pSplinePoints.y2 = 0.0;
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMEMotionAnimation
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMEMotionAnimation::~CTIMEMotionAnimation()
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::~CTIMEMotionAnimation()",
              this));

    if (m_spPath.p)
    {
        IGNORE_HR(m_spPath->Detach());
    }

    delete [] m_pPointValues;
} 


///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::Init(%p)",
              this, pBehaviorSite));
    
    
    HRESULT hr = E_FAIL; 
    CComPtr <IDispatch> pDocDisp;

    hr = THR(SUPER::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

    // Set up defauts
    m_bAdditive    = false;
    m_bAccumulate  = false;
    // Using InternalSet instead of '=', to prevent attribute from being persisted
    m_IACalcMode.InternalSet(CALCMODE_PACED);
    

done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: DetermineAdditiveEffect
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::DetermineAdditiveEffect (void)
{
    // by w/o from implies additive
    if (   (BY == m_dataToUse)
        && (m_bBy)
        && (!m_bFrom))
    {
        m_bAdditive = true;
    }
    // to w/o from overrides the additive=sum effect.
    else if (   (TO == m_dataToUse)
             && (m_bTo)
             && (!m_bFrom))
    {
        m_bAdditive = false;
    }
    // 
    else
    {
        m_bAdditive = m_bAdditiveIsSum;
    }
} // DetermineAdditiveEffect

///////////////////////////////////////////////////////////////
//  Name: put_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_by(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_by()",
              this));
    
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    // reset this attribute
    dt = RESET;
    m_pointBY.x = 0;
    m_pointBY.y = 0;
    m_bBy = false;

    // cache animation type
    dTemp = m_dataToUse;

    // delegate to base class
    hr = SUPER::put_by(val);
    if (FAILED(hr))
    {
        goto done;
    }
    
    // restore animation type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // parse
    hr = ParsePair(val,&m_pointBY);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    // indicate valid BY value
    m_bBy = true;
    dt = BY;

    hr = S_OK;
done:
    m_AnimPropState.fBadBy = FAILED(hr) ? true : false;

    m_AnimPropState.fInterpolateBy = fCanInterpolate;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_by


///////////////////////////////////////////////////////////////
//  Name: put_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_from(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_from()",
              this));
   
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;

    // Clear the attribute
    m_pointFROM.x = 0;
    m_pointFROM.y = 0;
    m_bFrom = false;

    // delegate to base class
    hr = SUPER::put_from(val);
    if (FAILED(hr))
    {
        goto done;
    }

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = ParsePair(val, &m_pointFROM);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }
                
    m_bFrom = true;
    
    hr = S_OK;;
done:
    m_AnimPropState.fBadFrom = FAILED(hr) ? true : false;
    
    m_AnimPropState.fInterpolateFrom = fCanInterpolate;

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_from


///////////////////////////////////////////////////////////////
//  Name: put_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_values(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_values()",
              this));

    HRESULT hr = E_FAIL;
    CComVariant svarTemp;
    int i;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    dTemp = m_dataToUse;

    // reset internal state
    delete [] m_pPointValues;
    m_pPointValues = NULL;

    // delegate to base class
    hr = SUPER::put_values(val);
    if (FAILED(hr))
    {
        goto done;
    }

    // restore animation-type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // check for an empty string
    if (m_numValues == 0)
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    m_pPointValues = NEW POINTF [m_numValues];
    if (NULL == m_pPointValues)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Parse out the pairs values.....
    for (i=0; i< m_numValues;i++)
    {
        svarTemp = m_ppstrValues[i];

        if (NULL == svarTemp.bstrVal)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = ParsePair(svarTemp, &m_pPointValues[i]);
        if (FAILED(hr))
        {
            fCanInterpolate = false;
            goto done;
        }
    }

    dt = VALUES;

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_AnimPropState.fBadValues = true;
        delete [] m_pPointValues;
        m_pPointValues = NULL;
    }
    else
    {
        m_AnimPropState.fBadValues = false;
    }

    m_AnimPropState.fInterpolateValues = fCanInterpolate;
    
    updateDataToUse(dt);

    CalculateTotalDistance();
    
    ValidateState();

    DetermineAdditiveEffect();
    
    RRETURN(hr);
} // put_values


///////////////////////////////////////////////////////////////
//  Name: put_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_to(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_to()",
              this));
   
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    // reset this attribute
    dt = RESET;
    m_pointTO.x = 0;
    m_pointTO.y = 0;
    m_bTo = false;

    // cache animation type
    dTemp = m_dataToUse;

    // delegate to base class
    hr = SUPER::put_to(val);
    if (FAILED(hr))
    {
        goto done;
    }
    
    // restore animation type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // parse
    hr = ParsePair(val,&m_pointTO);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    // indicate valid TO value
    m_bTo = true;
    dt = TO;

    hr = S_OK;
done:
    m_AnimPropState.fBadTo = FAILED(hr) ? true : false;
    
    m_AnimPropState.fInterpolateTo = fCanInterpolate;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_to


HRESULT 
CTIMEMotionAnimation::SetSMILPath(CTIMEPath ** pPath, long numPath, long numMoveTo)
{
    HRESULT hr = E_FAIL;
    CComPtr<ISMILPath> spPath;

    CHECK_RETURN_NULL(pPath);

    if (!m_spPath)
    {
        hr = THR(::CreateSMILPath(this, &spPath));
        if (FAILED(hr))
        {
            goto done;
        }

        // keep a reference on the interface
        m_spPath = spPath;
    }

    hr = THR(m_spPath->SetPath(pPath, numPath, numMoveTo));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: get_path
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::get_path(VARIANT * pvarPath)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_NULL(pvarPath);

    VariantInit(pvarPath);

    if (m_SAPath.GetValue())
    {
        V_BSTR(pvarPath) = SysAllocString(m_SAPath.GetValue());

        if (NULL == V_BSTR(pvarPath))
        {
            hr = E_OUTOFMEMORY;
        }

        V_VT(pvarPath) = VT_BSTR;
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: put_path
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_path(VARIANT varPath)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_path()",
              this));
    TraceTag((tagMotionAnimationPath, "CTIMEMotionAnimation(%p, %ls)::put_path(%ls)",
        this, GetID(), varPath.bstrVal));

    HRESULT hr = S_OK;  
    long numPath = 0;
    long numMoveTo = 0;
    CTIMEPath ** pPath = NULL;
    CTIMEParser *pParser = NULL;
    CComVariant svarTemp;
    DATATYPES dt;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    delete [] m_SAPath.GetValue();
    m_SAPath.Reset(DEFAULT_PATH);

    // Clear and reset internal state
    if (m_spPath.p)
    {
        m_spPath->ClearPath();
    }

    // do we need to remove this attribute?
    if (    (VT_EMPTY == varPath.vt)
        ||  (VT_NULL == varPath.vt))
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    // convert to BSTR
    hr = THR(svarTemp.Copy(&varPath));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(VariantChangeTypeEx(&svarTemp, &svarTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        goto done;
    }

    // Store the new attribute string
    m_SAPath.SetValue(CopyString(svarTemp.bstrVal));
    if (NULL == m_SAPath.GetValue())
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
  
    // create parser
    pParser = NEW CTIMEParser(svarTemp.bstrVal, true);
    if (pParser == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    // parse the path 
    pParser->ParsePath(numPath, numMoveTo,&pPath);

    // set it on the smil path object
    hr = THR(SetSMILPath(pPath, numPath, numMoveTo));
    if (FAILED(hr))
    {
        goto done;
    }

    // mark data as path values
    dt = PATH;

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        delete pPath;
    }
    delete pParser;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_PATH);

    RRETURN(hr);
} // put_path


///////////////////////////////////////////////////////////////
//  Name: get_origin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::get_origin(BSTR * val)
{
    HRESULT hr = S_OK;
    LPWSTR wszOriginString = WZ_ORIGIN_DEFAULT;

    CHECK_RETURN_SET_NULL(val);

    if (m_IAOrigin == ORIGIN_ELEMENT)
    {
        wszOriginString = WZ_ORIGIN_ELEMENT;
    }
    else if (m_IAOrigin == ORIGIN_PARENT)
    {
        wszOriginString = WZ_ORIGIN_PARENT;
    }
    else
    {
        wszOriginString = WZ_ORIGIN_DEFAULT;
    }

    *val = SysAllocString(wszOriginString);
    if (NULL == *val)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
} // get_origin

///////////////////////////////////////////////////////////////
//  Name: put_origin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_origin(BSTR val)
{
    HRESULT hr = S_OK;
    LPOLESTR szOrigin = NULL;

    CHECK_RETURN_NULL(val);

    m_IAOrigin.Reset(DEFAULT_ORIGIN);

    szOrigin = TrimCopyString(val);
    if (szOrigin == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_ORIGIN_DEFAULT, szOrigin))
    {
        m_IAOrigin.SetValue(ORIGIN_DEFAULT);
    }
    else if (0 == StrCmpIW(WZ_ORIGIN_PARENT, szOrigin))
    {
        m_IAOrigin.SetValue(ORIGIN_PARENT);
    }
    else if (0 == StrCmpIW(WZ_ORIGIN_ELEMENT, szOrigin))
    {
        m_IAOrigin.SetValue(ORIGIN_ELEMENT);
    }

done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ORIGIN);

    if (szOrigin != NULL)
    {
        delete [] szOrigin;
    }

    RRETURN(hr);
} // put_origin


///////////////////////////////////////////////////////////////
//  Name: removeFromComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::removeFromComposerSite (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::removeFromComposerSite(%p)", 
              this, m_spFragmentHelper));

    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstr(m_bAnimatingLeft?WZ_LEFT:WZ_TOP);

        if (bstr == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = THR(m_spCompSite->RemoveFragment(bstr, m_spFragmentHelper));
        
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // removeFromComposerSite


///////////////////////////////////////////////////////////////
//  Name: endAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::endAnimate (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%lx)::endAnimate()",
              this));

    if (m_spCompSite != NULL)
    {
        m_bAnimatingLeft = true;
        IGNORE_HR(removeFromComposerSite());
        m_bAnimatingLeft = false;
        IGNORE_HR(removeFromComposerSite());
        m_spCompSite.Release();
    }
    SUPER::endAnimate();
} // endAnimate


///////////////////////////////////////////////////////////////
//  Name: addToComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::addToComposerSite (IHTMLElement2 *pielemTarget)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::addToComposerSite(%p, %p)",
              this, pielemTarget, m_spFragmentHelper));

    HRESULT hr;
    CComPtr<IDispatch> pidispSite;

    hr = removeFromComposerSite();
    if (FAILED(hr))
    {
        goto done;
    }

    // Do we have work to do?
    if (NONE == m_dataToUse)
    {
        hr = S_FALSE;
        goto done;
    }    

    if (m_spCompSite == NULL)
    {
        hr = THR(EnsureComposerSite (pielemTarget, &pidispSite));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pidispSite->QueryInterface(IID_TO_PPV(IAnimationComposerSite, 
                                                       &m_spCompSite)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    {   
        CComBSTR bstrLeft(WZ_LEFT);
        CComBSTR bstrTop(WZ_TOP);

        if (bstrLeft == NULL ||
            bstrTop  == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->AddFragment(bstrLeft, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = THR(m_spCompSite->AddFragment(bstrTop, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
        
    }

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(removeFromComposerSite());
    }

    RRETURN2(hr, E_OUTOFMEMORY, S_FALSE);
} // CTIMEMotionAnimation::addToComposerSite

///////////////////////////////////////////////////////////////
//  Name: QueryAttributeForTopLeft
//
//  Abstract: Determine whether we're animating top or left.
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::QueryAttributeForTopLeft (LPCWSTR wzAttributeName)
{
    HRESULT hr;

    // Check first and final states for each attribute 
    // governed by this behavior.
    if (0 == StrCmpIW(wzAttributeName, WZ_LEFT))
    {
        m_bAnimatingLeft = true;
    }
    else if (0 == StrCmpIW(wzAttributeName, WZ_TOP))
    {
        m_bAnimatingLeft = false;
    }
    else
    {
        // Invalid attribute name for this behavior.
        // It must be either left or top.
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // QueryAttributeForTopLeft

///////////////////////////////////////////////////////////////
//  Name: PostprocessValue
//
//  Abstract: Apply additive, accumulate passes and save the value.
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    Assert(VT_R8 == V_VT(pvarValue));

    if (VT_R8 != V_VT(pvarValue))
    {
        goto done;
    }

    if (m_bAdditive)
    {
        DoAdditive(pvarCurrent, pvarValue);
    }
    // Do we need to apply an origin offset?  
    // This is only relevant when we're not doing 
    // additive animation.
    else if (m_IAOrigin != ORIGIN_PARENT)
    {
        V_R8(pvarValue) += GetCorrectLeftTopValue(m_ptOffsetParent);
    }

    if (m_bAccumulate)
    {
        DoAccumulation(pvarValue);
    }

    PutCorrectLeftTopValue(V_R8(pvarValue),m_pointLast);

done :
    return;
} // PostprocessValue

///////////////////////////////////////////////////////////////
//  Name: NotifyOnDetachFromComposer
//
//  Abstract: Let go of any refs to the composer site.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEMotionAnimation::NotifyOnDetachFromComposer (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::NotifyOnDetach(%p)", 
              this, m_spFragmentHelper));

    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstrLeft(WZ_LEFT);
        CComBSTR bstrTop(WZ_TOP);

        if ((bstrLeft == NULL) ||
            (bstrTop  == NULL))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }


        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->RemoveFragment(bstrLeft, m_spFragmentHelper));
        hr = THR(m_spCompSite->RemoveFragment(bstrTop, m_spFragmentHelper));
        IGNORE_RETURN(m_spCompSite.Release()); //lint !e792
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // NotifyOnDetachFromComposer

///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract: Convert the original and in-out values into
//            a canonical form.
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld)
{
    HRESULT hr = CTIMEAnimationBase::CanonicalizeValue(pvarValue, pvtOld);

    if (FAILED(hr))
    {
        goto done;
    }

    if (VT_BSTR == V_VT(pvarValue))
    {
        // We can avert canonicalizing "auto" here, as it 
        // will usually be an intial value.  If it turns
        // out not to be superfluous, we'll see this again
        // during interpolation.
        if (0 != StrCmpW(WZ_AUTO, V_BSTR(pvarValue)))
        {
            if (!ConvertToPixels(pvarValue))
            {
                hr = E_FAIL;
                goto done;
            }
        }
        *pvtOld = VT_BSTR;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UpdateCurrentBaseTime
//
//  Abstract: Examine the current base time, and update it if 
//            we're doing baseline+to animation (the spec calls
//            this hybrid additive).
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::UpdateCurrentBaseline (const VARIANT *pvarCurrent)
{
    m_bNeedBaselineUpdate = false;

    // Are we doing hybrid additive animation?
    if (   (TO == m_dataToUse)
        && (!m_bFrom))
    {
        CComVariant varCurrent;
        HRESULT hr = varCurrent.Copy(pvarCurrent);

        if (FAILED(hr))
        {
            goto done;
        }

        if (!ConvertToPixels(&varCurrent))
        {
            goto done;
        }

        // Has the baseline value changed since we updated it last?
        if (GetCorrectLeftTopValue(m_pointCurrentBaseline) != V_R8(&varCurrent))
        {
            m_bNeedBaselineUpdate = true;
            PutCorrectLeftTopValue(varCurrent, m_pointCurrentBaseline);
        }
    }

done :
    return;
} // UpdateCurrentBaseTime

///////////////////////////////////////////////////////////////
//  Name: UpdateStartValue
//
//  Abstract: This is a nop for animateMotion.
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::UpdateStartValue (VARIANT *pvarNewStartValue)
{
    m_bNeedStartUpdate = false;
} // UpdateStartValue

///////////////////////////////////////////////////////////////
//  Name: DoFill
//
//  Abstract: Apply the fill value if necessary.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::DoFill (VARIANT *pvarValue)
{
    HRESULT hr;

    if (IsOn() && m_bLastSet && m_timeAction.IsTimeActionOn())
    {
        VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: NotifyOnGetValue
//
//  Abstract: Compose the new value of the in/out variant
//            according to our interpolation logic.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::NotifyOnGetValue (BSTR bstrAttributeName, 
                                        VARIANT varOriginal, VARIANT varCurrentValue,
                                        VARIANT *pvarInOutValue)
{
    HRESULT hr = QueryAttributeForTopLeft(bstrAttributeName);
    if (FAILED(hr))
    {
        goto done;
    }

    // Check if we need to do anything
    if (DisableAnimation())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = CTIMEAnimationBase::NotifyOnGetValue(bstrAttributeName, varOriginal,
                                              varCurrentValue, pvarInOutValue);

    hr = S_OK;
done :

// Turn this on to trace in/out parameters of this function (this doesn't need to be in all dbg builds)
#if (0 && DBG) 
    {
        CComVariant v1(varOriginal);
        CComVariant v2(varCurrentValue);
        CComVariant v3(*pvarInOutValue);

        v1.ChangeType(VT_BSTR);
        v2.ChangeType(VT_BSTR);
        v3.ChangeType(VT_BSTR);

        TraceTag((tagError, "CTIMEAnimationBase(%p)::NotifyOnGetValue(Attr=%ls, Orig=%ls, Curr=%ls, Out=%ls)", 
            this, bstrAttributeName, v1.bstrVal, v2.bstrVal, v3.bstrVal));
    }
#endif

    RRETURN(hr);
} // NotifyOnGetValue

///////////////////////////////////////////////////////////////
//  Name: SetInitialState
//
//  Abstract: set an initial internal state for the animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::SetInitialState (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::SetInitialState()",
              this));

    m_bNeedFirstLeftUpdate = true;
    m_bNeedFirstTopUpdate = true;
    m_bNeedFinalLeftUpdate = false;
    m_bNeedFinalTopUpdate = false;
} // SetInitialState

///////////////////////////////////////////////////////////////
//  Name: SetFinalState
//
//  Abstract: set an final internal state for animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::SetFinalState (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::SetFinalState()",
              this));

    m_bNeedFinalLeftUpdate = true;
    m_bNeedFinalTopUpdate = true;
} // SetFinalState


///////////////////////////////////////////////////////////////
//  Name: OnFirstUpdate
//
//  Abstract: save the baseline value of the animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnFirstUpdate (VARIANT *pvarValue)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnFirstUpdate()",
              this));
    
    HRESULT hr = S_OK;
    CComVariant varTemp;

    hr = THR(varTemp.Copy(pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    PutCorrectLeftTopValue(varTemp ,m_pointLast);
    PutCorrectLeftTopValue(varTemp ,m_pointCurrentBaseline);
    PutCorrectLeftTopValue(varTemp, m_ptOffsetParent);

    if (m_bAnimatingLeft)
    {
        VariantCopy(&m_varLeftOrig,pvarValue);
        m_bNeedFirstLeftUpdate = false;
    }
    else
    {
        VariantCopy(&m_varTopOrig,pvarValue);
        m_bNeedFirstTopUpdate = false;
    }
        
done :
    return;
} // OnFirstUpdate

///////////////////////////////////////////////////////////////
//  Name: resetValue
//
//  Abstract: reset to the initial value
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::resetValue (VARIANT *pvarValue)
{
    if (m_varLeftOrig.vt != VT_EMPTY || m_varTopOrig.vt != VT_EMPTY)
    {
        if (m_bAnimatingLeft)
        {
            IGNORE_HR(THR(::VariantCopy(pvarValue, &m_varLeftOrig)));
            PutCorrectLeftTopValue(m_varLeftOrig, m_pointCurrentBaseline);
        }
        else
        {
            IGNORE_HR(THR(::VariantCopy(pvarValue, &m_varTopOrig)));
            PutCorrectLeftTopValue(m_varTopOrig, m_pointCurrentBaseline);
        }
    }
} // resetValue

///////////////////////////////////////////////////////////////
//  Name: resetAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::resetAnimate (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::resetAnimate()",
              this));

    m_pointCurrentBaseline.x = m_pointCurrentBaseline.y = 0.0;
    CTIMEAnimationBase::resetAnimate();
} // resetAnimate

////////////////////////////////////////////////////////////////
//  Name: OnFinalUpdate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnFinalUpdate()",
              this));

    bool bNeedPostprocess = false;

    VariantClear(pvarValue);
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = 0.0f;
    
    if (GetMMBvr().GetProgress() == 0 &&
        NeedFill() &&
        GetAutoReverse())
    {
        if (PATH == m_dataToUse)
        {
            //
            // Get the first point on the path
            // 

            POINTF startPoint = {0.0, 0.0};

            if (m_spPath.p)
            {
                IGNORE_HR(m_spPath->GetPoint(0, &startPoint));
            }
            else
            {
                Assert(false);
            }

            V_R8(pvarValue) = GetCorrectLeftTopValue(startPoint);
        }
        else if (m_dataToUse == VALUES)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pPointValues[0]);
        }
        else if (m_varFrom.vt != VT_EMPTY)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointFROM);
        }

        bNeedPostprocess = true;
    } 
    else if ((GetMMBvr().GetProgress() != 1) &&
             (NeedFill()))
    {
        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else if ((NeedFill()) &&
             (m_dataToUse != NONE))
    {
        bool fDontPostProcess = false;

        GetFinalValue(pvarValue, &fDontPostProcess);

        if (!fDontPostProcess)
        {
            bNeedPostprocess = true;
        }
    }
    else
    {
        // The animation has ended, and we should tell the base class so.
        resetValue(pvarValue); 
        // Indicate that we don't need to perform 
        // the additive work.
        if (!QueryNeedFirstUpdate())
        {
            IGNORE_HR(removeFromComposerSite());
            m_bNeedAnimInit = true;

        }
    }

    if (bNeedPostprocess)
    {
        PostprocessValue(pvarCurrent, pvarValue);
    }
    
    m_bLastSet = true;
done :

    if (m_bAnimatingLeft)
    {
        m_bNeedFinalLeftUpdate = false;
    }
    else
    {
        m_bNeedFinalTopUpdate = false;
    }
} // OnFinalUpdate


///////////////////////////////////////////////////////////////
//  Name: OnBegin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnBegin()",
              this));

    SetInitialState();
    SUPER::OnBegin(dblLocalTime, flags);
    
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: OnEnd
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnEnd(double dblLocalTime)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnEnd()",
              this));

    SetFinalState();
    SUPER::OnEnd(dblLocalTime);
}


///////////////////////////////////////////////////////////////
//  Name: GetAnimationRange
//
//  Abstract: Get the end point of the animation function over the
//            simple duration
//
///////////////////////////////////////////////////////////////
double 
CTIMEMotionAnimation::GetAnimationRange()
{
    double dblReturnVal = 0.0;

    switch (m_dataToUse)
    {
        case PATH:
            {
                if (m_spPath.p)
                {
                    int numPoints = 0;
                    POINTF ptEndPoint = {0.0, 0.0};

                    IGNORE_HR(m_spPath->GetNumPoints(&numPoints));

                    if (0 == numPoints)
                    {
                        goto done;
                    }

                    if (GetAutoReverse())
                    {
                        IGNORE_HR(m_spPath->GetPoint(0, &ptEndPoint));
                    }
                    else
                    {
                        IGNORE_HR(m_spPath->GetPoint(numPoints - 1, &ptEndPoint));
                    }

                    dblReturnVal = GetCorrectLeftTopValue(ptEndPoint);
                }
            }
            break;

        case VALUES:
            {
                if (!m_AnimPropState.fInterpolateValues)
                {
                    goto done;
                }

                if (m_numValues < 1)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pPointValues[0]);
                }
                else
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pPointValues[m_numValues - 1]);
                }
            }
            break;

        case TO:
            {
                if (!m_AnimPropState.fInterpolateTo)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    if (m_bFrom)
                    {
                        if (!m_AnimPropState.fInterpolateFrom)
                        {
                            goto done;
                        }
                    
                        dblReturnVal = GetCorrectLeftTopValue(m_pointFROM);
                    }

                    // For "to" animations (i.e. no "from"), accumulation is disabled, 
                    // so we do not need to handle it.
                }
                else
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pointTO);
                }
            }
            break;

        case BY:
            {
                POINTF ptFrom = {0.0, 0.0};

                if (!m_AnimPropState.fInterpolateBy)
                {
                    goto done;
                }

                if (m_bFrom)
                {
                    if (!m_AnimPropState.fInterpolateFrom)
                    {
                        goto done;
                    }

                    ptFrom = m_pointFROM;
                }

                if (GetAutoReverse())
                {
                    dblReturnVal = GetCorrectLeftTopValue(ptFrom);
                }
                else
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pointBY) + GetCorrectLeftTopValue(ptFrom);
                }
            }
            break;

        default:
            goto done;
    }

done:
    return dblReturnVal;
}


///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculateDiscreteValue (VARIANT *pvarValue)
{
    if (!ConvertToPixels(pvarValue))
    {
        VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
    }

    switch (m_dataToUse)
    {
        case PATH:
            {
                // ISSUE : dilipk: How should we handle MoveTo and KeyTimes?

                //
                // Discrete values are simply the points on the path
                //

                POINTF   newPos = {0.0, 0.0};

                if (m_spPath.p)
                {
                    int curPoint = 0;
                    int numPoints = 0;
                    double dblSegDur = 0.0;
                    double dblSimpTime = 0.0;

                    IGNORE_HR(m_spPath->GetNumPoints(&numPoints));

                    dblSegDur   = GetMMBvr().GetSimpleDur() / (numPoints ? numPoints : 1); 
                    dblSimpTime = GetMMBvr().GetSimpleTime();

                    if (dblSegDur != 0)
                    {
                        curPoint =  (int) (dblSimpTime / dblSegDur);
                    }
                
                    IGNORE_HR(m_spPath->GetPoint(curPoint, &newPos));
                
                }
                else
                {
                    Assert(false);
                }

                V_R8(pvarValue) = GetCorrectLeftTopValue(newPos);
            }
            break;

        case VALUES:
            {
                int curSeg = CalculateCurrentSegment(true);
                V_R8(pvarValue) = GetCorrectLeftTopValue(m_pPointValues[curSeg]);
            }
            break;

        case TO:
            {
                POINTF ptTo;

                if (m_bFrom && (GetMMBvr().GetProgress() < 0.5))
                {
                    ptTo = m_pointFROM;
                }
                else
                {
                    ptTo   = m_pointTO;
                }

                V_R8(pvarValue) = GetCorrectLeftTopValue(ptTo);
            }
            break;

        case BY:
            {
                if (m_bFrom) 
                {
                    if (GetMMBvr().GetProgress() < 0.5)
                    {
                        // use "from"
                        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointFROM);
                    }
                    else
                    {
                        // use "from" + "by"
                        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointBY)  
                                          + GetCorrectLeftTopValue(m_pointFROM);
                    }
                }
                else
                {
                    // use "parent offset" + "by" - the parent offset is
                    // applied during postprocessing.
                    V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointBY); 
                }
            }
            break;

        default:
            goto done;
    }

done:
    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p,%ls)::calculateDiscreteValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculateLinearValue (VARIANT *pvarValue)
{
    double dblProgress = GetMMBvr().GetProgress();
    POINTF ptFrom = m_pointFROM;

    if (!ConvertToPixels(pvarValue))
    {
        VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
    }

    Assert(pvarValue->vt == VT_R8);
    
    if (m_dataToUse == PATH)
    {
        m_pointLast = InterpolatePath();

        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else if (m_dataToUse == VALUES)
    {
        double curProgress;
        int    curSeg;

        curProgress = CalculateProgressValue(false);
        curSeg      = CalculateCurrentSegment(false);

        
        V_R8(pvarValue) = InterpolateValues((double)(GetCorrectLeftTopValue(m_pPointValues[curSeg])), 
                                                (double)(GetCorrectLeftTopValue(m_pPointValues[curSeg+1])),
                                                (double) curProgress); //lint !e736
    }
    else if (TO == m_dataToUse)
    {   
        if (m_FADur)
        {
            double dblFrom = 0;
            double dblTo = GetCorrectLeftTopValue(m_pointTO);
            
            if (m_bFrom)
            {
                dblFrom = GetCorrectLeftTopValue(ptFrom);
            }
            else
            {
                // Handle the case in which a hybrid animation
                // must factor in results from other fragments.
                if (m_bNeedBaselineUpdate)
                {
                    // Offset the new baseline relative to the old.
                    dblFrom = GetCorrectLeftTopValue(m_pointCurrentBaseline);
                }

                // animating TO w/ no from value, and parent's origin :
                // we should animate from our current position, to 
                // the parent's offset specified as the 'to' value.
                if (ORIGIN_PARENT == m_IAOrigin)
                {
                    dblFrom += GetCorrectLeftTopValue(m_ptOffsetParent);
                }
            }

            V_R8(pvarValue) = InterpolateValues(dblFrom, dblTo, dblProgress);
        }
        else
        {
            // Just go to the to Value...
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointTO);
        }
        
    }
    else if (BY == m_dataToUse)
    {
        double dblFrom = 0;

        if (m_bFrom)
        {
            dblFrom = GetCorrectLeftTopValue(ptFrom);
        }

        if (m_FADur)
        {
            V_R8(pvarValue) = InterpolateValues(dblFrom, dblFrom + GetCorrectLeftTopValue(m_pointBY), dblProgress);
        }
        else
        {
            // Just offset by the m_varBy value.
            V_R8(pvarValue) = dblFrom + GetCorrectLeftTopValue(m_pointBY);
        }
    }
    else
    {
        // just bail.
        goto done;
    }
        
done:

    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p, %ls)::calculateLinearValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculateSplineValue (VARIANT *pvarValue)
{
    double dblProgress = GetMMBvr().GetProgress();
    POINTF ptFrom = m_pointFROM;
    
    if (!ConvertToPixels(pvarValue))
    {
        VariantClear(pvarValue);
        pvarValue->vt = VT_R8;
    }

    Assert(pvarValue->vt == VT_R8);
  
    if (m_dataToUse == PATH)
    {
        m_pointLast = InterpolatePath();

        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else if (VALUES == m_dataToUse)
    {
        double curProgress;
        int    curSeg;

        if (NULL == m_pKeySplinePoints)
        {
            // do nothing if we have no SplinePoints and are told to animate with calcmode=spline
            goto done;
        }

        curProgress = CalculateProgressValue(false);
        curSeg      = CalculateCurrentSegment(false);

        curProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg],curProgress);

        V_R8(pvarValue) = InterpolateValues((double)(GetCorrectLeftTopValue(m_pPointValues[curSeg])), 
                                                (double)(GetCorrectLeftTopValue(m_pPointValues[curSeg+1])),
                                                curProgress); //lint !e736
    }
    else if (TO == m_dataToUse)
    {   
        if (m_FADur)
        {
            double dblFrom = 0;
            double dblTo = GetCorrectLeftTopValue(m_pointTO);

            dblProgress = CalculateBezierProgress(m_pKeySplinePoints[0],dblProgress);            
            
            if (m_bFrom)
            {
                dblFrom = GetCorrectLeftTopValue(ptFrom);
            }
            else
            {
                // Handle the case in which a hybrid animation
                // must factor in results from other fragments.
                if (m_bNeedBaselineUpdate)
                {
                    // Offset the new baseline relative to the old.
                    dblFrom = GetCorrectLeftTopValue(m_pointCurrentBaseline);
                }

                // animating TO w/ no from value, and parent's origin :
                // we should animate from our current position, to 
                // the parent's offset specified as the 'to' value.
                if (ORIGIN_PARENT == m_IAOrigin)
                {
                    dblFrom += GetCorrectLeftTopValue(m_ptOffsetParent);
                }
            }

            V_R8(pvarValue) = InterpolateValues(dblFrom, dblTo, dblProgress);
        }
        else
        {
            // Just go to the to Value...
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointTO);
        }
        
    }
    else if (BY == m_dataToUse)
    {
        double dblFrom = 0;

        if (m_bFrom)
        {
            dblFrom = GetCorrectLeftTopValue(ptFrom);
        }
        if (m_FADur)
        {
            dblProgress = CalculateBezierProgress(m_pKeySplinePoints[0],dblProgress);
            V_R8(pvarValue) = InterpolateValues(dblFrom, dblFrom + GetCorrectLeftTopValue(m_pointBY), dblProgress);
        }
        else
        {
            // Just offset by the m_varBy value.
            V_R8(pvarValue) = dblFrom + GetCorrectLeftTopValue(m_pointBY);
        }
    }
    else
    {
        // just bail.
        goto done;
    }
        
done:
    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p, %ls)::calculateSplineValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculatePacedValue (VARIANT *pvarValue)
{
    double dblVal = 0.;
    double dblProgress = GetMMBvr().GetProgress();
    double curDisanceTraveled = 0.0;
    double dblDistance,pDistance;
    int i;

    if (m_dataToUse == PATH)
    {
        //
        // delegate to the smil path object
        //

        POINTF fNewPoint = InterpolatePathPaced();

        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = GetCorrectLeftTopValue(fNewPoint);
    }
    else if (m_dataToUse == VALUES)
    {
        // how much should we have travelled by now ?
        curDisanceTraveled = InterpolateValues(0.0, m_dblTotalDistance, dblProgress);

        // run though and see what segment we should be in.
        i=1;
        dblDistance  =0.0;
        pDistance =0.0;
        do{
            pDistance = dblDistance;
            dblDistance += CalculateDistance(m_pPointValues[i-1],m_pPointValues[i]);
            i++;
        }while(dblDistance < curDisanceTraveled);
        i = (i < 2)?1:i-1;

        // Calculate what percentage of the current segment we are at.
        dblDistance = CalculateDistance(m_pPointValues[i-1],m_pPointValues[i]);
        if (dblDistance == 0)
        {
            goto done;
        }

        dblDistance = (curDisanceTraveled - pDistance)/dblDistance;

        V_R8(pvarValue) = InterpolateValues((double)(GetCorrectLeftTopValue(m_pPointValues[i-1])), 
                                            (double)(GetCorrectLeftTopValue(m_pPointValues[i])),
                                            dblDistance);
        V_VT(pvarValue) = VT_R8;
    }
    else
    {
        IGNORE_HR(calculateLinearValue(pvarValue));
        goto done;
    }

   
   
    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p, %ls)::calculatePacedValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

done:
    return S_OK;
}
   
///////////////////////////////////////////////////////////////
//  Name: CalculateDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEMotionAnimation::CalculateDistance(POINTF a, POINTF b)
{
    float deltaX,deltaY;

    deltaX = a.x - b.x;
    deltaY = a.y - b.y;
    return(sqrt((deltaX*deltaX) + (deltaY*deltaY)));
}


///////////////////////////////////////////////////////////////
//  Name: CalculateTotalDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::CalculateTotalDistance()
{
    int index;
    m_dblTotalDistance = 0;

    if (    (NULL == m_pPointValues)
        ||  (m_numValues < 2))
    {
        goto done;
    }

    for (index=1; index < m_numValues; index++)
    {
         m_dblTotalDistance += CalculateDistance(m_pPointValues[index-1], m_pPointValues[index]);
    }
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: CalculatePointDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEMotionAnimation::CalculatePointDistance(POINTF p1, POINTF p2)
{
    double dX = (p1.x - p2.x);
    double dY = (p1.y - p2.y);
    return sqrt((dX*dX) + (dY*dY));  
}


POINTF 
CTIMEMotionAnimation::InterpolatePathPaced()
{
    POINTF newPos = {0.0, 0.0};
    double dblProgress = 0.0;

    if (!m_spPath)
    {
        Assert(false);
        goto done;
    }

    // get the progress
    dblProgress = GetMMBvr().GetProgress();

    IGNORE_HR(m_spPath->InterpolatePaced(dblProgress, &newPos));

done:
    return newPos;
}


///////////////////////////////////////////////////////////////
//  Name: InterpolatePath
//
//  Abstract: calculates current position on path
//            Used for linear and spline CalcModes.
//            
///////////////////////////////////////////////////////////////
POINTF 
CTIMEMotionAnimation::InterpolatePath()
{
    HRESULT hr = E_FAIL;
    POINTF newPos = {0.0, 0.0};
    double dblProgress;
    bool fValid = false;
    int curSeg = 0;
    double curProgress = 0.0;

    if (!m_spPath)
    {
        Assert(false);
        goto done;
    }

    // get the progress
    dblProgress = GetMMBvr().GetProgress();

    // use keytimes if any
    if (m_pdblKeyTimes)
    {
        // get the segment we are in 
        if (dblProgress > 0)
        {
            //
            // ISSUE dilipk: should use binary search here (bug #14225, ie6)
            //

            // find the current segment
            for (int i = 1; i < m_numKeyTimes; i++)
            {
                if (dblProgress <= m_pdblKeyTimes[i])
                {
                    curSeg = i - 1;
                    break;
                }
            }

            // get the normalized linear progress in the segment
            curProgress = (dblProgress - m_pdblKeyTimes[curSeg]) / 
                          (m_pdblKeyTimes[curSeg + 1] - m_pdblKeyTimes[curSeg]);
        }
        else
        {
            curProgress = dblProgress;
        }

        // if necessary, apply bezier curve to progress
        if (    (m_IACalcMode == CALCMODE_SPLINE) 
            &&  (curSeg < m_numKeySplines))
        {
            curProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg], curProgress);
        }
    }
    else
    {
        // divvy up the time equally among segments

        // get the current segment and progress in that segment
        hr = THR(m_spPath->GetSegmentProgress(dblProgress, &curSeg, &curProgress));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // ask smil path object to interpolate this segment
    IGNORE_HR(m_spPath->InterpolateSegment(curSeg, curProgress, &newPos));

done:
    return newPos;
}


///////////////////////////////////////////////////////////////
//  Name: parsePair
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::ParsePair(VARIANT val, POINTF *outPT)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::parsePair()",
              this));
   
    HRESULT hr = E_FAIL;
    OLECHAR *sString = NULL;
    OLECHAR sTemp[INTERNET_MAX_URL_LENGTH];
    OLECHAR sTemp2[INTERNET_MAX_URL_LENGTH];
    CPtrAry<STRING_TOKEN*> aryTokens;
                   
    // need to parse out the top,left values.....
    if (val.vt != VT_BSTR)
    {
        hr = VariantChangeTypeEx(&val, &val, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            goto done;
        }   
    }

    sString = CopyString(val.bstrVal);
    if (sString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    hr = ::StringToTokens(sString, s_cPSTR_COMMA_SEPARATOR, &aryTokens);
    if (FAILED(hr) ||
        aryTokens.Size() != 2) // We must have a pair..
    {
        hr = E_FAIL;
        goto done;
    }

    if (   ((aryTokens.Item(0)->uLength + 1) >= INTERNET_MAX_URL_LENGTH)
        || ((aryTokens.Item(1)->uLength + 1) >= INTERNET_MAX_URL_LENGTH)
       )
    {
        hr = E_FAIL;
        goto done;
    }

    StrCpyNW(sTemp, sString+aryTokens.Item(0)->uIndex,aryTokens.Item(0)->uLength + 1);
    StrCpyNW(sTemp2,sString+aryTokens.Item(1)->uIndex,aryTokens.Item(1)->uLength + 1);

    {
        CComVariant tVar;
        tVar.vt      = VT_BSTR;
        tVar.bstrVal = SysAllocString(sTemp);
        if (!ConvertToPixels(&tVar))
        {
            hr = E_FAIL;
            goto done;
        }
        outPT->x = V_R8(&tVar);

        tVar.Clear();
        tVar.vt      = VT_BSTR;
        tVar.bstrVal = SysAllocString(sTemp2);
        if (!ConvertToPixels(&tVar))
        {
            hr = E_FAIL;
            goto done;
        }
        outPT->y = V_R8(&tVar);
    }

done:
    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    if (sString != NULL)
    {
        delete [] sString;
    }
        
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: GetCorrectLeftTopValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
float
CTIMEMotionAnimation::GetCorrectLeftTopValue(POINTF fPoint)
{
    if (m_bAnimatingLeft)
    {
        return fPoint.x;
    }

    return fPoint.y;
}

///////////////////////////////////////////////////////////////
//  Name: PutCorrectLeftTopValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::PutCorrectLeftTopValue(VARIANT pVar ,POINTF &fPointDest)
{
    if (!ConvertToPixels(&pVar))
    {
        goto done;
    }
       
    if (m_bAnimatingLeft)
    {
        fPointDest.x =  static_cast<float>(V_R8(&pVar));
    }
    else
    {
        fPointDest.y =  static_cast<float>(V_R8(&pVar));
    }
    
done:
    return;
}

void
CTIMEMotionAnimation::PutCorrectLeftTopValue(double val ,POINTF &fPointDest)
{     
    if (m_bAnimatingLeft)
    {
        fPointDest.x =  static_cast<float>(val);
    }
    else
    {
        fPointDest.y =  static_cast<float>(val);
    }
}

void
CTIMEMotionAnimation::PutCorrectLeftTopValue(POINTF fPointSrc ,POINTF &fPointDest)
{     
    if (m_bAnimatingLeft)
    {
        fPointDest.x =  fPointSrc.x;
    }
    else
    {
        fPointDest.y =  fPointSrc.y;
    }
}


void
CTIMEMotionAnimation::GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess)
{
    *pfDontPostProcess = false;

    ::VariantClear(pvarValue);
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = 0.0;
    if (GetAutoReverse())
    {
        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);

        *pfDontPostProcess = true;
    }
    else
    {
        if (PATH == m_dataToUse)
        {
            // if this is endholding then return last point
            // else return the first point 

            //
            // Get the last point on the path
            //

            POINTF endPoint = {0.0, 0.0};

            if (m_spPath.p)
            {
                int numPoints = 0;

                IGNORE_HR(m_spPath->GetNumPoints(&numPoints));
                IGNORE_HR(m_spPath->GetPoint(numPoints-1, &endPoint));
            }
            else
            {
                Assert(false);
            }

            V_R8(pvarValue) = GetCorrectLeftTopValue(endPoint);
        }        
        else if (VALUES == m_dataToUse)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pPointValues[m_numValues-1]);
        }
        else if (TO == m_dataToUse)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointTO);
        }
        else if (BY == m_dataToUse)
        {
            double dblFrom = 0;

            if (m_bFrom)
            {
                dblFrom = GetCorrectLeftTopValue(m_pointFROM);
            }

            V_R8(pvarValue) = dblFrom + GetCorrectLeftTopValue(m_pointBY);
        }
    }

done:
    return;

}


///////////////////////////////////////////////////////////////
//  Name: ValidateState, CTIMEAnimationBase
//
//  Abstract: Checks state of properties. Determines whether:
//              1. Animation should be disabled
//              2. CalcMode should be forced to "discrete"
//            
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::ValidateState()
{
    bool fIsValid = false;

    // validate base props
    CTIMEAnimationBase::ValidateState();

    // if base props are invalid then our state is invalid
    if (DisableAnimation())
    {
        goto done;
    }

    // Validate path
    if (PATH == m_dataToUse)
    {
        bool fCalcModeSpline = (CALCMODE_SPLINE == m_IACalcMode);
        bool fCalcModeLinear = (CALCMODE_LINEAR == m_IACalcMode);
        int  iNumSeg         = 0;
        bool fPathValid      = false;

        if (!m_spPath)
        {
            goto done;
        }

        IGNORE_HR(m_spPath->IsValid(&fPathValid));

        if (!fPathValid)
        {
            goto done;
        }

        IGNORE_HR(m_spPath->GetNumSeg(&iNumSeg));

        if (0 == iNumSeg)
        {
            goto done;
        }

        // validate keyTimes
        if (fCalcModeSpline || fCalcModeLinear)
        {
            // base class has already found keyTimes, keySplines and CalcModeSpline to be valid
            // so no need to check that here

            if (m_pdblKeyTimes)
            {
                // number of segments in keyTimes should equal
                // number of segments in path
                if (iNumSeg != (m_numKeyTimes - 1))
                {
                    goto done;
                }
            }
        }
    }

    fIsValid = true;
done:
    m_AnimPropState.fDisableAnimation = !(fIsValid);
} // ValidateState
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animset.cpp ===
// *******************************************************************************
// *
// * Copyright (c) 1998 Microsoft Corporation
// *
// * File: animset.cpp
// *
// * Abstract: Simple animation of Elements
// *
// *
// *
// *******************************************************************************

#include "headers.h"
#include "animset.h"
#include "colorutil.h"


// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagSetElementValue, "MSTIME", "CTIMESetAnimation composition callbacks")

#define SUPER CTIMEAnimationBase

///////////////////////////////////////////////////////////////
//  Name: CTIMESetAnimation
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMESetAnimation::CTIMESetAnimation()
{
    
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMESetAnimation
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMESetAnimation::~CTIMESetAnimation()
{
    
} 


///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMESetAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    HRESULT hr = S_OK;
   
    hr = THR(SUPER::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    
   
    // Set the Caclmode to discrete since that is all that set supports
    // Using InternalSet instead of '=', to prevent attribute from being persisted
    m_IACalcMode.InternalSet(CALCMODE_DISCRETE);
  
done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_calcmode
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMESetAnimation::get_calcmode(BSTR * calcmode)
{
    HRESULT hr = S_OK;
    CHECK_RETURN_NULL(calcmode);

    *calcmode = SysAllocString(WZ_CALCMODE_DISCRETE);
    if (NULL == *calcmode)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::calculateDiscreteValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (m_varDOMTo.vt != VT_EMPTY)
    {
        CComVariant svarTo;

        hr = svarTo.Copy(&m_varDOMTo);
        if (FAILED(hr))
        {
            goto done;
        }

        // We need to make sure that the type to be set is the same
        // as the original value.
        hr = VariantChangeTypeEx(&svarTo, &svarTo, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, V_VT(&m_varBaseline));
        if (!FAILED(hr))
        {
            if (IsTargetVML())
            {
                // We are trying to set this on a VML target.  So, we are going to 
                // see if what we have is a BSTR and if so if it also matches a value in our colorTable
                // if it does mactch then we are going to use the #RRGGBB value instead.
                CComVariant varRRGGBB;
               
                hr = RGBStringColorLookup(&m_varTo, &varRRGGBB);     
                if (SUCCEEDED(hr))
                {
                     hr = svarTo.Copy(&varRRGGBB);
                }
            }
            hr = THR(::VariantCopy(pvarValue, &svarTo));
        }
#if DBG
        if (VT_BSTR == V_VT(pvarValue))
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is %ls",
                      this, m_SAAttribute, V_BSTR(pvarValue)));
        }
        else if (VT_R4 == V_VT(pvarValue))
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is %f",
                      this, m_SAAttribute, V_R4(pvarValue)));
        }
        else if (VT_R8 == V_VT(pvarValue))
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is %lf",
                      this, m_SAAttribute, V_R8(pvarValue)));
        }
        else 
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is variant of type %X",
                      this, m_SAAttribute, V_VT(pvarValue)));
        }
#endif

    
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::calculateLinearValue(VARIANT *pvarValue)
{
    return CTIMESetAnimation::calculateDiscreteValue(pvarValue);
}

///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::calculateSplineValue(VARIANT *pvarValue)
{
    return CTIMESetAnimation::calculateDiscreteValue(pvarValue);   
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMESetAnimation::calculatePacedValue(VARIANT *pvarValue)
{
    return CTIMESetAnimation::calculateDiscreteValue(pvarValue);
}

///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::CanonicalizeValue (VARIANT *pvarOriginal, VARTYPE *pvtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UncanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::UncanonicalizeValue (VARIANT *pvarOriginal, VARTYPE vtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // UncanonicalizeValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animfilter.h ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\src\animfilter.h
//
//  Classes:    CTIMEFilterAnimation
//
//  History:
//  2000/08/24  mcalkins    Created.
//
//------------------------------------------------------------------------------
#pragma once

#ifndef _ANIMFILTER_H
#define _ANIMFILTER_H

#include "colorutil.h"
#include "animbase.h"

//+-----------------------------------------------------------------------------
//
// CTIMEFilterAnimation
//
//------------------------------------------------------------------------------
class CTIMEFilterAnimation : 
    public CComCoClass<CTIMEFilterAnimation, &CLSID_TIMEFilterAnimation>,
    public CTIMEAnimationBase,
    public IFilterAnimationInfo
{
public:

    CTIMEFilterAnimation();
    virtual ~CTIMEFilterAnimation();

    DECLARE_AGGREGATABLE(CTIMEFilterAnimation);
    DECLARE_REGISTRY(CLSID_TIMEFilterAnimation,
                     LIBID __T(".TIMEFilterAnimation.1"),
                     LIBID __T(".TIMEFilterAnimation"),
                     0,
                     THREADFLAGS_BOTH);

    //
    // IElementBehavior
    //
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    //
    // IFilterAnimationInfo
    //
    STDMETHOD(GetParameters)    (VARIANT *pvarParams);

    //
    // CBaseBvr
    //
    STDMETHOD(OnPropertiesLoaded)(void);

    //
    // CTIMEElementBase
    //
    void OnLoad (void);

    //
    // ITIMEAnimationElement
    //
    STDMETHOD(get_type)(BSTR *pbstrType);
    STDMETHOD(put_type)(BSTR bstrType);

    STDMETHOD(get_subType)(BSTR *pbstrSubtype);
    STDMETHOD(put_subType)(BSTR bstrSubtype);

    STDMETHOD(get_mode)(BSTR *pbstrMode);
    STDMETHOD(put_mode)(BSTR bstrMode);

    STDMETHOD(get_fadeColor)(BSTR *pbstrFadeColor);
    STDMETHOD(put_fadeColor)(BSTR bstrFadeColor);

    STUB_INVALID_ATTRIBUTE(BSTR, attributeName)

    //
    // QI Map
    //
    BEGIN_COM_MAP(CTIMEFilterAnimation)
        COM_INTERFACE_ENTRY(IFilterAnimationInfo)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEAnimationBase)
    END_COM_MAP();

protected :

    STDMETHOD(putStringAttribute)(DISPID dispidProperty, 
                                  BSTR bstrStringAttr, 
                                  CAttr<LPWSTR> & refStringAttr, 
                                  LPCWSTR wzDefaultValue);
    STDMETHOD(getStringAttribute)(const CAttr<LPWSTR> & refStringAttr, 
                                  BSTR *pbstrStringAttr);

    HRESULT     AssembleFragmentKey     (void);
    void        EnsureAnimationFunction (void);
    bool        RangeCheckValue (const VARIANT *pvarValueItem);
    virtual HRESULT addToComposerSite (IHTMLElement2 *pielemTarget);    
    virtual bool ValidateByValue (const VARIANT *pvarBy);
    virtual bool ValidateValueListItem (const VARIANT *pvarValueItem);

private:

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEFilterAnimation"); }
#endif

}; // CTIMEFilterAnimation


#endif // _ANIMFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\colorcomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcolor.h"
#include "animcomp.h"
#include "colorcomp.h"

DeclareTag(tagAnimationColorComposer, "SMIL Animation", 
           "CAnimationColorComposer methods");

DeclareTag(tagAnimationColorComposerProcess, "SMIL Animation", 
           "CAnimationColorComposer pre/post process methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT 
CAnimationColorComposer::Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                                 IAnimationComposer **ppiComp)
{
    HRESULT hr;

    CComObject<CAnimationColorComposer> *pNew = NULL;
    hr = THR(CComObject<CAnimationColorComposer>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiComp)));
    if (FAILED(hr))
    {
        pNew->Release();
        hr = E_UNEXPECTED;
        goto done;
    }

    Assert(NULL != (*ppiComp));

    hr = (*ppiComp)->ComposerInit(pidispHostElem, bstrAttributeName);
    if (FAILED(hr))
    {
        (*ppiComp)->Release();
        *ppiComp = NULL;
        goto done;
    }

    hr = S_OK;
done :

    RRETURN3(hr, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationColorComposer::Create

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::CAnimationColorComposer
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationColorComposer::CAnimationColorComposer (void)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::CAnimationColorComposer()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::~CAnimationColorComposer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationColorComposer::~CAnimationColorComposer (void)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::~CAnimationColorComposer()",
              this));
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::PreprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationColorComposer::PreprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::PreprocessCompositionValue()",
              this));

    HRESULT hr;
    CComVariant varNew;

    if ((VT_ARRAY | VT_R8) == V_VT(pvarValue))
    {
        hr = S_OK;
        goto done;
    }

    if (VT_BSTR != V_VT(pvarValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // If there's no proper value, clear the empty
    // BSTR and don't try to convert it to a color definition.
    // This can happen when there is no initial value specified.
    if (!IsColorUninitialized(V_BSTR(pvarValue)))   
    {
        hr = THR(RGBVariantStringToRGBVariantVectorInPlace(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_bInitialComposition)
    {
        hr = THR(::VariantCopy(&m_VarInitValue, pvarValue));
        if (FAILED(hr))
        {
            goto done;
        } 
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // PreprocessCompositionValue

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::PostprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationColorComposer::PostprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::PostprocessCompositionValue()",
              this));

    HRESULT hr;
    CComVariant varNew;

    if (VT_BSTR == V_VT(pvarValue))
    {
        hr = S_OK;
        goto done;
    }

    hr = RGBVariantVectorToRGBVariantString (pvarValue, &varNew);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::VariantCopy(pvarValue, &varNew));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationColorComposerProcess,
              "CAnimationColorComposer(%lx)::PostprocessCompositionValue() value is %ls",
              this, V_BSTR(pvarValue)));

    hr = S_OK;
done :
    RRETURN(hr);
} // PostprocessCompositionValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animutil.h ===
static const LPWSTR PX   = L"px";

#define HORIZ   true
#define VERT    false

typedef struct _VALUE_PAIR
{
    const WCHAR *wzName;
    bool         bValue;
} VALUE_PAIR;

// The info in the VALUE_PAIR is runtime-property and then either a vertical or horizontal depending on the 
// typeof attribute it is.

const VALUE_PAIR 
rgPropOr[] =
{
    { (L"backgroundPositionX"),     HORIZ  },
    { (L"backgroundPositionY"),     VERT   },
    { (L"borderBottomWidth"),       VERT   },
    { (L"borderLeftWidth"),         HORIZ  },
    { (L"borderRightWidth"),        HORIZ  },
    { (L"borderTopWidth"),          VERT   },
    { (L"bottom"),                  VERT   },
    { (L"height"),                  VERT   },
    { (L"left"),                    HORIZ  },
    { (L"top"),                     VERT   },
    { (L"letterSpacing"),           HORIZ  },
    { (L"lineHeight"),              VERT   },
    { (L"marginBottom"),            VERT   },
    { (L"marginLeft"),              HORIZ  },
    { (L"marginRight"),             HORIZ  },
    { (L"marginTop"),               VERT   },
    { (L"overflowX"),               HORIZ  },
    { (L"overflowY"),               VERT   },
    { (L"pixelBottom"),             VERT   },
    { (L"pixelHeight"),             VERT   },
    { (L"pixelLeft"),               HORIZ  },
    { (L"pixelRight"),              HORIZ  },
    { (L"pixelTop"),                VERT   },
    { (L"pixelWidth"),              HORIZ  },
    { (L"posBottom"),               VERT   },
    { (L"posHeight"),               VERT   },
    { (L"posLeft"),                 HORIZ  },
    { (L"posRight"),                HORIZ  },
    { (L"posTop"),                  VERT   },
    { (L"posWidth"),                HORIZ  },
    { (L"right"),                   HORIZ  },
    { (L"textIndent"),              HORIZ  },
    { (L"width"),                   HORIZ  }
}; // rgPropOr[]

#define SIZE_OF_VALUE_TABLE (sizeof(rgPropOr) / sizeof(VALUE_PAIR))


typedef struct _CONVERSION_PAIR
{
    WCHAR  *wzName;
    double  dValue;
} CONVERSION_PAIR;


const CONVERSION_PAIR 
rgPixelConv[] =
{
    // type , convertion to inches
    { (L"in"),   1.00  },
    { (L"cm"),   2.54  },
    { (L"mm"),  25.40  },
    { (L"pt"),  72.00  },
    { (L"pc"),   6.00  }
}; // 

#define SIZE_OF_CONVERSION_TABLE (sizeof(rgPixelConv) / sizeof(CONVERSION_PAIR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\animset.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animset.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMSET_H
#define _ANIMSET_H

#include "animbase.h"


//+-------------------------------------------------------------------------------------
//
// CTIMESetAnimation
//
//--------------------------------------------------------------------------------------

class CTIMESetAnimation : 
    public CComCoClass<CTIMESetAnimation, &CLSID_TIMESetAnimation>,
    public CTIMEAnimationBase
{

public:
    CTIMESetAnimation();
    virtual ~CTIMESetAnimation();

    DECLARE_AGGREGATABLE(CTIMESetAnimation);
    DECLARE_REGISTRY(CLSID_TIMESetAnimation,
                     LIBID __T(".TIMESetAnimation.1"),
                     LIBID __T(".TIMESetAnimation"),
                     0,
                     THREADFLAGS_BOTH);
    
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    STDMETHOD(get_calcmode)(BSTR * calcmode);

    STUB_INVALID_ATTRIBUTE(BSTR, additive)
    STUB_INVALID_ATTRIBUTE(BSTR, accumulate)
    STUB_INVALID_ATTRIBUTE(VARIANT, by)
    STUB_INVALID_ATTRIBUTE(VARIANT, from)
    STUB_INVALID_ATTRIBUTE(BSTR, keySplines)
    STUB_INVALID_ATTRIBUTE(BSTR, keyTimes)
    STUB_INVALID_ATTRIBUTE(BSTR, origin)
    STUB_INVALID_ATTRIBUTE(BSTR, path)
    STUB_INVALID_ATTRIBUTE(BSTR, values)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

protected:

    virtual HRESULT CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld);
    virtual HRESULT UncanonicalizeValue (VARIANT *pvarValue, VARTYPE vtOld);

private:

    HRESULT calculateDiscreteValue(VARIANT *pvarValue);
    HRESULT calculateLinearValue(VARIANT *pvarValue);
    HRESULT calculateSplineValue(VARIANT *pvarValue);
    HRESULT calculatePacedValue(VARIANT *pvarValue);
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMESetAnimation"); }
#endif



}; // CTIMESetAnimation


#endif /* _ANIMSET_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\colorcomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Color Animation Composer.

*******************************************************************************/

#pragma once

#ifndef _COLORCOMP_H
#define _COLORCOMP_H

class __declspec(uuid("C6E2F3CE-B548-442d-9958-7C433C31B93B"))
ATL_NO_VTABLE CAnimationColorComposer
    : public CComCoClass<CAnimationColorComposer, &__uuidof(CAnimationColorComposer)>,
      public CAnimationComposerBase
{

  public:

    CAnimationColorComposer (void);
    virtual ~CAnimationColorComposer (void);

    DECLARE_NOT_AGGREGATABLE(CAnimationColorComposer)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationColorComposer"); }
#endif

    static HRESULT Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                           IAnimationComposer **ppiComp);

    // These methods convert the animated value from its native format
    // to the composed format and back again.  This allows us to animate
    // color out of gamut.
    STDMETHOD(PreprocessCompositionValue) (VARIANT *pvarValue);
    STDMETHOD(PostprocessCompositionValue) (VARIANT *pvarValue);

  protected :

};

#endif /* _COLORCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\compfact.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Factory Implementation

*******************************************************************************/


#include "headers.h"
#include "tokens.h"
#include "compfact.h"
#include "animcomp.h"
#include "colorcomp.h"
#include "filtercomp.h"
#include "defcomp.h"

DeclareTag(tagAnimationComposerFactory, "SMIL Animation", 
           "CAnimationComposerFactory methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CAnimationComposerFactory
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerFactory::CAnimationComposerFactory (void)
{
} // CAnimationComposerFactory::CAnimationComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::~CAnimationComposerFactory
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerFactory::~CAnimationComposerFactory (void)
{
} // CAnimationComposerFactory::~CAnimationComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CreateColorComposer
//
//  Overview:  Build the color composer
//
//  Arguments: out param for the composer
//
//  Returns:   S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerFactory::CreateColorComposer (IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory::CreateColorComposer()"));

    HRESULT hr;

    CComObject<CAnimationColorComposer> *pNew;
    CComObject<CAnimationColorComposer>::CreateInstance(&pNew);

    if (NULL == pNew)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiAnimationComposer)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CreateColorComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CreateTransitionComposer
//
//  Overview:  Build the transition composer
//
//  Arguments: out param for the composer
//
//  Returns:   S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerFactory::CreateTransitionComposer (IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory::CreateTransitionComposer()"));

    HRESULT hr;

    CComObject<CAnimationFilterComposer> *pNew;
    CComObject<CAnimationFilterComposer>::CreateInstance(&pNew);

    if (NULL == pNew)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiAnimationComposer)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CreateColorComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CreateDefaultComposer
//
//  Overview:  Build the default composer
//
//  Arguments: out param for the composer
//
//  Returns:   S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerFactory::CreateDefaultComposer (IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory(%lx)::CreateDefaultComposer()"));

    HRESULT hr;

    CComObject<CAnimationComposer> *pNew;
    CComObject<CAnimationComposer>::CreateInstance(&pNew);

    if (NULL == pNew)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiAnimationComposer)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CreateDefaultComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::FindComposer
//
//  Overview:  Build the default composer
//
//  Arguments: the name of attribute that the composer will animate, out param for the composer
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerFactory::FindComposer (IDispatch *pidispElement, BSTR bstrAttributeName, 
                                         IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory(%lx)::FindComposer()",
              this));

    HRESULT hr;

    if ((NULL == pidispElement) || (NULL == bstrAttributeName) || 
        (NULL == ppiAnimationComposer))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // Sniff the fragment element's tag name for the proper composer.
    {
        CComPtr<IHTMLElement> spElem;
        CComBSTR bstrTag;

        hr = THR(pidispElement->QueryInterface(IID_TO_PPV(IHTMLElement, &spElem)));
        if (FAILED(hr))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        hr = THR(spElem->get_tagName(&bstrTag));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (0 == StrCmpIW(bstrTag, WZ_COLORANIM))
        {
            hr = CAnimationComposerFactory::CreateColorComposer(ppiAnimationComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else if (0 == StrCmpIW(bstrTag, WZ_TRANSITIONFILTER))
        {
            hr = CAnimationComposerFactory::CreateTransitionComposer(ppiAnimationComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            hr = CAnimationComposerFactory::CreateDefaultComposer(ppiAnimationComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CAnimationComposerFactory::FindComposer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\colorutil.cpp ===
// Colorutil.cpp
//

#include "headers.h"
#include "tokens.h"
#include "colorutil.h"

#define RGB_STRING_LENGTH           (7)
#define RGB_STRING_LENGTH2          (4)
#define MAX_COLOR_STRING_LENGTH     (0x10)

const double PERCEPTABLE_COLOR_ERROR = 0.001;

typedef struct _COLORVALUE_PAIR
{
    const WCHAR *wzName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { (L"aliceblue"),             0x01f0f8ff },
    { (L"antiquewhite"),          0x02faebd7 },
    { (L"aqua"),                  0x0300ffff },
    { (L"aquamarine"),            0x047fffd4 },
    { (L"azure"),                 0x05f0ffff },
    { (L"beige"),                 0x06f5f5dc },
    { (L"bisque"),                0x07ffe4c4 },
    { (L"black"),                 0x08000000 },
    { (L"blanchedalmond"),        0x09ffebcd },
    { (L"blue"),                  0x0a0000ff },
    { (L"blueviolet"),            0x0b8a2be2 },
    { (L"brown"),                 0x0ca52a2a },
    { (L"burlywood"),             0x0ddeb887 },
    { (L"cadetblue"),             0x0e5f9ea0 },
    { (L"chartreuse"),            0x0f7fff00 },
    { (L"chocolate"),             0x10d2691e },
    { (L"coral"),                 0x11ff7f50 },
    { (L"cornflowerblue"),        0x126495ed },
    { (L"cornsilk"),              0x13fff8dc },
    { (L"crimson"),               0x14dc143c },
    { (L"cyan"),                  0x1500ffff },
    { (L"darkblue"),              0x1600008b },
    { (L"darkcyan"),              0x17008b8b },
    { (L"darkgoldenrod"),         0x18b8860b },
    { (L"darkgray"),              0x19a9a9a9 },
    { (L"darkgreen"),             0x1a006400 },
    { (L"darkkhaki"),             0x1bbdb76b },
    { (L"darkmagenta"),           0x1c8b008b },
    { (L"darkolivegreen"),        0x1d556b2f },
    { (L"darkorange"),            0x1eff8c00 },
    { (L"darkorchid"),            0x1f9932cc },
    { (L"darkred"),               0x208b0000 },
    { (L"darksalmon"),            0x21e9967a },
    { (L"darkseagreen"),          0x228fbc8f },
    { (L"darkslateblue"),         0x23483d8b },
    { (L"darkslategray"),         0x242f4f4f },
    { (L"darkturquoise"),         0x2500ced1 },
    { (L"darkviolet"),            0x269400d3 },
    { (L"deeppink"),              0x27ff1493 },
    { (L"deepskyblue"),           0x2800bfff },
    { (L"dimgray"),               0x29696969 },
    { (L"dodgerblue"),            0x2a1e90ff },
    { (L"firebrick"),             0x2bb22222 },
    { (L"floralwhite"),           0x2cfffaf0 },
    { (L"forestgreen"),           0x2d228b22 },
    { (L"fuchsia"),               0x2eff00ff },
    { (L"gainsboro"),             0x2fdcdcdc },
    { (L"ghostwhite"),            0x30f8f8ff },
    { (L"gold"),                  0x31ffd700 },
    { (L"goldenrod"),             0x32daa520 },
    { (L"gray"),                  0x33808080 },
    { (L"green"),                 0x34008000 },
    { (L"greenyellow"),           0x35adff2f },
    { (L"honeydew"),              0x36f0fff0 },
    { (L"hotpink"),               0x37ff69b4 },
    { (L"indianred"),             0x38cd5c5c },
    { (L"indigo"),                0x394b0082 },
    { (L"ivory"),                 0x3afffff0 },
    { (L"khaki"),                 0x3bf0e68c },
    { (L"lavender"),              0x3ce6e6fa },
    { (L"lavenderblush"),         0x3dfff0f5 },
    { (L"lawngreen"),             0x3e7cfc00 },
    { (L"lemonchiffon"),          0x3ffffacd },
    { (L"lightblue"),             0x40add8e6 },
    { (L"lightcoral"),            0x41f08080 },
    { (L"lightcyan"),             0x42e0ffff },
    { (L"lightgoldenrodyellow"),  0x43fafad2 },
    { (L"lightgreen"),            0x4490ee90 },
    { (L"lightgrey"),             0x45d3d3d3 },
    { (L"lightpink"),             0x46ffb6c1 },
    { (L"lightsalmon"),           0x47ffa07a },
    { (L"lightseagreen"),         0x4820b2aa },
    { (L"lightskyblue"),          0x4987cefa },
    { (L"lightslategray"),        0x4a778899 },
    { (L"lightsteelblue"),        0x4bb0c4de },
    { (L"lightyellow"),           0x4cffffe0 },
    { (L"lime"),                  0x4d00ff00 },
    { (L"limegreen"),             0x4e32cd32 },
    { (L"linen"),                 0x4ffaf0e6 },
    { (L"magenta"),               0x50ff00ff },
    { (L"maroon"),                0x51800000 },
    { (L"mediumaquamarine"),      0x5266cdaa },
    { (L"mediumblue"),            0x530000cd },
    { (L"mediumorchid"),          0x54ba55d3 },
    { (L"mediumpurple"),          0x559370db },
    { (L"mediumseagreen"),        0x563cb371 },
    { (L"mediumslateblue"),       0x577b68ee },
    { (L"mediumspringgreen"),     0x5800fa9a },
    { (L"mediumturquoise"),       0x5948d1cc },
    { (L"mediumvioletred"),       0x5ac71585 },
    { (L"midnightblue"),          0x5b191970 },
    { (L"mintcream"),             0x5cf5fffa },
    { (L"mistyrose"),             0x5dffe4e1 },
    { (L"moccasin"),              0x5effe4b5 },
    { (L"navajowhite"),           0x5fffdead },
    { (L"navy"),                  0x60000080 },
    { (L"oldlace"),               0x61fdf5e6 },
    { (L"olive"),                 0x62808000 },
    { (L"olivedrab"),             0x636b8e23 },
    { (L"orange"),                0x64ffa500 },
    { (L"orangered"),             0x65ff4500 },
    { (L"orchid"),                0x66da70d6 },
    { (L"palegoldenrod"),         0x67eee8aa },
    { (L"palegreen"),             0x6898fb98 },
    { (L"paleturquoise"),         0x69afeeee },
    { (L"palevioletred"),         0x6adb7093 },
    { (L"papayawhip"),            0x6bffefd5 },
    { (L"peachpuff"),             0x6cffdab9 },
    { (L"peru"),                  0x6dcd853f },
    { (L"pink"),                  0x6effc0cb },
    { (L"plum"),                  0x6fdda0dd },
    { (L"powderblue"),            0x70b0e0e6 },
    { (L"purple"),                0x71800080 },
    { (L"red"),                   0x72ff0000 },
    { (L"rosybrown"),             0x73bc8f8f },
    { (L"royalblue"),             0x744169e1 },
    { (L"saddlebrown"),           0x758b4513 },
    { (L"salmon"),                0x76fa8072 },
    { (L"sandybrown"),            0x77f4a460 },
    { (L"seagreen"),              0x782e8b57 },
    { (L"seashell"),              0x79fff5ee },
    { (L"sienna"),                0x7aa0522d },
    { (L"silver"),                0x7bc0c0c0 },
    { (L"skyblue"),               0x7c87ceeb },
    { (L"slateblue"),             0x7d6a5acd },
    { (L"slategray"),             0x7e708090 },
    { (L"snow"),                  0x7ffffafa },
    { (L"springgreen"),           0x8000ff7f },
    { (L"steelblue"),             0x814682b4 },
    { (L"tan"),                   0x82d2b48c },
    { (L"teal"),                  0x83008080 },
    { (L"thistle"),               0x84d8bfd8 },
    { (L"tomato"),                0x85ff6347 },
    { (L"turquoise"),             0x8640e0d0 },
    { (L"violet"),                0x87ee82ee },
    { (L"wheat"),                 0x88f5deb3 },
    { (L"white"),                 0x89ffffff },
    { (L"whitesmoke"),            0x8af5f5f5 },
    { (L"yellow"),                0x8bffff00 },
    { (L"yellowgreen"),           0x8c9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))

///////////////////////////////////////////////////////////////
//  Name: CompareColorValuePairs
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
static int __cdecl
CompareColorValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((COLORVALUE_PAIR*)pv1)->wzName,
                    ((COLORVALUE_PAIR*)pv2)->wzName);
} 

///////////////////////////////////////////////////////////////
//  Name: GetDWORDColorFromString
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
DWORD
GetDWORDColorFromString (LPCWSTR wzColorValue)
{
    DWORD dwRet;
    WCHAR wzTempColorValue[RGB_STRING_LENGTH + 1] = {0};
    if (0 == lstrlenW(wzColorValue))
        return PROPERTY_INVALIDCOLOR;

    // first check if this string is possibly a color by name
    // by checking the first character for '#'
    if (wzColorValue[0] != L'#')
    {
        // check if it is a string named color
        COLORVALUE_PAIR ColorName;
        ColorName.wzName = wzColorValue;

        COLORVALUE_PAIR * pColorPair = (COLORVALUE_PAIR*)bsearch(&ColorName,
                                              rgColorNames,
                                              SIZE_OF_COLOR_TABLE,
                                              sizeof(COLORVALUE_PAIR),
                                              CompareColorValuePairsByName);

        if (NULL == pColorPair)
            return PROPERTY_INVALIDCOLOR;
        else
            return pColorPair->dwValue;
    }
    if (lstrlenW(wzColorValue) != RGB_STRING_LENGTH)
    {
        if (lstrlenW(wzColorValue) != RGB_STRING_LENGTH2) //this is the case of #xyz format which needs to become #xyz
        {
            return PROPERTY_INVALIDCOLOR;
        }
        else
        {
            wzTempColorValue[0] = wzColorValue[0];
            for (int i = 1; i < RGB_STRING_LENGTH2; i++)
            {
                wzTempColorValue[i * 2 - 1] = wzColorValue[i];
                wzTempColorValue[i * 2] = wzColorValue[i];
            }
        }
    }
    else
    {
        memcpy(wzTempColorValue, wzColorValue, sizeof(WCHAR) * RGB_STRING_LENGTH);
    }

    dwRet = 0;
    for (int i = 1; i < RGB_STRING_LENGTH; i++)
    {
        // shift dwRet by 4
        dwRet <<= 4;
        // and add in the value of this string
        switch (wzTempColorValue[i])
        {
        case '0':
            dwRet +=  0;
            break;
        case '1':
            dwRet +=  1;
            break;
        case '2':
            dwRet +=  2;
            break;
        case '3':
            dwRet +=  3;
            break;
        case '4':
            dwRet +=  4;
            break;
        case '5':
            dwRet +=  5;
            break;
        case '6':
            dwRet +=  6;
            break;
        case '7':
            dwRet +=  7;
            break;
        case '8':
            dwRet +=  8;
            break;
        case '9':
            dwRet +=  9;
            break;
        case 'a':
        case 'A':
            dwRet += 10;
            break;
        case 'b':
        case 'B':
            dwRet += 11;
            break;
        case 'c':
        case 'C':
            dwRet += 12;
            break;
        case 'd':
        case 'D':
            dwRet += 13;
            break;
        case 'e':
        case 'E':
            dwRet += 14;
            break;
        case 'f':
        case 'F':
            dwRet += 15;
            break;
        default:
            return PROPERTY_INVALIDCOLOR;
        }
    }
    return dwRet;
} // GetDWORDColorFromString

///////////////////////////////////////////////////////////////
//  Name: RGBStringToRGBValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
RGBStringToRGBValue (LPCWSTR wzColorValue, rgbColorValue *prgbValue)
{
    HRESULT hr;
    LPWSTR wzTrimmedColorValue = TrimCopyString(wzColorValue);

    if (NULL != wzTrimmedColorValue)
    {
        DWORD dwColorTo = GetDWORDColorFromString (wzTrimmedColorValue);

        delete [] wzTrimmedColorValue;

        if (dwColorTo == PROPERTY_INVALIDCOLOR)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        prgbValue->red = ((double)((dwColorTo & 0x00FF0000) >> 16)) / 255.0f;
        prgbValue->red = Clamp(0.0, prgbValue->red, 1.0);
        prgbValue->green = ((double)((dwColorTo & 0x0000FF00) >> 8)) / 255.0f;
        prgbValue->green = Clamp(0.0, prgbValue->green, 1.0);
        prgbValue->blue = ((double)(dwColorTo & 0x000000FF)) / 255.0f;
        prgbValue->blue = Clamp(0.0, prgbValue->blue, 1.0);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, E_INVALIDARG);
} // RGBStringToRGBValue


///////////////////////////////////////////////////////////////
//  Name: DWORDToRGB
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
DWORDToRGB (const DWORD dwColorTo, rgbColorValue *prgbValue)
{  
    prgbValue->red = ((double)((dwColorTo & 0x00FF0000) >> 16)) / 255.0f;
    prgbValue->red = Clamp(0.0, prgbValue->red, 1.0);
    prgbValue->green = ((double)((dwColorTo & 0x0000FF00) >> 8)) / 255.0f;
    prgbValue->green = Clamp(0.0, prgbValue->green, 1.0);
    prgbValue->blue = ((double)(dwColorTo & 0x000000FF)) / 255.0f;
    prgbValue->blue = Clamp(0.0, prgbValue->blue, 1.0);

} // DWORDToRGB


///////////////////////////////////////////////////////////////
//  Name: RGBValueToRGBVariantVector
//
//  Abstract: Push a color value specified in a rgbColorValue struct
//            into a SAFEARRAY with the double values {red, green, blue}
//    
///////////////////////////////////////////////////////////////
HRESULT
RGBValueToRGBVariantVector (const rgbColorValue *prgbValue, VARIANT *pvarValue)
{
    HRESULT hr;

    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }    

    {
        SAFEARRAY *psa = V_ARRAY(pvarValue);
        double rgdblValues[3];
        LPVOID pData = NULL;

        if (NULL == psa)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        hr = THR(::SafeArrayAccessData(psa, &pData));
        if (FAILED(hr))
        {
            goto done;
        }

        rgdblValues[0] = prgbValue->red;
        rgdblValues[1] = prgbValue->green;
        rgdblValues[2] = prgbValue->blue;
        memcpy(pData, rgdblValues, 3 * sizeof(double));

        hr = THR(::SafeArrayUnaccessData(psa));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBValueToRGBVariantVector

///////////////////////////////////////////////////////////////
//  Name: RGBStringToRGBVariantVector
//
//  Abstract: Push a color value specified in a string of the form #rrggbb
//            into a SAFEARRAY with the double values {red, green, blue}
//    
///////////////////////////////////////////////////////////////
HRESULT
RGBStringToRGBVariantVector (LPCWSTR wzColorValue, VARIANT *pvarValue)
{
    HRESULT hr;
    rgbColorValue rgbValue;

    if ((NULL == wzColorValue) ||
        (!(VT_ARRAY & V_VT(pvarValue))) 
       )
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = RGBStringToRGBValue (wzColorValue, &rgbValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = RGBValueToRGBVariantVector (&rgbValue, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBStringToRGBVariantVector

///////////////////////////////////////////////////////////////
//  Name: CreateInitialRGBVariantVector
//
//  Abstract: Create a safearray with space for a color value
//            in this variant
//    
///////////////////////////////////////////////////////////////
HRESULT 
CreateInitialRGBVariantVector(VARIANT *pvarValue)
{
    HRESULT hr;

    if (NULL == pvarValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(::VariantClear(pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        SAFEARRAY *psa = ::SafeArrayCreateVector(VT_R8, 0, 3);

        if (NULL == psa)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        V_VT(pvarValue) = VT_R8 | VT_ARRAY;
        V_ARRAY(pvarValue) = psa;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CreateInitialRGBVariantVector

///////////////////////////////////////////////////////////////
//  Name: RGBVariantStringToRGBVariantVectorInPlace
//
//  Abstract: Convert a variant with an RGB string into 
//            one containing the RGB values in a safearray.
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBVariantStringToRGBVariantVectorInPlace (VARIANT *pvarValue)
{
    HRESULT hr;

    if ((NULL == pvarValue) || (VT_BSTR != V_VT(pvarValue)) ||
        (NULL == V_BSTR(pvarValue)))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    {
        CComVariant varNew;

        hr = CreateInitialRGBVariantVector(&varNew);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = RGBStringToRGBVariantVector(V_BSTR(pvarValue), &varNew);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(::VariantCopy(pvarValue, &varNew));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBVariantStringToRGBVariantVectorInPlace


///////////////////////////////////////////////////////////////
//  Name: RGBVariantVectorToRGBValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBVariantVectorToRGBValue (const VARIANT *pvarValue, rgbColorValue *prgbValue)
{
    HRESULT hr;

    Assert(NULL != pvarValue);
    Assert(NULL != prgbValue);

    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    {
        SAFEARRAY *psa = V_ARRAY(pvarValue);
        double *pdblValues = NULL;
        LPVOID pData = NULL;

        if (NULL == psa)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        hr = THR(::SafeArrayAccessData(psa, &pData));
        if (FAILED(hr))
        {
            goto done;
        }

        pdblValues = static_cast<double *>(pData);

        prgbValue->red   = pdblValues[0];
        prgbValue->green = pdblValues[1]; 
        prgbValue->blue  = pdblValues[2];
        
        hr = THR(::SafeArrayUnaccessData(psa));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBVariantVectorToRGBValue

///////////////////////////////////////////////////////////////
//  Name: RGBVariantVectorToRGBVariantString
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBVariantVectorToRGBVariantString (const VARIANT *pvarArray, VARIANT *pvarRGBString)
{
    HRESULT hr;
    rgbColorValue rgbValue;

    USES_CONVERSION; //lint !e522

    hr = RGBVariantVectorToRGBValue(pvarArray, &rgbValue);
    if (FAILED(hr))
    {
        goto done;
    }

    rgbValue.red = Clamp(0.0, rgbValue.red, 1.0);
    rgbValue.green = Clamp(0.0, rgbValue.green, 1.0);
    rgbValue.blue = Clamp(0.0, rgbValue.blue, 1.0);

    {
        CComVariant varNew;

        // NOTE:
        // We are switching the R & B in the below RGB() for a reason!!
        // We need to construct the value this way inorder for IE to understand
        // and display the correct value.
        DWORD dwColor = RGB(rgbValue.blue*NUM_RGB_COLORS, 
                            rgbValue.green*NUM_RGB_COLORS, 
                            rgbValue.red*NUM_RGB_COLORS);
        char szColor[MAX_COLOR_STRING_LENGTH];

        wsprintfA(szColor, "#%06x", dwColor);
        V_VT(&varNew) = VT_BSTR;
        V_BSTR(&varNew) = ::SysAllocString(A2OLE(szColor));
        hr = THR(::VariantCopy(pvarRGBString, &varNew));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBVariantVectorToRGBVariantString

///////////////////////////////////////////////////////////////
//  Name: RGBStringColorLookup
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBStringColorLookup(const VARIANT *pvarString, VARIANT *pvarRGBString)
{
    HRESULT hr;
    DWORD dwColor;

    USES_CONVERSION; //lint !e522

    if (pvarString->vt != VT_BSTR)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    dwColor = GetDWORDColorFromString (pvarString->bstrVal);

    if (dwColor == PROPERTY_INVALIDCOLOR)
    {
        hr = E_INVALIDARG;
        goto done;
    }
   
    {
        CComVariant varNew;
        // NOTE:
        // We are switching the R & B in the below RGB() for a reason!!
        // We need to construct the value this way inorder for IE to understand
        // and display the correct value.
   
        char szColor[MAX_COLOR_STRING_LENGTH];

        wsprintfA(szColor, "#%06x", dwColor);
        V_VT(&varNew) = VT_BSTR;
        V_BSTR(&varNew) = ::SysAllocString(A2OLE(szColor));
        hr = THR(::VariantCopy(pvarRGBString, &varNew));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBStringColorLookup


///////////////////////////////////////////////////////////////
//  Name: IsColorUninitialized
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool 
IsColorUninitialized (LPCWSTR wzColorValue)
{
    return (   (NULL == wzColorValue)
            || (0 == lstrlenW(wzColorValue))
            || (0 == StrCmpIW(wzColorValue, WZ_TRANSPARENT))
           );
} // IsColorUninitialized

///////////////////////////////////////////////////////////////
//  Name: EnsureVariantVectorFormat
//
//  Abstract: Ensure that we're using the 
//            variant color vector format.
//    
///////////////////////////////////////////////////////////////
HRESULT
EnsureVariantVectorFormat (VARIANT *pvarVector)
{
    HRESULT hr = S_OK;

    if (VT_BSTR == V_VT(pvarVector))
    {
        hr = RGBVariantStringToRGBVariantVectorInPlace(pvarVector);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    if ((VT_R8 | VT_ARRAY) != V_VT(pvarVector))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // EnsureVariantVectorFormat

///////////////////////////////////////////////////////////////
//  Name: IsColorVariantVectorEqual
//
//  Abstract: Are the vectors in the two variants the same?
//    
///////////////////////////////////////////////////////////////
bool
IsColorVariantVectorEqual (const VARIANT *pvarLeft, const VARIANT *pvarRight)
{
    const double dblError = PERCEPTABLE_COLOR_ERROR;
    rgbColorValue rgbLeft;
    rgbColorValue rgbRight;
    bool bRet = false;
    HRESULT hr = THR(RGBVariantVectorToRGBValue(pvarLeft, &rgbLeft));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(RGBVariantVectorToRGBValue(pvarRight, &rgbRight));
    if (FAILED(hr))
    {
        goto done;
    }

    // Allow for imperceptible error in the 
    // comparison
    if (   (dblError > fabs(rgbLeft.red -   rgbRight.red) )
        && (dblError > fabs(rgbLeft.green - rgbRight.green) )
        && (dblError > fabs(rgbLeft.blue -  rgbRight.blue) ) )
    {
        bRet = true;
    }

done:
    return bRet;
} // IsColorVariantVectorEqual
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\colorutil.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: colorutil.h
//
//  Contents: Color conversion utilities
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _COLORUTIL__H
#define _COLORUTIL__H

#define PROPERTY_INVALIDCOLOR   (0x99999999)
#define NUM_RGB_COLORS          (255)

struct rgbColorValue
{
    double red;
    double green;
    double blue;
};

HRESULT CreateInitialRGBVariantVector(VARIANT *pvarValue);
HRESULT RGBVariantStringToRGBVariantVectorInPlace (VARIANT *pvarValue);
HRESULT RGBStringToRGBVariantVector (LPCWSTR wzColorValue, VARIANT *pvarValue);
HRESULT RGBStringToRGBValue (LPCWSTR wzColorValue, rgbColorValue *prgbValue);
HRESULT RGBValueToRGBVariantVector (const rgbColorValue *prgbValue, VARIANT *pvarValue);
HRESULT RGBVariantVectorToRGBValue (const VARIANT *pvarValue, rgbColorValue *prgbValue);
HRESULT RGBVariantVectorToRGBVariantString (const VARIANT *pvarArray, VARIANT *pvarRGBString);
HRESULT RGBStringColorLookup(const VARIANT *pvarString, VARIANT *pvarRGBString);
HRESULT EnsureVariantVectorFormat (VARIANT *pvarVector);
void DWORDToRGB (const DWORD dwColorTo, rgbColorValue *prgbValue);
bool IsColorVariantVectorEqual (const VARIANT *pvarLeft, const VARIANT *pvarRight);
bool IsColorUninitialized (LPCWSTR wzColorValue);

#endif // _COLORUTIL__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\compfact.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Default Animation Composer Factory.

*******************************************************************************/

#pragma once

#ifndef _COMPFACTORY_H
#define _COMPFACTORY_H

interface IAnimationComposer;

class __declspec(uuid("E9B48B62-53EA-4ab7-BD2C-8105D1C0624F"))
ATL_NO_VTABLE CAnimationComposerFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CAnimationComposerFactory, &CLSID_AnimationComposerFactory>,
      public IAnimationComposerFactory,
      public ISupportErrorInfoImpl<&IID_IAnimationComposerFactory>
{
  public:
    CAnimationComposerFactory();
    virtual ~CAnimationComposerFactory();

    DECLARE_NOT_AGGREGATABLE(CAnimationComposerFactory)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposerFactory"); }
#endif

    // IAnimationComposerFactory   
    STDMETHOD(FindComposer)(IDispatch *pidispElement, BSTR bstrAttributeName, 
                            IAnimationComposer **ppiAnimationComposer); 

    DECLARE_REGISTRY(CLSID_AnimationComposerFactory,
                     LIBID __T(".SMILAnimDefaultCompFactory.1"),
                     LIBID __T(".SMILAnimDefaultCompFactory"),
                     0,
                     THREADFLAGS_BOTH);    

    BEGIN_COM_MAP(CAnimationComposerFactory)
        COM_INTERFACE_ENTRY(IAnimationComposerFactory)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    static HRESULT CreateColorComposer   (IAnimationComposer **ppiAnimationComposer);
    static HRESULT CreateTransitionComposer   (IAnimationComposer **ppiAnimationComposer);
    static HRESULT CreateDefaultComposer (IAnimationComposer **ppiAnimationComposer);

  protected:

};

#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\compsite.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: compsite.h
//
//  Contents: Animation Composer Site object
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _COMPSITE_H
#define _COMPSITE_H

/////////////////////////////////////////////////////////////////////////////
// CAnimationComposerSite

typedef std::list<IAnimationComposer*> ComposerList;
typedef std::list<VARIANT *> ComposerFactoryList;

class CBaseBvr;

class __declspec(uuid("27982921-8CF2-49cc-9A1B-F41F5C11A607"))
ATL_NO_VTABLE CAnimationComposerSite : 
    public CBaseBvr,
    public CComCoClass<CAnimationComposerSite, &__uuidof(CAnimationComposerSite)>,
    public ITIMEDispatchImpl<IAnimationComposerSite, &IID_IAnimationComposerSite>,
    public ISupportErrorInfoImpl<&IID_IAnimationComposerSite>,
    public IAnimationComposerSiteSink
{
  
  public :

    CAnimationComposerSite (void);
    virtual ~CAnimationComposerSite (void);

    //
    // IElementBehavior
    //
    STDMETHOD(Init) (IElementBehaviorSite *piBvrSite);
    STDMETHOD(Detach) (void);

    //
    // IAnimationComposerSite
    //
    STDMETHOD(AddFragment) (BSTR bstrAttributeName, IDispatch *pidispFragment);
    STDMETHOD(RemoveFragment) (BSTR bstrAttributeName, IDispatch *pidispFragment);
    STDMETHOD(InsertFragment) (BSTR bstrAttributeName, IDispatch *pidispFragment, VARIANT varIndex);
    STDMETHOD(EnumerateFragments) (BSTR bstrAttributeName, IEnumVARIANT **ppienumFragments);
    STDMETHOD(RegisterComposerFactory) (VARIANT *varFactory);
    STDMETHOD(UnregisterComposerFactory) (VARIANT *varFactory);   

    //
    // IAnimationComposerSiteSink
    //
    STDMETHOD_(void, UpdateAnimations) (void);
    STDMETHOD_(void, ComposerSiteDetach) (void);

    // QI Map
    
    BEGIN_COM_MAP(CAnimationComposerSite)
        COM_INTERFACE_ENTRY(IAnimationComposerSite)
        COM_INTERFACE_ENTRY(IAnimationComposerSiteSink)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // CBaseBvr pure virtuals.
    // Most of these are do not have bona-fide implementations
    // as this behavior has no properties.
    void * GetInstance (void);
    HRESULT GetTypeInfo (ITypeInfo ** ppInfo);
    HRESULT GetPropertyBagInfo (CPtrAry<BSTR> **);
    HRESULT SetPropertyByIndex (unsigned , VARIANT *);
    HRESULT GetPropertyByIndex (unsigned , VARIANT *);
    bool IsPropertySet (unsigned long);
    void SetPropertyFlag (DWORD uIndex);
    void ClearPropertyFlag (DWORD uIndex);
    STDMETHOD(OnPropertiesLoaded) (void);
    HRESULT GetConnectionPoint(REFIID , IConnectionPoint **);
    LPCWSTR GetBehaviorURN (void);
    LPCWSTR GetBehaviorName (void);
    bool IsBehaviorAttached (void);

  // Internal Methods
  protected :

    void    DetachComposers (void);
    void    UnregisterFactories (void);
    HRESULT CacheAnimationRoot (void);
    HRESULT RegisterSite (void);
    void    UnregisterSite (void);

    void RemoveComposer(IAnimationComposer *piOldComp);
    bool QueryReleaseComposer (IAnimationComposer *piComp);

    HRESULT FindCustomComposer (IDispatch *pidispFragment, 
                                BSTR bstrAttributeName, 
                                IAnimationComposer **ppiComposer);
    HRESULT FindAndInitComposer (IAnimationComposerFactory *piFactory,
                                 IDispatch *pidispFragment,
                                 BSTR bstrAttributeName,
                                 IAnimationComposer **ppiComposer);
    IAnimationComposer * FindComposerForAttribute (BSTR bstrAttribName);
    IAnimationComposer * FindComposer (BSTR bstrAttributeName, IDispatch *pidispFragment);
    IAnimationComposer * EnsureComposer (BSTR bstrAttributeName, IDispatch *pidispFragment);

  // Data
  protected :

    CComPtr<IAnimationRoot> m_spAnimationRoot;
    ComposerList            m_composers;
    ComposerFactoryList     m_factories;

};

// ----------------------------------------------------------------------------------------

inline void * 
CAnimationComposerSite::GetInstance (void)
{ 
    return reinterpret_cast<ITIMEAnimationElement *>(this) ; 
} // CAnimationComposerSite::GetInstance

// ----------------------------------------------------------------------------------------

inline HRESULT
CAnimationComposerSite::GetTypeInfo (ITypeInfo ** ppInfo)
{
    return GetTI(GetUserDefaultLCID(), ppInfo);
} // CAnimationComposerSite::GetTypeInfo

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::GetPropertyBagInfo (CPtrAry<BSTR> **)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::GetPropertyBagInfo

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::SetPropertyByIndex (unsigned , VARIANT *)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::SetPropertyByIndex

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::GetPropertyByIndex (unsigned , VARIANT *)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::GetPropertyByIndex

// ----------------------------------------------------------------------------------------

inline bool
CAnimationComposerSite::IsPropertySet (unsigned long)
{
    return false;
} // CAnimationComposerSite::IsPropertySet

// ----------------------------------------------------------------------------------------

inline STDMETHODIMP
CAnimationComposerSite::OnPropertiesLoaded (void)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::OnPropertiesLoaded

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::GetConnectionPoint (REFIID , IConnectionPoint **)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::GetConnectionPoint

// ----------------------------------------------------------------------------------------

inline void 
CAnimationComposerSite::SetPropertyFlag (DWORD )
{
} // CAnimationComposerSite::SetPropertyFlag

// ----------------------------------------------------------------------------------------

inline void 
CAnimationComposerSite::ClearPropertyFlag (DWORD )
{
} // CAnimationComposerSite::ClearPropertyFlag

// ----------------------------------------------------------------------------------------

inline LPCWSTR 
CAnimationComposerSite::GetBehaviorURN (void)
{
    return WZ_SMILANIM_URN;
} // CAnimationComposerSite::GetBehaviorURN

// ----------------------------------------------------------------------------------------

inline LPCWSTR 
CAnimationComposerSite::GetBehaviorName (void)
{
    return WZ_REGISTERED_ANIM_NAME;
} // CAnimationComposerSite::GetBehaviorName

// ----------------------------------------------------------------------------------------

inline bool 
CAnimationComposerSite::IsBehaviorAttached (void)
{
    return IsComposerSiteBehaviorAttached(GetElement());
} // CTIMEElementBase::IsBehaviorAttached

#endif // _COMPSITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\defcomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "animcomp.h"
#include "defcomp.h"

DeclareTag(tagAnimationDefaultComposer, "SMIL Animation", 
           "CAnimationComposer methods");

DeclareTag(tagAnimationDefaultComposerProcess, "SMIL Animation", 
           "CAnimationComposer pre/post process methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposer::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposer::Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                            IAnimationComposer **ppiComp)
{
    HRESULT hr;

    CComObject<CAnimationComposer> *pNew = NULL;
    hr = THR(CComObject<CAnimationComposer>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiComp)));
    if (FAILED(hr))
    {
        pNew->Release();
        hr = E_UNEXPECTED;
        goto done;
    }

    Assert(NULL != (*ppiComp));

    hr = (*ppiComp)->ComposerInit(pidispHostElem, bstrAttributeName);
    if (FAILED(hr))
    {
        (*ppiComp)->Release();
        *ppiComp = NULL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposer::Create

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposer::CAnimationComposer
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposer::CAnimationComposer (void)
{
    TraceTag((tagAnimationDefaultComposer,
              "CAnimationComposer(%lx)::CAnimationComposer()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposer::~CAnimationComposer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposer::~CAnimationComposer (void)
{
    TraceTag((tagAnimationDefaultComposer,
              "CAnimationComposer(%lx)::~CAnimationComposer()",
              this));
} //dtor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\filtercomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Filter Animation Composer.

*******************************************************************************/

#pragma once

#ifndef _FILTERCOMP_H
#define _FILTERCOMP_H

class __declspec(uuid("5B81FB87-CC13-4bde-9F5C-51CFE4D221ED"))
ATL_NO_VTABLE CAnimationFilterComposer
    : public CComCoClass<CAnimationFilterComposer, &__uuidof(CAnimationFilterComposer)>,
      public CAnimationComposerBase
{

  public:

    CAnimationFilterComposer (void);
    virtual ~CAnimationFilterComposer (void);

    // IAnimationComposer methods
    STDMETHOD(AddFragment) (IDispatch *pidispNewAnimationFragment);
    STDMETHOD(InsertFragment) (IDispatch *pidispNewAnimationFragment, VARIANT varIndex);

    // IAnimationComposer2 methods
    STDMETHOD(ComposerInitFromFragment) (IDispatch *pidispHostElem, 
                                         BSTR bstrAttributeName, 
                                         IDispatch *pidispFragment);

    DECLARE_NOT_AGGREGATABLE(CAnimationFilterComposer)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationFilterComposer"); }
#endif

    static HRESULT Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                           IAnimationComposer **ppiComp);

  protected :

    HRESULT QueryFragmentForParameters (IDispatch *pidispFragment,
                                        VARIANT *pvarType, 
                                        VARIANT *pvarSubtype,
                                        VARIANT *pvarMode,
                                        VARIANT *pvarFadeColor,
                                        VARIANT *pvarParams);

    HRESULT ValidateFragmentForComposer (IDispatch *pidispFragment);

  protected :

    CComVariant m_varType;
    CComVariant m_varSubtype;
    CComVariant m_varMode;
    CComVariant m_varFadeColor;
    CComVariant m_varParams;

};

#endif /* _FILTERCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\compsite.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Site Implementation

*******************************************************************************/


#include "headers.h"
#include "tokens.h"
#include "array.h"
#include "basebvr.h"
#include "util.h"
#include "compfact.h"
#include "compsite.h"
#include "animcomp.h"

DeclareTag(tagAnimationComposerSite, "SMIL Animation", 
           "CAnimationComposerSite methods");

DeclareTag(tagAnimationComposerSiteLifecycle, "SMIL Animation", 
           "CAnimationComposerSite Composer lifecycle methods");

DeclareTag(tagAnimationComposerSiteUpdate, "SMIL Animation", 
           "CAnimationComposerSite UpdateAnimations");

DeclareTag(tagAnimationComposerSiteRegistration, "SMIL Animation", 
           "CAnimationComposerSite Register/Unregister site");

DeclareTag(tagAnimationComposerSiteAddRemove, "SMIL Animation", 
           "CAnimationComposerSite Add/remove Fragment");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::CAnimationComposerSite
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerSite::CAnimationComposerSite (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::CAnimationComposerSite()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::~CAnimationComposerSite
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerSite::~CAnimationComposerSite (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::~CAnimationComposerSite()",
              this));

    Assert(0 == m_composers.size());
    Assert(0 == m_factories.size());
    m_spAnimationRoot.Release();
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::CacheAnimationRoot
//
//  Overview:  Consult the body for the animation root
//
//  Arguments: None
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::CacheAnimationRoot (void)
{
    HRESULT hr;

    CComPtr<IHTMLElement> piBodyElm;

    hr = THR(GetBodyElement(GetElement(), IID_IHTMLElement,
                            reinterpret_cast<void **>(&piBodyElm)));
    if (FAILED(hr))
    {
        TraceTag((tagError,
         "CacheAnimationRoot (%p) could not get body element",
         this));
        hr = E_FAIL;
        goto done;
    }

    // For the time being, we need to preclude registration 
    // of the site when we're running in IE4.  This will prevent 
    // a per-tick penalty.
    {
        CComPtr<IHTMLElement> spElem;
        CComPtr<IHTMLElement2> spElem2;

        spElem = GetElement();
        // IHTMLElement2 only supported since IE5.
        hr = THR(spElem->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElem2)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // The animation root interface is part of the behavior
    hr = THR(FindBehaviorInterface(WZ_REGISTERED_TIME_NAME,
                                   piBodyElm, IID_IAnimationRoot,
                                   reinterpret_cast<void **>(&m_spAnimationRoot)));
    if (FAILED(hr))
    {
        TraceTag((tagError,
         "CacheAnimationRoot (%p) body behavior not installed",
         this));
        hr = E_FAIL;
        goto done;
    }

    hr= S_OK;
done :
    RRETURN(hr);
} // CAnimationComposerSite::CacheAnimationRoot

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RegisterSite
//
//  Overview:  Register the composer site behavior with the animation root
//
//  Arguments: None
//
//  Returns:   S_OK, E_FAIL
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::RegisterSite (void)
{
    TraceTag((tagAnimationComposerSiteRegistration,
              "CAnimationComposerSite(%p)::RegisterSite()", this));

    HRESULT hr;

    // Allow for initialization failure
    if (m_spAnimationRoot != NULL)
    {
        hr = THR(m_spAnimationRoot->RegisterComposerSite(
                 static_cast<IAnimationComposerSiteSink *>(this)));
        if (FAILED(hr))
        {
            TraceTag((tagError,
             "Cannot register composer site (%p)", this));
            hr = E_FAIL;
            goto done;
        }
    }

    hr= S_OK;
done :
    RRETURN1(hr, E_FAIL);
} // CAnimationComposerSite::RegisterSite

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::Init
//
//  Overview:  Initialize the composer site behavior
//
//  Arguments: the behavior site
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::Init (IElementBehaviorSite *piBvrSite)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::Init(%p)",
              this, piBvrSite));

    HRESULT hr = CBaseBvr::Init(piBvrSite);

    // Make sure there is a time root that we can hook into
    hr = THR(AddBodyBehavior(GetElement()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CacheAnimationRoot();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationComposerSite::Init

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UnregisterSite
//
//  Overview:  Unregister the composer site behavior with the animation root
//
//  Arguments: None
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::UnregisterSite (void)
{
    TraceTag((tagAnimationComposerSiteRegistration,
              "CAnimationComposerSite(%p)::UnregisterSite()", this));

    // Allow for initialization failure
    if (m_spAnimationRoot != NULL)
    {
        HRESULT hr;

        hr = THR(m_spAnimationRoot->UnregisterComposerSite(
                 static_cast<IAnimationComposerSiteSink *>(this)));
        if (FAILED(hr))
        {
            TraceTag((tagError,
             "Cannot unregister composer site (%p)", this));
        }
    }
} // CAnimationComposerSite::UnregisterSite

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::DetachComposers
//
//  Overview:  Tell all of the composers to detach
//
//  Arguments: none
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::DetachComposers (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::DetachComposers()",
              this));

    ComposerList listComposersToDetach;

    // Copy the composer list so that we can tolerate 
    // reentrancy on it.
    for (ComposerList::iterator i = m_composers.begin(); 
         i != m_composers.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listComposersToDetach.push_back(*i);
    }

    // Do not allow any failure to abort the detach cycle.
    for (i = listComposersToDetach.begin(); 
         i != listComposersToDetach.end(); i++)
    {
        IGNORE_HR((*i)->ComposerDetach());
        // This release is for the reference from the 
        // original list.
        IGNORE_RETURN((*i)->Release());
    }

    for (i = listComposersToDetach.begin(); 
         i != listComposersToDetach.end(); i++)
    {
        // This release is for the reference from the 
        // copied list.
        IGNORE_RETURN((*i)->Release());
    }

    m_composers.clear();
} // CAnimationComposerSite::DetachComposers

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UnregisterFactories
//
//  Overview:  Tell all of the factories to unregister, then delete 
//             their memory.
//
//  Arguments: none
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::UnregisterFactories (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::UnregisterFactories()",
              this));

    for (ComposerFactoryList::iterator i = m_factories.begin(); i != m_factories.end(); i++)
    {
        VARIANT *pvarRegisteredFactory = *i;
        IGNORE_HR(::VariantClear(pvarRegisteredFactory));
        delete pvarRegisteredFactory;
    }

    m_factories.clear();
} // CAnimationComposerSite::UnregisterFactories

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::Detach
//
//  Overview:  Tear down the composer site behavior
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::Detach (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::Detach()",
              this));

    HRESULT hr;

    // We typically do not want errors to stop us from detaching everything.

    // Let go of our reference to the animation root.
    ComposerSiteDetach();

    // Tear down the factories and fragments.
    DetachComposers();
    UnregisterFactories();

    hr = CBaseBvr::Detach();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CAnimationComposerSite::Detach (%p) Error in base detach -- continuing detach",
                  this));
    }

done :
    RRETURN(hr);
} // CAnimationComposerSite::Detach

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindComposerForAttribute
//
//  Overview:  Find the proper composer for a given attribute
//
//  Arguments: the name of the animated attribute
//
//  Returns:   a weak reference to the composer
//
//------------------------------------------------------------------------
IAnimationComposer *
CAnimationComposerSite::FindComposerForAttribute (BSTR bstrAttribName)
{
    IAnimationComposer *piComp = NULL;

    for (ComposerList::iterator i = m_composers.begin(); 
         i != m_composers.end(); i++)
    {
        CComBSTR bstrOneAttrib;

        (*i)->get_attribute(&bstrOneAttrib);
        if (0 == StrCmpIW(bstrAttribName, bstrOneAttrib))
        {
            piComp = *i;
            break;
        }
    }

done :
    return piComp;
} // CAnimationComposerSite::FindComposerForAttribute

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindComposer
//
//  Overview:  Find the proper composer for a given fragment
//
//  Arguments: the animated attribute name, and the dispatch of the fragment
//
//  Returns:   a weak reference to the composer
//
//------------------------------------------------------------------------
IAnimationComposer *
CAnimationComposerSite::FindComposer (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    IAnimationComposer *piComp = NULL;

    // Look in the current list of composers for the proper one for this attribute.
    // If we could not find one, make one.
    piComp = FindComposerForAttribute(bstrAttributeName);

done :
    return piComp;
} // CAnimationComposerSite::FindComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindAndInitComposer
//
//  Overview:  Given a composer factory, try to find and init a composer.
//
//  Arguments: Composer Factory, 
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::FindAndInitComposer (IAnimationComposerFactory *piFactory,
                                             IDispatch *pidispFragment,
                                             BSTR bstrAttributeName,
                                             IAnimationComposer **ppiComposer)
{
    HRESULT hr;
    CComVariant varElem;

    hr = THR(GetProperty(pidispFragment, WZ_FRAGMENT_ELEMENT_PROPERTY_NAME, &varElem));
    if (FAILED(hr))
    {
        goto done;
    }

    if (VT_DISPATCH != V_VT(&varElem))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(piFactory->FindComposer(V_DISPATCH(&varElem), bstrAttributeName, ppiComposer));
    if (S_OK == hr)
    {
        CComPtr<IAnimationComposer2> spComp2;

        // Try calling through the newer init method.  This allows the filter composer
        // to set itself up correctly upon initialization.
        hr = THR((*ppiComposer)->QueryInterface(IID_TO_PPV(IAnimationComposer2, &spComp2)));
        if (SUCCEEDED(hr))
        {
            hr = THR(spComp2->ComposerInitFromFragment(GetElement(), bstrAttributeName, pidispFragment));
        }
        // Fallback to older interface - no harm done, except for filters which we're revving
        // here.
        else
        {
            hr = THR((*ppiComposer)->ComposerInit(GetElement(), bstrAttributeName));
        }

        if (FAILED(hr))
        {
            IGNORE_RETURN((*ppiComposer)->Release());
            *ppiComposer = NULL;
            goto done;
        }
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // FindAndInitComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindCustomComposer
//
//  Overview:  Search the registered composer factories for the proper composer
//
//  Arguments: the animated attribute name
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::FindCustomComposer (IDispatch *pidispFragment, 
                                            BSTR bstrAttributeName, 
                                            IAnimationComposer **ppiComposer)
{
    HRESULT hr = S_FALSE;
    HRESULT hrTemp;
    CComPtr<IAnimationComposerFactory> spCompFactory;

    // Internal method - validation is not necessary.
    *ppiComposer = NULL;

    for (ComposerFactoryList::iterator i = m_factories.begin(); i != m_factories.end(); i++)
    {
        VARIANT *pvarFactory = *i;
        CLSID clsidFactory;

        if (VT_BSTR == V_VT(pvarFactory))
        {
            hrTemp = THR(CLSIDFromString(V_BSTR(pvarFactory), &clsidFactory));
            if (FAILED(hrTemp))
            {
                TraceTag((tagAnimationComposerSite,
                          "CAnimationComposerSite(%p)::FindCustomComposer() failed getting a CLSID -- continuing",
                          this));
                continue;
            }

            hrTemp = THR(::CoCreateInstance(clsidFactory, NULL, CLSCTX_INPROC_SERVER, 
                                            IID_IAnimationComposerFactory, 
                                            reinterpret_cast<void **>(&spCompFactory)));
            if (FAILED(hrTemp))
            {

                TraceTag((tagAnimationComposerSite,
                          "CAnimationComposerSite(%p)::FindCustomComposer() failed during a CoCreate -- continuing",
                          this));
                continue;
            }
        }
        else if (VT_UNKNOWN == V_VT(pvarFactory))
        {
            hrTemp = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_TO_PPV(IAnimationComposerFactory, &spCompFactory)));
            if (FAILED(hrTemp))
            {

                TraceTag((tagAnimationComposerSite,
                          "CAnimationComposerSite(%p)::FindCustomComposer() failed during a QI -- continuing",
                          this));
                continue;
            }
        }
        else
        {
            TraceTag((tagAnimationComposerSite,
                      "CAnimationComposerSite(%p)::FindCustomComposer() unexpected factory type %X -- continuing",
                      this, V_VT(pvarFactory)));
            continue;
        }

        // If either FindComposer or InitComposer come up empty, we want to keep looking 
        // for another composer, on the off-chance the animation will work properly.
        hrTemp = FindAndInitComposer(spCompFactory, pidispFragment, 
                                     bstrAttributeName, ppiComposer);
        if (S_OK == hrTemp)
        {
            hr = hrTemp;
            break;
        }
    }

done :
    RRETURN1(hr, S_FALSE);
} // CAnimationComposerSite::FindCustomComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::EnsureComposer
//
//  Overview:  Find or create the proper composer for a given fragment
//
//  Arguments: the animated attribute name, and the dispatch of the fragment
//
//  Returns:   a weak reference to the composer
//
//------------------------------------------------------------------------
IAnimationComposer *
CAnimationComposerSite::EnsureComposer (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    IAnimationComposer *piComp = FindComposer(bstrAttributeName, pidispFragment);

    if (NULL == piComp)
    {
        HRESULT hr;

        hr = FindCustomComposer(pidispFragment, bstrAttributeName, &piComp);
        if (S_OK != hr)
        {
            // Make sure we don't eat a composer reference.  This might happen if the composer 
            // doesn't properly clean up after a failure.
            Assert(NULL == piComp);

            // create a composer using the default factory.
            // The static create method addrefs the object.
            CComPtr<IAnimationComposerFactory> spFactory;

            hr = THR(::CoCreateInstance(CLSID_AnimationComposerFactory, NULL, CLSCTX_INPROC_SERVER, 
                                        IID_IAnimationComposerFactory, 
                                        reinterpret_cast<void **>(&spFactory)));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = FindAndInitComposer(spFactory, pidispFragment, bstrAttributeName, &piComp);
            if (FAILED(hr))
            {
                goto done;
            }

        }
        
        if (NULL != piComp)
        {
            TraceTag((tagAnimationComposerSiteLifecycle,
                      "CAnimationComposerSite(%p)::EnsureComposer(%ls, %p) created composer",
                      this, bstrAttributeName, piComp));

            // @@ Handle memory errors.
            m_composers.push_back(piComp);
            // If this is our first composer, then register ourselves 
            // for updates with the animation root.
            if (1 == m_composers.size())
            {
                hr = RegisterSite();
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
    }

done :
    return piComp;
} // CAnimationComposerSite::EnsureComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::AddFragment
//
//  Overview:  Add a fragment to the composer site.  Consults the 
//             registered composer factories to find the proper 
//             composer
//
//  Arguments: the animated attribute name and the fragment's dispatch
//
//  Returns:   S_OK, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::AddFragment (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    TraceTag((tagAnimationComposerSiteAddRemove,
              "CAnimationComposerSite(%p)::AddFragment(%ls, %p)",
              this, bstrAttributeName, pidispFragment));

    HRESULT hr;
    CComPtr<IAnimationComposer> piComp;

    // Find the proper composer for this fragment.
    piComp = EnsureComposer(bstrAttributeName, pidispFragment);
    if (piComp == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
        
    // This can return S_FALSE if the fragment is already inside the 
    // composer's fragment list.
    hr = THR(piComp->AddFragment(pidispFragment));
    if (S_OK != hr)
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN4(hr, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposerSite::AddFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RemoveFragment
//
//  Overview:  Remove a fragment from the composer site.  Determines which of 
//             the composers owns it.
//
//  Arguments: the animated attribute name, and the fragment's dispatch
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::RemoveFragment (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    TraceTag((tagAnimationComposerSiteAddRemove,
              "CAnimationComposerSite(%p)::RemoveFragment(%ls, %p)",
              this, bstrAttributeName, pidispFragment));

    HRESULT hr;
    CComPtr<IAnimationComposer> spComp;

    spComp = FindComposer(bstrAttributeName, pidispFragment);
    if (spComp == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = THR(spComp->RemoveFragment(pidispFragment));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_UNEXPECTED);
} // CAnimationComposerSite::RemoveFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::InsertFragment
//
//  Overview:  Insert a fragment to the composer site.  Consults the 
//             registered composer factories to find the proper 
//             composer
//
//  Arguments: the animated attribute name and the fragment's dispatch
//
//  Returns:   S_OK, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::InsertFragment (BSTR bstrAttributeName, IDispatch *pidispFragment, 
                                     VARIANT varIndex)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::InsertFragment(%ls, %p)",
              this, bstrAttributeName, pidispFragment));

    HRESULT hr;
    CComPtr<IAnimationComposer> piComp;

    // Find the proper composer for this fragment.
    piComp = EnsureComposer(bstrAttributeName, pidispFragment);
    if (piComp == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
        
    // This can return S_FALSE if the fragment is already inside the 
    // composer's fragment list.
    hr = THR(piComp->InsertFragment(pidispFragment, varIndex));
    if (S_OK != hr)
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN4(hr, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposerSite::InsertFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::EnumerateFragments
//
//  Overview:  Enumerate the fragments on the composer registered for 
//             the given attribute name.
//
//  Arguments: the animated attribute name and the enumerator
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::EnumerateFragments (BSTR bstrAttributeName, 
                                            IEnumVARIANT **ppienumFragments)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::EnumerateFragments(%ls)",
              this, bstrAttributeName));

    HRESULT hr;
    CComPtr<IAnimationComposer> piComp;

    // Find the proper composer for this fragment.
    piComp = FindComposerForAttribute(bstrAttributeName);
    if (piComp == NULL)
    {
        // @@ Need a proper error value for this.
        hr = E_FAIL;
        goto done;
    }
    
    hr = piComp->EnumerateFragments(ppienumFragments);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationComposerSite::EnumerateFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RegisterComposerFactory
//
//  Overview:  Register a new composer factory with this site
//
//  Arguments: The CLSID or IUnknown of the new composer factory
//
//  Returns:   S_OK, E_INVALIDARG, DISP_E_BADVARTYPE, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::RegisterComposerFactory (VARIANT *pvarFactory)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::RegisterComposerFactory()",
              this));

    HRESULT hr;

    if (NULL == pvarFactory)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if ((VT_BSTR != V_VT(pvarFactory)) && (VT_UNKNOWN != V_VT(pvarFactory)))
    {
        hr = DISP_E_BADVARTYPE;
        goto done;
    }

    // Add this to the list of factories.
    {
        VARIANT *pvarNewFactory = new VARIANT;

        if (NULL == pvarNewFactory)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        ::VariantInit(pvarNewFactory);
        hr = THR(::VariantCopy(pvarNewFactory, pvarFactory));
        if (FAILED(hr))
        {
            goto done;
        }
        // Put the newly registered factory at the 
        // front of the list to give it precedence over
        // previously registered factories.
        // @@ Check for memory error.
        m_factories.push_front(pvarNewFactory);
        // we no longer own this.
        pvarNewFactory = NULL; //lint !e423
    }
    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, DISP_E_BADVARTYPE, E_OUTOFMEMORY);
} // CAnimationComposerSite::RegisterComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UnregisterComposerFactory
//
//  Overview:  Unregister a composer factory on this site
//
//  Arguments: The CLSID of the composer factory
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::UnregisterComposerFactory (VARIANT *pvarFactory)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::UnregisterComposerFactory()",
              this));

    HRESULT hr;

    // Remove this from the list of factories.
    for (ComposerFactoryList::iterator i = m_factories.begin(); i != m_factories.end(); i++)
    {
        VARIANT *pvarRegisteredFactory = *i;

        if ((VT_BSTR == V_VT(pvarFactory)) &&
            (VT_BSTR == V_VT(pvarRegisteredFactory)))
        {
            if (0 == StrCmpIW(V_BSTR(pvarFactory), V_BSTR(pvarRegisteredFactory)))
            {
                break;
            }
        }
        else if ((VT_UNKNOWN == V_VT(pvarFactory)) &&
                 (VT_UNKNOWN == V_VT(pvarRegisteredFactory)))
        {
            if (MatchElements(V_UNKNOWN(pvarFactory), V_UNKNOWN(pvarRegisteredFactory)))
            {
                break;
            }
        }
    }

    if (i != m_factories.end())
    {
        IGNORE_HR(::VariantClear(*i));
        m_factories.remove(*i);
    }
    else
    {
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, S_FALSE);
} // CAnimationComposerSite::UnregisterComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::QueryReleaseComposer
//
//  Overview:  Determine whether we can release this composer
//
//  Returns:   
//
//------------------------------------------------------------------------
bool
CAnimationComposerSite::QueryReleaseComposer (IAnimationComposer *piComp)
{
    bool bRet = false;
    long lNumFragments = 0;
    HRESULT hr = THR(piComp->GetNumFragments(&lNumFragments));

    if (FAILED(hr))
    {
        // Failure constitutes a perf
        // hit, but not a disaster.
        goto done;
    }

    if (0 == lNumFragments)
    {
        bRet = true;
    }

done :
    return bRet;
} // CAnimationComposerSite::QueryReleaseComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RemoveComposer
//
//  Overview:  Remove this composer from our list.
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::RemoveComposer(IAnimationComposer *piOldComp)
{
    CComBSTR bstrAttrib;
    HRESULT hr = THR(piOldComp->get_attribute(&bstrAttrib));

    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationComposerSiteLifecycle,
              "CAnimationComposerSite(%p)::RemoveComposer(%p, %ls)",
              this, piOldComp, bstrAttrib));

    {
        for (ComposerList::iterator i = m_composers.begin(); 
             i != m_composers.end(); i++)
        {
            CComBSTR bstrOneAttrib;

            (*i)->get_attribute(&bstrOneAttrib);
            if (0 == StrCmpIW(bstrAttrib, bstrOneAttrib))
            {
                CComPtr<IAnimationComposer> spComp = (*i);
                m_composers.erase(i);
                THR(spComp->ComposerDetach());
                spComp.Release();
                break;
            }
        }
    }

done :
    return;
} // RemoveComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UpdateAnimations
//
//  Overview:  Tell all of our composers to cycle through their fragments 
//             and update the target.
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CAnimationComposerSite::UpdateAnimations (void)
{
    ComposerList listComposers;

    TraceTag((tagAnimationComposerSiteUpdate,
              "CAnimationComposerSite(%p)::UpdateAnimations(%ld composers)",
              this, m_composers.size()));

    // Make sure we can remove composers as we see fit.
    for (ComposerList::iterator i = m_composers.begin(); 
         i != m_composers.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listComposers.push_back(*i);
    }

    for (i = listComposers.begin(); i != listComposers.end(); i++)
    {
        IGNORE_RETURN((*i)->UpdateFragments());
        if (QueryReleaseComposer(*i))
        {
            // Remove this composer from the original list.
            (*i)->Release();
            RemoveComposer(*i);
        }
    }

    for (i = listComposers.begin(); i != listComposers.end(); i++)
    {
        IGNORE_RETURN((*i)->Release());
    }
    listComposers.clear();

    // If we have no active composers, we might as well unregister ourselves.
    if (0 == m_composers.size())
    {
        UnregisterSite();
    }
} // CAnimationComposerSite::UpdateAnimations

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::ComposerSiteDetach
//
//  Overview:  The animation root is going away.  Time to off our reference to it.
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CAnimationComposerSite::ComposerSiteDetach (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::AnimationComposerSiteDetach()",
              this));

    // Let go of our cached anim root reference.
    m_spAnimationRoot.Release();
} // CAnimationComposerSite::ComposerSiteDetach
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\filtercomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "timeparser.h"
#include "animcomp.h"
#include "filtercomp.h"
#include "transworker.h"
#include "targetpxy.h"
#include "filterpxy.h"

DeclareTag(tagAnimationFilterComposer, "SMIL Animation", 
           "CAnimationFilterComposer methods");

DeclareTag(tagAnimationFilterComposerProcess, "SMIL Animation", 
           "CAnimationFilterComposer pre/post process methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT 
CAnimationFilterComposer::Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                                 IAnimationComposer **ppiComp)
{
    HRESULT hr = S_OK;

    CComObject<CAnimationFilterComposer> *pNew = NULL;
    hr = THR(CComObject<CAnimationFilterComposer>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiComp)));
    if (FAILED(hr))
    {
        pNew->Release();
        hr = E_UNEXPECTED;
        goto done;
    }

    Assert(NULL != (*ppiComp));

    hr = (*ppiComp)->ComposerInit(pidispHostElem, bstrAttributeName);
    if (FAILED(hr))
    {
        (*ppiComp)->Release();
        *ppiComp = NULL;
        goto done;
    }

    hr = S_OK;
done :

    RRETURN3(hr, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationFilterComposer::Create

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::CAnimationFilterComposer
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFilterComposer::CAnimationFilterComposer (void)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::CAnimationFilterComposer()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::~CAnimationFilterComposer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFilterComposer::~CAnimationFilterComposer (void)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::~CAnimationFilterComposer()",
              this));
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::QueryFragmentForParameters
//
//  Overview:  Pull the filter parameters from the incoming fragment.
//
//  Arguments: The dispatch of the fragment, and the variants holding the 
//             respective filter attributes and custom parameters.
//
//------------------------------------------------------------------------
HRESULT
CAnimationFilterComposer::QueryFragmentForParameters (IDispatch *pidispFragment,
                                                      VARIANT *pvarType, 
                                                      VARIANT *pvarSubtype,
                                                      VARIANT *pvarMode,
                                                      VARIANT *pvarFadeColor,
                                                      VARIANT *pvarParams)
{
    HRESULT hr = S_OK;

    // Find the filter properties on the fragment
    {
        CComVariant varElem;

        //  Get the fragment's element
        hr = THR(GetProperty(pidispFragment, WZ_FRAGMENT_ELEMENT_PROPERTY_NAME, &varElem));
        if (FAILED(hr))
        {
            goto done;
        }

        //  Get the filter properties from the fragment's element
        Assert(VT_DISPATCH == V_VT(&varElem));
        if (VT_DISPATCH != V_VT(&varElem))
        {
            hr = E_UNEXPECTED;
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_TYPE, pvarType));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_SUBTYPE, pvarSubtype));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_MODE, pvarMode));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_FADECOLOR, pvarFadeColor));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    // ## ISSUE Pull the custom parameters from the fragment
    //  Find the time behavior dispatch
    //  Query for the IFilterAnimationInfo interface and ask for the parameters from that
    ::VariantClear(pvarParams);

    hr = S_OK;
done :
    RRETURN(hr);
} // QueryFragmentForParameters

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::ComposerInitFromFragment
//
//  Overview:  Tells the composer to initialize itself
//
//  Arguments: The dispatch of the host element, the animated attribute, 
//             and the fragment we can query for filter parameters from.
//
//  Returns:   S_OK, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFilterComposer::ComposerInitFromFragment (IDispatch *pidispHostElem, 
                                                    BSTR bstrAttributeName, 
                                                    IDispatch *pidispFragment)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::ComposerInitFromFragment(%p, %ls, %p)",
              this, pidispHostElem, bstrAttributeName, pidispFragment));

    HRESULT hr;

    hr = THR(PutAttribute(bstrAttributeName));
    if (FAILED(hr))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = QueryFragmentForParameters(pidispFragment,
                                    &m_varType, &m_varSubtype, 
                                    &m_varMode, &m_varFadeColor,
                                    &m_varParams);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CFilterTargetProxy::Create(pidispHostElem, 
                                        m_varType, m_varSubtype, 
                                        m_varMode, m_varFadeColor,
                                        m_varParams,
                                        &m_pcTargetProxy));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pcTargetProxy);

    hr = S_OK;
done :
    
    if (FAILED(hr))
    {
        IGNORE_HR(ComposerDetach());
    }

    RRETURN(hr);
} // CAnimationFilterComposer::ComposerInit

//+-----------------------------------------------------------------------
//
//  Member:    MatchStringVariant
//
//  Overview:  Case-insensitive compare of two variants 
//
//  Returns:   boolean
//
//------------------------------------------------------------------------
static bool
MatchStringVariant (VARIANT *pvarLeft, VARIANT *pvarRight)
{
    bool fRet = false;

    if (   (VT_BSTR == V_VT(pvarLeft)) 
        && (VT_BSTR == V_VT(pvarRight)))
    {
        // GetProperty will return VT_BSTR with a value
        // of NULL.  For some reason StrCmpIW doesn't
        // consider these equal.
        if (   (NULL == V_BSTR(pvarLeft)) 
            && (NULL == V_BSTR(pvarRight)))
        {
            fRet = true;
        }
        else if (0 == StrCmpIW(V_BSTR(pvarLeft), V_BSTR(pvarRight)))
        {
            fRet = true;
        }
    }
    // Need to allow for two empty variants 
    else if (   (VT_EMPTY == V_VT(pvarLeft))
             && (VT_EMPTY == V_VT(pvarRight)))
    {
        fRet = true;
    }

    return fRet;
} // MatchStringVariant

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::ValidateFragmentForComposer
//
//  Overview:  Validate this fragment to make sure its attributes
//             and params match those already registered here.
//
//  Arguments: the dispatch of the new fragment
//
//------------------------------------------------------------------------
HRESULT
CAnimationFilterComposer::ValidateFragmentForComposer (IDispatch *pidispFragment)
{
    HRESULT hr = S_OK;

    {
        CComVariant varType;
        CComVariant varSubtype;
        CComVariant varMode;
        CComVariant varFadeColor;
        CComVariant varParams;

        // ## ISSUE - we will need to match this fragment's parameter settings 
        // against those of the other fragments registered here.  Assuming that
        // parameters govern a filter's visual qualities, they should be identical.
        hr = QueryFragmentForParameters(pidispFragment, 
                                        &varType, &varSubtype, 
                                        &varMode, &varFadeColor,
                                        &varParams);

        if (   (!MatchStringVariant(&varType, &m_varType)) 
            || (!MatchStringVariant(&varSubtype, &m_varSubtype))
            || (!MatchStringVariant(&varMode, &m_varMode))
            || (!MatchStringVariant(&varFadeColor, &m_varFadeColor))
           )
        {
            hr = E_FAIL;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationFilterComposer::ValidateFragmentForComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::AddFragment
//
//  Overview:  Add a fragment to the composer's internal data structures.  
//             We will validate this fragment to make sure its attributes
//             and params match those already registered here.
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationFilterComposer::AddFragment (IDispatch *pidispNewAnimationFragment)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::AddFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr = S_OK;

    hr = ValidateFragmentForComposer(pidispNewAnimationFragment);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CAnimationComposerBase::AddFragment(pidispNewAnimationFragment));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationFilterComposer::AddFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::InsertFragment
//
//  Overview:  Insert a fragment to the composer's internal data structures,
//             at the specified position.
//             We will validate this fragment to make sure its attributes
//             and params match those already registered here.
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationFilterComposer::InsertFragment (IDispatch *pidispNewAnimationFragment, VARIANT varIndex)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::InsertFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr = S_OK;

    hr = ValidateFragmentForComposer(pidispNewAnimationFragment);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CAnimationComposerBase::InsertFragment(pidispNewAnimationFragment, varIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationFilterComposer::InsertFragment
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\filterpxy.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer's Filter Proxy Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "tokens.h"
#include "animcomp.h"
#include "targetpxy.h"
#include "transworker.h"
#include "filterpxy.h"

DeclareTag(tagFilterProxy, "SMIL Animation", 
           "CFilterTargetProxy methods");
DeclareTag(tagFilterProxyValue, "SMIL Animation", 
           "CFilterTargetProxy value get/put");


//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Create
//
//  Overview:  Creates and initializes the target proxy
//
//  Arguments: The dispatch of the host element, attribute name, out param
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Create (IDispatch *pidispHostElem, 
                            VARIANT varType, VARIANT varSubtype,
                            VARIANT varMode, VARIANT varFadeColor,
                            VARIANT varParams,
                            CTargetProxy **ppCFilterTargetProxy)
{
    HRESULT hr;

    CComObject<CFilterTargetProxy> * pTProxy;

    if (NULL == ppCFilterTargetProxy)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(CComObject<CFilterTargetProxy>::CreateInstance(&pTProxy));
    if (hr != S_OK)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    *ppCFilterTargetProxy = static_cast<CFilterTargetProxy *>(pTProxy);
    (static_cast<CTargetProxy *>(*ppCFilterTargetProxy))->AddRef();

    hr = THR(pTProxy->Init(pidispHostElem, varType, varSubtype, 
                           varMode, varFadeColor, varParams));
    if (FAILED(hr))
    {
        (static_cast<CTargetProxy *>(*ppCFilterTargetProxy))->Release();
        *ppCFilterTargetProxy = NULL;
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED);
} // CFilterTargetProxy::Create

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::CFilterTargetProxy
//
//  Overview:  Constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CFilterTargetProxy::CFilterTargetProxy (void)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::CFilterTargetProxy()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::~CFilterTargetProxy
//
//  Overview:  Destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CFilterTargetProxy::~CFilterTargetProxy (void)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::~CFilterTargetProxy()",
              this));
    
    // Make sure Detach is called.
    IGNORE_HR(Detach());

} // dtor


//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::DetermineMode
//
//  Overview:  Given a variant string determine the proper 
//             quick apply type for the filter.
//
//------------------------------------------------------------------------
DXT_QUICK_APPLY_TYPE
CFilterTargetProxy::DetermineMode (VARIANT varMode)
{
    DXT_QUICK_APPLY_TYPE dxtQAT = DXTQAT_TransitionIn;

    if (   (VT_BSTR == V_VT(&varMode)) 
        && (NULL != V_BSTR(&varMode))
        && (0 == StrCmpIW(V_BSTR(&varMode), WZ_TRANSITION_MODE_OUT)))
    {
        dxtQAT = DXTQAT_TransitionOut;
    }

    return dxtQAT;
} // CFilterTargetProxy::DetermineMode


//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Init
//
//  Overview:  Initialize the target proxy
//
//  Arguments: the host element dispatch, type/subtype name
//
//  Returns:   S_OK, E_UNEXPECTED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Init (IDispatch *pidispHostElem, 
                          VARIANT varType, VARIANT varSubtype, 
                          VARIANT varMode, VARIANT varFadeColor,
                          VARIANT varParams)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::Init (%p, %ls, %ls)",
              this, pidispHostElem, V_BSTR(&varType), V_BSTR(&varSubtype)));

    HRESULT hr = S_OK;

    Assert(!m_spElem);
    if (m_spElem)
    {
        m_spElem.Release();
    }

    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &m_spElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    // Create a transition worker.  This actually creates the DXTransform, 
    // adds it to the element, and manages it in general.

    hr = THR(CreateTransitionWorker(&m_spTransitionWorker));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransitionWorker->put_transSite((ITransitionSite *)this));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransitionWorker->InitStandalone(varType, varSubtype));

    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(m_spTransitionWorker->Apply(DetermineMode(varMode)));
    IGNORE_HR(m_spTransitionWorker->OnBeginTransition());

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(Detach());
    }

    RRETURN(hr);
} // CFilterTargetProxy::Init

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Detach
//
//  Overview:  Detach all external references in the target proxy
//
//  Arguments: none
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Detach (void)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::Detach()",
              this));

    HRESULT hr = S_OK;

    if (m_spTransitionWorker)
    {
        IGNORE_HR(m_spTransitionWorker->OnEndTransition());
        m_spTransitionWorker->Detach();
        m_spTransitionWorker.Release();
    }
    if (m_spElem)
    {
        m_spElem.Release();
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CFilterTargetProxy::Detach

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::GetCurrentValue
//
//  Overview:  Get the current value of target's attribute
//
//  Arguments: the attribute value
//
//  Returns:   S_OK, E_INVALIDARG, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::GetCurrentValue (VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (NULL == pvarValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!m_spTransitionWorker)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    {
        double dblProgress = 0;0;
     
        hr = THR(m_spTransitionWorker->get_progress(&dblProgress));
        if (FAILED(hr))
        {
            goto done;
        }
        ::VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = dblProgress;
    }

    hr = S_OK;

done :
    RRETURN2(hr, E_INVALIDARG, E_UNEXPECTED);
} // CFilterTargetProxy::GetCurrentValue

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Update
//
//  Overview:  Update the target's attribute
//
//  Arguments: the new attribute value
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Update (VARIANT *pvarNewValue)
{
    HRESULT hr = S_OK;

    if (NULL == pvarNewValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    if (VT_R8 != V_VT(pvarNewValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // Clamp the values to between [0..1].
    V_R8(pvarNewValue) = Clamp(0.0, V_R8(pvarNewValue), 1.0);

    {
        hr = THR(m_spTransitionWorker->put_progress(V_R8(pvarNewValue)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // CFilterTargetProxy::Update

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::get_htmlElement, ITransitionSite
//
//  Overview:  Get the host html element for this transition
//
//  Arguments: the outgoing element
//
//------------------------------------------------------------------------
STDMETHODIMP
CFilterTargetProxy::get_htmlElement (IHTMLElement ** ppHTMLElement)
{
    HRESULT hr = S_OK;

    if (NULL == ppHTMLElement)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!m_spElem)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    m_spElem.p->AddRef();
    *ppHTMLElement = m_spElem.p;

    hr = S_OK;
done :
    RRETURN(hr);
} // get_htmlElement

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::get_template, ITransitionSite
//
//  Overview:  Get the transition template (does not apply here)
//
//  Arguments: the outgoing template element
//
//------------------------------------------------------------------------
STDMETHODIMP 
CFilterTargetProxy::get_template (IHTMLElement ** ppHTMLElement)
{
    return S_FALSE;
} // get_template
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\defcomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Default Animation Composer.

*******************************************************************************/

#pragma once

#ifndef _DEFCOMP_H
#define _DEFCOMP_H

class __declspec(uuid("5FAD79F0-D40C-4df3-B334-7292FE80E664"))
ATL_NO_VTABLE CAnimationComposer
    : public CComCoClass<CAnimationComposer, &__uuidof(CAnimationComposer)>,
      public CAnimationComposerBase
{

  public:

    CAnimationComposer (void);
    virtual ~CAnimationComposer (void);

    DECLARE_NOT_AGGREGATABLE(CAnimationComposer)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposer"); }
#endif

    static HRESULT Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                           IAnimationComposer **ppiComp);

  protected :

};

#endif /* _DEFCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\sitefact.cpp ===
/*******************************************************************************
 *                                                                              
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Abstract:
 *
 *******************************************************************************/

#include "headers.h"
#include "sitefact.h"
#include "tokens.h"
#include "array.h"
#include "util.h"
#include "basebvr.h"
#include "compsite.h"

DeclareTag(tagAnimCompSiteFactory, "SMILANIM", "CAnimationComposerSiteFactory methods");

// ----------------------------------------------------------------------------------------

CAnimationComposerSiteFactory::CAnimationComposerSiteFactory (void)
: m_dwSafety(0)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::CAnimationComposerSiteFactory()",
              this));
} // CAnimationComposerSiteFactory::CAnimationComposerSiteFactory

// ----------------------------------------------------------------------------------------

CAnimationComposerSiteFactory::~CAnimationComposerSiteFactory (void)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::~CAnimationComposerSiteFactory()",
              this));
} // CAnimationComposerSiteFactory::~CAnimationComposerSiteFactory

// ----------------------------------------------------------------------------------------

HRESULT
CAnimationComposerSiteFactory::Error (void)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::Error()",
              this));

    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CAnimationComposerSiteFactory, &CLSID_AnimationComposerSiteFactory>::Error(str, IID_IAnimationComposerSiteFactory, hr);
        delete [] str;
    }
        
    return hr;
} // CAnimationComposerSiteFactory::Error

// ----------------------------------------------------------------------------------------

STDMETHODIMP 
CAnimationComposerSiteFactory::FindBehavior(BSTR bstrBehavior,
                                            BSTR bstrBehaviorURL,
                                            IElementBehaviorSite * pUnkArg,
                                            IElementBehavior ** ppBehavior)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::FindBehavior(%ls, %ls, %#x)",
              this, bstrBehavior, bstrBehaviorURL, pUnkArg));

    CHECK_RETURN_SET_NULL(ppBehavior);
    
    HRESULT hr;

    CComObject<CAnimationComposerSite> *pNew;
    hr = THR(CComObject<CAnimationComposerSite>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IElementBehavior, 
                                  reinterpret_cast<void **>(ppBehavior)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, E_UNEXPECTED);
} // CAnimationComposerSiteFactory::FindBehavior

// ----------------------------------------------------------------------------------------

STDMETHODIMP 
CAnimationComposerSiteFactory::GetInterfaceSafetyOptions (REFIID riid, 
                                                          DWORD *pdwSupportedOptions, 
                                                          DWORD *pdwEnabledOptions)
{
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;

    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag2 )
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    
    RRETURN1(hr, E_NOINTERFACE);
} // CAnimationComposerSiteFactory::GetInterfaceSafetyOptions

// ----------------------------------------------------------------------------------------

STDMETHODIMP
CAnimationComposerSiteFactory::SetInterfaceSafetyOptions (REFIID riid, 
                                                          DWORD dwOptionSetMask, 
                                                          DWORD dwEnabledOptions)
{       
    HRESULT hr;

    // If we're being asked to set our safe for scripting or
    // safe for initialization options then oblige
    if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
    {
            // Store our current safety level to return in GetInterfaceSafetyOptions
            m_dwSafety = dwEnabledOptions & dwOptionSetMask;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_NOINTERFACE);
} // CAnimationComposerSiteFactory::SetInterfaceSafetyOptions

// ----------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\filterpxy.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Abstract:

    Animation Composer's Target Proxy for filters.

*******************************************************************************/

#pragma once

#ifndef _FILTERPXY_H
#define _FILTERPXY_H

interface ITransitionWorker;
class CTargetProxy;

// The filter target proxy abstracts the communication with the target 
// object.  
class CFilterTargetProxy : 
    public CTargetProxy,
    public ITransitionSite
{

 public :

    static HRESULT Create (IDispatch *pidispHostElem, 
                           VARIANT varType, VARIANT varSubtype, 
                           VARIANT varMode, VARIANT varFadeColor,
                           VARIANT varParams,
                           CTargetProxy **ppCFilterTargetProxy);

    virtual ~CFilterTargetProxy (void);

    // ITransitionSite methods
    STDMETHOD(get_htmlElement)(IHTMLElement ** ppHTMLElement);
    STDMETHOD(get_template)(IHTMLElement ** ppHTMLElement);

    // CTargetProxy overrides.
    virtual HRESULT Detach (void);
    virtual HRESULT GetCurrentValue (VARIANT *pvarValue);
    virtual HRESULT Update (VARIANT *pvarNewValue);

#if DBG
    const _TCHAR * GetName() { return __T("CFilterTargetProxy"); }
#endif

        // QI Map
    BEGIN_COM_MAP(CTargetProxy)
        COM_INTERFACE_ENTRY2(IUnknown, CTargetProxy)
    END_COM_MAP();

 // Internal Methods
 protected :
    
    CFilterTargetProxy (void);
    HRESULT Init (IDispatch *pidispSite, 
                  VARIANT varType, VARIANT varSubtype, 
                  VARIANT varMode, VARIANT varFadeColor,
                  VARIANT varParams);

    DXT_QUICK_APPLY_TYPE DetermineMode (VARIANT varMode);

  // Data
 protected:


    // A transition worker manages the DXTransform attached to our host 
    // element.

    CComPtr<ITransitionWorker>  m_spTransitionWorker;
    CComPtr<IHTMLElement> m_spElem;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\fragenum.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Fragment Enumerator Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcomp.h"
#include "fragenum.h"

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The composer containing the fragments we will enumerate
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CFragmentEnum::Create (CAnimationComposerBase &refComp,
                       IEnumVARIANT **ppienumFragments, 
                       unsigned long ulCurrent)
{
    HRESULT hr;

    CComObject<CFragmentEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(ppienumFragments);

    hr = THR(CComObject<CFragmentEnum>::CreateInstance(&pNewEnum));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(refComp);
    pNewEnum->SetCurrent(ulCurrent);

    hr = THR(pNewEnum->QueryInterface(IID_TO_PPV(IEnumVARIANT, ppienumFragments)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // Create

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::CFragmentEnum
//
//  Overview:  ctor
//
//------------------------------------------------------------------------
CFragmentEnum::CFragmentEnum (void) :
    m_ulCurElement(0)
{
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::CFragmentEnum
//
//  Overview:  dtor
//
//------------------------------------------------------------------------
CFragmentEnum::~CFragmentEnum (void)
{
} // dtor

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::ValidateIndex
//
//  Overview:  Make sure an index is within the range of accepted values.
//
//  Arguments: index
//
//  Returns:   true on success
//
//------------------------------------------------------------------------
bool
CFragmentEnum::ValidateIndex (unsigned long ulIndex)
{
    bool bRet = false;

    if (m_spComp == NULL)
    {
        goto done;
    }

    if (m_spComp->GetFragmentCount() <= ulIndex)
    {
        goto done;
    }

    bRet = true;
done :
    return bRet;
} // CFragmentEnum::ValidateIndex

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::SetCurrent
//
//  Overview:  Set the current location to the specified index
//
//  Arguments: The new index
//
//  Returns:   true on success
//
//------------------------------------------------------------------------
bool
CFragmentEnum::SetCurrent (unsigned long ulCurrent)
{
    bool bRet = false;

    // If the new index is out of range, put us right at the end.
    if (!ValidateIndex(ulCurrent))
    {
        ulCurrent = m_spComp->GetFragmentCount();
    }

    m_ulCurElement = ulCurrent;

    bRet = true;
done :
    return bRet;
} // SetCurrent

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Reset
//
//  Overview:  Reset the current location to the beginning
//
//  Arguments: None
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Reset (void)
{
    m_ulCurElement = 0;
    RRETURN(S_OK);
} // Reset

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Clone
//
//  Overview:  Clone this enumerator
//
//  Arguments: The new enumerator
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Clone (IEnumVARIANT **ppEnum)
{
    HRESULT hr;

    hr = CFragmentEnum::Create(*m_spComp, ppEnum, m_ulCurElement);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // Reset

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Skip
//
//  Overview:  Move the current location forward lIndex slots
//
//  Arguments: The index delta
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Skip (unsigned long celt)
{
    HRESULT hr;
    
    // Try setting the location to the desired slot.  This
    // will fail if it will cause us to walk off the end of the 
    // sequence.
    if (!SetCurrent(m_ulCurElement + celt))
    {
        if (m_spComp)
        {
            // If we've got zero items, keep the location there.
            // Otherwise set the location to the last item in
            // the sequence.
            unsigned long ulNew = m_spComp->GetFragmentCount();

            if (0 < ulNew)
            {
                ulNew--;
            }

            IGNORE_RETURN(SetCurrent(ulNew));
        }
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, S_FALSE);
} // Reset

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Next
//
//  Overview:  Get the next celt items from the enumeration sequence.
//
//  Arguments: celt : number requested
//             rgVar : array of celt variants in which elements are returned
//             pCeltFetched : a pointer to a location in which the number
//                            actually retrieved is returned.
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Next (unsigned long celt, VARIANT *prgVar, unsigned long *pCeltFetched)
{
    HRESULT hr;
    unsigned long i = 0;

    if (!m_spComp)
    {
        hr = E_FAIL;
        goto done;
    }

    for (i = 0; i < celt; i++)
    {
        CComPtr<IDispatch> spDisp;

        if (!ValidateIndex(m_ulCurElement))
        {
            hr = S_FALSE;
            goto done;
        }

        hr = THR(m_spComp->GetFragment(m_ulCurElement, &spDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        spDisp.p->AddRef();
        V_DISPATCH(&(prgVar[i])) = spDisp;
        V_VT(&(prgVar[i])) = VT_DISPATCH;

        m_ulCurElement++;
    }

    hr = S_OK;
done :    
    if (NULL != pCeltFetched)
    {
        *pCeltFetched = i;
    }

    RRETURN1(hr, S_FALSE);
} // Reset
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\sitefact.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Composer Site factory

*******************************************************************************/

#pragma once

#ifndef _COMPSITEFACTORY_H
#define _COMPSITEFACTORY_H

class ATL_NO_VTABLE CAnimationComposerSiteFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CAnimationComposerSiteFactory, &CLSID_AnimationComposerSiteFactory>,
      public ITIMEDispatchImpl<IAnimationComposerSiteFactory, &IID_IAnimationComposerSiteFactory>,
      public ISupportErrorInfoImpl<&IID_IAnimationComposerSiteFactory>,
      public IElementBehaviorFactory,
      public IObjectSafety
{
  public:
    CAnimationComposerSiteFactory();
    virtual ~CAnimationComposerSiteFactory();

    DECLARE_NOT_AGGREGATABLE(CAnimationComposerSiteFactory)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposerSiteFactory"); }
#endif

    // IElementBehaviorFactory
    
    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IElementBehaviorSite * pUnkArg,
                            IElementBehavior ** ppBehavior);

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(
        /* [in] */ REFIID riid,
        /* [in] */ DWORD dwOptionSetMask,
        /* [in] */ DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(
        /* [in] */ REFIID riid, 
        /* [out] */DWORD *pdwSupportedOptions, 
        /* [out] */DWORD *pdwEnabledOptions);
    
    DECLARE_REGISTRY(CLSID_AnimationComposerSiteFactory,
                     LIBID __T(".SMILAnimCompSiteFactory.1"),
                     LIBID __T(".SMILAnimCompSiteFactory"),
                     0,
                     THREADFLAGS_BOTH);
    
    BEGIN_COM_MAP(CAnimationComposerSiteFactory)
        COM_INTERFACE_ENTRY(IAnimationComposerSiteFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    END_COM_MAP();

    HRESULT Error();

  protected:

    DWORD m_dwSafety;

};

#endif /* _COMPSITEFACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\fragenum.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Fragment Enumerator.

*******************************************************************************/

#pragma once

#ifndef _FRAGENUM_H
#define _FRAGENUM_H

class CFragmentEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{

  public:

    CFragmentEnum (void);
    virtual ~CFragmentEnum (void);

    static HRESULT Create (CAnimationComposerBase &refComp, 
                           IEnumVARIANT **ppienumFragments,
                           unsigned long ulCurrent = 0);

    void Init (CAnimationComposerBase &refComp) 
        { m_spComp = &refComp; }
    bool SetCurrent (unsigned long ulCurrent);
    
    // IEnumVARIANT methods
    STDMETHOD(Clone) (IEnumVARIANT **ppEnum);
    STDMETHOD(Next) (unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
    STDMETHOD(Reset) (void);
    STDMETHOD(Skip) (unsigned long celt);
                        
    // QI Map
    BEGIN_COM_MAP(CFragmentEnum)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP();

  protected:

    bool ValidateIndex (unsigned long ulIndex);

    unsigned long                       m_ulCurElement;
    CComPtr<CAnimationComposerBase>     m_spComp;

}; //lint !e1712

#endif // _FRAGENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\smilpath.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: smilpath.cpp
//
//  Contents: SMIL path
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "smilpath.h"
#include "animmotion.h"

DeclareTag(tagSMILPath, "SMIL Animation", "SMIL Path")


//+-------------------------------------------------------------------------------------
//
// CSMILPath factory method
//
//--------------------------------------------------------------------------------------

HRESULT CreateSMILPath(CTIMEMotionAnimation * pAnimElm, ISMILPath ** ppSMILPath)
{
    HRESULT hr = E_FAIL;
    CSMILPath * pPath = NULL;
    
    CHECK_RETURN_NULL(pAnimElm);
    CHECK_RETURN_SET_NULL(ppSMILPath);

    pPath = new CSMILPath;
    if (NULL == pPath)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pPath->Init(pAnimElm));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pPath->QueryInterface(IID_TO_PPV(ISMILPath, ppSMILPath)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        delete pPath;
    }
    return hr;
}


//+-------------------------------------------------------------------------------------
//
// CSMILPath Methods
//
//--------------------------------------------------------------------------------------

CSMILPath::CSMILPath() :
    m_numPath(0),
    m_numMOVETO(0),
    m_pSegmentMap(NULL),
    m_pLengthMap(NULL),
    m_pPath(NULL),
    m_pAnimElm(NULL),
    m_cRef(0)
{

}

CSMILPath::~CSMILPath()
{
    CSMILPath::ClearPath();
}


STDMETHODIMP
CSMILPath::Init(CTIMEMotionAnimation * pAnimElm)
{
    Assert(pAnimElm);

    m_pAnimElm = pAnimElm;

    return S_OK;
}

STDMETHODIMP
CSMILPath::Detach()
{
    m_pAnimElm = NULL;

    return S_OK;
}


STDMETHODIMP_(void)
CSMILPath::ClearPath()
{
    // delete the points
    if (m_pPath  != NULL &&
        *m_pPath != NULL)
    {
        for (int i = 0; i < m_numPath; i++)
        {
            delete m_pPath[i];
        }

        delete [] m_pPath;
        m_pPath = NULL;
    } 

    // clear the maps
    ClearSegmentMap();
    ClearLengthMap();
    
    // reset counts
    m_numPath = 0;
    m_numMOVETO = 0;
}


LPWSTR 
CSMILPath::GetID() 
{ 
    if (m_pAnimElm)
    {   
        return m_pAnimElm->GetID();
    }
    else
    {
        return NULL;
    }
}


STDMETHODIMP
CSMILPath::SetPath(CTIMEPath ** pPath, long numPath, long numMoveTo)
{
    HRESULT hr = E_FAIL;

    // clear the existing path
    ClearPath();

    // skip invalid paths
    // ASSUMES path always starts with a moveto, so there must at least be two points in a valid path
    if (!pPath            ||         // need points
        (numPath < 2)     ||         // need at least two points
        (numMoveTo < 1)   ||         // need at least 1 moveto
        ((numPath - numMoveTo) < 1)) // need at least one segment
    {
        hr = E_FAIL;
        goto done;
    }
    else
    {
        Assert(!m_pPath);
        Assert(!m_numPath);
        Assert(!m_numMOVETO);

        m_pPath = pPath;
        m_numPath = numPath;
        m_numMOVETO = numMoveTo;
    }

    TraceTag((tagSMILPath, "End of Parsed path: (%d)",
        PrintPath(numPath, numMoveTo, pPath)));

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CSMILPath::GetSegmentProgress(double dblProgress, int * pnSeg, double * pdblSegProgress)
{
    HRESULT hr = E_FAIL;
    long curSeg = 0;
    double curFractionalSeg = 0.0;
    double curProgress = 0.0;
    
    CHECK_RETURN_NULL(pnSeg);
    CHECK_RETURN_NULL(pdblSegProgress);

    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // get the fractional segment number
    curFractionalSeg = dblProgress * GetNumSeg();

    // get the (integer) segment number
    curSeg = static_cast<int>(curFractionalSeg);

    // get the progress in the current segment
    curProgress = curFractionalSeg - curSeg;

    hr = S_OK;
done:
    *pnSeg = curSeg;
    *pdblSegProgress = curProgress;

    return hr;
}


STDMETHODIMP
CSMILPath::Interpolate(double dblProgress, POINTF * pPoint)
{
    HRESULT hr = E_FAIL;
    int curSeg;
    double curProgress;
    
    CHECK_RETURN_NULL(pPoint);

    hr = THR(GetSegmentProgress(dblProgress, &curSeg, &curProgress));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(InterpolateSegment(curSeg, curProgress, pPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::Interpolate(prog=%g newPos={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            dblProgress,
            pPoint->x,
            pPoint->y
            ));

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CSMILPath::InterpolatePaced(double dblProgress, POINTF * pPoint)
{
    HRESULT hr = E_FAIL;
    int curSeg;
    int numSeg;
    double dblCumLength;
    double dblCurDistance;
    double dblCurProgress;
    double dblPrevCumLength;
    
    CHECK_RETURN_NULL(pPoint);

    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // clamp the progress
    dblProgress = Clamp(0.0, dblProgress, 1.0);

    dblCurDistance = dblProgress * GetLength();

    numSeg = GetNumSeg();

    // find the current segment
    for (curSeg = 0; curSeg < numSeg; curSeg++)
    {
        //
        // dilipk this should be a binary search (ie6 bug #14216)
        //

        dblCumLength = 0.0;

        hr = THR(GetCumulativeLength(curSeg, dblCumLength));
        if (FAILED(hr))
        {
            goto done;
        }

        if (dblCurDistance <= dblCumLength)
        {
            break;
        }
    }

    dblPrevCumLength = 0.0;

    if (curSeg > 0)
    {
        hr = THR(GetCumulativeLength(curSeg-1, dblPrevCumLength));
        if (FAILED(hr))
        {
            goto done;
        }
    }
        
    dblCurProgress = (dblCurDistance - dblPrevCumLength) / (dblCumLength - dblPrevCumLength);

    //
    //      dilipk: using linear sampling within bezier curve segments. This is an approximation
    //      that works reasonably well for bezier curves without sharp changes in curvature or when
    //      control points are relatively uniform in spacing.
    //      To do this the right way when the above assumptions are not valid, we need to integrate 
    //      along the length of the curve for each interpolation (unless we cache values). This could 
    //      be expensive and we should consider if we feel this is worth the added computation.
    //

    hr = THR(InterpolateSegment(curSeg, dblCurProgress, pPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::InterpolatePaced(prog=%g newPos={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            dblProgress,
            pPoint->x,
            pPoint->y
            ));

    hr = S_OK;
done:
    return hr;
}

double 
CSMILPath::GetLength()
{
    double dblLength = 0;
    HRESULT hr = E_FAIL;

    if (!IsPathValid())
    {
        goto done;
    }
    
    hr = THR(GetCumulativeLength(GetNumSeg(), dblLength));  
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return dblLength;
}


inline
bool 
CSMILPath::IsPathValid()
{
    // path is already validated in SetPath. Need only check m_pPath
    return (m_pPath ? true : false);
}


inline
void 
CSMILPath::ClearLengthMap()
{
    delete [] m_pLengthMap;
    m_pLengthMap = NULL;
}


inline
void 
CSMILPath::ClearSegmentMap()
{
    delete [] m_pSegmentMap;
    m_pSegmentMap = NULL;
}


double
CSMILPath::GetDistance(POINTF & p1, POINTF & p2)
{
    double dX = (p1.x - p2.x);
    double dY = (p1.y - p2.y);
    return sqrt((dX*dX) + (dY*dY));  
}


double 
CSMILPath::GetBezierLength(POINTF & startPoint, POINTF * pts)
{
    //
    //        ISSUE : this is not the best way to do this. To avoid wasted computations for sub-pixel segments,
    //        number of segments should be adaptive to the segment length
    //

    POINTF lastPoint = startPoint;
    double dblDistance = 0;

    for (double seg = 0.01; seg <= 1.0; seg += 0.01)
    {
        POINTF curPoint = CubicBezier(startPoint, pts, seg);
        dblDistance += GetDistance(lastPoint, curPoint);
        lastPoint = curPoint;
    }

    return dblDistance;
}


HRESULT
CSMILPath::GetCumulativeLength(int seg, double & segLength)
{
    HRESULT hr = E_FAIL;

    if (!m_pLengthMap)
    {
        hr = THR(CreateLengthMap());
        if (FAILED(hr))
        {
            goto done;
        }

        // sanity check
        if (!m_pLengthMap)
        {
            Assert(false);
            hr = E_FAIL;
            goto done;
        }
    }

    // clamp seg to within path
    seg = Clamp(0, seg, GetNumSeg()-1);

    // look up cumulative length
    segLength = m_pLengthMap[seg];

    hr = S_OK;
done:
    return hr;
}


HRESULT 
CSMILPath::ComputeSegmentLength(int seg, double & segLength)
{
    HRESULT hr = E_FAIL;
    int startIndex = 0;
    int endIndex = 0;
    POINTF startPoint = {0.0, 0.0};
    POINTF endPoint = {0.0, 0.0};
    POINTF * pts = NULL;

    // get start and end point indices
    hr = THR(GetSegmentEndPoints(seg, startIndex, endIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the start point
    hr = THR(GetPoint(startIndex, &startPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the end point and length
    if (PathBezier == m_pPath[endIndex]->GetType())
    {
        pts = m_pPath[endIndex]->GetPoints();
        if (NULL == pts)
        {
            hr = E_FAIL;
            goto done;
        }

        segLength = GetBezierLength(startPoint, pts);
    }
    else
    {
        // get the end point
        hr = THR(GetPoint(endIndex, &endPoint));
        if (FAILED(hr))
        {
            goto done;
        }

        segLength = GetDistance(startPoint, endPoint);
    }

    hr = S_OK; 
done:
    delete [] pts;
    return hr;
}


HRESULT
CSMILPath::CreateLengthMap()
{
    HRESULT hr = E_FAIL;
    int i;
    int numSeg;

    // delete the old map
    ClearLengthMap();

    // bail if path is invalid
    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // compute the number of segments
    numSeg = GetNumSeg();
    
    // allocate the map
    m_pLengthMap = new double [numSeg];
    if (!m_pLengthMap)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    for (i = 0; i < numSeg; i++)
    {
        double segLength = 0.0;

        hr = THR(ComputeSegmentLength(i, segLength));
        if (FAILED(hr))
        {
            goto done;
        }
        
        // compute the cumulative length
        m_pLengthMap[i] = segLength + (i > 0 ? m_pLengthMap[i-1] : 0);        
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        ClearLengthMap();
    }

    return hr;
}


//
// Creates a mapping between segment number and (index of) the start-point of the segment in the m_pPath array
//
// ASSUMES path always starts with a moveto
//
// -1 indicates no mapping
HRESULT
CSMILPath::CreateSegmentMap()
{
    HRESULT hr = E_FAIL;
    int i;
    int curSeg;
    int numSeg;

    // delete the old map
    ClearSegmentMap();

    // bail if path is invalid
    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // compute the number of segments
    numSeg = GetNumSeg();

    // alloc the new map
    m_pSegmentMap = new int [numSeg];
    if (!m_pSegmentMap)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    //
    // compute the mapping 
    // 

    for (curSeg = -1, i = 1; i < m_numPath; i++)
    {
        // map the segment number to (index of) it's start-point in the points array
        // The logic is that the end-point of a segment cannot be a move-to
        // so we skip all move-to's
        if (PathMoveTo == m_pPath[i]->GetType())
        {
            continue;
        }
        else
        {
            curSeg++;
            
            // subtract 1 because we are testing for the end-point of the segment
            if (curSeg < numSeg)
            {
                m_pSegmentMap[curSeg] = i - 1;
            }
            else
            {
                // this shouldn't happen
                Assert(false);
            }
        }
    }

    if (-1 == curSeg)
    {
        // something is really wrong
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:

    if (FAILED(hr))
    {
        ClearSegmentMap();
    }

    return hr;
}


// assumes zero-based segment numbers
HRESULT
CSMILPath::MapSegment(int seg, int & index)
{
    HRESULT hr = E_FAIL;
    int numSeg;

    // bail if path is invalid
    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // bail if seg is invalid
    numSeg = GetNumSeg();
    if (0 == numSeg)
    {
        hr = E_FAIL;
        goto done;
    }

    // create the segment map if it doesn't exist
    if (!m_pSegmentMap)
    {
        hr = THR(CreateSegmentMap());
        if (FAILED(hr))
        {
            goto done;
        }

        if (!m_pSegmentMap)
        {
            Assert(false);
            hr = E_FAIL;
            goto done;
        }
    }

    // clamp seg to within path
    seg = Clamp(0, seg, numSeg-1);

    index = m_pSegmentMap[seg];

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::MapSegment(seg=%d, index=%d)",
            this, 
            (GetID()?GetID():L"No id"), 
            seg,
            index
            ));

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CSMILPath::GetPoint(int nIndex, POINTF * pPoint)
{
    HRESULT hr = E_FAIL;
    PathType pt;
    POINTF * pts = NULL;
    int i;

    CHECK_RETURN_NULL(pPoint);

    nIndex = Clamp(0, nIndex, m_numPath - 1);

    pPoint->x = pPoint->y = 0.0;
    pt = m_pPath[nIndex]->GetType();
    pts = m_pPath[nIndex]->GetPoints();

    switch(pt)
    {
        case PathLineTo: 
        case PathHorizontalLineTo: 
        case PathVerticalLineTo: 
        case PathMoveTo:
            if (NULL != pts)
            {
                *pPoint = pts[0];
            }
            else
            {
                hr = E_FAIL;
                goto done;
            }
            break;

        case PathBezier:
            if (NULL != pts)
            {
                *pPoint = pts[2];
            }
            else
            {
                hr = E_FAIL;
                goto done;
            }
            break;

        case PathClosePath:
            {
                // This like a LineTo to the beginning of the subpath
                // so return the coordinates for the beginning of the subpath

                //
                // TODO: dilipk: compute and store point during parsing to eliminate this recomputation
                //

                // scan backwards for the beginning of the subpath
                for (i = nIndex - 1; i >= 0; i --)
                {
                    if (PathMoveTo == m_pPath[i]->GetType())
                    {
                        hr = THR(GetPoint(i, pPoint));
                        if (FAILED(hr))
                        {
                            goto done;
                        }
                        // break out of the for loop
                        break;
                    }
                }
                
                // sanity check to make sure we found a preceeding move-to. This has to exist because
                // all paths begin with a move-to.
                if (i < 0)
                {
                    Assert(false);
                    hr = E_FAIL;
                    goto done;
                }
            }
            break;

        case PathNotSet:
        default:
            hr = E_FAIL;
            goto done;
            break; //lint !e527
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::GetPoint(nIndex=%d, point={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            nIndex,
            pPoint->x,
            pPoint->y
            ));

    hr = S_OK;
done:
    delete [] pts;
    return hr;
}


POINTF 
CSMILPath::CubicBezier(POINTF ptStart, POINTF *aryPoints, double curPorgress)
{
    double cpm1,cpm13,cp3;
    double x,y;
    POINTF p,p1,p4;
    // This should either be to ORIG or the origin as specified.
    p1.x = ptStart.x;
    p1.y = ptStart.y;
    p4.x = aryPoints[2].x;
    p4.y = aryPoints[2].y;

    cpm1 = 1 - curPorgress;
    cpm13 = cpm1 * cpm1 * cpm1;
    cp3 = curPorgress * curPorgress * curPorgress;

    x = (cpm13*p1.x + 3*curPorgress*cpm1*cpm1*aryPoints[0].x + 3*curPorgress*curPorgress*cpm1*aryPoints[1].x + cp3*p4.x);
    y = (cpm13*p1.y + 3*curPorgress*cpm1*cpm1*aryPoints[0].y + 3*curPorgress*curPorgress*cpm1*aryPoints[1].y + cp3*p4.y);

    p.x = (float) Round(x);
    p.y = (float) Round(y);
  
    return(p);
}


HRESULT 
CSMILPath::GetSegmentEndPoints(int seg, int & startIndex, int & endIndex)
{
    HRESULT hr = E_FAIL;
    
    // init the out params
    startIndex = 0;
    endIndex = 0;

    // get start point index
    hr = THR(MapSegment(seg, startIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    // check start index
    if (startIndex > (m_numPath - 2))
    {
        Assert(false);
        hr = E_FAIL;
        goto done;
    }

    // get end point index
    endIndex = startIndex + 1;

    // check end point index
    if (PathMoveTo == m_pPath[endIndex]->GetType())
    {
        Assert(false);
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK; 
done:
    return hr;
}


STDMETHODIMP
CSMILPath::InterpolateSegment(int curseg, double dblCurProgress, POINTF * pNewPos)
{
    HRESULT hr = E_FAIL;
    int startIndex = 0;
    int endIndex = 0;
    POINTF startPoint = {0.0, 0.0};
    POINTF endPoint = {0.0, 0.0};
    POINTF * pts = NULL;

    CHECK_RETURN_NULL(pNewPos);

    // clamp progress
    dblCurProgress = Clamp(0.0, dblCurProgress, 1.0);

    // get start and end point indices
    hr = THR(GetSegmentEndPoints(curseg, startIndex, endIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the start point
    hr = THR(GetPoint(startIndex, &startPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the end point and interpolate
    if (PathBezier == m_pPath[endIndex]->GetType())
    {
        pts = m_pPath[endIndex]->GetPoints();
        if (NULL == pts)
        {
            hr = E_FAIL;
            goto done;
        }

        *pNewPos = CubicBezier(startPoint, pts, (double) dblCurProgress);
    }
    else
    {
        // get the end point
        hr = THR(GetPoint(endIndex, &endPoint));
        if (FAILED(hr))
        {
            goto done;
        }

        pNewPos->x = InterpolateValues((double)(startPoint.x), 
                                     (double)(endPoint.x),
                                     dblCurProgress); //lint !e736

        pNewPos->y = InterpolateValues((double)(startPoint.y), 
                                     (double)(endPoint.y),
                                     dblCurProgress); //lint !e736
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::InterpolateSegment(curseg=%d prog=%g newPos={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            curseg,
            dblCurProgress,
            pNewPos->x,
            pNewPos->y
            ));

    hr = S_OK; 
done:
    delete [] pts;
    return hr;
}



STDMETHODIMP_(ULONG)
CSMILPath::AddRef()
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CSMILPath::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CSMILPath::QueryInterface(REFIID riid, void **ppv)
{
    CHECK_RETURN_SET_NULL(ppv);

    if (InlineIsEqualUnknown(riid))
    {
        *ppv = (void *)(IUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_ISMILPath))
    {
        *ppv = (void *)(ISMILPath *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


#if DBG
int 
CSMILPath::PrintPath(long numPath, long numMOVETO, CTIMEPath ** pPath)
{
    if (pPath)
    {
        for (int i = 0; i < numPath; i++)
        {
            if (pPath[i])
            {
                POINTF * pts = pPath[i]->GetPoints();

                switch (pPath[i]->GetType())
                {
                case PathMoveTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "M" : "m"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathLineTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "L" : "l"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathHorizontalLineTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "H" : "h"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathVerticalLineTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "V" : "v"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathClosePath:
                    {
                        TraceTag((tagSMILPath, "%s",
                            (pPath[i]->GetAbsolute() ? "Z" : "z")));
                        break;
                    }
                case PathBezier:
                    {
                        TraceTag((tagSMILPath, "%s %g %g %g %g %g %g",
                            (pPath[i]->GetAbsolute() ? "C" : "c"),
                            pts[0].x,
                            pts[0].y,
                            pts[1].x,
                            pts[1].y,
                            pts[2].x,
                            pts[2].y));
                        break;
                    }
                case PathNotSet:
                default:
                    {
                        TraceTag((tagSMILPath, "Error: Unknown Path!!"));
                        break;
                    }
                }

                delete [] pts;
            }
        }
    }

    TraceTag((tagSMILPath, "Number of points parsed   : %d", numPath));
    TraceTag((tagSMILPath, "Number of move-to's parsed: %d", numMOVETO));

    return 0;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\targetpxy.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer's Target Proxy Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcomp.h"
#include "targetpxy.h"

const LPOLESTR WZ_EVAL_METHOD = L"eval";
const WCHAR WCH_OM_SEPARATOR = L'.';
const LPOLESTR WZ_OM_SEPARATOR = L".";
const LPOLESTR WZ_VML_SUBPROPERTY = L"value";
const LPOLESTR WZ_STYLEDOT = L"style.";
const WCHAR WZ_CSS_SEPARATOR = L'-';

DeclareTag(tagTargetProxy, "SMIL Animation", 
           "CTargetProxy methods");
DeclareTag(tagTargetProxyValue, "SMIL Animation", 
           "CTargetProxy value get/put");

//+-----------------------------------------------------------------------
//
//  Member:    GetHostDocument
//
//  Overview:  Get the host document for an element
//
//  Arguments: The element's dispatch
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
static HRESULT
GetHostDocument (IDispatch *pidispHostElem, IHTMLDocument2 **ppiDoc)
{
    HRESULT hr;
    CComPtr<IHTMLElement> piElem;
    CComPtr<IDispatch> pidispDoc;

    Assert(NULL != pidispHostElem);
    Assert(NULL != ppiDoc);

    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &piElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(piElem->get_document(&pidispDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pidispDoc->QueryInterface(IID_TO_PPV(IHTMLDocument2, ppiDoc)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // GetHostDocument

//+-----------------------------------------------------------------------
//
//  Member:    InitScriptEngine
//
//  Overview:  Kick start the script engine.  Required prior to calling 
//             'eval'.
//
//  Arguments: The hosting document
//
//  Returns:   void
//
//------------------------------------------------------------------------
static void 
InitScriptEngine (IHTMLDocument2 *piDoc)
{
    HRESULT hr;
   
    CComPtr<IHTMLWindow2>   piWindow2;
    CComVariant             varResult;
    CComBSTR                bstrScript(L"2+2");
    CComBSTR                bstrJS(L"JScript");

    Assert(NULL != piDoc);

    if (bstrScript == NULL ||
        bstrJS     == NULL)
    {
        goto done;
    }

    hr = THR(piDoc->get_parentWindow(&piWindow2));
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(piWindow2->execScript(bstrScript,bstrJS, &varResult));

done: 
    return;
} // InitScriptEngine

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Create
//
//  Overview:  Creates and initializes the target proxy
//
//  Arguments: The dispatch of the host element, attribute name, out param
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Create (IDispatch *pidispHostElem, LPOLESTR wzAttributeName, 
                      CTargetProxy **ppcTargetProxy)
{
    HRESULT hr;

    CComObject<CTargetProxy> * pTProxy;

    if (NULL == ppcTargetProxy)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(CComObject<CTargetProxy>::CreateInstance(&pTProxy));
    if (hr != S_OK)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    *ppcTargetProxy = static_cast<CTargetProxy *>(pTProxy);
    (*ppcTargetProxy)->AddRef();

    hr = THR((*ppcTargetProxy)->Init(pidispHostElem, wzAttributeName));
    if (FAILED(hr))
    {
        (*ppcTargetProxy)->Release();
        *ppcTargetProxy = NULL;
        hr = DISP_E_MEMBERNOTFOUND;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND);
} // CTargetProxy::Create

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::CTargetProxy
//
//  Overview:  Constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CTargetProxy::CTargetProxy (void) :
    m_wzAttributeName(NULL)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::CTargetProxy()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::~CTargetProxy
//
//  Overview:  Destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CTargetProxy::~CTargetProxy (void)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::~CTargetProxy()",
              this));
    
    if (NULL != m_wzAttributeName)
    {
        delete [] m_wzAttributeName;
        m_wzAttributeName = NULL;
    }
    // Make sure Detach is called.
    IGNORE_HR(Detach());

} // dtor

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::FindTargetDispatchOnStyle
//
//  Overview:  Discern the proper dispatch from this element's style interfaces 
//             for the given attribute.
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::FindTargetDispatchOnStyle (IDispatch *pidispHostElem, LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::FindTargetDispatchOnStyle(%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr;
    CComPtr<IHTMLElement2> spiElement2;
    CComVariant varResult;

    // We must be prepared to fall back for IE4.
    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement2, &spiElement2)));
    if (SUCCEEDED(hr))
    {
        CComPtr<IHTMLCurrentStyle> spiCurrStyle;
        CComPtr<IHTMLStyle> spiRuntimeStyle;

        hr = THR(spiElement2->get_currentStyle(&spiCurrStyle));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiCurrStyle->QueryInterface(IID_TO_PPV(IDispatch, &m_spdispTargetSrc)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiElement2->get_runtimeStyle(&spiRuntimeStyle));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiRuntimeStyle->QueryInterface(IID_TO_PPV(IDispatch, &m_spdispTargetDest)));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        CComPtr<IHTMLElement> spiElement;
        CComPtr<IHTMLStyle> spiStyle;

        hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &spiElement)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiElement->get_style(&spiStyle));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiStyle->QueryInterface(IID_TO_PPV(IDispatch, &m_spdispTargetSrc)));
        if (FAILED(hr))
        {
            goto done;
        }

        // No distinction between current/runtime style in IE4.
        m_spdispTargetDest = m_spdispTargetSrc;
    }

    // We don't care about the value in the attribute at this time -- just that
    // the attribute is present.
    Assert(m_spdispTargetSrc != NULL);
    hr = THR(GetProperty(m_spdispTargetSrc, wzAttributeName, &varResult));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_spdispTargetDest != NULL);
    hr = THR(GetProperty(m_spdispTargetDest, wzAttributeName, &varResult));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        // If we didn't find the attribute here, 
        // then we need to wipe out these dispatch pointers.
        m_spdispTargetSrc.Release();
        m_spdispTargetDest.Release();
        hr = DISP_E_MEMBERNOTFOUND;
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
} // CTargetProxy::FindTargetDispatchOnStyle

//+-----------------------------------------------------------------------
//
//  Member:    BuildScriptParameters
//
//  Overview:  Build the parameters necessary to talk directly an element's property
//
//  Arguments: 
//              input args : id, attrib name
//              output args : object path, and leaf attribute name.
//              
//              If the attribute name is atomic (something like 'top'
//              as opposed to 'filters.item(1).opacity', then pwzObject 
//              and pwzProperty will come back as NULL strings.  In that case,
//              the caller may use the input parameters to put a new value via
//              a scriptable dispatch.
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
static HRESULT
BuildScriptParameters (LPCWSTR wzID, LPCWSTR wzAttributeName, 
                       BSTR *pbstrObject, BSTR *pbstrProperty)
{
    HRESULT hr;

    Assert(NULL != wzID);
    Assert(NULL != wzAttributeName);

    // Get the last token in the attribute string.
    LPWSTR wzBeginLeafProperty = StrRChrW(wzAttributeName, 
                                          &(wzAttributeName[lstrlenW(wzAttributeName)]), 
                                          WCH_OM_SEPARATOR);

    // Simple attribute name.
    if (NULL == wzBeginLeafProperty)
    {
        *pbstrObject = NULL;
        *pbstrProperty = NULL;
    }
    else
    {
        unsigned int uObjectSize = lstrlenW(wzID) + lstrlenW(wzAttributeName) + 1;
        // The separator slot in this string accounts for the trailing NULL.
        unsigned int uPropertySize = lstrlenW(wzBeginLeafProperty);

        *pbstrObject = ::SysAllocStringLen(NULL, uObjectSize);
        *pbstrProperty = ::SysAllocStringLen(NULL, uPropertySize);

        if ((NULL == (*pbstrObject)) || (NULL == (*pbstrProperty)))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        ZeroMemory(*pbstrObject, uObjectSize * sizeof(WCHAR));
        ZeroMemory(*pbstrProperty, uPropertySize * sizeof(WCHAR));

        // Glom the id together with the attribute string.
        StrCpyW((*pbstrObject), wzID);
        StrCatW((*pbstrObject), WZ_OM_SEPARATOR);
        StrNCatW((*pbstrObject), wzAttributeName, 
                 lstrlenW(wzAttributeName) - lstrlenW(wzBeginLeafProperty) + 1);
        
        // Isolate the last token from the leading separator.
        StrCpyW((*pbstrProperty), &(wzBeginLeafProperty[1]));        
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // BuildScriptParameters

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::GetDispatchFromScriptEngine
//
//  Overview:  Discern a dispatch for this element/attribute using 
//             the script engine.  This method potentially changes 
//             the value of m_wzAttributeName to reflect something
//             we can query directly for a value.
//
//  Arguments: the script engine dispatch and the element id
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::GetDispatchFromScriptEngine(IDispatch *pidispScriptEngine, BSTR bstrID)
{
    HRESULT hr;
    CComVariant varArg;
    CComVariant varResultDispatch;
    CComVariant varResultPropGet;
    CComBSTR bstrObjectName;
    CComBSTR bstrPropertyName;

    // Build names we can query the script engine for.
    hr = THR(BuildScriptParameters(bstrID, m_wzAttributeName, &bstrObjectName, &bstrPropertyName));
    if (FAILED(hr))
    {
        goto done;
    }

    // Both the object and property names must be valid in order to rely on 
    // the results of BuildScriptParameters.  If we got NULL back for either 
    // or both, we'll just use our current ID and attribute values.
    V_VT(&varArg) = VT_BSTR;
    if ((bstrObjectName == NULL) || (bstrPropertyName == NULL))
    {
        V_BSTR(&varArg) = ::SysAllocString(bstrID);
        if (NULL == V_BSTR(&varArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    else
    {
        V_BSTR(&varArg) = ::SysAllocString(bstrObjectName);
        if (NULL == V_BSTR(&varArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        delete [] m_wzAttributeName;
        m_wzAttributeName = CopyString(bstrPropertyName);
        if (NULL == m_wzAttributeName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = THR(CallMethod(pidispScriptEngine, WZ_EVAL_METHOD, &varResultDispatch, &varArg));
    if (SUCCEEDED(hr) &&
        VT_DISPATCH == V_VT(&varResultDispatch))
    {
        varResultPropGet.Clear();
        hr = THR(GetProperty(V_DISPATCH(&varResultDispatch), m_wzAttributeName, &varResultPropGet));
        if (FAILED(hr) ||
            (varResultPropGet.vt      == VT_BSTR &&
             varResultPropGet.bstrVal == NULL))
        {
            hr = E_FAIL;
        }
    }
    if (FAILED(hr) ||
        VT_DISPATCH != V_VT(&varResultDispatch))
    {
        // Fall back and try document.all
        CComBSTR bstrDocumentAll;
        
        bstrDocumentAll = L"document.all.";
        bstrDocumentAll.AppendBSTR(varArg.bstrVal);
        VariantClear(&varArg);
        VariantClear(&varResultDispatch);
        V_VT(&varArg) = VT_BSTR;
        V_BSTR(&varArg) = ::SysAllocString(bstrDocumentAll);
        if (NULL == V_BSTR(&varArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
      
        hr = THR(CallMethod(pidispScriptEngine, WZ_EVAL_METHOD, &varResultDispatch, &varArg));
        if (FAILED(hr) ||
            VT_DISPATCH != V_VT(&varResultDispatch))
        {
            hr = E_FAIL;
            goto done;
        }
        varResultPropGet.Clear();
        hr = THR(GetProperty(V_DISPATCH(&varResultDispatch), m_wzAttributeName, &varResultPropGet));
        if (FAILED(hr) ||
            (varResultPropGet.vt      == VT_BSTR &&
            varResultPropGet.bstrVal == NULL))
        {
            hr = E_FAIL;
            goto done;
        }
    }

    // If we got a I_DISPATCH back we need to try "value" as that is what VML uses.
    if (varResultPropGet.vt == VT_DISPATCH)
    {
        varResultDispatch.Clear();
        varResultDispatch.Copy(&varResultPropGet);
        varResultPropGet.Clear();
        hr = THR(GetProperty(V_DISPATCH(&varResultDispatch), WZ_VML_SUBPROPERTY, &varResultPropGet));
        if (FAILED(hr)||
            varResultPropGet.pvarVal == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        if (m_wzAttributeName)
        {
            delete [] m_wzAttributeName;
        }
        m_wzAttributeName = CopyString(WZ_VML_SUBPROPERTY);
    }

    m_spdispTargetSrc = V_DISPATCH(&varResultDispatch);
    m_spdispTargetDest = V_DISPATCH(&varResultDispatch);

    hr = S_OK;
done :

    RRETURN(hr);
} // CTargetProxy::GetDispatchFromScriptEngine

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::FindScriptableTargetDispatch
//
//  Overview:  Discern a scriptable dispatch for this element/attribute.
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::FindScriptableTargetDispatch (IDispatch *pidispHostElem, 
                                            LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::FindScriptableTargetDispatch(%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr;
    CComPtr<IHTMLElement> spElem;
    CComPtr<IHTMLDocument2> spDoc;
    CComPtr<IHTMLWindow2> spWindow;
    CComPtr<IDispatch> spdispScriptEngine;
    CComBSTR bstrID;
    CComVariant varErrorFunction;
    CComVariant varNewError;
    bool fMustRemoveID = false;
    
    // Ensure that this element has an id.  If not, create one for
    // temporary use.
    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &spElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    // We require an ID here.
    IGNORE_HR(spElem->get_id(&bstrID));
    if ((bstrID == NULL) || (0 == bstrID.Length()))
    {
        CComPtr<IHTMLUniqueName> spUniqueName;

        hr = THR(spElem->QueryInterface(IID_TO_PPV(IHTMLUniqueName, &spUniqueName)));
        if (FAILED(hr))
        {
            goto done;
        }

        // This causes an ID to be assigned to the element.
        hr = THR(spUniqueName->get_uniqueID(&bstrID));

        fMustRemoveID = true;
        Assert(bstrID != NULL);

        if (FAILED(hr))
        {
            goto done;
        }


        TraceTag((tagTargetProxy,
                  "CTargetProxy(%lx)::FindScriptableTargetDispatch : Generated ID is %ls",
                  this, bstrID));
    }

    hr = GetHostDocument(pidispHostElem, &spDoc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spDoc->get_Script(&spdispScriptEngine));
    if (FAILED(hr))
    {
        goto done;
    }

    // Need to save off onerror function and put our own on
    // we addref before we send it to the ScriptEngine ( script enigne WILL release)
    this->AddRef();
    varNewError.vt = VT_DISPATCH;
    varNewError.pdispVal = this;

    hr = spDoc->get_parentWindow(&spWindow);
    if (FAILED(hr))
    {
        goto done;
    } 
    hr = spWindow->get_onerror(&varErrorFunction);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spWindow->put_onerror(varNewError);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetDispatchFromScriptEngine(spdispScriptEngine, bstrID);
    if (FAILED(hr))
    {
        CComBSTR bTemp;

        bTemp = bstrID.Copy();
        bTemp.Append(L".style");
        hr = GetDispatchFromScriptEngine(spdispScriptEngine, bTemp);
    }

    // Need to replace the users onerror function..
    spWindow->put_onerror(varErrorFunction);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :

    // Must clean things up.
    if (fMustRemoveID)
    {
        IGNORE_HR(spElem->put_id(NULL));
    }

    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::FindTargetDispatch
//
//  Overview:  Discern the proper dispatch from this element for the given attribute.
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::FindTargetDispatch (IDispatch *pidispHostElem, LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::FindTargetDispatch(%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr;
    bool bVML = IsVMLObject(pidispHostElem);

    if (bVML)
    {
        hr = FindScriptableTargetDispatch(pidispHostElem, wzAttributeName); 
        if (FAILED(hr))
        {
            hr = FindTargetDispatchOnStyle(pidispHostElem, wzAttributeName);       
        }
    }
    else
    {
        hr = FindTargetDispatchOnStyle(pidispHostElem, wzAttributeName);
    }

    if (FAILED(hr))
    {
        WCHAR wzTrimmedAttributeName[INTERNET_MAX_URL_LENGTH];
        WCHAR wzTrimmedAttributeNameWithoutDashes[INTERNET_MAX_URL_LENGTH];

        // Prevent overflow.
        if (INTERNET_MAX_URL_LENGTH < (ocslen(wzAttributeName) - 1))
        {
            hr = E_FAIL;
            goto done;
        }

        ZeroMemory(wzTrimmedAttributeName,sizeof(WCHAR)*INTERNET_MAX_URL_LENGTH);
        ZeroMemory(wzTrimmedAttributeNameWithoutDashes,sizeof(WCHAR)*INTERNET_MAX_URL_LENGTH);

        // Lets see if there is a style. if so strip it off and try the sytle again..
        if ((StrCmpNIW(wzAttributeName, WZ_STYLEDOT, 6) == 0))
        {
            StrCpyNW(wzTrimmedAttributeName,wzAttributeName+6,((int) ocslen(wzAttributeName)) -5);
            hr = FindTargetDispatchOnStyle(pidispHostElem, wzTrimmedAttributeName);
        }
        else
        {
            StrCpyNW(wzTrimmedAttributeName,wzAttributeName, INTERNET_MAX_URL_LENGTH);
        }

        // We need to strip out the '-' (WZ_CSS_SEPARATOR) and try again since we need to support border-top-color form as well as the 
        // standard bordertopcolor.
        if (FAILED(hr))    
        {
            int count =0;

            for (int i=0; i< (int) ocslen(wzTrimmedAttributeName); i++)
            {   
                if (wzTrimmedAttributeName[i] != WZ_CSS_SEPARATOR)
                {
                    wzTrimmedAttributeNameWithoutDashes[count++] = wzTrimmedAttributeName[i];
                }
            }
            hr = FindTargetDispatchOnStyle(pidispHostElem, wzTrimmedAttributeNameWithoutDashes);
            StrCpyW(wzTrimmedAttributeName, wzTrimmedAttributeNameWithoutDashes);
        }
        if (FAILED(hr))
        {
            hr = FindScriptableTargetDispatch(pidispHostElem, wzAttributeName); 
            if (FAILED(hr))
            {
                TraceTag((tagError,
                          "CTargetProxy(%lx)::FindTargetDispatch(%lx, %ls) cannot find attribute on targetElement",
                          this, pidispHostElem, wzAttributeName));          
                goto done;
            }
        }
        else 
        {
            if (m_wzAttributeName)
            {
                delete [] m_wzAttributeName ;
            }
            m_wzAttributeName = CopyString(wzTrimmedAttributeName);
        }
    }

    hr = S_OK;
done :
    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, E_FAIL);
} // CTargetProxy::FindTargetDispatch

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::InitHost
//
//  Overview:  Initialize the host
//
//  Arguments: the host element dispatch
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::InitHost (IDispatch *pidispHostElem)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::InitHost(%lx)",
              this, pidispHostElem));

    HRESULT hr;
    CComPtr<IHTMLDocument2> piDoc;

    hr = GetHostDocument(pidispHostElem, &piDoc);
    if (FAILED(hr))
    {
        goto done;
    }

    InitScriptEngine(piDoc);

    hr = S_OK;
done :
    RRETURN(hr);
} // InitHost

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Init
//
//  Overview:  Initialize the target proxy
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Init (IDispatch *pidispHostElem, LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::Init (%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr = S_OK;

    if (NULL != wzAttributeName)
    {
        m_wzAttributeName = CopyString(wzAttributeName);
        if (NULL == m_wzAttributeName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = InitHost (pidispHostElem);
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // Sniff the target element for the attribute name.
    hr = FindTargetDispatch(pidispHostElem, wzAttributeName);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_spdispTargetSrc != NULL);
    Assert(m_spdispTargetDest != NULL);

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(Detach());
    }

    RRETURN3(hr, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY);
} // CTargetProxy::Init

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Detach
//
//  Overview:  Detach all external references in the target proxy
//
//  Arguments: none
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Detach (void)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::Detach()",
              this));

    HRESULT hr;

    if (NULL != m_wzAttributeName)
    {
        delete [] m_wzAttributeName;
        m_wzAttributeName = NULL;
    }

    if (m_spdispTargetSrc != NULL)
    {
        m_spdispTargetSrc.Release();
    }

    if (m_spdispTargetDest != NULL)
    {
        m_spdispTargetDest.Release();
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CTargetProxy::Detach

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::GetCurrentValue
//
//  Overview:  Get the current value of target's attribute
//
//  Arguments: the attribute value
//
//  Returns:   S_OK, E_INVALIDARG, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::GetCurrentValue (VARIANT *pvarValue)
{
    HRESULT hr;

    if (NULL == pvarValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_spdispTargetSrc == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(::VariantClear(pvarValue));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(GetProperty(m_spdispTargetSrc, m_wzAttributeName, pvarValue));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;

#if (0 && DBG)
    {
        CComVariant varValue;
        varValue.Copy(pvarValue);
        ::VariantChangeTypeEx(&varValue, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        TraceTag((tagTargetProxyValue,
                  "CTargetProxy(%p)::GetCurrentValue(%ls = %ls)",
                  this, m_wzAttributeName, V_BSTR(&varValue)));
    }
#endif


done :
    RRETURN2(hr, E_INVALIDARG, E_UNEXPECTED);
} // CTargetProxy::GetCurrentValue

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Update
//
//  Overview:  Update the target's attribute
//
//  Arguments: the new attribute value
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Update (VARIANT *pvarNewValue)
{
    HRESULT hr;

#if (0 && DBG)
    {
        CComVariant varValue;
        varValue.Copy(pvarNewValue);
        ::VariantChangeTypeEx(&varValue, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        TraceTag((tagTargetProxyValue,
                  "CTargetProxy(%p)::Update (%ls = %ls)",
                  this, m_wzAttributeName, V_BSTR(&varValue)));
    }
#endif

    if (NULL == pvarNewValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_spdispTargetDest == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(PutProperty(m_spdispTargetDest, m_wzAttributeName, pvarNewValue));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // CTargetProxy::Update




///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CTargetProxy::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CTargetProxy::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CTargetProxy::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//      Currently this is only used for OnError.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTargetProxy::Invoke( DISPID id,
                           REFIID riid,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pDispParams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pExcepInfo,
                           UINT *puArgErr)
{
    HRESULT hr = S_OK;

    if ( DISPATCH_METHOD == wFlags)
    {
        pvarResult->vt = VT_BOOL;    
        pvarResult->boolVal = VARIANT_TRUE;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\smilpath.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: smilpath.h
//
//  Contents: SMIL path
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _SMILPATH_H
#define _SMILPATH_H

#include "timeparser.h"

class CTIMEMotionAnimation;

#define IID_ISMILPath __uuidof(ISMILPath)


//+-------------------------------------------------------------------------------------
//
// ISMILPath
//
//--------------------------------------------------------------------------------------

interface 
__declspec(uuid("cbe68ca2-47b9-41ff-a8f4-d2f810bd53c5")) 
ISMILPath :
    public IUnknown
{
    //
    // Interpolation functions
    //

    STDMETHOD(Interpolate)(double dblProgress, POINTF * pPoint) = 0;
    
    STDMETHOD(InterpolateSegment)(int curseg, double dblSegProgress, POINTF * pNewPos) = 0;

    STDMETHOD(InterpolatePaced)(double dblProgress, POINTF * pPoint) = 0;

    //
    // utility functions and accessors
    //

    STDMETHOD(Init)(CTIMEMotionAnimation * pAnimElm) = 0;

    STDMETHOD(Detach)() = 0;

    STDMETHOD_(void, ClearPath)() = 0;

    STDMETHOD(SetPath)(CTIMEPath ** pPath, long numPath, long numMoveTo) = 0;

    STDMETHOD(IsValid)(bool * pfValid) = 0;
    
    STDMETHOD(GetPoint)(int nIndex, POINTF * pPoint) = 0;
    
    STDMETHOD(GetNumPoints)(int * pnNumPoints) = 0;

    STDMETHOD(GetNumSeg)(int * pnNumSeg) = 0;

    STDMETHOD(GetSegmentProgress)(double dblProgress, int * pnSeg, double * pdblSegProgress) = 0; 
};


//+-------------------------------------------------------------------------------------
//
// CSMILPath factory method
//
//--------------------------------------------------------------------------------------

HRESULT CreateSMILPath(CTIMEMotionAnimation * pAnimElm, ISMILPath ** ppSMILPath);


//+-------------------------------------------------------------------------------------
//
// CSMILPath
//
//--------------------------------------------------------------------------------------

class CSMILPath : 
    public ISMILPath
{
public:
    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CSMILPath();
    virtual ~CSMILPath();

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    //
    // ISMILPath
    //

    // interpolation methods
    STDMETHOD(Interpolate)(double dblProgress, POINTF * pPoint);
    STDMETHOD(InterpolateSegment)(int curseg, double dblSegProgress, POINTF * pNewPos);
    STDMETHOD(InterpolatePaced)(double dblProgress, POINTF * pPoint);

    // utility methods
    STDMETHOD(Init)(CTIMEMotionAnimation * pAnimElm);
    STDMETHOD(Detach)();
    STDMETHOD_(void, ClearPath)();
    STDMETHOD(SetPath)(CTIMEPath ** pPath, long numPath, long numMoveTo);
    STDMETHOD(IsValid)(bool * pfValid) { *pfValid = IsPathValid(); return S_OK; }
    STDMETHOD(GetPoint)(int nIndex, POINTF * pPoint);
    STDMETHOD(GetNumPoints)(int * pnNumPoints) { *pnNumPoints = m_numPath; return S_OK; }
    STDMETHOD(GetNumSeg)(int * pnNumSeg) { *pnNumSeg = m_numPath - m_numMOVETO; return S_OK; }
    STDMETHOD(GetSegmentProgress)(double dblProgress, int * pnSeg, double * pdblSegProgress); 

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:
    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // hide the copy constructor
    CSMILPath(CSMILPath &);

    bool IsPathValid();
    HRESULT CreateSegmentMap();
    HRESULT MapSegment(int seg, int & index);
    POINTF CubicBezier(POINTF ptStart, POINTF *aryPoints, double curPorgress);
    LPWSTR GetID();
    HRESULT CreateLengthMap();
    long GetNumSeg() { return m_numPath - m_numMOVETO; }
    void ClearLengthMap();
    void ClearSegmentMap();
    double GetLength();
    HRESULT ComputeSegmentLength(int seg, double & segLength);
    HRESULT GetSegmentEndPoints(int seg, int & startIndex, int & endIndex);
    double GetDistance(POINTF & p1, POINTF & p2);
    double GetBezierLength(POINTF & startPoint, POINTF * pts);
    HRESULT GetCumulativeLength(int seg, double & segLength);

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

private:
    //+--------------------------------------------------------------------------------
    //
    // Private Methods
    //
    //---------------------------------------------------------------------------------

#if DBG
    int PrintPath(long numPath, long numMOVETO, CTIMEPath ** pPath);
#endif

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    long         m_numPath;
    long         m_numMOVETO;
    int *        m_pSegmentMap;
    CTIMEPath ** m_pPath;
    double *     m_pLengthMap;

    long m_cRef;

    // this is used only to get the ID for debugging
    CTIMEMotionAnimation * m_pAnimElm;
};


#endif // _SMILPATH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#undef malloc
#undef free
#undef realloc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\dll\init.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: init.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern bool InitializeModule_##ModuleName();  \
  if (!InitializeModule_##ModuleName()) return false;

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

bool
InitializeAllModules()
{
    // initialize Util first because InitializeModule_ATL uses a 
    // STL lock that is allocated in Util.
    INITIALIZE_MODULE(Util); //lint !e1717
    INITIALIZE_MODULE(ATL); //lint !e1717

    return true;
}

void
DeinitializeAllModules(bool bShutdown)
{
    DEINITIALIZE_MODULE(ATL, bShutdown);
    // deinitialize Util last because DeinitializeModule_ATL uses a 
    // STL lock that is deallocated in Util.
    DEINITIALIZE_MODULE(Util, bShutdown);
}

#include <initguid.h>
#include <strmif.h>
#include "transsiteguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\dll\oleobj.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: oleobj.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "tags\factory.h"

#include "anim\sitefact.h"
#include "anim\compfact.h"
#include "anim\animelm.h"
#include "anim\animset.h"
#include "anim\animmotion.h"
#include "anim\animcolor.h"
#include "anim\animfilter.h"

DeclareTag(tagLockCount,"TIME","Lock count")

DAComModule _Module;
extern HINSTANCE g_hInst;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_TIMEFactory, CTIMEFactory)
    OBJECT_ENTRY(CLSID_AnimationComposerSiteFactory, CAnimationComposerSiteFactory)
    OBJECT_ENTRY(CLSID_AnimationComposerFactory, CAnimationComposerFactory)
    OBJECT_ENTRY(CLSID_TIMEAnimation, CTIMEAnimationElement)
    OBJECT_ENTRY(CLSID_TIMESetAnimation, CTIMESetAnimation)
    OBJECT_ENTRY(CLSID_TIMEMotionAnimation, CTIMEMotionAnimation)
    OBJECT_ENTRY(CLSID_TIMEColorAnimation, CTIMEColorAnimation)
    OBJECT_ENTRY(CLSID_TIMEFilterAnimation, CTIMEFilterAnimation)
END_OBJECT_MAP() //lint !e785

extern bool InitializeModule_ImportManager(void);
extern void DeinitializeModule_ImportManager(bool);

LONG
DAComModule::Lock()
{
    bool bNeedInitialize = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (bNeedInitialize) 
    {
        InitializeModule_ImportManager();
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (l) return l;
    
    DeinitializeModule_ImportManager(true);

    return 0;
}

#if DBG
#include <map>

typedef std::map<void *, const _TCHAR *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const _TCHAR * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
        OutputDebugString(__T("\n**************Begin Time Dump List****************\n"));
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString (__T("DATIME.DLL: Detected unfreed COM pointers\n"));
            OutputDebugString (__T("Listing pointers and types:\n"));
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintfA(buf, "%#x:", (*i).first);
                OutputDebugStringA(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString(__T("\n"));
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
        OutputDebugString(__T("**************End Time Dump List******************\n\n"));
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif

bool
InitializeModule_ATL()
{
    _Module.Init(COMObjectMap, g_hInst);

#if DBG
    // NOTE: Memory allocation during construction now gives a warning. 
    // If this is ok because this is DEV_DEBUG then leave the following
    // pragma, otherwise move this NEW.
#pragma warning( disable: 4291 )     
    objMap = NEW ObjectMap;
#endif

    return true;
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DBG
    DumpCOMObjectList();
    
    delete objMap;
    objMap = NULL;
#endif
    
    _Module.Term();
}

//
//
//
STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(COMObjectMap)/sizeof(COMObjectMap[0])) - 1) //lint !e574
    {
        return S_FALSE;
    }

    *pclsid = *(COMObjectMap[i].pclsid);
    return DllGetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\idl\makefile.inc ===
!if !$(FREEBUILD)
C_DEFINES       = $(C_DEFINES) -DDBG=1
!endif

$O\TimeEng.h : TimeEng.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\TimeEng_p.c \
    -iid $O\TimeEng_i.c \
    -dlldata $O\dlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\TimeEng.h \
    $(C_DEFINES) \
    -Oicf \
    -no_warn \
    -error all \
    TimeEng.idl

$(O)\TimeEng_i.obj : $(O)\TimeEng_i.c

$(O)\mmpguid.lib : $(O)\TimeEng_i.obj
    copy $? $@

$(O)\MediaPrivate.tlb : $O\MediaPrivate.h

$O\MediaPrivate.h : MediaPrivate.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\MediaPrivate_p.c \
    -iid $O\MediaPrivate_i.c \
    -dlldata $O\dlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\MediaPrivate.h \
    -tlb $(O)\MediaPrivate.tlb \
    $(C_DEFINES) \
    -Oicf \
    -no_warn \
    -error all \
    MediaPrivate.idl

$(O)\MediaPrivate_i.obj : $(O)\MediaPrivate_i.c

$(O)\mediaprivateguid.lib : $(O)\MediaPrivate_i.obj
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\anim\targetpxy.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Animation Composer's Target Proxy.

*******************************************************************************/

#pragma once

#ifndef _TARGETPXY_H
#define _TARGETPXY_H

// The target proxy abstracts the communication with the target 
// object.  This allows us to change the target sniffing strategy 
// without changing the composer object.
class CTargetProxy : public IDispatch,
                     public CComObjectRootEx<CComSingleThreadModel>
{

 public :

    static HRESULT Create (IDispatch *pidispSite, LPOLESTR wzAttributeName, 
                           CTargetProxy **ppcTargetProxy);

    virtual ~CTargetProxy (void);

    virtual HRESULT Detach (void);
    virtual HRESULT GetCurrentValue (VARIANT *pvarValue);
    virtual HRESULT Update (VARIANT *pvarNewValue);

#if DBG
    const _TCHAR * GetName() { return __T("CTargetProxy"); }
#endif

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

        // QI Map
    BEGIN_COM_MAP(CTargetProxy)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP();

 // Internal Methods
 protected :
    
    CTargetProxy (void);
    HRESULT Init (IDispatch *pidispSite, LPOLESTR wzAttributeName);
    HRESULT InitHost (IDispatch *pidispHostElem);
    HRESULT GetDispatchFromScriptEngine(IDispatch *pidispScriptEngine, BSTR bstrID);
    HRESULT FindScriptableTargetDispatch (IDispatch *pidispHostElem, 
                                          LPOLESTR wzAttributeName);
    HRESULT FindTargetDispatchOnStyle (IDispatch *pidispHostElem, 
                                       LPOLESTR wzAttributeName);
    HRESULT FindTargetDispatch (IDispatch *pidispHostElem, 
                                LPOLESTR wzAttributeName);

  // Data
 protected:

    CComPtr<IDispatch>          m_spdispTargetSrc;
    CComPtr<IDispatch>          m_spdispTargetDest;
    LPWSTR                      m_wzAttributeName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\idlproxy\makefile.inc ===
$(O)\mstimepdlldata.c $O\mstimep.h : mstimep.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\mstimep_p.c \
    -iid $O\mstimep_i.c \
    -dlldata $O\mstimepdlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\mstimep.h \
    $(C_DEFINES) \
    -Oicf \
    -error all \
    -no_robust \
    mstimep.idl

$(O)\prxyguid.lib : $(O)\mstimep_i.obj
    -$(LIB_NAME) $(LIBRARIAN_FLAGS) $(O)\mstimep_i.obj /out:$(O)\prxyguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"

#include "dlldatax.h"

//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE     g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
LCID                g_lcidUserDefault = 0;

HINSTANCE  g_hInst;

DWORD g_dwFALSE = 0;

bool InitializeAllModules(void);
void DeinitializeAllModules(bool bShutdown);

extern "C" void InitDebugLib(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

MtDefine(OpNewATL, Mem, "operator new (mstime ATL)")

// Below is the trick used to make ATL use our memory allocator
void    __cdecl ATL_free(void * pv) { MemFree(pv); }
void *  __cdecl ATL_malloc(size_t cb) { return(MemAlloc(Mt(OpNewATL), cb)); }
void *  __cdecl ATL_realloc(void * pv, size_t cb)
{
    void * pvNew = pv;
    HRESULT hr = MemRealloc(Mt(OpNewATL), &pvNew, cb);
    return(hr == S_OK ? pvNew : NULL);
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {

#if DBG
        char buf[MAX_PATH + 1];

        GetModuleFileNameA(hInstance, buf, MAX_PATH);

        char buf2[1024];
        wsprintfA(buf2, "[%s] - Loaded DLL\n", buf);
        OutputDebugStringA(buf2);

        // init the debug Trace mech.
//        InitDebugLib(hInstance, NULL); 


    //  Tags for the .dll should be registered before
    //  calling DbgExRestoreDefaultDebugState().  Do this by
    //  declaring each global tag object or by explicitly calling
    //  DbgExTagRegisterTrace.

    DbgExRestoreDefaultDebugState();

#endif 
        g_hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        if (!InitializeAllModules())
        {
            return FALSE;
        }
        
    } else if (dwReason == DLL_PROCESS_DETACH) {
#if DBG
        char buf[MAX_PATH + 1];

        GetModuleFileNameA(hInstance, buf, MAX_PATH);

        char buf2[1024];
        wsprintfA(buf2, "[%s] - Unloaded DLL(%d)\n", buf, lpReserved);
        OutputDebugStringA(buf2);
#endif
        DeinitializeAllModules(lpReserved != NULL);
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }

    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
    {
        return hRes;
    }

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    PrxDllUnregisterServer();
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\dll\transsiteguid.h ===
// {387B7322-E999-4228-905D-D85CFB971AB5}
DEFINE_GUID(IID_ITIMETransitionSite, 
0x387b7322, 0xe999, 0x4228, 0x90, 0x5d, 0xd8, 0x5c, 0xfb, 0x97, 0x1a, 0xb5);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\basebvr.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\basebvr.h
//
//  Contents: DHTML Behavior base class
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _BASEBVR_H
#define _BASEBVR_H

class CBaseBvr :   
    public CComObjectRootEx<CComSingleThreadModel>,
    public IElementBehavior,
    public IServiceProvider,
    public IOleClientSite
{

protected:

    // To prevent instantiation/copying of this class
    CBaseBvr();
    CBaseBvr(const CBaseBvr&);
    virtual ~CBaseBvr();

public:

    BEGIN_COM_MAP(CBaseBvr)
        COM_INTERFACE_ENTRY(IElementBehavior)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IOleClientSite)
    END_COM_MAP();

    virtual void * GetInstance() = 0;
    virtual HRESULT GetTypeInfo(ITypeInfo ** ppInfo) = 0;

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // IServiceProvider interfaces
    //

    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    //
    // IOleClientSite interfaces
    //
    
    STDMETHOD(SaveObject)()
    { return E_NOTIMPL; }
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk)
    { CHECK_RETURN_SET_NULL(ppmk); return E_NOTIMPL; }
    STDMETHOD(GetContainer)(LPOLECONTAINER * ppContainer)
    { CHECK_RETURN_SET_NULL(ppContainer); return E_NOTIMPL; }
    STDMETHOD(ShowObject)()
    { return E_NOTIMPL; }
    STDMETHOD(OnShowWindow)(BOOL fShow)
    { return E_NOTIMPL; }
    STDMETHOD(RequestNewObjectLayout)()
    { return E_NOTIMPL; }

    virtual LPCWSTR GetBehaviorURN (void) = 0;
    virtual LPCWSTR GetBehaviorName (void) = 0;
    virtual bool    IsBehaviorAttached (void) = 0;

    //
    // Notification Helpers
    //

    void NotifyPropertyChanged(DISPID dispid);

    //
    // Accessors for cached interface pointers
    //
    
    IElementBehaviorSite * GetBvrSite()
    { return m_pBvrSite; }
    IElementBehaviorSiteOM * GetBvrSiteOM()
    { return m_pBvrSiteOM; }
    IHTMLElement * GetElement()
    { return m_pHTMLEle; }
    IHTMLDocument2 * GetDocument()
    { return m_pHTMLDoc; }
    IServiceProvider * GetServiceProvider()
    { return m_pSp; }

protected:

    //
    // IPersistPropertyBag2 methods
    //

    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // Persistance helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void) PURE;

    //
    // Notification Helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP) PURE;

    //
    // Persistance and Notification data
    //

    CLSID                                  m_clsid;
    bool                                   m_fPropertiesDirty;

    //
    // Cached Interface Pointers
    //

    CComPtr<IElementBehaviorSite>          m_pBvrSite;
    CComPtr<IElementBehaviorSiteOM>        m_pBvrSiteOM;
    CComPtr<IHTMLElement>                  m_pHTMLEle;
    CComPtr<IHTMLDocument2>                m_pHTMLDoc;
    CComPtr<IServiceProvider>              m_pSp;

    bool m_fIsIE4;
};

#endif /* _BASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\atlutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_STATIC_REGISTRY 1

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DBG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if DBG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DBG
        _Module.AddComPtr(this, GetName());
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DBG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\atomtable.h ===
#ifndef _ATOMTABLE_H_
#define _ATOMTABLE_H_

//************************************************************
//
// FileName:        atomtbl.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CAtomTable
//************************************************************

static const long ATOM_TABLE_VALUE_UNITIALIZED = -1L;

#include "array.h"

class CAtomTable
{
public:
    CAtomTable();
    virtual ~CAtomTable();
    
    //
    // CAtomTable impl
    //
    HRESULT AddNameToAtomTable(const WCHAR *pwszName,
                               long        *plOffset);
    HRESULT GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset);
    HRESULT GetNameFromAtom(long          lOffset, 
                            const WCHAR **ppwszName);

    LONG AddRef( void) { return InterlockedIncrement(&m_lRefCount); }
    LONG Release( void) { ULONG l = InterlockedDecrement(&m_lRefCount); if (l == 0) delete this; return l; }


private:
    CPtrAry<BSTR> *m_rgNames;
    LONG m_lRefCount;
};

#endif // _ATOMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\bindstatuscallback.h ===
#ifndef _BINDSTATUSCALLBACK_H__
#define _BINDSTATUSCALLBACK_H__

class CTIMEBindStatusCallback : 
  public IBindStatusCallback
{
  public:
    static HRESULT CreateTIMEBindStatusCallback(CTIMEBindStatusCallback ** ppbsc)
    {
        Assert(NULL != ppbsc);

        *ppbsc = new CTIMEBindStatusCallback;
        if (NULL == ppbsc)
        {
            return E_OUTOFMEMORY;
        }
        (*ppbsc)->AddRef();
        return S_OK;
    }

    virtual ~CTIMEBindStatusCallback() { delete m_pszText; m_pszText = NULL; }
    
    void StopAfter(ULONG ulStatusCode) { m_ulCodeToStopOn = ulStatusCode; }
    LPWSTR GetStatusText() { return m_pszText; }

    //
    // IUnknown methods
    //
    STDMETHOD_(ULONG, AddRef)(void) { return InterlockedIncrement(&m_cRef); }
    STDMETHOD_(ULONG, Release)(void)
    {
        LONG l = InterlockedDecrement(&m_cRef);
        
        if (0 == l)
        {
            delete this;
        }
        return l;
    }

    STDMETHOD (QueryInterface)(REFIID riid, void** ppv)
    {
        if (NULL == ppv)
        {
            return E_POINTER;
        }
        
        *ppv = NULL;
        
        if ( IsEqualGUID(riid, IID_IUnknown) )
        {
            *ppv = static_cast<IBindStatusCallback*>(this);
        }
        else if (IsEqualGUID(riid, IID_IBindStatusCallback))
        {
            *ppv = static_cast<IBindStatusCallback*>(this);
        }
        
        if ( NULL != *ppv )
        {
            ((LPUNKNOWN)*ppv)->AddRef();
            return NOERROR;
        }
        return E_NOINTERFACE;
    }

    //
    // IBindStatusCallback methods
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib)
    {
        return S_OK;
    }
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority)
    {
        return S_OK;
    }
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved)
    {
        return S_OK;
    }
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText)
    {
        if (ulStatusCode == m_ulCodeToStopOn)
        {
            m_pszText = ::CopyString(szStatusText);
            return E_ABORT;
        }
        return S_OK;
    }
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError)
    {
        return S_OK;
    }
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
    {
        return S_OK;
    }
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
    {
        return S_OK;
    }
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
    {
        return S_OK;
    }

  protected:
    CTIMEBindStatusCallback() { m_cRef = 0; m_ulCodeToStopOn = -1; m_pszText = NULL; }

  private:
    ULONG   m_ulCodeToStopOn;
    LPWSTR  m_pszText;
    LONG    m_cRef;
};

#endif // _BINDSTATUSCALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\attr.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: attr.h
//
//  Contents: utilities for persistable attributes
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ATTR_H
#define _ATTR_H

//+-------------------------------------------------------------------------------------
//
// CAttrBase
//
//--------------------------------------------------------------------------------------


// This class stores the persisted string and implements IsSet()
class 
ATL_NO_VTABLE
CAttrBase
{
public:
    CAttrBase();
    virtual ~CAttrBase();

    // This is for setting/getting the persisted string
    HRESULT SetString(BSTR pbstrAttr);
    HRESULT GetString(BSTR * ppbstrAttr);

    // This is for use of persistence macros only! Uses the storage passed in (does not allocate).
    void SetStringFromPersistenceMacro(LPWSTR pstrAttr);

    // Indicates if a valid value was set through persistence or the DOM
    bool IsSet() { return m_fSet; }

protected:
    NO_COPY(CAttrBase);

    void ClearString();
    void SetFlag(bool fSet) { m_fSet = fSet; }

private:
    LPWSTR m_pstrAttr;
    bool m_fSet;
};


//+-------------------------------------------------------------------------------------
//
// CAttr Template
//
//--------------------------------------------------------------------------------------

template<class T>
class CAttr :
    public CAttrBase
{
public:
    CAttr(T val) : m_val(val) {}
    virtual ~CAttr() {}

    //
    // Operators
    //

    operator T() const { return m_val; }
    
    //
    // Accessors
    //
    
    void SetValue(T val) 
    {
        m_val = val;
        MarkAsSet();
    }
    T GetValue() const { return m_val; }
    
    //
    // Misc methods
    //
    
    // Just sets the value. Does not clear the persisted string or mark it as set.
    // e.g. used internally to change defaults without affecting persistence
    T InternalSet(T val) { return (m_val = val); }
    // Resets to the specified value (usually the default), marks as not set, and does not persist
    void Reset(T val)
    {
        ClearString();
        SetFlag(false);
        m_val = val;
    }
    // Clears persisted string, forces IsSet() to return 'true'
    void MarkAsSet()
    { 
        ClearString();
        SetFlag(true);
    }

protected:
    // These are not to be used
    NO_COPY(CAttr);

private:
    // Data
    T m_val;
};

class CAttrString  : 
  public CAttrBase
{
  public:
    CAttrString(LPWSTR val);
    virtual ~CAttrString();

    HRESULT SetValue(LPWSTR val);
    BSTR GetValue();

  protected:
    NO_COPY(CAttrString);

    void MarkAsSet();

  private:
    LPWSTR m_pszVal;
};

//+-------------------------------------------------------------------------------------
//
// TIME_PERSISTENCE_MAP macros
//
//--------------------------------------------------------------------------------------


typedef HRESULT (*PFNPERSIST)(void*, VARIANT*, bool);

struct TIME_PERSISTENCE_MAP
{
    LPWSTR     pstrName;    // Attribute Name
    PFNPERSIST pfnPersist;  // Static persistence function for this attribute
};

#define BEGIN_TIME_PERSISTENCE_MAP(className)     TIME_PERSISTENCE_MAP className##::PersistenceMap[] = {
#define PERSISTENCE_MAP_ENTRY(AttrName, FnName)   {AttrName, ::TimePersist_##FnName},
#define END_TIME_PERSISTENCE_MAP()                {NULL, NULL}};


//+-------------------------------------------------------------------------------------
//
// Persistence helpers (All classes delegate to these functions for persistence)
//
//--------------------------------------------------------------------------------------

HRESULT TimeLoad(void * pvObj, TIME_PERSISTENCE_MAP PersistenceMap[], IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
HRESULT TimeSave(void * pvObj, TIME_PERSISTENCE_MAP PersistenceMap[], IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

//
// For loading attributes out of an element
//
HRESULT TimeElementLoad(void * pvObj, TIME_PERSISTENCE_MAP PersistenceMap[], IHTMLElement * pElement);


//+-------------------------------------------------------------------------------------
//
// The following macros are used to create static persistence accessor functions for the TIME_PERSISTENCE_MAP
// (It is best to read these in a top-down fashion, starting at the TIME_PERSIST_FN macro)
//
//--------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------------------
//
// VT_R4 Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VT_R4(hr, pvarAttr, PropPutFn) \
{ \
    hr = VariantChangeTypeEx(##pvarAttr##, ##pvarAttr##, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4); \
    if (SUCCEEDED(hr)) \
    { \
        hr = PropPutFn##(V_R4(##pvarAttr##)); \
    } \
}
#define TIME_GET_VT_R4(hr, pvarAttr, PropGetFn) \
{ \
    float flVal = 0; \
    hr = PropGetFn##(&flVal); \
    if (SUCCEEDED(hr)) \
    { \
        V_VT(##pvarAttr##) = VT_R4; \
        V_R4(##pvarAttr##) = flVal; \
    } \
} 

//+-------------------------------------------------------------------------------------
//
// VT_BOOL Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VT_BOOL(hr, pvarAttr, PropPutFn) \
{ \
    hr = VariantChangeTypeEx(##pvarAttr##, ##pvarAttr##, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BOOL); \
    if (SUCCEEDED(hr)) \
    { \
        hr = PropPutFn##(V_BOOL(##pvarAttr##)); \
    } \
}
#define TIME_GET_VT_BOOL(hr, pvarAttr, PropGetFn) \
{ \
    VARIANT_BOOL vbVal = VARIANT_TRUE; \
    hr = PropGetFn##(&vbVal); \
    if (SUCCEEDED(hr)) \
    { \
        V_VT(##pvarAttr##) = VT_BOOL; \
        V_BOOL(##pvarAttr##) = vbVal; \
    } \
} 

//+-------------------------------------------------------------------------------------
//
// VT_BSTR Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VT_BSTR(hr, pvarAttr, PropPutFn) \
{ \
    hr = PropPutFn##(V_BSTR(##pvarAttr##)); \
}
#define TIME_GET_VT_BSTR(hr, pvarAttr, PropGetFn) \
{ \
    hr = PropGetFn##(&V_BSTR(##pvarAttr##)); \
    if (SUCCEEDED(hr)) \
    { \
        if (NULL == V_BSTR(##pvarAttr##)) \
        { \
            /* No need to propogate a NULL string back.  A number of our */ \
            /* get methods return NULL strings. */ \
            V_VT(##pvarAttr##) = VT_NULL; \
        } \
        else \
        { \
            V_VT(##pvarAttr##) = VT_BSTR; \
        } \
    } \
}

//+-------------------------------------------------------------------------------------
//
// VARIANT Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VARIANT(hr, pvarAttr, PropPutFn) \
{ \
    hr = PropPutFn##(*##pvarAttr##); \
}
#define TIME_GET_VARIANT(hr, pvarAttr, PropGetFn) \
{ \
    hr = PropGetFn##(##pvarAttr##); \
}

//+-------------------------------------------------------------------------------------
//
// TIME_PERSISTGET macro
//
//--------------------------------------------------------------------------------------

// Assumes pvarAttr has been cleared
#define TIME_PERSISTGET(hr, pvarAttr, refAttr, idl_arg_type, PropGetFn) \
{ \
    BSTR bstrTemp; \
    /* Try to get string */ \
    hr = THR(refAttr##.GetString(&bstrTemp)); \
    if (SUCCEEDED(hr) && NULL != bstrTemp) \
    { \
        V_VT(##pvarAttr##) = VT_BSTR; \
        V_BSTR(##pvarAttr##) = bstrTemp; \
    } \
    /* else if attr is set, get value */ \
    else if (##refAttr##.IsSet()) \
    { \
        TIME_GET_##idl_arg_type##(hr, pvarAttr, PropGetFn); \
    } \
    /* else indicate that this attr should not be persisted */ \
    else \
    { \
        V_VT(##pvarAttr##) = VT_NULL; \
    } \
} 

//+-------------------------------------------------------------------------------------
//
// TIME_PERSISTPUT macro
//
//--------------------------------------------------------------------------------------

// The variant is first passed to the COM accessor, and then the persisted string is set 
// on the CAttr<> class. This ordering is important for the attribute to persist correctly.
// Assumes pvarAttr is valid and is a VT_BSTR (this is guaranteed by ::TimeLoad)
#define TIME_PERSISTPUT(hr, pvarAttr, refAttr, idl_arg_type, PropPutFn) \
{ \
    LPWSTR pstrTemp = NULL; \
    Assert(VT_BSTR == V_VT(pvarAttr)); \
    /* cache the bstr */ \
    if (NULL != V_BSTR(pvarAttr)) \
    { \
        /* intentionally ignoring NULL return value */ \
        pstrTemp = CopyString(V_BSTR(pvarAttr)); \
    } \
    /* use put_xxx COM accessor */ \
    TIME_PUT_##idl_arg_type(hr, pvarAttr, PropPutFn); \
    /* Assert that variant was not modified by COM Accessor */ \
    /* set the persisted string (do not delete pstrTemp because the storage is re-used) */ \
    refAttr##.SetStringFromPersistenceMacro(pstrTemp); \
}


#define TIME_CALLFN(ClassName, pvObj, Function)       static_cast<##ClassName##*>(##pvObj##)->##Function

//+-------------------------------------------------------------------------------------
//
// Macro: TIME_PERSIST_FN 
//
// Synopsis: This is the top level macro used to create static functions for the TIME_PERSISTENCE_MAP.
//           It provides a static, in-place definition for the ::TimePersist_[FnName] functions.
// 
// Arguments: [FnName]      Name of function (should be globally unique, one per attribute)
//            [ClassName]   Name of class that supports this attribute
//            [GetAttr_fn]  Name of accessor for the CAttr<> that stores this attribute
//            [put_fn]      Name of COM put_ function
//            [get_fn]      Name of COM get_ function
//            [idl_ArgType] VARTYPE of the COM put_function argument. It is assumed that the 
//                          VARTYPE of the COM get_function argument is [idl_ArgType]*
//
//--------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------------------
//
// Function: ::TimePersist_[FnName] (FnName is a macro parameter, see above comment)
//
// Synopsis: This function is called from ::TimeLoad and ::TimeSave, which iterate through 
//           the TIME_PERSISTENCE_MAP (which stores a pointer to this function). 
//
//           While loading an attribute, it first puts the attribute by calling the COM put_ method,
//           and then sets the persisted string on the CAttr (The order is important, because
//           the COM put_ functions clear the persisted string since it is expected to be invalid
//           once the attribute has bee set by the DOM).
//
//           While saving an attribute, it tries to get the persisted string from the CAttr. If
//           that fails, and if the attribute has been set by the DOM, it uses the COM get_ methods
//           to get the attribute value. Finally, if the attribute has not been set then it sets
//           the variant's VARTYPE field to VT_NULL to indicate that this attribute is not to be saved.
//             
// Arguments:   [pvObj]     pointer to the CTIMEXXXElement
//              [pvarAttr]  pointer to Variant that holds a bstr value (for puts) or that
//                          will return the attribute value (for gets)
//              [fPut]      flag that indicates whether to get or put the attribute
//
//--------------------------------------------------------------------------------------


#define TIME_PERSIST_FN(FnName, ClassName, GetAttr_fn, put_fn, get_fn, idl_ArgType) \
static HRESULT TimePersist_##FnName(void * pvObj, VARIANT * pvarAttr, bool fPut) \
{ \
    HRESULT hr = S_OK; \
    if (fPut) \
    { \
        TIME_PERSISTPUT(hr, \
                        pvarAttr, \
                        TIME_CALLFN(ClassName, pvObj, GetAttr_fn)(), \
                        idl_ArgType, \
                        TIME_CALLFN(ClassName, pvObj, put_fn)); \
    } \
    else \
    { \
        TIME_PERSISTGET(hr, \
                        pvarAttr, \
                        TIME_CALLFN(ClassName, pvObj, GetAttr_fn)(), \
                        idl_ArgType, \
                        TIME_CALLFN(ClassName, pvObj, get_fn)); \
    } \
    return hr; \
}


#endif // _ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\array.h ===
#ifndef _ARRAY_H_
#define _ARRAY_H_

//************************************************************
//
// FileName:        array.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//
//************************************************************

#pragma once

#define ULREF_IN_DESTRUCTOR 256

//************************************************************
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        DeleteItem(int i)  Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//************************************************************

//************************************************************
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    m_c          Current size of the array
//              m_pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//************************************************************

class CImplAry
{
    friend class CBaseEnum;
    friend class CEnumGeneric;
    friend class CEnumVARIANT;

public:
    virtual ~CImplAry();

    inline long Size() const
    {
        return m_c;
    } // Size

    inline void SetSize(int c)
    {
        m_c = c;
    } // SetSize

    inline operator void *()
    {
        return PData();
    } // void *
    
    void DeleteAll();

    void * Deref(size_t cb, int i);

    NO_COPY(CImplAry);

protected:

    //  Methods which are wrapped by inline subclass methods
    CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void *pv, void **ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void *pv);
    int         FindIndirect(size_t cb, void *);

    void        DeleteItem(size_t cb, int i);
    bool        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void *pv, bool fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(size_t   cb,
                             REFIID   iid,
                             void   **ppv,
                             bool     fAddRef,
                             bool     fCopy = true,
                             bool     fDelete = true);

    HRESULT     EnumVARIANT(size_t         cb,
                            VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);

    inline bool UsingStackArray()
    {
        return m_fDontFree;
    } // UsingStackArray

    UINT GetStackSize()
    { 
        Assert(m_fStack);
        return *(UINT*)((BYTE*)this + sizeof(CImplAry));
    } // GetStackSize

    void * GetStackPtr()
    {
        Assert(m_fStack);
        return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int));
    } // GetStackPtr

    bool          m_fStack;    // Set if we're a stack-based array.
    bool          m_fDontFree; // Cleared if m_pv points to alloced memory.
    unsigned long m_c;         // Count of elements

    void           *m_pv;

    inline void * & PData()
    {
        return m_pv;
    } // PData
};

//************************************************************
//
//  Member:     CImplAry::CImplAry
//
//************************************************************

inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
} // CImplAry 

//************************************************************
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//************************************************************

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));

    return ((BYTE *) PData()) + i * cb;
} // Deref

//************************************************************
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//************************************************************

class CImplPtrAry : public CImplAry
{
protected:
    CImplPtrAry() : CImplAry()
    {
    } // CImplPtrAry

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    bool        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, bool fAddRef);


public:
    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        DeleteItem(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);

    HRESULT     EnumElements(REFIID iid,
                             void **ppv,
                             bool   fAddRef,
                             bool   fCopy = true,
                             bool   fDelete = true);

    HRESULT     EnumVARIANT(VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);
}; // CImplPtrAry

//************************************************************
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    CDataAry() : CImplAry()
    {
    } // CDataAry

    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *

    CDataAry(const CDataAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT EnsureSize(long c)
    {
        return CImplAry::EnsureSize(sizeof(ELEM), c);
    } // EnsureSize
    
    HRESULT Grow(int c)
    {
        return CImplAry::Grow(sizeof(ELEM), c);
    } // Grow
    
    HRESULT AppendIndirect(ELEM *pe, ELEM **ppePlaced=NULL)
    {
        return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced);
    } // AppendIndirect
    
    ELEM * Append()
    {
        ELEM *pElem;
        return AppendIndirect( NULL, & pElem ) ? NULL : pElem;
    } // Append
    
    HRESULT InsertIndirect(int i, ELEM * pe)
    {
        return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe);
    } // InsertIndirect
    
    int FindIndirect(ELEM * pe)
    {
        return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe);
    } // FindIndirect
    
    void DeleteItem(int i)
    {
        CImplAry::DeleteItem(sizeof(ELEM), i);
    } // DeleteItem
    
    bool DeleteByValueIndirect(ELEM *pe)
    {
        return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe);
    } // DeleteByValueIndirect
    
    void DeleteMultiple(int start, int end)
    {
        CImplAry::DeleteMultiple(sizeof(ELEM), start, end);
    } // DeleteMultiple
    
    HRESULT CopyAppend(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return CImplAry::Copy(sizeof(ELEM), ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pv, bool fAddRef)
    {
        return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef);
    } // CopyIndirect

    HRESULT EnumElements(REFIID  iid,
                         void  **ppv,
                         bool    fAddRef,
                         bool    fCopy = true,
                         bool    fDelete = true)
    {
        return CImplAry::EnumElements(sizeof(ELEM), iid, ppv, fAddRef, fCopy, fDelete);
    } // EnumElements

    HRESULT EnumVARIANT(VARTYPE        vt,
                        IEnumVARIANT **ppenum,
                        bool           fCopy = true,
                        bool           fDelete = true)
    {
        return CImplAry::EnumVARIANT(sizeof(ELEM), vt, ppenum, fCopy, fDelete);
    } // EnumVARIANT
}; // CDataAry

//************************************************************
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:

    CPtrAry() : CImplPtrAry()
    {
        Assert(sizeof(ELEM) == sizeof(void*));
    } // CPtrAry
    
    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *
    
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT Append(ELEM e)
    {
        return CImplPtrAry::Append((void*)e);
    } // Append

    HRESULT Insert(int i, ELEM e)
    {
        return CImplPtrAry::Insert(i, (void*)e);
    } // Insert

    bool DeleteByValue(ELEM e)
    {
        return CImplPtrAry::DeleteByValue((void*)e);
    } // DeleteByValue

    int Find(ELEM e)
    {
        return CImplPtrAry::Find((void*)e);
    } // Find

    HRESULT CopyAppend(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return CImplPtrAry::Copy(ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pe, bool fAddRef)
    {
        return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef);
    } // CopyIndirect
}; // CPtrAry

//************************************************************
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    CStackDataAry(): CDataAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackDataAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackDataAry
/*lint --flb*/

//************************************************************
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    CStackPtrAry() : CPtrAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackPtrAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackPtrAry
/*lint --flb*/

//************************************************************
//
//  Class:      CBaseEnum (benum)
//
//  Purpose:    Base OLE enumerator class for a CImplAry.
//
//  Interface:  DECLARE_FORMS_STANRARD_IUNKNOWN
//
//              Next                   -- Per IEnum*
//              Skip                   --    ""
//              Reset                  --    ""
//              Clone                  --    ""
//              CBaseEnum              -- ctor.
//              CBaseEnum              -- ctor.
//              ~CBaseEnum             -- dtor.
//              Init                   -- 2nd stage initialization.
//              Deref                  -- gets pointer to element.
//
//  Notes:      Since there is no IEnum interface, we create a vtable
//              with the same layout as all IEnum interfaces.  Be careful
//              where you put virtual function declarations!
//
//************************************************************

class CBaseEnum : public IUnknown
{
public:
    //
    // IUnknown
    //
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    
    STDMETHOD_(ULONG, AddRef) (void)
    {
        return ++m_ulRefs;
    } // AddRef

    STDMETHOD_(ULONG, Release) (void)
    {
        if (--m_ulRefs == 0)
        {
            m_ulRefs = ULREF_IN_DESTRUCTOR;
            delete this;
            return 0;
        }
        return m_ulRefs;
    } // Release

    ULONG GetRefs(void)
    {
        return m_ulRefs;
    } // GetRefs

    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched) PURE;
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (CBaseEnum ** ppenum) PURE;

    //
    // Ensure that vtable contains virtual destructor after other virtual methods.
    //
    virtual ~CBaseEnum();

protected:
    CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CBaseEnum(const CBaseEnum & benum);

    CBaseEnum& operator=(const CBaseEnum & benum); // don't define

    HRESULT Init(CImplAry *rgItems, bool fCopy);
    void *  Deref(int i);

    CImplAry   *m_rgItems;
    const IID  *m_piid;
    int         m_i;
    size_t      m_cb;
    bool        m_fAddRef;
    bool        m_fDelete;
    ULONG       m_ulRefs;
    CBaseEnum();
}; // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::Deref
//
//  Synopsis:   Forwards deref to m_rgItems.  Required because classes derived
//              from CBaseEnum are friends of CImplAry.
//
//************************************************************

inline void *
CBaseEnum::Deref(int i)
{
    Assert(i >= 0);
    return (BYTE *)m_rgItems->PData() + i * m_cb;
} // Deref 

#endif // _ARRAY_H_

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\clock.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _CLOCK_H
#define _CLOCK_H

#include <ocmm.h>
#include <htmlfilter.h>

// This needs to be implemented by the object that wants to be called
// back on timer ticks

class ClockSink
{
  public:
    virtual void OnTimer(double time)=0;
};

// This is the base clock implementation

enum ClockState
{
    CS_STARTED,
    CS_PAUSED,
    CS_STOPPED
};

class Clock
    : public ITimerSink
{
  public :
    Clock();
    virtual ~Clock();

    HRESULT SetITimer(IServiceProvider * sp, ULONG iInterval);
    void SetSink(ClockSink *pClockSink)
    {
        m_pClockSink = pClockSink;
    }

    HRESULT Start();
    HRESULT Pause();
    HRESULT Resume();
    HRESULT Stop();

    // For the timer sink.
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

    // For the starvation sniffer
    void WINAPI StarvationCallback (void);
    static LRESULT __stdcall StarveWndProc (HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);

    double GetCurrentTime() { return m_curTime; }
    ClockState GetCurrentState() { return m_state; }
  protected :
    ULONG                      m_ulRefs;
    ClockState                 m_state;
    CComPtr<ITimer>            m_timer;
    DWORD                      m_cookie;
    ClockSink                 *m_pClockSink;
    ULONG                      m_interval;
    double                     m_lastTime;
    double                     m_curTime;
    UINT                       m_uStarveTimerID;
    HWND                       m_hWndStarveTimer;
    ULONG                      m_ulLastStarvationCallback;
    long                       m_lConsectiveStarvedTicks;
    bool                       m_fAllowOnTimer;
    bool                       m_fAllowStarvationCallback;

    HRESULT StartITimer();
    HRESULT StopITimer();

    void CreateStarveTimerWindow (void);
    void SetStarveTimer (void);
    
    ULONG GetNextInterval (void);
    HRESULT SetNextTimerInterval (ULONG ulNextInterval);

    double GetITimerTime();
    double GetGlobalTime() { return GetITimerTime(); }

    void ProcessCB(double time);
};


#endif /* _CLOCK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}


template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    operator T*() const { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T& operator*() const { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator->() const { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

//
// This is copied almost directly from atlcom.h.  It only changes the
// way we load the typelib to not use the registry but the current
// DLL.
//

// Create our own CComTypeInfoHolder so we can ensure which typelib is
// loaded

class CTIMEComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
        const GUID* m_pguid;
        const TCHAR * m_ptszIndex;

        ITypeInfo* m_pInfo;
        long m_dwRef;

public:
        HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

        void AddRef();
        void Release();
        HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid);
        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// ITIMEDispatchImpl

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex = NULL,
          class tihclass = CTIMEComTypeInfoHolder>
class ATL_NO_VTABLE ITIMEDispatchImpl : public T
{
public:
        typedef tihclass _tihclass;
        ITIMEDispatchImpl() {_tih.AddRef();}
        virtual ~ITIMEDispatchImpl() {_tih.Release();}

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {*pctinfo = 1; return S_OK;}

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
        static _tihclass _tih;
        static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {return _tih.GetTI(lcid, ppInfo);}
};

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex,
          class tihclass>
typename ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tihclass
ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tih =
{piid, ptszIndex, NULL, 0};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\empty.cpp ===
#include "headers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\headers.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: headers.h
//
//  Contents: Precompiled header for mstime.dll
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef DAL_HEADERS_HXX
#define DAL_HEADERS_HXX
#define DIRECTDRAW_VERSION 0x0300

//
//  STL needs a _Lockit class.  However, this causes us to start linking to
//  msvcp60.dll which is 400k and we don't currently ship it.  Obviously,
//  this wouldn't be efficient.  So instead of doing that, we will instead fake
//  out the header that we can implement our own version of _Lockit
//
#undef _DLL
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#define _DLL
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)


// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#define NEW new
#define AssertStr AssertSz
#ifndef INCMSG
//#define INCMSG(x)
#define INCMSG(x) message(x)
#endif

#pragma warning(disable:4530)

// Don't overload operator new -- it messes
// up the STL new operator (UG!)
#define TRIMEM_NOOPNEW

#ifndef X_TRIRT_H_
#define X_TRIRT_H_
#pragma INCMSG("--- Beg 'trirt.h'")
#include "trirt.h"
#pragma INCMSG("--- End 'trirt.h'")
#endif

#ifndef X_DAATL_H_
#define X_DAATL_H_
#pragma INCMSG("--- Beg 'daatl.h'")
#include "daatl.h"
#pragma INCMSG("--- End 'daatl.h'")
#endif

/* Standard */
#ifndef X_MATH_H_
#define X_MATH_H_
#pragma INCMSG("--- Beg <math.h>")
#include <math.h>
#pragma INCMSG("--- End <math.h>")
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#pragma INCMSG("--- Beg <stdio.h>")
#include <stdio.h>
#pragma INCMSG("--- End <stdio.h>")
#endif

#ifndef X_STDLIB_H_
#define X_STDLIB_H_
#pragma INCMSG("--- Beg <stdlib.h>")
#include <stdlib.h>
#pragma INCMSG("--- End <stdlib.h>")
#endif

#ifndef X_MEMORY_H_
#define X_MEMORY_H_
#pragma INCMSG("--- Beg <memory.h>")
#include <memory.h>
#pragma INCMSG("--- End <memory.h>")
#endif

#ifndef X_WTYPES_H_
#define X_WTYPES_H_
#pragma INCMSG("--- Beg <wtypes.h>")
#include <wtypes.h>
#pragma INCMSG("--- End <wtypes.h>")
#endif


#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#pragma INCMSG("--- Beg <mshtmhst.h>")
#include <mshtmhst.h>
#pragma INCMSG("--- End <mshtmhst.h>")
#endif

#ifndef X_MSHTML_H_
#define X_MSHTML_H_
#pragma INCMSG("--- Beg <mshtml.h>")
#include <mshtml.h>
#pragma INCMSG("--- End <mshtml.h>")
#endif


#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#pragma INCMSG("--- Beg <ddraw.h>")
#include <ddraw.h>
#pragma INCMSG("--- End <ddraw.h>")
#endif


#ifndef X_SHLWAPI_H_
#define X_SHLWAPI_H_
#pragma INCMSG("--- Beg <shlwapi.h>")
#include <shlwapi.h>
#pragma INCMSG("--- End <shlwapi.h>")
#endif


#define LIBID __T("MSTIME")

extern HINSTANCE g_hInst;

//+------------------------------------------------------------------------
//
//  Implement THR and IGNORE_HR for TIME code
//
//  This is to allow tracing of TIME-only THRs and IGNORE_HRs. Trident's THR 
//  and IGNORE_HR output is too polluted to allow TIME failures to be easily detected.
//
//-------------------------------------------------------------------------

#undef THR
#undef IGNORE_HR

#if DBG == 1
#define THR(x) THRTimeImpl(x, #x, __FILE__, __LINE__)
#define IGNORE_HR(x) IGNORE_HRTimeImpl(x, #x, __FILE__, __LINE__)
#else
#define THR(x) x
#define IGNORE_HR(x) x
#endif // if DBG == 1

//+------------------------------------------------------------------------
//
//  NO_COPY *declares* the constructors and assignment operator for copying.
//  By not *defining* these functions, you can prevent your class from
//  accidentally being copied or assigned -- you will be notified by
//  a linkage error.
//
//-------------------------------------------------------------------------

#define NO_COPY(cls)    \
    cls(const cls&);    \
    cls& operator=(const cls&)

#ifndef X_UTIL_H_
#define X_UTIL_H_
#pragma INCMSG("--- Beg 'util.h'")
#include "util.h"
#pragma INCMSG("--- End 'util.h'")
#endif

#ifndef X_MSTIME_H_
#define X_MSTIME_H_
#pragma INCMSG("--- Beg 'mstime.h'")
#include "mstime.h"
#pragma INCMSG("--- End 'mstime.h'")
#endif

#ifndef X_COMUTIL_H_
#define X_COMUTIL_H_
#pragma INCMSG("--- Beg 'comutil.h'")
#include "comutil.h"
#pragma INCMSG("--- End 'comutil.h'")
#endif

#ifndef X_TIMEENG_H_
#define X_TIMEENG_H_
#pragma INCMSG("--- Beg 'timeeng.h'")
#include "timeeng.h"
#pragma INCMSG("--- End 'timeeng.h'")
#endif

#ifndef X_LIST_
#define X_LIST_
#pragma INCMSG("--- Beg <list>")
#include <list>
#pragma INCMSG("--- End <list>")
#endif

#ifndef X_SET_
#define X_SET_
#pragma INCMSG("--- Beg <set>")
#include <set>
#pragma INCMSG("--- End <set>")
#endif

#ifndef X_ARRAY_H_
#define X_ARRAY_H_
#pragma INCMSG("--- Beg 'array.h'")
#include "array.h"
#pragma INCMSG("--- End 'array.h'")
#endif

#ifndef X_MAP_
#define X_MAP_
#pragma INCMSG("--- Beg <map>")
#include <map>
#pragma INCMSG("--- End <map>")
#endif

#ifndef X_SHLWAPI_H_
#define X_SHLWAPI_H_
#pragma INCMSG("--- Beg 'shlwapi.h'")
#include "shlwapi.h"
#pragma INCMSG("--- End 'shlwapi.h'")
#endif

#ifndef X_WININET_H_
#define X_WININET_H_
#pragma INCMSG("--- Beg <wininet.h>")
#include <wininet.h>
#pragma INCMSG("--- End <wininet.h>")
#endif

#ifndef X_MINMAX_H_
#define X_MINMAX_H_
#pragma INCMSG("--- Beg <minmax.h>")
#include <minmax.h>
#pragma INCMSG("--- End <minmax.h>")
#endif


#pragma warning(disable:4102)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\dlldatax.h ===
#ifndef _DLLDATAX_H_
#define _DLLDATAX_H_

#pragma once

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}


#endif // _DLLDATAX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\daatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DAATL_H
#define _DAATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

void   __cdecl ATL_free(void *);
void * __cdecl ATL_malloc(size_t);
void * __cdecl ATL_realloc(void *, size_t);

#ifndef X_ATLBASE_H_
#define X_ATLBASE_H_
#pragma INCMSG("--- Beg <atlbase.h>")
#include <atlbase.h>
#pragma INCMSG("--- End <atlbase.h>")
#endif


// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DBG
    void AddComPtr(void *ptr, const _TCHAR * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#ifndef X_ATLCOM_H_
#define X_ATLCOM_H_
#pragma INCMSG("--- Beg <atlcom.h>")
#include <atlcom.h>
#pragma INCMSG("--- End <atlcom.h>")
#endif

#ifndef X_ATLCTL_H_
#define X_ATLCTL_H_
#pragma INCMSG("--- Beg <atlctl.h>")
#include <atlctl.h>
#pragma INCMSG("--- End <atlctl.h>")
#endif


#if DBG
#ifndef X_TYPEINFO_H_
#define X_TYPEINFO_H_
#pragma INCMSG("--- Beg <typeinfo.h>")
#include <typeinfo.h>
#pragma INCMSG("--- End <typeinfo.h>")
#endif
#endif

#undef malloc
#undef free
#undef realloc


#endif /* _DAATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\importman.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\importman.h
//
//  Contents: declaration for CImportManager, CImportManagerList
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _IMPORTMAN_H
#define _IMPORTMAN_H

#include "threadsafelist.h"

#include "atomtable.h"

class CImportManager;

static const LONG NUMBER_THREADS_TO_SPAWN = 2;

CImportManager* GetImportManager(void);

class CImportManagerList :
    public CThreadSafeList
{
  public:
    CImportManagerList();
    virtual ~CImportManagerList();
  
    virtual HRESULT Add(ITIMEImportMedia * pImportMedia);

  protected:
    HRESULT FindMediaDownloader(ITIMEImportMedia * pImportMedia, ITIMEMediaDownloader** ppDownloader, bool * pfExisted);
    HRESULT GetNode(std::list<CThreadSafeListNode*> &listToCheck, const long lID, bool * pfExisted, ITIMEMediaDownloader ** ppMediaDownloader);
};


class CImportManager
{
  public:
    CImportManager();
    virtual ~CImportManager();

    HRESULT Init();
    HRESULT Detach();

    HRESULT Add(ITIMEImportMedia * pImportMedia);
    HRESULT Remove(ITIMEImportMedia * pImportMedia);

    HRESULT DataAvailable();
    
    HRESULT RePrioritize(ITIMEImportMedia * pImportMedia);

  protected:
    CImportManager(const CImportManager&);

    HRESULT StartThreads();

  private:
    HANDLE m_handleThread[NUMBER_THREADS_TO_SPAWN];
    CImportManagerList * m_pList;

    LONG m_lThreadsStarted;
};

#endif // _IMPORTMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\eventmgr.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1999 Microsoft Corporation
//
// File: EventMgr.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTMGR_H
#define _EVENTMGR_H

#include "mshtml.h"
#include "eventmgrmacros.h"
#include "timevalue.h"


#define INVALID_DISPID -1

///////////////////////////////////////////////////////////////
// This is the base class that must be implemented in the behavior
// to allow the event manager and the behavior class communicate.
///////////////////////////////////////////////////////////////

class CTIMEEventSite : 
    public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE EventNotify( 
        long event) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onBeginEndEvent(bool bBegin, float beginTime, float beginOffset, bool bend, float endTime, float endOffset) = 0;
   
    virtual HRESULT STDMETHODCALLTYPE onPauseEvent(float time, float offset) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onResumeEvent(float time, float offset) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onLoadEvent() = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onUnloadEvent() = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onReadyStateChangeEvent( 
        LPOLESTR lpstrReadyState) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onStopEvent(float time) = 0;
    
    virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_playState( 
        /* [retval][out] */ long __RPC_FAR *time) = 0;
    
    virtual /* [propget] */ float GetGlobalTime() = 0;
               
    virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
    
    virtual ULONG STDMETHODCALLTYPE Release( void) = 0;

    virtual bool IsThumbnail() = 0;
    
};





///////////////////////////////////////////////////////////////
// structures
///////////////////////////////////////////////////////////////

struct EventItem
{
    LPOLESTR  pEventName;
    LPOLESTR  pElementName;
    bool      bAttach;       //this field indicates whether the event should be
                             //attached to.  It is used to flag duplicate events
                             //so that only a single event can be attached to.
    float     offset;        //for passing timing information back to the timeelmbase.
};

struct Event
{
    EventItem *pEventList; 
    DISPID *pEventDispids;          //list of dispids for document events for each type of event
    IHTMLElement2 **pEventElements; //cached list of IHTMLElements that each event list references
    long lEventCount;               //count of events in list
    bool *pbDynamicEvents;          //flags to show whether event is presumed to be dynamic or not
};


//
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// enums
///////////////////////////////////////////////////////////////
enum TIME_EVENT  //these are events that Event Manager can fire
{
    TE_ONTIMEERROR = 0,
    TE_ONBEGIN,
    TE_ONPAUSE, 
    TE_ONRESUME, 
    TE_ONEND,
    TE_ONRESYNC,
    TE_ONREPEAT,
    TE_ONREVERSE,
    TE_ONMEDIACOMPLETE,
    TE_ONOUTOFSYNC,
    TE_ONSYNCRESTORED,
    TE_ONMEDIAERROR,
    TE_ONRESET,
    TE_ONSCRIPTCOMMAND,
    TE_ONMEDIABARTARGET,
    TE_ONURLFLIP,
    TE_ONTRACKCHANGE,
    TE_GENERIC,
    TE_ONSEEK,
    TE_ONMEDIAINSERTED,
    TE_ONMEDIAREMOVED,
    TE_ONTRANSITIONINBEGIN,
    TE_ONTRANSITIONINEND,
    TE_ONTRANSITIONOUTBEGIN,
    TE_ONTRANSITIONOUTEND,
    TE_ONTRANSITIONREPEAT,
    TE_ONUPDATE,
    TE_ONCODECERROR,
    TE_MAX
};

enum TIME_EVENT_NOTIFY  //these are events that event manager can sync and notify the 
{                       //managed class of.
    TEN_LOAD = 0,
    TEN_UNLOAD,
    TEN_STOP,
    TEN_READYSTATECHANGE,
    TEN_MOUSE_DOWN,
    TEN_MOUSE_UP,
    TEN_MOUSE_CLICK,
    TEN_MOUSE_DBLCLICK,
    TEN_MOUSE_OVER,
    TEN_MOUSE_OUT,
    TEN_MOUSE_MOVE,
    TEN_KEY_DOWN,
    TEN_KEY_UP,
    TEN_FOCUS,
    TEN_RESIZE,
    TEN_BLUR,
    TEN_MAX
};

enum TIME_EVENT_TYPE
{
    TETYPE_BEGIN = 0,
    TETYPE_END
};
//
///////////////////////////////////////////////////////////////


class CEventMgr
    : public IDispatch
{
  public:
    CEventMgr();
    virtual ~CEventMgr();

    //methods

    // These are functions that are used by the macros
    // they should not be called directly.
    HRESULT _InitEventMgrNotify(CTIMEEventSite *pEventSite);
    HRESULT _RegisterEventNotification(TIME_EVENT_NOTIFY event_id);
    HRESULT _RegisterEvent(TIME_EVENT event_id);
    HRESULT _SetTimeEvent(int type, LPOLESTR lpstrEvents);
    HRESULT _SetTimeEvent(int type, TimeValueList & tvList);
    HRESULT _Init(IHTMLElement *pEle, IElementBehaviorSite *pEleBehaviorSite);
    HRESULT _Deinit();
    HRESULT _FireEvent(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[],
                       float fTime); 

    HRESULT _RegisterDynamicEvents(LPOLESTR lpstrEvents);  //unsure how this will be handled or used.
    HRESULT _ToggleEndEvent(bool bOn);

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

  protected:
    //////////////////////////////////////////////////
    //data
    //////////////////////////////////////////////////

    //Cookie for the Window ConnectionPoint
    CComPtr<IConnectionPoint>        m_pWndConPt;
    CComPtr<IConnectionPoint>        m_pDocConPt;

    Event                            *m_pBeginEvents;
    Event                            *m_pEndEvents;

    // event cookies
    long                              m_cookies[TE_MAX];
    DWORD                             m_dwWindowEventConPtCookie;
    DWORD                             m_dwDocumentEventConPtCookie;

    // callback interface
    CTIMEEventSite                   *m_pEventSite;
    CComPtr <IHTMLElement>           m_pElement; //This is the element that the behavior is attached to.

    // status flags
    bool                              m_bInited;
    float                             m_fLastEventTime;
    bool                              m_bAttached;
    bool                              m_bEndAttached;
    bool                              m_bUnLoaded;
                                                                                                                  //the playstate has already been updated
    // Registered events
    bool                              m_bRegisterEvents[TE_MAX];  //determines if the managed class wants 
                                                                  //to register the appropriate event.
    bool                              m_bNotifyEvents[TEN_MAX];   //determines if the managed class wants 
                                                                  //to be notified of the appropriate event.
    IElementBehaviorSiteOM           *m_pBvrSiteOM;
    long                              m_lRefs;
    bool                              m_bDeInited;
    bool                              m_bReady;
    long                              m_lEventRecursionCount;

    //////////////////////////////////////////////////
    //methods
    //////////////////////////////////////////////////
    HRESULT                           RegisterEvents();   
    HRESULT                           ConnectToContainerConnectionPoint();
    long                              GetEventCount(LPOLESTR lpstrEvents);
    void                              EventMatch(IHTMLEventObj *pEventObj, Event *pEvent, BSTR bstrEvent, TIME_EVENT_TYPE evType, float fTime, bool *bZeroOffsetMatch);
    void                              EventNotifyMatch(IHTMLEventObj *pEventObj);
    void                              AttachNotifyEvents();
    void                              DetachNotifyEvents();
    HRESULT                           AttachEvents();
    HRESULT                           Attach(Event *pEvents);
    HRESULT                           DetachEvents();
    HRESULT                           Detach(Event *pEvents);
    HRESULT                           FireDynamicEvent(TIME_EVENT TimeEvent, long Count, LPWSTR szParamNames[], VARIANT varParams[], float fTime);
    HRESULT                           SetNewEventList(LPOLESTR lpstrEvents, Event **EventList);
    HRESULT                           SetNewEventStruct(TimeValueList & tvList,
                                                        Event **ppEvents);
    HRESULT                           GetEvents(LPOLESTR lpstrEvents, EventItem *pEvents, long lEventCount);
    void                              FindDuplicateEvents();
    void                              MarkSelfDups(Event *pEvents);
    void                              MarkDups(Event *pSrcEvents, Event *pDestEvents);
    bool                              ValidateEvent(LPOLESTR lpstrEventName, IHTMLEventObj2 *pEventObj, IHTMLElement *pElement);
    int                               isTimeEvent(LPOLESTR lpszEventName);
    long                              GetEventCount(TimeValueList & tvList);
    void                              UpdateReadyState();
};

#endif /* _EVENTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\eventmgrmacros.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelmbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _EVENTMGRMACROS_H
#define _EVENTMGRMACROS_H

#define TEM_BEGINEVENT 1
#define TEM_ENDEVENT 2

///////////////////////////////////////////////////////////////
// MACROS
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// These make up calls that can only appear in the event map
///////////////////////////////////////////////////////////////


#define DECLARE_EVENT_MANAGER()             CEventMgr  *m_EventMgr;       

// creates an init function that sets data then calls _Init()
#define BEGIN_TIME_EVENTMAP()               virtual HRESULT _InitEventMgr(IHTMLElement *pEle, IElementBehaviorSite *pEleBehaviorSite) \
                                            {                                   \
                                                HRESULT hr = S_OK;              \
                                                CComPtr <IHTMLElement> pEle2 = NULL;    \
                                                m_EventMgr = NEW CEventMgr;    \
                                                if (!m_EventMgr)                \
                                                {                               \
                                                    goto done;                  \
                                                }                               


//calls _RegisterEvent
#define TEM_REGISTER_EVENT(event_id)                hr = THR(m_EventMgr->_RegisterEvent(event_id)); \
                                                    if (FAILED(hr))                     \
                                                    {                                   \
                                                        goto done;                      \
                                                    }                                   
        
// calls _RegisterEventNotification      
#define TEM_REGISTER_EVENT_NOTIFICATION(event_id)   hr = THR(m_EventMgr->_RegisterEventNotification(event_id)); \
                                                    if (FAILED(hr))                                 \
                                                    {                                               \
                                                        goto done;                                  \
                                                    }

//calls _InitEventMgrNotify                                              
#define TEM_INIT_EVENTMANAGER_SITE()                m_EventMgr->_InitEventMgrNotify((CTIMEEventSite *)this);                     \
                                                    
// handles some cleanup and closes the function started by BEGIN_TIME_EVENTMAP();
#define END_TIME_EVENTMAP()                         hr = THR(pEle->QueryInterface(IID_IHTMLElement, (void **)&pEle2)); \
                                                    if (FAILED(hr))                             \
                                                    {                                           \
                                                        goto done;                              \
                                                    }                                           \
                                                    m_EventMgr->_Init(pEle2, pEleBehaviorSite);  \
                                                  done:                                         \
                                                    return hr;                                  \
                                                }


///////////////////////////////////////////////////////////////
// These are macro's that can be used anywhere.
///////////////////////////////////////////////////////////////

//calls into the init function created by BEGIN_TIME_EVENTMAP()
// This takes an HRESULT hr that should be checked on return. 
// an IHTMLElement *pEle that is the element the behavior is attached to,
// an IHTMLElementBehaviorSite *pEleBehaviorSite.
#define TEM_INIT_EVENTMANAGER(pEle, pEleBehaviorSite)   THR(_InitEventMgr(pEle, pEleBehaviorSite))
                                                        

//calls _Deinit
// This will return an HRESULT that should be checked for success
#define TEM_CLEANUP_EVENTMANAGER()      if (NULL != m_EventMgr) \
                                        { \
                                            IGNORE_HR(m_EventMgr->_Deinit());   \
                                        }

//deletes the eventmgr.
#define TEM_DELETE_EVENTMGR()           if (NULL != m_EventMgr) \
                                        { \
                                            delete m_EventMgr;                  \
                                            m_EventMgr = NULL; \
                                        }

//calls _FireEvent
// This will return an HRESULT that should be checked for success
#define TEM_FIRE_EVENT(event, param_count, param_names, params, time)  (m_EventMgr != NULL ? THR(m_EventMgr->_FireEvent(event, param_count, param_names, params, time)) : E_FAIL)

//calls _SetBeginEvent
// This will return an HRESULT that should be checked for success
#define TEM_SET_TIME_BEGINEVENT(event_list)     (m_EventMgr != NULL ? THR(m_EventMgr->_SetTimeEvent(TEM_BEGINEVENT, event_list)) : E_FAIL)

//calls _SetEndEvent
// This will return an HRESULT that should be checked for success
#define TEM_SET_TIME_ENDEVENT(event_list)       (m_EventMgr != NULL ? THR(m_EventMgr->_SetTimeEvent(TEM_ENDEVENT, event_list)) : E_FAIL)

//calls _ToggleEndEvent
#define TEM_TOGGLE_END_EVENT(bOn)               (m_EventMgr != NULL ? m_EventMgr->_ToggleEndEvent(bOn) : E_FAIL)

// used in constructor to initialize the eventmanager
#define TEM_DECLARE_EVENTMGR()                  (m_EventMgr = NULL)
// used in destructor to free the eventmanager
#define TEM_FREE_EVENTMGR()                     if (m_EventMgr != NULL) \
                                                {                       \
                                                    delete m_EventMgr;  \
                                                    m_EventMgr = NULL;  \
                                                }                       

//calls _RegisterDynamicEvents
// This will return an HRESULT that should be checked for success
// UNDONE;
#define REGISTER_DYNAMIC_TIME_EVENTS(eventlist)                 
//
///////////////////////////////////////////////////////////////

#endif /* _EVENTMGRMACROS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\loader.h ===
// loader.h : 
//
// (c) 1999 Microsoft Corporation.
//

#ifndef __LOADER_H_
#define __LOADER_H_
#include <windows.h>
#include <objbase.h>
#include "dmusici.h"
#include <stdio.h>
#include <atlbase.h>

class CObjectRef
{
public:
    CObjectRef() { m_pNext = NULL; m_pObject = NULL; m_guidObject = GUID_NULL; m_wszFileName[0] = L'\0'; m_pStream = NULL; m_guidClass = GUID_NULL; };
    CObjectRef *    m_pNext;
    GUID            m_guidObject;
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME];
    IDirectMusicObject *    m_pObject;
    IStream *       m_pStream;
    GUID            m_guidClass;
};

class CLoader : public IDirectMusicLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicLoader
	virtual STDMETHODIMP GetObject(LPDMUS_OBJECTDESC pDesc, REFIID, LPVOID FAR *) ;
	virtual STDMETHODIMP SetObject(LPDMUS_OBJECTDESC pDesc) ;
    virtual STDMETHODIMP SetSearchDirectory(REFGUID rguidClass, WCHAR *pwzPath, BOOL fClear) ;
	virtual STDMETHODIMP ScanDirectory(REFGUID rguidClass, WCHAR *pwzFileExtension, WCHAR *pwzScanFileName) ;
	virtual STDMETHODIMP CacheObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ReleaseObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ClearCache(REFGUID rguidClass) ;
	virtual STDMETHODIMP EnableCache(REFGUID rguidClass, BOOL fEnable) ;
	virtual STDMETHODIMP EnumObject(REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc) ;
	CLoader();
	~CLoader();
	ULONG				AddRefP();			// Private AddRef, for streams.
	ULONG				ReleaseP();			// Private Release, for streams.
	HRESULT				Init();

	// Returns the segment found at bstrSrc and remembers its URL so that subsequent GetObject
	// calls from the segment resolve relative to its filename.
	HRESULT				GetSegment(BSTR bstrSrc, IDirectMusicSegment **ppSeg);

private:
    HRESULT             LoadFromFile(LPDMUS_OBJECTDESC pDesc,
                            IDirectMusicObject * pIObject);
    HRESULT             LoadFromMemory(LPDMUS_OBJECTDESC pDesc,
                            IDirectMusicObject * pIObject);
    HRESULT             LoadFromStream(REFGUID rguidClass, IStream *pStream,
                            IDirectMusicObject * pIObject);
	long				m_cRef;             // Regular COM reference count.
	long				m_cPRef;			// Private reference count.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage internal object list.
    CObjectRef *        m_pObjectList;      // List of already loaded objects.
	BSTR     			m_bstrSrc;			// Current source segment
};

class CFileStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CFileStream( CLoader *pLoader );
						~CFileStream();
	HRESULT				Open( WCHAR *lpFileName, DWORD dwDesiredAccess );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME]; // Save name for cloning.
	HANDLE			m_pFile;		// file pointer
	CLoader *		m_pLoader;
};

class CMemStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CMemStream( CLoader *pLoader );
						~CMemStream();
	HRESULT				Open( BYTE *pbData, LONGLONG llLength );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
	BYTE*			m_pbData;		// memory pointer
	LONGLONG		m_llLength;
	LONGLONG		m_llPosition;	// Current file position.
	CLoader *		m_pLoader;
};


#endif //__CDMLOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\playerbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: playerbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _PLAYERBASE_H
#define _PLAYERBASE_H

#include "playerinterfaces.h"
#include "atomtable.h"

class CPlayList;
class CTIMEMediaElement;
class CTIMEPlayerNative;
/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

typedef enum SYNC_TYPE_ENUM
{
    sync_slow,
    sync_fast,
    sync_none
}; //lint !e612

interface ITIMEBasePlayer :
    public IUnknown,
    public ITIMEPlayerObjectManagement,
    public ITIMEPlayerEventHandling,
    public ITIMEPlayerPlaybackCapabilities,
    public ITIMEPlayerStateManagement,
    public ITIMEPlayerRender,
    public ITIMEPlayerTiming,
    public ITIMEPlayerProperties,
    public ITIMEPlayerMediaContent,
    public ITIMEPlayerPlayList,
    public ITIMEPlayerIntegration,
    public ITIMEPlayerMediaContext
{
//    virtual void SetCLSID(REFCLSID clsid) = 0;
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) = 0;

    virtual HRESULT SetRate(double dblRate) = 0;
    virtual HRESULT GetRate(double &dblRate) = 0;

    virtual HRESULT onMouseMove(long x, long y) = 0;
    virtual HRESULT onMouseDown(long x, long y) = 0;

    virtual void LoadFailNotify(PLAYER_EVENT reason) = 0;
    virtual void Tick() = 0;
};

class CTIMEBasePlayer :
    public ITIMEBasePlayer
{
  public:
    CTIMEBasePlayer();
    virtual ~CTIMEBasePlayer();

    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(QueryInterface)(REFIID refiid, void** ppunk) { return E_NOTIMPL; }
    STDMETHOD_(ULONG,AddRef)(void) { return 0; }
    STDMETHOD_(ULONG,Release)(void) { return 0; }
    virtual HRESULT Init(CTIMEMediaElement *pelem, 
                         LPOLESTR base, 
                         LPOLESTR src, 
                         LPOLESTR lpMimeType = NULL, 
                         double dblClipBegin = -1.0, 
                         double dblClipEnd = -1.0);
    virtual HRESULT DetachFromHostElement (void) = 0;
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp)
    { *ppDisp = NULL; return S_OK;}
    virtual CTIMEPlayerNative *GetNativePlayer()
    { return NULL;}
    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Pause() = 0;
    virtual void Resume() = 0;
    virtual void Repeat() = 0;
    virtual HRESULT Seek(double dblTime) = 0;
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT CanSeek(bool &fcanSeek) = 0;
    virtual HRESULT CanPause(bool &fcanPause);
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT HasPlayList(bool &fhasPlayList);
    virtual HRESULT ConvertFrameToTime(LONGLONG lFrameNr, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);
    // PLAYER PLAYBACK CAPABILITIES: END

    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Reset();
    virtual PlayerState GetState();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();
    virtual void Tick();
    virtual void LoadFailNotify(PLAYER_EVENT reason);
    virtual void SetPlaybackSite(CTIMEBasePlayer *pSite);
    virtual void FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer = NULL);

    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Render(HDC hdc, LPRECT prc) = 0;
    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);
    virtual HRESULT SetSize(RECT *prect) = 0;
    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetMediaLength(double &dblLength) = 0;
    virtual HRESULT GetEffectiveLength(double &dblLength);
    virtual double GetClipBegin();
    virtual void GetClipBegin(double &dblClibBegin);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void GetClipEnd(double &dblClipEnd);
    virtual void SetClipEnd(double dblClipEnd);
    virtual void GetClipBeginFrame(long &lClibBeginFrame);
    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void GetClipEndFrame(long &lClipEndFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);
    virtual double GetCurrentTime() = 0;
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime) = 0;
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);
    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PROPERTY ACCESSORS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src) = 0;
    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pRating) ;
    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    //////////////////////////////////////////////////////////////////////////
    // PROPERTY METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle);
    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: END
    //////////////////////////////////////////////////////////////////////////

    virtual HRESULT onMouseMove(long x, long y);
    virtual HRESULT onMouseDown(long x, long y);

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);

    // These are to make our internal implementation of playlists work
    // with all players
    virtual HRESULT SetActiveTrack(long index);
    virtual HRESULT GetActiveTrack(long *index);

    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT GetDownloadProgress(double &dblDownloadProgress);

    bool IsActive() const;
    bool IsPaused() const;
    bool IsParentPaused() const;

    // This does not addref so be careful what you do with it
    IHTMLElement * GetElement();
    IServiceProvider * GetServiceProvider();

    void InvalidateElement(LPCRECT lprect);
    void PutNaturalDuration(double dblNatDur);
    void ClearNaturalDuration();
    double GetElapsedTime() const;

    double GetRealClipStart() const { return m_dblClipStart; }
    double GetRealClipEnd() const { return m_dblClipEnd; }

  protected:
    virtual HRESULT InitElementSize();

    long VolumeLinToLog(float LinKnobValue);
    float VolumeLogToLin(long LogValue);
    long BalanceLinToLog(float LinKnobValue);
    float BalanceLogToLin(long LogValue);

    CAtomTable * GetAtomTable() { return m_pAtomTable; }
    void NullAtomTable()
    { 
        if (m_pAtomTable)
            {
                ReleaseInterface(m_pAtomTable);
            }
        m_pAtomTable = NULL;
    }

    CTIMEMediaElement *m_pTIMEElementBase;
    CTIMEBasePlayer *m_pPlaybackSite;
    
    double m_dblClipStart;
    double m_dblClipEnd;
    long m_lClipStartFrame;
    long m_lClipEndFrame;

  private:
    bool m_fHavePriority;
    double m_dblPriority;
    CAtomTable *m_pAtomTable;
};

#endif /* _PLAYERBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\pbagimp.cpp ===
//*****************************************************************************
//
// File: pbagimp.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of IPersistPropertyBag2 interface
//           for all objects to call to base class.
//
// Modification List:
// Date		Author		Change
// 11/21/98	jeffort		Created this file
//
//*****************************************************************************

STDMETHODIMP 
THIS::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
THIS::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
THIS::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return SUPER::Load(pPropBag, pErrorLog);
} // Load

//*****************************************************************************

STDMETHODIMP 
THIS::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);

} // Save 

//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\playlist.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYLIST_H
#define _PLAYLIST_H

class CTIMEBasePlayer;
class CPlayItem;

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayList :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayList, &__uuidof(CPlayList)>,
    public ITIMEDispatchImpl<ITIMEPlayList, &IID_ITIMEPlayList>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayList>,
    public IConnectionPointContainerImpl<CPlayList>,
    public IPropertyNotifySinkCP<CPlayList>
{
  public:
    CPlayList();
    virtual ~CPlayList();
    HRESULT ConstructArray();
        
    HRESULT Init(CTIMEBasePlayer & player);
    void Deinit();
    
    //    
    // QI & CP Map
    //

    BEGIN_COM_MAP(CPlayList)
        COM_INTERFACE_ENTRY(ITIMEPlayList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    // 
    // ITIMEPlayList methods
    //
        
    STDMETHOD(put_activeTrack)(VARIANT vTrack);
    STDMETHOD(get_activeTrack)(ITIMEPlayItem **pPlayItem);
        
    //returns the duration of the entire playlist if it is known or -1 if it is not.
    STDMETHOD(get_dur)(double *dur);

    STDMETHOD(item)(VARIANT varIndex,
                    ITIMEPlayItem **pPlayItem);

    STDMETHOD(get_length)(long* len);

    STDMETHOD(get__newEnum)(IUnknown** p);

    STDMETHOD(nextTrack)(); //Advances the active Track by one
    STDMETHOD(prevTrack)(); //moves the active track to the previous track

    BEGIN_CONNECTION_POINT_MAP(CPlayList)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

    void Clear();
    void SetLoaded(bool bLoaded);
    void SetLoadedFlag(bool bLoaded);
    long GetLength() { return m_rgItems->Size(); }

    CPlayItem * GetActiveTrack();
    CPlayItem * GetItem(long index);
    
    HRESULT Add(CPlayItem *pPlayItem,
                long index);
    HRESULT Remove(long index);

    void SetIndex();
    long GetIndex(LPOLESTR name);

    HRESULT CreatePlayItem(CPlayItem **pPlayItem);
        
  protected:
    CPtrAry<CPlayItem *>      *m_rgItems;
    CTIMEBasePlayer *          m_player;
    bool                       m_fLoaded;
    CComVariant                m_vNewTrack;

}; //lint !e1712


class CPlayListEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{
  public:
    CPlayListEnum();
    virtual ~CPlayListEnum();

    void Init(CPlayList &playList) { m_playList = &playList; }
    
    // IEnumVARIANT methods
    STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
    STDMETHOD(Next)(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
    STDMETHOD(Reset)();
    STDMETHOD(Skip)(unsigned long celt);
    void SetCurElement(unsigned long celt);
                        
    // QI Map
    BEGIN_COM_MAP(CPlayListEnum)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP();

  protected:
    long                        m_lCurElement;
    DAComPtr<CPlayList>         m_playList;
}; //lint !e1712

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayItem :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayItem, &__uuidof(CPlayItem)>,
    public ITIMEDispatchImpl<ITIMEPlayItem2, &IID_ITIMEPlayItem2>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayItem2>,
    public IConnectionPointContainerImpl<CPlayItem>,
    public IPropertyNotifySinkCP<CPlayItem>
{
  public:
    CPlayItem();
    virtual ~CPlayItem();

    void Init(CPlayList & pPlayList) { m_pPlayList = &pPlayList; }
    void Deinit() { m_pPlayList = NULL; }

    // QI Map
    BEGIN_COM_MAP(CPlayItem)
        COM_INTERFACE_ENTRY(ITIMEPlayItem2)
        COM_INTERFACE_ENTRY(ITIMEPlayItem)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    //
    // ITIMEPlayItem interface
    //
    STDMETHOD(get_abstract)(LPOLESTR *abs);
    STDMETHOD(get_author)(LPOLESTR *auth);
    STDMETHOD(get_copyright)(LPOLESTR *cpyrght);
    STDMETHOD(get_dur)(double *dur);
    STDMETHOD(get_index)(long *index);
    STDMETHOD(get_rating)(LPOLESTR *rate);
    STDMETHOD(get_src)(LPOLESTR *src);
    STDMETHOD(get_title)(LPOLESTR *title);
    STDMETHOD(setActive)();

    
    //
    // ITIMEPlayItem2 interface
    //
    STDMETHOD(get_banner)(LPOLESTR *banner);
    STDMETHOD(get_bannerAbstract)(LPOLESTR *abstract);
    STDMETHOD(get_bannerMoreInfo)(LPOLESTR *moreInfo);
    
    //
    
    LPCWSTR GetAbstract() const { return m_abstract; }
    HRESULT PutAbstract(LPWSTR abstract);

    LPCWSTR GetAuthor() const { return m_author; }
    HRESULT PutAuthor(LPWSTR author);

    LPCWSTR GetCopyright() const { return m_copyright; }
    HRESULT PutCopyright(LPWSTR copyright);

    double GetDur() const { return m_dur; }
    void PutDur(double dur);

    long GetIndex() const { return m_lIndex; }
    void PutIndex(long index);

    LPCWSTR GetRating() const { return m_rating; }
    HRESULT PutRating(LPWSTR rating);

    LPCWSTR GetSrc() const { return m_src; }
    HRESULT PutSrc(LPWSTR src);

    LPCWSTR GetTitle() const { return m_title; }
    HRESULT PutTitle(LPWSTR title);

    bool GetCanSkip() const { return m_fCanSkip; }
    HRESULT PutCanSkip(bool fCanSkip) { m_fCanSkip = fCanSkip; return S_OK; }

    LPCWSTR GetBanner() const { return m_banner; };
    LPCWSTR GetBannerAbstract() const { return m_bannerAbstract; };
    LPCWSTR GetBannerMoreInfo() const { return m_bannerMoreInfo; };
    HRESULT PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo);

    BEGIN_CONNECTION_POINT_MAP(CPlayItem)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

  protected:
    CPlayList            *m_pPlayList;
    LPWSTR                m_abstract;
    LPWSTR                m_author;
    LPWSTR                m_copyright;
    double                m_dur;
    int                   m_lIndex;
    LPWSTR                m_rating;
    LPWSTR                m_src;
    LPWSTR                m_title;
    bool                  m_fCanSkip;
    LPWSTR                m_banner;
    LPWSTR                m_bannerAbstract;
    LPWSTR                m_bannerMoreInfo;


};  //lint !e1712

#endif /* _PLAYLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\mmutil.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMUTIL_H
#define _MMUTIL_H

#include "TimeEng.h"
#include "clock.h"
#include "float.h"

class MMBaseBvr;
class CTIMEElementBase;
class MMPlayer;

enum ELM_CHANGE_TYPE
{
    ELM_ADDED = 0,
    ELM_DELETED = 1
};

#if DBG
inline char *
EventString(TE_EVENT_TYPE et)
{
    switch(et) {
      case TE_EVENT_BEGIN:
        return "Begin";
      case TE_EVENT_END:
        return "End";
      case TE_EVENT_PAUSE:
        return "Pause";
      case TE_EVENT_RESUME:
        return "Resume";
      case TE_EVENT_REPEAT:
        return "Repeat";
      case TE_EVENT_AUTOREVERSE:
        return "Autoreverse";
      case TE_EVENT_RESET:
        return "Reset";
      case TE_EVENT_UPDATE:
        return "Update";
      case TE_EVENT_SEEK:
        return "Seek";
      case TE_EVENT_PARENT_TIMESHIFT:
        return "ParentTimeShift";
      case TE_EVENT_ENABLE:
        return "Enable";
      case TE_EVENT_DISABLE:
        return "Disable";
      default:
        return "Unknown";
    }
}
#endif

class MMBaseBvr
{
  public:
    MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMBaseBvr();

    bool Init(ITIMENode * node);
    virtual bool Init() = 0;

    HRESULT Begin(double dblOffset);
    HRESULT BeginAt(double dblParentTime,
                    double dblOffset);
    HRESULT End(double dblOffset);
    HRESULT EndAt(double dblParentTime,
                  double dblOffset);

    HRESULT Pause();
    HRESULT Resume();

    HRESULT Enable();
    HRESULT Disable();

    HRESULT Reset(bool bLightweight);

    virtual HRESULT Update(bool bUpdateBegin,
                           bool bUpdateEnd);

    HRESULT SeekSegmentTime(double dblSegmentTime);
    HRESULT SeekActiveTime(double dblActiveTime);
    HRESULT SeekTo(long lRepeatCount, double dblSegmentTime);

    HRESULT PutNaturalDur(double dblNaturalDur);
    double GetNaturalDur();

    void SetEndSync(bool b);
    void SetSyncMaster(bool b);
    
    void ElementChangeNotify(CTIMEElementBase & teb, ELM_CHANGE_TYPE ect);

    double DocumentTimeToParentTime(double documentTime);
    double ParentTimeToDocumentTime(double parentTime);
        
    double ParentTimeToActiveTime(double parentTime);
    double ActiveTimeToParentTime(double activeTime);

    double ActiveTimeToSegmentTime(double activeTime);
    double SegmentTimeToActiveTime(double segmentTime);

    double SegmentTimeToSimpleTime(double segmentTime);
    double SimpleTimeToSegmentTime(double simpleTime);

    double             GetSegmentTime() const;
    double             GetSegmentDur() const;
    double             GetSimpleTime() const;
    double             GetSimpleDur() const;
    double             GetProgress() const;
    LONG               GetCurrentRepeatCount() const;
    double             GetRepeatCount() const;
    double             GetRepeatDur() const;
    float              GetSpeed() const;
    float              GetCurrSpeed() const;
    double             GetActiveBeginTime() const;
    double             GetActiveEndTime() const;
    double             GetActiveTime() const;
    double             GetActiveDur() const;
    TE_STATE           GetPlayState() const;
    bool               IsPaused() const;
    bool               IsOn() const;
    bool               IsActive() const;
    bool               IsCurrPaused() const;
    double             GetCurrParentTime() const;
    void               SetEnabled (bool bEnabled);
    bool               GetEnabled (){return m_bEnabled;};
    void               SetZeroRepeatDur(bool bFlag){ m_bZeroRepeatDur = bFlag; };
    bool               IsDisabled() const;
    bool               IsCurrDisabled() const;

#if DBG
    const LPOLESTR GetID() { return m_id; }
#endif

    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD tePropType) { return true; }
    
    ITIMENode *        GetMMBvr() const { return m_bvr; }
    CTIMEElementBase & GetElement() const { return m_elm; }

    void               AddOneTimeValue(MMBaseBvr * pmmbvr,
                                   TE_TIMEPOINT tetp,
                                   double dblOffset,
                                   bool bBegin);
    void               AddSyncArcs(bool bBegin);
    void               ClearSyncArcs(bool bBegin);

  protected:
    

  protected:
    CTIMEElementBase & m_elm;
    bool m_bFireEvents;

    class TEBvr :
        public ITIMENodeBehavior
    {
      public:
        TEBvr();
        ~TEBvr();
        
        // IUnknown

        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);

        // ITIMENodeBehavior
        
        STDMETHOD(tick)();

        STDMETHOD(eventNotify)(double eventTime,
                               TE_EVENT_TYPE eventType,
                               long lRepeatCount);

        STDMETHOD(getSyncTime)(double * dblNewTime,
                               LONG * lNewRepeatCount,
                               VARIANT_BOOL * bCueing);

        STDMETHOD(propNotify)(DWORD tepPropType);
    
        void SetMMBvr(MMBaseBvr * t) { m_mmbvr = t; }

      protected:
        // This is a weak pointer and it is our parent's responsibility to
        // NULL this out before it goes away
        MMBaseBvr * m_mmbvr;
        long m_cRef;
    };

    friend TEBvr;

    DAComPtr<TEBvr> m_teb;
    MMBaseBvr();

    typedef std::multimap<CTIMEElementBase *, long> CookieMap;

    // Only syncArc are stored here so we can handle updating
    // correctly
    CookieMap m_cmBegin;
    CookieMap m_cmEnd;
#if DBG    
    LPOLESTR        m_id;
#endif

    bool DeleteFromCookieMap(bool bBegin, CTIMEElementBase & teb);
    bool CheckForSyncArc(bool bBegin, CTIMEElementBase & teb);
    
  private:
    // Make sure no one ever sets this themselves
    DAComPtr<ITIMENode> m_bvr;
    bool                m_bEnabled;
    bool                m_bZeroRepeatDur;

};

inline bool
MMBaseBvr::IsPaused() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isPaused(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsCurrPaused() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isCurrPaused(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsDisabled() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isDisabled(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsCurrDisabled() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isCurrDisabled(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsOn() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr != NULL)
    {
        IGNORE_HR(m_bvr->get_isOn(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsActive() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr != NULL)
    {
        IGNORE_HR(m_bvr->get_isActive(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

class MMBvr
    : public MMBaseBvr
{
  public:
    MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB);
    ~MMBvr();

    virtual bool Init();
  protected:
    bool m_fNeedSyncCB;
    MMBvr();
};

#endif /* _MMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    DALite Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H



#define RESID_TYPELIB           1
#define RESID_TYPELIB_PRIVATE   2


/////////////////////////////////////////////////////////////////////////////
// String resource IDs

#define IDR_INVALID_ARG             0x10


#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\timeelmimpl.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\timeelmimpl.h
//
//  Contents: Implements ITIMEElement (delegates to base_xxxx methods)
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _TIMEELMIMPL_H
#define _TIMEELMIMPL_H

#include "../timebvr/timeelmbase.h"


//+-------------------------------------------------------------------------------------
//
// CTIMEElementImpl
//
//--------------------------------------------------------------------------------------

template <class T, const IID* pIID_T> 
class 
ATL_NO_VTABLE 
CTIMEElementImpl :
    public CTIMEElementBase,
    public ITIMEDispatchImpl<T, pIID_T>
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    virtual ~CTIMEElementImpl() { }

    //
    // ITIMEElement properties
    //
    
    STDMETHOD(get_accelerate)(VARIANT * v)
    { return CTIMEElementBase::base_get_accelerate(v); }
    STDMETHOD(put_accelerate)(VARIANT v)
    { return CTIMEElementBase::base_put_accelerate(v); }

    STDMETHOD(get_autoReverse)(VARIANT * b)
    { return CTIMEElementBase::base_get_autoReverse(b); }
    STDMETHOD(put_autoReverse)(VARIANT b)
    { return CTIMEElementBase::base_put_autoReverse(b); }

    STDMETHOD(get_begin)(VARIANT * time)
    { return CTIMEElementBase::base_get_begin(time); }
    STDMETHOD(put_begin)(VARIANT time)
    { return CTIMEElementBase::base_put_begin(time); }

    STDMETHOD(get_decelerate)(VARIANT * v)
    { return CTIMEElementBase::base_get_decelerate(v); }
    STDMETHOD(put_decelerate)(VARIANT v)
    { return CTIMEElementBase::base_put_decelerate(v); }

    STDMETHOD(get_dur)(VARIANT * time)
    { return CTIMEElementBase::base_get_dur(time); }
    STDMETHOD(put_dur)(VARIANT time)
    { return CTIMEElementBase::base_put_dur(time); }

    STDMETHOD(get_end)(VARIANT * time)
    { return CTIMEElementBase::base_get_end(time); }
    STDMETHOD(put_end)(VARIANT time)
    { return CTIMEElementBase::base_put_end(time); }

    STDMETHOD(get_fill)(LPOLESTR * f)
    { return CTIMEElementBase::base_get_fill(f); }
    STDMETHOD(put_fill)(LPOLESTR f)
    { return CTIMEElementBase::base_put_fill(f); }

    STDMETHOD(get_mute)(VARIANT *b)
    { return CTIMEElementBase::base_get_mute(b); }
    STDMETHOD(put_mute)(VARIANT b)
    { return CTIMEElementBase::base_put_mute(b); }

    STDMETHOD(get_repeatCount)(VARIANT * c)
    { return CTIMEElementBase::base_get_repeatCount(c); }
    STDMETHOD(put_repeatCount)(VARIANT c)
    { return CTIMEElementBase::base_put_repeatCount(c); }

    STDMETHOD(get_repeatDur)(VARIANT * time)
    { return CTIMEElementBase::base_get_repeatDur(time); }
    STDMETHOD(put_repeatDur)(VARIANT time)
    { return CTIMEElementBase::base_put_repeatDur(time); }

    STDMETHOD(get_restart)(LPOLESTR * r)
    { return CTIMEElementBase::base_get_restart(r); }
    STDMETHOD(put_restart)(LPOLESTR r)
    { return CTIMEElementBase::base_put_restart(r); }

    STDMETHOD(get_speed)(VARIANT * speed)
    { return CTIMEElementBase::base_get_speed(speed); }
    STDMETHOD(put_speed)(VARIANT speed)
    { return CTIMEElementBase::base_put_speed(speed); }

    STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
    { return CTIMEElementBase::base_get_syncBehavior(sync); }
    STDMETHOD(put_syncBehavior)(LPOLESTR sync)
    { return CTIMEElementBase::base_put_syncBehavior(sync); }

    STDMETHOD(get_syncTolerance)(VARIANT * tol)
    { return CTIMEElementBase::base_get_syncTolerance(tol); }
    STDMETHOD(put_syncTolerance)(VARIANT tol)
    { return CTIMEElementBase::base_put_syncTolerance(tol); }

    STDMETHOD(get_syncMaster)(VARIANT * b)
    { return CTIMEElementBase::base_get_syncMaster(b); }
    STDMETHOD(put_syncMaster)(VARIANT b)
    { return CTIMEElementBase::base_put_syncMaster(b); }

    STDMETHOD(get_timeAction)(LPOLESTR * time)
    { return CTIMEElementBase::base_get_timeAction(time); }
    STDMETHOD(put_timeAction)(LPOLESTR time)
    { return CTIMEElementBase::base_put_timeAction(time); }

    STDMETHOD(get_timeContainer)(LPOLESTR *tl)
    { return CTIMEElementBase::base_get_timeContainer(tl); }

    STDMETHOD(get_volume)(VARIANT * vol)
    { return CTIMEElementBase::base_get_volume(vol); }
    STDMETHOD(put_volume)(VARIANT vol)
    { return CTIMEElementBase::base_put_volume(vol); }

    // Properties
    STDMETHOD(get_currTimeState)(ITIMEState ** TimeState)
    { return CTIMEElementBase::base_get_currTimeState(TimeState); }

    STDMETHOD(get_timeAll)(ITIMEElementCollection **allColl)
    { return CTIMEElementBase::base_get_timeAll(allColl); }

    STDMETHOD(get_timeChildren)(ITIMEElementCollection **childColl)
    { return CTIMEElementBase::base_get_timeChildren(childColl); }

    STDMETHOD(get_timeParent)(ITIMEElement ** parent)
    { return CTIMEElementBase::base_get_timeParent(parent); }

    STDMETHOD(get_isPaused)(VARIANT_BOOL * b)
    { return CTIMEElementBase::base_get_isPaused(b); }

    // Methods
    STDMETHOD(beginElement)()
    { return CTIMEElementBase::base_beginElement(0.0); }

    STDMETHOD(beginElementAt)(double parentTime)
    { return CTIMEElementBase::base_beginElementAt(parentTime, 0.0); }

    STDMETHOD(endElement)()
    { return CTIMEElementBase::base_endElement(0.0); }

    STDMETHOD(endElementAt)(double parentTime)
    { return CTIMEElementBase::base_endElementAt(parentTime, 0.0); }

    STDMETHOD(pauseElement)()
    { return CTIMEElementBase::base_pauseElement(); }

    STDMETHOD(resetElement)()
    { return CTIMEElementBase::base_resetElement(); }

    STDMETHOD(resumeElement)()
    { return CTIMEElementBase::base_resumeElement(); }

    STDMETHOD(seekActiveTime)(double activeTime)
    { return CTIMEElementBase::base_seekActiveTime(activeTime); }
        
    STDMETHOD(seekSegmentTime)(double segmentTime)
    { return CTIMEElementBase::base_seekSegmentTime(segmentTime); }
        
    STDMETHOD(seekTo)(LONG repeatCount, double segmentTime)
    { return CTIMEElementBase::base_seekTo(repeatCount, segmentTime); }
        
    STDMETHOD(documentTimeToParentTime)(double documentTime,
                                        double * parentTime)
    { return CTIMEElementBase::base_documentTimeToParentTime(documentTime,
                                                        parentTime); }
        
    STDMETHOD(parentTimeToDocumentTime)(double parentTime,
                                        double * documentTime)
    { return CTIMEElementBase::base_parentTimeToDocumentTime(parentTime,
                                                        documentTime); }
        
    STDMETHOD(parentTimeToActiveTime)(double parentTime,
                                      double * activeTime)
    { return CTIMEElementBase::base_parentTimeToActiveTime(parentTime,
                                                      activeTime); }
        
    STDMETHOD(activeTimeToParentTime)(double activeTime,
                                      double * parentTime)
    { return CTIMEElementBase::base_activeTimeToParentTime(activeTime,
                                                      parentTime); }
        
    STDMETHOD(activeTimeToSegmentTime)(double activeTime,
                                       double * segmentTime)
    { return CTIMEElementBase::base_activeTimeToSegmentTime(activeTime,
                                                       segmentTime); }
        
    STDMETHOD(segmentTimeToActiveTime)(double segmentTime,
                                       double * activeTime)
    { return CTIMEElementBase::base_segmentTimeToActiveTime(segmentTime,
                                                       activeTime); }
        
    STDMETHOD(segmentTimeToSimpleTime)(double segmentTime,
                                       double * simpleTime)
    { return CTIMEElementBase::base_segmentTimeToSimpleTime(segmentTime,
                                                       simpleTime); }
        
    STDMETHOD(simpleTimeToSegmentTime)(double simpleTime,
                                       double * segmentTime)
    { return CTIMEElementBase::base_simpleTimeToSegmentTime(simpleTime,
                                                       segmentTime); }
        
    // Container attributes
    STDMETHOD(get_endSync)(LPOLESTR * es)
    { return CTIMEElementBase::base_get_endSync(es); }
    STDMETHOD(put_endSync)(LPOLESTR es)
    { return CTIMEElementBase::base_put_endSync(es); }

    // Container Properties
    STDMETHOD(get_activeElements)(ITIMEActiveElementCollection **activeColl)
    { return CTIMEElementBase::base_get_activeElements(activeColl); }
    STDMETHOD(get_hasMedia)(VARIANT_BOOL * pvbVal)
    { return CTIMEElementBase::base_get_hasMedia(pvbVal); }

    // Container Methods
    STDMETHOD(nextElement)()
    { return CTIMEElementBase::base_nextElement(); }
    STDMETHOD(prevElement)()
    { return CTIMEElementBase::base_prevElement(); }

    STDMETHOD(get_updateMode)(BSTR * pbstrUpdateMode)
    { return CTIMEElementBase::base_get_updateMode(pbstrUpdateMode); }
    STDMETHOD(put_updateMode)(BSTR bstrUpdateMode)
    { return CTIMEElementBase::base_put_updateMode(bstrUpdateMode); }
    
  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // hide these
    CTIMEElementImpl() { }
    NO_COPY(CTIMEElementImpl);

}; // CTIMEElementImpl

#endif // _TIMEELMIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\threadsafelist.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\threadsafelist.h
//
//  Contents: declarations for CThreadSafeList, and CThreadSafeListNode
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _THREADSAFELIST_H
#define _THREADSAFELIST_H

#include "mstimep.h"

static const DWORD TIMEOUT = 1000 * 30; // 1000 milliseconds/second * 30 seconds

DWORD PumpMessagesWhileWaiting(HANDLE * pHandleArray, UINT iHandleCount, DWORD dwTimeOut);

class CThreadSafeListNode
{
  public:
      CThreadSafeListNode(ITIMEImportMedia * pElement) :
        m_spElement(pElement), m_fRemove(false) { ; }

    virtual ~CThreadSafeListNode() {;}

    ITIMEImportMedia * GetElement() { return m_spElement; }

    void RemoveWhenDone() { m_fRemove = true; }
    bool GetRemoveWhenDone() { return m_fRemove; }

  protected:
    CThreadSafeListNode();
    CThreadSafeListNode(const CThreadSafeListNode&);

  private:
    CComPtr<ITIMEImportMedia>      m_spElement;
    bool            m_fRemove;
};

class CThreadSafeList :
 public IUnknown
{
  public:
    CThreadSafeList();
    virtual ~CThreadSafeList();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
        
    virtual ULONG STDMETHODCALLTYPE Release( void);

    virtual HRESULT Init();
    virtual HRESULT Detach();

    virtual HRESULT Add(ITIMEImportMedia * pImportMedia);
    virtual HRESULT Remove(ITIMEImportMedia * pImportMedia);

    virtual HRESULT ReturnElement(ITIMEImportMedia * pOldMedia);
    virtual HRESULT GetNextElement(ITIMEImportMedia ** pNewMedia, bool fBlockThread = true); //lint !e1735

    virtual HRESULT DataAvailable();
    
    virtual HRESULT RePrioritize(ITIMEImportMedia * pImportMedia);

    virtual LONG Size() { return m_listToDoDownload.size() + m_listCurrentDownload.size() + m_listDoneDownload.size(); }

    virtual LONG GetThreadsWaiting();
    
  protected:
    CThreadSafeList (const CThreadSafeList&);

    CThreadSafeListNode * GetNextMediaToCue();
    HRESULT ClearList(std::list<CThreadSafeListNode*> &listToClear);

  protected:
    CritSect                            m_CriticalSection;

    std::list<CThreadSafeListNode*>     m_listToDoDownload;
    std::list<CThreadSafeListNode*>     m_listCurrentDownload;
    std::list<CThreadSafeListNode*>     m_listDoneDownload;

  private:

    HANDLE                              m_hDataAvailable;
    HANDLE                              m_hDataRecieved;
    HANDLE                              m_hShutdown;

    LONG                                m_lThreadsWaiting;
    LONG                                m_lRefCount;
};


#endif // _THREADSAFELIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\playerinterfaces.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: playerinterfaces.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _PLAYERINTERFACES_H
#define _PLAYERINTERFACES_H

class CTIMEMediaElement;
class CPlayList;
class CTIMEBasePlayer;

typedef enum PlayerState
{
    PLAYER_STATE_ACTIVE,
    PLAYER_STATE_INACTIVE,
    PLAYER_STATE_SEEKING,
    PLAYER_STATE_CUEING,
    PLAYER_STATE_HOLDING,
    PLAYER_STATE_UNKNOWN
} tagPlayerState;

typedef
enum PLAYER_EVENT  //these are events that players can fire into the media element.
{
    PE_ONMEDIACOMPLETE,
    PE_ONTRACKCOMPLETE,
    PE_ONMEDIAEND,
    PE_ONMEDIASLIPSLOW,
    PE_ONMEDIASLIPFAST,
    PE_ONSYNCRESTORED,
    PE_ONSCRIPTCOMMAND,
    PE_ONRESIZE,
    PE_ONSEEKDONE,
    PE_ONMEDIAINSERTED,
    PE_ONMEDIAREMOVED,
    PE_ONMEDIALOADFAILED,
    PE_ONMEDIATRACKCHANGED,
    PE_METAINFOCHANGED,
    PE_ONMEDISYNCGAIN,
    PE_ONMEDIAERRORCOLORKEY,
    PE_ONMEDIAERRORRENDERFILE,
    PE_ONMEDIAERROR,
    PE_ONCODECERROR,
    PE_MAX
};

interface ITIMEPlayerObjectManagement
{
    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS
    // METHOD SYNOPSIS:
    // SetCLSID: is used to set class id on players that host windowless controls.
    //   this method should be called before the init method. The WMP player is hosted
    //   with the CTIMEPlayer class.
    // Init: is called by the mediaelement to initialize the player. If
    //   the player does not support dynamic changing of source this method
    //   changes the source by rebuilding the player. Before calling Init
    //   again DetachFromHostElement is called to release all player resources.
    // DetachFromHostElement: is called by the mediaelement before the element
    //   is removed or before rebuilding the player with a call on Init.
    // GetExternalPlayerDispatch: This method returns a pointer to a IDispatch interface if the
    // player implements it.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Init(CTIMEMediaElement *pelem, 
                         LPOLESTR base, 
                         LPOLESTR src, 
                         LPOLESTR lpMimeType = NULL, 
                         double dblClipBegin = -1.0, 
                         double dblClipEnd = -1.0) = 0;
    virtual HRESULT DetachFromHostElement (void) = 0;
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp) = 0;
};

interface ITIMEPlayerEventHandling
{
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS
    // METHOD SYNOPSIS:
    // Start: starts media playback
    // Stop: stops media playback
    // Pause: pauses media playback
    // Resume: resumes media playback
    // Repeat: causes the media to repeat playback from the beginning
    // Seek: jumps to location in media playback
    //////////////////////////////////////////////////////////////////////////
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Pause() = 0;
    virtual void Resume() = 0;
    virtual void Repeat() = 0;
    virtual HRESULT Seek(double dblTime) = 0;
};

interface ITIMEPlayerPlaybackCapabilities
{
    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: BEGIN
    // METHOD SYNOPSIS:
    // HasMedia: tests if media is loaded into the player i.e. player is ready for playback
    // HasVideo: tests if media contains video content
    // HasAudio: tests if media contains audio content
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT HasMedia(bool &fHasMedia) = 0;
    virtual HRESULT HasVisual(bool &fHasVideo) = 0;
    virtual HRESULT HasAudio(bool &fHasAudio) = 0;
    virtual HRESULT CanSeek(bool &fcanSeek) = 0;
    virtual HRESULT CanPause(bool &fcanPause) = 0;
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM) = 0;
    virtual HRESULT IsBroadcast(bool &bisBroad) = 0;
    virtual HRESULT HasPlayList(bool &fhasPlayList) = 0;
    virtual HRESULT ConvertFrameToTime(LONGLONG lFrameNr, double &dblTime) = 0;
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr) = 0;
};

interface ITIMEPlayerStateManagement
{
    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: BEGIN
    // METHOD SYNOPSIS:
    // Reset: alligns the player state to that of it's associated mediaelement.
    // OnTEPropChange: called by the media element when timing state changes.
    // GetState: returns the state of the player.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Reset() = 0;
    virtual PlayerState GetState() = 0;
    virtual void PropChangeNotify(DWORD tePropType) = 0;
    virtual void ReadyStateNotify(LPWSTR szReadyState) = 0;
    virtual bool UpdateSync() = 0;
    virtual void SetPlaybackSite(CTIMEBasePlayer *pSite) = 0;
};

interface ITIMEPlayerRender
{
    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS
    // Render: is called when element rendering is ncessarry.
    // GetNaturalWidth and GetNaturalWidth: return the natural size of visible
    //   media.
    // SetSize: This method is used to inform the player that size has changed.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Render(HDC hdc, LPRECT prc) = 0;
    virtual HRESULT GetNaturalHeight(long *height) = 0;
    virtual HRESULT GetNaturalWidth(long *width) = 0;
    virtual HRESULT SetSize(RECT *prect) = 0;
};

interface ITIMEPlayerTiming
{
    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: BEGIN
    // METHOD SYNOPSIS:
    // GetMediaLength: returns the duration of the media.
    // GetEffectiveLength: returns the duration that is media 
    //   length minus clip times.
    // SetClipBegin: sets clip begin time. Not dynamic in current implementation.
    // SetClipEnd: sets clip begin time. Not dynamic in current implementation.
    // GetCurrentTime: returns current playback time.
    // GetCurrentSyncTime: returns S_FALSE is player is not in playback,
    //   S_OK if the player is active. This method is used by the timing engine
    //   to get clock source information.
    // SetRate and GetRate: set and get playback speed. 1.0 indicates
    //   playback at media natural speed.
    //////////////////////////////////////////////////////////////////////////
    virtual double GetCurrentTime() = 0;
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime) = 0;
    virtual HRESULT GetMediaLength(double &dblLength) = 0;
    virtual HRESULT GetEffectiveLength(double &dblLength) = 0;
    virtual void GetClipBegin(double &dblClibBegin) = 0;
    virtual void SetClipBegin(double dblClipBegin) = 0;
    virtual void GetClipEnd(double &dblClipEnd) = 0;
    virtual void SetClipEnd(double dblClipEnd) = 0;
    virtual void GetClipBeginFrame(long &lClibBeginFrame) = 0;
    virtual void SetClipBeginFrame(long lClipBeginFrame) = 0;
    virtual void GetClipEndFrame(long &lClipEndFrame) = 0;
    virtual void SetClipEndFrame(long lClipEndFrame) = 0;
    virtual HRESULT GetPlaybackOffset(double &dblOffset) = 0;
    virtual HRESULT GetEffectiveOffset(double &dblOffset) = 0;
};

interface ITIMEPlayerProperties
{
    //////////////////////////////////////////////////////////////////////////
    // PROPERTY ACCESSORS: BEGIN
    // METHOD SYNOPSIS:
    // GetVolume and SetVolume: get and set volume on player. Value range (0 - 1.0).
    // GetMute and SetMute: get and set mute flag on player (true - media muted).
    // Save: This method is used to pass a property bag to players that
    // can use it.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetVolume(float *pflVolume) = 0;
    virtual HRESULT SetVolume(float flVolume) = 0;
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance) = 0;
    virtual HRESULT SetBalance(float flBalance) = 0;
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute) = 0;
    virtual HRESULT SetMute(VARIANT_BOOL varMute) = 0;
};

interface ITIMEPlayerMediaContent
{
    //////////////////////////////////////////////////////////////////////////
    // MEDIA CONTENT ACCESSORS: BEGIN
    // METHOD SYNOPSIS:
    // SetSrc: changes the media source
    // GetAuthor: gets author info from media content
    // GetTilte: gets title info from media content
    // GetCopyright: gets copyright info from media content
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src) = 0;
    virtual HRESULT GetAuthor(BSTR *pAuthor) = 0;
    virtual HRESULT GetTitle(BSTR *pTitle) = 0;
    virtual HRESULT GetCopyright(BSTR *pCopyright) = 0;
    virtual HRESULT GetAbstract(BSTR *pAbstract) = 0;
    virtual HRESULT GetRating(BSTR *pAbstract) = 0;
};

interface ITIMEPlayerMediaContext
{
    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime) = 0;
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime) = 0;
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur) = 0;
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur) = 0;
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal) = 0;
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent) = 0;
    virtual HRESULT GetIsStreamed(bool &fIsStreamed) = 0;
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress) = 0;
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress) = 0;
    virtual HRESULT GetMimeType(BSTR *pMime) = 0;
    virtual HRESULT GetDownloadProgress(double &dblDownloadProgress) = 0;
};

interface ITIMEPlayerIntegration
{
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle) = 0;
};

interface ITIMEPlayerPlayList
{
    virtual HRESULT GetPlayList(ITIMEPlayList **pPlayList) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\timetoken.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timetoken.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#pragma once

#ifndef _TIMETOKEN_H
#define _TIMETOKEN_H

#pragma INCMSG("--- Beg 'timetoken.h'")


/* BNF CSS1 grammar

    *  : 0 or more 
    +  : 1 or more 
    ?  : 0 or 1 
    |  : separates alternatives 
    [ ]: grouping 

    S  : [ \t\r\n\f]+


  stylesheet : 

  import : 

  ruleset : 

  selector : 

*/


#define     CHAR_ESCAPE         '\\'
#define     CHAR_AT             '@'
#define     CHAR_DOT            '.'
#define     CHAR_COLON          ':'
#define     CHAR_SINGLE         '\''
#define     CHAR_DOUBLE         '"'
#define     CHAR_SEMI           ';'
#define     CHAR_LEFT_PAREN     '('
#define     CHAR_RIGHT_PAREN    ')'
#define     CHAR_LEFT_CURLY     '{'
#define     CHAR_RIGHT_CURLY    '}'
#define     CHAR_HASH           '#'
#define     CHAR_BACKSLASH      '\\'
#define     CHAR_FORWARDSLASH   '/'
#define     CHAR_ASTERISK       '*'
#define     CHAR_EQUAL          '='
#define     CHAR_UNDERLINE      '_'
#define     CHAR_HYPHEN         '-'
#define     CHAR_BANG           '!'
#define     CHAR_COMMA          ','
#define     CHAR_PERCENT        '%'
#define     CHAR_PLUS           '+'
#define     CHAR_MINUS          '-'
#define     CHAR_SPACE          ' '
#define     CHAR_LESS           '<'
#define     CHAR_GREATER        '>'

enum TIME_TOKEN_TYPE { TT_Identifier,
                       TT_Number,
                       TT_At,
                       TT_Minus,
                       TT_Plus,
                       TT_ForwardSlash,
                       TT_Comma,
                       TT_Semi,
                       TT_Dot,
                       TT_Colon,
                       TT_Equal,
                       TT_Asterisk,
                       TT_Backslash,
                       TT_Comment,
                       TT_Import,
                       TT_QuotedString,
                       TT_LParen,
                       TT_RParen,
                       TT_LCurly,
                       TT_RCurly,
                       TT_Symbol,
                       TT_EOF,
                       TT_String,
                       TT_Hash,
                       TT_Bang,
                       TT_Percent,
                       TT_Space,
                       TT_Less,
                       TT_Greater,
                       TT_Unknown };


class CTIMETokenizer
{
public:
    CTIMETokenizer();
    ~CTIMETokenizer();
    HRESULT Init (OLECHAR *pData, ULONG ulLen);

    
    TIME_TOKEN_TYPE NextToken();
    TIME_TOKEN_TYPE TokenType()
      { return _currToken; }

    OLECHAR * GetTokenValue();
    OLECHAR * GetNumberTokenValue();
    double    GetTokenNumber();
    OLECHAR * GetStartToken()
      { return _pStartTokenValueOffset; }
    OLECHAR * GetStartOffset(ULONG uStartOffset)
      { return _pCharacterStream + uStartOffset; }
    ULONG   GetTokenLength()
      { return _pEndTokenValueOffset - _pStartTokenValueOffset; }

        OLECHAR CurrentChar()
      { return _currChar; }
        OLECHAR PrevChar()
      { Assert(_nextTokOffset >= 2); return *(_pCharacterStream + _nextTokOffset - 2); }

    OLECHAR PeekNextChar(int relOffset)
      { return (_nextTokOffset < _cCharacterStream) ? (*(_pCharacterStream + _nextTokOffset + relOffset)) : '\0'; }

    OLECHAR PeekNextNonSpaceChar();

    BOOL isIdentifier(OLECHAR *szMatch);

    // ISSUE : Really shouldn't expose this however, I do to get the value parsing up quicker...
    ULONG CurrTokenOffset()
      { return _currTokOffset; }
    ULONG NextTokenOffset()
      { return _nextTokOffset; }
    ULONG GetStreamLength()
      { return _cCharacterStream; }
    OLECHAR *GetRawString(ULONG uStartOffset, ULONG uEndOffset);
    ULONG  GetCharCount(OLECHAR token);
    ULONG GetAlphaCount(char cCount); //counts all alphabetic characters in the string

    bool GetTightChecking()
        { return _bTightSyntaxCheck; };
    void SetTightChecking(bool bCheck)
        { _bTightSyntaxCheck = bCheck; };
    void SetSingleCharMode(bool bSingle);
    BOOL FetchStringToChar(OLECHAR chDelim);
    BOOL FetchStringToString(LPOLESTR pstrDelim);

protected:
    OLECHAR       NextNonSpaceChar();
    BOOL        FetchString(OLECHAR chDelim);
    BOOL        FetchString(LPOLESTR strDelim);
    inline OLECHAR       NextChar();
    TIME_TOKEN_TYPE FetchIdentifier();
    TIME_TOKEN_TYPE FetchNumber();
    BOOL        CDOToken();
    void        BackChar()
      { _nextTokOffset--; }

private:
        OLECHAR      *_pCharacterStream;
        ULONG       _cCharacterStream;
    ULONG       _currTokOffset;
    ULONG       _nextTokOffset;
    OLECHAR       _currChar;

    TIME_TOKEN_TYPE  _currToken;
    OLECHAR      *_pStartOffset;
    OLECHAR      *_pEndOffset;

    OLECHAR      *_pStartTokenValueOffset;
    OLECHAR      *_pEndTokenValueOffset;
    bool          _bTightSyntaxCheck; //used to determine if whitespaces should be skipped or not.
    bool          _bSingleCharMode;   //used for path parsing where a single character is needed.
};


#endif //_TIMETOKEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\timevalue.h ===
//+___________________________________________________________________________________
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timevalue.h
//
//  Contents: 
//
//____________________________________________________________________________________



#ifndef _TIMEVALUE_H
#define _TIMEVALUE_H

class TimeValue
{
  public:
    TimeValue(LPWSTR Element,
              LPWSTR Event,
              double Offset);
    TimeValue();
    TimeValue(const TimeValue & tv);
    ~TimeValue();
    
    TimeValue& operator=(const TimeValue & tv)
    { if ( &tv != this ) Copy(tv); return *this; }

    void Clear();
    HRESULT Copy(const TimeValue & tv);
    HRESULT Set(LPWSTR Element,
                LPWSTR Event,
                double Offset);
    
    LPOLESTR GetElement() const { return m_pwszElm; }
    LPOLESTR GetEvent() const { return m_pwszEv; }
    double GetOffset() const { return m_dblOffset; }
  protected:
    LPOLESTR m_pwszElm;
    LPOLESTR m_pwszEv;
    double m_dblOffset;
};

typedef std::list<TimeValue *> TimeValueSTLList;

class TimeValueList
{
  public:
    TimeValueList();
    ~TimeValueList();

    void Clear();
    
    TimeValueSTLList & GetList() { return m_tvlList; }
  protected:
    TimeValueSTLList m_tvlList;
};

#endif /* _TIMEVALUE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\trans.h ===
/*******************************************************************************
 *
 * Copyright (c) 2000 Microsoft Corporation
 *
 * File: trans.h
 *
 * Abstract: Interface definition for ITransitionElement
 *
 *******************************************************************************/

#ifndef _TRANS_H__
#define _TRANS_H__

#pragma once

//
// ITransitionElement is for private use by HTML+TIME.
// Do *NOT* use a CTrans* in other places.
//
// If you need something else, add it to the ITransitionElement interface
// and then implement it in CTIMETransBase and the relates classes
//

interface ITransitionElement : public IUnknown
{
  public:
    STDMETHOD(Init)() PURE;
    STDMETHOD(Detach)() PURE;

    STDMETHOD(put_template)(LPWSTR pwzTemplate) PURE;
    STDMETHOD(put_htmlElement)(IHTMLElement * pHTMLElement) PURE;
    STDMETHOD(put_timeElement)(ITIMEElement * pTIMEElement) PURE;
};

HRESULT CreateTransIn(ITransitionElement ** ppTransElement);
HRESULT CreateTransOut(ITransitionElement ** ppTransElement);

#endif // _TRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\tokens.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: tokens.h
//
//  Contents: tokens and related utilities
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _TOKENS_H
#define _TOKENS_H

//+----------------------------------------------------------------------------
//
// Good place to put general string expansion macros that are not tokens:
//
//-----------------------------------------------------------------------------

#define WZ_LAST                         L"last"
#define WZ_FIRST                        L"first"
#define WZ_NONE                         L"none"
#define WZ_ALL                          L"all"
#define WZ_INDEFINITE                   L"indefinite"

#define WZ_PAR                          L"par"
#define WZ_EXCL                         L"excl"
#define WZ_SEQUENCE                     L"seq"

#define WZ_SWITCH                       L"switch"

#define WZ_REF                          L"ref"
#define WZ_MEDIA                        L"media"
#define WZ_IMG                          L"img"
#define WZ_AUDIO                        L"audio"
#define WZ_VIDEO                        L"video"
#define WZ_ANIMATION                    L"animation"

#define WZ_EVENT                        L"event"

#define WZ_ANIMATE                      L"animate"
#define WZ_SET                          L"set"
#define WZ_COLORANIM                    L"animatecolor"
#define WZ_MOTIONANIM                   L"animatemotion"

#define WZ_BODY                         L"body"

#define WZ_TRANSITIONFILTER             L"transitionFilter"
#define WZ_TRANSITION_NAME              L"transition"

#define WZ_DEFAULT_SCOPE_NAME           L"HTML"

#define WZ_TIME_STYLE_PREFIX            L"#time"
#define WZ_SMILANIM_STYLE_PREFIX        L"#smilanim"

#define WZ_REGISTERED_TIME_NAME             L"HTMLTIME"
#define WZ_REGISTERED_ANIM_NAME             L"SMILANIMCOMPOSERSITE"
#define WZ_TIME_URN                         L"TIME_BEHAVIOR_URN"
#define WZ_SMILANIM_URN                     L"SMILANIM_COMPSITE_BEHAVIOR_URN"
#define WZ_TIME_TAG_URN                     L"urn:schemas-microsoft-com:time"

#define WZ_MEDIA_PRINTING               L"print"

#define WZ_PRIORITYCLASS_NAME           L"priorityClass"
#define WZ_PEERS                        L"peers"
#define WZ_HIGHER                       L"higher"
#define WZ_LOWER                        L"lower"

#define WZ_TRANSPARENT                  L"transparent"

#define WZ_FRAGMENT_ATTRIBUTE_PROPERTY_NAME L"attributeName"
#define WZ_FRAGMENT_VALUE_PROPERTY_NAME     L"get_value"
#define WZ_FRAGMENT_ELEMENT_PROPERTY_NAME   L"element"
#define WZ_EVENT_CAUSE_IS_RESTART           L"restart"

#define WZ_STATE_ON                         L"on"
#define WZ_STATE_OFF                        L"off"
#define WZ_STATE_PAUSED                     L"paused"

#define WZ_STATE_ACTIVE                     L"active"
#define WZ_STATE_INACTIVE                   L"inactive"
#define WZ_STATE_SEEKING                    L"seeking"
#define WZ_STATE_HOLDING                    L"holding"
#define WZ_STATE_CUEING                     L"cueing"

#define WZ_CALCMODE_DISCRETE                L"discrete"
#define WZ_CALCMODE_LINEAR                  L"linear"
#define WZ_CALCMODE_SPLINE                  L"spline"
#define WZ_CALCMODE_PACED                   L"paced"

#define WZ_ORIGIN_DEFAULT                   L"default"
#define WZ_ORIGIN_PARENT                    L"parent"
#define WZ_ORIGIN_ELEMENT                   L"element"

#define WZ_FILL_FREEZE                      L"freeze"
#define WZ_FILL_REMOVE                      L"remove"
#define WZ_FILL_HOLD                        L"hold"
#define WZ_FILL_TRANSITION                  L"transition"

#define WZ_RESTART_NEVER                    L"never"
#define WZ_RESTART_ALWAYS                   L"always"
#define WZ_RESTART_WHENNOTACTIVE            L"whennotactive"

#define WZ_DIRECTION_NOHUE                  L"nohue"
#define WZ_DIRECTION_CLOCKWISE              L"clockwise"
#define WZ_DIRECTION_CCLOCKWISE             L"cclockwise"

#define WZ_TOP                              L"top"
#define WZ_LEFT                             L"left"
#define WZ_AUTO                             L"auto"

#define WZ_TIMEBASE_BEGIN                   L"begin"
#define WZ_TIMEBASE_END                     L"end"

#define WZ_ADDITIVE_SUM                     L"sum"   

#define WZ_TRUE                             L"true"
#define WZ_FALSE                            L"false"

#define WZ_SWITCHCHILDDISABLED              L"SwitchChildDisabled"

#define WZ_HIDDEN                           L"hidden"
#define WZ_VISIBLE                          L"visible"

//
// ITIMEElement attribute names
// 

#define WZ_SPEED                            L"speed"
#define WZ_VOLUME                           L"volume"
#define WZ_DUR                              L"dur"
#define WZ_ACCELERATE                       L"accelerate"
#define WZ_DECELERATE                       L"decelerate"
#define WZ_END                              L"end"
#define WZ_REPEATCOUNT                      L"repeatCount"
#define WZ_REPEATDUR                        L"repeatDur"
#define WZ_SYNCTOLERANCE                    L"syncTolerance"
#define WZ_AUTOREVERSE                      L"autoReverse"
#define WZ_BEGIN                            L"begin"
#define WZ_END                              L"end"
#define WZ_FILL                             L"fill"
#define WZ_MUTE                             L"mute"
#define WZ_RESTART                          L"restart"
#define WZ_SYNCBEHAVIOR                     L"syncBehavior"
#define WZ_SYNCMASTER                       L"syncMaster"
#define WZ_TIMECONTAINER                    L"timeContainer"
#define WZ_TIMEACTION                       L"timeAction"
#define WZ_UPDATEMODE                       L"updateMode"
#define WZ_ENDSYNC                          L"endSync"

//
// ITIMEMediaElement attribute names
// 

#define WZ_CLIPBEGIN                        L"clipBegin"
#define WZ_CLIPEND                          L"clipEnd"
#define WZ_PLAYER                           L"player"
#define WZ_SRC                              L"src"
#define WZ_TYPE                             L"type"
#define WZ_TRANSIN                          L"transIn"
#define WZ_TRANSOUT                         L"transOut"

//
// ITIMETransitionElement attribute names
//
#define WZ_SUBTYPE                          L"subType"
#define WZ_DURATION                         L"duration"
#define WZ_STARTPROGRESS                    L"startProgress"
#define WZ_ENDPROGRESS                      L"endProgress"
#define WZ_DIRECTION                        L"direction"
#define WZ_FORWARD                          L"forward"
#define WZ_REVERSE                          L"reverse"
#define WZ_REPEAT                           L"repeat"
#define WZ_TRANSITIONTYPE                   L"transitiontype"
#define WZ_DEFAULT_TRANSITION_TYPE          L"barWipe"
#define WZ_DEFAULT_TRANSITION_SUBTYPE       L"leftToRight"
#define WZ_DEFAULT_TRANSITION_MODE          L"in"
#define WZ_TRANSITION_MODE_OUT              L"out"


//
// ITIMEAnimationElement attribute names
// 

#define WZ_ACCUMULATE                       L"accumulate"
#define WZ_ADDITIVE                         L"additive"
#define WZ_ATTRIBUTENAME                    L"attributeName"
#define WZ_BY                               L"by"
#define WZ_CALCMODE                         L"calcMode"
#define WZ_FROM                             L"from"
#define WZ_KEYSPLINES                       L"keySplines"
#define WZ_KEYTIMES                         L"keyTimes"
#define WZ_ORIGIN                           L"origin"
#define WZ_PATH                             L"path"
#define WZ_TARGETELEMENT                    L"targetElement"
#define WZ_TO                               L"to"
#define WZ_VALUES                           L"values"
#define WZ_MODE                             L"mode"
#define WZ_FADECOLOR                        L"fadeColor"

//
// ITIMEBodyElement attribute names
// 


//
// ITIMEventElement attribute names
// 

#define WZ_TYPE_EVENT                   L"type"
#define WZ_ACTIVE                       L"active"

//
// Attribute names for elements whose events we monitor
//
#define WZ_FILTER_MOUSE_EVENTS          L"filterMouseOverMouseOut"
#define WZ_TIMECANCELBUBBLE             L"timeCancelBubble"

//
// Connection type names
#define WZ_MODEM                        L"modem"
#define WZ_LAN                          L"lan"






// merge conflict here please




//+----------------------------------------------------------------------------
//
// This is to save on string storage space and to avoid unnecessary
// string comparisons
//
//-----------------------------------------------------------------------------

typedef void * TOKEN;

TOKEN StringToToken(wchar_t * str);
inline wchar_t * TokenToString(TOKEN token) { return (wchar_t *) token; }

// timeAction values
extern TOKEN NONE_TOKEN;
extern TOKEN INVALID_TOKEN;
extern TOKEN STYLE_TOKEN;
extern TOKEN DISPLAY_TOKEN;
extern TOKEN VISIBILITY_TOKEN;

extern TOKEN     CLASS_TOKEN;
extern const int nCLASS_TOKEN_LENGTH;
extern TOKEN     SEPARATOR_TOKEN;
extern const int nSEPARATOR_TOKEN_LENGTH;

extern TOKEN ONOFF_PROPERTY_TOKEN;

extern TOKEN TRUE_TOKEN;
extern TOKEN FALSE_TOKEN;
extern TOKEN HIDDEN_TOKEN;

extern TOKEN CANSLIP_TOKEN;
extern TOKEN LOCKED_TOKEN;

extern TOKEN STOP_TOKEN;
extern TOKEN PAUSE_TOKEN;
extern TOKEN DEFER_TOKEN;
extern TOKEN NEVER_TOKEN;

extern TOKEN READYSTATE_COMPLETE_TOKEN;

extern TOKEN REMOVE_TOKEN;
extern TOKEN FREEZE_TOKEN;
extern TOKEN HOLD_TOKEN;
extern TOKEN TRANSITION_TOKEN;

extern TOKEN ALWAYS_TOKEN;
// extern TOKEN NEVER_TOKEN; // also above
extern TOKEN WHENNOTACTIVE_TOKEN;

extern TOKEN SEQ_TOKEN;
extern TOKEN PAR_TOKEN;
extern TOKEN EXCL_TOKEN;

extern TOKEN AUTO_TOKEN; 
extern TOKEN MANUAL_TOKEN;
extern TOKEN RESET_TOKEN;

#if DBG // 94850
extern TOKEN DSHOW_TOKEN;
#endif
extern TOKEN DVD_TOKEN;
extern TOKEN DMUSIC_TOKEN;
extern TOKEN CD_TOKEN;

extern TOKEN DISCRETE_TOKEN;
extern TOKEN LINEAR_TOKEN;
extern TOKEN PACED_TOKEN;

extern TOKEN CLOCKWISE_TOKEN;
extern TOKEN COUNTERCLOCKWISE_TOKEN;

extern TOKEN FIRST_TOKEN;
extern TOKEN LAST_TOKEN;

extern TOKEN ENTRY_TOKEN;
extern TOKEN TITLE_TOKEN;
extern TOKEN COPYRIGHT_TOKEN;
extern TOKEN AUTHOR_TOKEN;
extern TOKEN REF_TOKEN;
extern TOKEN ENTRYREF_TOKEN;
extern TOKEN ASX_TOKEN;
extern TOKEN ABSTRACT_TOKEN;
extern TOKEN HREF_TOKEN;
extern TOKEN REPEAT_TOKEN;
extern TOKEN EVENT_TOKEN;
extern TOKEN MOREINFO_TOKEN;
extern TOKEN BASE_TOKEN;
extern TOKEN LOGO_TOKEN;
extern TOKEN PARAM_TOKEN;
extern TOKEN PREVIEWDURATION_TOKEN;
extern TOKEN STARTTIME_TOKEN;
extern TOKEN STARTMARKER_TOKEN;
extern TOKEN ENDTIME_TOKEN;
extern TOKEN ENDMARKER_TOKEN;
extern TOKEN DURATION_TOKEN;
extern TOKEN BANNER_TOKEN;
extern TOKEN CLIENTSKIP_TOKEN;
extern TOKEN CLIENTBIND_TOKEN;
extern TOKEN COUNT_TOKEN;


extern TOKEN INDEFINITE_TOKEN;

#endif /* _TOKENS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\timer.h ===
#pragma once

#ifndef _TIMER_H__
#define _TIMER_H__

class CTIMETimer
{
  public:
      CTIMETimer(bool fBeginNow = false) : 
  m_bStarted(false),
  m_iBeginTime(0),
  m_iusecSumTime(0)
{
    QueryPerformanceFrequency((LARGE_INTEGER *)&m_iFreq);

    if (fBeginNow)
    {
        Start();
    }
}

    ~CTIMETimer() { }

    inline void Start();
    inline void Stop();
    void Clear() { Assert(!m_bStarted); m_iusecSumTime = 0; }

    // micro-second time
    LONG usecTime() { Assert(!m_bStarted); return m_iusecSumTime; }

    // milli-second time
    LONG msecTime() { Assert(!m_bStarted); return m_iusecSumTime / 1000; }

    bool IsStopped() { return !m_bStarted; }

  private:
    __int64 m_iBeginTime;
    __int64 m_iusecSumTime;
    __int64 m_iFreq;

    bool m_bStarted;
};


inline void
CTIMETimer::Start()
{
#ifdef DBG
    Assert(!m_bStarted);
    m_bStarted = true;
#endif

    QueryPerformanceCounter((LARGE_INTEGER *)&m_iBeginTime);    
}

inline void
CTIMETimer::Stop()
{
    __int64 iEndTime;
    QueryPerformanceCounter((LARGE_INTEGER *)&iEndTime);

#ifdef DBG
    Assert(m_bStarted);
    m_bStarted = false;
#endif

    __int64 usecdelta = (((iEndTime - m_iBeginTime) * 1000000) / m_iFreq);

    m_iusecSumTime += usecdelta;
}


#endif // _TIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\timeparser.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timeparser.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _TIMEPARSER_H
#define _TIMEPARSER_H

#include "timetoken.h"
#include "tokens.h"
#include "timevalue.h"

class CPlayList;
class CPlayItem;

enum TimelineType
{
    ttUninitialized,
    ttNone,
    ttPar,
    ttSeq,
    ttExcl
};

enum PathType
{
    PathMoveTo,
    PathLineTo,
    PathHorizontalLineTo,
    PathVerticalLineTo,
    PathClosePath,
    PathBezier,
    PathNotSet
};


class CTIMEPath
{
public:
    CTIMEPath();
    ~CTIMEPath();

    PathType    GetType() { return m_pathType; };
    bool        GetAbsolute() { return m_bAbsoluteMode; };
    POINTF     *GetPoints();

    
    HRESULT     SetType(PathType type);
    HRESULT     SetAbsolute(bool bMode);
    HRESULT     SetPoints (long index, POINTF point);

private:
    long        m_lPointCount;
    POINTF     *m_pPoints;
    PathType    m_pathType;
    bool        m_bAbsoluteMode;      //true when the mode is absolute, false otherwise

};

typedef struct _ParentList
{
    TOKEN tagToken;
    int listLen;
    TOKEN allowedParents[5];
} ParentList;


class CTIMEParser
{
protected:
    typedef std::list<TOKEN> TokenList;
    typedef std::list<LPOLESTR> StringList;

public:
    
    CTIMEParser(CTIMETokenizer *tokenizer, bool bSingleChar = false) 
        { CreateParser(tokenizer, bSingleChar);};
    CTIMEParser(LPOLESTR tokenStream, bool bSingleChar = false)
        { CreateParser(tokenStream, bSingleChar);};
    CTIMEParser(VARIANT *tokenStream, bool bSingleChar = false)
        { CreateParser(tokenStream, bSingleChar);};

    void CreateParser(CTIMETokenizer *tokenizer, bool bSingleChar);
    void CreateParser(LPOLESTR tokenStream, bool bSingleChar);
    void CreateParser(VARIANT *tokenStream, bool bSingleChar);
    ~CTIMEParser();

    HRESULT ParsePercent(double & percentVal);
    HRESULT ParseBoolean(bool & boolVal);
    HRESULT ParseClockValue(double & time);
    HRESULT ParseNumber(double & doubleVal, bool bValidate=true);
    HRESULT ParseTimeValueList(TimeValueList & tvList, bool * bWallClock = NULL, SYSTEMTIME * sysTime = NULL);
    HRESULT ParseFill(TOKEN & FillTok);
    HRESULT ParseRestart(TOKEN & TokRestart);
    HRESULT ParseSyncBehavior(TOKEN & SyncVal);
    HRESULT ParseTimeAction(TOKEN & timeAction);
    HRESULT ParseTimeLine(TimelineType & timeline);
    HRESULT ParseUpdateMode(TOKEN & update);
    HRESULT ParsePlayer(TOKEN & player, CLSID & clsid);
    HRESULT ParseCLSID(CLSID & clsid);
    HRESULT ParseCalcMode(TOKEN & calcMode);
    HRESULT ParseIdentifier(LPOLESTR & id);
    HRESULT ParseEnd(LPOLESTR & ElementID, LPOLESTR & syncEvent, double & time);
    HRESULT ParseEOF();
    HRESULT ParseSyncBase(LPOLESTR & ElementID, LPOLESTR & syncEvent, double & time);
    HRESULT ParseEndSync(TOKEN & endSync, LPOLESTR & ID);
    HRESULT ParsePath(long & count, long & moveCount, CTIMEPath ***pppPath);
    HRESULT ParseWallClock(double & curOffsetTime, SYSTEMTIME * sysTime = NULL);
    HRESULT ParseRepeatDur(double & time);
    HRESULT ParseDur(double & time);

    HRESULT ParseDate(int & nYear, int & nMonth, int & nDay);
    HRESULT ParseOffset(double & fHours, double & fMinutes, double & fSec, bool & bUseLocalTime);
    HRESULT ParseSystemLanguages(long & lLangCount, LPWSTR **ppszLang);

    HRESULT ParsePriorityClass(TOKEN & priorityClass);

    HRESULT ParsePlayList(CPlayList *pPlayList, bool fOnlyHeader, std::list<LPOLESTR> *asxList = NULL);
    HRESULT IgnoreValueTag();
    HRESULT ProcessValueTag(TOKEN token, CPlayItem *pPlayItem, TOKEN parentToken, bool &ffound, std::list<LPOLESTR> *asxList, TokenList *ptokenList);
    HRESULT ProcessRefTag(CPlayItem *pPlayItem);
    HRESULT ProcessBannerTag(CPlayItem *pPlayItem);
    HRESULT ProcessEntryRefTag(std::list<LPOLESTR> *asxList);

    LPOLESTR ProcessMoreInfoTag();
    LPOLESTR ProcessAbstractTag();   
    HRESULT ProcessHREF(LPOLESTR *);
    HRESULT GetTagParams(TokenList *tokenList, StringList *valueList, bool &fClosed);

    HRESULT ParseTransitionTypeAndSubtype (VARIANT *pvarType, VARIANT *pvarSubtype);

protected:

    static LPOLESTR FindTokenValue(TOKEN token, TokenList &tokenList, StringList &valueList);
    static void FreeStrings(StringList &valueList);

    CTIMEParser();
    CTIMETokenizer      *m_Tokenizer;

    bool IsAsxTagToken(TOKEN token);
    void TestForValueTag(TOKEN token, TOKEN parentToken, bool &ffound, bool &fparentOk);
    HRESULT ProcessTag(TOKEN tempToken, LPOLESTR pszTemp, CPlayItem *pPlayItem);
    double DoubleToDecimal(double val, long lCount);  //converts a number to a decimal value i.e. 5.24 to 0.524.
    HRESULT ParseToken(TOKEN *pToken);  //returns a token representation of the next identifier or E_FAIL if the next token is not an identifier.
    double GetModifier(OLECHAR *szToken);
    long CountPath();
    bool IsWallClock(OLECHAR *szWallclock);
    HRESULT ComputeTime(SYSTEMTIME *curTime, SYSTEMTIME *wallTime, double & curOffsetTime, bool bUseDate);
    bool IsEmpty();
    void CheckTime(SYSTEMTIME *wallTime, bool bUseDate);

private:
    HRESULT                m_hrLoadError;
    bool                   m_fDeleteTokenizer;
};

#endif //CTIMEParser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\transsite.h ===
#ifndef _TRANSITIONSITE_H__
#define _TRANSITIONSITE_H__

#pragma once

EXTERN_C const IID IID_ITIMETransitionSite;
extern enum TIME_EVENT;

interface ITIMETransitionSite : public IUnknown
{
  public:
    STDMETHOD(InitTransitionSite) (void) PURE;
    STDMETHOD(DetachTransitionSite) (void) PURE;
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b) PURE;
    STDMETHOD(get_node)(ITIMENode ** ppNode) PURE;
    STDMETHOD(get_timeParentNode)(ITIMENode ** ppNode) PURE;
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event) PURE;
};

#endif // _TRANSITIONSITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\transworker.h ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transworker.h
//
//  Interfaces: ITransitionSite
//              ITransitionWorker
//
//  Functions:  CreateTransitionWorker
//
//  History:
//  2000/07/??  jeffwall    Created.
//  2000/09/07  mcalkins    Added these comments!
//  2000/09/15  mcalkins    Added eQuickApplyType parameter to Apply().
//
//------------------------------------------------------------------------------

#ifndef _TRANSWORKER_H__
#define _TRANSWORKER_H__

#pragma once

#include "dxtransp.h"




// TODO: (mcalkins) Create an idl file for private SMIL Transitions interfaces?

interface ITransitionSite : public IUnknown
{
public:
    STDMETHOD(get_htmlElement)(IHTMLElement ** ppHTMLElement) PURE;
    STDMETHOD(get_template)(IHTMLElement ** ppHTMLElement) PURE;
};


interface ITransitionWorker : public IUnknown
{
public:
    STDMETHOD(InitFromTemplate)() PURE;
    STDMETHOD(InitStandalone)(VARIANT varType, VARIANT varSubtype) PURE;
    STDMETHOD(Detach)() PURE;
    STDMETHOD(Apply)(DXT_QUICK_APPLY_TYPE eDXTQuickApplyType) PURE;

    STDMETHOD(put_transSite)(ITransitionSite * pTransElement) PURE;
    STDMETHOD(put_progress)(double dblProgress) PURE;
    STDMETHOD(get_progress)(double * pdblProgress) PURE;

    STDMETHOD(OnBeginTransition) (void) PURE;
    STDMETHOD(OnEndTransition) (void) PURE;

};


HRESULT CreateTransitionWorker(ITransitionWorker ** ppTransWorker);

#endif // _TRANSWORKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\codec.h ===
//+___________________________________________________________________________________
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: codec.h
//
//  Contents: 
//
//____________________________________________________________________________________



#ifndef _CODEC_H
#define _CODEC_H

class
ATL_NO_VTABLE
CDownloadCallback
    : public CComObjectRootEx<CComSingleThreadModel>,
      public IBindStatusCallback,
      public IAuthenticate,
      public ICodeInstall
{
  public:
    CDownloadCallback();
    virtual ~CDownloadCallback();
    
    BEGIN_COM_MAP(CDownloadCallback)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
        COM_INTERFACE_ENTRY(IAuthenticate)
        COM_INTERFACE_ENTRY(ICodeInstall)
        COM_INTERFACE_ENTRY(IWindowForBindingUI)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    // --- IBindStatusCallback methods ---

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                               LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                                    STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IAuthenticate methods
    STDMETHODIMP Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);

    // IWindowForBindingUI methods
    STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *phwnd);

    // ICodeInstall methods
    STDMETHODIMP OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination, 
                                      LPCWSTR szSource, DWORD dwReserved);

    HWND                m_hwnd;
    HRESULT             m_hrBinding;
    HANDLE              m_evFinished;
    ULONG               m_ulProgress;
    ULONG               m_ulProgressMax;
    DAComPtr<IBinding>  m_spBinding;
    DAComPtr<IUnknown>  m_pUnk;
};

#endif /* _CODEC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\containersite.h ===
#ifndef _CONTAINERSITE_H_
#define _CONTAINERSITE_H_

//************************************************************
//
// FileName:        containersite.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CContainerSite
//
//************************************************************

#include <docobj.h>
#include <mshtml.h>

// forward class declarations
class
ATL_NO_VTABLE
CContainerSiteHost
{
  public:
    virtual IHTMLElement * GetElement() = 0;
    virtual IServiceProvider * GetServiceProvider() = 0;

    virtual HRESULT Invalidate(LPCRECT prc) = 0;

    virtual HRESULT GetContainerSize(LPRECT prcPos) = 0;
    virtual HRESULT SetContainerSize(LPCRECT prcPos) = 0;
    virtual HRESULT ProcessEvent(DISPID dispid,
                                 long lCount, 
                                 VARIANT varParams[]) = 0;

    virtual HRESULT GetExtendedControl(IDispatch **ppDisp) = 0;
};

enum ObjectState
{
    OS_PASSIVE,
    OS_LOADED,
    OS_RUNNING,
    OS_INPLACE,
    OS_UIACTIVE
};

class
ATL_NO_VTABLE
CContainerSite :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatch,
    public IServiceProvider,
    public IOleClientSite,
    public IAdviseSinkEx,
    public IOleInPlaceSiteWindowless,
    public IOleInPlaceFrame,
    public IOleCommandTarget,
    public IOleControlSite
{
  public:
    CContainerSite();
    virtual ~CContainerSite();

    HRESULT Init(CContainerSiteHost &pHost,
                 IUnknown * pCtl,
                 IPropertyBag2 *pPropBag,
                 IErrorLog *pErrorLog);
    virtual void Detach();

    //
    // ATL Maps
    //

    BEGIN_COM_MAP(CContainerSite)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IOleClientSite)
        COM_INTERFACE_ENTRY(IAdviseSink)
        COM_INTERFACE_ENTRY(IAdviseSinkEx)
        COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceSiteWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceSite)
        COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
        COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY(IOleControlSite)
        COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
        COM_INTERFACE_ENTRY(IOleInPlaceFrame)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown Methods
    //
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

#endif
    //
    // IServiceProvider methods
    //
    STDMETHODIMP QueryService(REFGUID guid, REFIID iid, void **ppv);

    //
    // IOleClientSite methods
    //
    STDMETHODIMP SaveObject(void);
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk);
    STDMETHODIMP GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    //
    // IAdviseSink Methods
    //
    STDMETHODIMP_(void) OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *pmk);
    STDMETHODIMP_(void) OnSave(void);
    STDMETHODIMP_(void) OnClose(void);

    //
    // IAdviseSinkEx Methods
    //
    STDMETHODIMP_(void) OnViewStatusChange(DWORD dwViewStatus);

    //
    // IOleWindow Methods
    //
    STDMETHODIMP GetWindow(HWND *phWnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    //
    // IOleInPlaceSite Methods
    //
    STDMETHODIMP CanInPlaceActivate(void);
    STDMETHODIMP OnInPlaceActivate(void);
    STDMETHODIMP OnUIActivate(void);
    STDMETHODIMP GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppUIWin, RECT *prc, RECT *prcClip, OLEINPLACEFRAMEINFO *pFI);
    STDMETHODIMP Scroll(SIZE sz);
    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate(void);
    STDMETHODIMP DiscardUndoState(void);
    STDMETHODIMP DeactivateAndUndo(void);
    STDMETHODIMP OnPosRectChange(const RECT * prc);

    //
    // IOleInPlaceSiteEx Methods
    //
    STDMETHODIMP OnInPlaceActivateEx(BOOL * pfNoRedraw, DWORD dwFlags);
    STDMETHODIMP OnInPlaceDeactivateEx(BOOL fNoRedraw);
    STDMETHODIMP RequestUIActivate(void);

    //
    // IOleInPlaceSiteWindowless Methods
    //
    STDMETHODIMP CanWindowlessActivate(void);
    STDMETHODIMP GetCapture(void);
    STDMETHODIMP SetCapture(BOOL fCapture);
    STDMETHODIMP GetFocus(void);
    STDMETHODIMP SetFocus(BOOL fFocus);
    STDMETHODIMP GetDC(const RECT *pRect, DWORD dwFlags, HDC* phDC);
    STDMETHODIMP ReleaseDC(HDC hDC);
    STDMETHODIMP InvalidateRect(const RECT *pRect, BOOL fErase);
    STDMETHODIMP InvalidateRgn(HRGN hRGN, BOOL fErase);
    STDMETHODIMP ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip);
    STDMETHODIMP AdjustRect(RECT *prc);
    STDMETHODIMP OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

    //
    // IOleUIWindow
    //
    STDMETHODIMP GetBorder(LPRECT prcBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pBW);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pBW);
    STDMETHODIMP SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj);

    //
    // IOleInPlaceFrame Methods
    //
    STDMETHODIMP InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW);
    STDMETHODIMP SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj);
    STDMETHODIMP RemoveMenus(HMENU hMenu);
    STDMETHODIMP SetStatusText(LPCOLESTR pszText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG pMSG, WORD wID);

    //
    // IDispatch Methods
    //
    STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
    STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
    STDMETHODIMP Invoke(DISPID disIDMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

    //
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    //
    // IOleControlSite methods
    //
    STDMETHOD(OnControlInfoChanged)(void);
    STDMETHOD(LockInPlaceActive)(BOOL fLock);
    STDMETHOD(GetExtendedControl)(IDispatch **ppDisp);
    STDMETHOD(TransformCoords)(POINTL *pPtlHiMetric, POINTF *pPtfContainer, DWORD dwFlags);
    STDMETHOD(TranslateAccelerator)(MSG *pmsg, DWORD grfModifiers);
    STDMETHOD(OnFocus)(BOOL fGotFocus);
    STDMETHOD(ShowPropertyFrame)(void);

    // internal
    HRESULT Activate();
    HRESULT Deactivate();
    HRESULT Unload();
    HRESULT Draw(HDC hdc, RECT *prc);

    IOleInPlaceObject *GetIOleInPlaceObject() { return m_pInPlaceObject;}

    // persistance
    HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    void SetSize (RECT *pRect);

  protected:
    enum
    {
        VALIDATE_ATTACHED = 1,
        VALIDATE_LOADED   = 2,
        VALIDATE_INPLACE  = 3,
        VALIDATE_WINDOWLESSINPLACE = 4
    };

    bool IllegalSiteCall(DWORD dwFlags);
    virtual HRESULT _OnPosRectChange(const RECT * prc) { return S_OK; }

  protected:
    DWORD                            m_dwAdviseCookie;
    ObjectState                      m_osMode;
    IViewObject2                    *m_pViewObject;
    IOleObject                      *m_pIOleObject;
    IUnknown                        *m_pObj;
    IOleInPlaceObject               *m_pInPlaceObject;
    IHTMLDocument2                  *m_pHTMLDoc;
    CContainerSiteHost              *m_pHost;
    bool                             m_fWindowless;
    bool                             m_fStarted;
    bool                             m_fIgnoreInvalidate;
    RECT                             m_rectSize;
}; // CContainerSite

#endif //_CONTAINERSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\include\util.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\include\util.h
//
//  Contents: commonly used utility functions, etc.
//
//------------------------------------------------------------------------------------

#ifndef _UTIL_H
#define _UTIL_H

#include "mstime.h"
#include "atlcom.h"
#include "array.h"
#include <ras.h>

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define TIME_INFINITE HUGE_VAL
#define valueNotSet -1

#if DBG == 1

//+------------------------------------------------------------------------
//
//  This is to allow tracing of TIME-only THRs and IGNORE_HRs.
//
//-------------------------------------------------------------------------
HRESULT THRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine);
void    IGNORE_HRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine);

#endif // if DBG == 1

class TimeValueList;

//+------------------------------------------------------------------------
//
//  global: enum for tri-state variables .
//
//-------------------------------------------------------------------------
enum TRI_STATE_BOOL {TSB_UNINITIALIZED, TSB_TRUE, TSB_FALSE};



//************************************************************
// this is used globally to denote that when scripting, we 
// use English.
#define LCID_SCRIPTING 0x0409

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS;


//+-------------------------------------------------------------------------------------
// RAS accessor function types
//+-------------------------------------------------------------------------------------
typedef DWORD (APIENTRY *RASGETCONNECTIONSTATISTICSPROC)(HRASCONN hRasConn, RAS_STATS *lpStatistics);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)( LPRASCONNW, LPDWORD, LPDWORD );


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar ? _allocArr: _ppUnk; } //lint !e1402

    bool IsOK() { return !_failed; }
  protected:
    SafeArrayAccessor();
    NO_COPY(SafeArrayAccessor);

    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

WCHAR * TrimCopyString(const WCHAR *str);
WCHAR * BeckifyURL(WCHAR *url);

IDirectDraw * GetDirectDraw(void);

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT *pf,
                       bool vidmem,
                       LONG width, LONG height);

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect);

/////////////////////////  CriticalSections  //////////////////////

class CritSect
{
  public:
    CritSect();
    ~CritSect();
    void Grab();
    void Release();
    
  protected:
    CRITICAL_SECTION _cs;
};

class CritSectGrabber
{
  public:
    CritSectGrabber(CritSect& cs, bool grabIt = true);
    ~CritSectGrabber();
    
  protected:
    NO_COPY(CritSectGrabber);
    CritSectGrabber();

    CritSect& _cs;
    bool grabbed;
};

/////////////////////// Misc ////////////////////

typedef bool TEDirection;
const bool TED_Forward = true;
const bool TED_Backward = false;

inline bool TEIsForward(TEDirection dir) { return dir; }
inline bool TEIsBackward(TEDirection dir) { return !dir; }
inline TEDirection TEReverse(TEDirection dir) { return !dir; }

#if DBG
inline char *
DirectionString(TEDirection dir)
{
    return dir?"Forward":"Backward";
}
#endif

#define INDEFINITE (float) HUGE_VAL //defined for Variant conversion functions

#define FOREVER    (float) HUGE_VAL

#define INVALID    ((float) -HUGE_VAL)

HRESULT GetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, LONG lFlags, VARIANT * value);
HRESULT SetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, VARIANT value, LONG lFlags);
BSTR CreateTIMEAttrName(LPCWSTR str);

bool VariantToBool(VARIANT var);
float VariantToFloat(VARIANT var,
                     bool bAllowIndefinite = false,
                     bool bAllowForever = false);
HRESULT VariantToTime(VARIANT vt, float *retVal, long *lframe = NULL, bool *isFrame = NULL);
BOOL IsIndefinite(OLECHAR *szTime);

extern const wchar_t * TIMEAttrPrefix;

/////////////////////// Convenience macros ////////////////////

//
// used in QI implementations for safe pointer casting
// e.g. if( IsEqualGUID(IID_IBleah) ) *ppv = SAFECAST(this,IBleah);
// Note: w/ vc5, this is ~equiv to *ppv = static_cast<IBleah*>(this);
//
#define SAFECAST(_src, _type) static_cast<_type>(_src)

// 
// used in QI calls, 
// e.g. IOleSite * pSite;  p->QI( IID_TO_PPV(IOleInPlaceSite, &pSite) ) 
// would cause a C2440 as _src is not really a _type **.
// Note: the riid must be the _type prepended by IID_.
//
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

// Explicit directive to ignore a return value
#define IGNORE_RETURN(_call)        static_cast<void>((_call))

//************************************************************


#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86


//
// ReleaseInterface calls 'Release' and NULLs the pointer
// The Release() return will be in eax for IA builds.
//
#define ReleaseInterface(p)\
{\
    /*lint -e550 -e774 -e423*/ /* suppress cRef not referenced, if always evaluates to false, and creation of memory leak */ \
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
    /*lint -restore */ \
} 

//************************************************************
// Error Reporting helper macros

HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg = NULL);

HRESULT CheckElementForBehaviorURN(IHTMLElement *pElement,
                                   WCHAR *wzURN,
                                   bool *pfReturn);
HRESULT TIMEGetLastError(void);
LPWSTR TIMEGetLastErrorString(void);

HRESULT AddBodyBehavior(IHTMLElement* pElement);
HRESULT GetBodyElement(IHTMLElement *pElement, REFIID riid, void **);

bool IsTIMEBodyElement(IHTMLElement *pElement);
HRESULT FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem);
HRESULT FindTIMEBehavior(IHTMLElement *pHTMLElem, IDispatch **ppDisp);

HRESULT FindBehaviorInterface(LPCWSTR pszName,
                              IDispatch *pHTMLElem,
                              REFIID riid,
                              void **ppRet);

bool IsTIMEBehaviorAttached (IDispatch *pidispElem);
bool IsComposerSiteBehaviorAttached (IDispatch *pidispElem);

HRESULT EnsureComposerSite (IHTMLElement2 *pielemTarget, IDispatch **ppidispComposerSite);

const LPOLESTR HTMLSTREAMSRC = L"#html";
const LPOLESTR SAMISTREAMSRC = L"#sami";
const long HTMLSTREAMSRCLEN = 5;

const LPOLESTR M3USRC = L".m3u";
const LPOLESTR WAXSRC = L".wax";
const LPOLESTR WMXSRC = L".wmx";
const LPOLESTR WVXSRC = L".wvx";
const LPOLESTR ASXSRC = L".asx";
const LPOLESTR ASFSRC = L".asf";
const LPOLESTR WMFSRC = L".wmf";
const LPOLESTR LSXSRC = L".lsx";
const LPOLESTR ASXMIME = L"x-ms-asf";
const LPOLESTR ASXMIME2 = L"asx";
const LPOLESTR WZ_VML_URN = L"urn:schemas-microsoft-com:vml";

bool IsHTMLSrc(const WCHAR * src);

bool IsASXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsM3USrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWAXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWVXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWMFSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsLSXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWMXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);

bool MatchElements (IUnknown *piInOne, IUnknown *piInTwo);

LPWSTR GetSystemLanguage(IHTMLElement *pEle);
bool GetSystemCaption();
bool GetSystemOverDub();
HRESULT GetSystemBitrate(long *lpBitrate);
LPWSTR GetSystemConnectionType();
HRESULT CheckRegistryBitrate(long *pBitrate);


//////////////////////////////////////////////////////////////////////////////////////////////////
// IDispatch Utilities
//////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT PutProperty (IDispatch *pidisp, LPCWSTR wzPropName, VARIANTARG *pvar);
HRESULT GetProperty (IDispatch *pidisp, LPCWSTR wzPropName, VARIANTARG *pvar);
HRESULT CallMethod(IDispatch *pidisp, LPCWSTR wzMethodName, VARIANT *pvarResult = NULL, VARIANT *pvarArgument1 = NULL);
bool IsVMLObject(IDispatch *pidisp);

//////////////////////////////////////////////////////////////////////////////////////////////////
// String Parsing Utilities
//////////////////////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------------------
//
//  Structure:  STRING_TOKEN
//
//  Synopsis:   References a token in a string. Used in conjunction with a string Str, 
//              the first character of the token is Str[uIndex] and the last character
//              of the token is Str[uIndex + uLength - 1].
//
//  Members:    [uIndex]    Index of the first character of the token. First char of the
//                          string has uIndex = 0.
//              [uLength]   Number of characters in the token, excluding separators, null, etc.  
//
//------------------------------------------------------------------------------------

typedef struct TAG_STRING_TOKEN
{
    UINT    uIndex;
    UINT    uLength;
} STRING_TOKEN;


HRESULT StringToTokens(/*in*/ LPWSTR                   pstrString, 
                       /*in*/ LPWSTR                   pstrSeparators, 
                       /*out*/CPtrAry<STRING_TOKEN*> * paryTokens );  

HRESULT TokensToString(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens, 
                       /*in*/  LPWSTR                   pstrString, 
                       /*out*/ LPWSTR *                 ppstrOutString);  

HRESULT TokenSetDifference(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens1,
                           /*in*/  LPWSTR                   pstr1,
                           /*in*/  CPtrAry<STRING_TOKEN*> * paryTokens2,
                           /*in*/  LPWSTR                   pstr2,
                           /*out*/ CPtrAry<STRING_TOKEN*> * paryTokens1Minus2);

HRESULT FreeStringTokenArray(/*in*/CPtrAry<STRING_TOKEN*> * paryTokens);


bool    StringEndsIn(const LPWSTR pszString, const LPWSTR pszSearch);


bool IsPalettizedDisplay();

bool IsElementNameThis(IHTMLElement * pElement, LPWSTR pszName);
bool IsElementPriorityClass(IHTMLElement * pElement);
bool IsElementTransition(IHTMLElement * pElement);

HRESULT GetHTMLAttribute(IHTMLElement * pElement, const WCHAR * pwchAttribute, VARIANT * pVar);

bool IsValidtvList(TimeValueList *tvlist);

HRESULT
SinkHTMLEvents(IUnknown * pSink, 
               IHTMLElement * pEle, 
               IConnectionPoint ** ppDocConPt,
               DWORD * pdwDocumentEventConPtCookie,
               IConnectionPoint ** ppWndConPt,
               DWORD * pdwWindowEventConPtCookie);

// get document.all.pwzID
HRESULT FindHTMLElement(LPWSTR pwzID, IHTMLElement * pAnyElement, IHTMLElement ** ppElement);
HRESULT SetVisibility(IHTMLElement * pElement, bool bVisibile);
HRESULT GetSyncBaseBody(IHTMLElement * pHTMLElem, ITIMEBodyElement ** ppBodyElem);

HRESULT WalkUpTree(IHTMLElement *pFirst, long &lscrollOffsetyc, long &lscrollOffsetxc, long &lPixelPosTopc, long &lPixelPosLeftc);
void GetRelativeVideoClipBox(RECT &screenRect, RECT &elementSize, RECT &rectVideo, long lscaleFactor);
//
//
//

inline double
Clamp(double min, double val, double max)
{
    if (val < min)
    {
        val = min;
    }
    else if (val > max)
    {
        val = max;
    }

    return val;
}

double 
Round(double inValue);

double 
InterpolateValues(double dblNum1, double dblNum2, double dblProgress);

inline int
Clamp(int min, int val, int max)
{
    if (val < min)
    {
        val = min;
    }
    else if (val > max)
    {
        val = max;
    }

    return val;
}

HRESULT GetReadyState(IHTMLElement * pElm, BSTR * pbstrReadyState);

HRESULT CreateObject(REFCLSID clsid,
                     REFIID iid,
                     void ** ppObj);
 
HWND GetDocumentHwnd(IHTMLDocument2 * pDoc);


//
// Returns true if this is Win95 or 98
//

bool TIMEIsWin9x(void);

//
// Returns true is this is Win95 only
//
bool TIMEIsWin95(void);

//
// Combine a base and src into newly allocated storage, ppOut
//
HRESULT TIMECombineURL(LPCTSTR base, LPCTSTR src, LPOLESTR * ppOut);

UINT TIMEGetUrlScheme(const TCHAR * pchUrlIn);

bool ConvertToPixelsHELPER(LPOLESTR szString, LPOLESTR szKey, double dFactor, float fPixelFactor, double *outVal);
//
// Find a mime type
//
HRESULT
TIMEFindMimeFromData(LPBC pBC,
                     LPCWSTR pwzUrl,
                     LPVOID pBuffer,
                     DWORD cbSize,
                     LPCWSTR pwzMimeProposed,
                     DWORD dwMimeFlags,
                     LPWSTR *ppwzMimeOut,
                     DWORD dwReserved);

//
// Property change notification helper
//

HRESULT NotifyPropertySinkCP(IConnectionPoint *pICP, DISPID dispid);

//
// Stub out property accessors that don't really belong on an object.
//
#define STUB_INVALID_ATTRIBUTE_GET(type_name,attrib_name) \
STDMETHOD(get_##attrib_name##) ( ##type_name## * ) \
{\
    return E_UNEXPECTED;\
}

#define STUB_INVALID_ATTRIBUTE_PUT(type_name,attrib_name) \
STDMETHOD(put_##attrib_name##) ( ##type_name## ) \
{\
    return E_UNEXPECTED;\
}

#define STUB_INVALID_ATTRIBUTE(type_name,attrib_name) \
    STUB_INVALID_ATTRIBUTE_GET(##type_name##,##attrib_name##)\
    STUB_INVALID_ATTRIBUTE_PUT(##type_name##,##attrib_name##)


#ifdef DBG

//
// Debugging Utilities
//

void PrintStringTokenArray(/*in*/ LPWSTR                  pstrString, 
                           /*in*/CPtrAry<STRING_TOKEN*> * paryTokens);

void PrintWStr(/*in*/ LPWSTR pstr);

#endif /* DBG */

#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\containersite.cpp ===
//************************************************************
//
// FileName:        containersite.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container site implementation.
//
//************************************************************

#include "headers.h"
#include "containersite.h"
#include "player.h"
#include "util.h"
#include "eventmgr.h"

DeclareTag(tagContainerSite, "TIME: Players", "CContainerSite methods");

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerSite::CContainerSite() :
    m_pObj(NULL),
    m_pIOleObject(NULL),
    m_pInPlaceObject(NULL),
    m_pViewObject(NULL),
    m_dwAdviseCookie(0),
    m_osMode(OS_PASSIVE),
    m_fWindowless(false),
    m_pHTMLDoc(NULL),
    m_pHost(NULL),
    m_fStarted(false),
    m_fIgnoreInvalidate(false)
{
    TraceTag((tagContainerSite, "CContainerSite::CContainerSite"));

    m_rectSize.top = m_rectSize.left = m_rectSize.bottom = m_rectSize.right = 0;
} // CContainerSite

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerSite::~CContainerSite()
{
    TraceTag((tagContainerSite, "CContainerSite::~CContainerSite"));
    
    m_pHost = NULL;

    ReleaseInterface(m_pViewObject);
    ReleaseInterface(m_pIOleObject);
    ReleaseInterface(m_pObj);
    ReleaseInterface(m_pInPlaceObject);
    ReleaseInterface(m_pHTMLDoc);
} // ~CContainerSite

HRESULT
CContainerSite::Init(CContainerSiteHost & pHost,
                     IUnknown * pObj,
                     IPropertyBag2 *pPropBag,
                     IErrorLog *pErrorLog)
{
    TraceTag((tagContainerSite, "CContainerSite::Init"));

    HRESULT hr = S_OK;
    CComPtr<IPersistPropertyBag2> spPropBag;

    Assert(pObj);

    m_pHost = &pHost;
    
    m_pObj = pObj;
    m_pObj->AddRef();
    
    // Weak reference.
    IHTMLElement *pHTMLElem = m_pHost->GetElement();
    
    if (NULL == pHTMLElem)
    {
        TraceTag((tagError,
                  "CContainerSite::Init - unable to get element pointer from time behavior!!!"));
        hr = E_UNEXPECTED;
        goto done;
    }

    {
        DAComPtr<IDispatch> pDisp;
        hr = THR(pHTMLElem->get_document(&pDisp));
        if (FAILED(hr))
        {
            goto done;
        }
        
        Assert(pDisp);
        Assert(m_pHTMLDoc == NULL);
        hr = THR(pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &m_pHTMLDoc)));

        if (FAILED(hr))
        {
            goto done;
        }
    }

    Assert(m_pHTMLDoc != NULL);

    // We need an IOleObject most of the time, so get one here.
    hr = THR(m_pObj->QueryInterface(IID_TO_PPV(IOleObject, &m_pIOleObject)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pIOleObject->QueryInterface(IID_TO_PPV(IViewObject2, &m_pViewObject)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pObj->QueryInterface(IID_TO_PPV(IPersistPropertyBag2, &spPropBag)));
    if (SUCCEEDED(hr) && pPropBag != NULL)
    {
        hr = THR(spPropBag->Load(pPropBag, pErrorLog));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    // SetClientSite is critical for DocObjects
    hr = THR(m_pIOleObject->SetClientSite(SAFECAST(this, IOleClientSite*)));
    if (FAILED(hr))
    {
        goto done;
    }

    m_dwAdviseCookie = 0;
    hr = THR(m_pIOleObject->Advise(SAFECAST(this, IAdviseSink*), &m_dwAdviseCookie));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_dwAdviseCookie != 0);

    // Put the object in the running state
    hr = THR(OleRun(m_pIOleObject));
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_osMode = OS_RUNNING;
        
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    RRETURN(hr);
} // Init

void 
CContainerSite::SetSize(RECT *pRect)
{
	HRESULT hr = S_OK;

    if (!pRect)
    {
        goto done;
    }

    m_rectSize.top = pRect->top;
    m_rectSize.left = pRect->left;
    m_rectSize.right = pRect->right;
    m_rectSize.bottom = pRect->bottom;

    hr = THR(m_pInPlaceObject->SetObjectRects(pRect, pRect));
    if (FAILED(hr))
    {
        goto done;
    }

  done:

    return;
}

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        Detach
//************************************************************
void
CContainerSite::Detach()
{
    TraceTag((tagContainerSite, "CContainerSite(%p)::Detach()",
              this));

    Unload();

    m_osMode = OS_LOADED;

    ReleaseInterface(m_pObj);

    m_osMode = OS_PASSIVE;

    // local book keeping
    ReleaseInterface(m_pHTMLDoc);

    m_pHost = NULL;
} // Detach

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Validate call
//************************************************************

bool
CContainerSite::IllegalSiteCall(DWORD dwFlags)
{
    // check object state
    switch (dwFlags)
    {
        case VALIDATE_WINDOWLESSINPLACE:
            if (!m_fWindowless)
            {
                Assert(0 && "Illegal call to windowless interface by ActiveX control (not a hosting bug)");
                return true;
            }
            break;

        case VALIDATE_INPLACE:
            if (m_osMode < OS_INPLACE)
                return true;
            break;

        case VALIDATE_LOADED:
            if (m_osMode < OS_LOADED)
                return true;
            break;
        default:
            break;
    }

    return false;
} // IllegalSiteCall

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        IService Provider method
//************************************************************

STDMETHODIMP
CContainerSite::QueryService(REFGUID sid, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    IServiceProvider *psp = NULL;

    if( NULL == ppv )
    {
        Assert( false );
        return E_POINTER;
    }

    *ppv = NULL;

    // check to see if this is something we support locally
    // in the container.
    if (IsEqualGUID(sid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
        goto done;
    }

   
    // Fall back to TIME Element if we still have one.

    // We have the supporting Service Provider cached (at init() time) for 
    // the behavior over in CBaseBvr which CTIMEElementBase inherits from.
    if (m_pHost != NULL)
    {
        psp = m_pHost->GetServiceProvider();
        if (psp != NULL)
        {
            hr = psp->QueryService(sid, riid, ppv);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CContainerSite::QueryService - query failed!!! [%08X]", hr));
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }

  done:
    return hr;
} // QueryService

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::Activate()
{
    HRESULT hr = S_OK;
    HWND hWnd = NULL;
    RECT rc;

    rc.left = rc.top = rc.right = rc.bottom = 0;

    hr = THR(GetWindow(&hWnd));
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pIOleObject && !m_fStarted)
    {
        hr = m_pIOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE,
                                   NULL, 
                                   SAFECAST(this, IOleClientSite*), 
                                   0, 
                                   hWnd, 
                                   &rc);

    }
    m_fStarted = true;
    hr = S_OK;
done:
    return hr;
}


HRESULT
CContainerSite::Unload()
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite(%p)::Unload()",
              this));

    // Deactivate InPlace Object (Interface is released as a result of this call)
    if (m_pInPlaceObject != NULL)
    { 
        m_pInPlaceObject->InPlaceDeactivate();
        ReleaseInterface(m_pInPlaceObject);
    }

    ReleaseInterface(m_pViewObject);

    if (m_pIOleObject != NULL)
    {
        DAComPtr<IOleObject> spTmp = m_pIOleObject;
        
        ReleaseInterface(m_pIOleObject);

        spTmp->Close(OLECLOSE_NOSAVE);

        Assert(m_dwAdviseCookie != 0);

        spTmp->Unadvise(m_dwAdviseCookie);
        spTmp->SetClientSite(NULL);
    }

    hr = S_OK;
  done:
    return hr;
}


//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::Deactivate()
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite(%p)::Deactivate()",
              this));

    m_fStarted = false;
    
    hr = S_OK;
  done:
    return hr;
}


//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

HRESULT
CContainerSite::Draw(HDC hdc, RECT *prc)
{
    HRESULT hr = S_OK;

    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, NULL)", hdc));
    else
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, (%d, %d, %d, %d))", hdc, prc->left, prc->top, prc->right, prc->bottom));

    if (m_pViewObject == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    // repack rect into RECTL.
    RECTL  rcl;
    RECTL *prcl;
    
    if (prc == NULL)
    {
        prcl = NULL;
    }
    else
    {
        rcl.left = prc->left;
        rcl.top = prc->top;
        rcl.right = prc->right;
        rcl.bottom = prc->bottom;
        prcl = &rcl;

        if (m_pInPlaceObject)
        {
            // This is a workaround for the WMP.  We have to ignore the Invalidate that is 
            // generated in the SetObjectRect in the Draw call otherwise will will not render correctly
            m_fIgnoreInvalidate = true;
            hr = m_pInPlaceObject->SetObjectRects(prc, prc);
            m_fIgnoreInvalidate = false;
            if (FAILED(hr))
            {
                goto done;
            }
        }

    }

    hr = m_pViewObject->Draw(DVASPECT_CONTENT,
                             0,
                             NULL,
                             NULL,
                             NULL,
                             hdc,
                             prcl,
                             NULL,
                             NULL,
                             0);
done:

    return hr;
} // render

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SaveObject, IOleClientSite 
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

STDMETHODIMP
CContainerSite::SaveObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::SaveObject"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    RRETURN(E_NOTIMPL);
} // SaveObject

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetMoniker, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk)
{
    TraceTag((tagContainerSite, "CContainerSite::GetMoniker"));
    return E_NOTIMPL;
} // GetMoniker

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetContainer, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetContainer(IOleContainer **ppContainer)
{
    TraceTag((tagContainerSite, "CContainerSite::GetContainer"));

    *ppContainer = NULL;
    return E_NOINTERFACE;
} // GetContainer

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestNewObjectLayout, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::RequestNewObjectLayout(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestNewObjectLayout"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // RequestNewObjectLayout

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnShowWindow, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagContainerSite, "CContainerSite::OnShowWindow"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // OnShowWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ShowObject, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ShowObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowObject"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // ShowObject

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnControlInfoChanged, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnControlInfoChanged(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnControlInfoChanged"));
    return S_OK;
} // OnControlInfoChanged

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        LockInPlaceActive, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagContainerSite, "CContainerSite::LockInPlaceActive"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // LockInPlaceActive

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        GetExtendedControl, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetExtendedControl(IDispatch **ppDisp)
{
    TraceTag((tagContainerSite, "CContainerSite::GetExtendedControl"));
    
    HRESULT hr = E_NOTIMPL;
    
    CHECK_RETURN_SET_NULL(ppDisp);
    
    if (m_pHost != NULL)
    {
        hr = m_pHost->GetExtendedControl(ppDisp);
    }

    return hr;
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TransformCoords, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::TransformCoords(POINTL *pPtlHiMetric,
                       POINTF *pPtfContainer,
                       DWORD   dwFlags)
{
    TraceTag((tagContainerSite, "CContainerSite::TransformCoords"));
    return E_NOTIMPL;
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TranslateAccelerator, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::TranslateAccelerator(MSG *pmsg, DWORD grfModifiers)
{
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    return S_FALSE;
} // TranslateAccelerator

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnFocus, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnFocus"));
    return S_OK;
} // OnFocus

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        ShowPropertyFrame, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ShowPropertyFrame(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowPropertyFrame"));
    return S_OK;
} // ShowPropertyFrame

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindow, IOleWindow 
// Abstract:        Retrieves the handle of the window 
//                  associated with the object on which this 
//                  interface is implemented.
//************************************************************

STDMETHODIMP
CContainerSite::GetWindow(HWND *phWnd)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindow"));

    if (phWnd == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetWindow - invalid arg"));
        return E_POINTER;
    }
        
    Assert(m_pHTMLDoc != NULL);

    IOleWindow *pOleWindow = NULL;
    HRESULT hr = m_pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pOleWindow));

#if 1
    if (FAILED(hr))
    {
        goto done;
    }
#else
    if (FAILED(hr))
    {
        // IE4 path
        CComPtr<IElementBehaviorSite> spElementBehaviorSite;
        spElementBehaviorSite = m_pTIMEElem->GetBvrSite();

        CComPtr<IObjectWithSite> spSite;
        // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
        hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
        if (FAILED(hr))
        {
            goto done;
        }

        // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
        hr = spSite->GetSite(IID_IOleWindow, (void**) &pOleWindow);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::GetWindow - unable to QI for IOleWindow on hosting Document"));
            goto done;
        }
    }
#endif
   
    Assert(pOleWindow != NULL);

    hr = pOleWindow->GetWindow(phWnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(*phWnd != NULL);
    
    hr = S_OK;
done:
    ReleaseInterface(pOleWindow);
    return hr;
} // GetWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ContextSensitiveHelp, IOleWindow 
// Abstract:        Instructs the object on which this 
//                  interface is implemented to enter or leave 
//                  a context-sensitive help mode.
//************************************************************

STDMETHODIMP
CContainerSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagContainerSite, "CContainerSite::ContextSensitiveHelp"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    
    // ISSUE - reach back to document and forward on call to it's InplaceSite!
    return NOERROR;
} // ContextSensitiveHelp

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanInPlaceActivate, IOleInPlaceSite
// Abstract:        Answers the server whether or not we can 
//                  currently in-place activate its object.  
//                  By implementing this interface we say
//                  that we support in-place activation, but 
//                  through this function we indicate whether 
//                  the object can currently be activated
//                  in-place.  Iconic aspects, for example, 
//                  cannot, meaning we return S_FALSE.
//************************************************************

STDMETHODIMP
CContainerSite::CanInPlaceActivate(void)
{    
    TraceTag((tagContainerSite, "CContainerSite::CanInPlaceActivate"));
    return S_OK;
} // CanInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivate, IOleInPlaceSite
// Abstract:        Informs the container that an object is 
//                  being activated in-place such that the 
//                  container can prepare appropriately.  The
//                  container does not, however, make any user 
//                  interface changes at this point.
//                  See OnUIActivate.
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivate"));
    return OnInPlaceActivateEx(NULL, 0);
} // OnInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivate, IOleInPlaceSite
// Abstract:        Notifies the container that the object has 
//                  deactivated itself from an in-place state.  
//                  Opposite of OnInPlaceActivate.  The 
//                  container does not change any UI at this 
//                  point.
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceDeactivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivate"));

    if (m_osMode == OS_UIACTIVE)
        OnUIDeactivate(false);
    
    Assert(m_pInPlaceObject != NULL);
    ReleaseInterface(m_pInPlaceObject);

    m_fWindowless = false;
    m_osMode = OS_RUNNING;

    return S_OK;
} // OnInPlaceDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIActivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  going to start munging around with user 
//                  interface, like replacing the menu.  The
//                  container should remove any relevant UI in 
//                  preparation.
//************************************************************

STDMETHODIMP
CContainerSite::OnUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIActivate"));
    if (IllegalSiteCall(VALIDATE_LOADED) ||
        (m_osMode < OS_RUNNING))
    {
        TraceTag((tagError, "Object is not inplace yet!!!"));
        return E_UNEXPECTED;
    }

    m_osMode = OS_UIACTIVE;
    return S_OK;
} // OnUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIDeactivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  deactivating its in-place user interface 
//                  at which time the container may reinstate 
//                  its own.  Opposite of OnUIActivate.
//************************************************************

STDMETHODIMP
CContainerSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIDeactivate"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    
    m_osMode = OS_INPLACE;
    return S_OK;
} // OnUIDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DeactivateAndUndo, IOleInPlaceSite
// Abstract:        If immediately after activation the object 
//                  does an Undo, the action being undone is 
//                  the activation itself, and this call
//                  informs the container that this is, in 
//                  fact, what happened.
//************************************************************

STDMETHODIMP
CContainerSite::DeactivateAndUndo(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DeactivateAndUndo"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // DeactivateAndUndo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DiscardUndoState, IOleInPlaceSite
// Abstract:        Informs the container that something 
//                  happened in the object that means the 
//                  container should discard any undo 
//                  information it currently maintains for the 
//                  object.
//************************************************************

STDMETHODIMP
CContainerSite::DiscardUndoState(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DiscardUndoState"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // DiscardUndoState

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindowContext, IOleInPlaceSite
// Abstract:        Provides an in-place object with pointers 
//                  to the frame and document level in-place 
//                  interfaces (IOleInPlaceFrame and 
//                  IOleInPlaceUIWindow) such that the object 
//                  can do border negotiation and so forth.  
//                  Also requests the position and clipping 
//                  rectangles of the object in the container 
//                  and a pointer to an OLEINPLACEFRAME info 
//                  structure which contains accelerator 
//                  information.
//
//                  NOTE: that the two interfaces this call 
//                  returns are not available through 
//                  QueryInterface on IOleInPlaceSite since 
//                  they live with the frame and document, but 
//                  not the site.
//************************************************************

STDMETHODIMP
CContainerSite::GetWindowContext(IOleInPlaceFrame    **ppFrame,
                                 IOleInPlaceUIWindow **ppUIWindow, 
                                 RECT                 *prcPos, 
                                 RECT                 *prcClip, 
                                 OLEINPLACEFRAMEINFO  *pFI)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindowContext"));
    HRESULT hr;

    if ( (ppFrame == NULL) ||
         (ppUIWindow == NULL) ||
         (prcPos == NULL) ||
         (prcClip == NULL) ||
         (pFI == NULL) )
    {
        TraceTag((tagError, "CContainerSite::GetWindowContext - invalid arg"));
        return E_POINTER;
    }

    *ppFrame = NULL;
    *ppUIWindow = NULL;
    SetRectEmpty(prcPos);
    SetRectEmpty(prcClip);
    memset(pFI, 0, sizeof(OLEINPLACEFRAMEINFO));

    if (IllegalSiteCall(VALIDATE_LOADED))
    {
        Assert(0 && "Unexpected call to client site.");
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // return pointers to ourselves
    // NOTE: these are stubbed out
    hr = THR(this->QueryInterface(IID_IOleInPlaceFrame, (void**)ppFrame));
    if (FAILED(hr))
        goto done;

    hr = THR(this->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow));
    if (FAILED(hr))
        goto done;

    // get position rect
    if (m_pHost != NULL)
    {
        hr = THR(m_pHost->GetContainerSize(prcPos));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // Note that Clip and Pos are the same.
    ::CopyRect(prcClip, prcPos);

    hr = S_OK;

done:
    return hr;
} // GetWindowContext

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Scroll, IOleInPlaceSite
// Abstract:        Asks the container to scroll the document, 
//                  and thus the object, by the given amounts 
//                  in the sz parameter.
//************************************************************

STDMETHODIMP
CContainerSite::Scroll(SIZE sz)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::Scroll"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // Scroll

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnPosRectChange, IOleInPlaceSite
// Abstract:        Informs the container that the in-place 
//                  object was resized.  This does not change 
//                  the site's rectangle in any case.
//************************************************************

STDMETHODIMP
CContainerSite::OnPosRectChange(const RECT *prcPos)
{
    if (prcPos == NULL)
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange((%d, %d, %d, %d))", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));
 
    HRESULT hr;

    if (prcPos == NULL)
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - invalidarg"));
        hr = E_POINTER;
        goto done;
    }


    if (IllegalSiteCall(VALIDATE_INPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (m_pHost == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(_OnPosRectChange(prcPos));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
} // OnPosRectChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags)
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivateEx"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    Assert(m_pInPlaceObject == NULL);

    // Make Sure we are Windowless
    if (dwFlags == ACTIVATE_WINDOWLESS)
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObjectWindowless, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
        m_fWindowless = true;
    }
    else
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObject, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
    }

    if (m_pInPlaceObject)
    {
        if (m_rectSize.bottom - m_rectSize.top != 0 && m_rectSize.left - m_rectSize.right != 0)
        {
            IGNORE_HR(m_pInPlaceObject->SetObjectRects(&m_rectSize, &m_rectSize));
        }
    }

    if (pfNoRedraw != NULL)
        *pfNoRedraw = m_fWindowless ? true : false;

    m_osMode = OS_INPLACE;

    return S_OK;
} // OnInPlaceActivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivateEx"));
        
    return OnInPlaceDeactivate();
} // OnInPlaceDeactivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestUIActivate, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::RequestUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestUIActivate"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // RequestUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanWindowlessActivate, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::CanWindowlessActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::CanWindowlessActivate"));
    return S_OK;
} // CanWindowlessActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetCapture, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetCapture(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // GetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetCapture, IOleInPlaceSiteWindowless
// Abstract:        Enables an in-place active, windowless 
//                  object to capture all mouse messages.
//                  If TRUE, the container should capture the 
//                  mouse for the object. If FALSE, the container 
//                  should release mouse capture for the object. 
//************************************************************

STDMETHODIMP
CContainerSite::SetCapture(BOOL fCapture)
{
    TraceTag((tagContainerSite, "CContainerSite::SetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // SetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetFocus, IOleInPlaceSiteWindowless
// Abstract:        Called by an in-place active, windowless 
//                  object to determine if it still has the 
//                  keyboard focus or not.
//************************************************************

STDMETHODIMP
CContainerSite::GetFocus(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return S_FALSE;
} // GetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetFocus, IOleInPlaceSiteWindowless
// Abstract:        Sets the keyboard focus for a UI-active, 
//                  windowless object.  If TRUE, sets the 
//                  keyboard focus to the calling object. If FALSE, 
//                  removes the keyboard focus from the calling object, 
//                  provided that the object has the focus.
//************************************************************

STDMETHODIMP
CContainerSite::SetFocus(BOOL fFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::SetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
 } // SetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetDC(const RECT *prc, DWORD dwFlags, HDC *phDC)
{
    TraceTag((tagContainerSite, "CContainerSite::GetDC"));
    HRESULT hr;
    HWND hWnd;

    if (phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - invalid arg"));
        hr = E_POINTER;
        goto done;
    }

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = GetWindow(&hWnd);
    if (FAILED(hr) || (hWnd == NULL))
    {
        TraceTag((tagError, "CContainerSite::GetDC - GetWindow() failed"));
        hr = E_FAIL;
        goto done;
    }

    *phDC = ::GetDC(hWnd);
    if (*phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - Win32 GetDC returned NULL!"));
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }

done:
    return hr;
} // GetDC

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ReleaseDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ReleaseDC(HDC hDC)
{
    TraceTag((tagContainerSite, "CContainerSite::ReleaseDC"));

    HRESULT hr;
    HWND    hWnd;

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    hr = GetWindow(&hWnd);
    Assert(SUCCEEDED(hr) && (hWnd != NULL));
    
    Assert(hDC != NULL);

    ::ReleaseDC(hWnd, hDC);

    return S_OK;
} //lint !e550

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRect, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

STDMETHODIMP
CContainerSite::InvalidateRect(const RECT *prc, BOOL fErase)
{
    if (m_fIgnoreInvalidate)
    {
        // This is a workaround for the WMP.  We have to ignore the Invalidate that is 
        // generated in the SetObjectRect in the Draw call otherwise will will not render correctly
        return S_OK;
    }
    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(%d, %d, %d, %d)", prc->left, prc->top, prc->right, prc->bottom));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // reach back to the time element and invalidate
    Assert(m_pHost != NULL);
    // TODO: The below was changed to NULL from for use with the IHTMLPainter interfaces
    return m_pHost->Invalidate(NULL);//prc);
} // InvalidateRect

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRgn, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

STDMETHODIMP
CContainerSite::InvalidateRgn(HRGN hRGN, BOOL fErase)
{
    TraceTag((tagContainerSite, "CContainerSite::InvalidateRgn"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    HRESULT hr = S_OK;
    return hr;
} // InvalidateRgn

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ScrollRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::ScrollRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // ScrollRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        AdjustRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::AdjustRect(RECT *prc)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::AdjustRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // AdjustRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDefWindowMessage, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDefWindowMessage"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // Return that the message was not handled.

    // release focus for the document.

    switch (msg)
    {
// ISSUE: we don't handle focus right now
//        case WM_SETFOCUS:
//            return SetFocus(true);
//        case WM_KILLFOCUS:
//            return SetFocus(false);

        case WM_MOUSEMOVE:
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            return S_OK;

        case WM_SETCURSOR:
        case WM_CONTEXTMENU:
        case WM_HELP:
            return S_FALSE;

        case WM_MOUSEHOVER:
        case WM_MOUSELEAVE:
        case 0x8004: //  WM_MOUSEOVER
            return S_OK;

        case WM_CAPTURECHANGED:
            return S_OK;
        default:
            break;
    }

    return S_FALSE;
} // OnDefWindowMessage

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDataChange, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void)
CContainerSite::OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDataChange"));
} // OnDataChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewChange, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnViewChange(DWORD dwAspect, LONG lindex)
{    
    TraceTag((tagContainerSite, "CContainerSite::OnViewChange"));
} // OnViewChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnRename, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnRename(IMoniker *pmk)
{
    TraceTag((tagContainerSite, "CContainerSite::OnRename"));
} // OnRename

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnSave, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnSave(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnSave"));
} // OnSave

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnClose, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnClose(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnClose"));
} // OnClose

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewStatusChange, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnViewStatusChange(DWORD dwViewStatus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnViewStatusChange"));
} // OnViewStatusChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

STDMETHODIMP
CContainerSite::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

STDMETHODIMP
CContainerSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

STDMETHODIMP
CContainerSite::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagContainerSite, "CContainerSite::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

STDMETHODIMP
CContainerSite::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
              DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{

#ifdef DEBUG
    // Here the key to wFlags:
    //
    // #define DISPATCH_METHOD         0x1
    // #define DISPATCH_PROPERTYGET    0x2
    // #define DISPATCH_PROPERTYPUT    0x4
    // #define DISPATCH_PROPERTYPUTREF 0x8

    switch (dispIDMember)
    {
        case DISPID_AMBIENT_USERMODE:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(DISPID_AMBIENT_USERMODE, %04X)", wFlags));
            break;

        default:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(%08X, %04X)", dispIDMember, wFlags));
            break;
    }
#endif

    return E_NOTIMPL;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        QueryStatus, IOleCommandTarget
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{ 
    TraceTag((tagContainerSite, "CContainerSite::QueryStatus"));
    return E_NOTIMPL;
} // QueryStatus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Exec, IOleCommandTarget
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{ 
    TraceTag((tagContainerSite, "CContainerSite::Exec"));
    return E_NOTIMPL;
} // Exec
//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        GetBorder, IOleUIWindow
// Abstract:        Returns the rectangle in which the 
//                  container is willing to negotiate about an 
//                  object's adornments. 
//************************************************************

STDMETHODIMP
CContainerSite::GetBorder(LPRECT prcBorder)
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetBorder"));
    return NOERROR; 
} // GetBorder

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        RequestBorderSpace, IOleUIWindow
// Abstract:        Asks the container if it can surrender the
//                  amount of space in pBW that the object 
//                  would like for it's adornments.  The 
//                  container does nothing but validate the 
//                  spaces on this call. 
//************************************************************

STDMETHODIMP
CContainerSite::RequestBorderSpace(LPCBORDERWIDTHS pBW)
{ 
    TraceTag((tagContainerSite, "CContainerSite::RequestBorderSpace"));
    return NOERROR; 
} // RequestBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetBorderSpace, IOleUIWindow
// Abstract:        Called when the object now officially 
//                  requests that the container surrender 
//                  border space it previously allowed in 
//                  RequestBorderSpace.  The container should 
//                  resize windows appropriately to surrender 
//                  this space. 
//************************************************************

STDMETHODIMP
CContainerSite::SetBorderSpace(LPCBORDERWIDTHS pBW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetBorderSpace"));
    return NOERROR; 
} // SetBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetActiveObject, IOleUIWindow
// Abstract:        Provides the container with the object's 
//                  IOleInPlaceActiveObject pointer and a name 
//                  of the object to show in the container's 
//                  caption. 
//************************************************************

STDMETHODIMP
CContainerSite::SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetActiveObject(%08X, %08X)", pIIPActiveObj, pszObj));
    return S_OK; 
} // SetActiveObject

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        InsertMenus, IOleInPlaceFrame
// Abstract:        Instructs the container to place its 
//                  in-place menu items where necessary in the 
//                  given menu and to fill in elements 0, 2, 
//                  and 4 of the OLEMENUGROUPWIDTHS array to 
//                  indicate how many top-level items are in 
//                  each group. 
//************************************************************

STDMETHODIMP
CContainerSite::InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::InsertMenus"));
    return NOERROR; 
} // InsertMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetMenu, IOleInPlaceFrame
// Abstract:        Instructs the container to replace 
//                  whatever menu it's currently using with 
//                  the given menu and to call 
//                  OleSetMenuDescritor so OLE knows to whom 
//                  to dispatch messages. 
//************************************************************

STDMETHODIMP
CContainerSite::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetMenu"));
    return NOERROR; 
} // SetMenu

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RemoveMenus, IOleInPlaceFrame
// Abstract:        Asks the container to remove any menus it 
//                  put into hMenu in InsertMenus.
//************************************************************

STDMETHODIMP
CContainerSite::RemoveMenus(HMENU hMenu) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::RemoveMenus"));
    return NOERROR; 
} // RemoveMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetStatusText, IOleInPlaceFrame
// Abstract:        Asks the container to place some text in a 
//                  status line, if one exists.  If the 
//                  container does not have a status line it 
//                  should return E_FAIL here in which case 
//                  the object could display its own. 
//************************************************************

STDMETHODIMP
CContainerSite::SetStatusText(LPCOLESTR pszText) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetStatusText"));
    return E_FAIL; 
} // SetStatusText

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        EnableModeless, IOleInPlaceFrame
// Abstract:        Instructs the container to show or hide 
//                  any modeless popup windows that it may be 
//                  using. 
//************************************************************

STDMETHODIMP
CContainerSite::EnableModeless(BOOL fEnable) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::EnableModeless - %s", fEnable ? "TRUE" : "FALSE"));
    return NOERROR; 
} // EnableModeless

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        TranslateAccelerator, IOleInPlaceFrame
// Abstract:        When dealing with an in-place object from 
//                  an EXE server, this is called to give the 
//                  container a chance to process accelerators 
//                  after the server has looked at the message. 
//************************************************************

STDMETHODIMP
CContainerSite::TranslateAccelerator(LPMSG pMSG, WORD wID) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    return S_FALSE; 
} // TranslateAccelerator

HRESULT 
CContainerSite::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;

    CComPtr<IPersistPropertyBag2> spPropBag;
    
    hr = m_pObj->QueryInterface(IID_TO_PPV(IPersistPropertyBag2, &spPropBag));
    if (SUCCEEDED(hr))
    {
        hr = THR(spPropBag->Save(pPropBag, fClearDirty, fSaveAllProperties));
        if (FAILED(hr))
        {
            goto done;
        }
    }
done:
    return hr;
}

//************************************************************
// End of file
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\containerobj.h ===
#ifndef _CONTAINEROBJ_H_
#define _CONTAINEROBJ_H_

//************************************************************
//
// FileName:        containerobj.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of CContainerObj
//
//************************************************************


#include "mpctnsite.h"
#include "playlist.h"

interface ITIMEMediaPlayerOld;

#define mpShowFilename      0
#define mpShowTitle         1
#define mpShowAuthor        2
#define mpShowCopyright     3
#define mpShowRating        4
#define mpShowDescription   5
#define mpShowLogoIcon      6
#define mpClipFilename      7
#define mpClipTitle         8
#define mpClipAuthor        9
#define mpClipCopyright     10
#define mpClipRating        11
#define mpClipDescription   12
#define mpClipLogoIcon      13
#define mpBannerImage       14
#define mpBannerMoreInfo    15
#define mpWatermark         16

enum PlayerState;

// forward declaration
class CMPContainerSite;
class CTIMEPlayer;

class CContainerObj
    : public CMPContainerSiteHost
{
  public: 
    CContainerObj();
    virtual ~CContainerObj();
    HRESULT Init(REFCLSID clsid, 
                 CTIMEPlayer *pPlayer,
                 IPropertyBag2 * pPropBag,
                 IErrorLog * pErrorLog);
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // CContainerSiteHost
    virtual IHTMLElement * GetElement();
    virtual IServiceProvider * GetServiceProvider();

    virtual HRESULT Invalidate(LPCRECT prc);

    virtual HRESULT GetContainerSize(LPRECT prcPos);
    virtual HRESULT SetContainerSize(LPCRECT prcPos);
    
    virtual HRESULT ProcessEvent(DISPID dispid,
                                 long lCount, 
                                 VARIANT varParams[]);

    virtual HRESULT GetExtendedControl(IDispatch **ppDisp);

    // CMPContainerSiteHost
    virtual HRESULT NegotiateSize(RECT &nativeSize,
                                  RECT &finalSize,
                                  bool &fIsNative);

    // methods for hosting site
    HRESULT Start();
    HRESULT Stop();
    HRESULT Pause();
    HRESULT Resume();

    HRESULT Render(HDC hdc, RECT *prc);
    HRESULT SetMediaSrc(WCHAR * pwszSrc);
    HRESULT SetRepeat(long lRepeat);
    HRESULT SetSize(RECT *prect);

    HRESULT GetControlDispatch(IDispatch **ppDisp);

    HRESULT clipBegin(VARIANT var);
    HRESULT clipEnd(VARIANT var);

    HRESULT Seek(double dblTime);
    double GetCurrentTime();
    HRESULT GetMediaLength(double &dblLength);
    HRESULT GetCurrClipLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    HRESULT CanSeekToMarkers(bool &fcanSeek);
    HRESULT IsBroadcast(bool &fcanSeek);
    HRESULT BufferingTime(double &dblBuffTime);
    HRESULT BufferingProgress(double &dblBuffTime);
    HRESULT BufferingCount(long &dblBuffTime);
    HRESULT HasMedia(bool &fhasMedia);
    bool UsingWMP() {return m_fUsingWMP; }

    HRESULT GetNaturalWidth(long *width);
    HRESULT GetNaturalHeight(long *height);
        
    HRESULT setActiveTrackOnLoad(long index);
    void SetDuration();
    HRESULT SetVisibility(bool fVisible);
    bool UsingPlaylist();
    
    HRESULT GetMediaPlayerInfo(LPWSTR *pwstr,  int mpInfoToReceive);
    void SetMediaInfo(CPlayItem *pPlayItem);

    HRESULT GetSourceLink(LPWSTR *pwstr);

    // persistance
    HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //state control
    void ReadyStateNotify(LPWSTR szReadyState);

    CTIMEPlayer * GetPlayer() { return m_pPlayer; }
    ITIMEMediaPlayerOld *GetProxyPlayer() { return m_pProxyPlayer; }

    PlayerState GetState();

    bool IsActive() const { return m_bActive; }

  private:
    bool isFileNameAsfExt(WCHAR * pwszSrc);
    void UpdateNaturalDur(bool bUpdatePlaylist);
    
    void SetMediaReadyFlag() { m_fMediaReady = true;}
    bool GetMediaReadyFlag() const { return m_fMediaReady;}
    HRESULT SetPosition(double dblLength);

    HRESULT PutSrc(WCHAR *pwszSrc);
        
  private:
    LONG                m_cRef;
    DAComPtr<CMPContainerSite> m_pSite;
    bool                m_fStarted;
    bool                m_fUsingWMP;
    bool                m_bPauseOnPlay;
    bool                m_bFirstOnMediaReady;
    bool                m_bSeekOnPlay;
    bool                m_bEndOnPlay;
    double              m_dblSeekTime;
    bool                m_bIsAsfFile;
    long                m_lActiveLoadedTrack;
    bool                m_setVisible;
    LPOLESTR            m_origVisibility;
    CTIMEPlayer        *m_pPlayer;
    bool                m_bMMSProtocol;
    bool                m_bStartOnLoad;
    bool                m_fMediaReady;
    bool                m_fLoaded;

    DAComPtr<ITIMEMediaPlayerOld>    m_pProxyPlayer;
    bool                             m_bActive;
}; // CContainerObj

#endif //_CONTAINEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\decibels.cpp ===
//--------------------------------------------------------------------------;
//
//  File: decibels.cpp
//
//  Copyright (c) 1995 - 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	SteveDav    plagiarised from Direct Sound
//
//--------------------------------------------------------------------------;

#include "headers.h"

#include "decibels.h"

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
const WORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    0xFFFF, // 0dB
    };


// The two routines that follow convert from a linear AmpFactor in the
// range 65535/65536 to 1/65536 to a decibel range of -100.00 to -0.01
// and vice versa.
//
// The amp factors are expressed in parts per 65536 as a 16 bit numerator,
// i.e. actual amplification is (ampfactor)/65536.
//
// The decibels are expressed as parts per 100.  i.e. -100 means -1dB.
//
// Note that although a decibel is formally 10 * log10(x), the AmpFactor
// refers to voltages and the dB to powers, and power = v**2/r
// so the rule is dB = 20*log10(x)
//
// If you change one routine you will almost certainly have to change
// the other.  In an ideal world the routines would be inverses
// meaning that the following is true
//
// 	AmpFactor == DBToAmpFactor(AmpFactorToDB(AmpFactor))
//
// HOWEVER many iterations are made through the routines. The
// secondary objective is to minimise the drift such that
// successive iterations do not stray too far from the starting
// point.
//
// This is clearly impossible because the quantisations are
// quite different.  10**-.005 = 1.0115 or 65536->64786, so if
// we start from (say) 65000 then something nasty must happen.
// likewise the difference between an amp factor of 1/65536 and
// 2/65536 is about 6dB - so much for the nearest hundredth!
//
// From here on we'll call them DB (even though that should be a
// dekabell (10 bells) to avoid confusion with hungarian.
//

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB-5)/10;		    // scaled to 1/10th dB units

    if (lDB > 0)    lDB = 0;        // upper boundary
    if (lDB < -964) return 0;  	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index
//    ASSERT(lDB >= 0);
//    ASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));

    dwFactor = (DWORD) tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

LONG AmpFactorToDB( DWORD dwFactor )
{

    LONG    lDB;

    int	    iMin;
    int	    iMax;
    int     iMiddle;

    iMin = 0;

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;

    //
    // Binary search through the table of AmpFactors.
    //
    // iMin and iMax specify the range in which the result can be found this
    // is initially the whole table.
    //
    // In each interation we reduce the range by half.
    //
    // Loop variant: iMax - iMin, which decreases in each iteration.
    // Invariant:  iMin <= iMax.
    // Exit condition: iMin = iMax.
    //
    while (iMin != iMax) {
//        ASSERT(iMin < iMax);

        iMiddle = (iMin + iMax) / 2;

        // Chose the half which includes dwFactor.
        if (dwFactor <= tblDBTenthsToAmpFactor[iMiddle])
            iMax = iMiddle;       // iMin does not change
        else
            iMin = iMiddle + 1;   // iMax does not change
    }

    lDB = (iMin - 964) * 10;

    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\codec.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: codec.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "codec.h"

DeclareTag(tagCodec, "TIME: Media", "CDownloadCallback methods");

/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::CDownloadCallback()
: m_hrBinding(S_ASYNCHRONOUS),
  m_ulProgress(0),
  m_ulProgressMax(0),
  m_hwnd(NULL)
{
    m_evFinished = CreateEvent(NULL, FALSE, FALSE, NULL);
}


STDMETHODIMP
CDownloadCallback::Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::Authenticate()",
              this));

    *phwnd = m_hwnd; // !!! is this right?
    *pszUsername = NULL;
    *pszPassword = NULL;
    return S_OK;
}

// IWindowForBindingUI methods
STDMETHODIMP
CDownloadCallback:: GetWindow(REFGUID rguidReason, HWND *phwnd)
{
    *phwnd = m_hwnd; // !!! is this right?

#ifdef DEBUG
    WCHAR achguid[50];
    StringFromGUID2(rguidReason, achguid, 50);
    
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::GetWindow(): (%ls) returned %x",
              this,
              achguid,
              *phwnd));
#endif
    
    return S_OK;
}

STDMETHODIMP
CDownloadCallback::OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination,
                                        LPCWSTR szSource, DWORD dwReserved)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnCodeInstallProblem(%d, %ls, %ls)",
              this,
              ulStatusCode,
              szDestination,
              szSource));

    return S_OK;   // !!!!!!!@!!!!!!!!!!!
}


/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::~CDownloadCallback()
{
    Assert(!m_spBinding);

    if (m_evFinished)
    {
        // Set it first to make sure we break any loops
        SetEvent(m_evFinished);
        CloseHandle(m_evFinished);
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnStartBinding(%x, %p)",
              this,
              grfBSCOption,
              pbinding));

    m_spBinding = pbinding;

    return S_OK;
}  // CDownloadCallback::OnStartBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}  // CDownloadCallback::GetPriority

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CDownloadCallback::OnLowResource

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                              ULONG ulStatusCode, LPCWSTR szStatusText)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnProgress(%d, %d, %d, %ls)",
              this,
              ulProgress,
              ulProgressMax,
              ulStatusCode,
              szStatusText));

    m_ulProgress = ulProgress;
    m_ulProgressMax = ulProgressMax;

#if 0
    if (ulStatusCode >= BINDSTATUS_FINDINGRESOURCE &&
        ulStatusCode <= BINDSTATUS_SENDINGREQUEST)
    {
        m_pDXMP->SetStatusMessage(NULL, IDS_BINDSTATUS + ulStatusCode,
                                  szStatusText ? szStatusText : L"",
                                  ulProgress, ulProgressMax);
    }
#endif
    
    return S_OK;
}  // CDownloadCallback::OnProgress

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnStopBinding(%hr, %ls)",
              this,
              hrStatus,
              pszError));

    // should this be a SetEvent?
    m_hrBinding = hrStatus;

    if (FAILED(hrStatus))
    {
        // !!! send some notification that the download failed....
    }

    if (m_evFinished)
    {
        SetEvent(m_evFinished);
    }

    m_spBinding.Release();

    return S_OK;
}  // CDownloadCallback::OnStopBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::GetBindInfo()",
              this));

    // !!! are these the right flags?

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NEEDFILE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CDownloadCallback::GetBindInfo

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
    return S_OK;
}  // CDownloadCallback::OnDataAvailable

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnObjectAvailable()",
              this));

    // should only be used in BindToObject case, which we don't use?
    m_pUnk = punk;

    return S_OK;
}  // CDownloadCallback::OnObjectAvailable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\containerobj.cpp ===
//************************************************************
//
// FileName:        containerobj.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container object implementation.
//
//************************************************************

#include "headers.h"
#include "containerobj.h"
#include "player.h"
#include "playlist.h"
#include "util.h"
#include "eventmgr.h"
#include "mediaprivate.h"

DeclareTag(tagContainerObj, "TIME: Players", "CContainerObj methods")

#define NOTRACKSELECTED -1

const LPOLESTR cszVisible = L"visible";
const LPOLESTR cszHidden = L"hidden";


//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerObj::CContainerObj() :
    m_cRef(0),
    m_pSite(NULL),
    m_fStarted(false),
    m_fUsingWMP(false),
    m_bPauseOnPlay(false),
    m_bSeekOnPlay(false),
    m_bEndOnPlay(false),
    m_dblSeekTime(0),
    m_bFirstOnMediaReady(true),
    m_bIsAsfFile(false),
    m_lActiveLoadedTrack(NOTRACKSELECTED),
    m_setVisible(false),
    m_origVisibility(NULL),
    m_pPlayer(NULL),
    m_bMMSProtocol(false),
    m_fMediaReady(false),
    m_bStartOnLoad(false),
    m_bActive(false),
    m_fLoaded(false)
{
    TraceTag((tagContainerObj, "CContainerObj::CContainerObj"));
} // CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerObj::~CContainerObj()
{
    TraceTag((tagContainerObj, "CContainerObj::~CContainerObj"));

    DetachFromHostElement();

    if (m_origVisibility)
    {
        delete [] m_origVisibility;
        m_origVisibility = NULL;
    }
} // ~CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Init
//************************************************************

HRESULT
CContainerObj::Init(REFCLSID clsid, CTIMEPlayer *pPlayer, IPropertyBag2 * pPropBag, IErrorLog * pErrorLog)
{
    TraceTag((tagContainerObj, "CContainerObj::Init"));

    HRESULT hr;

    CComPtr<IUnknown> pObj;
    Assert(pPlayer != NULL);

    m_pPlayer = pPlayer;

    hr = THR(::CreateObject(clsid,
                            IID_IUnknown,
                            (void **)&pObj));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // before we try anything, see if it supports ITIMEMediaPlayer
    hr = THR(pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayerOld, &m_pProxyPlayer)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pProxyPlayer->Init());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CreateMPContainerSite(*this,
                                   pObj,
                                   pPropBag,
                                   pErrorLog,
                                   true,
                                   &m_pSite));
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsEqualCLSID(clsid, __uuidof(MediaPlayerCLSID)))
    {
        m_fUsingWMP = true;
    }

  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }
    
    return hr;
} // Init

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        DetachFromHostElement
//************************************************************
HRESULT
CContainerObj::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagContainerObj, "CContainerObj::DetachFromHostElement(%lx)", this));

    Stop();
    
    m_pPlayer = NULL;

    // Protect against reentrancy
    if (m_pProxyPlayer)
    {
        DAComPtr<ITIMEMediaPlayerOld> pTmp = m_pProxyPlayer;
        
        m_pProxyPlayer.Release();

        pTmp->end();
    }
    
    if (m_pSite)
    {
        DAComPtr<CMPContainerSite> pTmp = m_pSite;
        
        m_pSite.Release();

        pTmp->Detach();
    }

    return hr;
} // DetachFromHostElement

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
} // Release

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Start
//************************************************************

HRESULT
CContainerObj::Start()
{
    TraceTag((tagContainerObj, "CContainerObj::Start"));
    HRESULT hr;
    
    if (m_bFirstOnMediaReady)
    {
        if (!m_fLoaded)
        {
            ReadyStateNotify(L"OnLoad");
        }
        m_bStartOnLoad = true;
        m_bPauseOnPlay = false;
        hr = S_OK;
        goto done;
    }

    if (!m_pPlayer)
    {
        hr = E_FAIL;
        goto done;
    }

    IGNORE_HR(m_pProxyPlayer->end());

    if (!m_pSite)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pSite->Activate());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_pProxyPlayer->begin());
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_fStarted = true;

    if (m_pPlayer != NULL)
    {
        m_pPlayer->ClearHoldingFlag();
    }

  done:
    if (FAILED(hr))
    {
        Stop();
    }
    
    return hr;
} // Start

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Pause
//************************************************************

HRESULT
CContainerObj::Pause()
{
    TraceTag((tagContainerObj, "CContainerObj::Pause"));
    HRESULT hr;

    hr  = m_pProxyPlayer->pause();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Pause - pause() failed"));
        if (m_pPlayer->IsActive())
        {
            m_bPauseOnPlay = true;
        }
    }
    return hr;
} // Pause

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Stop
//************************************************************

HRESULT
CContainerObj::Stop()
{
    TraceTag((tagContainerObj, "CContainerObj::Stop(%lx)", this));
    HRESULT hr = S_OK;

        
    if (m_bFirstOnMediaReady)
    {
        m_bStartOnLoad = false;
        m_bEndOnPlay = true;
    }
    if (m_fStarted)
    {    
        // This protects against reentrancy
        m_fStarted = false;

        if (m_pProxyPlayer)
        {
            hr = THR(m_pProxyPlayer->pause());
            if (FAILED(hr))
            {
                goto done;
            }
        }

        if (m_pSite)
        {
            hr = THR(m_pSite->Deactivate());
            if (S_FALSE == hr)
            {
                // when we get the onmediacomplete, we must call end
                m_bEndOnPlay = true;
                hr = S_OK;
            }
            
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
  done:
    return hr;
} // Stop

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Resume
//************************************************************

HRESULT
CContainerObj::Resume()
{
    TraceTag((tagContainerObj, "CContainerObj::Resume"));
    HRESULT hr;
    
    hr  = m_pProxyPlayer->resume();
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::Resume - resume() failed"));
    }
    return hr;
} // Resume


HRESULT CContainerObj::SetVisibility(bool fVisible)
{
    IHTMLElement *pEle; //this is a weak reference
    CComPtr <IHTMLStyle> pStyle;
    BSTR bstrVis = NULL;
    HRESULT hr;

    if (UsingPlaylist() == false)
    {
        hr = S_OK;
        goto done;
    }

    //need to hide the element here.
    pEle = m_pPlayer->GetElement();
    
    hr = THR(pEle->get_style(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    if (fVisible == false)
    {
        BSTR bstrOrigVis;
        //need to cache the old visiblity value here
        if (m_origVisibility == NULL)
        {
            hr = THR(pStyle->get_visibility(&bstrOrigVis));
            if (FAILED(hr) || bstrOrigVis == NULL)
            {
                m_origVisibility = CopyString(cszVisible);
            }
            else
            {
                m_origVisibility = CopyString(bstrOrigVis);
                SysFreeString(bstrOrigVis);
            }
        }

        bstrVis = SysAllocString(cszHidden);
        m_setVisible = true;
    }
    else
    {
        if (m_origVisibility)
        {
            bstrVis = SysAllocString(m_origVisibility);
            delete [] m_origVisibility;
            m_origVisibility = NULL;
        }
        else
        {
            bstrVis = SysAllocString(cszVisible);
        }
        m_setVisible = false;
    }

    if (bstrVis == NULL)
    {
        goto done;
    }
    
    hr = THR(pStyle->put_visibility(bstrVis));
    SysFreeString(bstrVis);
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return S_OK;

}

HRESULT CContainerObj::setActiveTrackOnLoad(long index)
{
 
    m_lActiveLoadedTrack = index; 
    m_bFirstOnMediaReady = true;
    
    //SetVisibility(false);
    return S_OK;
}

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Render(HDC hdc, RECT *prc)
{
    HRESULT hr = S_OK;
    bool bHasMedia = false;

    if (prc == NULL)
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, NULL)"));
    else
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, (%d, %d, %d, %d))", prc->left, prc->right, prc->top, prc->bottom));

    HasMedia(bHasMedia);
    if (m_pSite && bHasMedia)
    {
        hr = m_pSite->Draw(hdc, prc);
    }
    
    return hr;
} // Render

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetMediaSrc
//************************************************************

HRESULT
CContainerObj::SetMediaSrc(WCHAR *pwszSrc)
{
    TraceTag((tagContainerObj, "CContainerObj::SetMediaSrc (%S)", pwszSrc));
    HRESULT hr;

    isFileNameAsfExt(pwszSrc);

    m_pProxyPlayer->end();

    hr  = PutSrc(pwszSrc);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::SetMediaSrc - SetSrc() failed"));
    }

    m_bFirstOnMediaReady = true;

    return hr;
} // SetMediaSrc


// the following is a helper function used because the CanSeek method on WMP only
// works on ASF fles.
bool
CContainerObj::isFileNameAsfExt(WCHAR *pwszSrc)
{
    WCHAR *pext;
    
    m_bIsAsfFile = false;
    m_bMMSProtocol = false;

    if (NULL != pwszSrc)
    {
        if(wcslen(pwszSrc) > 4)
        {
            pext = pwszSrc + wcslen(pwszSrc) - 4;
            if(StrCmpIW(pext, L".asf") == 0)
            {
                m_bIsAsfFile = true;
            }

            if (StrCmpNIW(pwszSrc, L"mms:", 4) == 0)
            {
                m_bMMSProtocol = true;
            }
        }
    }

    return m_bIsAsfFile;
}


//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetRepeat
//************************************************************

HRESULT
CContainerObj::SetRepeat(long lRepeat)
{
    TraceTag((tagContainerObj, "CContainerObj::SetRepeat (%d)", lRepeat));
    HRESULT hr;
    
    if (lRepeat == 1)
       return S_OK;
    
    hr = THR(m_pProxyPlayer->put_repeat(lRepeat));
    if (FAILED(hr))
    {    
    }
    return hr;
} // SetRepeat

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipBegin
//************************************************************

HRESULT
CContainerObj::clipBegin(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipBegin"));
    HRESULT hr = S_OK;
    CComVariant vClip = var;
    
    if (var.vt == VT_EMPTY)
    {
        goto done;
    }

    if (vClip.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&vClip, &vClip, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }
            
    hr  = THR(m_pProxyPlayer->clipBegin(vClip));
    if (FAILED(hr))
    {    
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
} // ClipBegin

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipEnd
//************************************************************

HRESULT
CContainerObj::clipEnd(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipEnd"));
    HRESULT hr = S_OK;


    CComVariant vClip = var;
    
    if (var.vt == VT_EMPTY)
    {
        goto done;
    }

    if (vClip.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&vClip, &vClip, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }
            
    hr  = m_pProxyPlayer->clipEnd(vClip);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::clipEnd - clipEnd() failed"));
    }

    hr = S_OK;
  done:
    return hr;

} // ClipEnd

//************************************************************
// Author:          twillie
// Created:         10/26/98
// Abstract:        GetControlDispatch
//************************************************************

HRESULT
CContainerObj::GetControlDispatch(IDispatch **ppDisp)
{
    HRESULT hr;
    TraceTag((tagContainerObj, "CContainerObj::GetControlDispatch"));

    if(!m_pProxyPlayer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CMPContainerSite::GetControlDispatch - QI failed for IDispatch"));
    }
done:
    return hr;
} // GetControlDispatch

void 
CContainerObj::SetMediaInfo(CPlayItem *pPlayItem)
{
    HRESULT hr;
    LPWSTR pwzStr = NULL;

    if (pPlayItem == NULL)
    {
        goto done;
    }

    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipTitle));
    if (hr == S_OK)
    {
        pPlayItem->PutTitle(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipAuthor));
    if (hr == S_OK)
    {
        pPlayItem->PutAuthor(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipCopyright));
    if (hr == S_OK)
    {
        pPlayItem->PutCopyright(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipRating));
    if (hr == S_OK)
    {
        pPlayItem->PutRating(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipDescription));
    if (hr == S_OK)
    {
        pPlayItem->PutAbstract(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipFilename));
    if (hr == S_OK)
    {
        // 105410: do the best we can when no clip filename is available
        if (NULL == pwzStr)
        {
            IGNORE_HR(GetSourceLink(&pwzStr));
        }

        pPlayItem->PutSrc(pwzStr);
        delete [] pwzStr;
    }
  done:

    return;
}

HRESULT
CContainerObj::GetSourceLink(LPWSTR *pwstr)
{
    CComPtr<IDispatch>  pdisp;
    HRESULT             hr = E_FAIL;
    CComVariant         svarOut;
      
    *pwstr = NULL;
    
    hr = GetControlDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::GetProperty(pdisp, L"SourceLink", &svarOut));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::VariantChangeTypeEx(&svarOut, &svarOut, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        goto done;
    }

    *pwstr = CopyString(V_BSTR(&svarOut));

    hr = S_OK;
  done:
    return hr;
}


HRESULT
CContainerObj::GetMediaPlayerInfo(LPWSTR *pwstr,  int mpInfoToReceive)
{
    HRESULT             hr = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName = L"GetMediaInfoString";
    CComVariant         varResult;
    VARIANT             rgvarg[1];

    *pwstr = NULL;
    
    hr = GetControlDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    rgvarg[0].vt    = VT_I4;
    rgvarg[0].lVal  = mpInfoToReceive;

    DISPPARAMS dp;
    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if((*varResult.bstrVal) != NULL)
    {
        *pwstr = CopyString(V_BSTR(&varResult));
    }
    
    hr = S_OK;
  done:
    return hr;
} 


bool 
CContainerObj::UsingPlaylist()
{
    if (!m_pPlayer)
    {
        return false;
    }

    if(NULL == m_pPlayer->GetPlayList())
    {
        return false;
    }

    return (m_pPlayer->GetPlayList()->GetLength() > 1);
}

//sets the duration of the currently playing track in the playlist
void  
CContainerObj::SetDuration()
{
    double mediaLength;
    HRESULT hr;
    double duration = 0;
    CPlayList * pPlayList = NULL;
    CPlayItem * pPlayItem = NULL;
    
    if (m_pPlayer == NULL)
    {
        goto done;
    }
    
    pPlayList = m_pPlayer->GetPlayList();
    pPlayItem = pPlayList->GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        goto done;
    }
    
    duration = pPlayItem->GetDur();

    //if it is not set, then query the media player for it.
    if (duration == valueNotSet)
    {
        hr = GetCurrClipLength(mediaLength);
        if(FAILED(hr))
        {
            goto done;
        }   

        pPlayItem->PutDur(mediaLength);
    }

  done:
    return;
}

#define DISPID_DURATION 1003

#define DISPID_ISDURATIONVALID 1059
#define DISPID_CANSEEK 1012
#define DISPID_CANSEEKTOMARKERS 1047
#define DISPID_ISBROADCAST 1058
#define DISPID_BUFFERINGPROGRESS 1080
#define DISPID_BUFFERINGTIME 1070
#define DISPID_BUFFERINGCOUNT 1043

HRESULT
CContainerObj::BufferingTime(double &dblBuffTime)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vBuffTime;
    
    if (!m_pProxyPlayer)
    {
        dblBuffTime = 0.0;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_BUFFERINGTIME,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vBuffTime, NULL, NULL);
    if (FAILED(hr))
    {
        dblBuffTime = 0.0;
        goto done;
    }

    if(vBuffTime.vt != VT_R8)
    {
        hr = VariantChangeTypeEx(&vBuffTime, &vBuffTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if(FAILED(hr))
        {
            dblBuffTime = 0;
            goto done;
        }
    }

    dblBuffTime = vBuffTime.dblVal;

    hr = S_OK;
  done:
    return hr;

}

HRESULT
CContainerObj::BufferingProgress(double &dblBuffTime)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vBuffTime;
    
    if (!m_pProxyPlayer)
    {
        dblBuffTime = 0.0;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_BUFFERINGPROGRESS,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vBuffTime, NULL, NULL);
    if (FAILED(hr))
    {
        dblBuffTime = 0.0;
        goto done;
    }

    if(vBuffTime.vt != VT_I4)
    {
        hr = VariantChangeTypeEx(&vBuffTime, &vBuffTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if(FAILED(hr))
        {
            dblBuffTime = 0;
            goto done;
        }
    }

    dblBuffTime = vBuffTime.lVal;

    hr = S_OK;
  done:
    return hr;

}


HRESULT
CContainerObj::BufferingCount(long &lBuffCount)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vBuffTime;
    
    if (!m_pProxyPlayer)
    {
        lBuffCount = 0;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_BUFFERINGCOUNT,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vBuffTime, NULL, NULL);
    if (FAILED(hr))
    {
        lBuffCount;
        goto done;
    }

    if(vBuffTime.vt != VT_I4)
    {
        hr = VariantChangeTypeEx(&vBuffTime, &vBuffTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if(FAILED(hr))
        {
            lBuffCount = 0;
            goto done;
        }
    }

    lBuffCount = vBuffTime.lVal;

    hr = S_OK;
  done:
    return hr;

}

HRESULT
CContainerObj::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    if(m_bIsAsfFile)
    {
        if (!m_bMMSProtocol || !UsingWMP()) //if this is not the WMP or this is not the MMS:// protocol call canseek.
        {
            DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
            CComPtr<IDispatch> pdisp;
            CComVariant vIsValid;
            hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
            if (FAILED(hr))
            {
                fcanSeek = false;
                goto done;
            }

            hr = pdisp->Invoke(DISPID_CANSEEK,
                               IID_NULL,
                               LCID_SCRIPTING,
                               DISPATCH_PROPERTYGET,
                               &dispparamsNoArgs,
                               &vIsValid, NULL, NULL);
            if (FAILED(hr))
            {
                fcanSeek = false;
                goto done;
            }
            if (vIsValid.boolVal)
            {
                fcanSeek = true;
            }
            else
            {
                fcanSeek = false;
            }
        }
        else // if this is both the WMP and the MMS: protocol, canseek should return false.  The WMP does not 
        {    // correctly identify that it cannot seek asf files using this protocol.
            fcanSeek = false;
        }

        if(FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        fcanSeek = true;
    }
  done:
    return hr;

}

HRESULT
CContainerObj::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_CANSEEKTOMARKERS,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }

    if(vIsValid.vt != VT_BOOL)
    {
        bcanSeekToM = false; //I got wrong type.
        goto done;
    }

    if (vIsValid.boolVal == VARIANT_FALSE)
    {
        bcanSeekToM = false;
    }
    else
    {
        bcanSeekToM = true;
    }

    hr = S_OK;
  done:
    return hr;

}


HRESULT
CContainerObj::IsBroadcast(bool &bisBroadcast)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;
    
    if (!m_pProxyPlayer)
    {
        bisBroadcast = false;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_ISBROADCAST,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        bisBroadcast = false;
        goto done;
    }

    if(vIsValid.vt != VT_BOOL)
    {
        bisBroadcast = false; //I got wrong type.
        goto done;
    }

    if (vIsValid.boolVal == VARIANT_FALSE)
    {
        bisBroadcast = false;
    }
    else
    {
        bisBroadcast = true;
    }

    hr = S_OK;
  done:
    return hr;

}

HRESULT
CContainerObj::HasMedia(bool &fhasMedia)
{
    // m_bFirstOnMediaReady is set to flase when the media has finished loading
    // and is ready to play.
    if(m_bFirstOnMediaReady)
    {
        fhasMedia = false;
    }
    else
    {
        fhasMedia = true;
    }
    return S_OK;
}

HRESULT
CContainerObj::Seek(double dblTime)
{
    HRESULT hr = S_OK;
    bool fcanSeek;
    double dblLength = HUGE_VAL;

    if (m_bFirstOnMediaReady)
    {
        // we haven't started yet, wait on the seek
        m_bSeekOnPlay = true;
        m_dblSeekTime = dblTime;
    }
    else if (m_pSite)
    {
        hr = CanSeek(fcanSeek);
        if(FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }

        if(fcanSeek)
        {
            //
            // ISSUE: dilipk: does this handle playlists? GetMediaLength returns infinite for playlists.
            //

            // hack to get WMP playing  if we have played in the element beyond the
            // natural duration of the media i.e. dur is set to a value greater than 
            // the media length. (dorinung)
            if(SUCCEEDED(m_pPlayer->GetEffectiveLength(dblLength)))
            {
                if((dblTime >= dblLength) && (m_pPlayer != NULL))
                {
                    m_pPlayer->SetHoldingFlag();
                    dblTime = dblLength;
                }
                if((dblTime < dblLength) && (m_pPlayer != NULL))
                {
                    m_pPlayer->ClearHoldingFlag();
                }
            }
            if (UsingWMP() && (dblTime >= dblLength))
            {
                SetPosition(dblLength);
            }
            else
            {
                IGNORE_HR(m_pProxyPlayer->put_CurrentTime(dblTime));
            }
        }
    }
done:
    return hr;
}

double
CContainerObj::GetCurrentTime()
{
    double dblTime = 0.0;
    
    if (m_pProxyPlayer)
    {
        double dblTemp = 0.0;
        HRESULT hr;
        hr = m_pProxyPlayer->get_CurrentTime(&dblTemp);
        if (SUCCEEDED(hr))
            dblTime = dblTemp;
    }
    return dblTime;
}


HRESULT
CContainerObj::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    if (!m_pSite)
    {
        hr = E_FAIL;
        goto done;
    }

    m_pSite->SetSize(prect);

done:
    return hr;
}

HRESULT
CContainerObj::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    if (!m_fUsingWMP)
    {
        return E_FAIL;
    }
    
    Assert(m_pSite);
    if (UsingPlaylist()) //if a playlist is being used then it is not possible to determine the length
    {
        dblLength = HUGE_VAL;
    }
    else
    {
        hr = GetCurrClipLength(dblLength);
    }
        
    return hr;
}


HRESULT
CContainerObj::GetCurrClipLength(double &dblLength)
{
    HRESULT hr = S_OK;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_ISDURATIONVALID,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!vIsValid.boolVal)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = pdisp->Invoke(DISPID_DURATION,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &_retVar, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = _retVar.ChangeType(VT_R8, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    dblLength = _retVar.dblVal;

    hr = S_OK;
  done:
    return hr;
}


HRESULT
CContainerObj::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;

    if (m_pSite)
    {
        *height = m_pSite->GetNaturalHeight();
        if (*height == 0)
        {
            *height = -1;
        }
    }
    else
    {
        *height = -1;
    }

    return hr;
}


HRESULT
CContainerObj::GetNaturalWidth(long *width)
{
    HRESULT hr = S_OK;

    if (m_pSite)
    {
        *width = m_pSite->GetNaturalWidth();
        if (*width == 0)
        {
            *width = -1;
        }
    }
    else
    {
        *width = -1;
    }

    return hr;
}

HRESULT 
CContainerObj::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;

    hr = THR(m_pSite->Save(pPropBag, fClearDirty, fSaveAllProperties));
    
    return hr;
}


void 
CContainerObj::ReadyStateNotify(LPWSTR szReadyState)
{
    if (StrCmpIW(szReadyState, L"OnLoad") == 0)
    {
        if (!m_fStarted && !m_fLoaded)
        {
            SetVisibility(false);

            if(m_bStartOnLoad == false)
            {
                m_bPauseOnPlay = true;
            }
            
            if (m_pSite)
            {   
                IGNORE_HR(m_pSite->Activate());
                IGNORE_HR(m_pProxyPlayer->begin());
            }

            if (m_pPlayer)
            {
                m_pPlayer->SetMute(VARIANT_TRUE);
            }
            m_fLoaded = true;
        }
    }
    else if (StrCmpIW(szReadyState, L"OnUnload") == 0)
    {
        if (m_pSite)
        {
            IGNORE_HR(m_pSite->Unload());
        }
    }

    return;
}

void
CContainerObj::UpdateNaturalDur(bool bUpdatePlaylist)
{
    HRESULT hr;

    double dblMediaLength;
    double dblClipStart;
    double dblClipEnd;

    if (!m_pPlayer)
    {
        goto done;
    }
    
    dblMediaLength = 0.0;
    dblClipStart = m_pPlayer->GetRealClipStart();
    dblClipEnd = m_pPlayer->GetRealClipEnd();

    if (dblClipStart < 0.0)
    {
        dblClipStart = 0.0;
    }

    // if this is not a playlist, attempt to set the natural duration
    if (dblClipEnd != valueNotSet &&
        dblClipEnd > dblClipStart)
    {
        dblMediaLength = dblClipEnd - dblClipStart;
    }
    else if (UsingPlaylist())
    {
        if (!bUpdatePlaylist)
        {
            goto done;
        }
        
        // Need to add a fudge factor since we cannot calc right now
        dblMediaLength = (m_pPlayer->GetElapsedTime() + 0.00001);
    }
    else
    {
        hr = THR(GetMediaLength(dblMediaLength));
        if (FAILED(hr))
        {
            goto done;
        }

        dblMediaLength -= dblClipStart;
    }

    if (dblMediaLength <= 0.0)
    {
        goto done;
    }
    
    m_pPlayer->PutNaturalDuration(dblMediaLength);

  done:
    return;
}

PlayerState
CContainerObj::GetState()
{
    PlayerState state;
    
    if (!m_fStarted)
    {
        if (m_bFirstOnMediaReady)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        state = PLAYER_STATE_ACTIVE;
    }

    return state;
}

HRESULT
CContainerObj::PutSrc(WCHAR *pwszSrc)
{
    HRESULT hr;
    
    if (m_pSite)
    {
        m_pSite->ClearSizeFlag();
    }

    if (m_pProxyPlayer)
    {
        hr = THR(m_pProxyPlayer->put_src(pwszSrc));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

IHTMLElement *
CContainerObj::GetElement()
{
    IHTMLElement * pRet = NULL;

    if (m_pPlayer)
    {
        pRet = m_pPlayer->GetElement();
    }

    return pRet;
}

IServiceProvider *
CContainerObj::GetServiceProvider()
{
    IServiceProvider * pRet = NULL;

    if (m_pPlayer)
    {
        pRet = m_pPlayer->GetServiceProvider();
    }

    return pRet;
}

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Invalidate(LPCRECT prc)
{
    HRESULT  hr;
    RECT     rc;
    RECT    *prcNew;

    // No need to forward call on if we are not started yet or if the element has detached.
    if ((!m_fStarted) || (NULL == m_pPlayer))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // since we have incapatible types due to const.  Take the time and repack it.
    if (prc == NULL)
    {
        prcNew = NULL;
    }
    else
    {
        ::CopyRect(&rc, prc);
        prcNew = &rc;
    }

    // m_pPlayer != is checked above.
    m_pPlayer->InvalidateElement(prcNew);   
    hr = S_OK;

done:
    return hr;
} // Invalidate

HRESULT
CContainerObj::GetContainerSize(LPRECT prcPos)
{
    HRESULT hr = E_FAIL;

    if (m_pPlayer)
    {
        hr = THR(GetPlayer()->GetPlayerSize(prcPos));
    }

    return hr;
}

HRESULT
CContainerObj::SetContainerSize(LPCRECT prcPos)
{
    HRESULT hr = E_FAIL;

    if (m_pPlayer)
    {
        hr = THR(GetPlayer()->SetPlayerSize(prcPos));
    }

    return hr;
}

HRESULT
CContainerObj::ProcessEvent(DISPID dispid,
                            long lCount, 
                            VARIANT varParams[])
{
    TraceTag((tagContainerObj, "CContainerObj::ProcessEvent(%lx)",this));

    HRESULT hr = S_OK;
    int itrackNr = 0;
    LPWSTR szParamNames[1] = {{ L"TrackError" }};
    VARIANT varParamsLocal[1];

    AddRef(); //to protect this object from being deleted during the event handling

    if (NULL == m_pPlayer)
    {
        hr = E_NOTIMPL;
        goto done;
    }

    switch (dispid)
    {
#define DISPID_WARNING                  3009
      case DISPID_WARNING:
        if(lCount != 3)
        {
            break;
        }
        if(varParams[2].vt != VT_I4)
        {
            break;
        }
        if(varParams[2].lVal != 2)
        {
            break;
        }
        if(varParams[1].vt != VT_I4)
        {
            break;
        }
        VariantInit(&varParamsLocal[0]);

        varParamsLocal[0].vt =  VT_I4;
        varParamsLocal[0].lVal = varParams[1].lVal;

        if(m_pPlayer)
        {
            m_pPlayer->FireEventNoErrorState(TE_ONMEDIAERROR, 1, szParamNames, varParamsLocal);
        }
        
        break;
//left in for future investigation dorinung.
#define DISPID_BUFFERING 3003
      case DISPID_BUFFERING:
        break;
      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
       
        if(m_pPlayer)
        {
            m_pPlayer->FireMediaEvent(PE_ONMEDIAERROR);
        }
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:

        SetMediaReadyFlag();
        if (m_pSite)
        {
            m_pSite->ClearAutosizeFlag();
        }
                
        //make the element visible here.
        if (m_setVisible)
        {
            SetVisibility(true);
        }

        if (m_bFirstOnMediaReady)
        {
            m_bFirstOnMediaReady = false;
                
            // This must happen before we set natural duration
            // since we detect playlist during this call
            
            if(m_pPlayer)
            {
                m_pPlayer->FireMediaEvent(PE_ONMEDIACOMPLETE);        
                m_pPlayer->ClearNaturalDuration();
            }
            UpdateNaturalDur(false);

            // if this is not a playlist, attempt to set the natural duration

            if (m_lActiveLoadedTrack != NOTRACKSELECTED)
            {
                if (m_pPlayer && m_pPlayer->GetPlayList())
                {
                    CComVariant vIndex(m_lActiveLoadedTrack);
                        
                    IGNORE_HR(m_pPlayer->GetPlayList()->put_activeTrack(vIndex));
                }

                m_lActiveLoadedTrack = NOTRACKSELECTED;
            }

            if (m_bStartOnLoad)
            {
                m_bStartOnLoad = false;
                Start();
            }

            if (m_bEndOnPlay)
            {
                m_pProxyPlayer->end();
                m_bEndOnPlay = false;
            }
            if (m_bPauseOnPlay || (m_pPlayer && m_pPlayer->IsParentPaused()))
            {
                THR(m_pProxyPlayer->pause());
                m_bPauseOnPlay = false;
            }

            if (m_bSeekOnPlay)
            {
                IGNORE_HR(Seek(m_dblSeekTime));
                if(m_pPlayer)
                {
                    m_pPlayer->InvalidateElement(NULL);
                }
                m_bSeekOnPlay = false;
            }

        }
        else
        {
            CPlayItem *pPlayItem = NULL;
                
            if (m_bPauseOnPlay)
            {
                hr = THR(m_pProxyPlayer->pause());
                if (FAILED(hr))
                {
                    TraceTag((tagError, "Pause failed"));
                }
                m_bPauseOnPlay = false;
            }

            if (m_pPlayer && m_pPlayer->GetPlayList())
            {
                //load the current info into the selected playitem.
                pPlayItem = m_pPlayer->GetPlayList()->GetActiveTrack();
                SetMediaInfo(pPlayItem);
            }

            if(m_pPlayer)
            {
                m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
            }
        }

        SetDuration();
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN:
        m_bActive = true;
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
        m_bActive = false;

        //need notification here.
        if(m_pPlayer)
        {
            m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
        }
        if (m_bFirstOnMediaReady || UsingPlaylist())
        {
            UpdateNaturalDur(true);
        }
            
        if(m_pPlayer != NULL)
        {
            m_pPlayer->SetHoldingFlag();
        }

        break;

#define DISPID_SCRIPTCOMMAND 3001
      case DISPID_SCRIPTCOMMAND:
        // HACKHACK
        // Pick off the script command from WMP and repackage the event as our own.
        // This allows triggers to work.  The real fix is to add another event on
        // TIMEMediaPlayerEvents.
        if (m_fUsingWMP && lCount == 2) 
        {
            static LPWSTR pNames[] = {L"Param", L"scType"};
            
            if(m_pPlayer)
            {
                hr = m_pPlayer->FireEvents(TE_ONSCRIPTCOMMAND, 
                                           lCount, 
                                           pNames, 
                                           varParams);
            }
        }
        break;
      default:
        hr = E_NOTIMPL;
        goto done;
    }

    hr = S_OK;
  done:

    Release(); //Release the addref done at the beginning of the function
    
    RRETURN(hr);
}

HRESULT
CContainerObj::GetExtendedControl(IDispatch **ppDisp)
{
    CHECK_RETURN_SET_NULL(ppDisp);

    return E_NOTIMPL;
}

HRESULT
CContainerObj::NegotiateSize(RECT &nativeSize,
                             RECT &finalSize,
                             bool &fIsNative)
{
    HRESULT hr = S_OK;
    bool fResetSize = false;

    if(UsingPlaylist())
    {
        fResetSize = true;
    }

    if (m_pPlayer)
    {
        hr = THR(m_pPlayer->NegotiateSize(nativeSize,
                                          finalSize,
                                          fIsNative, fResetSize));
    }

    return hr;
}

HRESULT 
CContainerObj::SetPosition(double dblLength)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDispatch;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName = L"CurrentPosition";
    CComVariant         varResult;
    VARIANT             rgvarg[1];
    DISPPARAMS dp;
    UINT puArgErr = 0;

    hr = GetControlDispatch(&pDispatch);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    VariantInit(&rgvarg[0]);
    rgvarg[0].vt    = VT_R8;
    rgvarg[0].dblVal = dblLength;

    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = pDispatch->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           &puArgErr);
    if (FAILED(hr))
    {
        goto done;
    }

  done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\decibels.h ===
//--------------------------------------------------------------------------;
//
//  File: decibels.cpp
//
//  Copyright (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//       utilities for converting volume/pan in decibel units to/from
//       the 0-0xffff (0-1000) range used by waveOutSetVolume (MCI) etc
//
//  Contents:
//
//  History:
//      06/15/95	SteveDav    plagiarised from Direct Sound
//
//--------------------------------------------------------------------------;
#ifndef _DECIBELS_H
#define _DECIBELS_H

LONG AmpFactorToDB( DWORD dwFactor );
DWORD DBToAmpFactor( LONG lDB );

#define AX_MIN_VOLUME -10000
#define AX_QUARTER_VOLUME -1200
#define AX_HALF_VOLUME -600
#define AX_THREEQUARTERS_VOLUME -240
#define AX_MAX_VOLUME 0

#define AX_BALANCE_LEFT -10000
#define AX_BALANCE_RIGHT 10000
#define AX_BALANCE_NEUTRAL 0

#define MAX_VOLUME_RANGE 1.0
#define MIN_VOLUME_RANGE 0.0

#endif /* _DECIBELS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\dshowcdproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: implementation of CTIMEDshowCDPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "dshowcdproxy.h"
#include "playercd.h"

#define SUPER CTIMEPlayerProxy

CTIMEDshowCDPlayerProxy* 
CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy()
{
    HRESULT hr;
    CTIMEDshowCDPlayerProxy * pProxy;

    pProxy = new CTIMEDshowCDPlayerProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEDshowCDPlayerProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEDshowCDPlayer(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\dmusicproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.h
//
//  Contents: declaration for CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DMUSIC_PROXY_H__
#define _DMUSIC_PROXY_H__

#include "playerproxy.h"

class CTIMEPlayerDMusicProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEPlayerDMusicProxy* CreateDMusicProxy();
    
  protected:
    CTIMEPlayerDMusicProxy() {}
    virtual HRESULT Init();

};

#endif //_DMUSIC_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\dshowproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: implementation of CTIMEDshowPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "dshowproxy.h"
#include "playerdshow.h"

#define SUPER CTIMEPlayerProxy

CTIMEDshowPlayerProxy* 
CTIMEDshowPlayerProxy::CreateDshowPlayerProxy()
{
    HRESULT hr;
    CTIMEDshowPlayerProxy * pProxy;

    pProxy = new CTIMEDshowPlayerProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEDshowPlayerProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEDshowPlayer(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\dmusicproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.cpp
//
//  Contents: implementation of CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "dmusicproxy.h"
#include "playerdmusic.h"

#define SUPER CTIMEPlayerProxy

CTIMEPlayerDMusicProxy* 
CTIMEPlayerDMusicProxy::CreateDMusicProxy()
{
    HRESULT hr = S_OK;
    CTIMEPlayerDMusicProxy * pProxy;

    pProxy = new CTIMEPlayerDMusicProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEPlayerDMusicProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEPlayerDMusic(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\dshowcdproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: declaration for CTIMEDshowCDPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DSHOWCD_PROXY_H__
#define _DSHOWCD_PROXY_H__

#include "playerproxy.h"

class CTIMEDshowCDPlayerProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEDshowCDPlayerProxy* CreateDshowCDPlayerProxy();
    
  protected:
    CTIMEDshowCDPlayerProxy() {}
    virtual HRESULT Init();

};

#endif //_DSHOW_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\dshowproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: declaration for CTIMEDshowPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DSHOW_PROXY_H__
#define _DSHOW_PROXY_H__

#include "playerproxy.h"

class CTIMEDshowPlayerProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEDshowPlayerProxy* CreateDshowPlayerProxy();
    
  protected:
    CTIMEDshowPlayerProxy() {}
    virtual HRESULT Init();

};

#endif //_DSHOW_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\externuuids.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\time\src\externuuids.cpp
//
//  Contents:  UUID definitions for music center
//
//------------------------------------------------------------------------
#include "headers.h"
#include <initguid.h>
#include "mixerocx.h"
#include <ExternUUIDs.h>
#include <inc\qnetwork.h>

//
// originally in \mm\inc\manager.h
//
const CLSID    CLSID_MCMANAGER          = {0xcd103bcf,0x4846,0x11d3,{0xa2,0x0a,0x00,0xc0,0x4f,0xa3,0xb6,0x0c}};
const IID      IID_IMCManager           = {0x901B7025,0x4846,0x11d3,{0xa2,0x0a,0x00,0xc0,0x4f,0xa3,0xb6,0x0c}};

//
// originally in \mm\inc\dplayer.h
//
const CLSID    CLSID_DLXPLAY            = {0xcf94dff3,0x38ea,0x4343,{0x96,0x3e,0x41,0x0d,0xb6,0x0d,0xd9,0xb8}};
const IID      IID_IDLXPLAY             = {0x89301af7,0xeb8d,0x41f8,{0xbb,0x3d,0x6b,0xc2,0x25,0xda,0x31,0xc2}};
const IID      IID_IDLXPLAYEVENTSINK    = {0x89301af8,0xeb8d,0x41f8,{0xbb,0x3d,0x6b,0xc2,0x25,0xda,0x31,0xc2}};

//
// originally in \mm\shplay\shplay.h
//
const IID      IID_IMCPList             = {0xEBC54B0C,0x4091,0x11D3,{0xA2,0x08,0x00,0xC0,0x4F,0xA3,0xB6,0x0C}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\externuuids.h ===
//+-----------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\time\src\externuuids.h
//
//  Contents:  UUID and interface declarations for music center
//             
//             IDEALLY, THIS FILE SHOULD GO AWAY
//
//------------------------------------------------------------------------

#pragma once

// These are defined under different macro names inside of maguids.h

#define MCPLAYLIST_PROPERTY_ARTIST              L"Artist"
#define MCPLAYLIST_PROPERTY_TITLE               L"Title"
#define MCPLAYLIST_PROPERTY_COPYRIGHT           L"Copyright"

#define MCPLAYLIST_TRACKPROPERTY_ARTIST         L"Artist"
#define MCPLAYLIST_TRACKPROPERTY_TITLE          L"Title"
#define MCPLAYLIST_TRACKPROPERTY_FILENAME       L"Filename"
#define MCPLAYLIST_TRACKPROPERTY_COPYRIGHT      L"Copyright"
#define MCPLAYLIST_TRACKPROPERTY_RATING         L"Rating"

//
// originally in \mm\inc\deluxecd.h
//

// CD-ROM table-of-contents track count         
#ifndef MAXIMUM_NUMBER_TRACKS                   
#define MAXIMUM_NUMBER_TRACKS                   100             // 99 actual tracks + 1 leadout
#endif // MAXIMUM_NUMBER_TRACKS                 


// Table-of-contents                             
typedef struct 
{
    DWORD           dwType;                             // Track type
    DWORD           dwStartPosition;                    // Track starting position
} DLXCDROMTOCTRACK;

typedef struct 
{
    DWORD               dwTrackCount;                       // Track count
    DLXCDROMTOCTRACK    TrackData[MAXIMUM_NUMBER_TRACKS];   // Track data
} DLXCDROMTOC;


//
// originally in \mm\inc\manager.h
//
EXTERN_C const CLSID    CLSID_MCMANAGER;
EXTERN_C const IID      IID_IMCManager;


typedef interface IMCManager            IMCManager;
typedef IMCManager *	                LPMCMANAGER;

typedef interface IMCManagerChangeSink  IMCManagerChangeSink;
typedef IMCManagerChangeSink *		    LPMCMANAGERCHANGESINK;

//IMCPList is generated from the shplay\shplay.idl file into shplay\shplay.h
//         It isn't nice enough to create these typedefs for us, so we are
//         defining them here

    MIDL_INTERFACE("EBC54B0C-4091-11D3-A208-00C04FA3B60C")
    IMCPList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tracks( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GetProperty( 
            BSTR PropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GetTrackProperty( 
            int TrackNumber,
            BSTR PropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( 
            BSTR PlaylistName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( 
            BSTR PlaylistName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InsertTrack( 
            VARIANT FilenameOrNumber,
            short Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTrack( 
            short Index) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadCDPlaylist( 
            LPUNKNOWN pChangeSink,
            HWND hwnd,
            LPUNKNOWN pRoot,
            void __RPC_FAR *pTOC,
            BOOL fOriginal) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadFromFile( 
            BSTR FileName) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            LPUNKNOWN pChangeSink,
            HWND hwnd,
            LPUNKNOWN pRoot) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveTrack( 
            short OldIndex,
            short NewIndex) = 0;
        
        virtual /* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Clone( 
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *ppVal) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeFromCopy( 
            LPUNKNOWN pChangeSink,
            HWND hwnd,
            LPUNKNOWN pRoot,
            LPUNKNOWN pPlaylist,
            short PlaylistType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasMetaData( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
    };




typedef interface IMCPList              IMCPList;
typedef IMCPList *		                LPMCPLIST;
//



#undef INTERFACE
#define INTERFACE IMCManager

DECLARE_INTERFACE_(IMCManager, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			        (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			        (THIS) PURE;
    STDMETHOD_(ULONG,Release) 			        (THIS) PURE;

    // IMCManager methods
    STDMETHOD (GetCDPlaylist)                   (THIS_ DLXCDROMTOC* pTOC, IMCPList** ppPlaylist) PURE;
    STDMETHOD (GetNewPlaylist)                  (THIS_ IMCPList** ppPlaylist) PURE;
    STDMETHOD (RegisterChangeSink)              (THIS_ IMCManagerChangeSink* pSink) PURE;
    STDMETHOD_(DWORD,GetNumNamedPlaylists)      (THIS) PURE;
    STDMETHOD (BeginNamedPlaylistEnumeration)   (THIS_ DWORD dwIndex) PURE;
    STDMETHOD (EnumerateNamedPlaylist)          (THIS_ BSTR bstrName) PURE;
    STDMETHOD (EndNamedPlaylistEnumeration)     (THIS) PURE;
};


//
// originally in \mm\inc\dplayer.h
//
EXTERN_C const CLSID    CLSID_DLXPLAY;
EXTERN_C const IID      IID_IDLXPLAY;

typedef interface IDLXPlay		        IDLXPlay;
typedef IDLXPlay *	    		        LPDLXPLAY;

typedef interface IDLXPlayEventSink     IDLXPlayEventSink;
typedef IDLXPlayEventSink *		        LPDLXPLAYEVENTSINK;

#undef INTERFACE
#define INTERFACE IDLXPlay

DECLARE_INTERFACE_(IDLXPlay, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
                                        
    // IDLXPlay methods                 
    STDMETHOD (Initialize)              (THIS_ LPMCMANAGER pManager, LPDLXPLAYEVENTSINK pSink) PURE;
	STDMETHOD (get_GetCurrentPlaylist)  (THIS_ IMCPList* *pVal) PURE;
	STDMETHOD (SetRadioPlaylist)        (THIS_ IMCPList* pPlaylist) PURE;
	STDMETHOD (SetMusicPlaylist)        (THIS_ IMCPList* pPlaylist) PURE;
	STDMETHOD (get_Tracks)              (THIS_ short *pVal) PURE;
	STDMETHOD (get_CurrentTrack)        (THIS_ int *pVal) PURE;
	STDMETHOD (put_CurrentTrack)        (THIS_ int newVal) PURE;
	STDMETHOD (get_CurrentCD)           (THIS_ short *pVal) PURE;
	STDMETHOD (put_CurrentCD)           (THIS_ short newVal) PURE;
	STDMETHOD (get_GetCDPlaylist)       (THIS_ short Index, IMCPList **ppVal) PURE;
	STDMETHOD (get_GetMusicPlaylist)    (THIS_ IMCPList **ppVal) PURE;
	STDMETHOD (get_GetRadioPlaylist)    (THIS_ IMCPList **ppVal) PURE;
	STDMETHOD (get_NumCDs)              (THIS_ short *pVal) PURE;
	STDMETHOD (get_State)               (THIS_ short *pVal) PURE;
	STDMETHOD (PreviousTrack)           (THIS) PURE;
	STDMETHOD (NextTrack)               (THIS) PURE;
	STDMETHOD (Stop)                    (THIS) PURE;
	STDMETHOD (Pause)                   (THIS) PURE;
	STDMETHOD (Play)                    (THIS) PURE;
	STDMETHOD (OpenFiles)               (THIS) PURE;
	STDMETHOD (Options)                 (THIS) PURE;
	STDMETHOD (OnDraw)                  (THIS_  HDC hdc, RECT *pRect) PURE;
    STDMETHOD_(LRESULT,OnMessage)       (THIS_  UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) PURE;
    STDMETHOD (SetUIInfo)               (THIS_  HWND hwndParent, RECT* pRect, IOleInPlaceSiteWindowless* pSite) PURE;
    STDMETHOD (BeginCacheTrack)         (THIS_  short CD, short Track, wchar_t* filename) PURE;
    STDMETHOD (CancelCache)             (THIS) PURE;
	STDMETHOD(get_Mute)                 (THIS_ BOOL *pVal) PURE;
	STDMETHOD(put_Mute)                 (THIS_ BOOL newVal) PURE;
	STDMETHOD(get_Volume)               (THIS_ float *pVal) PURE;
	STDMETHOD(put_Volume)               (THIS_ float newVal) PURE;
	STDMETHOD(get_PlayerMode)           (THIS_ short *pVal) PURE;
	STDMETHOD(put_PlayerMode)           (THIS_ short newVal) PURE;
    STDMETHOD(Eject)                    (THIS) PURE;
};



#undef INTERFACE
#define INTERFACE IDLXPlayEventSink

DECLARE_INTERFACE_(IDLXPlayEventSink, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 		    (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 		    (THIS) PURE;
    STDMETHOD_(ULONG,Release) 		    (THIS) PURE;
                                        
    // IDLXPlayEventSink methods        
	STDMETHOD (OnDiscInserted)          (THIS_  long CDID) PURE;
    STDMETHOD (OnDiscRemoved)           (THIS_  long CDID) PURE;
    STDMETHOD (OnPause)                 (THIS) PURE;
    STDMETHOD (OnStop)                  (THIS) PURE;
    STDMETHOD (OnPlay)                  (THIS) PURE;
    STDMETHOD (OnTrackChanged)          (THIS_ short NewTrack) PURE;
    STDMETHOD (OnCacheProgress)         (THIS_ short CD, short Track, short PercentCompleted) PURE;
    STDMETHOD (OnCacheComplete)         (THIS_ short CD, short Track, short Status) PURE;
};


//
// originally in \mm\shplay\shplay.h
//
EXTERN_C const IID      IID_IMCPList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\hwproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.h
//
//  Contents: declaration for CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DSHOW_HW_PROXY_H__
#define _DSHOW_HW_PROXY_H__

#include "playerproxy.h"

class CTIMEDshowHWPlayerProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEDshowHWPlayerProxy* CreateDshowHWPlayerProxy();
    
  protected:
    CTIMEDshowHWPlayerProxy() {}
    virtual HRESULT Init();

};

#endif //_DSHOW_HW_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\hwproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.cpp
//
//  Contents: implementation of CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "hwproxy.h"
#include "playerhwdshow.h"

#define SUPER CTIMEPlayerProxy

CTIMEDshowHWPlayerProxy* 
CTIMEDshowHWPlayerProxy::CreateDshowHWPlayerProxy()
{
    HRESULT hr;
    CTIMEDshowHWPlayerProxy * pProxy;

    pProxy = new CTIMEDshowHWPlayerProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEDshowHWPlayerProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEDshowHWPlayer(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\mediaelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mediaelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mediaelm.h"
#include "playerimage.h"
#include "playerproxy.h"
#if DBG == 1
#include "playerdshowtest.h"
#endif
#include "playerdvd.h"
#include "player.h"
#include "player2.h"
#include "dmusicproxy.h"
#include "playernative.h"
#include <mshtmdid.h>
#include "playlist.h"
#include "timeparser.h"
#include "..\tags\bodyelm.h"

// #define ALWAYSDS 1


bool ConvertToPixels(VARIANT *pvarValue, WCHAR *pAttribute);

// static class data.
DWORD CTIMEMediaElement::ms_dwNumTimeMediaElems = 0;

DeclareTag(tagMediaTimeElm, "TIME: Behavior", "CTIMEMediaElement methods")
DeclareTag(tagMediaTimeElmSync, "TIME: Behavior", "CTIMEMediaElement sync methods")
DeclareTag(tagMediaElementOnChanged, "TIME: Behavior", "CTIMEMediaElement OnChanged method")
DeclareTag(tagMediaTransitionSite, "TIME: Behavior", "CTIMEMediaElement transition site methods")

#define DEFAULT_M_SRC       NULL
#define DEFAULT_M_SRCTYPE   NULL

#if DBG == 1
#define TestPlayerCLSID L"{FAC64649-FD53-4A41-89B8-DA126CB9DD10}"
#endif

extern long g_LOGPIXELSX;
extern long g_LOGPIXELSY;

CTIMEMediaElement::CTIMEMediaElement()
: m_SASrc(DEFAULT_M_SRC),
  m_baseHREF(NULL),
  m_SASrcType(DEFAULT_M_SRCTYPE),
  m_SAPlayer(NULL),
  m_FAClipBegin(-1.0f),
  m_FAClipEnd(-1.0f),
  m_LAClipBegin(-1),
  m_LAClipEnd(-1),
  m_Player(NULL),
  m_fLoaded(false),
  m_fExternalPlayer(false),
  m_fCreatePlayerError(false),
  m_fHaveCLSID(false),
  m_mediaElementPropertyAccesFlags(0),
  m_fMediaSizeSet(false),
  m_dwAdviseCookie(0),
  m_fInOnChangedFlag(false),
  m_fDurationIsNatural(false),
  m_playerToken(NONE_TOKEN),
  m_playerCLSID(GUID_NULL),
  m_fLoadError(false),
  m_fInPropLoad(false),
  m_fEditModeFlag(false),
  m_fWaitForSync(false),
  m_fPauseForSync(false),
  m_fFirstPause(false),
  m_pPlayListDelegator(NULL),
  m_pSyncElem(NULL),
  m_fDetached(true),
  m_fNativeSize(false),
  m_fNativeSizeComputed(false),
  m_fLoading(false),
  m_fIgnoreStyleChange(false)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::CTIMEMediaElement()",
              this));

    m_clsid = __uuidof(CTIMEMediaElement);
    CTIMEMediaElement::ms_dwNumTimeMediaElems++;
    
    m_rcOrigSize.bottom = m_rcOrigSize.left = m_rcOrigSize.right = m_rcOrigSize.top = 0;
    m_rcMediaSize.bottom = m_rcMediaSize.left = m_rcMediaSize.right = m_rcMediaSize.top = 0;
}

CTIMEMediaElement::~CTIMEMediaElement()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::~CTIMEMediaElement()",
              this));
    
    delete [] m_SASrc.GetValue();
    delete [] m_SASrcType.GetValue();
    delete [] m_SAPlayer.GetValue();
    delete [] m_baseHREF;
    m_baseHREF = NULL;

    RemovePlayer();

    // Order dependency: this should happen only after RemovePlayer has been called
    if (m_pPlayListDelegator)
    {
        m_pPlayListDelegator->Release();
        m_pPlayListDelegator = NULL;
    }

    CTIMEMediaElement::ms_dwNumTimeMediaElems--;

} //lint !e1740

STDMETHODIMP
CTIMEMediaElement::onPauseEvent(float time, float fOffset)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::onPauseEvent()",
              this));
    HRESULT hr = S_OK;
    VARIANT_BOOL canPause;

    hr = THR(get_canPause(&canPause));
    if (FAILED(hr)) //if this fails, try to pause
    {
        canPause = VARIANT_TRUE;
    }

    if (canPause == VARIANT_TRUE)
    {
        IGNORE_HR(CTIMEElementBase::onPauseEvent(time, fOffset));
    }

  done:
    return S_OK;  //don't fail this call, it will return an error to script.
}

STDMETHODIMP
CTIMEMediaElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Init()",
              this));

    HRESULT hr = E_FAIL;

    CComPtr<IHTMLElement2> pElem2;
    VARIANT_BOOL varboolSuccess;

    m_fDetached = false;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

    m_sp = GetServiceProvider();
    if (!m_sp)
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - unable get QS"));
        hr = TIMESetLastError(DISP_E_TYPEMISMATCH, NULL);   
        goto done;
    }

    hr = CTIMEElementBase::GetSize(&m_rcOrigSize);
    if (FAILED(hr))
        goto done;

    hr = InitPropertySink();
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetElement() != NULL);
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = S_OK;
        goto done;
    }

    hr = pElem2->attachEvent( L"onresize", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pElem2->attachEvent( L"onmousemove", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pElem2->attachEvent( L"onmousedown", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pElem2->attachEvent( L"onmouseup", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fEditModeFlag = IsDocumentInEditMode();


    hr = pBehaviorSite->QueryInterface(IID_IElementBehaviorSiteRender, (void **) &m_pBvrSiteRender);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pBehaviorSite->QueryInterface(IID_IHTMLPaintSite, (void **) &m_spPaintSite);
    if (FAILED(hr))
    {
        // We don't want to fail since we will just use the old rendering interfaces..
        m_spPaintSite = NULL;
    }

    hr = S_OK;

done:
    return hr;
}

void
CTIMEMediaElement::RemovePlayer()
{
    // release reference on player's playlist object
    if (m_pPlayListDelegator)
    {
        m_pPlayListDelegator->DetachPlayList();
    }

    if (m_Player)
    {
        // Do an extra addref in case we get released between calls
        DAComPtr<ITIMEBasePlayer> pTmp = m_Player;
    
        // Release the pointer before calling stop since it can cause
        // us to be reentered and we do not want to cause an infinite loop
        m_Player.Release();

        pTmp->Stop();
        THR(pTmp->DetachFromHostElement());
    }

    m_fLoaded = false;
}

HRESULT
CTIMEMediaElement::CreateExternalPlayer(CLSID clsid,
                                        ITIMEBasePlayer ** ppPlayer)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppPlayer);
    
    if (IsEqualCLSID(clsid, __uuidof(MediaPlayerCLSID)))
    {
        *ppPlayer = NEW CTIMEPlayer(clsid);

        if (*ppPlayer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        (*ppPlayer)->AddRef();
    }
    else
    {
        CComPtr<IUnknown> pObj;

        hr = THR(::CreateObject(clsid,
                                IID_IUnknown,
                                (void **)&pObj));
        if (FAILED(hr))
        {
            goto done;
        }
    
        if (CTIMEPlayer2::CheckObject(pObj))
        {
            CTIMEPlayer2 * p2;
            
            hr = THR(CreateTIMEPlayer2(clsid,
                                       pObj,
                                       &p2));

            if (FAILED(hr))
            {
                goto done;
            }

            *ppPlayer = p2;
        }
        else if (CTIMEPlayer::CheckObject(pObj))
        {
            *ppPlayer = NEW CTIMEPlayer(clsid);

            if (*ppPlayer == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            (*ppPlayer)->AddRef();
        }
        else
        {
            hr = E_INVALIDARG;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEMediaElement::CreatePlayer(TOKEN playerToken)
{
    HRESULT hr = E_FAIL;
    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;
    BOOL fAllowed = FALSE;
    
    ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
    RemovePlayer();
    Assert(!m_fLoaded);

    if (GetMMBvr().IsDisabled())
    {
        GetMMBvr().Enable();
    }

    if(playerToken == NULL)
    {
#if DBG == 1
        CLSID clsidTest;
        CLSIDFromString(TestPlayerCLSID, &clsidTest);
        if (IsEqualCLSID(m_playerCLSID, clsidTest))
        {
            m_Player = NEW CTIMEPlayerNative(PLAYER_DSHOWTEST);
        } 
        else
#endif
        {
            if (fPlayVideo &&
                !IsEqualCLSID(m_playerCLSID,
                              GUID_NULL))
            {
                hr = AllowCreateControl(&fAllowed, m_playerCLSID);
                if (FAILED(hr) || (fAllowed == FALSE))
                {
                    hr = E_FAIL;
                    goto done;
                }
                hr = THR(CreateExternalPlayer(m_playerCLSID,
                                              &m_Player));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                m_Player = NEW CTIMEPlayerNative(PLAYER_NONE);
            }
        }
    }
#if DBG // 94850
    else if((playerToken == DSHOW_TOKEN) && fPlayVideo)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_DSHOW);
    }
#endif
    else if((playerToken == DVD_TOKEN) && fPlayVideo)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_DVD);
    }
    else if(playerToken == CD_TOKEN)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_CD);
    }
    else if(playerToken == NONE_TOKEN)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_NONE);
    }

    if (!m_Player)
    {
        hr = E_FAIL;
        goto done;
    }

    if (IsReady())
    {
        InitOnLoad();
    }

    if (m_pPlayListDelegator)
    {
        CComPtr<ITIMEPlayList> spPlayList;

        hr = THR(m_Player->GetPlayList(&spPlayList));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        m_pPlayListDelegator->AttachPlayList(spPlayList);
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_fCreatePlayerError = true;
        RemovePlayer();
    }
    
    return hr;
}

void
CTIMEMediaElement::InvalidateElement(LPCRECT lprect)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::InvalidateElement",
              this));

    RECT rc;
    RECT *prcNew;

    // since we have incapatible types due to const.  Take the time and repack it.
    if (lprect == NULL)
    {
        prcNew = NULL;
    }
    else
    {
        ::CopyRect(&rc, lprect);
        prcNew = &rc;
    }

    if (m_spPaintSite)
    {
        m_spPaintSite->InvalidateRect(prcNew);
    }
    else if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->Invalidate(prcNew);
    }
}

bool
CTIMEMediaElement::IsNativeSize()
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs;
    CComPtr<IHTMLCurrentStyle> sc;
    CComPtr<IHTMLElement2> pEle2;
    VARIANT styleWidth, styleHeight;
    VARIANT crstyleWidth, crstyleHeight;
    VariantInit(&styleWidth);
    VariantInit(&styleHeight);
    VariantInit(&crstyleWidth);
    VariantInit(&crstyleHeight);
    long pixelWidth = 0, pixelHeight = 0;
    bool fstyleWidth = false, fstyleHeight = false;
    bool fnativeSize = true;

    if (m_fNativeSizeComputed == true)
    {
        fnativeSize = m_fNativeSize;
        goto done;
    }
   
    if(GetElement() == NULL)
    {
        goto done;
    }

    hr = GetElement()->get_style(&s);
    if (FAILED(hr) || s == NULL)
    {
        goto done;
    }
    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_currentStyle(&sc);
        if (FAILED(hr) || sc == NULL)
        {
            goto done;
        }
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        hr = sc->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
            }
        }

        hr = sc -> get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
            }
        }

    }


    if(rs != NULL)
    {
        hr = rs->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }

    if(fstyleWidth == false)
    {
        VariantClear(&styleWidth);
        hr = s->get_width(&styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }

    if(rs != NULL)
    {
        hr = rs->get_height(&styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }

    if(fstyleHeight == false)
    {
        VariantClear(&styleHeight);
        hr = s->get_height( &styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }
    
  done:

    m_fNativeSize = fnativeSize;
    m_fNativeSizeComputed = true;

    VariantClear(&styleWidth);
    VariantClear(&styleHeight);
    VariantClear(&crstyleWidth);
    VariantClear(&crstyleHeight);
 
    return fnativeSize;
}

HRESULT
CTIMEMediaElement::NegotiateSize(RECT &rctNativeSize, RECT &rctFinalSize, bool &fnativeSize, bool fResetRs)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs = NULL;
    CComPtr<IHTMLCurrentStyle> sc;
    CComPtr<IHTMLElement2> pEle2;
    VARIANT styleWidth, styleHeight;
    VARIANT crstyleWidth, crstyleHeight;
    VariantInit(&styleWidth);
    VariantInit(&styleHeight);
    VariantInit(&crstyleWidth);
    VariantInit(&crstyleHeight);
    CComVariant emptyVar;
    BSTR bstrWidth = SysAllocString(L"width");
    BSTR bstrHeight = SysAllocString(L"height");
    VARIANT_BOOL varStat;

    long pixelWidth = 0, pixelHeight = 0;
    RECT rc;
    bool fstyleWidth = false, fstyleHeight = false;
    
    rc.top = rc.left = 0;
    rc.right = rctNativeSize.right;
    rc.bottom = rctNativeSize.bottom;
    fnativeSize = true;

    if(GetElement() == NULL)
    {
        goto done;
    }

    hr = GetElement()->get_style(&s);
    if (FAILED(hr) || s == NULL)
    {
        goto done;
    }
    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        if(fResetRs)
        {
            m_fIgnoreStyleChange = true;
            hr = rs->removeAttribute(bstrWidth, VARIANT_FALSE, &varStat);
            hr = rs->removeAttribute(bstrHeight, VARIANT_FALSE, &varStat);
            m_fIgnoreStyleChange = false;
        }

        hr = pEle2->get_currentStyle(&sc);
        if (FAILED(hr) || sc == NULL)
        {
            goto done;
        }

        hr = sc->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
                fstyleWidth = true;
                if(ConvertToPixels(&styleWidth, L"height"))
                {
                    pixelWidth = styleWidth.fltVal; //lint !e524
                }
                else
                {
                    pixelWidth = rctNativeSize.right;
                }
                rc.right = pixelWidth;
            }
            else
            {
                pixelWidth = rctNativeSize.right;
            }
        }

        hr = sc -> get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
                fstyleHeight = true;
                if(ConvertToPixels(&styleHeight, L"height"))
                {
                    pixelHeight = styleHeight.fltVal; //lint !e524
                }
                else
                {
                    pixelHeight = rctNativeSize.bottom;
                }
                rc.bottom = pixelHeight;

            }
            else
            {
                pixelHeight = rctNativeSize.bottom;
            }
        }

        if(fstyleWidth && !fstyleHeight)
        {
            if (IsNativeSize() == false)
            {
                pixelHeight = rctNativeSize.bottom * ((float )pixelWidth) / ((float )rctNativeSize.right); //lint !e524
            }
            else
            {
                pixelHeight = rctNativeSize.bottom;
            }
            SetHeight(pixelHeight);
        }
        else if(!fstyleWidth && fstyleHeight)
        {
            if (IsNativeSize() == false)
            {
                pixelWidth = rctNativeSize.right * ((float )pixelHeight) / ((float )rctNativeSize.bottom); //lint !e524
            }
            else
            {
                pixelWidth = rctNativeSize.right;
            }
            SetWidth(pixelWidth);
        }
    }


    if(rs != NULL)
    {
        VariantClear(&styleWidth);
        hr = rs->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                    rc.right = pixelWidth;
                    fstyleWidth = true;
                }
            }
        }
    }

    if(fstyleWidth == false)
    {
        VariantClear(&styleWidth);
        hr = s->get_width(&styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                    rc.right = pixelWidth;
                    fstyleWidth = true;
                }
            }
        }
    }

    if(rs != NULL)
    {
        VariantClear(&styleHeight);
        hr = rs->get_height(&styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                    rc.bottom = pixelHeight;
                    fstyleHeight = true;
                }
            }
        }
    }

    if(fstyleHeight == false)
    {
        VariantClear(&styleHeight);
        hr = s->get_height( &styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                    rc.bottom = pixelHeight;
                    fstyleHeight = true;
                }
            }
        }
    }
    
    if (GetParent() &&
        GetParent()->IsSequence())
    {
        // try and grab the parents style...if there is one...
        CComPtr<IHTMLElement> pParentElement = GetParent()->GetElement();
        CComPtr<IHTMLStyle>   pStyle;
        
        hr = pParentElement->get_style(&pStyle);
        if (SUCCEEDED(hr))
        {
            if (false == fstyleWidth)
            {
                hr = pStyle->get_pixelWidth( &pixelWidth);
                if (SUCCEEDED(hr))
                {
                    if (pixelWidth  != 0)
                    {
                        rc.right = pixelWidth;
                        fstyleWidth = true;
                    }
                }
            }
            if (false == fstyleHeight)
            {
                hr = pStyle->get_pixelHeight( &pixelHeight);
                if (SUCCEEDED(hr))
                {           
                    if (pixelHeight != 0)
                    {
                        rc.bottom = pixelHeight;
                        fstyleHeight = true;
                    } 
                }
            }
        }
    }
    
    if(fstyleWidth && !fstyleHeight)
    {
        rc.bottom *= ((float )pixelWidth) / ((float )rctNativeSize.right); //lint !e524
    }
    else if(!fstyleWidth && fstyleHeight)
    {
        rc.right *= ((float )pixelHeight) / ((float )rctNativeSize.bottom); //lint !e524
    }


    hr = S_OK;
done:

    TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::NegotiateSize(%d-%d)",
                  this,
                  rc.right - rc.left,
                  rc.bottom - rc.top));

    memcpy((void*)&m_rcMediaSize, (void*)&rctNativeSize, sizeof(rctNativeSize));
    if(fnativeSize)
    {
        if(rc.bottom != -1 && rc.right != -1)
        {
            THR(SetSize(&rc));
        }
    }
    rctFinalSize = rc;

    VariantClear(&styleWidth);
    VariantClear(&styleHeight);
    VariantClear(&crstyleWidth);
    VariantClear(&crstyleHeight);

    SysFreeString(bstrWidth);
    SysFreeString(bstrHeight);
 
    return hr;
}

HRESULT
CTIMEMediaElement::Error()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Error()",
              this));
    
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>::Error(str, IID_ITIMEMediaElement2, hr);
        delete [] str;
    }

    return hr;
}

STDMETHODIMP
CTIMEMediaElement::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Notify()",
              this));

    HRESULT hr;
    hr = THR(CTIMEElementBase::Notify(event, pVar));

    return hr;
}

STDMETHODIMP
CTIMEMediaElement::Detach()
{
    HRESULT hr;
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Detach()",
              this));

    m_fDetached = true;

    THR(UnInitPropertySink());
    
    if (NULL != GetElement())
    {
        CComPtr<IHTMLElement2> pElem2;
        hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
        if (SUCCEEDED(hr))
        {
            THR(pElem2->detachEvent(L"onresize", this));
            THR(pElem2->detachEvent(L"onmousemove", this));
            THR(pElem2->detachEvent(L"onmouseup", this));
            THR(pElem2->detachEvent(L"onmousedown", this));
        }
    }

    // This should be the done before calling RemovePlayer
    THR(CTIMEElementBase::Detach());

    RemovePlayer();

    m_sp.Release();
    m_spPaintSite.Release();
    m_pBvrSiteRender.Release();

    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::get_src(VARIANT * url)
{
    HRESULT hr;
    
    if (url == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(url))))
    {
        goto done;
    }
    
    V_VT(url) = VT_BSTR;
    V_BSTR(url) = SysAllocString(m_SASrc);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::InitPlayer(CTIMEMediaElement *pelem, 
                              LPOLESTR base, 
                              LPOLESTR src, 
                              LPOLESTR lpMimeType) 
{
    HRESULT hr = S_OK;
    double dblClipBegin = m_FAClipBegin.GetValue();
    double dblClipEnd= m_FAClipEnd.GetValue();
    long lClipBeginFrame = m_LAClipBegin.GetValue();
    long lClipEndFrame = m_LAClipEnd.GetValue();

    //this flag is used to turn elements off at creation.
    //it is not dynamic.
    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }

    if (dblClipEnd != -1 &&
        dblClipBegin != -1 &&
        dblClipEnd <= dblClipBegin)
    {
        dblClipEnd = -1;
    }
    if (lClipBeginFrame != -1 &&
        lClipEndFrame != -1 &&
        lClipEndFrame <= lClipBeginFrame)
    {
        lClipEndFrame = -1;
    }
     
    hr = m_Player->Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if(m_LAClipBegin.IsSet())
    {
        m_FAClipBegin.Reset(-1.0f);
        m_Player->SetClipBeginFrame(lClipBeginFrame);
    }
    if(m_LAClipEnd.IsSet())
    {
        m_FAClipEnd.Reset(-1.0f);
        m_Player->SetClipEndFrame(lClipEndFrame);
    }
    if(!m_fInPropLoad)
    {
        if (m_Player)
        {
            m_Player->ReadyStateNotify(L"OnLoad");
        }
    }

    if (m_Player)
    {
        m_Player->Reset();
    }
  
  done:    
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_src(VARIANT url)
{
    CComVariant v;
    HRESULT hr = E_FAIL;
    bool clearFlag = false;
    CComPtr<IHTMLStyle> rs = NULL;
    CComPtr<IHTMLElement2> pEle2;
    CComBSTR bstrWidth("width");
    CComBSTR bstrHeight("height");
    VARIANT_BOOL varStat;

    if(V_VT(&url) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &url);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    //clear the runtime size so media can resize to natural size.
    if(GetElement() == NULL)
    {
        goto done;
    }

    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        m_fIgnoreStyleChange = true;
        if(bstrWidth != NULL)
        {
            hr = rs->removeAttribute(bstrWidth, VARIANT_FALSE, &varStat);
        }
        if(bstrHeight != NULL)
        {
            hr = rs->removeAttribute(bstrHeight, VARIANT_FALSE, &varStat);
        }
        m_fIgnoreStyleChange = false;
    }

    delete [] m_SASrc.GetValue();

    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_SASrc.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SASrc.Reset(DEFAULT_M_SRC);
    }

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_SRC);


    GetBASEHREF();
    Assert(m_baseHREF != NULL);

    if (m_fLoaded)
    {
        RemovePlayer();
        hr = CreatePlayer(m_playerToken);
        if (FAILED(hr) || !m_Player)
        {
            hr = S_FALSE;
            goto done;
        }

        ClearNaturalDuration();
    }

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANPAUSE);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANSEEK);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASAUDIO);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASVISUAL);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIADUR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYLIST);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CTIMEMediaElement::get_player(VARIANT  * clsid)
{
    HRESULT hr;
    BSTR bstr = NULL;
    
    CHECK_RETURN_NULL(clsid);

    VariantClear(clsid);
    
    if (m_SAPlayer.GetValue() != NULL)
    {
        bstr = SysAllocString(m_SAPlayer.GetValue());
    }
    else if (IsEqualCLSID(m_playerCLSID, GUID_NULL))
    {
        hr = S_OK;
        goto done;
    }
    else
    {
        LPOLESTR ppsz = NULL;

        hr = THR(StringFromCLSID(m_playerCLSID, &ppsz));
        if (FAILED(hr))
        {
            goto done;
        }

        bstr = SysAllocString(ppsz);

        CoTaskMemFree(ppsz);
    }

    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    // set the VT only after above code succeeds
    V_VT(clsid) = VT_BSTR;
    V_BSTR(clsid) = bstr;
        
    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        SysFreeString(bstr);
    }
    
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_player(VARIANT vPlayer)
{
    HRESULT hr = S_OK;
    TOKEN playerTokenOld = m_playerToken;
    CLSID clsidOld = m_playerCLSID;
    
    m_playerToken = NULL;
    m_playerCLSID = GUID_NULL;
    m_SAPlayer.Reset(NULL);

    if(V_VT(&vPlayer) != VT_NULL)
    {
        CComVariant v;

        hr = THR(VariantChangeTypeEx(&v,
                                     &vPlayer,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR));
        if (SUCCEEDED(hr))
        {
            CTIMEParser pParser(&v);
            LPWSTR lpwStr = CopyString(V_BSTR(&v));

            if (lpwStr == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            m_SAPlayer.SetValue(lpwStr);

            IGNORE_HR(pParser.ParsePlayer(m_playerToken, m_playerCLSID));
        }
    }
    
    if (!m_fLoaded ||
        (playerTokenOld == m_playerToken &&
         IsEqualCLSID(clsidOld, m_playerCLSID)))
    {
        hr = S_OK;
        goto done;
    }

    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }
    
    RemovePlayer();

    hr = THR(CreatePlayer(m_playerToken));
    if (FAILED(hr) || !m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    InitOnLoad();
    
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANPAUSE);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANSEEK);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASAUDIO);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASVISUAL);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIADUR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYLIST);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        RemovePlayer();
    }

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYER);

    return hr;
}


STDMETHODIMP
CTIMEMediaElement::get_type(VARIANT * type)
{
    HRESULT hr;
    
    if (type == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(type))))
    {
        goto done;
    }
    
    V_VT(type) = VT_BSTR;
    V_BSTR(type) = SysAllocString(m_SASrcType);

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_type(VARIANT type)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;


    if(V_VT(&type) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &type);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    delete [] m_SASrcType.GetValue();

    //processing the attribute change should be done here
    if(!clearFlag)
    {
        m_SASrcType.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SASrcType.Reset(DEFAULT_M_SRCTYPE);
    }
    
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TYPE);

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_playerObject(IDispatch **ppDisp)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement::get_playerObject"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppDisp);

    if (!m_Player)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = m_Player->GetExternalPlayerDispatch(ppDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;    
}

void 
CTIMEMediaElement::OnLoad()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnLoad()",
              this));

    // Protect against reentrancy due to WMP pumping messages on shutdown,
    // which interferes with Trident's message loop and causes onload to be
    // called a second time in some cases
    if (m_bLoaded)
    {
        goto done;
    }

    CTIMEElementBase::OnLoad();

    if(m_Player)
    {
        m_Player->ReadyStateNotify(L"OnLoad");
    }

done:
    return;
}


void
CTIMEMediaElement::OnTEPropChange(DWORD tePropType)
{

    TraceTag((tagMediaTimeElm,
              "CTIMEElementBase(%lx)::OnTEPropChange(%#x)",
              this,
              tePropType));

    CTIMEElementBase::OnTEPropChange(tePropType);

    
    //this flag is used to turn elements off at creation.
    //it is not dynamic.
    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }

    if(m_Player)
    {
        m_Player->PropChangeNotify(tePropType);
    }
  done:
    return;
}

void
CTIMEMediaElement::OnSeek(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnSeek()",
              this));

    if (m_Player)
    {
        m_Player->Reset();
    }
    
    CTIMEElementBase::OnSeek(dblLocalTime);
}


HRESULT
CTIMEMediaElement::GetSyncMaster(double & dblNewSegmentTime,
                                 LONG & lNewRepeatCount,
                                 bool & bCueing)
{
    TraceTag((tagMediaTimeElmSync,
              "CTIMEMediaElement(%lx)::GetSyncMaster()",
              this));

    HRESULT hr;
    
    if (!m_fLoaded ||
        !m_fCachedSyncMaster ||
        !m_Player)
    {
        bCueing = !m_fLoaded;
        
        hr = S_FALSE;
        TraceTag((tagMediaTimeElmSync,
                  "CTIMEMediaElement(%lx)::GetSyncMaster():Disabled",
                  this));
        goto done;
    }
    
    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());
    
    double dblPlayerTime;
    hr = THR(m_Player->GetCurrentSyncTime(dblPlayerTime));
    if (S_OK != hr)
    {
        TraceTag((tagMediaTimeElmSync,
                  "CTIMEMediaElement(%lx)::GetSyncMaster():Error",
                  this));
        goto done;
    }
    
    if (dblPlayerTime < 0)
    {
        dblPlayerTime = 0;
    }
    
    dblNewSegmentTime = dblPlayerTime;
    lNewRepeatCount = TE_UNDEFINED_VALUE;
    
    if (m_Player &&
        m_Player->GetState() == PLAYER_STATE_CUEING)
    {
        bCueing = true;
    }
    
    TraceTag((tagMediaTimeElmSync,
              "CTIMEMediaElement(%lx)::GetSyncMaster():Enabled(%f)",
              this, dblPlayerTime));
    hr = S_OK;
  done:
    RRETURN2(hr, S_FALSE, E_NOTIMPL);
}

void
CTIMEMediaElement::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnBegin()",
              this));

    CTIMEElementBase::OnBegin(dblLocalTime, flags);
    
    Assert(NULL != m_mmbvr);

    if(m_Player)
    {
        m_Player->Start();
    }   

done:
    return;
}

HRESULT
CTIMEMediaElement::AllowCreateControl(BOOL *fAllowed, REFCLSID clsid)
{
    HRESULT hr = S_OK;
    CComPtr<IElementBehaviorSite> spElementBehaviorSite;
    CComPtr<IServiceProvider> spServProvider;
    CComPtr<IInternetSecurityManager> spSecMan;
    CComPtr<IHTMLDocument2> spDoc2;
    CComPtr<IHTMLLocation> spLocation;
    CComPtr<IDispatch> pDisp;
    CComBSTR pHref;
    DWORD dwPolicy = 0;

    *fAllowed = FALSE;

    spElementBehaviorSite = GetBvrSite();

    hr = THR(spElementBehaviorSite->QueryInterface(IID_TO_PPV(IServiceProvider, &spServProvider)));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spServProvider->QueryService(IID_IInternetSecurityManager, IID_TO_PPV(IInternetSecurityManager, &spSecMan));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&spDoc2));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spDoc2->get_location(&spLocation);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spLocation->get_href(&pHref);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spSecMan->ProcessUrlAction(
                pHref,
                URLACTION_ACTIVEX_RUN,
                (BYTE *)&dwPolicy,
                sizeof(DWORD),
                (BYTE *)&clsid,
                sizeof(CLSID),
                0,
                0));
    if (FAILED(hr))
    {
        goto done;
    }

    *fAllowed = (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW);


done:
    return hr;
}

HRESULT
CTIMEMediaElement::AllowMixedContent(BOOL *fAllow)
{
    HRESULT hr = S_OK;
    CComPtr<ISecureUrlHost> spSecureUrlHost;
	CComPtr<IElementBehaviorSite> spElementBehaviorSite;
    DWORD dwFlags = 0;
    TCHAR pchExpUrl[4096];
    DWORD cchBuf;

    if(m_SASrc.GetValue() == NULL)
    {
        *fAllow = TRUE;
        hr = S_OK;
        goto done;
    }

    spElementBehaviorSite = GetBvrSite();
    hr = THR(spElementBehaviorSite->QueryInterface(IID_TO_PPV(ISecureUrlHost, &spSecureUrlHost)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoInternetCombineUrl(m_baseHREF, m_SASrc.GetValue(), 0xFFFFFFFF,
                                  pchExpUrl, 4096, &cchBuf, 0));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(fAllow, pchExpUrl, dwFlags);

done:
    return hr;
}

void 
CTIMEMediaElement::InitOnLoad()
{
    HRESULT hr = S_OK;

    if(m_fCreatePlayerError)
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        m_fCreatePlayerError = false;
        goto done;
    }

    if (m_fLoaded == false && m_Player)
    {
        BOOL fAllow = FALSE;

        hr = AllowMixedContent(&fAllow);
        if (FAILED(hr) || (fAllow == FALSE))
        {
            FireMediaEvent(PE_ONMEDIAERROR);
            hr = E_FAIL;
            goto done;
        }

        m_fLoaded = true;
        InitPlayer(this, m_baseHREF, m_SASrc, m_SASrcType);
    }
done:
    return;
}

void
CTIMEMediaElement::OnEnd(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnEnd()",
              this));

    CTIMEElementBase::OnEnd(dblLocalTime);
    
    if(m_Player)
    {
        m_Player->Stop();
    }
done:
    return;
}

void 
CTIMEMediaElement::OnUpdate(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnUpdate()",
              this));

    CTIMEElementBase::OnUpdate(dblLocalTime, flags);

    OnReset(dblLocalTime, flags);
    
done:
    return;

}

void
CTIMEMediaElement::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnReset()",
              this));
    
    CTIMEElementBase::OnReset(dblLocalTime, flags);
    
    if(m_Player)
    {
        m_Player->Reset();
    }

  done:

    return;
}

void
CTIMEMediaElement::OnPause(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnPause()",
              this));

    if(m_fWaitForSync && m_fFirstPause)
    {
        m_fFirstPause = false;
        goto done;
    }

    CTIMEElementBase::OnPause(dblLocalTime);

    if(m_Player)
    {
        m_Player->Pause();
    }

  done:
    return;
}

void
CTIMEMediaElement::OnResume(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnResume()",
              this));

    HRESULT hr = S_OK;

    CTIMEElementBase::OnResume(dblLocalTime);
        
    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());
    if(!m_Player)
    {
        goto done;
    }

    // If we can't get either segment time or media length, resume unconditionally,
    // else use the information to decide whether to pause 
    double dblSegmentTime;
    dblSegmentTime= m_mmbvr->GetSimpleTime();

    double dblMediaLength;
    dblMediaLength = 0.0;
    
    hr = THR(m_Player->GetMediaLength(dblMediaLength));
    if (FAILED(hr))
    {
        // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
        dblMediaLength = HUGE_VAL;
    }

    if (dblSegmentTime <= dblMediaLength)
    {        
        if (m_Player)
        {
            m_Player->Resume();
        }
    }
  done:
    return;

} // OnResume

void CTIMEMediaElement::OnRepeat(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnRepeat()",
              this));

    CTIMEElementBase::OnRepeat(dblLocalTime);

    if(m_Player)
    {
        m_Player->Repeat();
    }

  done:
    return;
}

void
CTIMEMediaElement::OnUnload()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnUnload()",
              this));

    if (m_Player)
    {
        // Do an extra addref in case we get released between calls
        DAComPtr<ITIMEBasePlayer> pTmp = m_Player;
    
        pTmp->Stop();
        pTmp->ReadyStateNotify(L"OnUnload");
    }

    CTIMEElementBase::OnUnload();
}

STDMETHODIMP
CTIMEMediaElement::get_clipBegin(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipBegin()",
              this));
    HRESULT hr = S_OK;
    TCHAR pSrcNr[ 20];
    long lClip;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    VariantInit(pvar);
    if(m_FAClipBegin.IsSet())
    {
        pvar->vt = VT_R8;
        pvar->dblVal = m_FAClipBegin;
    }
    else if(m_LAClipBegin.IsSet())
    {
        pvar->vt = VT_BSTR;
        lClip = m_LAClipBegin;
        _itow(lClip, pSrcNr, 10);
        if(lstrlenW(pSrcNr) <= 18)
        {
            StrCatW(pSrcNr, L"f");
        }
        V_BSTR(pvar) = SysAllocString(pSrcNr);
    }
    else
    {
        pvar->vt = VT_R8;
        pvar->dblVal = -1;
    }
    
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_clipBegin(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipBegin()",
              this));
    long lbeginFrame = 0;
    bool fIsFrame= false;

    HRESULT hr = S_OK;
    float beginTime= 0.0;

    // reset to default
    m_FAClipBegin.Reset(-1.0f);
    m_LAClipBegin.Reset(-1);

    hr = VariantToTime(var, &beginTime, &lbeginFrame, &fIsFrame);
    if (FAILED(hr))
    {
        goto done;
    }

    if(!fIsFrame)
    {
        m_FAClipBegin.SetValue(beginTime);
    }
    else
    {
        m_LAClipBegin.SetValue(lbeginFrame);
    }
    
    UpdateClipTimes();

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CLIPBEGIN);
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_clipEnd(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipEnd()",
              this));
    HRESULT hr = S_OK;
    TCHAR pSrcNr[ 20];
    long lClip;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    VariantInit(pvar);
    if(m_FAClipEnd.IsSet())
    {
        pvar->vt = VT_R8;
        pvar->dblVal = m_FAClipEnd;
    }
    else if(m_LAClipEnd.IsSet())
    {
        pvar->vt = VT_BSTR;
        lClip = m_LAClipEnd;
        _itow(lClip, pSrcNr, 10);
        if(lstrlenW(pSrcNr) <= 18)
        {
            StrCatW(pSrcNr, L"f");
        }
        V_BSTR(pvar) = SysAllocString(pSrcNr);
    }
    else
    {
        pvar->vt = VT_R8;
        pvar->dblVal = -1;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_clipEnd(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipEnd()",
              this));
    long lendFrame = 0;
    bool fIsFrame= false;

    HRESULT hr = S_OK;
    float endTime = 0.0;

    // reset to default
    m_FAClipEnd.Reset(-1.0f);
    m_LAClipEnd.Reset(-1);

    hr = VariantToTime(var, &endTime, &lendFrame, &fIsFrame);
    if (FAILED(hr))
    {
        goto done;
    }

    if(!fIsFrame)
    {
        m_FAClipEnd.SetValue(endTime);
    }
    else
    {
        m_LAClipEnd.SetValue(lendFrame);
    }

    UpdateClipTimes();

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CLIPEND);
done:
    return hr;
}

HRESULT
CTIMEMediaElement::GetSize(RECT *prcPos)
{
    return CTIMEElementBase::GetSize(prcPos);
}

HRESULT 
CTIMEMediaElement::SetSize(const RECT *prcPos)
{
    HRESULT hr;

    hr = THR(UnInitPropertySink());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = CTIMEElementBase::SetSize(prcPos);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(InitPropertySink());
    if (FAILED(hr))
    {
        goto done;
    }
    if (m_fIsIE4)
    {
        RECT newRect;
        newRect.left = -1;
        newRect.top = -1;
        newRect.right = prcPos->right;
        newRect.bottom = prcPos->bottom;
        
        hr = m_pBvrSiteRender->Invalidate(&newRect);
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMediaElement::GetRenderInfo(LONG *pdwRenderInfo)
{
    // Return the layers we are interested in drawing
//    *pdwRenderInfo = BEHAVIORRENDERINFO_BEFORECONTENT; //BEHAVIORRENDERINFO_AFTERCONTENT;
    *pdwRenderInfo = BEHAVIORRENDERINFO_AFTERCONTENT | BEHAVIORRENDERINFO_SURFACE;
    return S_OK;
}

bool
CTIMEMediaElement::ToggleTimeAction(bool on)
{
    bool bRet = false;
    bRet = CTIMEElementBase::ToggleTimeAction(on);
    
    if (m_Player && on == false)
    {
        InvalidateElement(NULL);
    }
    return bRet;
}


STDMETHODIMP
CTIMEMediaElement::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagMediaTimeElm,
          "CTIMEMediaElement(%lx)::Draw()",
          this));

    HRESULT hr = S_OK;
    bool bIsActiveInEdit = true;  //only query this if the document is in edit mode. Otherwise assume it is true

    //it is possible that these have already gone away if we are asked to render after receiving the onUnload event.
    if (!m_mmbvr || !m_Player)
    {
        goto done;
    }

    if (m_fEditModeFlag)
    {
        bIsActiveInEdit = m_mmbvr->IsActive();

    }

    if (m_fLoaded && bIsActiveInEdit && !m_fDetached &&
        (m_timeAction.IsTimeActionOn() || GetTimeAction() != NONE_TOKEN) )
    {
        if (m_Player)
        {
            hr = THR(m_Player->Render(hdc, prc));
        }
        else
        {
            hr = S_OK;
        }
    }
done:
    return hr;        
}


STDMETHODIMP
CTIMEMediaElement::HitTestPoint(LPPOINT point,
                       IUnknown *pReserved,
                       BOOL *hit)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::HitTestPoint()",
              this));

    *hit = FALSE;

    return S_OK;
}

void scalePoint( long &x, long &y, HTML_PAINT_DRAW_INFO &DrawInfo)
{
    long xtemp, ytemp;

    xtemp = x * DrawInfo.xform.eM11 + y * DrawInfo.xform.eM21 + DrawInfo.xform.eDx; //lint !e524
    ytemp = x * DrawInfo.xform.eM12 + y * DrawInfo.xform.eM22 + DrawInfo.xform.eDy; //lint !e524

    x = xtemp;
    y = ytemp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IHTMLPainter
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CTIMEMediaElement::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Draw()",
              this));

    HRESULT hr = S_OK;
    bool bIsActiveInEdit = true;  //only query this if the document is in edit mode. Otherwise assume it is true

    //it is possible that these have already gone away if we are asked to render after receiving the onUnload event.
    if (   (!m_mmbvr) || (!m_Player) 
        || (GetMMBvr().GetEnabled() == false) 
        || (GetDrawFlag() == VARIANT_FALSE))
    {
        goto done;
    }

    if (m_fEditModeFlag)
    {
        bIsActiveInEdit = m_mmbvr->IsActive();

    }

    if (HTMLPAINT_DRAW_USE_XFORM == lDrawFlags)
    {
        HTML_PAINT_DRAW_INFO DrawInfo;

        hr = m_spPaintSite->GetDrawInfo(HTMLPAINT_DRAWINFO_XFORM, &DrawInfo);

        TraceTag((tagMediaTimeElm, "xform DrawInfo: eM11:%g eM12:%g eM21:%g eM22:%g eDx:%g eDy:%g", DrawInfo.xform.eM11, DrawInfo.xform.eM12, DrawInfo.xform.eM21, DrawInfo.xform.eM22, DrawInfo.xform.eDx, DrawInfo.xform.eDy));
    
        if( (DrawInfo.xform.eM12 == 0) && (DrawInfo.xform.eM21 == 0))
        {
            TraceTag((tagError, "xform scale"));
            scalePoint(rcBounds.left, rcBounds.top, DrawInfo);
            scalePoint(rcBounds.right, rcBounds.bottom, DrawInfo);
        }
    }
    if (m_fLoaded && bIsActiveInEdit && !m_fDetached &&
        (m_timeAction.IsTimeActionOn() || GetTimeAction() != NONE_TOKEN) )
    {
        TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::PlayerDraw()",
                  this));
        if (m_Player)
        {
            hr = THR(m_Player->Render(hdc, &rcBounds));
        }
        else
        {
            hr = S_OK;
        }
    }
done:
    return hr;       
}


STDMETHODIMP
CTIMEMediaElement::OnMove(RECT rcDevice)
{
    HRESULT hr = S_OK;


    return hr;
}



STDMETHODIMP
CTIMEMediaElement::GetPainterInfo(HTML_PAINTER_INFO* pInfo)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::GetPainterInfo()",
              this));

    HRESULT hr = S_OK;

    if (NULL == pInfo)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pInfo->lFlags  |= HTMLPAINTER_SURFACE;
    pInfo->lFlags  |= HTMLPAINTER_SUPPORTS_XFORM;
    pInfo->lFlags  |= HTMLPAINTER_HITTEST;

    pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_FLOW;
    SetRect(&pInfo->rcExpand, 0, 0, 0, 0);

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::HitTestPoint(POINT pt, BOOL* pbHit, LONG *plPartID)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::HitTestPoint()",
              this));
    
    *pbHit = TRUE;
    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::OnResize(SIZE size)
{
    return S_OK;
}

void
CTIMEMediaElement::InvalidateRenderInfo()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::InvalidateRenderInfo",
              this));

    if (m_spPaintSite)
    {
        m_spPaintSite->InvalidatePainterInfo();
    }
    else if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->InvalidateRenderInfo();
    }

}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::OnPropertiesLoaded, CBaseBvr
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEMediaElement::OnPropertiesLoaded(void)
{
    HRESULT hr;
    // Once we've read the properties in, 
    // set up the timeline.  This is immutable
    // in script.
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::OnPropertiesLoaded"));

    m_fInPropLoad = true;
    hr = CTIMEElementBase::OnPropertiesLoaded();
    m_fInPropLoad = false;

    if (!m_fLoaded)
    {
        hr = CreatePlayer(m_playerToken);
        if (FAILED(hr) || !m_Player)
        {
            goto done;
        }

        if (GetElement())
        {
            CComBSTR pbstrReadyState;
            IHTMLElement *pEle = GetElement();
            hr = GetReadyState(pEle, &pbstrReadyState);
            if (FAILED(hr))
            {
                goto done;
            }
            if (StrCmpIW(pbstrReadyState, L"complete") == 0)
            {
                InitOnLoad();
                OnLoad();
            }
        }
    }

done:
    return hr;
} // OnPropertiesLoaded


//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

STDMETHODIMP
CTIMEMediaElement::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

bool
CTIMEMediaElement::NeedSizeChange()
{
    HRESULT hr = S_OK;
    bool bAutoSize = false;
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs;
    CComPtr<IHTMLCurrentStyle> sc;
    CComPtr<IHTMLElement2> pEle2;
    VARIANT styleWidth, styleHeight;
    
    VariantInit(&styleWidth);
    VariantInit(&styleHeight);

    hr = GetElement()->get_style(&s);
    if (FAILED(hr) || s == NULL)
    {
        goto done;
    }
    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_currentStyle(&sc);
        if (FAILED(hr) || sc == NULL)
        {
            goto done;
        }
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        hr = sc->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

        hr = sc -> get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

        VariantClear(&styleWidth); 
        hr = rs->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

        VariantClear(&styleHeight);
        hr = rs->get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

    }


done:

    VariantClear(&styleWidth);
    VariantClear(&styleHeight);

    return bAutoSize;
}

STDMETHODIMP
CTIMEMediaElement::OnChanged(DISPID dispID)
{
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs = NULL;
    CComPtr<IHTMLElement2> pEle2;
    HRESULT hr = S_OK;
    CComVariant svarStyleWidth, svarStyleHeight;
    long pixelWidth = 0, pixelHeight = 0;
    bool fstyleWidth = false, fstyleHeight = false;
    RECT rNativeSize, rElementSize;
    bool fisNative;

    if( m_fInOnChangedFlag)
        return S_OK;

    m_fInOnChangedFlag = true;

    switch(dispID)
    {
    case DISPID_IHTMLCURRENTSTYLE_TOP:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():TOP", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_LEFT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():LEFT", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_WIDTH:
    case DISPID_IHTMLCURRENTSTYLE_HEIGHT:
        if(m_fIgnoreStyleChange)
        {
            break;
        }
        if (m_rcMediaSize.right != 0 && m_rcMediaSize.bottom != 0 && NeedSizeChange() == true)
        {
            bool bNativeSize;
            RECT rcFinalSize;
            NegotiateSize(m_rcMediaSize, rcFinalSize, bNativeSize);
        }       
        break;
    case DISPID_IHTMLSTYLE_CSSTEXT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():TEXT", this));
        
        hr = GetElement()->get_style(&s);
        if (FAILED(hr) || s == NULL)
        {
            goto done;
        }
        hr = s->get_width( &svarStyleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((svarStyleWidth.vt == VT_BSTR) && (svarStyleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(svarStyleWidth.bstrVal, L"auto") != 0)
            {
                fstyleWidth = true;
                if(ConvertToPixels(&svarStyleWidth, L"width"))
                {
                    pixelWidth = svarStyleWidth.fltVal; //lint !e524
                    SetWidth(pixelWidth);
                }
            }
        }

        hr = s -> get_height( &svarStyleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((svarStyleHeight.vt == VT_BSTR) && (svarStyleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(svarStyleHeight.bstrVal, L"auto") != 0)
            {
                fstyleHeight = true;
                if(ConvertToPixels(&svarStyleHeight, L"height"))
                {
                    pixelHeight = svarStyleHeight.fltVal; //lint !e524
                    SetHeight(pixelHeight);
                }
            }
        }

        if(fstyleHeight || fstyleWidth)
        {
            goto done;
        }

        if(!m_Player)
        {
            goto done;
        }

        rNativeSize.top = rNativeSize.left = 0;

        hr = m_Player->GetNaturalWidth(&(rNativeSize.right));
        if(FAILED(hr) || rNativeSize.right == -1)
        {
            goto done;
        }
        hr = m_Player->GetNaturalHeight(&(rNativeSize.bottom));
        if(FAILED(hr) || rNativeSize.bottom == -1)
        {
            goto done;
        }
        VariantClear(&svarStyleWidth);
        VariantClear(&svarStyleHeight);
        hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
        if(FAILED(hr))
        {
            goto done;
        }

        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        svarStyleWidth = L"auto";
        svarStyleHeight = L"auto";

        IGNORE_HR(rs->put_width(svarStyleWidth));
        IGNORE_HR(rs->put_height(svarStyleHeight));

        NegotiateSize( rNativeSize, rElementSize, fisNative);

        break;
    default:
        break;
    }
done:
    m_fInOnChangedFlag = false;
    return hr;
}


HRESULT
CTIMEMediaElement::GetNotifyConnection(IConnectionPoint **ppConnection)
{
    HRESULT hr = S_OK;

    Assert(ppConnection != NULL);
    *ppConnection = NULL;

    IConnectionPointContainer *pContainer = NULL;
    IHTMLElement *pElement = GetElement();

    // Get connection point container
    hr = pElement->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pContainer));
    if(FAILED(hr))
        goto end;
    
    // Find the IPropertyNotifySink connection
    hr = pContainer->FindConnectionPoint(IID_IPropertyNotifySink, ppConnection);
    if(FAILED(hr))
        goto end;

end:
    ReleaseInterface( pContainer );

    return hr;
}

//*****************************************************************************

/**
* Initializes a property sink on the current style of the animated element so that
* can observe changes in width, height, visibility, zIndex, etc.
*/
HRESULT
CTIMEMediaElement::InitPropertySink()
{
    HRESULT hr = S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr))
        return hr;

    // Advise on it
    hr = pConnection->Advise(GetUnknown(), &m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

HRESULT
CTIMEMediaElement::UnInitPropertySink()
{
    HRESULT hr = S_OK;

    if (m_dwAdviseCookie == 0)
        return S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr) || pConnection == NULL )
        return hr;

    // Unadvise on it
    hr = pConnection->Unadvise(m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    m_dwAdviseCookie = 0;

    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::Invoke( DISPID id,
                           REFIID riid,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pDispParams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pExcepInfo,
                           UINT *puArgErr)
{
    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLEventObj> pEventObj;
    CComPtr<IHTMLElement2> pElem2;
    HRESULT hr = S_OK;
    CComBSTR bstrEventName;
    RECT elementRect;

    long mousex = 0;
    long mousey = 0;


    if (id != 0) // we are only proccesing the onresize event. For other event we call the parent method.
    {
        hr = ITIMEDispatchImpl<ITIMEMediaElement2, &IID_ITIMEMediaElement2>::Invoke(
                            id, riid, lcid, wFlags, pDispParams, pvarResult, pExcepInfo, puArgErr);
        goto done;
    }

    hr = THR(GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&pWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWindow->get_event(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pEventObj->get_type(&bstrEventName);
    if (FAILED(hr))
    {
        goto done;
    }

    if (StrCmpIW(bstrEventName, L"resize") == 0)
    {
        TraceTag((tagMediaTimeElm, "CTIMEMediaElement::Invoke::resize"));

        hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
        if (FAILED(hr))
        {
            goto done;       
        }

        long lPixelWidth, lPixelHeight;

        hr = pElem2->get_clientWidth(&lPixelWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = pElem2->get_clientHeight(&lPixelHeight);
        if (FAILED(hr))
        {
            goto done;
        }

        elementRect.top = elementRect.left = 0;
        elementRect.right = lPixelWidth;
        elementRect.bottom = lPixelHeight;

        if(!m_Player) 
        {
            hr = E_FAIL;
            goto done;
        }
        hr = THR(m_Player -> SetSize(&elementRect));
    }
    else if (StrCmpIW(bstrEventName, L"scroll") == 0)
    {
    }
    else if (StrCmpIW(bstrEventName, L"mousemove") == 0)
    {
        pEventObj -> get_offsetX(&mousex);
        pEventObj -> get_offsetY(&mousey);
        TraceTag((tagMediaTimeElm, "CTIMEMediaElement::Invoke..mosemove %d %d", mousex, mousey));
    }

    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::UpdatePlayerAudioProperties, CTIMEElementBase
//
//  Synopsis:   This method is implemented by elements directly affected by audio
//              properties. It forces the cascaded volume and mute to be set on
//              the player.
//              
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
void 
CTIMEMediaElement::UpdatePlayerAudioProperties()
{
    CascadedPropertyChanged(false);
} // UpdatePlayerAudioProperties


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::CascadedPropertyChanged, CTIMEElementBase
//
//  Synopsis:   This method is implemented by elements directly affected by cascaded
//              properties. Cascaded volume/mute are first computed by recursing up
//              till the root, and then set on the player object. If the fNotifyChildren
//              argument is true, the notification is propagated to all our children.
//
//  Arguments:  [fNotifyChildren]   flag that indicates whether to propagate this notification
//                                  to children
//
//  Returns:    Failure     1. Properties could not be set on the player
//                          2. CTIMEElementBase::CascadedPropertyChanged failed
//
//              S_FALSE     Player has not yet been set
//
//              S_OK        Otherwise
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEMediaElement::CascadedPropertyChanged(bool fNotifyChildren)
{
    HRESULT hr;
    float   flVolume;
    bool    fMute;

    // this function maybe called before player has been set
    if (!m_Player || (GetMMBvr().GetEnabled() == false))
    {
        hr = S_FALSE;
        goto done;
    }

    GetCascadedAudioProps(&flVolume, &fMute);

    // set volume and mute
    if (m_Player)
    {
        IGNORE_HR(m_Player->SetVolume(flVolume));
    }

    if (m_Player)
    {
        IGNORE_HR(m_Player->SetMute(fMute ? VARIANT_TRUE : VARIANT_FALSE));
    }

    hr = S_OK;
done:
    // notify children always
    hr = THR(CTIMEElementBase::CascadedPropertyChanged(fNotifyChildren));

    return hr;
} // cascadedPropertyChanged


STDMETHODIMP 
CTIMEMediaElement::get_canSeek(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    HRESULT hr = S_OK;
    bool fcanSeek = false;

    CHECK_RETURN_NULL(pvbVal);
    *pvbVal = VARIANT_FALSE;

    if(!m_Player)
    {
        goto done;
    }

    hr = m_Player->CanSeek(fcanSeek);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    if (fcanSeek)
    {
        *pvbVal = VARIANT_TRUE;
    }
    else
    {
        *pvbVal = VARIANT_FALSE;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP 
CTIMEMediaElement::get_canPause(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    HRESULT hr = S_OK;
    bool bIsBroad;

    CHECK_RETURN_NULL(pvbVal);
    *pvbVal = VARIANT_FALSE;

    if(!m_Player)
    {
        goto done;
    }
    hr = m_Player->IsBroadcast(bIsBroad);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    if (bIsBroad)
    {
        *pvbVal = VARIANT_FALSE;
    }
    else
    {
        *pvbVal = VARIANT_TRUE;
    }

done:
    return S_OK;
}

STDMETHODIMP 
CTIMEMediaElement::get_title(/*[out, retval]*/ BSTR *name)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(name);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetTitle(name);
done:
    if (FAILED(hr))
    {
        *name = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_copyright(/*[out, retval]*/ BSTR *cpyrght)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(cpyrght);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetCopyright(cpyrght);
done:
    if (FAILED(hr))
    {
        *cpyrght = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_hasAudio(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    bool fhasAudio;
    CHECK_RETURN_NULL(pvbVal);
    HRESULT hr = S_OK;

    *pvbVal = VARIANT_FALSE;

    if(m_Player)
    {
        hr = m_Player->HasAudio(fhasAudio);
        if(FAILED(hr))
        {
            *pvbVal = VARIANT_FALSE;
            goto done;
        }
        if(fhasAudio)
        {
            *pvbVal = VARIANT_TRUE;
        }
        else
        {
            *pvbVal = VARIANT_FALSE;
        }
    }
done:
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_hasVisual(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    bool fhasVisual;
    CHECK_RETURN_NULL(pvbVal);
    HRESULT hr = S_OK;

    *pvbVal = VARIANT_FALSE;

    if(m_Player)
    {
        hr = m_Player->HasVisual(fhasVisual);
        if(FAILED(hr))
        {
            *pvbVal = VARIANT_FALSE;
            goto done;
        }
        if(fhasVisual)
        {
            *pvbVal = VARIANT_TRUE;
        }
        else
        {
            *pvbVal = VARIANT_FALSE;
        }
    }
done:
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_author(/*[out, retval]*/ BSTR *auth)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(auth);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetAuthor(auth);
done:
    if (FAILED(hr))
    {
        *auth = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_abstract(/*[out, retval]*/ BSTR *abstract)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(abstract);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetAbstract(abstract);
done:
    if (FAILED(hr))
    {
        *abstract = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_rating(/*[out, retval]*/ BSTR *rate)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(rate);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetRating(rate);
done:
    if (FAILED(hr))
    {
        *rate = SysAllocString(L"");
    }
    return S_OK;
}

//Playlist methods
STDMETHODIMP
CTIMEMediaElement::get_playList(/*[out, retval]*/ ITIMEPlayList** ppPlayList)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(ppPlayList);

    //
    // Do lazy creation of playlist object
    //

    if (!m_pPlayListDelegator)
    {
        CComObject<CPlayListDelegator> * pPlayListDelegator = NULL;

        // create the object
        hr = THR(CComObject<CPlayListDelegator>::CreateInstance(&pPlayListDelegator));
        if (FAILED(hr))
        {
            goto done;
        }
    
        // cache a pointer to the PlayList Delegator object
        pPlayListDelegator->AddRef();
        m_pPlayListDelegator = static_cast<CPlayListDelegator*>(pPlayListDelegator);

        // init the playlist
        if (m_Player)
        {
            CComPtr<ITIMEPlayList> spPlayList;

            hr = THR(m_Player->GetPlayList(&spPlayList));
            if (FAILED(hr) && hr != E_NOTIMPL)
            {
                THR(m_pPlayListDelegator->QueryInterface(IID_TO_PPV(ITIMEPlayList, ppPlayList)));
                hr = S_OK;
                goto done;
            }

            m_pPlayListDelegator->AttachPlayList(spPlayList);
        }
    }

    // return the requested interface
    hr = THR(m_pPlayListDelegator->QueryInterface(IID_TO_PPV(ITIMEPlayList, ppPlayList)));
    if (FAILED(hr))
    {
        // this should not happen
        Assert(false);
        goto done;
    }

    hr = S_OK;

  done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::get_hasPlayList(VARIANT_BOOL * pvbVal)
{
    CHECK_RETURN_NULL(pvbVal);
    
    *pvbVal = VARIANT_FALSE;

    if (m_Player)
    {
        bool fHasPlayList = false;
        IGNORE_HR(m_Player->HasPlayList(fHasPlayList));
        *pvbVal = (fHasPlayList ? VARIANT_TRUE : VARIANT_FALSE);
    }

    return S_OK;
}

STDMETHODIMP 
CTIMEMediaElement::get_mediaWidth(long *width)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(width);

    *width = -1;
    
    
    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if (m_Player)
    {
        hr = THR(m_Player->GetNaturalWidth(width));
        if (FAILED(hr))
        {
            *width = -1;
            hr = S_OK;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEMediaElement::get_mediaDur(double *dblDuration)
{
    HRESULT hr;

    CHECK_RETURN_NULL(dblDuration);

    *dblDuration = -1.0;

    if ((GetMMBvr().GetEnabled() == false))
    {
        hr = S_OK;
        goto done;
    }

    if (m_Player)
    {
        hr = THR(m_Player->GetMediaLength(*dblDuration));
        if (FAILED(hr))
        {
            *dblDuration = -1.0;
            hr = S_OK;
            goto done;
        }
        
        if (*dblDuration == 0.0)
        {
            bool bUnresolved = true;
            TimeValueSTLList & l = m_realEndValue.GetList();
            for (TimeValueSTLList::iterator iter = l.begin();
                 iter != l.end();
                 iter++)
            {
                TimeValue *p = (*iter);

                if (p->GetEvent() == NULL)
                {
                    bUnresolved = false;
                }        
            }

            if (bUnresolved == true)
            {
                *dblDuration = HUGE_VAL;
            }
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEMediaElement::get_mediaHeight(long *height)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(height);

    *height = -1;

    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if (m_Player)
    {
        hr = THR(m_Player->GetNaturalHeight(height));
        if (FAILED(hr))
        {
            *height = -1;
            hr = S_OK;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

void 
CTIMEMediaElement::FireMediaEvent(PLAYER_EVENT plEvent)
{
    //This should mean that a new list is available so the old one has to be cleared.
    //need to clear the natural duration of the element
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    switch(plEvent)
    {
      case PE_ONTRACKCOMPLETE:
        UpdatePlayerAudioProperties();
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
        break;
      case PE_ONMEDIACOMPLETE:
        if (m_pPlayListDelegator)
        {
            CComPtr<ITIMEPlayList> spPlayList;

            hr = THR(m_Player->GetPlayList(&spPlayList));
            if (FAILED(hr))
            {
                hr = S_OK;
                goto done;
            }

            m_pPlayListDelegator->AttachPlayList(spPlayList);
        }

        IGNORE_HR(FireEvents(TE_ONMEDIACOMPLETE, 0, NULL, NULL));
        FireTrackChangeEvent();
        UpdatePlayerAudioProperties();
        if (m_Player)
        {
            double dblLength = 0.0;
            hr = m_Player->GetMediaLength(dblLength);
            if (FAILED(hr))
            {
                goto done;
            }
            if (dblLength == 0.0 && m_FADur.IsSet() == false)
            {
                m_FADur.InternalSet(0.0);
            }
            NotifyPropertyChanged(DISPID_TIMEELEMENT_DUR);
        }
        break;
      case PE_ONMEDIAEND:
        break;
      case PE_ONMEDIAINSERTED:
        IGNORE_HR(FireEvents(TE_ONMEDIAINSERTED, 0, NULL, NULL));
        break;
      case PE_ONMEDIAREMOVED:
        IGNORE_HR(FireEvents(TE_ONMEDIAREMOVED, 0, NULL, NULL));
        break;
      case PE_ONMEDIALOADFAILED:
        break;
      case PE_ONRESIZE:
        break;
      case PE_ONMEDIATRACKCHANGED:
        NotifyTrackChange();
        FireTrackChangeEvent();
        break;
      case PE_METAINFOCHANGED:
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
        break;
      case PE_ONMEDIASLIPSLOW:
        TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::PE_ONMEDIASLIPSLOW()",
                  this));
        if(!IsSyncMaster())
        {
            fHaveTESpeed = GetTESpeed(flTeSpeed);
            if(fHaveTESpeed && (flTeSpeed < 0.0))
            {
                break;
            }
            IGNORE_HR(PauseTimeSubTree());
        }
        else
        {
            m_fWaitForSync = true;
        }
        IGNORE_HR(FireEvents(TE_ONOUTOFSYNC, 0, NULL, NULL));
        break;
      case PE_ONMEDIASLIPFAST:
        TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::PE_ONMEDIASLIPFAST()",
                  this));
        if(!IsSyncMaster())
        {
            fHaveTESpeed = GetTESpeed(flTeSpeed);
            if(fHaveTESpeed && (flTeSpeed < 0.0))
            {
                break;
            }
            m_fPauseForSync = true;
            m_Player->Pause();
            m_pSyncElem = this;
        }
        else
        {
            m_fPauseForSync = true;
        }
        IGNORE_HR(FireEvents(TE_ONOUTOFSYNC, 0, NULL, NULL));
        break;
      case PE_ONSYNCRESTORED:
        IGNORE_HR(FireEvents(TE_ONSYNCRESTORED, 0, NULL, NULL));
        break;
      case PE_ONMEDIAERRORCOLORKEY:
        //IGNORE_HR(FireEvents(TE_ONMEDIAERROR, 0, NULL, NULL));
        m_Player->LoadFailNotify(PE_ONMEDIAERRORCOLORKEY);
        break;
      case PE_ONMEDIAERRORRENDERFILE:
        IGNORE_HR(FireEvents(TE_ONMEDIAERROR, 0, NULL, NULL));
        m_Player->LoadFailNotify(PE_ONMEDIAERRORRENDERFILE);
        break;
      case PE_ONMEDIAERROR:
        IGNORE_HR(FireEvents(TE_ONMEDIAERROR, 0, NULL, NULL));
        if (IsSyncMaster())
        {
            PutCachedSyncMaster(false);
        }

        if ((m_FARepeatDur.IsSet() != m_FARepeat.IsSet()) &&
            (m_FADur.IsSet() == false) &&
            (m_SAEnd.IsSet() == false))
        {
            GetMMBvr().Disable();
        }
        else
        {
            GetMMBvr().PutNaturalDur(0.0);
        }

        break;
      case PE_ONCODECERROR:
        IGNORE_HR(FireEvents(TE_ONCODECERROR, 0, NULL, NULL));
        break;
      default:
        break;
    }
  done:
    return;
}

HRESULT
CTIMEMediaElement::PauseTimeSubTree()
{
    CTIMEElementBase *pelem = this;
    HRESULT hr = S_OK;
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::PauseTimeSubTree()",
              this));

    while(pelem)
    {
        if(!pelem->IsLocked())
        {
            break;
        }
        pelem = pelem -> GetParent();
    }

    if(pelem == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = pelem->QueryInterface(IID_ITIMEElement, (void **)&m_pSyncNode);
    if(SUCCEEDED(hr))
    {
        m_fWaitForSync = true;
        m_fFirstPause = true;
        pelem->base_pauseElement();
        m_pSyncElem = pelem;
    }

    hr = S_OK;

done:
    return hr;
}

void
CTIMEMediaElement::UpdateSync()
{
    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if(m_Player && m_fWaitForSync)
    {
        if(m_Player->UpdateSync())
        {
            TraceTag((tagMediaTimeElm,
                      "CTIMEMediaElement(%lx)::UpdateSync():ResumeSlow",
                      this));
            if(!IsSyncMaster())
            {
                if (m_pSyncElem != NULL)
                {
                    m_pSyncElem->base_resumeElement();
                    m_pSyncElem = NULL;
                    m_pSyncNode = NULL;
                }
            }
            FireMediaEvent(PE_ONSYNCRESTORED);
            m_fWaitForSync = false;
        }
    }
    else if(m_Player && m_fPauseForSync)
    {
        if(m_Player->UpdateSync())
        {
            TraceTag((tagMediaTimeElm,
                      "CTIMEMediaElement(%lx)::UpdateSync():ResumeFast",
                      this));
            if(!IsSyncMaster())
            {
                m_Player->Resume();
                m_pSyncElem = NULL;
            }
            m_fPauseForSync = false;
            FireMediaEvent(PE_ONSYNCRESTORED);
        }
    }
    if(m_Player)
    {
        m_Player->Tick();
    }
  done:
    return;
}


void 
CTIMEMediaElement::FireTrackChangeEvent()
{
    CComPtr<ITIMEPlayItem> pPlayItem;
    CComPtr<ITIMEPlayItem2> pPlayItem2;
    CComPtr<ITIMEPlayList> pPlayList;
    HRESULT hr = S_OK;
    static LPWSTR pNames[] = {L"Banner", L"Abstract", L"MoreInfo"};
    VARIANTARG pvars[3];
    bool bHasPlayList = false;

    pvars[0].vt = VT_I4;
    pvars[1].vt = VT_I4;
    pvars[2].vt = VT_I4;

    hr = m_Player->HasPlayList(bHasPlayList);

    if(FAILED(hr) || (!bHasPlayList))
    {
        goto done;
    }

    if (m_pPlayListDelegator == NULL)
    {
        hr = get_playList(&pPlayList);
        if (FAILED(hr) || m_pPlayListDelegator == NULL)
        {
            goto done;
        }
    }

    if (m_pPlayListDelegator)
    {
        CComPtr<ITIMEPlayList> spPlayList;

        hr = THR(m_Player->GetPlayList(&spPlayList));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        m_pPlayListDelegator->AttachPlayList(spPlayList);
    }

    hr = m_pPlayListDelegator->get_activeTrack(&pPlayItem);
    if (FAILED(hr))
    {
        goto done;
    }

    if (pPlayItem != NULL)
    {
        hr = THR(pPlayItem->QueryInterface(IID_ITIMEPlayItem2, (void **)&pPlayItem2));
        if (FAILED(hr))
        {
            goto done;
        }
    
        hr = pPlayItem2->get_banner(&(pvars[0].bstrVal));
        if (FAILED(hr))
        {
            goto done;
        }
        pvars[0].vt = VT_BSTR;

        hr = pPlayItem2->get_bannerAbstract(&(pvars[1].bstrVal));
        if (FAILED(hr))
        {
            goto done;
        }
        pvars[1].vt = VT_BSTR;

        hr = pPlayItem2->get_bannerMoreInfo(&(pvars[2].bstrVal));
        if (FAILED(hr))
        {
            goto done;
        }
        pvars[2].vt = VT_BSTR;
    

        IGNORE_HR(FireEvents(TE_ONTRACKCHANGE, 3, pNames, pvars));
        }
    
  done:

    if (pvars[0].vt == VT_BSTR)
    {
        SysFreeString(pvars[0].bstrVal);
        pvars[0].bstrVal = NULL;
    }
    
    if (pvars[1].vt == VT_BSTR)
    {
        SysFreeString(pvars[1].bstrVal);
        pvars[1].bstrVal = NULL;
    }
    
    if (pvars[2].vt == VT_BSTR)
    {
        SysFreeString(pvars[2].bstrVal);
        pvars[2].bstrVal = NULL;
    }
    return;

}

void 
CTIMEMediaElement::NotifyTrackChange()
{
    NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK);

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
}


void 
CTIMEMediaElement::GetBASEHREF()
{
    HRESULT hr;
    long nLength,index;

    CComPtr<IDispatch>              spDisp;
    CComPtr<IHTMLDocument2>         spDoc;
    CComPtr<IHTMLElementCollection> spChildrenElementCollection;
    CComPtr<IHTMLElementCollection> spBASEElementCollection;
    CComPtr<IDispatch>              spChildrenDisp;
    CComPtr<IDispatch>              spElementDisp;
    CComPtr<IHTMLElement>           spElement;
    CComBSTR                        bstrBASE  = L"BASE";
    CComBSTR                        bstrHREF  = L"href";
    CComVariant                     varName(bstrBASE);
    CComVariant                     varIndex;
    CComVariant                     varValue;

 
    if (m_baseHREF)
    {
        delete m_baseHREF;
        m_baseHREF = NULL;
    }

    if (!GetElement())
    {
        goto done;
    }

    hr = THR(GetElement()->get_document(&spDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spDisp->QueryInterface(IID_IHTMLDocument2, (void **)&spDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDoc->get_all(&spChildrenElementCollection);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spChildrenElementCollection->tags(varName,&spChildrenDisp);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = spChildrenDisp->QueryInterface(IID_TO_PPV(IHTMLElementCollection, &spBASEElementCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    varIndex.Clear();
    varName.Clear();
    varIndex = 0;

    spBASEElementCollection->get_length(&nLength);

    for (index = 0; index < nLength; index++)
    {
        varIndex = index;
        varValue.Clear();
        hr = spBASEElementCollection->item(varName, varIndex, &spElementDisp);
        if (FAILED(hr))
        {
            goto done;
        }
   
        hr = spElementDisp->QueryInterface(IID_TO_PPV(IHTMLElement, &spElement));
        if (FAILED(hr))
        {
            goto done;
        }
   
        hr = spElement->getAttribute(bstrHREF,NULL, &varValue);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (varValue.bstrVal != NULL)
        {
            m_baseHREF = CopyString(varValue.bstrVal);
            goto done;
        }
    }

    if (m_baseHREF == NULL)
    {
        CComPtr<IHTMLDocument2> pDoc;
        CComPtr<IDispatch> pDisp;
        BSTR tempBstr = NULL;

        hr = THR(GetElement()->get_document(&pDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
        if (FAILED(hr))
        {
            goto done;
        }

        pDoc->get_URL(&tempBstr);
        m_baseHREF = CopyString(tempBstr);
        SysFreeString(tempBstr);
    }
done:
    return; 
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::GetTimeState
//
//  Synopsis:   Gets timeState from the base class (active, inactive or holding), and
//              if that is "active", checks for media specific sub-states (cueing, seeking)
//
//  Arguments:  
//
//  Returns:    
//
//------------------------------------------------------------------------------------

TimeState
CTIMEMediaElement::GetTimeState()
{ 
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::GetTimeState()",
              this));

    TimeState ts = CTIMEElementBase::GetTimeState();

    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    // 
    // If time node is active check player for sub-states (cueing, seeking)
    //

    if (TS_Active != ts)
    {
        goto done;
    }
    
    // check if cueing or seeking
    if (m_Player)
    {
        PlayerState playerState;

        playerState = m_Player->GetState();

        switch (playerState)
        {
          case PLAYER_STATE_CUEING:
            {
                ts = TS_Cueing;
                break;
            }

          case PLAYER_STATE_ACTIVE:
            {
                // do nothing (state is already set to active)
                break;
            }

          case PLAYER_STATE_SEEKING:
            {
                //
                // ISSUE: dilipk 9/21/99: need to hook this up (#88122)
                //

                Assert(false);
                break;
            }

          default:
            {
                // This can happen if the player cannot play the
                // media.  In this case just return active
                break;
            }
        } // switch
    }

  done:
    return ts;
}

void
CTIMEMediaElement::ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool &fPlayAnimations)
{
    Assert(GetBody());
    GetBody()->ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
}

STDMETHODIMP
CTIMEMediaElement::Load(IPropertyBag2 *pPropBag, IErrorLog *pErrorLog)
{
    HRESULT hr = S_OK;

    m_fLoading = true;

    m_spPropBag = pPropBag;
    m_spErrorLog = pErrorLog;

    hr = THR(::TimeLoad(this, CTIMEMediaElement::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Load(pPropBag, pErrorLog)); 
done:
    m_spPropBag.Release();
    m_spErrorLog.Release();
    
    m_fLoading = false;

    return hr;
}

STDMETHODIMP
CTIMEMediaElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    IGNORE_HR(::TimeSave(this, CTIMEMediaElement::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));

    IGNORE_HR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));

    if (m_Player)
    {
        IGNORE_HR(m_Player->Save(pPropBag, fClearDirty, fSaveAllProperties));
    }
done:
    return S_OK;
}

HRESULT
CTIMEMediaElement::GetPropBag(IPropertyBag2 ** ppPropBag, IErrorLog ** ppErrorLog)
{
    HRESULT hr = S_OK;

    if (NULL == ppPropBag || NULL == ppErrorLog)
    {
        hr = E_INVALIDARG;
    }

    *ppPropBag = m_spPropBag;
    *ppErrorLog = m_spErrorLog;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    PutNaturalRepeatCount
//
//  Overview:  If there is no repeatCount set, 
//             set the repeatCount on the engine directly
//
//  Arguments: dblRepeatCount   number of times to repeat
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CTIMEMediaElement::PutNaturalRepeatCount(double dblRepeatCount)
{
    HRESULT hr = S_OK;
    
    // This is incorrect and we will remove for now until we implement
    // strip repeat
#if SUPPORT_STRIP_REPEAT
    if (!m_FARepeat.IsSet())
    {
        hr = GetMMBvr().GetMMBvr()->put_repeatCount(dblRepeatCount);
        hr = GetMMBvr().Reset(false);
    }
#endif
    
    hr = S_OK;
done:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    PutNaturalDuration
//
//  Arguments: dblNatDur   natural duration
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CTIMEMediaElement::PutNaturalDuration(double dblNatDur)
{
    HRESULT hr = S_OK;
    
    hr = (GetMMBvr().PutNaturalDur(dblNatDur));
    if(FAILED(hr))
    {
        goto done;
    }
    setNaturalDuration();                        
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ClearNaturalDuration
//
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CTIMEMediaElement::ClearNaturalDuration()
{
    HRESULT hr = S_OK;
    
    hr = THR(GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE));
    if(FAILED(hr))
    {
        goto done;
    }
    clearNaturalDuration();
    hr = S_OK;
done:
    return hr;
}

void
CTIMEMediaElement::UpdateClipTimes()
{
    double dblDuration = 0.0;    
    double flBeginTime = -1;
    double flEndTime = -1;
    int clipBeginType = -1;
    int clipEndType = -1;
    LONGLONG lTemp;
    HRESULT hr = S_OK;

    if(m_FAClipBegin.IsSet())
    {
        flBeginTime = m_FAClipBegin.GetValue();
        clipBeginType = 1;
    }
    else if(m_LAClipBegin.IsSet())
    {
        lTemp = m_LAClipBegin.GetValue();
        if(m_Player)
        {
            hr = m_Player->ConvertFrameToTime(lTemp, flBeginTime);
            if(SUCCEEDED(hr))
            {
                clipBeginType = 2;
            }
            else
            {
                flBeginTime = -1.0;
            }
        }
    }
    if(m_FAClipEnd.IsSet())
    {
        flEndTime = m_FAClipEnd.GetValue();
        clipEndType = 1;
    }
    else if(m_LAClipEnd.IsSet())
    {
        lTemp = m_LAClipEnd.GetValue();
        if(m_Player)
        {
            hr = m_Player->ConvertFrameToTime(lTemp, flEndTime);
            if(SUCCEEDED(hr))
            {
                clipEndType = 2;
            }
            else
            {
                flEndTime = -1.0;
            }
        }
    }

    if (flEndTime != -1 &&
        flBeginTime != -1 &&
        flEndTime <= flBeginTime)
    {
        flEndTime = -1;
    }
    if (!m_fLoaded)
    {
        goto done;
    }
        
    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if (m_Player)
    {
        if(clipBeginType == 1)
        {
            m_Player->SetClipBegin(flBeginTime);
        }
        else if(clipBeginType == 2)
        {
            m_Player->SetClipBeginFrame(m_LAClipBegin.GetValue());
        }

        if(clipEndType == 1)
        {
            m_Player->SetClipEnd(flEndTime);
        }
        else if(clipEndType == 2)
        {
            m_Player->SetClipEndFrame(m_LAClipEnd.GetValue());
        }
    }

    if (flBeginTime == -1)
    {
        flBeginTime = 0.0;
    }
    if (flEndTime != -1)
    {
        dblDuration = (double)(flEndTime - flBeginTime);
    }
    else
    {
        dblDuration = HUGE_VAL;
        if (m_Player)
        {
            m_Player->GetMediaLength(dblDuration);
        }

        if (dblDuration < HUGE_VAL)
        {
            dblDuration = dblDuration - flBeginTime;
        }
    }
    if (dblDuration < HUGE_VAL)
    {
        if (dblDuration < 0.001)
        {
            //we cannot allow a smaller duration than this, if this repeats it could.
            //appear to hang the browser.
            dblDuration = 0.001;
        }

        PutNaturalDuration(dblDuration);
    }
  done:
    return;
}


//+-----------------------------------------------------------------------
//
//  String to pixel conversion functions.
//
//
// 
//
//------------------------------------------------------------------------
static const LPWSTR PX   = L"px";

#define HORIZ   true
#define VERT    false

typedef struct _VALUE_PAIR
{
    const WCHAR *wzName;
    bool         bValue;
} VALUE_PAIR;

#define VALUE_NOT_SET         -999.998

const VALUE_PAIR 
rgPropOr[] =
{
    { (L"backgroundPositionX"),     HORIZ  },
    { (L"backgroundPositionY"),     VERT   },
    { (L"borderBottomWidth"),       VERT   },
    { (L"borderLeftWidth"),         HORIZ  },
    { (L"borderRightWidth"),        HORIZ  },
    { (L"borderTopWidth"),          VERT   },
    { (L"bottom"),                  VERT   },
    { (L"height"),                  VERT   },
    { (L"left"),                    HORIZ  },
    { (L"letterSpacing"),           HORIZ  },
    { (L"lineHeight"),              VERT   },
    { (L"marginBottom"),            VERT   },
    { (L"marginLeft"),              HORIZ  },
    { (L"marginRight"),             HORIZ  },
    { (L"marginTop"),               VERT   },
    { (L"overflowX"),               HORIZ  },
    { (L"overflowY"),               VERT   },
    { (L"pixelBottom"),             VERT   },
    { (L"pixelHeight"),             VERT   },
    { (L"pixelLeft"),               HORIZ  },
    { (L"pixelRight"),              HORIZ  },
    { (L"pixelTop"),                VERT   },
    { (L"pixelWidth"),              HORIZ  },
    { (L"posBottom"),               VERT   },
    { (L"posHeight"),               VERT   },
    { (L"posLeft"),                 HORIZ  },
    { (L"posRight"),                HORIZ  },
    { (L"posTop"),                  VERT   },
    { (L"posWidth"),                HORIZ  },
    { (L"right"),                   HORIZ  },
    { (L"textIndent"),              HORIZ  },
    { (L"width"),                   HORIZ  }
}; // rgPropOr[]

#define SIZE_OF_VALUE_TABLE (sizeof(rgPropOr) / sizeof(VALUE_PAIR))



typedef struct _CONVERSION_PAIR
{
    WCHAR  *wzName;
    double  dValue;
} CONVERSION_PAIR;


const CONVERSION_PAIR 
rgPixelConv[] =
{
    // type , convertion to inches
    { (L"in"),   1.00  },
    { (L"cm"),   2.54  },
    { (L"mm"),  25.40  },
    { (L"pt"),  72.00  },
    { (L"pc"), 864.00  }
}; // 

#define SIZE_OF_CONVERSION_TABLE (sizeof(rgPixelConv) / sizeof(CONVERSION_PAIR))


///////////////////////////////////////////////////////////////
//  Name: CompareValuePairs
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
static int __cdecl
CompareValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((VALUE_PAIR*)pv1)->wzName,
                    ((VALUE_PAIR*)pv2)->wzName);
} 


///////////////////////////////////////////////////////////////
//  Name: ConvertToPixels
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool
ConvertToPixels(VARIANT *pvarValue, WCHAR *pAttribute)
{
    int  pixelPerInchVert, pixelPerInchHoriz, pixelFactor;
    LPOLESTR szTemp  = NULL;
    HDC hdc;
    double fVal = VALUE_NOT_SET;
    HRESULT hr;
    bool bReturn = false;

    pixelPerInchHoriz=pixelPerInchVert=0;
    if (pvarValue->vt != VT_BSTR)
    {
        // no conversion to do...just return.
        bReturn = true;
        goto done;
    }
    // see if we can just do a straight converstion.
    hr = VariantChangeTypeEx(pvarValue,pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
    if (SUCCEEDED(hr))
    {
        bReturn = true;
        goto done;
    }

    // see if the bstr is empty
    if (ocslen(pvarValue->bstrVal) == 0)
    {
        SysFreeString(pvarValue->bstrVal);
        pvarValue->vt   = VT_R4;
        pvarValue->fltVal = 0;
        bReturn = true;
        goto done;
    }


    szTemp = CopyString(pvarValue->bstrVal);
    if (NULL == szTemp)
    {
        goto done;
    }

    hdc = GetDC(NULL);
    if (NULL != hdc)
    {
        pixelPerInchHoriz = g_LOGPIXELSX;
        pixelPerInchVert  = g_LOGPIXELSY;
        ReleaseDC(NULL, hdc);
    }


    // Determine the PixelFactor based on what the target is...
    {
        VALUE_PAIR valName;
        valName.wzName = pAttribute;

        VALUE_PAIR * pValPair = (VALUE_PAIR*)bsearch(&valName,
                                              rgPropOr,
                                              SIZE_OF_VALUE_TABLE,
                                              sizeof(VALUE_PAIR),
                                              CompareValuePairsByName);

        if (NULL == pValPair)
            pixelFactor = (pixelPerInchVert + pixelPerInchHoriz) /2;
        else
            pixelFactor = pValPair->bValue == HORIZ ? pixelPerInchHoriz : pixelPerInchVert;
    }


    {
        // See if we have PIXELS
        if (ConvertToPixelsHELPER(szTemp, PX, 1, 1, &fVal))
        {
            bReturn = true;
            goto done;
        }
     
        // Try to convert to Pixels.
        unsigned i;
        for(i=0; i < SIZE_OF_CONVERSION_TABLE;i++)
        {
            if (ConvertToPixelsHELPER(szTemp, rgPixelConv[i].wzName, rgPixelConv[i].dValue, pixelFactor, &fVal))
            {
                bReturn = true;
                goto done;
            }
        }
    }

done:
    if (fVal != VALUE_NOT_SET)
    {
        ::VariantClear(pvarValue);
        pvarValue->vt     = VT_R4;
        pvarValue->fltVal = fVal; //lint !e736
    }
    if (szTemp)
    {
        delete [] szTemp;
    }
    return bReturn;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::IsFilterAttached
//
//  Synopsis:   Returns true if a filter is attached to the HTML element
//
//  Arguments:  None
//
//  Returns:    true/false
//
//------------------------------------------------------------------------------------
bool                
CTIMEMediaElement::IsFilterAttached()
{
    bool fHasFilters = false;
    CComPtr<IHTMLFiltersCollection> pFilters;    
    long length = 0;
    HRESULT hr;

    if (GetElement())
    {
        hr = THR(GetElement()->get_filters(&pFilters));
        if (FAILED(hr))
        {
            goto done;
        }

        if (pFilters.p) 
        {
            hr = THR(pFilters->get_length(&length));
            if (FAILED(hr))
            {
                goto done;
            }

            if (length > 0)
            {
                fHasFilters = true;
            }            
        }
    }

done:
    return fHasFilters;
}

HRESULT
CTIMEMediaElement::StartRootTime(MMTimeline * tl)
{
    HRESULT hr = S_OK;

    IsNativeSize();

    hr = CTIMEElementBase::StartRootTime(tl);
    if(FAILED(hr))
    {
        goto done;
    }

    if(!IsSyncMaster())
    {
        SetSyncMaster(true);
    }


    if(m_sHasSyncMMediaChild == -1)
    {
        goto done;
    }

    RemoveSyncMasterFromBranch(*(m_pTIMEChildren + m_sHasSyncMMediaChild));

done:
    return hr;
}

void
CTIMEMediaElement::StopRootTime(MMTimeline * tl)
{
    CTIMEElementBase::StopRootTime(tl);

done:
    return;
}

void CTIMEMediaElement::NotifyPropertyChanged(DISPID dispid)
{
    CTIMEElementBase::NotifyPropertyChanged(dispid);

    // need this to work with proxy players that cannot fire events.
    // on specifying the source, we fire a ONMEDIACOMPLETE event
    // which should trigger some stuff for us.
    if (dispid == DISPID_TIMEMEDIAPLAYER_SRC)
    {
        FireMediaEvent(PE_ONMEDIACOMPLETE);
    }      
    else if (dispid == DISPID_TIMEPLAYLIST_ACTIVETRACK)
    {
        FireTrackChangeEvent();
    }
    else if (dispid == DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR)
    {
        FireMediaEvent(PE_ONMEDIAERROR);
    }

    
}

STDMETHODIMP
CTIMEMediaElement::get_earliestMediaTime(VARIANT * earliestMediaTime)
{
    HRESULT hr;
    double dblEarliest;
    
    if (earliestMediaTime == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetEarliestMediaTime(dblEarliest))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(earliestMediaTime))))
    {
        hr = S_FALSE;
        goto done;
    }

    earliestMediaTime->vt = VT_R8;
    earliestMediaTime->dblVal = dblEarliest;

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_latestMediaTime(VARIANT * latestMediaTime)
{
    HRESULT hr;
    double dblLatest;
    
    if (latestMediaTime == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetLatestMediaTime(dblLatest))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(latestMediaTime))))
    {
        hr = S_FALSE;
        goto done;
    }
    latestMediaTime->vt = VT_R8;
    latestMediaTime->dblVal = dblLatest;

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_minBufferedMediaDur(VARIANT * minBufferedMediaDur)
{
    HRESULT hr;
    
    if (minBufferedMediaDur == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(minBufferedMediaDur))))
    {
        hr = S_FALSE;
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::put_minBufferedMediaDur(VARIANT minBufferedMediaDur)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false