               _itot( gdwPLID[giCurrentLine], szBuffer, 10 ); 
                    RegSetValueEx (hKey, TEXT("Preferred Line"), 0, REG_SZ,
                                   (LPBYTE)szBuffer, (lstrlen(szBuffer)+1)*sizeof(TCHAR));

                    // Update address
                    hwndBox = GetDlgItem( hwnd, IDD_CULISTADDRESS );
                    giCurrentAddress = (int) SendMessage (
                                                    hwndBox,
                                                    CB_GETITEMDATA,
                                                    SendMessage(hwndBox, CB_GETCURSEL, 0, 0),
                                                    0
                                                   );

                    _itot( giCurrentAddress, szBuffer, 10 ); 
                    RegSetValueEx (hKey, TEXT("Preferred Address"), 0, REG_SZ,
                                   (LPBYTE)szBuffer, (lstrlen(szBuffer)+1)*sizeof(TCHAR));

                    RegCloseKey (hKey);

                    // Update application priority
                    if ( SendDlgItemMessage (
                                                hwnd,
                                                IDD_CUSIMPLETAPICHKBOX,
                                                BM_GETCHECK,
                                                0,
                                                0L
                                            )
                          == 0)
                    {
                        dwPriority = 0;
                    }
                    else   
                    {
                        dwPriority = 1;
                    }

                    lineSetAppPriority (
                                        TEXT("DIALER.EXE"),
                                        0,
                                        NULL,
                                        LINEREQUESTMODE_MAKECALL,
                                        NULL,
                                        dwPriority
                                       );

                    EndDialog(hwnd, TRUE);
                    return TRUE;
                }

                case IDCANCEL:
                    EndDialog(hwnd, FALSE);
                    return TRUE;
            }
        }

        default:
              ;

    }

    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK LineInUseProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int lNewParam = (int)lParam;
    PTSTR  ptStr;


    switch(msg)
    {
        case WM_INITDIALOG:
        {
            switch(lParam)
            {
                case LINEDISCONNECTMODE_REJECT:
                    lNewParam = ikszDisconnectedReject;
                    break;

                case LINEDISCONNECTMODE_BUSY:
                    lNewParam = ikszDisconnectedBusy;
                    break;

                case LINEDISCONNECTMODE_NOANSWER:
                    lNewParam = ikszDisconnectedNoAnswer;
                    break;

                case LINEDISCONNECTMODE_CONGESTION:
                    lNewParam = ikszDisconnectedNetwork;
                    break;

                case LINEDISCONNECTMODE_INCOMPATIBLE:
                    lNewParam = ikszDisconnectedIncompatible;
                    break;

                case LINEDISCONNECTMODE_NODIALTONE:
                    lNewParam = ikszDisconnectedNoDialTone;
                    break;

                default:
                    lNewParam = ikszDisconnectedCantDo;
                    break;
            }

            ptStr = DialerAlloc( MAXBUFSIZE*sizeof(TCHAR) );
            LoadString( ghInst, lNewParam, ptStr, MAXBUFSIZE );
            SetDlgItemText (hwnd, IDD_CFTEXT, ptStr);
            DialerFree( ptStr );

            return TRUE;
        }

        case WM_COMMAND:
            if(LOWORD((DWORD)wParam) == IDOK)
                {
                EndDialog(hwnd, TRUE);
                return TRUE;
                }
            break;
    }    

    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK SpeedDial1Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static DWORD nCurrentSpeedDial;

    static const DWORD aMenuHelpIDs[] = 
    {
        IDOK,                   IDH_DIALER_SPEED_SAVE,
        IDD_SD1SPEEDDIAL1,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL2,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL3,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL4,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL5,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL6,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL7,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIAL8,      IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT1,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT2,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT3,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT4,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT5,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT6,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT7,  IDH_DIALER_BUTTONS,
        IDD_SD1SPEEDDIALTEXT8,  IDH_DIALER_BUTTONS,
        IDD_SD1TEXTNAME,        IDH_DIALER_SPEED_NAME,
        IDD_SD1EDITNAME,        IDH_DIALER_SPEED_NAME,
        IDD_SD1TEXTNUMBER,      IDH_DIALER_SPEED_NUMBER,
        IDD_SD1EDITNUMBER,      IDH_DIALER_SPEED_NUMBER,
        IDD_SD1TEXTCHOOSE,      (DWORD)-1,
        IDD_SD1TEXTENTER,       (DWORD)-1,
        0,                      0
    };

    // buffer to store speed dial names till they are saved.
    static TCHAR szSDName[NSPEEDDIALS + 1][TAPIMAXCALLEDPARTYSIZE] = {0};

    switch(msg)
    {
        case WM_HELP:
            // processes clicks on controls when
            // context mode help is selected
            WinHelp(
                ((LPHELPINFO)lParam)->hItemHandle,
                gszHELPfilename,
                HELP_WM_HELP,
                (ULONG_PTR)aMenuHelpIDs
                );
            return TRUE;

        case WM_CONTEXTMENU: // processes right-clicks on controls
            WinHelp(
                (HWND)wParam,
                gszHELPfilename,
                HELP_CONTEXTMENU,
                (ULONG_PTR)aMenuHelpIDs
                );
            return TRUE;

        case WM_INITDIALOG:
        {
            DWORD cSDEntry;
            DWORD idFirstEmpty = (DWORD) -1;

            TCHAR szName[TAPIMAXCALLEDPARTYSIZE] = {0};
            TCHAR szTemp[TAPIMAXCALLEDPARTYSIZE];
            TCHAR szFieldName[MAXBUFSIZE];

            HKEY hKey = NULL;
            DWORD dwSize;

            // Retrieve speed dial info from INI file
            RegOpenKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, KEY_READ, &hKey);
            for(cSDEntry = 1; cSDEntry <= NSPEEDDIALS; ++cSDEntry)
            {
                wsprintf(szFieldName, TEXT("Name%d"), cSDEntry);
                dwSize = sizeof (szSDName[ cSDEntry ]);
                RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szSDName[cSDEntry], &dwSize);

                // set the first empty speed dial button
                if ( idFirstEmpty == -1 && 
                     szSDName[ cSDEntry ][0] == '\0' &&
                     gszSDNumber[ cSDEntry ][ 0 ] == '\0' )
                    idFirstEmpty = cSDEntry;

                wsprintf(szFieldName, TEXT("Number%d"), cSDEntry);
                dwSize = sizeof (gszSDNumber[cSDEntry]);
                RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)gszSDNumber[cSDEntry], &dwSize);

                // get a copy of the name for editing
                // if name is empty, use the number as the
                // name.
                if (0 != szSDName[ cSDEntry][0])
                {            
                    lstrcpyn( szName, szSDName[ cSDEntry], sizeof(szName)/sizeof(szName[0]));
                }
                else
                {
                    lstrcpyn( szName, gszSDNumber[ cSDEntry ], sizeof(szName)/sizeof(szName[0]) );
                }
            
                FitTextToButton( hwnd, IDD_SD1SPEEDDIAL1 + cSDEntry - 1, szName );
                AmpersandCompensate( szName, szTemp );

                SetDlgItemText (
                                hwnd,
                                IDD_SD1SPEEDDIAL1 + cSDEntry - 1,
                                (LPCTSTR) szTemp
                               ); 

            }
            RegCloseKey (hKey);

            // for the edit speed dial dialog
            // limit the lengths of text
            SendDlgItemMessage (
                                hwnd,
                                IDD_SD1EDITNAME,
                                EM_LIMITTEXT,
                                (WPARAM)(TAPIMAXCALLEDPARTYSIZE - 1),
                                0
                               );

            SendDlgItemMessage (
                                hwnd,
                                IDD_SD1EDITNUMBER,
                                EM_LIMITTEXT,
                                (WPARAM)(TAPIMAXDESTADDRESSSIZE - 1),
                                0
                               );

            // select the first empty button
            // nothing empty, then edit #1
            if ( -1 == idFirstEmpty ) 
            {
                nCurrentSpeedDial = 1;
                SetDlgItemText(
                                hwnd,
                                IDD_SD1EDITNAME,
                                (LPCTSTR) szSDName[ 1 ]
                              );

                SetDlgItemText(
                                hwnd,
                                IDD_SD1EDITNUMBER,
                                (LPCTSTR) gszSDNumber[ 1 ]
                              );
            }
            else
            {
                nCurrentSpeedDial = idFirstEmpty;
            }

            SetFocus( GetDlgItem( hwnd, IDD_SD1EDITNAME ) );
            return FALSE;
        }

        case WM_COMMAND:
        {
            TCHAR szName[TAPIMAXCALLEDPARTYSIZE];
            TCHAR szTemp[ TAPIMAXCALLEDPARTYSIZE ];

            switch( LOWORD( (DWORD) wParam ) )
            {
                case IDOK:
                {
                    DWORD cSDEntry;
                    TCHAR szFieldName[MAXBUFSIZE];
                    HKEY hKey = NULL;

                    // save new speed dial settings
                    RegCreateKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL);
                    for ( cSDEntry = 1; cSDEntry <= NSPEEDDIALS; ++cSDEntry )
                    {
                        wsprintf(szFieldName, TEXT("Name%d"), cSDEntry);
                        RegSetValueEx (hKey, szFieldName, 0, REG_SZ,
                            (LPBYTE)(szSDName[cSDEntry]),
                            (lstrlen(szSDName[cSDEntry])+1)*sizeof(TCHAR));

                        wsprintf(szFieldName, TEXT("Number%d"), cSDEntry);
                        RegSetValueEx (hKey, szFieldName, 0, REG_SZ,
                            (LPBYTE)(gszSDNumber[cSDEntry]),
                            (lstrlen(gszSDNumber[cSDEntry])+1)*sizeof(TCHAR));

                        // set the text for the corresponding 
                        // main window button
                        if ( szSDName[ cSDEntry ][ 0 ] == TEXT('\0') )
                        {
                            lstrcpyn( szName, gszSDNumber[ cSDEntry ], sizeof(szName)/sizeof(szName[0]) );
                        }
                        else
                        {
                            lstrcpyn( szName, szSDName[ cSDEntry ], sizeof(szName)/sizeof(szName[0]) );
                        }

                        FitTextToButton( 
                                        ghWndMain, 
                                        IDD_DSPEEDDIAL1 + cSDEntry - 1, 
                                        szName 
                                       );

                        AmpersandCompensate( szName, szTemp );
                        SetDlgItemText ( 
                                        ghWndMain,
                                        IDD_DSPEEDDIAL1 + cSDEntry - 1,
                                        (LPCTSTR) szTemp
                                       );
                    }
                    RegCloseKey (hKey);

                    EndDialog(hwnd, TRUE);
                    return TRUE;
                }

                case IDCANCEL:
                    EndDialog(hwnd, FALSE);
                    return TRUE;

                case IDD_SD1SPEEDDIAL1:
                case IDD_SD1SPEEDDIAL2:
                case IDD_SD1SPEEDDIAL3:
                case IDD_SD1SPEEDDIAL4:
                case IDD_SD1SPEEDDIAL5:
                case IDD_SD1SPEEDDIAL6:
                case IDD_SD1SPEEDDIAL7:
                case IDD_SD1SPEEDDIAL8:

                    nCurrentSpeedDial =    LOWORD( (DWORD) wParam ) - IDD_SD1SPEEDDIAL1 + 1;

                    SetDlgItemText (
                                    hwnd,
                                    IDD_SD1EDITNAME,
                                    szSDName [ nCurrentSpeedDial ]
                                   );
                    SetDlgItemText (
                                    hwnd,
                                    IDD_SD1EDITNUMBER,
                                    gszSDNumber[nCurrentSpeedDial]
                                   );

                    SetFocus( GetDlgItem( hwnd, IDD_SD1EDITNAME ) );
                    SendDlgItemMessage(
                                        hwnd,
                                        IDD_SD1EDITNAME,
                                        EM_SETSEL,
                                        0,
                                        MAKELPARAM(0, -1)
                                    );
                    break;

                case IDD_SD1EDITNAME:
                    if ( HIWORD( wParam ) == EN_CHANGE )
                    {
                        TCHAR *p;

                        GetDlgItemText (
                                        hwnd,
                                        IDD_SD1EDITNAME,
                                        szName,
                                        TAPIMAXCALLEDPARTYSIZE
                                       );

                        for (p = szName; *p == TEXT(' '); p++);
                        // if there is no name, label the button with
                        // the number
                        if ( *p == TEXT('\0') )
                        {
                            szSDName[ nCurrentSpeedDial ][ 0 ] = TEXT('\0');
                            lstrcpyn( szName, gszSDNumber[ nCurrentSpeedDial ], sizeof(szName)/sizeof(szName[0]) );
                            p = szName;
                        }
                        else
                        {
                            lstrcpy( szSDName[ nCurrentSpeedDial ], p );
                        }

                        FitTextToButton ( 
                                            hwnd, 
                                            IDD_SD1SPEEDDIAL1 + nCurrentSpeedDial - 1,
                                            szName
                                        );
                        AmpersandCompensate( p, szTemp );

                        SetDlgItemText (
                                        hwnd,
                                        IDD_SD1SPEEDDIAL1 + nCurrentSpeedDial - 1,
                                        szTemp
                                       );
                    }
                    break;

                case IDD_SD1EDITNUMBER:
                    if ( HIWORD( wParam ) == EN_CHANGE )
                    {
                        GetDlgItemText (
                                        hwnd,
                                        IDD_SD1EDITNUMBER,
                                        gszSDNumber[nCurrentSpeedDial],
                                        TAPIMAXDESTADDRESSSIZE
                                       );

                        if ( gszSDNumber[ nCurrentSpeedDial ][ 0 ] == '\0' )
                        {
                            GetDlgItemText (
                                            hwnd,
                                            IDD_SD1EDITNAME,
                                            szName,
                                            TAPIMAXDESTADDRESSSIZE
                                           );

                            if ( szName[ 0 ] == TEXT('\0') )
                            {
                                SetDlgItemText ( 
                                                hwnd,
                                                IDD_SD1SPEEDDIAL1 + nCurrentSpeedDial - 1,
                                                szName
                                               );

                            }
                        }
                    }
                    break;
                } // switch(LOWORD((DWORD)wParam))
            break;

        } // case WM_COMMAND:

        default:
              ;

    } // switch(msg)

    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK SpeedDial2Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static DWORD nCurrentSpeedDial;

    static const DWORD aMenuHelpIDs[] = 
    {
        IDOK,                   IDH_DIALER_SPEED_SAVE,
        IDD_SD2SAVEANDDIAL,     IDH_DIALER_SPEED_SAVE_DIAL,
        IDD_SD2TEXTNAME,        IDH_DIALER_SPEED_NAME,
        IDD_SD2EDITNAME,        IDH_DIALER_SPEED_NAME,
        IDD_SD2TEXTNUMBER,      IDH_DIALER_SPEED_NUMBER,
        IDD_SD2EDITNUMBER,      IDH_DIALER_SPEED_NUMBER,
        0,                      0
    };

    switch(msg)
    {
        case WM_HELP: 
            // processes clicks on controls when
            // context mode help is selected
            WinHelp (
                        ((LPHELPINFO)lParam)->hItemHandle,
                        gszHELPfilename,
                        HELP_WM_HELP,
                        (ULONG_PTR)aMenuHelpIDs
                    );
            return TRUE;

        case WM_CONTEXTMENU: 
            // processes right-clicks on controls
            WinHelp (
                        (HWND)wParam,
                        gszHELPfilename,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR)aMenuHelpIDs
                    );
            return TRUE;

        case WM_INITDIALOG:
        {
            TCHAR szFieldName [MAXBUFSIZE];
            TCHAR szName [TAPIMAXCALLEDPARTYSIZE] = {0};
            HKEY hKey = NULL;
            DWORD dwSize;

            nCurrentSpeedDial = LOWORD( lParam ) - IDD_DSPEEDDIAL1 + 1;

            // retrieve speed dial button info
            RegOpenKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, KEY_READ, &hKey);
            wsprintf(szFieldName, TEXT("Name%d"), nCurrentSpeedDial);
            dwSize = sizeof (szName);
            RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szName, &dwSize);
            RegCloseKey (hKey);

            SetDlgItemText (
                            hwnd,
                            IDD_SD2EDITNAME,
                            szName
                           );

            SetDlgItemText (
                            hwnd,
                            IDD_SD2EDITNUMBER,
                            gszSDNumber[nCurrentSpeedDial]
                           );

            // limit the lengths of the texts
            SendDlgItemMessage (
                                hwnd,
                                IDD_SD2EDITNAME,
                                EM_LIMITTEXT,
                                (WPARAM)(TAPIMAXCALLEDPARTYSIZE - 1),
                                0
                               );

            SendDlgItemMessage (
                                hwnd,
                                IDD_SD2EDITNUMBER,
                                EM_LIMITTEXT,
                                (WPARAM)(TAPIMAXDESTADDRESSSIZE - 1),
                                0
                               );


            SetFocus( GetDlgItem( hwnd, IDD_SD2EDITNAME ) );
            SendDlgItemMessage (
                                hwnd,
                                IDD_SD2EDITNAME,
                                EM_SETSEL,
                                0,
                                MAKELPARAM(0, -1)
                               );

            return FALSE;
        }

        case WM_COMMAND:
        {
            TCHAR szName[ TAPIMAXDESTADDRESSSIZE ];
            TCHAR szTemp[ TAPIMAXCALLEDPARTYSIZE ];
            TCHAR szFieldName[MAXBUFSIZE];
            TCHAR *p;

            switch ( LOWORD( (DWORD) wParam ) )
            {
                case IDOK:
                case IDD_SD2SAVEANDDIAL:
                {
                    HKEY hKey = NULL;

                    RegCreateKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL);

                    GetDlgItemText (
                                    hwnd,
                                    IDD_SD2EDITNUMBER,
                                    (LPTSTR) szName,
                                    TAPIMAXDESTADDRESSSIZE
                                   );
                    for (p = szName; *p == TEXT(' '); p++);

                    if (0 == *p)
                    {
                        wsprintf (szFieldName, TEXT("Name%d"), nCurrentSpeedDial);
                        RegDeleteValue (hKey, szFieldName);
                        wsprintf (szFieldName, TEXT("Number%d"), nCurrentSpeedDial);
                        RegDeleteValue (hKey, szFieldName);
                    }
                    else
                    {
                        lstrcpyn (gszSDNumber[nCurrentSpeedDial], p,
                                  sizeof(gszSDNumber[nCurrentSpeedDial])/sizeof(TCHAR));

                        GetDlgItemText (
                                        hwnd,
                                        IDD_SD2EDITNAME,
                                        szName,
                                        TAPIMAXCALLEDPARTYSIZE
                                       );
                        for (p = szName; *p == TEXT(' '); p++);

                        wsprintf ( szFieldName, TEXT("Name%d"), nCurrentSpeedDial );
                        RegSetValueEx (hKey, szFieldName, 0, REG_SZ, (LPBYTE)p, (lstrlen(p)+1)*sizeof(TCHAR));
    
                        wsprintf ( szFieldName, TEXT("Number%d"), nCurrentSpeedDial );
                        RegSetValueEx (hKey, szFieldName, 0, REG_SZ,
                            (LPBYTE)(gszSDNumber[nCurrentSpeedDial]),
                            (lstrlen(gszSDNumber[nCurrentSpeedDial])+1)*sizeof(TCHAR));

                        // update main window buttons
                        // is only number has been entered, label button with it.
                        if ( *p == TEXT('\0') )
                        {
                            lstrcpyn( szName, gszSDNumber[ nCurrentSpeedDial ], sizeof(szName)/sizeof(szName[0]) );
                            p = szName;
                        }

                        FitTextToButton ( 
                                            ghWndMain, 
                                            IDD_DSPEEDDIAL1 + nCurrentSpeedDial - 1, 
                                            p
                                        );

                        AmpersandCompensate( p, szTemp );
                    
                        SetDlgItemText ( 
                                        ghWndMain,
                                        IDD_DSPEEDDIAL1 + nCurrentSpeedDial - 1,
                                        szTemp
                                       );

                        // if save and dial, then post dial message to main window
                        if ( LOWORD( (DWORD) wParam ) == IDD_SD2SAVEANDDIAL )
                        {
                            PostMessage (
                                            ghWndMain,
                                            WM_COMMAND,
                                            MAKEWPARAM (
                                                        nCurrentSpeedDial + IDD_DSPEEDDIAL1 - 1,
                                                        BN_CLICKED
                                                       ),
                                            (LPARAM) GetDlgItem (
                                                                    ghWndMain,
                                                                    nCurrentSpeedDial + IDD_DSPEEDDIAL1 - 1
                                                                )
                                        );
                        }
                    }

                    RegCloseKey (hKey);

                    EndDialog(hwnd, TRUE);
                    return TRUE;
                }

                case IDCANCEL:
                    EndDialog(hwnd, FALSE);
                    return TRUE;

                case IDD_SD2EDITNAME:
                case IDD_SD2EDITNUMBER:
                    if ( HIWORD( wParam ) == EN_CHANGE)
                    {
                        EnableWindow (
                                        GetDlgItem( hwnd, IDD_SD2SAVEANDDIAL ),
                                        GetWindowTextLength ( GetDlgItem( hwnd, IDD_SD2EDITNUMBER ) ) > 0
                                     );
                    }
                    break;

            } // switch(LOWORD((DWORD)wParam))
            break;
        }


        default:
              ;

    } // switch(msg)

    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID CALLBACK
tapiCallback (
                DWORD   hDevice,
                DWORD   dwMsg,
                DWORD   dwCBInstance,
                DWORD   dwParam1,
                DWORD   dwParam2,
                DWORD   dwParam3
            )
{
    switch (dwMsg)
    {
        INT errCode;

        case LINE_ADDRESSSTATE:
            break;

        case LINE_CALLINFO:
            break;

        case LINE_CALLSTATE:
            if ( (HCALL)hDevice != ghCall )
                return;

            switch ( dwParam1 ) // new state
            {
                case LINECALLSTATE_IDLE:

                    // tell "Dialing" window to terminate
                    if ( ghWndDialing )
                    {
                        SendMessage ( 
                                        ghWndDialing,
                                        WM_COMMAND,
                                        MAKEWPARAM( IDOK, 0 ),
                                        0
                                    );
                    }

                    // tapi call cleanup
                    if ( !gfMakeCallReplyPending && ghCall )
                    {
                        if ( ( errCode = lineDeallocateCall( ghCall ) ) < 0 )
                        {
                            errString ( ghWndMain, errCode, MB_ICONSTOP | MB_OK );
                        }
                        ghCall = 0;
                    }
                    DialerLineClose();
                    gfCurrentLineAvail = TRUE;

                    // update main window
                    DisableDialButtons( FALSE );
                    break;

                case LINECALLSTATE_BUSY:
                    tapiCallback (
                                    hDevice,
                                    dwMsg,
                                    dwCBInstance,
                                    LINECALLSTATE_DISCONNECTED,
                                    LINEDISCONNECTMODE_BUSY,
                                    dwParam3
                                 );
                    break;

                case LINECALLSTATE_SPECIALINFO:
                    tapiCallback (
                                    hDevice,
                                    dwMsg,
                                    dwCBInstance,
                                    LINECALLSTATE_DISCONNECTED,
                                    LINEDISCONNECTMODE_UNREACHABLE,
                                    dwParam3
                                 );
                    break;

                case LINECALLSTATE_DISCONNECTED:
                {
                    BOOL fCallOK;
                    DWORD LineDisconnectMode;


                    if ( dwParam2 == 0 )
                        LineDisconnectMode = LINEDISCONNECTMODE_NORMAL;
                    else
                        LineDisconnectMode = dwParam2;

                    fCallOK = ( LineDisconnectMode == LINEDISCONNECTMODE_NORMAL        ||
                                LineDisconnectMode == LINEDISCONNECTMODE_UNKNOWN    ||
                                LineDisconnectMode == LINEDISCONNECTMODE_PICKUP        ||
                                LineDisconnectMode == LINEDISCONNECTMODE_FORWARDED    ||
                                LineDisconnectMode == LINEDISCONNECTMODE_UNAVAIL
                              );

                    
                    if ( !gfMakeCallReplyPending && ghCall )
                    {
                        //gfDropping = TRUE;
                        if ( ( gDropCallRequestID = lineDrop ( ghCall, NULL, 0 ) ) < 0 )
                        {
                            errString ( ghWndMain, gDropCallRequestID, MB_ICONSTOP | MB_OK );
                        }
                    }

                    if ( !fCallOK )
                        DialogBoxParam (
                                        ghInst,
                                        MAKEINTRESOURCE(IDD_CALLFAILED),
                                        ghWndMain,
                                        LineInUseProc,
                                        LineDisconnectMode
                                       );
                    break;
                }
            }
            break;


        case LINE_CLOSE:
            if ( gCurrentLineInfo.hLine == (HLINE)hDevice )
            {
                errString(ghWndMain, ERR_LINECLOSE, MB_ICONEXCLAMATION | MB_OK );
                gCurrentLineInfo.hLine = 0;
                gfCurrentLineAvail = FALSE;
                DisableDialButtons(FALSE);                
            }
            break;

        case LINE_CREATE:
            // dwParam1 is the new device's ID
            if ( dwParam1 >= gnAvailDevices ) 
            {
                DWORD* gnAddrTemp;
                DWORD iLine;
                LINEINFO LineInfo;

                // we record new device's address count.

                // we are assuming here that we're just adding a new
                // line and it's sequential and it's the last one

                gnAvailDevices = dwParam1 + 1;
                
                gnAddrTemp = (DWORD *) DialerAlloc ( sizeof(DWORD) * (int)(gnAvailDevices) );

                for ( iLine = 0; iLine < (gnAvailDevices-1); ++iLine )
                    gnAddrTemp[iLine] = gnAddr[iLine];

                DialerFree( gnAddr );

                // we have effectively added one more
                // space in the gnAddr array
                gnAddr = gnAddrTemp; 

                if ( GetLineInfo( dwParam1, &LineInfo ) != ERR_NONE )
                    break;

                 gnAddr[dwParam1] = LineInfo.nAddr;
            }
            break;

        case LINE_DEVSPECIFIC:
            break;

        case LINE_DEVSPECIFICFEATURE:
            break;

        case LINE_GATHERDIGITS:
            break;

        case LINE_GENERATE:
            break;

        case LINE_LINEDEVSTATE:
            if ( dwParam1 & LINEDEVSTATE_REINIT )
            {
                if(dwParam2 != 0) 
                {
                    // this is another msg translated into REINIT
                    tapiCallback( hDevice, dwParam2, dwCBInstance, dwParam3, 0, 0 );
                }
                else 
                {
                    // Re-initialize TAPI
                    gfNeedToReinit = TRUE;
                }
            }

            if ( dwParam1 & LINEDEVSTATE_REMOVED )
            {
                DialerLineClose();
                tapiCallback(hDevice, LINE_CLOSE, dwCBInstance, 0, 0, 0); // is this needed?
            }
            break;

        case LINE_MONITORDIGITS:
            break;

        case LINE_MONITORMEDIA:
            break;

        case LINE_MONITORTONE:
            break;

        // async reply from lineMakeCall() or lineDrop()
        case LINE_REPLY:

            // reply for lineMakeCall 
            if ( (LONG) dwParam1 == gMakeCallRequestID )
            {
                // error on make call
                if ( dwParam2 != ERR_NONE )
                {
                    // Get rid of the Dialing Dialog box if it's up
                    if ( ghWndDialing )
                    {
                       SendMessage(
                                    ghWndDialing,
                                    WM_COMMAND,
                                    MAKEWPARAM(IDOK,0),
                                    0
                                  );
                    }

                    if ( dwParam2 == LINEERR_CALLUNAVAIL )
                    {
                        DialogBoxParam (
                                        ghInst,
                                        MAKEINTRESOURCE(IDD_CALLFAILED),
                                        ghWndMain,
                                        LineInUseProc,
                                        0
                                       );
                    }
                    else
                    {
                        errString ( ghWndMain, dwParam2, MB_ICONEXCLAMATION | MB_OK );
                    }

                    ghCall = 0;
                    DialerLineClose();
                    gfCurrentLineAvail = TRUE;
                }

                gfMakeCallReplyPending = FALSE;
            }

            // reply from lineDrop()
            if ( (LONG) dwParam1 == gDropCallRequestID )
            {
                // tell "Dialing" window to terminate
                if ( ghWndDialing )
                {
                    SendMessage ( 
                                    ghWndDialing,
                                    WM_COMMAND,
                                    MAKEWPARAM( IDOK,0 ),
                                    0
                                );
                }
                
                // tapi call cleanup
                if ( dwParam2 == ERR_NONE )
                {
                    if ( !gfMakeCallReplyPending && ghCall )
                    {
                        if ( ( errCode = lineDeallocateCall( ghCall ) ) < 0 )
                        {
                            errString ( ghWndMain, errCode, MB_ICONSTOP | MB_OK );
                        }
                        ghCall = 0;
                    }
                }
                DialerLineClose ();
                gfCurrentLineAvail = TRUE;
            }

            break;

        case LINE_REQUEST:
            // Simple TAPI request
            if ( dwParam1 == LINEREQUESTMODE_MAKECALL )
            {
                gfCallRequest = TRUE;
            }
            break;
    }
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL InitializeLineBox(HWND hwndLineBox)
{

    DWORD iLine, iItem, iItemCurrent = (DWORD)-1;
    DWORD errCode;

    LPLINEINFO lpLineInfo = NULL;

    // allocate buffer for storing LINEINFO for all of 
    // the available lines.  Always allocate space for 
    // at least one line
    if ( gnAvailDevices == 0 )
    {
        lpLineInfo = (LPLINEINFO) DialerAlloc( sizeof(LINEINFO) );
    }
    else
    {
        lpLineInfo = (LPLINEINFO) DialerAlloc ( sizeof(LINEINFO) * (int)gnAvailDevices );
    }

    // if no space was set aside...
    if ( lpLineInfo == NULL ) 
        return LINEERR_NOMEM;

    // fill lpLineInfo[] and open each line
    for ( iLine = 0; iLine < gnAvailDevices; ++iLine )
    {
        // skip remaining processing for this line if it didn't open
        if ( GetLineInfo( iLine, &lpLineInfo[iLine] ) != ERR_NONE )
        {
            continue;
        }

        iItem = (int) SendMessage (
                                hwndLineBox,
                                CB_ADDSTRING,
                                0,
                                (LPARAM)(lpLineInfo[iLine].szLineName)
                            );

        // error, bail out.
        if ( iItem == CB_ERR || iItem == CB_ERRSPACE )
        {
            if (lpLineInfo)
            {
                DialerFree(lpLineInfo);
            }
            
            return FALSE; 
        }

        errCode = (int) SendMessage (
                                hwndLineBox,
                                CB_SETITEMDATA,
                                (WPARAM)iItem,
                                (LPARAM)iLine
                              );

        if ( iLine == giCurrentLine )
        {
            iItemCurrent = iItem;
        }
        else if ( iItemCurrent != -1 && iItem <= iItemCurrent )
        {
            // if the item we are putting is before the
            // "current" item, we must increment iItemCurrent
            // to reflect that something is being placed before
            // it, due to sorting
            ++iItemCurrent;
        }
    }

    if ( iItemCurrent == (DWORD)-1 )
        iItemCurrent = 0;

    if ( SendMessage( hwndLineBox, CB_GETCOUNT, 0, 0) != 0 )
    {
        SendMessage( hwndLineBox, CB_SETCURSEL, (WPARAM)iItemCurrent, 0 );
        return TRUE;
    }

    DialerFree(lpLineInfo);
    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL InitializeAddressBox( HWND hwndLineBox, HWND hwndAddressBox )
{
    DWORD errCode;
    DWORD iAddress, iItem, iItemCurrent = (DWORD)-1;
    DWORD iLineBoxCurrent;
    LPTSTR pszAddressName;

    if ( SendMessage( hwndLineBox, CB_GETCOUNT, 0, 0 ) == 0 )
    {
        return FALSE;
    }

    // select current entry in line box
    iLineBoxCurrent = (int) SendMessage ( 
                                    hwndLineBox,
                                    CB_GETITEMDATA,
                                    SendMessage( hwndLineBox, CB_GETCURSEL, 0, 0 ),
                                    0
                                  );
    // empty address list box
    SendMessage ( hwndAddressBox, CB_RESETCONTENT, 0, 0); 

    // get all the address for this line
    for ( iAddress = 0; iAddress < gnAddr[iLineBoxCurrent]; ++iAddress )
    {
        pszAddressName = GetAddressName (iLineBoxCurrent, iAddress );

        // if this address if fails, try the next one
        if ( !pszAddressName )
            continue; 

        iItem = (int) SendMessage (
                                hwndAddressBox,
                                CB_ADDSTRING,
                                0,
                                (LPARAM)pszAddressName
                            );

        // error, bail out
        if ( iItem == CB_ERR || iItem == CB_ERRSPACE )
            return FALSE; 

        errCode = (int)SendMessage (
                                hwndAddressBox,
                                CB_SETITEMDATA,
                                (WPARAM) iItem,
                                (LPARAM) iAddress
                              );

        if ( iLineBoxCurrent == giCurrentLine )
        {
            if(iAddress == giCurrentAddress)
            {
                iItemCurrent = iItem;
            }
            else 
            {
                // if the item we are putting is before the
                // "current" item, we must increment iItemCur
                // to reflect that something is being placed
                // before it, due to sorting
                if ( iItemCurrent != -1 && iItem <= iItemCurrent )
                {
                    ++iItemCurrent; 
                }
            }
        }

        DialerFree( pszAddressName );
    }
    
    if ( iLineBoxCurrent != giCurrentLine )
    {    
        // if we're not looking at the current line
        // then highlight address 0
        iItemCurrent = 0;
    }

    SendMessage (
                    hwndAddressBox,
                    CB_SETCURSEL,
                    iItemCurrent,
                    0
                );
    return TRUE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID ManageAssistedTelephony(VOID)
{
    DWORD errCode;
    LINEREQMAKECALL *lpRequestBuffer;

    lpRequestBuffer = (LINEREQMAKECALL*) DialerAlloc( sizeof( LINEREQMAKECALL ) );
    if ( !lpRequestBuffer ) 
    {
        goto error;
    }

    // bring window to front
    SetForegroundWindow(ghWndMain);
    
    // get next queued request.
    errCode = lineGetRequest (
                                ghLineApp,
                                LINEREQUESTMODE_MAKECALL,
                                lpRequestBuffer
    
                             );
    if ( errCode )
    {
        // if no more call requests pending, reset flag.
        if ( errCode == LINEERR_NOREQUEST )
        {
            gfCallRequest = FALSE;
        }
        else
        {
            errString ( ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK );
        }
        goto error;
    }

    
    // if a line has not been selected
    if ( giCurrentLine == (DWORD)-1 )
    {
        if (!DialogBoxParam (
                        ghInst,
                        MAKEINTRESOURCE(IDD_CONNECTUSING),
                        ghWndMain,
                        ConnectUsingProc,
                        INVALID_LINE
                      ))
        {
            // failed to get a line
            goto error;
        }
    }

    // make the reuested call.
    InitiateCall (
                    lpRequestBuffer->szDestAddress,
                    lpRequestBuffer->szCalledParty
                 );

error :
    if ( lpRequestBuffer )
    {
        DialerFree( lpRequestBuffer );
    }
    return;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID DialerLineClose()
{
    DWORD errCode;

    if ( gCurrentLineInfo.hLine )
    {
        if ( errCode = lineClose ( gCurrentLineInfo.hLine ) )
        {
            errString ( ghWndMain, errCode, MB_ICONSTOP | MB_OK );
        }
        gCurrentLineInfo.hLine = 0;
    }


    // re-initialize TAPI if it needs to be re-initialized
    if ( gfNeedToReinit ) 
    {
        CloseTAPI();

        errCode = InitializeTAPI();
        if(errCode)
        {
            errString(ghWndMain, errCode, MB_APPLMODAL | MB_ICONEXCLAMATION );
            DialerCleanup(); // terminate program if we can't init
            return;
        }

        errCode = lineRegisterRequestRecipient (
                                                ghLineApp,
                                                0, 
                                                LINEREQUESTMODE_MAKECALL,
                                                TRUE
                                               );
        if (errCode)
        {
            errString(ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK );
        }

        gfNeedToReinit = FALSE;
    }
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
int errString( HWND hWndOwner, UINT errCode, UINT uFlags )
{
    PTSTR ptStrTitle;
    PTSTR ptStrError;
    int   nResult;
    BOOL  bDefault = FALSE;

    ptStrTitle = DialerAlloc( MAXBUFSIZE*sizeof(TCHAR) );
    if ( NULL == ptStrTitle )
    {
       // Now, _this_ is a problem.
       return 0;
    }

    ptStrError = DialerAlloc( MAXBUFSIZE*sizeof(TCHAR) );
    if ( NULL == ptStrError )
    {
       // Now, _this_ is a problem.
       DialerFree( ptStrTitle);
       return 0;
    }

    switch(errCode)
    {
        case ERR_NOLINES:
            errCode = ikszErrNoVoiceLine;
            break;

        case ERR_NOVOICELINE:
            errCode = ikszErrNoVoiceLine;
            break;
    
        case ERR_LINECLOSE:
            errCode = ikszErrLineClose;
            break;

        case ERR_911WARN:
            errCode = ikszWarningFor911;
            break;
    
        case ERR_NEWDEFAULT:
            errCode = ikszWarningNewDefault;
            break;

        case LINEERR_NODRIVER:
            errCode = ikszErrLineInitNoDriver;
            break;
    
        case LINEERR_NODEVICE:
            errCode = ikszErrLineInitNoDevice;
            break;
    
        case LINEERR_INIFILECORRUPT:
            errCode = ikszErrLineInitBadIniFile ;
            break;
    
        case LINEERR_NOMEM:
            errCode = ikszErrOOM;
            break;
    
        case LINEERR_INCOMPATIBLEAPIVERSION:
            errCode = ikszErrLineInitWrongDrivers ;
            break;
    
        case LINEERR_OPERATIONFAILED:
            errCode = ikszErrTAPI;
            break;
    
        case LINEERR_INVALADDRESS:
            errCode = ikszErrInvalAddress;
            break;
    
        case LINEERR_ADDRESSBLOCKED:
            errCode = ikszErrAddrBlocked;
            break;
    
        case LINEERR_BILLINGREJECTED:
            errCode = ikszErrBillingRejected;
            break;
    
        case LINEERR_RESOURCEUNAVAIL:
        case LINEERR_ALLOCATED:
        case LINEERR_INUSE:
            errCode = ikszErrResUnavail;
            break;
    
        case LINEERR_NOMULTIPLEINSTANCE:
            errCode = ikszErrNoMultipleInstance;
            break;
    
        case LINEERR_INVALCALLSTATE:
            errCode = ikszErrInvalCallState;
            break;

        case LINEERR_INVALCOUNTRYCODE:
            errCode = ikszErrInvalidCountryCode;
            break;

        case LINEERR_INVALCALLPARAMS:
            errCode = ikszDisconnectedCantDo;
            break;
    
        default:
            bDefault = TRUE;
            break;

    }


    if (bDefault)
    {
        // if using default error, get TAPI's
        // error message from FormatError()
        if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                           (LPCVOID)GetModuleHandle(TEXT("TAPI32.DLL")),
                           (DWORD)TAPIERROR_FORMATMESSAGE(errCode),
                           0,
                           (LPTSTR)ptStrError,
                           MAXBUFSIZE,
                           NULL))
        {
            // if this fails, fall back on default
            LoadString( ghInst, ikszErrDefault, ptStrError, MAXBUFSIZE);
        }

    }
    else    // not the default error message
    {

        if ( 0 == LoadString( ghInst, errCode, ptStrError, MAXBUFSIZE ) )
        {
            LoadString( ghInst, ikszErrDefault, ptStrError, MAXBUFSIZE );
        }
    }

    LoadString( ghInst, ikszWarningTitle, ptStrTitle, MAXBUFSIZE );

    nResult = MessageBox( hWndOwner, ptStrError, ptStrTitle, uFlags );


    DialerFree( ptStrTitle );
    DialerFree( ptStrError );


    return nResult;
}


/*
 *    Name :
 *        FitTextToButton 
 *
 *    Arguements :
 *        hDlg         handle for the dialog in which this button is embedded
 *        nButtonID     button id of this button
 *        szName        Name to fit on the button. Max size TAPIMAXCALLEDPARTYSIZE
 *
 *    Return :
 *        None
 *
 *    Comments :
 *        Function first checks to see if the button text specified fits in the
 *        button.  If it does not it truncates it appropriately and adds trailing
 *        ellipses.  
 */
VOID FitTextToButton ( HWND hDlg, INT nButtonID, LPTSTR szName )
{

    HDC hDC;
    HFONT hFont, hOldFont;
    HWND hWnd;

    do
    {
        // calculate number of chars. that can fit on 
        // the button
        int    nLen;
        RECT rect;
        SIZE size;
        POINT pt;
        TCHAR buf [TAPIMAXCALLEDPARTYSIZE + 1];

        // get button dimensions
        hWnd = GetDlgItem( hDlg, nButtonID );
        if ( hWnd == NULL )
            break;

        if ( !GetClientRect( hWnd, &rect ) )
            break;
        
        // get character dimensions
        hDC = GetDC( hWnd );
        if ( hDC == NULL )
            break;

        hFont = (HFONT) SendMessage( hWnd, WM_GETFONT, 0, 0 );
        if ( hFont == NULL )
            hOldFont = SelectObject( hDC, GetStockObject( SYSTEM_FONT ) );
        else
            hOldFont = SelectObject( hDC, hFont );

        // add an extra char at the end to compensate for
        // leading space,
        lstrcpy ( buf, szName );
        nLen = lstrlen( buf );
        buf [ nLen ] = TEXT('X');
        buf [ nLen + 1 ] = TEXT('\0');

        if ( !GetTextExtentPoint32( hDC, buf, nLen + 1, &size ) )
            break;

        pt.x = size.cx;
        if ( !LPtoDP( hDC, &pt, 1 ) )
            break;

        // check if name fits on button
        if (  pt.x > rect.right )
        {
            // find how much of the name fits 
            int i = 0;

            nLen = lstrlen( szName );
            for ( i = 0; i < nLen; i++ )
            {
                buf[ i ] = szName[ i ];
                // an extra char is stuffed to compensate for the
                // leading space left by the left alignment
                buf [ i + 1 ] = TEXT('X');
                buf [ i + 2 ] = TEXT('\0');

                // break out in cases of error condition
                if ( !GetTextExtentPoint32( hDC, buf, i + 2, &size ) )
                {
                    i = nLen;
                    break;
                }

                pt.x = size.cx;
                if ( !LPtoDP( hDC, &pt, 1 ) )
                {
                    i = nLen;
                    break;
                }
                    
                if ( pt.x > rect.right ) 
                    break;
            }

            // error
            if ( i >= nLen )
                break;

            // name is too long. truncate and add ellipses
            szName [i - 3] = TEXT('\0');
            lstrcat( szName, TEXT("...") );
        }

    } while( FALSE );

    if ( hDC )
    {
        SelectObject( hDC, hOldFont );
        ReleaseDC( hWnd, hDC );
    }

    return;
}



/*
 *    Name :
 *        Is911
 *
 *    Arguements :
 *        lpTransOut -        Translated address contained the dialable string
 *
 *    Returns
 *        TRUE -                If number to be dialed (in the US) is prefixed by 911 
 *        FALSE -                Otherwise
 *
 * Comments
 *
 */
BOOL Is911 ( LPLINETRANSLATEOUTPUT lpTransOut )
{

    DWORD i = 0, j = 0;    
    LPTSTR lpDialDigits = (LPTSTR)((char*)lpTransOut + lpTransOut-> dwDialableStringOffset);
    TCHAR sz3Pref [ 4 ] = TEXT("");


    // if this is not the US
    if ( lpTransOut-> dwCurrentCountry != 1 )
        return FALSE;

    // skip non digit characters and extract
    // the first 3 digits in the dialable number
    for ( i = 0, j = 0; i < lpTransOut-> dwDialableStringSize ; i++ )
    {
        if ( ISDIGIT( lpDialDigits[i] ) )
        {
            sz3Pref[ j++ ] = lpDialDigits [ i ];
            sz3Pref[ j ] = TEXT('\0'); 
            if ( j == 3 )
                break;
        }
    }

    if ( !lstrcmp( sz3Pref, TEXT("911") ) )
    {
        return TRUE;
    }

    return FALSE;
}


/*
 *    Name :
 *        MakeCanonicalNumber
 *
 *    Arguements :
 *        szNumber         Number to convert into canonical form. Max size TAPIMAXDESTADDRESSSIZE
 *        szCanNumber        Canonical representation of number specified in szNumber
 *
 *    Return :
 *        TRUE            If the conversion was successful.
 *        FALSE            otherwise
 *
 *    Comments :
 *        Function first checks if given number is already in canonical form.
 *        If it is, it returns.  If it is not, then it performs the conversion.
 */
 
BOOL MakeCanonicalNumber ( LPCTSTR szNumber, LPTSTR szCanNumber )
{
    TCHAR szDigits [ TAPIMAXDESTADDRESSSIZE ];
    TCHAR szPref [ TAPIMAXDESTADDRESSSIZE ];

    BOOL bRes = FALSE;

    BOOL bTryAgain = TRUE;

    INT errCode = -1;
    INT nLenPref, nLenDigits, cPos, i;

    DWORD dwSize = 0;
    DWORD dwInd = 0;

    LPLINETRANSLATEOUTPUT lpTransOut = NULL;
    LPLINETRANSLATECAPS lpTransCaps = NULL;


    dwSize = sizeof ( LINETRANSLATEOUTPUT );
    do
    {
        lpTransOut = ( LPLINETRANSLATEOUTPUT ) DialerAlloc ( dwSize );
        if ( !lpTransOut )
        {
            errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK );
            goto error;
        }

        while (TRUE)
        {
            lpTransOut-> dwTotalSize = dwSize;
            errCode = lineTranslateAddress (
                                                ghLineApp,
                                                giCurrentLine,
                                                gCurrentLineInfo.dwAPIVersion,
                                                szNumber,
                                                0,
                                                0,
                                                lpTransOut
                                           );
            if ( (LINEERR_INIFILECORRUPT != errCode) ||
                 (FALSE == bTryAgain) )
            {
                break;
            }

            bTryAgain = FALSE;
            errCode = lineTranslateDialog (
                                            ghLineApp,
                                            giCurrentLine,
                                            TAPI_VERSION_1_4,
                                            NULL,
                                            szNumber
                                          );
            if (NO_ERROR != errCode)
            {
                break;
            }
        }

        if (errCode)
        {
            goto error;
        }

        if ( lpTransOut-> dwNeededSize <= lpTransOut-> dwTotalSize )
            break;

        dwSize = lpTransOut-> dwNeededSize;
        DialerFree( lpTransOut );

    } while (TRUE);

    
    // check if input number is already in 
    // canonical form.
    if ( lpTransOut-> dwTranslateResults & LINETRANSLATERESULT_CANONICAL )
        goto error;

    // ensure country is the USA.
    if ( lpTransOut-> dwCurrentCountry != 1 )
        goto error;


    // Extract the digits from given string
    // allowed formatting characters that are ignored are
    // space, (, ), -, . 
    // presence of other characters will render the string invalid.
    
    // find the prefix of the address upto the | mark.
    // the rest of the string can be ignored
    nLenPref = _tcscspn ( szNumber, TEXT("|") );
    lstrcpyn( szPref, szNumber, nLenPref+1 );
    szPref[ nLenPref ] = TEXT('\0');

    // if string is not composed entirely of digits
    // and allowable formating characters, quit conversion
    if ( _tcsspn( szPref, TEXT(" 0123456789()-.") ) != (size_t) nLenPref )
        goto error;

    // collect digits ignoring formating characters.
    szDigits[ 0 ] = TEXT('\0');
    for ( i = 0, nLenDigits = 0; i < nLenPref; i++ )
    {
        if ( ISDIGIT( szNumber[ i ] ) )
        {
            szDigits[ nLenDigits++ ] = szNumber[ i ];
        }
    }
    szDigits[ nLenDigits ] = TEXT('\0');

    // if "internal" number
    if ( nLenDigits < LOCAL_NUMBER )
        goto error;

    switch ( nLenDigits )
    {
        // Local number ( 7 digits) preceeded by a 0/1
        // Strip leading 0/1 and treat as a local number
        case EXTENDED_LOCAL_NUMBER:
            if ( szDigits[ 0 ] == TEXT('0') || szDigits[ 0 ] == TEXT('1') )
            {
                nLenDigits--;
                memmove( szDigits, &(szDigits[1]), nLenDigits*sizeof(TCHAR) );
                szDigits[ nLenDigits ] = TEXT('\0');

                cPos = _tcscspn( szPref, TEXT("01") );
                nLenPref--;
                memmove( &(szPref[ cPos ]), &(szPref[ cPos + 1 ]), (nLenPref - cPos)*sizeof(TCHAR) );
                szPref[ nLenPref ] = TEXT('\0');
            }
            else
            {
                goto error;
            }

        case LOCAL_NUMBER :
        {
            LPLINELOCATIONENTRY lpLocLst;

            // if leading digit is 0 or 1, it is 
            // illegal in the US
            if ( szDigits[ 0 ] == TEXT('0') || szDigits[ 0 ] == TEXT('1') )
            {
                goto error;
            }

            // get area code nformation for local number
            dwSize = sizeof( LINETRANSLATECAPS );
            do
            {
                lpTransCaps = (LPLINETRANSLATECAPS) DialerAlloc( dwSize );
                if ( !lpTransCaps )
                {
                    errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK );
                    goto error;
                }

                lpTransCaps-> dwTotalSize = dwSize;
                errCode = lineGetTranslateCaps (
                                                ghLineApp,
                                                gCurrentLineInfo.dwAPIVersion,
                                                lpTransCaps
                                               );
                if ( errCode )
                {
                    errString( ghWndMain, errCode, MB_ICONSTOP | MB_OK );
                    goto error;
                }

                if ( lpTransCaps-> dwNeededSize <= lpTransCaps-> dwTotalSize )
                {
                    break;
                }

                dwSize = lpTransCaps-> dwNeededSize;
                DialerFree( lpTransCaps );

            } while ( TRUE );

            // skip entries till you locate information for current location
            dwSize = sizeof( LINELOCATIONENTRY );
            lpLocLst = (LPLINELOCATIONENTRY) ( (LPTSTR) ((char*)lpTransCaps + 
                                                lpTransCaps-> dwLocationListOffset) );

            for ( dwInd = 0; dwInd < lpTransCaps-> dwNumLocations ; dwInd++ )
            {
                if ( lpLocLst[ dwInd ].dwPermanentLocationID == lpTransCaps-> dwCurrentLocationID )
                    break;
            }
            
            // current location no found ?????
            // login error
            if ( dwInd == lpTransCaps-> dwNumLocations )
            {
                goto error;
            }

            // construct canonical form as
            szCanNumber[ 0 ]= TEXT('\0');
            lstrcat( szCanNumber, TEXT("+1 (") );
            lstrcat( szCanNumber, (LPTSTR) ((char*)lpTransCaps + lpLocLst[ dwInd ].dwCityCodeOffset) );
            lstrcat( szCanNumber, TEXT(") ") );
            lstrcat( szCanNumber, szDigits );

            cPos = _tcscspn( szNumber, TEXT("|") );
            if ( cPos != lstrlen( szNumber ) )
            {
                lstrcat( szCanNumber, &(szNumber[ cPos ]) );
            }

            bRes = TRUE;
            break;
        }

        case EXTENDED_LONG_DISTANCE_NUMBER:
        {
            // Long distance number ( 10 digits) preceeded by a 0/1
            // Strip leading 0/1 and treat as a long distance number
            if ( szDigits[ 0 ] == TEXT('0') || szDigits[ 0 ] == TEXT('1') )
            {
                nLenDigits--;
                memmove( szDigits, &(szDigits[1]), nLenDigits*sizeof(TCHAR) );
                szDigits[ nLenDigits ] = TEXT('\0');

                cPos = _tcscspn( szPref, TEXT("01") );
                nLenPref--;
                memmove( &(szPref[ cPos ]), &(szPref[ cPos + 1 ]), (nLenPref - cPos)*sizeof(TCHAR) );
                szPref[ nLenPref ] = TEXT('\0');
            }
            else
            {
                goto error;
            }

        }

        case LONG_DISTANCE_NUMBER:
        {
            // if first or fourth digit is 0/1, illegal number
            if ( szDigits[ 0 ] == TEXT('0') || szDigits[ 0 ] == TEXT('1') ||
                 szDigits[ 3 ] == TEXT('0') || szDigits[ 3 ] == TEXT('1') )
            {
                goto error;
            }
            
            szCanNumber[ 0 ] = TEXT('\0');
            lstrcat( szCanNumber, TEXT("+1 (") );
            _tcsncat( szCanNumber, szDigits, 3 );
            lstrcat( szCanNumber, TEXT(") ") );

            lstrcat( szCanNumber, &(szDigits[ 3 ]) );
        
            bRes = TRUE;
        }
        break;

        default :
            goto error;
    }

error:
    if ( lpTransOut )
        DialerFree( lpTransOut );

    if ( lpTransCaps )
        DialerFree( lpTransCaps );

    return bRes;
}


/*
 *    Name :
 *        AmpersandCompensate
 *
 *    Arguements :
 *        lpszSrc        :    Src string containing &s
 *        lpszDst        :    Dest string   
 *
 *    Return :
 *
 *    Comments :
 *        Copies string pointed to by lpszSrc to lpszDst character by
 *        character.  If an & is encountered in this process in lpszSrc
 *        it is copied as && into lpszDst.
 *        Assumes lpszDst and lpszSrc are of size TAPIMAXCALLEDPARTYSIZE
 */
VOID AmpersandCompensate ( LPCTSTR lpszSrc, LPTSTR lpszDst )
{
    // check if the name has an & in it.  If so replace
    // it with &&.
    INT cCnt, cInd;

    for ( cCnt = 0, cInd = 0; 
          cInd < TAPIMAXCALLEDPARTYSIZE; 
          cInd++, cCnt++ )
    {
        if ( lpszSrc[ cCnt ] == TEXT('&') )
        {
            lpszDst[ cInd++ ] = TEXT('&');
        }
        lpszDst[ cInd ] = lpszSrc[ cCnt ];

        if ( lpszSrc[ cCnt ] == TEXT('\0') )
            break;
    }

    // make sure string is null terminated.
    lpszDst[ TAPIMAXCALLEDPARTYSIZE - 1 ] = TEXT('\0');

    return;
}


 /*
 *    Name :
 *        AmpersandDeCompensate
 *
 *    Arguements :
 *        lpszSrc        :    Src string containing &s
 *        lpszDst        :    Dest string   
 *
 *    Return :
 *
 *    Comments :
 *        Copies string pointed to by lpszSrc to lpszDst character by
 *        character.  If an && is encountered in this process in lpszSrc
 *        it is copied as & into lpszDst.
 *        Assumes lpszDst and lpszSrc are of size TAPIMAXCALLEDPARTYSIZE
 */
 VOID AmpersandDeCompensate ( LPCTSTR lpszSrc, LPTSTR lpszDst )
 {
    // check if the name has an & in it.  If so replace
    // it with &&.
    INT cCnt, cInd;

    for ( cCnt = 0, cInd = 0; 
          cInd < TAPIMAXCALLEDPARTYSIZE; 
          cInd++, cCnt++ )
    {
        if  ( ( lpszSrc[ cInd ] == TEXT('&') ) &&
              ( lpszSrc[ cInd + 1 ] == TEXT('&') ) )
        {
            cInd++;
        }
        lpszDst[ cCnt ] = lpszSrc[ cInd ] ;

        if ( lpszSrc [ cInd ] == TEXT('\0') )
        {
            break;
        }
    }

    lpszDst[ TAPIMAXCALLEDPARTYSIZE - 1 ] = TEXT('\0');

    return;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\dialer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialer.RC
//
#define IDI_DIALER                      1
#define IDD_DDIAL                       1
#define IDI_LINEBUSY                    116
#define IDA_DIALER                      117
#define IDM_MENU                        118
#define IDD_DIALER                      200
#define IDD_DCOMBO                      201
#define IDD_DBUTTON1                    202
#define IDD_DBUTTON2                    203
#define IDD_DBUTTON3                    204
#define IDD_DBUTTON4                    205
#define IDD_DBUTTON5                    206
#define IDD_DBUTTON6                    207
#define IDD_DBUTTON7                    208
#define IDD_DBUTTON8                    209
#define IDD_DBUTTON9                    210
#define IDD_DBUTTON0                    211
#define IDD_DBUTTONSTAR                 212
#define IDD_DBUTTONPOUND                213
#define IDD_DSPEEDDIAL1                 214
#define IDD_DSPEEDDIAL2                 215
#define IDD_DSPEEDDIAL3                 216
#define IDD_DSPEEDDIAL4                 217
#define IDD_DSPEEDDIAL5                 218
#define IDD_DSPEEDDIAL6                 219
#define IDD_DSPEEDDIAL7                 220
#define IDD_DSPEEDDIAL8                 221
#define IDD_DSPEEDDIALGRP               222
#define IDD_DNUMTODIAL                  223
#define IDD_DRECTSEPARATOR              224
#define IDD_DSPEEDDIALTEXT1             225
#define IDD_DSPEEDDIALTEXT2             226
#define IDD_DSPEEDDIALTEXT3             227
#define IDD_DSPEEDDIALTEXT4             228
#define IDD_DSPEEDDIALTEXT5             229
#define IDD_DSPEEDDIALTEXT6             230
#define IDD_DSPEEDDIALTEXT7             231
#define IDD_DSPEEDDIALTEXT8             232
#define IDD_SD1                         300
#define IDD_SD1SPEEDDIAL1               301
#define IDD_SD1SPEEDDIAL2               302
#define IDD_SD1SPEEDDIAL3               303
#define IDD_SD1SPEEDDIAL4               304
#define IDD_SD1SPEEDDIAL5               305
#define IDD_SD1SPEEDDIAL6               306
#define IDD_SD1SPEEDDIAL7               307
#define IDD_SD1SPEEDDIAL8               308
#define IDD_SD1EDITNAME                 317
#define IDD_SD1EDITNUMBER               318
#define IDD_SD1TEXTCHOOSE               319
#define IDD_SD1TEXTENTER                320
#define IDD_SD1TEXTNAME                 321
#define IDD_SD1TEXTNUMBER               322
#define IDD_SD1RECTSEPARATOR            323
#define IDD_SD1SPEEDDIALTEXT1           324
#define IDD_SD1SPEEDDIALTEXT2           325
#define IDD_SD1SPEEDDIALTEXT3           326
#define IDD_SD1SPEEDDIALTEXT4           327
#define IDD_SD1SPEEDDIALTEXT5           328
#define IDD_SD1SPEEDDIALTEXT6           329
#define IDD_SD1SPEEDDIALTEXT7           330
#define IDD_SD1SPEEDDIALTEXT8           331
#define IDD_SD2                         400
#define IDD_SD2SAVEANDDIAL              401
#define IDD_SD2EDITNAME                 402
#define IDD_SD2EDITNUMBER               403
#define IDD_SD2TEXTENTER                404
#define IDD_SD2TEXTNAME                 405
#define IDD_SD2TEXTNUMBER               406
#define IDD_CONNECTUSING                500
#define IDD_CULISTLINE                  501
#define IDD_CULISTADDRESS               502
#define IDD_CUSIMPLETAPICHKBOX          503
#define IDD_CUTEXTLINE                  504
#define IDD_CUTEXTADDRESS               505
#define IDD_CUPROPERTIES                506
#define IDD_ABOUT                       700
#define IDD_AICON                       701
#define IDD_ATEXTTITLE                  702
#define IDD_ATEXTVERSION                703
#define IDD_ATEXTWINMODE                704
#define IDD_ATEXTFREEMEM                705
#define IDD_ATEXTRESOURCE               706
#define IDD_ATEXTCOPYRIGHT              707
#define IDD_INUSE                       900
#define IDD_IUICON                      901
#define ikszAppName                     901
#define IDD_IUTEXT1                     902
#define ikszAppFriendlyName             902
#define IDD_IUTEXT2                     903
#define ikszErrDefault                  940
#define ikszErrOOM                      941
#define ikszErrTAPI                     942
#define ikszErrNoVoiceLine              943
#define ikszErrInvalAddress             945
#define ikszErrLineInitWrongDrivers     949
#define ikszErrAddrBlocked              950
#define ikszErrBillingRejected          952
#define ikszErrResUnavail               956
#define ikszWarningTitle                977
#define ikszWarningRegisterSTapi        978
#define ikszWarningFor911               978
#define ikszWarningNewDefault           979
#define IDM_EXIT                        1000
#define IDM_EDIT_CUT                    1001
#define IDM_EDIT_COPY                   1002
#define IDD_DGNUMBERTEXT                1002
#define IDM_EDIT_PASTE                  1003
#define IDM_EDIT_DELETE                 1004
#define IDD_DGNAMETEXT                  1004
#define IDM_EDIT_SPEEDDIAL              1005
#define IDM_CONNECTUSING                1006
#define IDM_LOCATION                    1008
#define IDM_HELP_CONTENTS               1010
#define IDM_ABOUT                       1011
#define IDM_ACCEL_NUMTODIAL             1012
#define ikszErrLineInitBadIniFile       1013
#define IDM_ACCEL_HELP                  1013
#define ikszErrLineInitNoDriver         1014
#define ikszErrBadTAPIAddr              1015
#define IDM_HELP_WHATSTHIS              1015
#define ikszErrLineInitNoDevice         1016
#define ikszErrNoMultipleInstance       1020
#define IDD_CALLFAILED                  1300
#define IDD_CFTEXT                      1301
#define ikszWarning911                  1544
#define ikszDisconnectedReject          1545
#define ikszDisconnectedBusy            1546
#define ikszDisconnectedNoAnswer        1547
#define ikszDisconnectedCantDo          1548
#define ikszDisconnectedNetwork         1549
#define ikszDisconnectedIncompatible    1550
#define ikszErrInvalCallState           1551
#define ikszWarningTapiReInit           1552
#define ikszErrLineClose                1553
#define ikszDisconnectedNoDialTone      1554
#define ikszErrInvalidCountryCode       1555
#define IDD_DIALING                     9115
#define IDD_CUERRORTEXT                 -1
#define IDD_DGNUMBER                    -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        9116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           9101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapitna\privateold.h ===
extern HINSTANCE ghUIInst;
//extern const WCHAR     gszCardKeyW[];

//***************************************************************************
//***************************************************************************
//***************************************************************************
void AllocNewID( HKEY MainKey, LPDWORD lpdw );
void PASCAL WideStringToNotSoWideString( LPBYTE lpBase, LPDWORD lpdwThing );
PWSTR PASCAL MultiToWide( LPCSTR  lpStr );
PWSTR PASCAL NotSoWideStringToWideString( LPCSTR lpStr, DWORD dwLength );



//***************************************************************************
//***************************************************************************
//***************************************************************************
typedef enum
{
    Dword,
    lpDword,
    hXxxApp,
    hXxxApp_NULLOK,
//    lpsz,
    lpszW,
    lpGet_SizeToFollow,
    lpSet_SizeToFollow,
    lpSet_Struct,
    lpGet_Struct,
    Size,
    Hwnd

} ARG_TYPE;


typedef struct _FUNC_ARGS
{
    DWORD               Flags;

    ULONG_PTR           Args[MAX_TAPI_FUNC_ARGS];

    BYTE                ArgTypes[MAX_TAPI_FUNC_ARGS];

} FUNC_ARGS, *PFUNC_ARGS;


typedef struct _UI_REQUEST_THREAD_PARAMS
{
    BOOL                bRequestCompleted;

    PFUNC_ARGS          pFuncArgs;

    LONG                lResult;

} UI_REQUEST_THREAD_PARAMS, *PUI_REQUEST_THREAD_PARAMS;


typedef struct _INIT_DATA
{
    DWORD               dwKey;

    DWORD               dwInitOptions;

    union
    {
        HWND            hwnd;

        HANDLE          hEvent;

        HANDLE          hCompletionPort;
    };

    union
    {
        LINECALLBACK    lpfnCallback;

        DWORD           dwCompletionKey;
    };

    HLINEAPP            hXxxApp;

    BOOL                bPendingAsyncEventMsg;

    DWORD               dwNumTotalEntries;

    DWORD               dwNumUsedEntries;

    PASYNC_EVENT_PARAMS pEventBuffer;

    PASYNC_EVENT_PARAMS pValidEntry;

    PASYNC_EVENT_PARAMS pFreeEntry;

    DWORD               dwNumLines;

    BOOL                bLine;

    DWORD               dwThreadID;

} INIT_DATA, *PINIT_DATA;



#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

DWORD   gdwDebugLevel;

#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    );

#else

#define DBGOUT(arg)

#define DOFUNC(arg1,arg2) DoFunc(arg1)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapitna\tapitna.h ===
#if !defined(tapitna_h)
#define tapitna_h

#define IDM_CONTEXTMENU 203
#define IDM_DIALINGPROPERTIES    204
#define IDM_OTHERMENUITEM        205
#define IDM_LOCATIONMENU         206
#define IDM_LAUNCHDIALER         207
#define IDM_CLOSEIT              208
#define IDM_ABOUT                209
#define IDM_PROPERTIES           210


//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   

//This value is a base.  A menu is dynamically created with as many menuitems
//as there are locations.  The menuid starts with IDM_LOCATION0 and is
//incremented for each.  So, don't use any values above 700 (for how many?).

#define IDM_LOCATION0   700

//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   
//*** *** ***WARNING   WARNING   WARNING   WARNING   WARNING   WARNING   


#define IDS_CAPTION               401
#define IDS_SELECTNEWLOCATION     402
#define IDS_ABOUTTEXT             403
#define IDS_LOCATIONCHANGED       404
#define ALTDATA                   405
#define IDS_CANTFINDLOCATIONID    406
#define IDS_CANTFINDLOCATIONNAME  407
#define IDS_HELP                  408


#define IDI_TAPITNAICON  501


#define IDR_RBUTTONMENU 601



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapitna\general.h ===
#define FLAG_AUTOLAUNCH               0x00000001
#define FLAG_AUTOLOCATIONID           0x00000002
#define FLAG_PROMPTAUTOLOCATIONID     0x00000004
#define FLAG_ANNOUNCEAUTOLOCATIONID   0x00000008
#define FLAG_UPDATEONSTARTUP          0x00000010

INT_PTR
CALLBACK
GeneralDlgProc(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );


#define MAX_CONFIGPROFILES 4

#define IDC_STATIC                      -1


#define IDD_GENERAL                     114



//WARNING GENERAL.C _ASSUMES_ that the defines for the profile comboboxes are
//sequential
#define IDCS_DL_PROFILETEXT              5017
#define IDCB_DL_PROFILE1                 5018
#define IDCB_DL_PROFILE2                 5019
#define IDCB_DL_PROFILE3                 5020
#define IDCB_DL_PROFILE4                 5021

//WARNING GENERAL.C _ASSUMES_ that the defines for the profile texts are
//sequential
#define IDCS_DL_PROFILE1                 5024
#define IDCS_DL_PROFILE2                 5025
#define IDCS_DL_PROFILE3                 5026
#define IDCS_DL_PROFILE4                 5027


#define IDCK_DL_LAUNCHTAPITNA               6012
#define IDCK_DL_AUTOLOCATIONID              6013
#define IDCK_DL_PROMPTAUTOLOCATIONID        6014
#define IDCK_DL_ANNOUNCEAUTOLOCATIONID      6015
#define IDCK_DL_UPDATEONSTARTUP             6018

#define IDCS_DL_PROMPTAUTOLOCATIONID        6016
#define IDCS_DL_ANNOUNCEAUTOLOCATIONID         6017
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapitna\client.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    client.h

Abstract:

    Header file for tapi client module

Author:

    Dan Knudson (DanKn)    01-Apr-1994

Revision History:

--*/


#define TAPI_VERSION1_0           0x00010003
#define TAPI_VERSION1_4           0x00010004
#define TAPI_VERSION2_0           0x00020000
#define TAPI_VERSION2_1           0x00020001
#define TAPI_VERSION2_2           0x00020002
#define TAPI_VERSION3_0           0x00030000
#define TAPI_VERSION_CURRENT      TAPI_VERSION3_0

#define NUM_ARGS_MASK             0x0000000f

#define LINE_FUNC                 0x00000010
#define PHONE_FUNC                0x00000020
#define TAPI_FUNC                 0x00000000

#define ASYNC                     0x00000040
#define SYNC                      0x00000000

#define INITDATA_KEY              ((DWORD) 'INIT')
#define TPROXYREQUESTHEADER_KEY   ((DWORD) 'REQH')

#define WM_ASYNCEVENT             (WM_USER+111)

#define DEF_NUM_EVENT_BUFFER_ENTRIES    16

#define TAPI_SUCCESS                    0
#define TAPI_NO_DATA                    -1
#define MAX_TAPI_FUNC_ARGS              13

#define REMOVEPROVIDER                  0
#define CONFIGPROVIDER                  1
#define ADDPROVIDER                     2
#define TAPI16BITSUCCESS                -2

#define INITIAL_CLIENT_THREAD_BUF_SIZE  512
#define WM_TAPI16_CALLBACKMSG           (WM_USER+101)

#define IsOnlyOneBitSetInDWORD(dw) (dw && !(((DWORD)dw) & (((DWORD)dw) - 1)))

#define AllCallSelect                \
    (LINECALLSELECT_CALL           | \
    LINECALLSELECT_ADDRESS         | \
    LINECALLSELECT_LINE)

#define AllDigitModes                \
    (LINEDIGITMODE_PULSE           | \
    LINEDIGITMODE_DTMF             | \
    LINEDIGITMODE_DTMFEND)

#define AllForwardModes              \
    (LINEFORWARDMODE_UNCOND        | \
    LINEFORWARDMODE_UNCONDINTERNAL | \
    LINEFORWARDMODE_UNCONDEXTERNAL | \
    LINEFORWARDMODE_UNCONDSPECIFIC | \
    LINEFORWARDMODE_BUSY           | \
    LINEFORWARDMODE_BUSYINTERNAL   | \
    LINEFORWARDMODE_BUSYEXTERNAL   | \
    LINEFORWARDMODE_BUSYSPECIFIC   | \
    LINEFORWARDMODE_NOANSW         | \
    LINEFORWARDMODE_NOANSWINTERNAL | \
    LINEFORWARDMODE_NOANSWEXTERNAL | \
    LINEFORWARDMODE_NOANSWSPECIFIC | \
    LINEFORWARDMODE_BUSYNA         | \
    LINEFORWARDMODE_BUSYNAINTERNAL | \
    LINEFORWARDMODE_BUSYNAEXTERNAL | \
    LINEFORWARDMODE_BUSYNASPECIFIC)

#define AllTerminalModes             \
    (LINETERMMODE_BUTTONS          | \
    LINETERMMODE_LAMPS             | \
    LINETERMMODE_DISPLAY           | \
    LINETERMMODE_RINGER            | \
    LINETERMMODE_HOOKSWITCH        | \
    LINETERMMODE_MEDIATOLINE       | \
    LINETERMMODE_MEDIAFROMLINE     | \
    LINETERMMODE_MEDIABIDIRECT)

#define AllToneModes                 \
    (LINETONEMODE_CUSTOM           | \
    LINETONEMODE_RINGBACK          | \
    LINETONEMODE_BUSY              | \
    LINETONEMODE_BEEP              | \
    LINETONEMODE_BILLING)

#define AllHookSwitchDevs            \
    (PHONEHOOKSWITCHDEV_HANDSET    | \
    PHONEHOOKSWITCHDEV_SPEAKER     | \
    PHONEHOOKSWITCHDEV_HEADSET)

#define AllHookSwitchModes           \
    (PHONEHOOKSWITCHMODE_ONHOOK    | \
    PHONEHOOKSWITCHMODE_MIC        | \
    PHONEHOOKSWITCHMODE_SPEAKER    | \
    PHONEHOOKSWITCHMODE_MICSPEAKER)

#define AllLampModes                 \
    (PHONELAMPMODE_BROKENFLUTTER   | \
    PHONELAMPMODE_FLASH            | \
    PHONELAMPMODE_FLUTTER          | \
    PHONELAMPMODE_OFF              | \
    PHONELAMPMODE_STEADY           | \
    PHONELAMPMODE_WINK             | \
    PHONELAMPMODE_DUMMY)

#define AllMediaModes                \
    (LINEMEDIAMODE_UNKNOWN         | \
    LINEMEDIAMODE_INTERACTIVEVOICE | \
    LINEMEDIAMODE_AUTOMATEDVOICE   | \
    LINEMEDIAMODE_DIGITALDATA      | \
    LINEMEDIAMODE_G3FAX            | \
    LINEMEDIAMODE_G4FAX            | \
    LINEMEDIAMODE_DATAMODEM        | \
    LINEMEDIAMODE_TELETEX          | \
    LINEMEDIAMODE_VIDEOTEX         | \
    LINEMEDIAMODE_TELEX            | \
    LINEMEDIAMODE_MIXED            | \
    LINEMEDIAMODE_TDD              | \
    LINEMEDIAMODE_ADSI             | \
    LINEMEDIAMODE_VOICEVIEW        | \
    LINEMEDIAMODE_VIDEO)


typedef enum
{
    xGetAsyncEvents,
    xGetUIDllName,
    xUIDLLCallback,
    xFreeDialogInstance,

    lAccept,
    lAddToConference,
    lAgentSpecific,
    lAnswer,
    lBlindTransfer,
    lClose,
    lCompleteCall,
    lCompleteTransfer,
//    lConditionalMediaDetection,  //remotesp
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
    lDrop,
    lForward,
    lGatherDigits,
    lGenerateDigits,
    lGenerateTone,
    lGetAddressCaps,
    lGetAddressID,
    lGetAddressStatus,
    lGetAgentActivityList,
    lGetAgentCaps,
    lGetAgentGroupList,
    lGetAgentStatus,
    lGetAppPriority,
    lGetCallAddressID,          // remotesp only
    lGetCallInfo,
    lGetCallStatus,
    lGetConfRelatedCalls,
    lGetCountry,
    lGetDevCaps,
    lGetDevConfig,
    lGetIcon,
    lGetID,
    lGetLineDevStatus,
    lGetNewCalls,
    lGetNumAddressIDs,          // remotesp only
    lGetNumRings,
    lGetProviderList,
    lGetRequest,
    lGetStatusMessages,
//In TAPI32.DLL now:    lGetTranslateCaps,
    lHandoff,
    lHold,
    lInitialize,
    lMakeCall,
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
    lPark,
    lPickup,
    lPrepareAddToConference,
    lProxyMessage,
    lProxyResponse,
    lRedirect,
    lRegisterRequestRecipient,
    lReleaseUserUserInfo,
    lRemoveFromConference,
    lSecureCall,
//    lSelectExtVersion,
    lSendUserUserInfo,
    lSetAgentActivity,
    lSetAgentGroup,
    lSetAgentState,
    lSetAppPriority,
    lSetAppSpecific,
    lSetCallData,
    lSetCallParams,
    lSetCallPrivilege,
    lSetCallQualityOfService,
    lSetCallTreatment,
//In TAPI32.DLL now:    lSetCurrentLocation,
    lSetDefaultMediaDetection,  // remotesp only
    lSetDevConfig,
    lSetLineDevStatus,
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
//In TAPI32.DLL now:    lSetTollList,
    lSetupConference,
    lSetupTransfer,
    lShutdown,
    lSwapHold,
//In TAPI32.DLL now:    lTranslateAddress,
    lUncompleteCall,
    lUnhold,
    lUnpark,

    pClose,
    pDevSpecific,
    pGetButtonInfo,
    pGetData,
    pGetDevCaps,
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetID,
    pGetIcon,
    pGetLamp,
    pGetRing,
    pGetStatus,
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
//    pSelectExtVersion,      // remotesp
    pSetButtonInfo,
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

//In TAPI32.DLL now:    tGetLocationInfo,
    tRequestDrop,
    tRequestMakeCall,
    tRequestMediaCall,
//    tMarkLineEvent,
    tReadLocations,
    tWriteLocations,
    tAllocNewID,
    tPerformance,
    lConditionalMediaDetection,  //remotesp
    lSelectExtVersion,
    pSelectExtVersion,      // remotesp
//    lOpenInt,
//    lShutdownInt,

    //
    // Ordinals for tapi 2.1 ended here.  the lOpenInt & lShutdownInt
    // were Win95 local-machine-only hacks which have since been removed
    //

    xNegotiateAPIVersionForAllDevices, // remotesp

    mGetAvailableProviders,
    mGetLineInfo,
    mGetPhoneInfo,
    mGetServerConfig,
    mSetLineInfo,
    mSetPhoneInfo,
    mSetServerConfig,

    //
    // Ordinals for 2.1 update (nt4 sp4) ended here.
    //

    lMSPIdentify,
    lReceiveMSPData,

    lGetCallHubTracking,
    lGetCallIDs,
    lGetHubRelatedCalls,
    lSetCallHubTracking,
    xPrivateFactoryIdentify,
    lDevSpecificEx,
    lCreateAgent,
    lCreateAgentSession,
    lGetAgentInfo,
    lGetAgentSessionInfo,
    lGetAgentSessionList,
    lGetQueueInfo,
    lGetGroupList,
    lGetQueueList,
    lSetAgentMeasurementPeriod,
    lSetAgentSessionState,
    lSetQueueMeasurementPeriod,
    lSetAgentStateEx,
    lGetProxyStatus,
    lCreateMSPInstance,
    lCloseMSPInstance,

    //
    // The following is always the last one in the list
    //

    xLastFunc

} FUNC_TYPE;



typedef struct _CLIENT_THREAD_INFO
{
    LIST_ENTRY  TlsList;

    LPBYTE      pBuf;

    DWORD       dwBufSize;

} CLIENT_THREAD_INFO, *PCLIENT_THREAD_INFO;


typedef struct _TAPI32_MSG
{
    //
    // The following union is used:
    //
    //   1. by requests from client to server to specify a function type
    //   2. by acks from server to client to specify a return value
    //   3. by async msgs from server to client to specify msg type
    //

    union
    {
        DWORD       Req_Func;

        LONG_PTR    Ack_ReturnValue;

        DWORD       Msg_Type;

    } u;


    //
    // The following...
    //

    ULONG_PTR       hRpcClientInst;


    //
    // Function paramters
    //

    ULONG_PTR       Params[MAX_TAPI_FUNC_ARGS];

} TAPI32_MSG, *PTAPI32_MSG;


typedef struct _ASYNCEVENTMSG
{
    ULONG_PTR               TotalSize;
    ULONG_PTR               InitContext;
    ULONG_PTR               pfnPostProcessProc;
    ULONG_PTR               hDevice;

    ULONG_PTR               Msg;
    ULONG_PTR               OpenContext;
    ULONG_PTR               Param1;
    ULONG_PTR               Param2;

    ULONG_PTR               Param3;
    ULONG_PTR               Param4;

} ASYNCEVENTMSG, *PASYNCEVENTMSG;


typedef void (PASCAL *POSTPROCESSPROC)(PASYNCEVENTMSG pMsg);


typedef struct _ASYNC_EVENT_PARAMS
{
    DWORD                   hDevice;
    DWORD                   dwMsg;
    ULONG_PTR               dwCallbackInstance;
    ULONG_PTR               dwParam1;

    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;

} ASYNC_EVENT_PARAMS, *PASYNC_EVENT_PARAMS;


typedef LONG (PASCAL *TUISPIPROC)();


typedef struct _UITHREADDATA
{
    HTAPIDIALOGINSTANCE     htDlgInst;
    HINSTANCE               hUIDll;
    HANDLE                  hThread;
    HANDLE                  hEvent;

    LPVOID                  pParams;
    DWORD                   dwSize;
    TUISPIPROC              pfnTUISPI_providerGenericDialog;
    TUISPIPROC              pfnTUISPI_providerGenericDialogData;

    struct _UITHREADDATA   *pPrev;
    struct _UITHREADDATA   *pNext;

} UITHREADDATA, *PUITHREADDATA;


typedef struct _PROXYREQUESTHEADER
{
    DWORD                   dwKey;

    DWORD                   dwInstance;

} PROXYREQUESTHEADER, *PPROXYREQUESTHEADER;


#if DBG
extern char    gszDebug[];
#endif
//extern const char    gszLocation[];
//extern const char    gszLocations[];
extern const char    gszCurrentLocation[];
extern const CHAR    gszNullString[];


#if DBG
#define ClientAlloc( __size__ ) ClientAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

#else
#define ClientAlloc( __size__ ) ClientAllocReal( __size__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize
    );

#endif
    
SIZE_T
WINAPI
ClientSize(
    LPVOID  lp
    );

void
WINAPI
ClientFree(
    LPVOID  lp
    );



LONG
WINAPI
MarkLineEvent(
    DWORD           dwApiVersion,
    DWORD           ptLine,
    DWORD           ptLineClientToExclude,
    DWORD           dwMsg,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwParam3
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapitna\tapitna.c ===
/****************************************************************************

    PROGRAM:  Telephony Location Manager

    PURPOSE:

    FUNCTIONS:

****************************************************************************/

#define STRICT

#include "windows.h"
#include "windowsx.h"
#include "shellapi.h"
#include "prsht.h"
#include "dbt.h"
//#include "stdio.h"

#if WINNT
#else
#include "pbt.h"
#endif

#include "tapi.h"
#include "tapitna.h"

#include "clientr.h"
#include "general.h"


#if DBG
#define DBGOUT(arg) DbgPrt arg
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PTCHAR DbgMessage,
    IN ...
    );
#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)
#else
#define DBGOUT(arg)
#define DOFUNC(arg1,arg2) DoFunc(arg1)
#endif




int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, int );
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message,
                              WPARAM wParam, LPARAM lParam);
static BOOL InitApplication( void );
static BOOL InitInstance( void );


static HINSTANCE ghInst;
static HWND   ghWnd;            /* handle to main window */

static const TCHAR gszConfigMe[] = TEXT("ConfigMe");


LPDWORD lpdwLocationIDs = NULL;
TCHAR buf[356];
TCHAR buf2[356];
int i;


//***************************************************************************
//***************************************************************************
//***************************************************************************

//#define TAPI_API_VERSION  0x00020000
#define TAPI_API_VERSION  0x00010004



//***************************************************************************

extern TCHAR gszCurrentProfileKey[];
extern TCHAR gszStaticProfileKey[];
extern TCHAR gszAutoLaunchKey[];
extern TCHAR gszAutoLaunchValue[];
extern TCHAR gszAutoLocationID[];


extern BOOL GetTranslateCaps( LPLINETRANSLATECAPS FAR * pptc);

//***************************************************************************


// Need to keep tapi initialized so that we can get
// location id changes from Xlate dialog (or lineSetCurrentLocation()...)

HLINEAPP ghLineApp = 0;
//DWORD    gdwTapiAPIVersion = 0;


//***************************************************************************

//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL MachineHasMultipleHWProfiles()
{
   DWORD dwDataSize;
   DWORD dwDataType;
   HKEY  hKey;
   LONG  lResult;


   //
   // Try to get the friendly name for profile #2.  If
   // this fails, that means we only have one config,
   // so there's no point in confusing the user with
   // hotdocking options they can't use...
   //
   lResult = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB"),
                  0,
                  KEY_READ,
                  &hKey
                  );

   if (ERROR_SUCCESS == lResult)
   {
       dwDataSize = sizeof(buf);

       lResult = RegQueryValueEx(
                                  hKey,
                                  TEXT("FriendlyName0002"),
                                  0,
                                  &dwDataType,
                                  (LPBYTE)buf,
                                  &dwDataSize
                               );

       RegCloseKey( hKey );
   }


   return ( ERROR_SUCCESS == lResult);
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG SaveNewLocation( DWORD dwNewLocation )
{
   HKEY hKey;
   DWORD dwTemp;
   LONG lResult;


   //
   // Ok, the user wants to change the location
   //
   DBGOUT((0, TEXT("SaveNewLocation...")));
   {
      //
      // Update the AutoLocationID entry in the current
      // profile config
      //
      lResult = RegCreateKeyEx(
                     HKEY_CURRENT_CONFIG,
                     gszCurrentProfileKey,
                     0,
                     TEXT(""),
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS,
                     NULL,
                     &hKey,
                     &dwTemp
                  );

      if ( 0 == lResult )
      {
         lResult = RegSetValueEx(
                        hKey,
                        gszAutoLocationID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNewLocation,
                        sizeof(DWORD)
                     );

         RegCloseKey( hKey );
      }
   }



   return lResult;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID PASCAL TapiCallbackProc( DWORD hDevice, DWORD dwMsg, DWORD dwCallbackInstance,
                  DWORD dwParam1, DWORD dwParam2, DWORD dwParam3 )
{
   TCHAR buf[256];


//{
//char buf[100];
//wsprintf(buf, "dwMsg=0x%08lx  dwParam1=0x%08lx  dwParam2=0x%08lx  dwParam3=0x%08lx",
//               dwMsg, dwParam1, dwParam2, dwParam3 );
//MessageBox(GetFocus(), buf, "LINEDEVSTATE", MB_OK);
//}


//
// Since we don't bother doing a negotiate (like, cause if there are no
// devices, we _can't_, so why bother at all?), we use the 1.4 cheat of
// looking at dwParam2 and dwParam3 on a REINIT for the real dwMsg and
// dwParam1
//


   if (
         (dwMsg == LINE_LINEDEVSTATE)
       &&
         (dwParam1 == LINEDEVSTATE_REINIT)
      )
   {

      if (
         (dwParam2 == LINE_LINEDEVSTATE)
       &&
         (dwParam3 == LINEDEVSTATE_TRANSLATECHANGE)
      )
      {
         LPLINETRANSLATECAPS ptc;

DBGOUT((0,TEXT("XlateChange!!")));

         if ( GetTranslateCaps(&ptc) )
         {
            SaveNewLocation( ptc->dwCurrentLocationID );
            GlobalFreePtr(ptc);
         }
      }
      else
      if (
         (dwParam2 == 0)
       &&
         (dwParam3 == 0)
      )
      {
         LONG lResult=1;
         UINT nTooManyTries;
         DWORD dwNumDevs;

DBGOUT((0,TEXT("Reinit!!")));

         lineShutdown( ghLineApp );

         LoadString( ghInst,
                     IDS_CAPTION,
                     buf,
                     sizeof(buf) );


         for ( nTooManyTries=0;
               (nTooManyTries<500) && (lResult != 0);
               nTooManyTries++)
         {
            Sleep(1000);
            lResult = lineInitialize( &ghLineApp,
                                       ghInst,
                                       // use the MainWndProc as the callback
                                       // cause we're gonna ignore all of the
                                       // messages anyway...
                                       (LINECALLBACK) TapiCallbackProc,
                                       (LPCSTR) buf,
                                       &dwNumDevs
                                    );
         }
      }

   }

}



//***************************************************************************
//***************************************************************************
//***************************************************************************
void ChangeTapiLocation( UINT nCallersFlag )
{
   HKEY hKey;
   DWORD dwNewLocationID;
   DWORD dwSize = sizeof(dwNewLocationID);
   DWORD dwType;
   DWORD dwMyFlags = 0;
   LONG  lResult;


   //
   // read our flags
   //

   lResult = RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   gszAutoLaunchKey,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );



   if (ERROR_SUCCESS == lResult)
   {
       RegQueryValueEx(
                        hKey,
                        TEXT("AutoLaunchFlags"),
                        0,
                        &dwType,
                        (LPBYTE)&dwMyFlags,
                        &dwSize
                      );

       RegCloseKey( hKey );
   }


   //
   // If the user doesn't want to get involved, 
   // let's get out now.
   //
   if ( 0 == (dwMyFlags & nCallersFlag) )
   {
      return;
   }


   lResult = RegOpenKeyEx(
                   HKEY_CURRENT_CONFIG,
                   gszCurrentProfileKey,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );


   if ( ERROR_SUCCESS == lResult )
   {
      dwSize = sizeof(dwNewLocationID);
      
      lResult = RegQueryValueEx(
                                  hKey,
                                  gszAutoLocationID,
                                  0,
                                  &dwType,
                                  (LPBYTE)&dwNewLocationID,
                                  &dwSize
                               );

   }
#if DBG
   else
   {
MessageBox( GetFocus(), TEXT("...and there's no key"), TEXT("Config changed"), MB_OK);
   }
#endif


   //
   // Did we find the key\value?
   //
   if ( ERROR_SUCCESS == lResult )
   {
      LONG  lTranslateCapsResult;
      LPLINETRANSLATECAPS ptc;


      //
      // Ok, the user wants to change the location
      //
      lTranslateCapsResult = GetTranslateCaps(&ptc);


      //
      // If the location to be set to is the same as the
      // current, do nothing.
      //
      if ( ptc &&
           ptc->dwCurrentLocationID != dwNewLocationID )
      {
         //
         // Check flag - should we confirm with user?
         //
         if ( dwMyFlags & FLAG_PROMPTAUTOLOCATIONID )
         {
         }


         DBGOUT((0, TEXT("ChangeLocation...")));
         lineSetCurrentLocation( ghLineApp, dwNewLocationID );


DBGOUT((0,TEXT("Done.")));


         //
         // Should we tell the user what we've done?
         //
         if ( dwMyFlags & FLAG_ANNOUNCEAUTOLOCATIONID )
         {
            LPTSTR pstrOldLocation = NULL;
            LPTSTR pstrNewLocation = NULL;


//FEATUREFEATURE Tell the user from what location and to what location

            if ( lTranslateCapsResult )
            {
                DWORD i;
                LPLINELOCATIONENTRY ple;
                DWORD dwCurLocID = ptc->dwCurrentLocationID;
                DWORD dwNumLocations = ptc->dwNumLocations;


                //
                // Allocate an array of DWORDs.  This will allow us
                // to map the menuID to the TAPI perm provider ID.
                //
                lpdwLocationIDs = GlobalAllocPtr( GMEM_FIXED, sizeof(DWORD)*dwNumLocations );


                //
                // Put each location in the menu.  When we hit the
                // "current" location, put a check next to it.
                //

                ple = (LPLINELOCATIONENTRY)((LPBYTE)ptc + ptc->dwLocationListOffset);

                for (i = 0; i < dwNumLocations; i++, ple++)
                {

                    if (ptc->dwCurrentLocationID ==
                        ple->dwPermanentLocationID)
                    {
                       pstrOldLocation = (LPTSTR)((LPBYTE)ptc + 
                                        ple->dwLocationNameOffset);
                    }

                    if (dwNewLocationID ==
                        ple->dwPermanentLocationID)
                    {
                       pstrNewLocation = (LPTSTR)((LPBYTE)ptc + 
                                        ple->dwLocationNameOffset);
                    }

                }

            }


            //
            // If the location has since been deleted, we should
            // say something about it.
            //

            if (
                  (NULL == pstrOldLocation)
                ||
                  (NULL == pstrNewLocation)
               )
            {
               LoadString( ghInst,
                           IDS_CANTFINDLOCATIONID,
                           buf2,
                           sizeof(buf2) );

               wsprintf( buf,
                         buf2,
                         dwNewLocationID
                       );
            }
            else
            {
               LoadString( ghInst,
                           IDS_LOCATIONCHANGED,
                           buf2,
                           sizeof(buf2) );

               wsprintf( buf,
                         buf2,
                         pstrOldLocation,
                         pstrNewLocation );

            }

            // We're done using buf2, so reuse it.
            LoadString( ghInst,
                        IDS_CAPTION,
                        buf2,
                        sizeof(buf2) );

            MessageBox(
                        NULL, //GetFocus(),
                        buf,
                        buf2, //  caption
                        MB_OK
                      );

         }

         GlobalFreePtr(ptc);
      }

   }
   else
   {
#if DBG
MessageBox( GetFocus(), TEXT("...and there's no key (or value)"), TEXT("Config changed"), MB_OK);
#endif

   }
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
PTSTR SkipSpaces( PTSTR const ptStr )
{
   PTSTR pStr = ptStr;
   while ( *pStr && (*pStr == ' ' ) )
   {
      pStr++;
   }

   return pStr;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPSTR lpCmdLine,  int nCmdShow)
    {
    MSG msg;
//    int nResult = 1;
//    UINT nSwitchLen;
    TCHAR *pCommandLine;
    TCHAR *pCommandLineSave;
//    TCHAR *pLastStart;
    DWORD dwParmLocationID;
    LONG  lResult;
    BOOL  fDieNow = FALSE;
    DWORD dwCommandLineLength;
    TCHAR buf[256];


    DBGOUT((0, TEXT("Main...")));
         
    ghInst = GetModuleHandle(0);


    if (InitApplication() == 0)
    {
        return (FALSE);
    }

    if (InitInstance() == 0)
    {
        return (FALSE);
    }


    {
       DWORD dwNumDevs;

       LoadString( ghInst,
                   IDS_CAPTION,
                   buf,
                   sizeof(buf) );

       //
       // We initialize TAPI and we never shutdown (except to reinit) so
       // we get notifications if someone changes the location from
       // the Dialing Properties dialog.
       //
       lineInitialize( &ghLineApp,
                       ghInst,
                       // use the MainWndProc as the callback
                       // cause we're gonna ignore all of the
                       // messages anyway...
                       (LINECALLBACK) TapiCallbackProc,
                       (LPCSTR) buf,
                       &dwNumDevs
                     );

    }


//----------------------
//    //
//    // If the user wants it, startup in the config dialog
//    // But we'll only do this if there is more than one HW config...
//    //
//    if ( MachineHasMultipleHWProfiles() )
//    {
//       //
//       // (We do a bunch of stuff "manually" here so we don't have to 
//       // drag in the entire MSVCRT20 for this one function...)
//       //
//       nSwitchLen = lstrlen(gszConfigMe);
//
//       //
//       // 'pLastStart' is the last possible char the string could start on
//       //
//       pLastStart = pCommandLine + 1 + (lstrlen(pCommandLine) - nSwitchLen);
//
//       for ( ; pCommandLine < pLastStart; pCommandLine++)
//       {
//          //
//          // Do a hack so we can use lstrcmpi
//          //
//          TCHAR c;
//
//          c = pCommandLine[nSwitchLen];
//          pCommandLine[nSwitchLen] = '\0';
//         
//          nResult = lstrcmpi( (LPSTR)pCommandLine, gszConfigMe );
//
//          pCommandLine[nSwitchLen] = c;
//
//          if (0 == nResult)
//          {
//             break;
//          }
//       }
//
//       //
//       // Did we find our string?
//       //
//       if ( 0 == nResult )
//       {
//          PostMessage(ghWnd, WM_COMMAND, IDM_PROPERTIES, 0);
//       }
//    }
//----------------------


    dwCommandLineLength = (lstrlen( GetCommandLine() ) + 1) * sizeof(TCHAR);

    pCommandLine = LocalAlloc( LPTR, dwCommandLineLength );
    pCommandLineSave = pCommandLine;  // We'll need this later to free it...

    lstrcpy( pCommandLine, GetCommandLine() );

    while ( *pCommandLine )
    {
       //
       // Is this an arg?
       //
       if (
             ('-' == *pCommandLine)
           ||
             ('/' == *pCommandLine)
          )
       {
          TCHAR c;

          //
          // Figger out what the arg is
          //

          pCommandLine = SkipSpaces( pCommandLine + 1 );


          //
          // Just looking?
          //
          if (
                ('?' == *pCommandLine)
              ||
                ('H' == *pCommandLine)
              ||
                ('h' == *pCommandLine)
             )
          {
             LoadString( ghInst,
                         IDS_HELP,
                         buf,
                         sizeof(buf) );

             LoadString( ghInst,
                         IDS_CAPTION,
                         buf2,
                         sizeof(buf2) );

             MessageBox(GetFocus(), buf, buf2, MB_OK);
//             MessageBox(NULL, buf, buf2, MB_OK);


             //
             // Ok, now that we're leaving, we can shut this down...
             //
             fDieNow = TRUE;
          }


          //
          // Is this a location die-now request?
          //
          if (
                ('X' == *pCommandLine)
              ||
                ('x' == *pCommandLine)
             )
          {
             fDieNow = TRUE;
          }


          //
          // Is this a location ID?
          //
          if (
                ('I' == *pCommandLine)
              ||
                ('i' == *pCommandLine)
             )
          {
             pCommandLine = SkipSpaces( pCommandLine + 1 );


             dwParmLocationID = 0;

             //
             // get digits
             //
             while (
                      (*pCommandLine >= '0')
                    &&
                      (*pCommandLine <= '9')
                   )
             {
                dwParmLocationID = ( dwParmLocationID * 10 ) + 
                                   (*pCommandLine - '0');

                pCommandLine++;
             }

             //
             // Now set the current location to the ID we just gathered
             //
             lResult = lineSetCurrentLocation( ghLineApp, dwParmLocationID );
   
             if ( 0 == lResult )
                 lResult = SaveNewLocation( dwParmLocationID );
                 
             if ( 0 != lResult )
             {
                LoadString( ghInst,
                            IDS_CANTFINDLOCATIONID,
                            buf2,
                            sizeof(buf2) );

                wsprintf( buf, buf2, dwParmLocationID);

                LoadString( ghInst,
                            IDS_CAPTION,
                            buf2,
                            sizeof(buf2) );

                //
                // Messagebox to tell the user what happened
                //
                MessageBox(
                           NULL,
                           buf,
                           buf2,
                           MB_OK | MB_ICONERROR
                          );
             }
          }


          //
          // Is this a location name?
          //
          if (
                ('N' == *pCommandLine)
              ||
                ('n' == *pCommandLine)
             )
          {
             LPLINETRANSLATECAPS ptc;
             PTSTR pszMyString;
             PTSTR pszMyStringPointer;

             pCommandLine = SkipSpaces( pCommandLine + 1 );

             //
             // We'll never need more than the entire command line's len...
             // (and that's better than some arbitraty large number)
             //
             pszMyString = LocalAlloc( LPTR, dwCommandLineLength );
             if (pszMyString == NULL)
             {
                return (FALSE);
             }

             pszMyStringPointer = pszMyString;

             pCommandLine = SkipSpaces( pCommandLine );

             while (
                      (*pCommandLine != '\0')
                    &&
                      (*pCommandLine != '/')
                    &&
                      (*pCommandLine != '-')
                   )
             {
                //
                // add this char to the string
                //
                *pszMyStringPointer = *pCommandLine;

                pszMyStringPointer++;
                pCommandLine++;
             }

             //
             // First, get back to the last char
             //
             pszMyStringPointer--;

             //
             // Now chop off any trailing spaces
             //
             while (
                      (' ' == *pszMyStringPointer)
                    &&
                      (pszMyStringPointer > pszMyString )
                   )
             {
                pszMyStringPointer--;
             }

             //
             // Set the end of the string to be the last non-space in the name
             //
             *(pszMyStringPointer + 1) = '\0';


             if (GetTranslateCaps(&ptc))
             {
                 DWORD i;
                 LPLINELOCATIONENTRY ple;
                 DWORD dwCurLocID = ptc->dwCurrentLocationID;
                 DWORD dwNumLocations = ptc->dwNumLocations;

DBGOUT((0, TEXT("There seem to be %ld locations - ptc=0x%08lx"), dwNumLocations,
                                      ptc));

                 //
                 // See if we can find the string...
                 //

                 ple = (LPLINELOCATIONENTRY)((LPBYTE)ptc + ptc->dwLocationListOffset);

                 for (i = 0; i < dwNumLocations; i++, ple++)
                 {

DBGOUT((0, TEXT("Location #%ld is [%s] at 0x%08lx"),
              i, 
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset),
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset) ));

                     if ( 0 == lstrcmpi( (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset),
                                    pszMyString
                                  )
                        )
                     {
                        dwParmLocationID = ple->dwPermanentLocationID;
                        break;
                     }
                 }


                 //
                 // Did we run the list without finding a match?
                 //
                 if ( i == dwNumLocations )
                 {
                    LoadString( ghInst,
                                IDS_CANTFINDLOCATIONNAME,
                                buf2,
                                sizeof(buf2) );

                    wsprintf( buf, buf2, pszMyString );

                    LoadString( ghInst,
                                IDS_CAPTION,
                                buf2,
                                sizeof(buf2) );

                    //
                    // Messagebox to tell the user what happened
                    //
                    MessageBox(
                               NULL,
                               buf,
                               buf2,
                               MB_OK | MB_ICONERROR
                              );

                     lResult = LINEERR_INVALLOCATION;
                  }
                  else
                  {
                      lResult = lineSetCurrentLocation( ghLineApp, dwParmLocationID );
                       
                      if ( 0 == lResult )
                          lResult = SaveNewLocation( dwParmLocationID );
                  }

                  GlobalFreePtr(ptc);

                  LocalFree( pszMyString );

             }

          }



          //
          // Is this parm "ConfigMe" ?
          //
          c = pCommandLine[ lstrlen( gszConfigMe ) ];

          if ( 0 == lstrcmpi( pCommandLine, gszConfigMe ) )
          {
             //
             // Found this arg.
             //

             //
             // If the user wants it, startup in the config dialog
             // But we'll only do this if there is more than one HW config...
             //
             if ( MachineHasMultipleHWProfiles() )
             {
                PostMessage( ghWnd, WM_COMMAND, IDM_PROPERTIES, 0 );
             }

             //
             // In either case, get past this arg
             //
             pCommandLine[ lstrlen( gszConfigMe ) ] = c;

             pCommandLine += lstrlen( gszConfigMe );
          }

       }
       else
       {
          pCommandLine++;
       }
    }


    LocalFree( pCommandLineSave );


    //
    // Go see if we should auto-update the TAPI location on startup
    //
    ChangeTapiLocation( FLAG_UPDATEONSTARTUP );

    //
    // Should we quit before we start?
    //
    if ( fDieNow )
    {
       DestroyWindow( ghWnd );
    }


    while (GetMessage(&msg, 0, 0, 0) != 0)
    {
       TranslateMessage(&msg);
       DispatchMessage(&msg);
    }


    //
    // Ok, now that we're leaving, we can shut this down...
    lineShutdown( ghLineApp );


    return ((int) msg.wParam);
    }


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

static BOOL InitApplication( void )
    {
    WNDCLASS  wc;

    wc.style          = 0;
    wc.lpfnWndProc    = MainWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = ghInst;
    wc.hIcon          = NULL;
    wc.hCursor        = NULL;
    wc.hbrBackground  = NULL;
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = TEXT("TLOCMGR_WINCLSS");

    return (RegisterClass(&wc));
    }


//***************************************************************************
//***************************************************************************
//***************************************************************************
static BOOL InitInstance( void )
    {
    ghWnd = CreateWindow(
             TEXT("TLOCMGR_WINCLSS"),
             NULL,
             WS_OVERLAPPED | WS_MINIMIZE,
             CW_USEDEFAULT,
             CW_USEDEFAULT,
             CW_USEDEFAULT,
             CW_USEDEFAULT,
             0,
             0,
             ghInst,
             0 );

    if (ghWnd == 0 )
    {
        return ( FALSE );
    }


    ShowWindow(ghWnd, SW_HIDE);


#if WINNT
#else
    RegisterServiceProcess( 0, RSP_SIMPLE_SERVICE);
#endif


    return (TRUE);
    }



//***************************************************************************
//***************************************************************************
//***************************************************************************
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message,
                              WPARAM wParam, LPARAM lParam)
{
    HICON hIcon;
    static DWORD dwCurrentChoice = 0;
    DWORD i;


    static NOTIFYICONDATA nid = {
                           sizeof(NOTIFYICONDATA),
                           0, //hWnd,
                           IDI_TAPITNAICON,
                           NIF_ICON | NIF_MESSAGE | NIF_TIP,
                           WM_USER+0x42,
                           0, //hIcon,
                           0 //pCaption
                        };


    switch ( message )
    {

#if WINNT
        case WM_POWER:
        {
           if (
                 (PWR_SUSPENDRESUME == LOWORD(wParam))
               ||
                 (PWR_CRITICALRESUME == LOWORD(wParam))
              )
           {
DBGOUT((0, TEXT("Power resume(normal or critical)")));
              ChangeTapiLocation( FLAG_UPDATEONSTARTUP );
           }
        }
        break;
#else
        case WM_POWERBROADCAST:
        {
           if (
                 (PBT_APMRESUMESUSPEND == wParam)
               ||
                 (PBT_APMRESUMESTANDBY == wParam)
               ||
                 (PBT_APMRESUMECRITICAL == wParam)
              )
           {
DBGOUT((0, TEXT("Power resume(normal or critical)")));
              ChangeTapiLocation( FLAG_UPDATEONSTARTUP );
           }
        }
        break;
#endif


        case WM_DEVICECHANGE:
        {
           switch (wParam)
           {

//              case DBT_DEVICEARRIVAL:
//MessageBox( GetFocus(), "DBT_DEVICEARRIVAL", "WM_DEVICECHANGE", MB_OK);
//                   break;
//
//              case DBT_DEVICEREMOVECOMPLETE:
//MessageBox( GetFocus(), "DBT_DEVICEREMOVECOMPLETE", "WM_DEVICECHANGE", MB_OK);
//                   break;
//
//              case DBT_MONITORCHANGE:
//MessageBox( GetFocus(), "DBT_MONITORCHANGE", "WM_DEVICECHANGE", MB_OK);
////                   lParam = new resolution   LOWORD=x  HIWORD=y
//                   break;



              case DBT_CONFIGCHANGED:
              {
DBGOUT((0, TEXT("DBG_CONFIGCHANGED")));
                 ChangeTapiLocation( FLAG_AUTOLOCATIONID );
              }
              break;

           }
        }
        break;



        case WM_SETTINGCHANGE:
        {
           //
           // Is it something we're interested in?
           //
//           if ( SPI_SETICONMETRICS == wParam )
           {
//              hIcon = LoadImage(ghInst,
//                                MAKEINTRESOURCE(IDI_TAPITNAICON),
//                                IMAGE_ICON,
//                                GetSystemMetrics(SM_CXSMICON),
//                                GetSystemMetrics(SM_CYSMICON),
//                                0);

              hIcon = LoadImage(ghInst,
                                MAKEINTRESOURCE(IDI_TAPITNAICON),
                                IMAGE_ICON,
                                0,
                                0,
                                0);

              Shell_NotifyIcon( NIM_MODIFY, &nid );

              return 0;
           }
//           else
//           {
//              return (DefWindowProc(hWnd, message, wParam, lParam));
//           }

        }
//        break;


        case WM_CREATE:
        {
           //
           // Well, we're not gonna create a window, but we can do other
           // stuff...
           //

           LoadString (ghInst, IDS_CAPTION, nid.szTip, sizeof (nid.szTip));

//           hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_TAPITNAICON) );
           hIcon = LoadImage(ghInst,
                             MAKEINTRESOURCE(IDI_TAPITNAICON),
                             IMAGE_ICON,
                                0,
                                0,
//                             GetSystemMetrics(SM_CXSMICON),
//                             GetSystemMetrics(SM_CYSMICON),
                             0);
//                                 IMAGE_ICON, 32, 32, 0);
//                                 IMAGE_ICON, 16, 16, 0);



           nid.hWnd  = hWnd;
           nid.hIcon = hIcon;


//           fResult = 
           Shell_NotifyIcon( NIM_ADD, &nid );


        }
        break;



        case WM_USER+0x42:
        {

           switch ( lParam )
           {
              case WM_LBUTTONDOWN:
              {
                 switch ( wParam )
                 {
                    case IDI_TAPITNAICON:
                    {
                       //
                       // User is left clicking on our icon.
                       //
                       PostMessage(hWnd, WM_COMMAND, IDM_LOCATIONMENU, 0L);
                    }
                    break;


                    default:
                    break;
                 }
              }
              break;



              case WM_LBUTTONDBLCLK:
              {
                 PostMessage(hWnd, WM_COMMAND, IDM_DIALINGPROPERTIES, 0L);
              }
              break;



              case WM_RBUTTONDOWN:
              {
                 switch ( wParam )
                 {
                    case IDI_TAPITNAICON:
                    {
                       //
                       // User is right clicking on our icon.  Now what?
                       //
                       //MessageBox(GetFocus(), "RCLICK", "RCLICK", MB_OK);
                       PostMessage(hWnd, WM_COMMAND, IDM_CONTEXTMENU, 0L);
                    }
                    break;


                    default:
                    break;
                 }
              }
              break;


              default:
              break;

           }
        }
        break;



        case WM_COMMAND:
            switch ( wParam )
            {

                case IDM_ABOUT:
                {
                   LoadString(ghInst, IDS_CAPTION, buf, sizeof(buf));
                   LoadString(ghInst, IDS_ABOUTTEXT, buf2, sizeof(buf2));
                   hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_TAPITNAICON) );
                   return ShellAbout(hWnd, buf, buf2, hIcon);
                }
                break;



                case IDM_CONTEXTMENU:
                {
                    HMENU popup;
                    HMENU subpopup;
                    POINT mousepos;
                    
                    popup = LoadMenu(ghInst,MAKEINTRESOURCE(IDR_RBUTTONMENU));

                    if(popup)
                    {
                       //
                       // So?  Is there more than one config?
                       //
                       if ( !MachineHasMultipleHWProfiles() )
                       {
                          //
                          // Nope, remove the hotdock options.  :-(
                          //
                          RemoveMenu( popup,
                                      IDM_PROPERTIES,
                                      MF_BYCOMMAND
                                    );
                       }


                       subpopup = GetSubMenu(popup, 0);

                       if (subpopup)
                       {
                           SetMenuDefaultItem(subpopup,IDM_DIALINGPROPERTIES,FALSE);

                           if(GetCursorPos(&mousepos))
                           {
                              SetForegroundWindow(ghWnd);
                              ShowWindow(ghWnd, SW_HIDE);
                              TrackPopupMenuEx( subpopup,
                                                TPM_LEFTALIGN |
                                                    TPM_LEFTBUTTON |
                                                    TPM_RIGHTBUTTON,
                                                mousepos.x,
                                                mousepos.y,
                                                ghWnd,
                                                NULL
                                              );
                           }

                           RemoveMenu(popup, 0, MF_BYPOSITION);
                           DestroyMenu(subpopup);
                       }

                       DestroyMenu(popup);
                    }
                        
                }
                break;


                case IDM_LOCATIONMENU:
                {
                    HMENU fakepopup = NULL;
                    POINT mousepos;
                    LPLINETRANSLATECAPS ptc;
                    UINT nPrefixSize;


                    fakepopup = CreatePopupMenu();


                    nPrefixSize = LoadString( ghInst,
                                IDS_SELECTNEWLOCATION,
                                buf,
                                sizeof(buf) );

//                    AppendMenu( fakepopup,
//                                MF_BYPOSITION | MF_STRING | MF_DISABLED, // | MF_GRAYED,
//                                0,
//                                buf
//                              );
//
//                    AppendMenu( fakepopup,
//                                MF_BYPOSITION | MF_STRING | MF_SEPARATOR,
//                                0,
//                                0
//                              );



                    if (GetTranslateCaps(&ptc))
                    {
                        LPLINELOCATIONENTRY ple;
                        DWORD dwCurLocID = ptc->dwCurrentLocationID;
                        DWORD dwNumLocations = ptc->dwNumLocations;

DBGOUT((0, TEXT("There seem to be %ld locations - ptc=0x%08lx"), dwNumLocations,
                                      ptc));

                        //
                        // Allocate an array of DWORDs.  This will allow us
                        // to map the menuID to the TAPI perm provider ID.
                        //
                        lpdwLocationIDs = GlobalAllocPtr( GMEM_FIXED, sizeof(DWORD)*dwNumLocations );


                        //
                        // Put each location in the menu.  When we hit the
                        // "current" location, put a check next to it.
                        //

                        ple = (LPLINELOCATIONENTRY)((LPBYTE)ptc + ptc->dwLocationListOffset);

                        for (i = 0; i < dwNumLocations; i++, ple++)
                        {

                            lpdwLocationIDs[i] = ple->dwPermanentLocationID;

                            //
                            // Now make a proper displayable string
                            lstrcpy( &buf[nPrefixSize],
                                     (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset)
                                   );

                            AppendMenu( fakepopup,
                                        MF_BYPOSITION |
                                           MF_STRING |
                                           MF_ENABLED |
                                           ((dwCurLocID == ple->dwPermanentLocationID) ?
                                              MF_CHECKED : 0),
                                        IDM_LOCATION0+i,
                                        buf
                                      );

DBGOUT((0, TEXT("Location #%ld is [%s] at 0x%08lx"),
              i, 
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset),
              (LPTSTR)((LPBYTE)ptc + ple->dwLocationNameOffset) ));

                            if (dwCurLocID == ple->dwPermanentLocationID)
                            {
                               dwCurrentChoice = IDM_LOCATION0+i;
                            }
                        }


                        GlobalFreePtr(ptc);
                    }
else
{
   DBGOUT((0, TEXT("Gettranscaps failed")));
}


                    if (fakepopup)
                    {
//                       SetMenuDefaultItem(fakepopup,0,MF_BYPOSITION);
                       GetCursorPos(&mousepos);
                       SetForegroundWindow(ghWnd);
    ShowWindow(ghWnd, SW_HIDE);
                       TrackPopupMenu(fakepopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON , mousepos.x, mousepos.y-20, 0, ghWnd, NULL);

                       DestroyMenu(fakepopup);
                    }



//                    {
//                       subpopup = GetSubMenu(fakepopup, 0);
//
//           //put a check next to the current location
//
//                       SetMenuDefaultItem(subpopup,0,MF_BYPOSITION);
//                       if(GetCursorPos(&mousepos))
//                       {
//                          SetForegroundWindow(ghWnd);
//                          TrackPopupMenuEx(subpopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON ,mousepos.x,mousepos.y,ghWnd,NULL);
//                       }
//                       RemoveMenu(popup, 0, MF_BYPOSITION);
//                       DestroyMenu(fakepopup);
//                       DestroyMenu(popup);
//                       DestroyMenu(subpopup);
//                    }

                }
                break;



                case IDM_DIALINGPROPERTIES:
                {
                      {

                      lineTranslateDialog(ghLineApp, 0, TAPI_API_VERSION, ghWnd, NULL);
ShowWindow( ghWnd, SW_HIDE );

//                      lineTranslateDialog(ghLineApp, 0, TAPI_API_VERSION, GetFocus(), NULL);

                      }
                }
                break;



                case IDM_PROPERTIES:
                {

#ifdef NASHVILLE_BUILD_FLAG

                   // Should we just hack into the TAPI dialing properties?

#else
                   HPROPSHEETPAGE  rPages[1];
                   PROPSHEETPAGE   psp;
                   PROPSHEETHEADER psh;


                   //
                   // Let's configure TAPITNA
                   //
                   psh.dwSize      = sizeof(psh);
                   psh.dwFlags     = PSH_DEFAULT;  //PSH_NOAPPLYNOW;
                   psh.hwndParent  = GetFocus(); //NULL; //hwnd;
                   psh.hInstance   = ghInst;
                   LoadString(ghInst, IDS_CAPTION, buf, sizeof(buf)/sizeof(TCHAR));
                   psh.pszCaption  = buf;
                   psh.nPages      = 0;
                   psh.nStartPage  = 0;
                   psh.phpage      = rPages;

                   psp.dwSize      = sizeof(psp);
                   psp.dwFlags     = PSP_DEFAULT;
                   psp.hInstance   = ghInst;
                   psp.pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
                   psp.pfnDlgProc  = GeneralDlgProc;

                   psp.lParam      = 0;

                   psh.phpage[psh.nPages] = CreatePropertySheetPage (&psp);

                   if (psh.phpage[psh.nPages])
                   {                  
                      psh.nPages++;
                   }

                   PropertySheet (&psh);
#endif

                }
                break;


//                case IDM_OTHERMENUITEM:
//                {
//                }
//                break;


                case IDM_LAUNCHDIALER:
                {
                   ShellExecute( ghWnd,
                                 NULL,
                                 TEXT("Dialer.exe"),
                                 NULL,
                                 NULL,
                                 SW_SHOWDEFAULT);
                }
                break;


                case IDM_CLOSEIT:
                {
                   DestroyWindow(ghWnd);
                }
                break;


                default:
                {
                   //
                   // Ok, we actually have to do work in this default.
                   // If the user has the location menu open and selects one,
                   // we deal with it here (instead of having 100 case
                   // statements).  This is the limitation: 100 locations is
                   // the max we put up with (would that many even display?).
                   //
                   if ( 
                         (wParam >= IDM_LOCATION0)
                       &&
                         (wParam <= IDM_LOCATION0 + 100)
                      )
                   {

                      //
                      // Ok, set this to be the new current location
                      //
// there's a bug in TAPI - either the docs or the code, but the following
// _should_ work but doesn't...
//                      lineSetCurrentLocation(NULL, currentlocation);


                      //
                      // If the user is selecting the same location,
                      // do nothing.
                      //
                      if ( dwCurrentChoice == wParam )
                      {
                      }
                      else
                      {
                         i = lineSetCurrentLocation( ghLineApp,
                                                     lpdwLocationIDs[wParam-IDM_LOCATION0] );
                          
                         if ( 0 == i )
                            SaveNewLocation( lpdwLocationIDs[wParam-IDM_LOCATION0] );
                      }

                      GlobalFreePtr( lpdwLocationIDs );
                      
                      return( TRUE );
                      
                   }
                   else
                   {
                      return (DefWindowProc(hWnd, message, wParam, lParam));
                   }

                }
                break;

            }
            break;


        case WM_DESTROY:
            Shell_NotifyIcon( NIM_DELETE, &nid );
            PostQuitMessage(0);
            break;

#if WINNT
#else
        case WM_ENDSESSION:
            if (wParam) {
                RegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE);
                DestroyWindow(hWnd);
            }
#endif


        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return (FALSE);
}


//{
//char buf[100];
//wsprintf(buf, "GetActiveWindwow() = 0x%08lx", (DWORD) GetActiveWindow());
//OutputDebugString(buf);
//}
//{
//char buf[60];
//wsprintf (buf, "fResult = 0x%08lx",
//                fResult);
//MessageBox(GetFocus(), buf, "", MB_OK);
//}






#if DBG


#include "stdarg.h"
#include "stdio.h"


VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PTCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = 0;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        TCHAR    buf[256] = TEXT("TLOCMGR: ");
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[8],
                  lpszFormat,
                  ap
                  );

        lstrcat(buf, TEXT("\n"));

        OutputDebugString(buf);

        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapitna\general.c ===
#include <windows.h>
#include <windowsx.h>

#if WINNT
#else
#include <help.h>
#endif

#include "tchar.h"
#include "prsht.h"

//#define TAPI_API_VERSION  0x00020000
#define TAPI_API_VERSION  0x00010004
#define TAPI_CURRENT_VERSION 0x00010004

#include "tapi.h"

#undef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#include "tspi.h"
#undef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00010004

#include "clientr.h"
#include "client.h"
#include "privateold.h"

#include "general.h"



#if DBG
#define InternalDebugOut(_x_) DbgPrt _x_
garbage;
#else
#define InternalDebugOut(_x_)
#endif


//***************************************************************************

TCHAR gszCurrentProfileKey[] = "System\\CurrentControlSet\\Control\\Telephony";
TCHAR gszStaticProfileKey[]  = "Config\\%04d\\System\\CurrentControlSet\\Control\\Telephony";
TCHAR gszAutoLaunchKey[]     = "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";
TCHAR gszAutoLaunchValue[]   = "AutoLaunchFlags";
TCHAR gszAutoLocationID[]    = "AutoLocationID";


UINT  gnNumConfigProfiles = 0;
DWORD gdwConfigProfiles[MAX_CONFIGPROFILES];



//***************************************************************************
//***************************************************************************
//***************************************************************************
//Purpose: Gets the appropriately sized translate caps structure
//         from TAPI.  Return TRUE if successful


#define LOCATION_GROW   4


BOOL GetTranslateCaps(
    LPLINETRANSLATECAPS FAR * pptc)
{
    LONG lineErr;
    LPLINETRANSLATECAPS ptc;
    DWORD cbSize;

    cbSize = sizeof(*ptc) * LOCATION_GROW + 200;
    ptc = (LPLINETRANSLATECAPS)GlobalAllocPtr(GPTR, cbSize);
    if (ptc)
        {
        // Get the translate devcaps
        ptc->dwTotalSize = cbSize;
        lineErr = lineGetTranslateCaps (0, TAPI_API_VERSION, ptc);
        if (LINEERR_STRUCTURETOOSMALL == lineErr ||
            ptc->dwNeededSize > ptc->dwTotalSize)
            {
            // Provided structure was too small, resize and try again
            cbSize = ptc->dwNeededSize;
            GlobalFreePtr(ptc);
            ptc = (LPLINETRANSLATECAPS)GlobalAllocPtr(GPTR, cbSize);
            if (ptc)
                {
                ptc->dwTotalSize = cbSize;
                lineErr = lineGetTranslateCaps (0, TAPI_API_VERSION, ptc);
                if (0 != lineErr)
                    {
                    // Failure
                    GlobalFreePtr(ptc);
                    ptc = NULL;
                    }
                }
            }
        else if (0 != lineErr)
            {
            // Failure
            GlobalFreePtr(ptc);
            ptc = NULL;
            }
        }

    *pptc = ptc;

    return NULL != *pptc;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
//
// WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  
// Returns 1 if a problem, 0 if no problem
// Code below assumes that this function ONLY returns 0 or 1 (but I think
// it would be confusing to have the rettype be BOOL, since we want a
// return of '1' on a problem...)
//
LONG FillConfigProfileBox( HWND hWnd,
                           DWORD dwControl,
                           LPLINETRANSLATECAPS ptc)
{
   UINT n;
   DWORD nProfileNumberZ;
   WPARAM wIndex;
   LINELOCATIONENTRY *ple;
   HKEY hKey;
   TCHAR szValueName[40];
   TCHAR buf[256];
   DWORD dwType;
   DWORD dwDataSize;
   LPSTR lpstrProfileLocation = NULL;
   LONG  lResult;


   //
   // Get the zero-based Config Profile Number
   //
   nProfileNumberZ = dwControl - IDCB_DL_PROFILE1;


   //
   // Get the profile's name.  If this fails, we assume we've run out
   // of configs
   //
   RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   "System\\CurrentControlSet\\Control\\IDConfigDB",
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );

   wsprintf( szValueName, "FriendlyName%04d", nProfileNumberZ + 1);

   dwDataSize = sizeof(buf);

   lResult = RegQueryValueEx(
                              hKey,
                              szValueName,
                              0,
                              &dwType,
                              buf,
                              &dwDataSize
                            );

   RegCloseKey( hKey );


   //
   // Did we find a name for it?
   //
   if ( ERROR_SUCCESS != lResult )
   {
      return (1);
   }

   //
   // Put whatever we found into the field
   //
   SendMessage( GetDlgItem( hWnd, IDCS_DL_PROFILE1 + nProfileNumberZ ),
                WM_SETTEXT,
                0,
                (LPARAM)&buf
              );


   //
   // Read what location ID is currently specified for this profile
   //
   wsprintf( buf, gszStaticProfileKey, nProfileNumberZ + 1);

   RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   buf,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                 );

   dwDataSize = sizeof(DWORD);

   lResult = RegQueryValueEx(
                           hKey,
                           gszAutoLocationID,
                           0,
                           &dwType,
                           (LPBYTE)&gdwConfigProfiles[ nProfileNumberZ ],
                           &dwDataSize
                         );

   RegCloseKey( hKey );


   //
   // If there's no value (maybe it's the first run), use current location
   //
   if (lResult != ERROR_SUCCESS)
   {
      gdwConfigProfiles[nProfileNumberZ] = ptc->dwCurrentLocationID;
   }


   for (n=0; n<ptc->dwNumLocations; n++)
   {
      ple = (LINELOCATIONENTRY*) ((LPSTR)ptc + ptc->dwLocationListOffset);

      wIndex = SendMessage( GetDlgItem(hWnd, dwControl),
                   CB_ADDSTRING,
                   0,
                   (LPARAM)((LPSTR)ptc + ple[n].dwLocationNameOffset));

      SendMessage( GetDlgItem( hWnd, dwControl),
                   CB_SETITEMDATA,
                   wIndex,
                   ple[n].dwPermanentLocationID
                 );


//{
////   UINT temp;
//
//   wsprintf( buf, "prof=%d loop=%d   s=%s  dw=%ld seek=%ld",
//                   nProfileNumberZ,
//                   n,
//                   (LPARAM)((LPSTR)ptc + ple[n].dwLocationNameOffset),
//                   (DWORD)ple[n].dwPermanentLocationID,
//                   (DWORD)gdwConfigProfiles[nProfileNumberZ]);
//
//   MessageBox(GetFocus(), buf, "", MB_OK);
//}


      //
      // If this location is the one this profile wants, select it
      //
      if ( gdwConfigProfiles[nProfileNumberZ] == ple[n].dwPermanentLocationID )
      {
//MessageBox(GetFocus(), "Found profile locationID", "", MB_OK);

         lpstrProfileLocation = (LPSTR)((LPSTR)ptc + ple[n].dwLocationNameOffset);
      }

   }


//{
////   UINT temp;
//
//   wsprintf( buf, "profile=%ld loop=%ld   s=%s",
//                   (DWORD)nProfileNumberZ,
//                   (DWORD)n,
//                   (LPARAM)((LPSTR)ptc + ple[n].dwLocationNameOffset));
//   MessageBox(GetFocus(), buf, "", MB_OK);
//}


   SendMessage( GetDlgItem( hWnd, dwControl),
                CB_SELECTSTRING,
                (WPARAM)-1,
                (LPARAM)lpstrProfileLocation
              );


   return ERROR_SUCCESS;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR
CALLBACK
GeneralDlgProc(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static DWORD aIds[] = {
        0, 0
    };

    UINT n;
    LONG lResult;
    HKEY hKey;
    static DWORD dwType;
    static DWORD dwDataSize;

    static DWORD dwTapiTNAFlags = 0;
// these values are in GENERAL.H
//       #define FLAG_AUTOLAUNCH            0x00000001
//       #define FLAG_AUTOLOCATIONID        0x00000002
//       #define FLAG_PROMPTAUTOLOCATIONID  0x00000004
//       #define FLAG_ANNOUNCEAUTOLOCATIONID   0x00000008

    LPLINETRANSLATECAPS ptc;



    switch (msg)
    {
       case WM_INITDIALOG:
       {

          GetTranslateCaps(&ptc);
          //BUGBUG What if this fails?


//BUGBUG If the number of hardware configs == 1, don't bother showing these
          //
          // Fill up the Hardware config boxes
          //

          if ( ptc )
          {
             lResult = ERROR_SUCCESS;

             for (
                   n=0;
                   (n<MAX_CONFIGPROFILES) && (ERROR_SUCCESS == lResult);
                   n++
                 )
             {
                lResult = FillConfigProfileBox( hWnd,
                                                IDCB_DL_PROFILE1 + n,
                                                ptc );
             }

             gnNumConfigProfiles = n - lResult;

             GlobalFreePtr( ptc );
          }


          //
          // Now go disable all the stuff not being used
          // 
          for ( n=gnNumConfigProfiles; n<MAX_CONFIGPROFILES; n++)
          {
             ShowWindow( GetDlgItem( hWnd, IDCB_DL_PROFILE1 + n),
                         SW_HIDE
                       );
             ShowWindow( GetDlgItem( hWnd, IDCS_DL_PROFILE1 + n),
                         SW_HIDE
                       );
          }


          //
          // Get the TapiTNA flags
          //

          lResult = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszAutoLaunchKey,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey
                    );


          dwDataSize = sizeof(dwTapiTNAFlags);

          lResult = RegQueryValueEx(
                                     hKey,
                                     gszAutoLaunchValue,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwTapiTNAFlags,
                                     &dwDataSize
                                   );

          RegCloseKey( hKey );


          //
          // Now check the boxes as appropriate
          //

          if ( dwTapiTNAFlags & FLAG_AUTOLAUNCH )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_LAUNCHTAPITNA,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_AUTOLOCATIONID )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_AUTOLOCATIONID,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_UPDATEONSTARTUP )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_UPDATEONSTARTUP,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_PROMPTAUTOLOCATIONID )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_PROMPTAUTOLOCATIONID,
                             TRUE
                           );
          }

          if ( dwTapiTNAFlags & FLAG_ANNOUNCEAUTOLOCATIONID )
          {
             CheckDlgButton( hWnd,
                             IDCK_DL_ANNOUNCEAUTOLOCATIONID,
                             TRUE
                           );
          }


          //
          // Disable the two checkboxes dependent on this one,
          // but keep the settings
          //
          if ( dwTapiTNAFlags & FLAG_AUTOLOCATIONID )
          {
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                           TRUE
                         );
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                           TRUE
                         );
          }
          else
          {
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                           FALSE
                         );
             EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                           FALSE
                         );
          }


       }
       break;


       // Process clicks on controls after Context Help mode selected
       case WM_HELP:
           InternalDebugOut((50, "  WM_HELP in LocDefineDlg"));
           WinHelp (((LPHELPINFO) lParam)->hItemHandle, "windows.hlp", HELP_WM_HELP, 
                                           (ULONG_PTR)(LPSTR) aIds);
           break;


       // Process right-clicks on controls            
       case WM_CONTEXTMENU:
           InternalDebugOut((50, "  WM_CONTEXT_MENU in LocationsDlgProc"));
           WinHelp ((HWND) wParam, "windows.hlp", HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID) aIds);
           break;


       case WM_NOTIFY:
       {
          LPNMHDR lpnm = (LPNMHDR)lParam;

          switch ( lpnm->code )
          {

             case PSN_APPLY: /* case IDOK */
             {
                DWORD dwDisposition;   // Don't really care about this...


                InternalDebugOut((0, "  PSN_APPLY - General"));

                if ( ((LPPSHNOTIFY)lpnm)->lParam )
                   InternalDebugOut((0, "     (actually, it was the OK button)"));


                //
                // Write out the new flags
                //

                lResult = RegCreateKeyEx(
                                          HKEY_LOCAL_MACHINE,
                                          gszAutoLaunchKey,
                                          0,
                                          "", //Class?  Who cares?
                                          REG_OPTION_NON_VOLATILE,
                                          KEY_ALL_ACCESS,
                                          NULL,
                                          &hKey,
                                          &dwDisposition
                                        );


                if (ERROR_SUCCESS == lResult)
                {
                    lResult = RegSetValueEx(
                                              hKey,
                                              gszAutoLaunchValue,
                                              0,
                                              dwType,
                                              (LPBYTE)&dwTapiTNAFlags,
                                              dwDataSize
                                            );

                    RegCloseKey( hKey );
                }




                for ( n=0;  n < gnNumConfigProfiles; n++)
                {
                   DWORD dwTemp;
                   TCHAR szKeyName[128];


                   wsprintf ( szKeyName, gszStaticProfileKey, n+1);

                   RegCreateKeyEx(
                                   HKEY_LOCAL_MACHINE,
                                   szKeyName,
                                   0,
                                   "",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hKey,
                                   &dwTemp
                                 );

                   RegSetValueEx(
                                    hKey,
                                    gszAutoLocationID,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)&gdwConfigProfiles[n],
                                    sizeof(DWORD)
                               );

                   RegCloseKey( hKey );

                }

                break;
             }


             case  PSN_RESET:        /* case IDCANCEL: */
                InternalDebugOut((0, "  PSN_RESET - General"));
                break;


#if DBG     
             case PSN_SETACTIVE:
                InternalDebugOut((0, "  PSN_SETACTIVE - General"));
                break;


             case PSN_KILLACTIVE:
                InternalDebugOut((0, "  PSN_KILLACTIVE - General"));
                break;

#endif

          }
       }
       break;


       case WM_COMMAND:
       {
          switch (LOWORD(wParam))
          {

             case IDCB_DL_PROFILE1:
             case IDCB_DL_PROFILE2:
             case IDCB_DL_PROFILE3:
             case IDCB_DL_PROFILE4:
             {

                //
                // Only process if something is changing
                //
                switch  HIWORD(wParam)
                {
                   case  CBN_SELCHANGE:
                   {
                      LRESULT m;


                      gdwConfigProfiles[LOWORD(wParam) - IDCB_DL_PROFILE1] =
                            n = (UINT) SendMessage( GetDlgItem( hWnd, LOWORD(wParam)),
                                         CB_GETITEMDATA,
                                       ( m= SendMessage(
                                                      GetDlgItem( hWnd,
                                                                  LOWORD(wParam)),
                                                      CB_GETCURSEL,
                                                      0,
                                                      0
                                                    ) ) ,
                                         0
                                       );

//{
//   TCHAR Buffer[256];
//   wsprintf( Buffer, "wParam=0x%08lx lParam=0x%08lx data=0x%08lx m=0x%08lx",
//                     (DWORD)wParam,
//                     (DWORD)lParam,
//                     (DWORD)n,
//                     (DWORD)m
//           );
//   MessageBox(GetFocus(), Buffer, "", MB_OK);
//}

                      //
                      // Activate the APPLY button if not already done
                      //
                      PropSheet_Changed(GetParent(hWnd), hWnd);
                   }
                }
             }
             break;


             case IDCK_DL_LAUNCHTAPITNA:
             {
                dwTapiTNAFlags ^= FLAG_AUTOLAUNCH;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_AUTOLOCATIONID:
             {
                dwTapiTNAFlags ^= FLAG_AUTOLOCATIONID;

                //
                // Disable the two checkboxes dependent on this one,
                // but keep the settings
                //
                if ( dwTapiTNAFlags & FLAG_AUTOLOCATIONID )
                {
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                                 TRUE
                               );
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                                 TRUE
                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_PROMPTAUTOLOCATIONID),
//                                 TRUE
//                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_ANNOUNCEAUTOLOCATIONID),
//                                 TRUE
//                               );
                }
                else
                {
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_PROMPTAUTOLOCATIONID),
                                 FALSE
                               );
                   EnableWindow( GetDlgItem(hWnd, IDCK_DL_ANNOUNCEAUTOLOCATIONID),
                                 FALSE
                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_PROMPTAUTOLOCATIONID),
//                                 FALSE
//                               );
//                   EnableWindow( GetDlgItem(hWnd, IDCS_DL_ANNOUNCEAUTOLOCATIONID),
//                                 FALSE
//                               );
                }


                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_PROMPTAUTOLOCATIONID:
             {
                dwTapiTNAFlags ^= FLAG_PROMPTAUTOLOCATIONID;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_UPDATEONSTARTUP:
             {
                dwTapiTNAFlags ^= FLAG_UPDATEONSTARTUP;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             case IDCK_DL_ANNOUNCEAUTOLOCATIONID:
             {
                dwTapiTNAFlags ^= FLAG_ANNOUNCEAUTOLOCATIONID;

                //
                // Activate the APPLY button if not already done
                //
                PropSheet_Changed(GetParent(hWnd), hWnd);
             }
             break;


             default:
             {
             }
             break;

          }
       }
       break;


       default:
       break;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapiupr\location.h ===
#include "loc_comn.h"

extern PLOCATION gLocationList;
extern PLOCATION gpCurrentLocation;
extern UINT gnNumLocations;
extern UINT gnCurrentLocationID;

//***************************************************************************
//***************************************************************************
//***************************************************************************

LONG PASCAL GetLocationIndexFromID( UINT nID, PLOCATION pCallersList, UINT nCallersNumLocations );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapiupr\loc_comn.h ===
#ifdef PARTIAL_UNICODE

#define  __TTEXT(quote) quote
#define  TAPISendDlgItemMessage  SendDlgItemMessage
#define  TAPIRegQueryValueExW    TAPIRegQueryValueExW
#define  TAPIRegSetValueExW      TAPIRegSetValueExW
#define  TAPILoadStringW         TAPILoadStringW
#define  TAPICHAR                char

#define TAPIRegDeleteValueW RegDeleteValueA

LONG TAPIRegQueryValueExW(
                           HKEY hKey,
                           const CHAR *SectionName,
                           LPDWORD lpdwReserved,
                           LPDWORD lpType,
                           LPBYTE  lpData,
                           LPDWORD lpcbData
                          );

LONG TAPIRegSetValueExW(
                         HKEY    hKey,
                         const CHAR    *SectionName,
                         DWORD   dwReserved,
                         DWORD   dwType,
                         LPBYTE  lpData,
                         DWORD   cbData
                        );

LONG TAPIRegEnumValueW(
                       HKEY         hKey,
                       DWORD        dwIndex,
                       TAPICHAR     *lpName,
                       LPDWORD      lpcbName,
                       LPDWORD      lpdwReserved,
                       LPDWORD      lpwdType,
                       LPBYTE       lpData,
                       LPDWORD      lpcbData
                      );

int TAPILoadStringW(
                HINSTANCE hInst,
                UINT      uID,
                PWSTR     pBuffer,
                int       nBufferMax
               );

HINSTANCE TAPILoadLibraryW(
                PWSTR     pszLibraryW
               );

BOOL WINAPI TAPIIsBadStringPtrW( LPCWSTR lpsz, UINT cchMax );


#else
#define  __TTEXT(quote) L##quote
#define  TAPISendDlgItemMessage  SendDlgItemMessageW
#define  TAPIRegDeleteValueW     RegDeleteValueW
#define  TAPIRegQueryValueExW    RegQueryValueExW
#define  TAPIRegSetValueExW      RegSetValueExW
#define  TAPIRegEnumValueW       RegEnumValueW
#define  TAPILoadStringW         LoadStringW
#define  TAPILoadLibraryW        LoadLibraryW
#define  TAPIIsBadStringPtrW     IsBadStringPtrW
#define  TAPICHAR                WCHAR
#endif

#define TAPITEXT(quote) __TTEXT(quote)

//***************************************************************************
typedef struct {

        DWORD dwID;

#define MAXLEN_NAME                96
        WCHAR NameW[MAXLEN_NAME];

#define MAXLEN_AREACODE            16
        WCHAR AreaCodeW[MAXLEN_AREACODE];

        DWORD dwCountryID;
//PERFORMANCE KEEP CountryCode here - reduce # calls to readcountries

#define MAXLEN_OUTSIDEACCESS       16
        WCHAR OutsideAccessW[MAXLEN_OUTSIDEACCESS];
// There is one instance where code assumes outside & ld are same size
// (the code that reads in the text from the control)

#define MAXLEN_LONGDISTANCEACCESS  16
        WCHAR LongDistanceAccessW[MAXLEN_LONGDISTANCEACCESS];

        DWORD dwFlags;
             #define LOCATION_USETONEDIALING        0x00000001
             #define LOCATION_USECALLINGCARD        0x00000002
             #define LOCATION_HASCALLWAITING        0x00000004
             #define LOCATION_ALWAYSINCLUDEAREACODE 0x00000008

        DWORD dwCallingCard;

#define MAXLEN_DISABLECALLWAITING  16
        WCHAR DisableCallWaitingW[MAXLEN_DISABLECALLWAITING];

//
// When dialing some area codes adjacent to the current area code, the
// LD prefix does not need to (or can not) be added
#define MAXLEN_NOPREFIXAREACODES (400)
        DWORD NoPrefixAreaCodesCount;
        DWORD NoPrefixAreaCodes[ MAXLEN_NOPREFIXAREACODES ];

        DWORD NoPrefixAreaCodesExceptions[ MAXLEN_NOPREFIXAREACODES ];

//
// Allow all prefixes to be toll. (Yes, even 911.)  String is "xxx,"
#define MAXLEN_TOLLLIST     (1000*4 + 1)
        WCHAR TollListW[MAXLEN_TOLLLIST];

       } LOCATION, *PLOCATION;

//***************************************************************************
//***************************************************************************
//***************************************************************************
#define CHANGEDFLAGS_CURLOCATIONCHANGED      0x00000001
#define CHANGEDFLAGS_REALCHANGE              0x00000002
#define CHANGEDFLAGS_TOLLLIST                0x00000004


//***************************************************************************
//***************************************************************************
//***************************************************************************
//
// These bits decide which params TAPISRV will check on READLOCATION and
// WRITELOCATION operations
//
#define CHECKPARMS_DWHLINEAPP         1
#define CHECKPARMS_DWDEVICEID         2
#define CHECKPARMS_DWAPIVERSION       4

//***************************************************************************
//***************************************************************************
//***************************************************************************
#define DWTOTALSIZE  0
#define DWNEEDEDSIZE 1
#define DWUSEDSIZE   2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\resource.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    resource.h

NOTE from Testing: 
  If these values are changed, it will very likely break test automation. Please advise the test
  team if these values are altered. (peterje)

Abstract:

    Resource header file for the TAPI Browser util

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TB.RC
//
#define IDR_MENU1                       101
#define IDD_DIALOG1                     102
#define IDD_DIALOG2                     103
#define IDD_DIALOG3                     104
#define IDD_DIALOG4                     105
#define IDD_DIALOG5                     106
#define IDD_DIALOG6                     107
#define IDI_ICON1                       108
#define IDR_ACCELERATOR1                109
#define IDC_LIST1                       1000
#define IDC_LIST2                       1001
#define IDC_COMBO1                      1002
#define IDC_EDIT1                       1003
#define IDC_CLEAR                       1004
#define IDC_STATIC1                     1005
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010
#define IDC_BUTTON6                     1011
#define IDC_BUTTON7                     1012
#define IDC_BUTTON8                     1013
#define IDC_BUTTON9                     1014
#define IDC_BUTTON10                    1015
#define IDC_BUTTON11                    1016
#define IDC_BUTTON12                    1017
#define IDC_BUTTON13                    1018
#define IDC_BUTTON14                    1019
#define IDC_BUTTON15                    1020
#define IDC_BUTTON16                    1021
#define IDC_BUTTON17                    1022
#define IDC_BUTTON18                    1023
#define IDC_TB_HELP                     1024
#define IDC_F1HELP                      1025
#define IDC_PREVCTRL                    1026
#define IDC_NEXTCTRL                    1027
#define IDC_ENTER                       1028
#define IDM_DEFAULTVALUES               40001
#define IDM_ABOUT                       40002
#define IDM_USINGTB                     40003
#define IDM_DUMPPARAMS                  40004
#define IDM_LOGSTRUCTDWORD              40005
#define IDM_LOGSTRUCTALLFIELD           40006
#define IDM_LOGSTRUCTNONZEROFIELD       40007
#define IDM_LOGSTRUCTNONE               40008
#define IDM_USERBUTTONS                 40009
#define IDM_LOGFILE                     40010
#define IDM_CLEAR                       40011
#define IDM_PARAMS                      40012
#define IDM_EXIT                        40013
#define IDM_TAPIHLP                     40014
#define IDM_TSPIHLP                     40015
#define IDM_NUKEIDLEMONITORCALLS        40016
#define IDM_NUKEIDLEOWNEDCALLS          40017
#define IDM_TIMESTAMP                   40018
#define IDM_NOHANDLECHK                 40019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\tb.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    tb.c

Abstract:

    API wrapper code for the TAPI Browser util.  Contains the big switch
    statement for all the supported Telephony API's, & various support funcs.

Author:

    Dan Knudson (DanKn)    23-Aug-1994

Revision History:

--*/


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include "tb.h"
#include "vars.h"
#include "resource.h"


char szdwDeviceID[]   = "dwDeviceID";
char szdwSize[]       = "dwSize";
char szhCall[]        = "hCall";
char szhLine[]        = "hLine";
char szhLineApp[]     = "hLineApp";
char szhPhone[]       = "hPhone";
char szlpCallParams[] = "lpCallParams";

char szlphCall[]         = "lphCall";
char szlpParams[]        = "lpParams";
char szhwndOwner[]       = "hwndOwner";
char szdwAddressID[]     = "dwAddressID";
char szlpszAppName[]     = "lpszAppName";
char szdwAPIVersion[]    = "APIVersion";
char szlphConsultCall[]  = "lphConsultCall";
char szlpszDeviceClass[] = "lpszDeviceClass";
char szlpszDestAddress[] = "lpszDestAddress";
char szlpsUserUserInfo[] = "lpsUserUserInfo";
char szlpszFriendlyAppName[] = "lpszFriendlyAppName";


DWORD NullWidget[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


void
FuncDriver2(
    FUNC_INDEX funcIndex
    );


void
ErrorAlert(
    void
    )
{
    //
    // We used to do MessageBeep(-1) when user hit an error, but
    // in NT bug #160090 MessageBeep will hang on HP Vectra boxes.
    // So the MessageBeep's were replaced with this func, which
    // simply flashes the window text.
    //

    SetWindowText (ghwndMain, "        Error!");
    Sleep (250);
    SetWindowText (ghwndMain, "Tapi Browser");
}


LPWSTR
PASCAL
My_lstrcpyW(
    WCHAR   *pString1,
    WCHAR   *pString2
    )
{
    //
    // lstrcpyW isn't supported on win95 (at least up to osr2)
    // so we'll use our own func
    //

    WCHAR *p = pString1;


    for (; (*p = *pString2); p++, pString2++);
    return pString1;
}


char *
PASCAL
GetTimeStamp(
    void
    )
{
    static char szEmptyString[] = "", szTimeStamp[32];
    SYSTEMTIME  systemTime;


    if (!bTimeStamp)
    {
        return szEmptyString;
    }

    GetLocalTime (&systemTime);

    wsprintf(
        szTimeStamp,
        "%d:%d.%d.%d : ",
        (DWORD) systemTime.wHour,
        (DWORD) systemTime.wMinute,
        (DWORD) systemTime.wSecond,
        (DWORD) systemTime.wMilliseconds
        );

    return szTimeStamp;
}


void
ShowLineFuncResult(
    LPSTR   lpFuncName,
    LONG    lResult
    )
{
    char   *pszTimeStamp = GetTimeStamp();


    if (lResult > 0)
    {
        ShowStr ("%s%s returned x%lx", pszTimeStamp, lpFuncName, lResult);
    }
    else if (lResult != 0 &&
             ((DWORD) lResult < LINEERR_ALLOCATED ||
             (DWORD) lResult > LAST_LINEERR))
    {
        ErrorAlert();

        ShowStr(
            "%s%s returned inval err code (x%lx)",
            pszTimeStamp,
            lpFuncName,
            lResult
            );
    }
    else
    {
        if (lResult < 0)
        {
            ErrorAlert();
        }

        ShowStr(
            "%s%s returned %s%s",
            pszTimeStamp,
            lpFuncName,
            (lResult ? "LINEERR_" : ""), // ...to shrink aszLineErrs array
            aszLineErrs[LOWORD(lResult)]
            );
    }
}


void
ShowPhoneFuncResult(
    LPSTR   lpFuncName,
    LONG    lResult
    )
{
    char *pszTimeStamp = GetTimeStamp();


    if (lResult > 0)
    {
        ShowStr ("%s%s returned x%lx", pszTimeStamp, lpFuncName, lResult);
    }
    else if (lResult != 0 &&
             ((DWORD) lResult < PHONEERR_ALLOCATED ||
             (DWORD) lResult > PHONEERR_REINIT))
    {
        ErrorAlert();

        ShowStr(
            "%s%s returned inval err code (x%lx)",
            pszTimeStamp,
            lpFuncName,
            lResult
            );
    }
    else
    {
        if (lResult < 0)
        {
            ErrorAlert();
        }

        ShowStr(
            "%s%s returned %s%s",
            pszTimeStamp,
            lpFuncName,
            (lResult ? "PHONEERR_" : ""), // ...to shrink aszPhoneErrs array
            aszPhoneErrs[LOWORD(lResult)]
            );
    }
}


void
ShowTapiFuncResult(
    LPSTR   lpFuncName,
    LONG    lResult
    )
{
    char *pszTimeStamp = GetTimeStamp();


    if ((lResult > 0) || (lResult < TAPIERR_INVALPOINTER))
    {
        ShowStr(
            "%s%s returned inval err code (x%lx)",
            pszTimeStamp,
            lpFuncName,
            lResult
            );
    }
    else
    {
        lResult = (~lResult) + 1;

        if (lResult > 0)
        {
            ErrorAlert();
        }

        ShowStr(
            "%s%s returned %s%s",
            pszTimeStamp,
            lpFuncName,
            (lResult ? "TAPIERR_" : ""), // ...to shrink aszTapiErrs array
            aszTapiErrs[lResult]
            );
    }
}


void
UpdateResults(
    BOOL bBegin
    )
{
    //
    // In order to maximize speed, minimize flash, & have the
    // latest info in the edit control scrolled into view we
    // shrink the window down and hide it. Later, when all the
    // text has been inserted in the edit control, we show
    // the window (since window must be visible in order to
    // scroll caret into view), then tell it to scroll the caret
    // (at this point the window is still 1x1 so the painting
    // overhead is 0), and finally restore the control to it's
    // full size. In doing so we have zero flash and only 1 real
    // complete paint. Also put up the hourglass for warm fuzzies.
    //

    static RECT    rect;
    static HCURSOR hCurSave;
    static int     iNumBegins = 0;


    if (bBegin)
    {
        iNumBegins++;

        if (iNumBegins > 1)
        {
            return;
        }

        hCurSave = SetCursor (LoadCursor ((HINSTANCE)NULL, IDC_WAIT));
        GetWindowRect (ghwndEdit, &rect);
        SetWindowPos(
            ghwndEdit,
            (HWND) NULL,
            0,
            0,
            1,
            1,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW |
                SWP_NOZORDER | SWP_HIDEWINDOW
            );
    }
    else
    {
        iNumBegins--;

        if (iNumBegins > 0)
        {
            return;
        }

        //
        // Do control restoration as described above
        //

        ShowWindow (ghwndEdit, SW_SHOW);
#ifdef WIN32
        SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
#else
        SendMessage(
            ghwndEdit,
            EM_SETSEL,
            (WPARAM)0,
            (LPARAM) MAKELONG(0xfffd,0xfffe)
            );
#endif
        SetWindowPos(
            ghwndEdit,
            (HWND) NULL,
            0,
            0,
            rect.right - rect.left,
            rect.bottom - rect.top,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
            );
        SetCursor (hCurSave);
    }
}


void
ShowModBytes(
    DWORD               dwSize,
    unsigned char far  *lpc,
    char               *pszTab,
    char               *buf
    )
{
    DWORD   dwSize2 = dwSize, i, j, k;


    strcpy (buf, pszTab);

    k = strlen (buf);

    for (i = 8; i < 36; i += 9)
    {
        buf[k + i] = ' ';

        for (j = 2; j < 9; j += 2)
        {
            char buf2[8] = "xx";

            if (dwSize2)
            {
                sprintf (buf2, "%02x", (int) (*lpc));
                dwSize2--;
            }

            buf[k + i - j]     = buf2[0];
            buf[k + i - j + 1] = buf2[1];

            lpc++;
        }
    }

    k += 37;

    buf[k - 1] = ' ';

    lpc -= 16;

    for (i = 0; i < dwSize; i++)
    {
        buf[k + i] = aAscii[*(lpc+i)];
    }

    buf[k + i] = 0;

    ShowStr (buf);
}


void
ShowBytes(
    DWORD   dwSize,
    LPVOID  lp,
    DWORD   dwNumTabs
    )
{
    char    tabBuf[17] = "";
    char    buf[80];
    DWORD   i, j, k, dwNumDWORDs, dwMod4 = (DWORD) (((ULONG_PTR) lp) & 3);
    LPDWORD lpdw;
    unsigned char far *lpc = (unsigned char far *) lp;


    UpdateResults (TRUE);


    for (i = 0; i < dwNumTabs; i++)
    {
        strcat (tabBuf, szTab);
    }


    //
    // Special case for unaligned pointers (will fault on ppc/mips)
    //

    if (dwMod4)
    {
        DWORD   dwNumUnalignedBytes = 4 - dwMod4,
                dwNumBytesToShow = (dwNumUnalignedBytes > dwSize ?
                    dwSize : dwNumUnalignedBytes);


        ShowModBytes (dwNumBytesToShow, lpc, tabBuf, buf);
        lpc += dwNumUnalignedBytes;
        lpdw = (LPDWORD) lpc;
        dwSize -= dwNumBytesToShow;
    }
    else
    {
        lpdw = (LPDWORD) lp;
    }


    //
    // Dump full lines of four DWORDs in hex & corresponding ASCII
    //

    if (dwSize >= (4*sizeof(DWORD)))
    {
        dwNumDWORDs = dwSize / 4; // adjust from numBytes to num DWORDs

        for (i = 0; i < (dwNumDWORDs - (dwNumDWORDs%4)); i += 4)
        {
            sprintf (
                buf,
                "%s%08lx %08lx %08lx %08lx  ",
                tabBuf,
                *lpdw,
                *(lpdw+1),
                *(lpdw+2),
                *(lpdw+3)
                );

            k = strlen (buf);

            for (j = 0; j < 16; j++)
            {
                buf[k + j] = aAscii[*(lpc + j)];
            }

            buf[k + j] = 0;

            ShowStr (buf);
            lpdw += 4;
            lpc += 16;
        }
    }


    //
    // Special case for remaining bytes to dump (0 < n < 16)
    //

    if ((dwSize %= 16))
    {
        ShowModBytes (dwSize, lpc, tabBuf, buf);
    }


    UpdateResults (FALSE);
}


void
ShowStructByDWORDs(
    LPVOID  lp
    )
{

    if (dwDumpStructsFlags & DS_BYTEDUMP)
    {
        //
        // Cast lp as DWORD, then add 2 to point to where a
        // dwUsedSize field is in a TAPI struct
        //

        ShowBytes (*(((LPDWORD) lp) + 2), lp, 0);
    }
}


void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    )
{
    static char far *aszCommonFields[] =
    {
        "dwTotalSize",
        "dwNeededSize",
        "dwUsedSize"
    };
    DWORD i, j;
    char far *buf = malloc (256);


    UpdateResults (TRUE);

    ShowStr (pHeader->szName);

    if (!bSubStructure)
    {
        LPDWORD lpdw =  (LPDWORD) pHeader->pStruct;


        for (i = 0; i < 3; i++)
        {
            ShowStr ("%s%s=x%lx", szTab, aszCommonFields[i], *lpdw);
            lpdw++;
        }
    }

    for (i = 0; i < pHeader->dwNumFields; i++)
    {
        if ((pHeader->aFields[i].dwValue == 0) &&
            !(dwDumpStructsFlags & DS_ZEROFIELDS))
        {
            continue;
        }

        sprintf(
            buf,
            "%s%s=x%lx",
            szTab,
            pHeader->aFields[i].szName,
            pHeader->aFields[i].dwValue
            );

        switch (pHeader->aFields[i].dwType)
        {
        case FT_DWORD:

            ShowStr (buf);
            break;

        case FT_FLAGS:
        {
            PLOOKUP pLookup = pHeader->aFields[i].pLookup;


            strcat (buf, ", ");

            for(
                j = 0;
                pHeader->aFields[i].dwValue, pLookup[j].dwVal != 0xffffffff;
                j++
                )
            {
                if (pHeader->aFields[i].dwValue & pLookup[j].dwVal)
                {
                    if (buf[0] == 0)
                    {
                        sprintf (buf, "%s%s", szTab, szTab);
                    }

                    strcat (buf, pLookup[j].lpszVal);
                    strcat (buf, " ");
                    pHeader->aFields[i].dwValue =
                        pHeader->aFields[i].dwValue & ~pLookup[j].dwVal;

                    if (strlen (buf) > 50)
                    {
                        //
                        // We don't want strings getting so long that
                        // they're going offscreen, so break them up.
                        //

                        ShowStr (buf);
                        buf[0] = 0;
                    }
                }
            }

            if (pHeader->aFields[i].dwValue)
            {
                strcat (buf, "<unknown flag(s)>");
            }

            if (buf[0])
            {
                ShowStr (buf);
            }

            break;
        }
        case FT_ORD:
        {
            PLOOKUP pLookup = pHeader->aFields[i].pLookup;


            strcat (buf, ", ");

            for(
                j = 0;
                pLookup[j].dwVal != 0xffffffff;
                j++
                )
            {
                if (pHeader->aFields[i].dwValue == pLookup[j].dwVal)
                {
                    strcat (buf, pLookup[j].lpszVal);
                    break;
                }
            }

            if (pLookup[j].dwVal == 0xffffffff)
            {
                strcpy (buf, "<unknown ordinal>");
            }

            ShowStr (buf);
            break;
        }
        case FT_SIZE:

            ShowStr (buf);
            break;

        case FT_OFFSET:

            ShowStr (buf);

            if (IsBadReadPtr(
                    ((char far *) pHeader->pStruct) +
                        pHeader->aFields[i].dwValue,
                    (UINT)pHeader->aFields[i-1].dwValue
                    ))
            {
                ShowStr ("<size/offset pair yields bad pointer>");
            }
            else
            {
                ShowBytes(
                    pHeader->aFields[i-1].dwValue,
                    ((char far *) pHeader->pStruct) +
                        pHeader->aFields[i].dwValue,
                    2
                    );
            }

            break;
        }
    }

    free (buf);

    UpdateResults (FALSE);
}


void
ShowVARSTRING(
    LPVARSTRING lpVarString
    )
{
    if (dwDumpStructsFlags & DS_NONZEROFIELDS)
    {
        STRUCT_FIELD fields[] =
        {
            { "dwStringFormat", FT_ORD,     lpVarString->dwStringFormat, aStringFormats },
            { "dwStringSize",   FT_SIZE,    lpVarString->dwStringSize, NULL },
            { "dwStringOffset", FT_OFFSET,  lpVarString->dwStringOffset, NULL }

        };
        STRUCT_FIELD_HEADER fieldHeader =
        {
            lpVarString,
            "VARSTRING",
            3,
            fields
        };

        ShowStructByField (&fieldHeader, FALSE);
    }
}


INT_PTR
LetUserMungeParams(
    PFUNC_PARAM_HEADER pParamsHeader
    )
{
    if (!bShowParams)
    {
        return TRUE;
    }

    return (DialogBoxParam(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
        ghwndMain,
        ParamsDlgProc,
        (LPARAM) pParamsHeader
        ));
}


void
DumpParams(
    PFUNC_PARAM_HEADER pHeader
    )
{
    if (bTimeStamp || bDumpParams)
    {
        char   *pszTimeStamp = GetTimeStamp();


        UpdateResults (TRUE);

        ShowStr(
            "%sCalling %s",
            pszTimeStamp,
            aFuncNames[pHeader->FuncIndex]
            );

        if (bDumpParams)
        {
            DWORD   i;


            for (i = 0; i < pHeader->dwNumParams; i++)
            {
                ShowStr(
                    "    %s=x%lx",
                    pHeader->aParams[i].szName,
                    pHeader->aParams[i].dwValue
                    );
            }

        }

        UpdateResults (FALSE);
    }
}


void
PASCAL
MakeWideString(
    LPVOID pString
    )
{
    if (!IsBadStringPtr ((LPCSTR) pString, 0xffffffff))
    {
        int    len = strlen ((char *) pString) + 1;
        WCHAR  buf[MAX_STRING_PARAM_SIZE/2];


        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            (LPCSTR) pString,
            (len > MAX_STRING_PARAM_SIZE/2 ? MAX_STRING_PARAM_SIZE/2 - 1 : -1),
            buf,
            MAX_STRING_PARAM_SIZE/2
            );

        buf[MAX_STRING_PARAM_SIZE/2 - 1] = 0;

        My_lstrcpyW ((WCHAR *) pString, buf);
    }
}


LONG
DoFunc(
    PFUNC_PARAM_HEADER pHeader
    )
{
    LONG    lResult;


    if (!LetUserMungeParams (pHeader))
    {
       return 0xffffffff;
    }

#if TAPI_2_0

    //
    // Convert any unicode string params as appropriate
    //

    if (gbWideStringParams)
    {
        DWORD       dwNumParams = pHeader->dwNumParams, i;
        PFUNC_PARAM pParam = pHeader->aParams;


        for (i = 0; i < dwNumParams; i++)
        {
            if (pParam->dwType == PT_STRING)
            {
                MakeWideString ((LPVOID) pParam->dwValue);
            }

            pParam++;
        }
    }

#endif

    DumpParams (pHeader);

    switch (pHeader->dwNumParams)
    {
    case 1:

        lResult = (*pHeader->u.pfn1)(
            pHeader->aParams[0].dwValue
            );
        break;

    case 2:

        lResult = (*pHeader->u.pfn2)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue
            );
        break;

    case 3:

        lResult = (*pHeader->u.pfn3)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue
            );
        break;

    case 4:

        lResult = (*pHeader->u.pfn4)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue
            );
        break;

    case 5:

        lResult = (*pHeader->u.pfn5)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue
            );
        break;

    case 6:

        lResult = (*pHeader->u.pfn6)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue
            );
        break;

    case 7:

        lResult = (*pHeader->u.pfn7)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue
            );
        break;

    case 8:

        lResult = (*pHeader->u.pfn8)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue
            );
        break;

    case 9:

        lResult = (*pHeader->u.pfn9)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue,
            pHeader->aParams[8].dwValue
            );
        break;

    case 10:

        lResult = (*pHeader->u.pfn10)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue,
            pHeader->aParams[8].dwValue,
            pHeader->aParams[9].dwValue
            );
        break;

    default: // case 12:

        lResult = (*pHeader->u.pfn12)(
            pHeader->aParams[0].dwValue,
            pHeader->aParams[1].dwValue,
            pHeader->aParams[2].dwValue,
            pHeader->aParams[3].dwValue,
            pHeader->aParams[4].dwValue,
            pHeader->aParams[5].dwValue,
            pHeader->aParams[6].dwValue,
            pHeader->aParams[7].dwValue,
            pHeader->aParams[8].dwValue,
            pHeader->aParams[9].dwValue,
            pHeader->aParams[10].dwValue,
            pHeader->aParams[11].dwValue
            );
        break;
    }

    if (pHeader->FuncIndex < pClose)
    {
        ShowLineFuncResult (aFuncNames[pHeader->FuncIndex], lResult);
    }
    else if (pHeader->FuncIndex < tGetLocationInfo)
    {
        ShowPhoneFuncResult (aFuncNames[pHeader->FuncIndex], lResult);
    }
    else
    {
        ShowTapiFuncResult (aFuncNames[pHeader->FuncIndex], lResult);
    }

    return lResult;
}


BOOL
IsLineAppSelected(
    void
    )
{
    if (!pLineAppSel)
    {
        if (gbDisableHandleChecking)
        {
            pLineAppSel = (PMYLINEAPP) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select an hLineApp", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsLineSelected(
    void
    )
{
    if (!pLineSel)
    {
        if (gbDisableHandleChecking)
        {
            pLineSel = (PMYLINE) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a Line", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsCallSelected(
    void
    )
{
    if (!pCallSel)
    {
        if (gbDisableHandleChecking)
        {
            pCallSel = (PMYCALL) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a Call", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsTwoCallsSelected(
    void
    )
{
    if (!pCallSel || !pCallSel2)
    {
        if (gbDisableHandleChecking)
        {
            if (!pCallSel)
            {
                pCallSel = (PMYCALL) NullWidget;
            }

            pCallSel2 = (PMYCALL) NullWidget;
        }
        else
        {
            MessageBox(
                ghwndMain,
                "Select a Call (must have at least two calls on same line)",
                "",
                MB_OK
                );
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsPhoneAppSelected(
    void
    )
{
    if (!pPhoneAppSel)
    {
        if (gbDisableHandleChecking)
        {
            pPhoneAppSel = (PMYPHONEAPP) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a PhoneApp", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsPhoneSelected(
    void
    )
{
    if (!pPhoneSel)
    {
        if (gbDisableHandleChecking)
        {
            pPhoneSel = (PMYPHONE) NullWidget;
        }
        else
        {
            MessageBox (ghwndMain, "Select a Phone", "", MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}


//
// We get a slough of C4113 (func param lists differed) warnings down below
// in the initialization of FUNC_PARAM_HEADER structs as a result of the
// real func prototypes having params that are pointers rather than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4113)

//#pragma code_seg ("myseg")

void
FuncDriver(
    FUNC_INDEX funcIndex
    )
{
    int     i;
    LONG    lResult;


#if TAPI_2_0

    //
    // Determine if we're doing a ascii or a unicode op
    //

    gbWideStringParams =
        ((aFuncNames[funcIndex])[strlen (aFuncNames[funcIndex]) - 1] == 'W' ?
            TRUE : FALSE);

#endif

    switch (funcIndex)
    {
    case lAccept:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING, (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineAccept };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lAddToConference:
    {
        FUNC_PARAM params[] =
        {
            { "hConfCall",       PT_DWORD, (ULONG_PTR) 0, NULL },
            { "hConsultCall",    PT_DWORD, (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineAddToConference };


        CHK_TWO_CALLS_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) pCallSel2->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lAgentSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,                      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,                PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwAgentExtensionIDIndex",    PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,                   PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,                     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineAgentSpecific };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
#endif
    case lAnswer:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING, (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineAnswer };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lBlindTransfer:
#if TAPI_2_0
    case lBlindTransferW:
#endif
    {
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { "dwCountryCode",      PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lBlindTransfer ?
                (PFN3) lineBlindTransfer : (PFN3) lineBlindTransferW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineBlindTransfer };
#endif



        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lClose:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineClose };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc(&paramsHeader)) == 0)
        {
            FreeLine (GetLine((HLINE) params[0].dwValue));
        }

        break;
    }
    case lCompleteCall:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,   0, NULL },
            { "lpdwCompletionID",   PT_POINTER, 0, NULL },
            { "dwCompletionMode",   PT_FLAGS,   LINECALLCOMPLMODE_CAMPON, aCallComplModes },
            { "dwMessageID",        PT_DWORD,   0, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineCompleteCall };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) &pCallSel->dwCompletionID;

// BUGBUG if user chgs hCall the wrong &pCallSel->dwCompletionID filled in

        DoFunc(&paramsHeader);

        break;
    }
    case lCompleteTransfer:
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   0, NULL },
            { "hConsultCall",   PT_DWORD,   0, NULL },
            { "lphConfCall",    PT_POINTER, 0, NULL },
            { "dwTransferMode", PT_ORDINAL, LINETRANSFERMODE_TRANSFER, aTransferModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineCompleteTransfer };


        CHK_TWO_CALLS_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) pCallSel2->hCall;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // First make sure we're created the call under the right line,
            // and if not move it to the right place in the widgets list
            //

            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);

            if (lineGetCallInfo ((HCALL) params[0].dwValue, &callInfo) == 0)
            {
                if (callInfo.hLine != pLineSel->hLine)
                {
                    MoveCallToLine (pNewCall, callInfo.hLine);
                }
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lConfigDialog:
#if TAPI_2_0
    case lConfigDialogW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,       PT_DWORD, dwDefLineDeviceID, NULL },
            { szhwndOwner,        PT_DWORD, (ULONG_PTR) ghwndMain, NULL },
            { szlpszDeviceClass,  PT_STRING, (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lConfigDialog ?
                (PFN3) lineConfigDialog : (PFN3) lineConfigDialogW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineConfigDialog };
#endif


        CHK_LINEAPP_SELECTED()

        strcpy (szDeviceClass, szDefLineDeviceClass);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineConfigDialog(
            params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPCSTR) params[2].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case lDeallocateCall:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineDeallocateCall };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            FreeCall (GetCall((HCALL) params[0].dwValue));
        }

        break;
    }
    case lDevSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,           PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineDevSpecific };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
        }

        memset (pBigBuf, 0, (size_t) dwBigBufSize);

        DoFunc (&paramsHeader);

        break;
    }
    case lDevSpecificFeature:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
//            { "dwFeature",          PT_???, 0, aPhoneButtonFunctions },
            { "dwFeature",          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,           PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineDevSpecificFeature };


        // BUGBUG need another PT_ type for constants for dwFeature param

        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);

        DoFunc (&paramsHeader);

        break;
    }
    case lDial:
#if TAPI_2_0
    case lDialW:
#endif
    {
        char szAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szAddress, szAddress },
            { "dwCountryCode",      PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lDial ?
                (PFN3) lineDial : (PFN3) lineDialW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineDial };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szAddress, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lDrop:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING, (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineDrop };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        // assert (lResult != 0);

        if (gbDeallocateCall && (lResult > 0))
        {
            PMYCALL pCall = GetCall ((HCALL) params[0].dwValue);

            dwNumPendingDrops++;
            pCall->lDropReqID = lResult;
        }

        break;
    }
    case lForward:
#if TAPI_2_0
    case lForwardW:
#endif
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,        0, NULL },
            { "bAllAddresses",      PT_DWORD,        1, NULL },
            { szdwAddressID,        PT_DWORD,        0, NULL },
            { "lpForwardList",      PT_FORWARDLIST,  0, NULL },
            { "dwNumRingsNoAnswer", PT_DWORD,        5, NULL },
            { szlphConsultCall,     PT_POINTER,      0, NULL },
            { szlpCallParams,       PT_CALLPARAMS,   0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (funcIndex == lForward ?
                (PFN7) lineForward : (PFN7) lineForwardW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineForward };
#endif
        LPLINEFORWARDLIST lpForwardList;
        DWORD   dwTotalSize = sizeof(LINEFORWARDLIST) +
                    MAX_LINEFORWARD_ENTRIES *
                    (sizeof(LINEFORWARD) + 2*MAX_STRING_PARAM_SIZE);


        CHK_LINE_SELECTED()


        if (!(lpForwardList = malloc (dwTotalSize)))
        {
            ErrorAlert();
            ShowStr ("error alloc'ing data structure");
            break;
        }

        memset (lpForwardList, 0, dwTotalSize);

        lpForwardList->dwTotalSize  = dwTotalSize;
        lpForwardList->dwNumEntries = 0;

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            free (lpForwardList);
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[3].dwValue =
        params[3].u.dwDefValue = (ULONG_PTR) lpForwardList;
        params[5].dwValue =
        params[5].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) > 0)
        {
            if (params[0].dwValue != (ULONG_PTR) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        free (lpForwardList);

        break;
    }
    case lGatherDigits:
#if TAPI_2_0
    case lGatherDigitsW:
#endif
    {
        char *buf;
        char szTermDigits[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { szhCall,                  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwDigitModes",           PT_FLAGS,   (ULONG_PTR) LINEDIGITMODE_DTMF, aDigitModes },
            { "lpsDigits",              PT_POINTER, (ULONG_PTR) 0, NULL },
            { "dwNumDigits",            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpszTerminationDigits",  PT_STRING,  (ULONG_PTR) szTermDigits, szTermDigits },
            { "dwFirstDigitTimeout",    PT_DWORD,   (ULONG_PTR) 0x8000, NULL },
            { "dwInterDigitTimeout",    PT_DWORD,   (ULONG_PTR) 0x8000, NULL },
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (funcIndex == lGatherDigits ?
                (PFN7) lineGatherDigits : (PFN7) lineGatherDigitsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineGatherDigits };
#endif

        CHK_CALL_SELECTED()

        #define DEF_NUM_GATHERED_DIGITS 64

        if (!(buf = (char *) malloc ((DEF_NUM_GATHERED_DIGITS + 1) * 2)))
        {
            ShowStr ("failed to allocate memory");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) buf;
        params[3].dwValue = DEF_NUM_GATHERED_DIGITS;

        memset (buf, 0, DEF_NUM_GATHERED_DIGITS * 2);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        if (params[0].dwValue != (DWORD) pCallSel->hCall)
        {
            pCallSel = GetCall ((HCALL) params[0].dwValue);
        }

        if (params[2].dwValue == (ULONG_PTR) buf &&
            params[3].dwValue > DEF_NUM_GATHERED_DIGITS)
        {
            if (MessageBox(
                    ghwndMain,
                    "Do you want to allocate a larger GatherDigits buffer?" \
                        "(Not doing so may cause undefined app behavior.)",
                    "Warning: lineGatherDigits",
                    MB_YESNO
                    ) == IDYES)
            {
                free (buf);

                // Note: we get weird errors in malloc when specifying a
                //       size > 0xffffff00, so special case

                if (params[3].dwValue > 0x10000)
                {
                    ShowStr ("sorry, too many digits.");
                    break;
                }

                buf = (char *) malloc ((size_t) (params[3].dwValue + 1) * 2);

                if (!(params[2].dwValue = (ULONG_PTR) buf))
                {
                    ShowStr ("failed to allocate memory");
                    break;
                }

                memset (buf, 0, (size_t) params[3].dwValue * 2);
            }
        }

        if (pCallSel->lpsGatheredDigits && params[2].dwValue)
        {
            if (MessageBox(
                    ghwndMain,
                    "GatherDigits already in progress on this hCall; if you" \
                        "continue previous digits buffer may be discarded" \
                        "without being freed",
                    "Warning: lineGatherDigits",
                    MB_OKCANCEL

                    ) == IDCANCEL)
            {
                if (buf)
                {
                    free (buf);
                }
                break;
            }
        }

        DumpParams (&paramsHeader);

#if TAPI_2_0
        if (funcIndex == lGatherDigits)
        {
            lResult = lineGatherDigits(
                (HCALL) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPSTR) params[2].dwValue,
                (DWORD) params[3].dwValue,
                (LPCSTR) params[4].dwValue,
                (DWORD) params[5].dwValue,
                (DWORD) params[6].dwValue
                );
        }
        else
        {
            MakeWideString (szTermDigits);

            lResult = lineGatherDigitsW(
                (HCALL) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPWSTR) params[2].dwValue,
                (DWORD) params[3].dwValue,
                (LPCWSTR) params[4].dwValue,
                (DWORD) params[5].dwValue,
                (DWORD) params[6].dwValue
                );
        }
#else
        lResult = lineGatherDigits(
            (HCALL) params[0].dwValue,
            params[1].dwValue,
            (LPSTR) params[2].dwValue,
            params[3].dwValue,
            (LPCSTR) params[4].dwValue,
            params[5].dwValue,
            params[6].dwValue
            );

#endif
        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult) // FAILURE
        {
            if (buf)
            {
                free (buf);
            }
        }
        else // SUCCESS
        {
            if (pCallSel->lpsGatheredDigits)
            {
                //free (pCallSel->lpsGatheredDigits);
            }

            pCallSel->lpsGatheredDigits   = (char *) params[2].dwValue;
            pCallSel->dwNumGatheredDigits = (DWORD) params[3].dwValue;
#if TAPI_2_0
            if (funcIndex == lGatherDigitsW)
            {
                pCallSel->dwNumGatheredDigits *= 2;
            }
#endif
        }

        break;
    }
    case lGenerateDigits:
#if TAPI_2_0
    case lGenerateDigitsW:
#endif
    {
        char szDigits[MAX_STRING_PARAM_SIZE] = "123";
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,  (ULONG_PTR) 0, NULL },
            { "dwDigitMode",    PT_FLAGS,  (ULONG_PTR) LINEDIGITMODE_DTMF, aDigitModes },
            { "lpszDigits",     PT_STRING, (ULONG_PTR) szDigits, szDigits },
            { "dwDuration",     PT_DWORD,  (ULONG_PTR) 0, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lGenerateDigits ?
                (PFN4) lineGenerateDigits :  (PFN4) lineGenerateDigitsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineGenerateDigits };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lGenerateTone:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,         PT_DWORD,    (ULONG_PTR) 0, NULL },
            { "dwToneMode",    PT_FLAGS,    (ULONG_PTR) LINETONEMODE_CUSTOM, aToneModes },
            { "dwDuration",    PT_DWORD,    (ULONG_PTR) 0, NULL },
            { "dwNumTones",    PT_DWORD,    (ULONG_PTR) 1, NULL },
            { "lpTones",       PT_POINTER,  (ULONG_PTR) pBigBuf, pBigBuf }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGenerateTone };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lGetAddressCaps:
#if TAPI_2_0
    case lGetAddressCapsW:
#endif
    {
        LPLINEADDRESSCAPS lpAddrCaps = (LPLINEADDRESSCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "dwExtVersion",   PT_DWORD,   (ULONG_PTR) dwDefLineExtVersion, NULL },
            { "lpAddressCaps",  PT_POINTER, (ULONG_PTR) lpAddrCaps, lpAddrCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lGetAddressCaps ?
                (PFN6) lineGetAddressCaps : (PFN6) lineGetAddressCapsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineGetAddressCaps };
#endif

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpAddrCaps, 0, (size_t) dwBigBufSize);

        lpAddrCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpAddrCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwLineDeviceID",                 FT_DWORD,   lpAddrCaps->dwLineDeviceID, NULL },
                    { "dwAddressSize",                  FT_SIZE,    lpAddrCaps->dwAddressSize, NULL },
                    { "dwAddressOffset",                FT_OFFSET,  lpAddrCaps->dwAddressOffset, NULL },
                    { "dwDevSpecificSize",              FT_SIZE,    lpAddrCaps->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",            FT_OFFSET,  lpAddrCaps->dwDevSpecificOffset, NULL },
                    { "dwAddressSharing",               FT_FLAGS,   lpAddrCaps->dwAddressSharing, aAddressSharing },
                    { "dwAddressStates",                FT_FLAGS,   lpAddrCaps->dwAddressStates, aAddressStates },
                    { "dwCallInfoStates",               FT_FLAGS,   lpAddrCaps->dwCallInfoStates, aCallInfoStates },
                    { "dwCallerIDFlags",                FT_FLAGS,   lpAddrCaps->dwCallerIDFlags, aCallerIDFlags },
                    { "dwCalledIDFlags",                FT_FLAGS,   lpAddrCaps->dwCalledIDFlags, aCallerIDFlags },
                    { "dwConnectedIDFlags",             FT_FLAGS,   lpAddrCaps->dwConnectedIDFlags, aCallerIDFlags },
                    { "dwRedirectionIDFlags",           FT_FLAGS,   lpAddrCaps->dwRedirectionIDFlags, aCallerIDFlags },
                    { "dwRedirectingIDFlags",           FT_FLAGS,   lpAddrCaps->dwRedirectingIDFlags, aCallerIDFlags },
                    { "dwCallStates",                   FT_FLAGS,   lpAddrCaps->dwCallStates, aCallStates },
                    { "dwDialToneModes",                FT_FLAGS,   lpAddrCaps->dwDialToneModes, aDialToneModes },
                    { "dwBusyModes",                    FT_FLAGS,   lpAddrCaps->dwBusyModes, aBusyModes },
                    { "dwSpecialInfo",                  FT_FLAGS,   lpAddrCaps->dwSpecialInfo, aSpecialInfo },
                    { "dwDisconnectModes",              FT_FLAGS,   lpAddrCaps->dwDisconnectModes, aDisconnectModes },
                    { "dwMaxNumActiveCalls",            FT_DWORD,   lpAddrCaps->dwMaxNumActiveCalls, NULL },
                    { "dwMaxNumOnHoldCalls",            FT_DWORD,   lpAddrCaps->dwMaxNumOnHoldCalls, NULL },
                    { "dwMaxNumOnHoldPendingCalls",     FT_DWORD,   lpAddrCaps->dwMaxNumOnHoldPendingCalls, NULL },
                    { "dwMaxNumConference",             FT_DWORD,   lpAddrCaps->dwMaxNumConference, NULL },
                    { "dwMaxNumTransConf",              FT_DWORD,   lpAddrCaps->dwMaxNumTransConf, NULL },
                    { "dwAddrCapFlags",                 FT_FLAGS,   lpAddrCaps->dwAddrCapFlags, aAddressCapFlags },
                    { "dwCallFeatures",                 FT_FLAGS,   lpAddrCaps->dwCallFeatures, aCallFeatures },
                    { "dwRemoveFromConfCaps",           FT_ORD,     lpAddrCaps->dwRemoveFromConfCaps, aRemoveFromConfCaps },
                    { "dwRemoveFromConfState",          FT_FLAGS,   lpAddrCaps->dwRemoveFromConfState, aCallStates },
                    { "dwTransferModes",                FT_FLAGS,   lpAddrCaps->dwTransferModes, aTransferModes },
                    { "dwParkModes",                    FT_FLAGS,   lpAddrCaps->dwParkModes, aParkModes },
                    { "dwForwardModes",                 FT_FLAGS,   lpAddrCaps->dwForwardModes, aForwardModes },
                    { "dwMaxForwardEntries",            FT_DWORD,   lpAddrCaps->dwMaxForwardEntries, NULL },
                    { "dwMaxSpecificEntries",           FT_DWORD,   lpAddrCaps->dwMaxSpecificEntries, NULL },
                    { "dwMinFwdNumRings",               FT_DWORD,   lpAddrCaps->dwMinFwdNumRings, NULL },
                    { "dwMaxFwdNumRings",               FT_DWORD,   lpAddrCaps->dwMaxFwdNumRings, NULL },
                    { "dwMaxCallCompletions",           FT_DWORD,   lpAddrCaps->dwMaxCallCompletions, NULL },
                    { "dwCallCompletionConds",          FT_FLAGS,   lpAddrCaps->dwCallCompletionConds, aCallComplConds },
                    { "dwCallCompletionModes",          FT_FLAGS,   lpAddrCaps->dwCallCompletionModes, aCallComplModes },
                    { "dwNumCompletionMessages",        FT_DWORD,   lpAddrCaps->dwNumCompletionMessages, NULL },
                    { "dwCompletionMsgTextEntrySize",   FT_DWORD,   lpAddrCaps->dwCompletionMsgTextEntrySize, NULL },
                    { "dwCompletionMsgTextSize",        FT_SIZE,    lpAddrCaps->dwCompletionMsgTextSize, NULL },
                    { "dwCompletionMsgTextOffset",      FT_OFFSET,  lpAddrCaps->dwCompletionMsgTextOffset, NULL }
#if TAPI_1_1
                     ,
                    { "dwAddressFeatures",              FT_FLAGS,   0, aAddressFeatures }
#if TAPI_2_0
                     ,
                    { "dwPredictiveAutoTransferStates", FT_FLAGS,   0, aCallStates },
                    { "dwNumCallTreatments",            FT_DWORD,   0, NULL },
                    { "dwCallTreatmentListSize",        FT_SIZE,    0, NULL },
                    { "dwCallTreatmentListOffset",      FT_OFFSET,  0, NULL },
                    { "dwDeviceClassesSize",            FT_SIZE,    0, NULL },
                    { "dwDeviceClassesOffset",          FT_OFFSET,  0, NULL },
                    { "dwMaxCallDataSize",              FT_DWORD,   0, NULL },
                    { "dwCallFeatures2",                FT_FLAGS,   0, aCallFeatures2 },
                    { "dwMaxNoAnswerTimeout",           FT_DWORD,   0, NULL },
                    { "dwConnectedModes",               FT_FLAGS,   0, aConnectedModes },
                    { "dwOfferingModes",                FT_FLAGS,   0, aOfferingModes },
                    { "dwAvailableMediaModes",          FT_FLAGS,   0, aMediaModes }
#endif
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpAddrCaps, "LINEADDRESSCAPS", 0, fields
                };


                if (params[3].dwValue == 0x10003)
                {
                    //
                    // Only show ver 1.0 params
                    //

                    fieldHeader.dwNumFields = 41;
                }
#if TAPI_1_1
                else if (params[3].dwValue == 0x10004)
                {
                    //
                    // Only show <= ver 1.4 params
                    //

                    fieldHeader.dwNumFields = 42;

                    fields[41].dwValue = lpAddrCaps->dwAddressFeatures;
                }
#if TAPI_2_0
                else
                {
                    //
                    // Only show <= ver 2.0 params
                    //

                    fieldHeader.dwNumFields = 54;

                    fields[41].dwValue = lpAddrCaps->dwAddressFeatures;
                    fields[42].dwValue = lpAddrCaps->dwPredictiveAutoTransferStates;
                    fields[43].dwValue = lpAddrCaps->dwNumCallTreatments;
                    fields[44].dwValue = lpAddrCaps->dwCallTreatmentListSize;
                    fields[45].dwValue = lpAddrCaps->dwCallTreatmentListOffset;
                    fields[46].dwValue = lpAddrCaps->dwDeviceClassesSize;
                    fields[47].dwValue = lpAddrCaps->dwDeviceClassesOffset;
                    fields[48].dwValue = lpAddrCaps->dwMaxCallDataSize;
                    fields[49].dwValue = lpAddrCaps->dwCallFeatures2;
                    fields[50].dwValue = lpAddrCaps->dwMaxNoAnswerTimeout;
                    fields[51].dwValue = lpAddrCaps->dwConnectedModes;
                    fields[52].dwValue = lpAddrCaps->dwOfferingModes;
                    fields[53].dwValue = lpAddrCaps->dwAvailableMediaModes;
                }
#endif
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetAddressID:
#if TAPI_2_0
    case lGetAddressIDW:
#endif
    {
        DWORD dwAddressID;
        char  szAddress[MAX_STRING_PARAM_SIZE] = "0";
        LPLINEADDRESSCAPS lpAddrCaps = (LPLINEADDRESSCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwAddressID",  PT_POINTER, (ULONG_PTR) &dwAddressID, &dwAddressID },
            { "dwAddressMode",  PT_FLAGS,   (ULONG_PTR) LINEADDRESSMODE_DIALABLEADDR, aAddressModes },
            { "lpsAddress",     PT_STRING,  (ULONG_PTR) szAddress, szAddress },
            { szdwSize,         PT_DWORD,   (ULONG_PTR) 2, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lGetAddressID ?
                (PFN5) lineGetAddressID : (PFN5) lineGetAddressIDW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGetAddressID };
#endif

        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%s%s=x%lx", szTab, szdwAddressID, dwAddressID);
        }

        break;
    }
    case lGetAddressStatus:
#if TAPI_2_0
    case lGetAddressStatusW:
#endif
    {
        LPLINEADDRESSSTATUS lpAddrStatus = (LPLINEADDRESSSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAddressCaps",  PT_POINTER, (ULONG_PTR) lpAddrStatus, lpAddrStatus }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetAddressStatus ?
                (PFN3) lineGetAddressStatus : (PFN3) lineGetAddressStatusW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetAddressStatus };
#endif


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpAddrStatus, 0, (size_t) dwBigBufSize);
        lpAddrStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpAddrStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwNumInUse",             FT_DWORD,   lpAddrStatus->dwNumInUse, NULL },
                    { "dwNumActiveCalls",       FT_DWORD,   lpAddrStatus->dwNumActiveCalls, NULL },
                    { "dwNumOnHoldCalls",       FT_DWORD,   lpAddrStatus->dwNumOnHoldCalls, NULL },
                    { "dwNumOnHoldPendCalls",   FT_DWORD,   lpAddrStatus->dwNumOnHoldPendCalls, NULL },
                    { "dwAddressFeatures",      FT_FLAGS,   lpAddrStatus->dwAddressFeatures, aAddressFeatures },
                    { "dwNumRingsNoAnswer",     FT_DWORD,   lpAddrStatus->dwNumRingsNoAnswer, NULL },
                    { "dwForwardNumEntries",    FT_DWORD,   lpAddrStatus->dwForwardNumEntries, NULL },
                    { "dwForwardSize",          FT_SIZE,    lpAddrStatus->dwForwardSize, NULL },
                    { "dwForwardOffset",        FT_OFFSET,  lpAddrStatus->dwForwardOffset, NULL },
                    { "dwTerminalModesSize",    FT_SIZE,    lpAddrStatus->dwTerminalModesSize, NULL },
                    { "dwTerminalModesOffset",  FT_OFFSET,  lpAddrStatus->dwTerminalModesOffset, NULL },
                    { "dwDevSpecificSize",      FT_SIZE,    lpAddrStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpAddrStatus->dwDevSpecificOffset, NULL }
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpAddrStatus,
                    "LINEADDRESSSTATUS",
                    13,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
#if TAPI_2_0
    case lGetAgentActivityList:
    case lGetAgentActivityListW:
    {
        LPLINEAGENTACTIVITYLIST lpActivityList = (LPLINEAGENTACTIVITYLIST)
                                    pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,                  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,            PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentActivityList",    PT_POINTER, (ULONG_PTR) lpActivityList, lpActivityList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetAgentActivityList ?
                (PFN3) lineGetAgentActivityList :
                (PFN3) lineGetAgentActivityListW) };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpActivityList, 0, (size_t) dwBigBufSize);
        lpActivityList->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent activity list on successful async completion

        break;
    }
    case lGetAgentCaps:
    {
        LPLINEAGENTCAPS lpAgentCaps = (LPLINEAGENTCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpAgentCaps",    PT_POINTER, (ULONG_PTR) lpAgentCaps, lpAgentCaps }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGetAgentCaps };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpAgentCaps, 0, (size_t) dwBigBufSize);
        lpAgentCaps->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent caps on successful async completion

        break;
    }
    case lGetAgentGroupList:
    {
        LPLINEAGENTGROUPLIST    lpGroupList = (LPLINEAGENTGROUPLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentGroupList",   PT_POINTER, (ULONG_PTR) lpGroupList, lpGroupList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetAgentGroupList };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpGroupList, 0, (size_t) dwBigBufSize);
        lpGroupList->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent group list on successful async completion

        break;
    }
    case lGetAgentStatus:
    {
        LPLINEAGENTSTATUS   lpStatus = (LPLINEAGENTSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentStatus",  PT_POINTER, (ULONG_PTR) lpStatus, lpStatus }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetAgentStatus };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpStatus, 0, (size_t) dwBigBufSize);
        lpStatus->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

// BUGBUG dump agent status on successful async completion

        break;
    }
#endif
    case lGetCallInfo:
#if TAPI_2_0
    case lGetCallInfoW:
#endif
    {
        LPLINECALLINFO lpCallInfo = (LPLINECALLINFO) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallInfo", PT_POINTER, (ULONG_PTR) lpCallInfo, lpCallInfo }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == lGetCallInfo ?
                (PFN2) lineGetCallInfo : (PFN2) lineGetCallInfoW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetCallInfo };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpCallInfo, 0x5a, (size_t) dwBigBufSize);
        lpCallInfo->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallInfo);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { szhLine,                      FT_DWORD,   (DWORD)lpCallInfo->hLine, NULL },
                    { "dwLineDeviceID",             FT_DWORD,   lpCallInfo->dwLineDeviceID, NULL },
                    { szdwAddressID,                FT_DWORD,   lpCallInfo->dwAddressID, NULL },
                    { "dwBearerMode",               FT_FLAGS,   lpCallInfo->dwBearerMode, aBearerModes },
                    { "dwRate",                     FT_DWORD,   lpCallInfo->dwRate, NULL },
                    { "dwMediaMode",                FT_FLAGS,   lpCallInfo->dwMediaMode, aMediaModes },
                    { "dwAppSpecific",              FT_DWORD,   lpCallInfo->dwAppSpecific, NULL },
                    { "dwCallID",                   FT_DWORD,   lpCallInfo->dwCallID, NULL },
                    { "dwRelatedCallID",            FT_DWORD,   lpCallInfo->dwRelatedCallID, NULL },
                    { "dwCallParamFlags",           FT_FLAGS,   lpCallInfo->dwCallParamFlags, aCallParamFlags },
                    { "dwCallStates",               FT_FLAGS,   lpCallInfo->dwCallStates, aCallStates },
                    { "dwMonitorDigitModes",        FT_FLAGS,   lpCallInfo->dwMonitorDigitModes, aDigitModes },
                    { "dwMonitorMediaModes",        FT_FLAGS,   lpCallInfo->dwMonitorMediaModes, aMediaModes },
                    { "DialParams.dwDialPause",         FT_DWORD,   lpCallInfo->DialParams.dwDialPause, NULL },
                    { "DialParams.dwDialSpeed",         FT_DWORD,   lpCallInfo->DialParams.dwDialSpeed, NULL },
                    { "DialParams.dwDigitDuration",     FT_DWORD,   lpCallInfo->DialParams.dwDigitDuration, NULL },
                    { "DialParams.dwWaitForDialtone",   FT_DWORD,   lpCallInfo->DialParams.dwWaitForDialtone, NULL },
                    { "dwOrigin",                   FT_FLAGS,   lpCallInfo->dwOrigin, aCallOrigins },
                    { "dwReason",                   FT_FLAGS,   lpCallInfo->dwReason, aCallReasons },
                    { "dwCompletionID",             FT_DWORD,   lpCallInfo->dwCompletionID, NULL },
                    { "dwNumOwners",                FT_DWORD,   lpCallInfo->dwNumOwners, NULL },
                    { "dwNumMonitors",              FT_DWORD,   lpCallInfo->dwNumMonitors, NULL },
                    { "dwCountryCode",              FT_DWORD,   lpCallInfo->dwCountryCode, NULL },
                    { "dwTrunk",                    FT_DWORD,   lpCallInfo->dwTrunk, NULL },
                    { "dwCallerIDFlags",            FT_FLAGS,   lpCallInfo->dwCallerIDFlags, aCallerIDFlags },
                    { "dwCallerIDSize",             FT_SIZE,    lpCallInfo->dwCallerIDSize, NULL },
                    { "dwCallerIDOffset",           FT_OFFSET,  lpCallInfo->dwCallerIDOffset, NULL },
                    { "dwCallerIDNameSize",         FT_SIZE,    lpCallInfo->dwCallerIDNameSize, NULL },
                    { "dwCallerIDNameOffset",       FT_OFFSET,  lpCallInfo->dwCallerIDNameOffset, NULL },
                    { "dwCalledIDFlags",            FT_FLAGS,   lpCallInfo->dwCalledIDFlags, aCallerIDFlags },
                    { "dwCalledIDSize",             FT_SIZE,    lpCallInfo->dwCalledIDSize, NULL },
                    { "dwCalledIDOffset",           FT_OFFSET,  lpCallInfo->dwCalledIDOffset, NULL },
                    { "dwCalledIDNameSize",         FT_SIZE,    lpCallInfo->dwCalledIDNameSize, NULL },
                    { "dwCalledIDNameOffset",       FT_OFFSET,  lpCallInfo->dwCalledIDNameOffset, NULL },
                    { "dwConnectedIDFlags",         FT_FLAGS,   lpCallInfo->dwConnectedIDFlags, aCallerIDFlags },
                    { "dwConnectedIDSize",          FT_SIZE,    lpCallInfo->dwConnectedIDSize, NULL },
                    { "dwConnectedIDOffset",        FT_OFFSET,  lpCallInfo->dwConnectedIDOffset, NULL },
                    { "dwConnectedIDNameSize",      FT_SIZE,    lpCallInfo->dwConnectedIDNameSize, NULL },
                    { "dwConnectedIDNameOffset",    FT_OFFSET,  lpCallInfo->dwConnectedIDNameOffset, NULL },
                    { "dwRedirectionIDFlags",       FT_FLAGS,   lpCallInfo->dwRedirectionIDFlags, aCallerIDFlags },
                    { "dwRedirectionIDSize",        FT_SIZE,    lpCallInfo->dwRedirectionIDSize, NULL },
                    { "dwRedirectionIDOffset",      FT_OFFSET,  lpCallInfo->dwRedirectionIDOffset, NULL },
                    { "dwRedirectionIDNameSize",    FT_SIZE,    lpCallInfo->dwRedirectionIDNameSize, NULL },
                    { "dwRedirectionIDNameOffset",  FT_OFFSET,  lpCallInfo->dwRedirectionIDNameOffset, NULL },
                    { "dwRedirectingIDFlags",       FT_FLAGS,   lpCallInfo->dwRedirectingIDFlags, aCallerIDFlags },
                    { "dwRedirectingIDSize",        FT_SIZE,    lpCallInfo->dwRedirectingIDSize, NULL },
                    { "dwRedirectingIDOffset",      FT_OFFSET,  lpCallInfo->dwRedirectingIDOffset, NULL },
                    { "dwRedirectingIDNameSize",    FT_SIZE,    lpCallInfo->dwRedirectingIDNameSize, NULL },
                    { "dwRedirectingIDNameOffset",  FT_OFFSET,  lpCallInfo->dwRedirectingIDNameOffset, NULL },
                    { "dwAppNameSize",              FT_SIZE,    lpCallInfo->dwAppNameSize, NULL },
                    { "dwAppNameOffset",            FT_OFFSET,  lpCallInfo->dwAppNameOffset, NULL },
                    { "dwDisplayableAddressSize",   FT_SIZE,    lpCallInfo->dwDisplayableAddressSize, NULL },
                    { "dwDisplayableAddressOffset", FT_OFFSET,  lpCallInfo->dwDisplayableAddressOffset, NULL },
                    { "dwCalledPartySize",          FT_SIZE,    lpCallInfo->dwCalledPartySize, NULL },
                    { "dwCalledPartyOffset",        FT_OFFSET,  lpCallInfo->dwCalledPartyOffset, NULL },
                    { "dwCommentSize",              FT_SIZE,    lpCallInfo->dwCommentSize, NULL },
                    { "dwCommentOffset",            FT_OFFSET,  lpCallInfo->dwCommentOffset, NULL },
                    { "dwDisplaySize",              FT_SIZE,    lpCallInfo->dwDisplaySize, NULL },
                    { "dwDisplayOffset",            FT_OFFSET,  lpCallInfo->dwDisplayOffset, NULL },
                    { "dwUserUserInfoSize",         FT_SIZE,    lpCallInfo->dwUserUserInfoSize, NULL },
                    { "dwUserUserInfoOffset",       FT_OFFSET,  lpCallInfo->dwUserUserInfoOffset, NULL },
                    { "dwHighLevelCompSize",        FT_SIZE,    lpCallInfo->dwHighLevelCompSize, NULL },
                    { "dwHighLevelCompOffset",      FT_OFFSET,  lpCallInfo->dwHighLevelCompOffset, NULL },
                    { "dwLowLevelCompSize",         FT_SIZE,    lpCallInfo->dwLowLevelCompSize, NULL },
                    { "dwLowLevelCompOffset",       FT_OFFSET,  lpCallInfo->dwLowLevelCompOffset, NULL },
                    { "dwChargingInfoSize",         FT_SIZE,    lpCallInfo->dwChargingInfoSize, NULL },
                    { "dwChargingInfoOffset",       FT_OFFSET,  lpCallInfo->dwChargingInfoOffset, NULL },
                    { "dwTerminalModesSize",        FT_SIZE,    lpCallInfo->dwTerminalModesSize, NULL },
                    { "dwTerminalModesOffset",      FT_OFFSET,  lpCallInfo->dwTerminalModesOffset, NULL },
                    { "dwDevSpecificSize",          FT_SIZE,    lpCallInfo->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",        FT_OFFSET,  lpCallInfo->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwCallTreatment",            FT_DWORD,   0, NULL },
                    { "dwCallDataSize",             FT_SIZE,    0, NULL },
                    { "dwCallDataOffset",           FT_OFFSET,  0, NULL },
                    { "dwSendingFlowspecSize",      FT_SIZE,    0, NULL },
                    { "dwSendingFlowspecOffset",    FT_OFFSET,  0, NULL },
                    { "dwReceivingFlowspecSize",    FT_SIZE,    0, NULL },
                    { "dwReceivingFlowspecOffset",  FT_OFFSET,  0, NULL }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallInfo, "LINECALLINFO", 0, fields
                };


                if (pLineSel->dwAPIVersion < 0x00020000)
                {
                    //
                    // Only show ver 1.0 params
                    //

                    fieldHeader.dwNumFields = 71;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 78;

                    fields[71].dwValue = lpCallInfo->dwCallTreatment;
                    fields[72].dwValue = lpCallInfo->dwCallDataSize;
                    fields[73].dwValue = lpCallInfo->dwCallDataOffset;
                    fields[74].dwValue = lpCallInfo->dwSendingFlowspecSize;
                    fields[75].dwValue = lpCallInfo->dwSendingFlowspecOffset;
                    fields[76].dwValue = lpCallInfo->dwReceivingFlowspecSize;
                    fields[77].dwValue = lpCallInfo->dwReceivingFlowspecOffset;
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetCallStatus:
    {
        LPLINECALLSTATUS lpCallStatus = (LPLINECALLSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallStatus",   PT_POINTER, (ULONG_PTR) lpCallStatus, lpCallStatus }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetCallStatus };
        DWORD   dwAPIVersion;


        CHK_CALL_SELECTED()

        dwAPIVersion = pLineSel->dwAPIVersion;

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpCallStatus, 0, (size_t) dwBigBufSize);
        lpCallStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwCallState",            FT_FLAGS,   lpCallStatus->dwCallState, aCallStates },
                    { "dwCallStateMode",        FT_FLAGS,   lpCallStatus->dwCallStateMode, NULL },
                    { "dwCallPrivilege",        FT_FLAGS,   lpCallStatus->dwCallPrivilege, aCallPrivileges },
                    { "dwCallFeatures",         FT_FLAGS,   lpCallStatus->dwCallFeatures, aCallFeatures },
                    { "dwDevSpecificSize",      FT_SIZE,    lpCallStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpCallStatus->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwCallFeatures2",        FT_FLAGS,   0, aCallFeatures2 },
                    { "tStateEntryTime[0]",     FT_DWORD,   0, NULL },
                    { "tStateEntryTime[1]",     FT_DWORD,   0, NULL },
                    { "tStateEntryTime[2]",     FT_DWORD,   0, NULL },
                    { "tStateEntryTime[3]",     FT_DWORD,   0, NULL }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallStatus, "LINECALLSTATUS", 0, fields
                };


                switch (lpCallStatus->dwCallState)
                {
                case LINECALLSTATE_DIALTONE:

                    fields[1].pLookup = aDialToneModes;
                    break;

                case LINECALLSTATE_BUSY:

                    fields[1].pLookup = aBusyModes;
                    break;

                case LINECALLSTATE_SPECIALINFO:

                    fields[1].pLookup = aSpecialInfo;
                    break;

                case LINECALLSTATE_DISCONNECTED:

                    fields[1].pLookup = aDisconnectModes;
                    break;

                default:

                    fields[1].dwType = FT_DWORD;
                    break;
                }

                if (dwAPIVersion < 0x00020000)
                {
                    fieldHeader.dwNumFields = 6;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 11;

                    fields[6].dwValue  = lpCallStatus->dwCallFeatures2;
                    fields[7].dwValue  = *((LPDWORD) &lpCallStatus->tStateEntryTime);
                    fields[8].dwValue  = *(((LPDWORD) &lpCallStatus->tStateEntryTime) + 1);
                    fields[9].dwValue  = *(((LPDWORD) &lpCallStatus->tStateEntryTime) + 2);
                    fields[10].dwValue = *(((LPDWORD) &lpCallStatus->tStateEntryTime) + 3);
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetConfRelatedCalls:
    {
        LPLINECALLLIST lpCallList = (LPLINECALLLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallList", PT_POINTER, (ULONG_PTR) lpCallList, lpCallList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetConfRelatedCalls };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpCallList, 0, (size_t) dwBigBufSize);
        lpCallList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwCallsNumEntries",  FT_DWORD,   lpCallList->dwCallsNumEntries, NULL },
                    { "dwCallsSize",        FT_SIZE,    lpCallList->dwCallsSize, NULL },
                    { "dwCallsOffset",      FT_OFFSET,  lpCallList->dwCallsOffset, NULL }

                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallList,
                    "LINECALLLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetDevCaps:
#if TAPI_2_0
    case lGetDevCapsW:
#endif
    {
        LPLINEDEVCAPS lpDevCaps = (LPLINEDEVCAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "dwExtVersion",   PT_DWORD,   (ULONG_PTR) dwDefLineExtVersion, NULL },
            { "lpLineDevCaps",  PT_POINTER, (ULONG_PTR) lpDevCaps, lpDevCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lGetDevCaps ?
                (PFN5) lineGetDevCaps : (PFN5) lineGetDevCapsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineGetDevCaps };
#endif

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpDevCaps, 0, (size_t) dwBigBufSize);
        lpDevCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwProviderInfoSize",             FT_SIZE,    lpDevCaps->dwProviderInfoSize, NULL },
                    { "dwProviderInfoOffset",           FT_OFFSET,  lpDevCaps->dwProviderInfoOffset, NULL },
                    { "dwSwitchInfoSize",               FT_SIZE,    lpDevCaps->dwSwitchInfoSize, NULL },
                    { "dwSwitchInfoOffset",             FT_OFFSET,  lpDevCaps->dwSwitchInfoOffset, NULL },
                    { "dwPermanentLineID",              FT_DWORD,   lpDevCaps->dwPermanentLineID, NULL },
                    { "dwLineNameSize",                 FT_SIZE,    lpDevCaps->dwLineNameSize, NULL },
                    { "dwLineNameOffset",               FT_OFFSET,  lpDevCaps->dwLineNameOffset, NULL },
                    { "dwStringFormat",                 FT_ORD,     lpDevCaps->dwStringFormat, aStringFormats },
                    { "dwAddressModes",                 FT_FLAGS,   lpDevCaps->dwAddressModes, aAddressModes },
                    { "dwNumAddresses",                 FT_DWORD,   lpDevCaps->dwNumAddresses, NULL },
                    { "dwBearerModes",                  FT_FLAGS,   lpDevCaps->dwBearerModes, aBearerModes },
                    { "dwMaxRate",                      FT_DWORD,   lpDevCaps->dwMaxRate, NULL },
                    { "dwMediaModes",                   FT_FLAGS,   lpDevCaps->dwMediaModes, aMediaModes },
                    { "dwGenerateToneModes",            FT_FLAGS,   lpDevCaps->dwGenerateToneModes, aToneModes },
                    { "dwGenerateToneMaxNumFreq",       FT_DWORD,   lpDevCaps->dwGenerateToneMaxNumFreq, NULL },
                    { "dwGenerateDigitModes",           FT_FLAGS,   lpDevCaps->dwGenerateDigitModes, aDigitModes },
                    { "dwMonitorToneMaxNumFreq",        FT_DWORD,   lpDevCaps->dwMonitorToneMaxNumFreq, NULL },
                    { "dwMonitorToneMaxNumEntries",     FT_DWORD,   lpDevCaps->dwMonitorToneMaxNumEntries, NULL },
                    { "dwMonitorDigitModes",            FT_FLAGS,   lpDevCaps->dwMonitorDigitModes, aDigitModes },
                    { "dwGatherDigitsMinTimeout",       FT_DWORD,   lpDevCaps->dwGatherDigitsMinTimeout, NULL },
                    { "dwGatherDigitsMaxTimeout",       FT_DWORD,   lpDevCaps->dwGatherDigitsMaxTimeout, NULL },
                    { "dwMedCtlDigitMaxListSize",       FT_DWORD,   lpDevCaps->dwMedCtlDigitMaxListSize, NULL },
                    { "dwMedCtlMediaMaxListSize",       FT_DWORD,   lpDevCaps->dwMedCtlMediaMaxListSize, NULL },
                    { "dwMedCtlToneMaxListSize",        FT_DWORD,   lpDevCaps->dwMedCtlToneMaxListSize, NULL },
                    { "dwMedCtlCallStateMaxListSize",   FT_DWORD,   lpDevCaps->dwMedCtlCallStateMaxListSize, NULL },
                    { "dwDevCapFlags",                  FT_FLAGS,   lpDevCaps->dwDevCapFlags, aDevCapsFlags },
                    { "dwMaxNumActiveCalls",            FT_DWORD,   lpDevCaps->dwMaxNumActiveCalls, NULL },
                    { "dwAnswerMode",                   FT_FLAGS,   lpDevCaps->dwAnswerMode, aAnswerModes },
                    { "dwRingModes",                    FT_DWORD,   lpDevCaps->dwRingModes, NULL },
                    { "dwLineStates",                   FT_FLAGS,   lpDevCaps->dwLineStates, aLineStates },
                    { "dwUUIAcceptSize",                FT_DWORD,   lpDevCaps->dwUUIAcceptSize, NULL },
                    { "dwUUIAnswerSize",                FT_DWORD,   lpDevCaps->dwUUIAnswerSize, NULL },
                    { "dwUUIMakeCallSize",              FT_DWORD,   lpDevCaps->dwUUIMakeCallSize, NULL },
                    { "dwUUIDropSize",                  FT_DWORD,   lpDevCaps->dwUUIDropSize, NULL },
                    { "dwUUISendUserUserInfoSize",      FT_DWORD,   lpDevCaps->dwUUISendUserUserInfoSize, NULL },
                    { "dwUUICallInfoSize",              FT_DWORD,   lpDevCaps->dwUUICallInfoSize, NULL },
                    { "MinDialParams.dwDialPause",          FT_DWORD,   lpDevCaps->MinDialParams.dwDialPause, NULL },
                    { "MinDialParams.dwDialSpeed",          FT_DWORD,   lpDevCaps->MinDialParams.dwDialSpeed, NULL },
                    { "MinDialParams.dwDigitDuration",      FT_DWORD,   lpDevCaps->MinDialParams.dwDigitDuration, NULL },
                    { "MinDialParams.dwWaitForDialtone",    FT_DWORD,   lpDevCaps->MinDialParams.dwWaitForDialtone, NULL },
                    { "MaxDialParams.dwDialPause",          FT_DWORD,   lpDevCaps->MaxDialParams.dwDialPause, NULL },
                    { "MaxDialParams.dwDialSpeed",          FT_DWORD,   lpDevCaps->MaxDialParams.dwDialSpeed, NULL },
                    { "MaxDialParams.dwDigitDuration",      FT_DWORD,   lpDevCaps->MaxDialParams.dwDigitDuration, NULL },
                    { "MaxDialParams.dwWaitForDialtone",    FT_DWORD,   lpDevCaps->MaxDialParams.dwWaitForDialtone, NULL },
                    { "DefDialParams.dwDialPause",          FT_DWORD,   lpDevCaps->DefaultDialParams.dwDialPause, NULL },
                    { "DefDialParams.dwDialSpeed",          FT_DWORD,   lpDevCaps->DefaultDialParams.dwDialSpeed, NULL },
                    { "DefDialParams.dwDigitDuration",      FT_DWORD,   lpDevCaps->DefaultDialParams.dwDigitDuration, NULL },
                    { "DefDialParams.dwWaitForDialtone",    FT_DWORD,   lpDevCaps->DefaultDialParams.dwWaitForDialtone, NULL },
                    { "dwNumTerminals",                 FT_DWORD,   lpDevCaps->dwNumTerminals, NULL },
                    { "dwTerminalCapsSize",             FT_SIZE,    lpDevCaps->dwTerminalCapsSize, NULL },
                    { "dwTerminalCapsOffset",           FT_OFFSET,  lpDevCaps->dwTerminalCapsOffset, NULL },
                    { "dwTerminalTextEntrySize",        FT_DWORD,   lpDevCaps->dwTerminalTextEntrySize, NULL },
                    { "dwTerminalTextSize",             FT_SIZE,    lpDevCaps->dwTerminalTextSize, NULL },
                    { "dwTerminalTextOffset",           FT_OFFSET,  lpDevCaps->dwTerminalTextOffset, NULL },
                    { "dwDevSpecificSize",              FT_SIZE,    lpDevCaps->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",            FT_OFFSET,  lpDevCaps->dwDevSpecificOffset, NULL }
#if TAPI_1_1
                     ,
                    { "dwLineFeatures",                 FT_FLAGS,   0, aLineFeatures }
#if TAPI_2_0
                     ,
                    { "dwSettableDevStatus",            FT_FLAGS,   0, aLineDevStatusFlags },
                    { "dwDeviceClassesSize",            FT_SIZE,    0, NULL },
                    { "dwDeviceClassesOffset",          FT_OFFSET,  0, NULL }
#if TAPI_2_2
                     ,
                    { "PermanentLineGuid(Size)",        FT_SIZE,    sizeof (lpDevCaps->PermanentLineGuid), NULL },
                    { "PermanentLineGuid(Offset)",      FT_OFFSET,  ((LPBYTE) &lpDevCaps->PermanentLineGuid) - ((LPBYTE) lpDevCaps), NULL }
#endif
#endif
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpDevCaps, "LINEDEVCAPS", 0, fields
                };

                if (params[2].dwValue == 0x10003)
                {
                    //
                    // Only show ver 1.0 params
                    //

                    fieldHeader.dwNumFields = 56;
                }
#if TAPI_1_1
                else if (params[2].dwValue == 0x10004)
                {
                    //
                    // Only show <= ver 1.1 params
                    //

                    fieldHeader.dwNumFields = 57;

                    fields[56].dwValue = lpDevCaps->dwLineFeatures;
                }
#if TAPI_2_0
                else
                {
                    //
                    // Only show <= ver 2.0 params
                    //

                    fieldHeader.dwNumFields = 60;

                    fields[56].dwValue = lpDevCaps->dwLineFeatures;
                    fields[57].dwValue = lpDevCaps->dwSettableDevStatus;
                    fields[58].dwValue = lpDevCaps->dwDeviceClassesSize;
                    fields[59].dwValue = lpDevCaps->dwDeviceClassesOffset;
#if TAPI_2_2
                    if (params[2].dwValue >= 0x20002)
                    {
                        fieldHeader.dwNumFields += 2;
                    }
#endif
                }
#endif
#endif

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lGetDevConfig:
#if TAPI_2_0
    case lGetDevConfigW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpDevConfig = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { "lpDeviceConfig",     PT_POINTER, (ULONG_PTR) lpDevConfig, lpDevConfig },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetDevConfig ?
                (PFN3) lineGetDevConfig : (PFN3) lineGetDevConfigW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetDevConfig };
#endif

        memset (lpDevConfig, 0, (size_t) dwBigBufSize);
        lpDevConfig->dwTotalSize = dwBigBufSize;

        strcpy (szDeviceClass, szDefLineDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevConfig);

            ShowVARSTRING (lpDevConfig);
        }

        break;
    }
    case lGetIcon:
#if TAPI_2_0
    case lGetIconW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE] = "";
        HICON hIcon;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lphIcon",            PT_POINTER, (ULONG_PTR) &hIcon, &hIcon }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetIcon ?
                (PFN3) lineGetIcon : (PFN3) lineGetIconW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetIcon };
#endif

        strcpy (szDeviceClass, szDefLineDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            DialogBoxParam (
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG5),
                (HWND) ghwndMain,
                IconDlgProc,
                (LPARAM) hIcon
                );
        }

        break;
    }
    case lGetID:
#if TAPI_2_0
    case lGetIDW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpDevID = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwSelect",           PT_ORDINAL, (ULONG_PTR) LINECALLSELECT_LINE, aCallSelects },
            { "lpDeviceID",         PT_POINTER, (ULONG_PTR) lpDevID, lpDevID },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lGetID ?
                (PFN6) lineGetID : (PFN6) lineGetIDW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineGetID };
#endif


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
            params[3].dwValue = LINECALLSELECT_CALL;
        }
        else
        {
            params[3].dwValue = LINECALLSELECT_LINE;
        }

        memset (lpDevID, 0, (size_t) dwBigBufSize);
        lpDevID->dwTotalSize = dwBigBufSize;

        strcpy (szDeviceClass, szDefLineDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevID);

            ShowVARSTRING (lpDevID);
        }

        break;
    }
    case lGetLineDevStatus:
#if TAPI_2_0
    case lGetLineDevStatusW:
#endif
    {
        LPLINEDEVSTATUS lpDevStatus = (LPLINEDEVSTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpLineDevStatus",    PT_POINTER, (ULONG_PTR) lpDevStatus, lpDevStatus }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == lGetLineDevStatus ?
                (PFN2) lineGetLineDevStatus : (PFN2) lineGetLineDevStatusW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineGetLineDevStatus };
#endif
        DWORD   dwAPIVersion;


        CHK_LINE_SELECTED()

        dwAPIVersion = pLineSel->dwAPIVersion;

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpDevStatus, 0, (size_t) dwBigBufSize);
        lpDevStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwNumOpens",             FT_DWORD,   lpDevStatus->dwNumOpens, NULL },
                    { "dwOpenMediaModes",       FT_FLAGS,   lpDevStatus->dwOpenMediaModes, aMediaModes },
                    { "dwNumActiveCalls",       FT_DWORD,   lpDevStatus->dwNumActiveCalls, NULL },
                    { "dwNumOnHoldCalls",       FT_DWORD,   lpDevStatus->dwNumOnHoldCalls, NULL },
                    { "dwNumOnHoldPendCalls",   FT_DWORD,   lpDevStatus->dwNumOnHoldPendCalls, NULL },
                    { "dwLineFeatures",         FT_FLAGS,   lpDevStatus->dwLineFeatures, aLineFeatures },
                    { "dwNumCallCompletions",   FT_DWORD,   lpDevStatus->dwNumCallCompletions, NULL },
                    { "dwRingMode",             FT_DWORD,   lpDevStatus->dwRingMode, NULL },
                    { "dwSignalLevel",          FT_DWORD,   lpDevStatus->dwSignalLevel, NULL },
                    { "dwBatteryLevel",         FT_DWORD,   lpDevStatus->dwBatteryLevel, NULL },
                    { "dwRoamMode",             FT_FLAGS,   lpDevStatus->dwRoamMode, aLineRoamModes },
                    { "dwDevStatusFlags",       FT_FLAGS,   lpDevStatus->dwDevStatusFlags, aLineDevStatusFlags },
                    { "dwTerminalModesSize",    FT_SIZE,    lpDevStatus->dwTerminalModesSize, NULL },
                    { "dwTerminalModesOffset",  FT_OFFSET,  lpDevStatus->dwTerminalModesOffset, NULL },
                    { "dwDevSpecificSize",      FT_SIZE,    lpDevStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpDevStatus->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwAvailableMediaModes",  FT_FLAGS,   0, aMediaModes },
                    { "dwAppInfoSize",          FT_DWORD,   0, NULL },
                    { "dwAppInfoOffset",        FT_DWORD,   0, NULL }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpDevStatus, "LINEDEVSTATUS", 0, fields
                };

                if (dwAPIVersion < 0x00020000)
                {
                    fieldHeader.dwNumFields = 16;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 19;

                    fields[16].dwValue = lpDevStatus->dwAvailableMediaModes;
                    fields[17].dwValue = lpDevStatus->dwAppInfoSize;
                    fields[18].dwValue = lpDevStatus->dwAppInfoOffset;
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);

#if TAPI_2_0
                if (dwAPIVersion >= 0x00020000 && lpDevStatus->dwAppInfoSize)
                {
                    char            szAppInfoN[16];
                    DWORD           i;
                    LPLINEAPPINFO   pAppInfo;
                    STRUCT_FIELD    fields[] =
                    {
                        { "dwMachineNameSize",      FT_SIZE,    0, NULL },
                        { "dwMachineNameOffset",    FT_OFFSET,  0, NULL },
                        { "dwUserNameSize",         FT_SIZE,    0, NULL },
                        { "dwUserNameOffset",       FT_OFFSET,  0, NULL },
                        { "dwModuleFilenameSize",   FT_SIZE,    0, NULL },
                        { "dwModuleFilenameOffset", FT_OFFSET,  0, NULL },
                        { "dwFriendlyNameSize",     FT_SIZE,    0, NULL },
                        { "dwFriendlyNameOffset",   FT_OFFSET,  0, NULL },
                        { "dwMediaModes",           FT_FLAGS,   0, aMediaModes },
                        { "dwAddressID",            FT_DWORD,   0, NULL },
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpDevStatus, szAppInfoN, 10, fields
                    };


                    pAppInfo = (LPLINEAPPINFO) (((LPBYTE) lpDevStatus) +
                        lpDevStatus->dwAppInfoOffset);

                    for (i = 0; i < lpDevStatus->dwNumOpens; i++)
                    {
                        wsprintf (szAppInfoN, "APPINFO[%d]", i);

                        fields[0].dwValue = pAppInfo->dwMachineNameSize;
                        fields[1].dwValue = pAppInfo->dwMachineNameOffset;
                        fields[2].dwValue = pAppInfo->dwUserNameSize;
                        fields[3].dwValue = pAppInfo->dwUserNameOffset;
                        fields[4].dwValue = pAppInfo->dwModuleFilenameSize;
                        fields[5].dwValue = pAppInfo->dwModuleFilenameOffset;
                        fields[6].dwValue = pAppInfo->dwFriendlyNameSize;
                        fields[7].dwValue = pAppInfo->dwFriendlyNameOffset;
                        fields[8].dwValue = pAppInfo->dwMediaModes;;
                        fields[9].dwValue = pAppInfo->dwAddressID;

                        ShowStructByField (&fieldHeader, TRUE);

                        pAppInfo++;
                    }
                }
#endif
            }
        }

        break;
    }
#if TAPI_2_0
    case lGetMessage:
    {
        LINEMESSAGE msg;
        FUNC_PARAM params[] =
        {
            { szhLineApp,   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpMessage",  PT_POINTER, (ULONG_PTR) &msg, &msg },
            { "dwTimeout",  PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

//        // Max timeout of 10 seconds (don't want to hang app & excite user)
//        // unless the user wants INFINITE
//
//        if ( 0xffffffff != params[2].dwValue )
//        {
//            if ( params[2].dwValue > 10000 )
//            {
//                params[2].dwValue = 10000;
//            }
//        }
        

        DumpParams (&paramsHeader);

        lResult = lineGetMessage(
            (HLINEAPP)      params[0].dwValue,
            (LPLINEMESSAGE) params[1].dwValue,
            (DWORD)         params[2].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            tapiCallback(
                msg.hDevice,
                msg.dwMessageID,
                msg.dwCallbackInstance,
                msg.dwParam1,
                msg.dwParam2,
                msg.dwParam3
                );
        }

        break;
    }
#endif
    case lGetNewCalls:
    {
        LPLINECALLLIST lpCallList = (LPLINECALLLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "dwSelect",       PT_ORDINAL, (ULONG_PTR) LINECALLSELECT_LINE, aCallSelects },
            { "lpCallList",     PT_POINTER, (ULONG_PTR) lpCallList, lpCallList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineGetNewCalls };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        memset (lpCallList, 0, (size_t) dwBigBufSize);
        lpCallList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpCallList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwCallsNumEntries",  FT_DWORD,   lpCallList->dwCallsNumEntries, NULL },
                    { "dwCallsSize",        FT_SIZE,    lpCallList->dwCallsSize, NULL },
                    { "dwCallsOffset",      FT_OFFSET,  lpCallList->dwCallsOffset, NULL }

                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCallList,
                    "LINECALLLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }


            //
            // If there are any hCalls returned in this struct we want
            // to add them to the widget list
            //

            if (lpCallList->dwCallsNumEntries)
            {
                PMYLINE pLine = GetLine ((HLINE) params[0].dwValue);
                LPHCALL lphCall = (LPHCALL)
                    (((LPBYTE) lpCallList) + lpCallList->dwCallsOffset);


                for (i = 0; i < (int) lpCallList->dwCallsNumEntries; i++)
                {
                    PMYCALL pNewCall = AllocCall (pLine);
                    LINECALLSTATUS callStatus;


                    if (pNewCall)
                    {
                        pNewCall->hCall    = *lphCall;
                        pNewCall->bMonitor = TRUE;
                        lphCall++;

                        memset (&callStatus, 0, sizeof(LINECALLSTATUS));
                        callStatus.dwTotalSize = sizeof(LINECALLSTATUS);

                        if (lineGetCallStatus (pNewCall->hCall, &callStatus)
                                == 0)
                        {
                            //
                            // Special case chk for bNukeIdleMonitorCalls
                            //

                            if ((callStatus.dwCallState
                                    == LINECALLSTATE_IDLE) &&
                                bNukeIdleMonitorCalls &&
                                (callStatus.dwCallPrivilege
                                    == LINECALLPRIVILEGE_MONITOR))
                            {
                                if ((lResult = lineDeallocateCall(
                                        (HCALL) pNewCall->hCall)) == 0)
                                {
                                    ShowStr(
                                        "Monitored call x%lx deallocated " \
                                            "on IDLE",
                                        pNewCall->hCall
                                        );

                                    FreeCall (pNewCall);
                                }
                                else
                                {
                                    ShowStr(
                                        "lineDeallocateCall failed (x%lx) to" \
                                            " free idle monitored call x%lx",
                                        lResult,
                                        pNewCall->hCall
                                        );

                                    pNewCall->dwCallState = callStatus.dwCallState;
                                }
                            }
                            else
                            {
                                pNewCall->dwCallState = callStatus.dwCallState;
                            }
                        }
                        else
                        {
                            pNewCall->dwCallState = LINECALLSTATE_UNKNOWN;
                        }
                    }
                }

                UpdateWidgetList();
            }
        }

        break;
    }
    case lGetNumRings:
    {
        DWORD dwNumRings;
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,    PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpdwNumRings",   PT_POINTER, (ULONG_PTR) &dwNumRings, &dwNumRings }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetNumRings };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%snum rings = x%lx", szTab, dwNumRings);
        }

        break;
    }
    case lGetRequest:
#if TAPI_2_0
    case lGetRequestW:
#endif
    {
#if TAPI_2_0
        LINEREQMEDIACALLW   reqXxxCall;
#else
        LINEREQMEDIACALL    reqXxxCall;
#endif
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRequestMode",      PT_ORDINAL, (ULONG_PTR) LINEREQUESTMODE_MAKECALL, aRequestModes },
            { "lpRequestBuffer",    PT_POINTER, (ULONG_PTR) &reqXxxCall, &reqXxxCall }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetRequest ?
                (PFN3) lineGetRequest : (PFN3) lineGetRequestW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetRequest };
#endif

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (&reqXxxCall, 0, sizeof (reqXxxCall));

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            if (params[1].dwValue == LINEREQUESTMODE_MAKECALL)
            {
#if TAPI_2_0
                if (gbWideStringParams)
                {
                    LPLINEREQMAKECALLW  lpReqMakeCall = (LPLINEREQMAKECALLW)
                                            &reqXxxCall;


                    ShowStr ("%sszDestAddress=%ws", szTab, lpReqMakeCall->szDestAddress);
                    ShowStr ("%sszAppName=%ws",     szTab, lpReqMakeCall->szAppName);
                    ShowStr ("%sszCalledParty=%ws", szTab, lpReqMakeCall->szCalledParty);
                    ShowStr ("%sszComment=%ws",     szTab, lpReqMakeCall->szComment);
                }
                else
                {
                    LPLINEREQMAKECALL   lpReqMakeCall = (LPLINEREQMAKECALL)
                                            &reqXxxCall;

                    ShowStr ("%sszDestAddress=%s", szTab, lpReqMakeCall->szDestAddress);
                    ShowStr ("%sszAppName=%s",     szTab, lpReqMakeCall->szAppName);
                    ShowStr ("%sszCalledParty=%s", szTab, lpReqMakeCall->szCalledParty);
                    ShowStr ("%sszComment=%s",     szTab, lpReqMakeCall->szComment);
                }
#else
                LPLINEREQMAKECALL   lpReqMakeCall = (LPLINEREQMAKECALL)
                                        &reqXxxCall;


                ShowStr ("%sszDestAddress=%s", szTab, lpReqMakeCall->szDestAddress);
                ShowStr ("%sszAppName=%s",     szTab, lpReqMakeCall->szAppName);
                ShowStr ("%sszCalledParty=%s", szTab, lpReqMakeCall->szCalledParty);
                ShowStr ("%sszComment=%s",     szTab, lpReqMakeCall->szComment);
#endif
            }
            else
            {
                //
                // NOTE: lineGetRequest(MEDIACALL) is a NOOP for win32,
                //       so we don't have to sweat differing sizes for
                //       HWND & WPARAM in the struct
                //

                LPLINEREQMEDIACALL  lpReqMediaCall = (LPLINEREQMEDIACALL)
                                        &reqXxxCall;


                ShowStr ("%shWnd=x%x",         szTab, lpReqMediaCall->hWnd);
                ShowStr ("%swRequestID=x%x",   szTab, lpReqMediaCall->wRequestID);
                ShowStr ("%sszDeviceClass=%s", szTab, lpReqMediaCall->szDeviceClass);
                ShowStr ("%sdwSize=x%lx",      szTab, lpReqMediaCall->dwSize);
                ShowStr ("%sdwSecure=x%lx",    szTab, lpReqMediaCall->dwSecure);
                ShowStr ("%sszDestAddress=%s", szTab, lpReqMediaCall->szDestAddress);
                ShowStr ("%sszAppName=%s",     szTab, lpReqMediaCall->szAppName);
                ShowStr ("%sszCalledParty=%s", szTab, lpReqMediaCall->szCalledParty);
                ShowStr ("%sszComment=%s",     szTab, lpReqMediaCall->szComment);
            }
        }

        break;
    }
    case lGetStatusMessages:
    {
        DWORD aFlags[2];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwLineStates",     PT_POINTER, (ULONG_PTR) &aFlags[0], &aFlags[0] },
            { "lpdwAddressStates",  PT_POINTER, (ULONG_PTR) &aFlags[1], &aFlags[1] }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetStatusMessages };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            STRUCT_FIELD fields[] =
            {
                { "dwLineStates",       FT_FLAGS,   aFlags[0], aLineStates },
                { "dwAddressStates",    FT_FLAGS,   aFlags[1], aAddressStates }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                aFlags,
                "",
                2,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);
        }

        break;
    }
    case lGetTranslateCaps:
#if TAPI_2_0
    case lGetTranslateCapsW:
#endif
    {
        LPLINETRANSLATECAPS lpTranslateCaps = (LPLINETRANSLATECAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpTranslateCaps",    PT_POINTER, (ULONG_PTR) lpTranslateCaps, lpTranslateCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetTranslateCaps ?
                (PFN3) lineGetTranslateCaps : (PFN3) lineGetTranslateCapsW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetTranslateCaps };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        memset (lpTranslateCaps, 0, (size_t) dwBigBufSize);
        lpTranslateCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpTranslateCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                DWORD i;
                LPLINECARDENTRY lpCardEntry;
                LPLINELOCATIONENTRY lpLocationEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumLocations",           FT_DWORD,   lpTranslateCaps->dwNumLocations, NULL },
                    { "dwLocationListSize",       FT_DWORD,   lpTranslateCaps->dwLocationListSize, NULL },
                    { "dwLocationListOffset",     FT_DWORD,   lpTranslateCaps->dwLocationListOffset, NULL },
                    { "dwCurrentLocationID",      FT_DWORD,   lpTranslateCaps->dwCurrentLocationID, NULL },
                    { "dwNumCards",               FT_DWORD,   lpTranslateCaps->dwNumCards, NULL },
                    { "dwCardListSize",           FT_DWORD,   lpTranslateCaps->dwCardListSize, NULL },
                    { "dwCardListOffset",         FT_DWORD,   lpTranslateCaps->dwCardListOffset, NULL },
                    { "dwCurrentPreferredCardID", FT_DWORD,   lpTranslateCaps->dwCurrentPreferredCardID, NULL }
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpTranslateCaps,
                    "LINETRANSLATECAPS",
                    8,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpLocationEntry = (LPLINELOCATIONENTRY)
                    (((LPBYTE) lpTranslateCaps) +
                        lpTranslateCaps->dwLocationListOffset);

                for (i = 0; i < lpTranslateCaps->dwNumLocations; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentLocationID",          FT_DWORD,  lpLocationEntry->dwPermanentLocationID, NULL },
                        { "dwLocationNameSize",             FT_SIZE,   lpLocationEntry->dwLocationNameSize, NULL },
                        { "dwLocationNameOffset",           FT_OFFSET, lpLocationEntry->dwLocationNameOffset, NULL },
                        { "dwCountryCode",                  FT_DWORD,  lpLocationEntry->dwCountryCode, NULL },
                        { "dwCityCodeSize",                 FT_SIZE,   lpLocationEntry->dwCityCodeSize, NULL },
                        { "dwCityCodeOffset",               FT_OFFSET, lpLocationEntry->dwCityCodeOffset, NULL },
                        { "dwPreferredCardID",              FT_DWORD,  lpLocationEntry->dwPreferredCardID, NULL }
#if TAPI_1_1
                         ,
                        { "dwLocalAccessCodeSize",          FT_SIZE,    lpLocationEntry->dwLocalAccessCodeSize, NULL },
                        { "dwLocalAccessCodeOffset",        FT_OFFSET,  lpLocationEntry->dwLocalAccessCodeOffset, NULL },
                        { "dwLongDistanceAccessCodeSize",   FT_SIZE,    lpLocationEntry->dwLongDistanceAccessCodeSize, NULL },
                        { "dwLongDistanceAccessCodeOffset", FT_OFFSET,  lpLocationEntry->dwLongDistanceAccessCodeOffset, NULL },
                        { "dwTollPrefixListSize",           FT_SIZE,    lpLocationEntry->dwTollPrefixListSize, NULL },
                        { "dwTollPrefixListOffset",         FT_OFFSET,  lpLocationEntry->dwTollPrefixListOffset, NULL },
                        { "dwCountryID",                    FT_DWORD,   lpLocationEntry->dwCountryID, NULL },
                        { "dwOptions",                      FT_FLAGS,   lpLocationEntry->dwOptions, aLocationOptions },
                        { "dwCancelCallWaitingSize",        FT_SIZE,    lpLocationEntry->dwCancelCallWaitingSize, NULL },
                        { "dwCancelCallWaitingOffset",      FT_OFFSET,  lpLocationEntry->dwCancelCallWaitingOffset, NULL }
#endif
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpTranslateCaps, // size,offset relative to lpXlatCaps
                        buf,
#if TAPI_1_1
                        17,
#else
                        7,
#endif
                        fields
                    };


                    sprintf (buf, "LINELOCATIONENTRY[%ld]", i);

                    lpLocationEntry++;
#if TAPI_1_1
                    if (params[1].dwValue == 0x10003)
                    {
                        //
                        // Only show ver 1.0 params & munge ptr to
                        // compensate for for smaller struct size
                        //

                        fieldHeader.dwNumFields = 7;
                        lpLocationEntry = (LPLINELOCATIONENTRY)
                            (((LPBYTE) lpLocationEntry) - 10*sizeof(DWORD));

                    }
#endif
                    ShowStructByField (&fieldHeader, TRUE);

                }

                lpCardEntry = (LPLINECARDENTRY)
                    (((LPBYTE) lpTranslateCaps) +
                        lpTranslateCaps->dwCardListOffset);

                for (i = 0; i < lpTranslateCaps->dwNumCards; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentCardID",          FT_DWORD,   lpCardEntry->dwPermanentCardID, NULL },
                        { "dwCardNameSize",             FT_SIZE,    lpCardEntry->dwCardNameSize, NULL },
                        { "dwCardNameOffset",           FT_OFFSET,  lpCardEntry->dwCardNameOffset, NULL }
#if TAPI_1_1
                         ,
                        { "dwCardNumberDigits",         FT_DWORD,   lpCardEntry->dwCardNumberDigits, NULL },
                        { "dwSameAreaRuleSize",         FT_SIZE,    lpCardEntry->dwSameAreaRuleSize, NULL },
                        { "dwSameAreaRuleOffset",       FT_OFFSET,  lpCardEntry->dwSameAreaRuleOffset, NULL },
                        { "dwLongDistanceRuleSize",     FT_SIZE,    lpCardEntry->dwLongDistanceRuleSize, NULL },
                        { "dwLongDistanceRuleOffset",   FT_OFFSET,  lpCardEntry->dwLongDistanceRuleOffset, NULL },
                        { "dwInternationalRuleSize",    FT_SIZE,    lpCardEntry->dwInternationalRuleSize, NULL },
                        { "dwInternationalRuleOffset",  FT_OFFSET,  lpCardEntry->dwInternationalRuleOffset, NULL },
                        { "dwOptions",                  FT_FLAGS,   lpCardEntry->dwOptions, aCardOptions }
#endif
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpTranslateCaps, // size,offset relative to lpXlatCaps
                        buf,
#if TAPI_1_1
                        11,
#else
                        3,
#endif
                        fields
                    };


                    sprintf (buf, "LINECARDENTRY[%ld]", i);

                    lpCardEntry++;
#if TAPI_1_1
                    if (params[1].dwValue == 0x10003)
                    {
                        //
                        // Only show ver 1.0 params & munge ptr to
                        // compensate for for smaller struct size
                        //

                        fieldHeader.dwNumFields = 3;
                        lpCardEntry = (LPLINECARDENTRY)
                            (((LPBYTE) lpCardEntry) - 8*sizeof(DWORD));

                    }
#endif
                    ShowStructByField (&fieldHeader, TRUE);
                }
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case lHandoff:
#if TAPI_2_0
    case lHandoffW:
#endif
    {
        char szFilename[MAX_STRING_PARAM_SIZE] = "tb20.exe";
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpszFileName",   PT_STRING,  (ULONG_PTR) szFilename, szFilename },
            { "dwMediaMode",    PT_FLAGS,   (ULONG_PTR) dwDefMediaMode, aMediaModes }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lHandoff ?
                (PFN3) lineHandoff : (PFN3) lineHandoffW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineHandoff };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lHold:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineHold };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lInitialize:
    {
        PMYLINEAPP pNewLineApp;
        char szAppName[MAX_STRING_PARAM_SIZE];
        DWORD dwNumLineDevs;
        FUNC_PARAM params[] =
        {
            { "lphLineApp",     PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszAppName,    PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumLineDevs, &dwNumLineDevs }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineInitialize };


        if (!(pNewLineApp = AllocLineApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewLineApp->hLineApp;

        strcpy (szAppName, szDefAppName);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HINSTANCEs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreeLineApp (pNewLineApp);

            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineInitialize(
            (LPHLINEAPP)   params[0].dwValue,
            (HINSTANCE)    params[1].dwValue,
            (LINECALLBACK) params[2].dwValue,
            (LPCSTR)       params[3].dwValue,
            (LPDWORD)      params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        if (lResult == 0)
        {
            ShowStr ("%snum line devs = %ld", szTab, dwNumLineDevs);
            //SendMessage (ghwndLineApps, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            gdwNumLineDevs = dwNumLineDevs;
            SelectWidget ((PMYWIDGET) pNewLineApp);
        }
        else
        {
            FreeLineApp (pNewLineApp);
        }

        break;
    }
#if TAPI_2_0
    case lInitializeEx:
    case lInitializeExW:
    {
        char                    szAppName[MAX_STRING_PARAM_SIZE];
        DWORD                   dwNumLineDevs, dwAPIVersion;
        PMYLINEAPP              pNewLineApp;
        LINEINITIALIZEEXPARAMS  initExParams;
        FUNC_PARAM params[] =
        {
            { "lphLineApp",     PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszFriendlyAppName, PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumLineDevs, &dwNumLineDevs },
            { "lpdwAPIVersion", PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "  ->dwAPIVersion",PT_ORDINAL,(ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpInitExParams", PT_POINTER, (ULONG_PTR) &initExParams, &initExParams },
            { "  ->dwOptions",  PT_FLAGS,   (ULONG_PTR) LINEINITIALIZEEXOPTION_USECOMPLETIONPORT, aLineInitExOptions }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, NULL };


        if (!(pNewLineApp = AllocLineApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewLineApp->hLineApp;

        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreeLineApp (pNewLineApp);

            break;
        }

        initExParams.dwTotalSize = sizeof (LINEINITIALIZEEXPARAMS);
        initExParams.dwOptions = (DWORD) params[8].dwValue;
        initExParams.Handles.hCompletionPort = ghCompletionPort;

        dwAPIVersion = (DWORD) params[6].dwValue;

        DumpParams (&paramsHeader);

        if (funcIndex == lInitializeEx)
        {
            lResult = lineInitializeEx(
                (LPHLINEAPP)                params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (LINECALLBACK)              params[2].dwValue,
                (LPCSTR)                    params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPLINEINITIALIZEEXPARAMS)  params[7].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[3].dwValue);

            lResult = lineInitializeExW(
                (LPHLINEAPP)                params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (LINECALLBACK)              params[2].dwValue,
                (LPCWSTR)                   params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPLINEINITIALIZEEXPARAMS)  params[7].dwValue
                );
        }

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%snum line devs = %ld", szTab, dwNumLineDevs);

            if (params[7].dwValue != 0  &&
                (initExParams.dwOptions & 3) ==
                    LINEINITIALIZEEXOPTION_USEEVENT)
            {
                ShowStr(
                    "hLineApp x%x was created with the\r\n" \
                        "USEEVENT option, so you must use\r\n" \
                        "lineGetMessage to retrieve messages.",
                    pNewLineApp->hLineApp
                    );
            }

            //SendMessage (ghwndLineApps, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            gdwNumLineDevs = dwNumLineDevs;
            SelectWidget ((PMYWIDGET) pNewLineApp);
        }
        else
        {
            FreeLineApp (pNewLineApp);
        }

        break;
    }
#endif
    case lMakeCall:
#if TAPI_2_0
    case lMakeCallW:
#endif
    {
        PMYCALL pNewCall;
        char szAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,       (ULONG_PTR) 0, NULL },
            { szlphCall,            PT_POINTER,     (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING,      (ULONG_PTR) szAddress, szAddress },
            { "dwCountryCode",      PT_DWORD,       (ULONG_PTR) dwDefCountryCode, NULL },
            { szlpCallParams,       PT_CALLPARAMS,  (ULONG_PTR) 0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lMakeCall ?
                (PFN5) lineMakeCall : (PFN5) lineMakeCallW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineMakeCall };
#endif

        CHK_LINE_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        strcpy (szAddress, szDefDestAddress);

        if ((lResult = DoFunc (&paramsHeader)) > 0)
        {
            if (params[0].dwValue != (DWORD) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lMonitorDigits:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwDigitModes",   PT_FLAGS, LINEDIGITMODE_DTMF, aDigitModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineMonitorDigits };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lMonitorMedia:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwMediaModes",   PT_FLAGS, dwDefMediaMode, aMediaModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineMonitorMedia };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lMonitorTones:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpToneList",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "dwNumEntries",   PT_DWORD,   (ULONG_PTR) 1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineMonitorTones };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lNegotiateAPIVersion:
    {
        DWORD dwAPIVersion;
        LINEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { "dwAPILowVersion",    PT_DWORD,   (ULONG_PTR) 0x00010000, aAPIVersions },
            { "dwAPIHighVersion",   PT_DWORD,   (ULONG_PTR) 0x10000000, aAPIVersions },
            { "lpdwAPIVersion",     PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineNegotiateAPIVersion };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%s%s=x%lx", szTab, szdwAPIVersion, dwAPIVersion);
            ShowStr(
                "%sextID.ID0=x%lx, .ID1=x%lx, .ID2=x%lx, .ID3=x%lx, ",
                szTab,
                extID.dwExtensionID0,
                extID.dwExtensionID1,
                extID.dwExtensionID2,
                extID.dwExtensionID3
                );
        }

        break;
    }
    case lNegotiateExtVersion:
    {
        DWORD dwExtVersion;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "dwExtLowVersion",    PT_DWORD,   (ULONG_PTR) 0x00000000, NULL },
            { "dwExtHighVersion",   PT_DWORD,   (ULONG_PTR) 0x80000000, NULL },
            { "lpdwExtVersion",     PT_POINTER, (ULONG_PTR) &dwExtVersion, &dwExtVersion }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineNegotiateExtVersion };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwExtVersion=x%lx", szTab, dwExtVersion);
        }

        break;
    }
    default:

        FuncDriver2 (funcIndex);
        break;
    }

    gbWideStringParams = FALSE;
}

//#pragma code_seg ()

#pragma warning (default:4113)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\tb2.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    tb2.c

Abstract:

    API wrapper code for the TAPI Browser util.  Contains the big switch
    statement for all the supported Telephony API's, & various support funcs.

Author:

    Dan Knudson (DanKn)    18-Aug-1995

Revision History:

--*/


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include "tb.h"
#include "vars.h"
#include "resource.h"


extern char szdwDeviceID[];
extern char szdwSize[];
extern char szhCall[];
extern char szhLine[];
extern char szhLineApp[];
extern char szhPhone[];
extern char szlpCallParams[];

extern char szlphCall[];
extern char szlpParams[];
extern char szhwndOwner[];
extern char szdwAddressID[];
extern char szlpszAppName[];
extern char szdwAPIVersion[];
extern char szlphConsultCall[];
extern char szlpszDeviceClass[];
extern char szlpszDestAddress[];
extern char szlpsUserUserInfo[];
extern char szlpszFriendlyAppName[];

char szhMmcApp[]   = "hMmcApp";
char szhPhoneApp[] = "hPhoneApp";
char szdwProviderID[] = "dwProviderID";


void
ShowStructByDWORDs(
    LPVOID  lp
    );

void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    );

void
DumpParams(
    PFUNC_PARAM_HEADER pHeader
    );

void
ShowPhoneFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

void
ShowVARSTRING(
    LPVARSTRING lpVarString
    );

void
ShowTapiFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

VOID
UpdateWidgetListCall(
    PMYCALL pCall
    );

LPWSTR
PASCAL
My_lstrcpyW(
    WCHAR   *pString1,
    WCHAR   *pString2
    );

void
PASCAL
MakeWideString(
    LPVOID pString
    );

#if (INTERNAL_VER >= 0x20000)
DWORD
APIENTRY
internalNewLocationW(
    IN WCHAR* pszName
    );
#endif


void
ShowWidgetList(
    BOOL bShow
    )
{
    static RECT    rect;
    static int     iNumHides = 0;


    if (!bShow)
    {
        iNumHides++;

        if (iNumHides > 1)
        {
            return;
        }

        GetWindowRect (ghwndList1, &rect);

        SetWindowPos(
            ghwndList1,
            (HWND) NULL,
            0,
            0,
            1,
            1,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW |
                SWP_NOZORDER | SWP_HIDEWINDOW
            );
    }
    else
    {
        iNumHides--;

        if (iNumHides > 0)
        {
            return;
        }

        //
        // Do control restoration
        //

        ShowWindow (ghwndList1, SW_SHOW);

        SetWindowPos(
            ghwndList1,
            (HWND) NULL,
            0,
            0,
            rect.right - rect.left,
            rect.bottom - rect.top,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
            );
    }
}


//
// We get a slough of C4113 (func param lists differed) warnings down below
// in the initialization of FUNC_PARAM_HEADER structs as a result of the
// real func prototypes having params that are pointers rather than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4113)

void
FuncDriver2(
    FUNC_INDEX funcIndex
    )
{
    LONG    lResult;
    DWORD   i;


    switch (funcIndex)
    {
    case lOpen:
#if TAPI_2_0
    case lOpenW:
#endif
    {
        PMYLINE pNewLine;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,       0, NULL },
            { szdwDeviceID,         PT_DWORD,       dwDefLineDeviceID, NULL },
            { "lphLine",            PT_POINTER,     0, NULL },
            { szdwAPIVersion,       PT_ORDINAL,     dwDefLineAPIVersion, aAPIVersions },
            { "dwExtVersion",       PT_DWORD,       dwDefLineExtVersion, NULL },
            { "dwCallbackInstance", PT_DWORD,       0, NULL },
            { "dwPrivileges",       PT_FLAGS,       dwDefLinePrivilege, aLineOpenOptions },
            { "dwMediaModes",       PT_FLAGS,       dwDefMediaMode, aMediaModes },
            { szlpCallParams,       PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, (funcIndex == lOpen ?
                (PFN9) lineOpen : (PFN9) lineOpenW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, (PFN9) lineOpen };
#endif

        CHK_LINEAPP_SELECTED()

        if (!(pNewLine = AllocLine (pLineAppSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewLine->hLine;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            if ((HLINEAPP) params[0].dwValue != pLineAppSel->hLineApp)
            {
                //
                // User has switched line apps on us we need to recreate
                // the line data structure under a different line app
                //

                PMYLINE pNewLine2 =
                    AllocLine (GetLineApp((HLINEAPP)params[0].dwValue));

                if (pNewLine2)
                {
                    pNewLine2->hLine = pNewLine->hLine;

                    FreeLine (pNewLine);

                    pNewLine = pNewLine2;
                }
                else
                {
                    // BUGBUG show error: couldn't alloc a new line struct

                    lineClose (pNewLine->hLine);
                    FreeLine  (pNewLine);
                    break;
                }
            }


            //
            // Save info about this line that we can display
            //

            pNewLine->hLineApp     = (HLINEAPP) params[0].dwValue;
            pNewLine->dwDevID      = (DWORD) params[1].dwValue;
            pNewLine->dwAPIVersion = (DWORD) params[3].dwValue;
            pNewLine->dwPrivileges = (DWORD) params[6].dwValue;
            pNewLine->dwMediaModes = (DWORD) params[7].dwValue;

            //SendMessage (ghwndLines, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            SelectWidget ((PMYWIDGET) pNewLine);
        }
        else
        {
            FreeLine (pNewLine);
        }

        break;
    }
    case lPark:
#if TAPI_2_0
    case lParkW:
#endif
    {
        char szDirAddress[MAX_STRING_PARAM_SIZE] = "";
        LPVARSTRING lpNonDirAddress = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhCall,            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwParkMode",       PT_ORDINAL, (ULONG_PTR) LINEPARKMODE_DIRECTED, aParkModes },
            { "lpszDirAddress",   PT_STRING,  (ULONG_PTR) szDirAddress, szDirAddress },
            { "lpNonDirAddress",  PT_POINTER, (ULONG_PTR) lpNonDirAddress, lpNonDirAddress }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lPark ?
                (PFN4) linePark : (PFN4) lineParkW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) linePark };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        memset (lpNonDirAddress, 0, (size_t) dwBigBufSize);
        lpNonDirAddress->dwTotalSize = dwBigBufSize;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lPickup:
#if TAPI_2_0
    case lPickupW:
#endif
    {
        PMYCALL pNewCall;
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        char szGroupID[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szlphCall,            PT_POINTER, (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING,  (ULONG_PTR) szDestAddress, szDestAddress },
            { "lpszGroupID",        PT_STRING,  (ULONG_PTR) szGroupID, szGroupID }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lPickup ?
                (PFN5) linePickup : (PFN5) linePickupW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) linePickup };
#endif


        CHK_LINE_SELECTED()


        //
        // Find a free entry in the call array
        //

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            if (params[0].dwValue != (DWORD) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lPrepareAddToConference:
#if TAPI_2_0
    case lPrepareAddToConferenceW:
#endif
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { "hConfCall",          PT_DWORD,       0, NULL },
            { szlphConsultCall,     PT_POINTER,     0, NULL },
            { szlpCallParams,       PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lPrepareAddToConference ?
                (PFN3) linePrepareAddToConference : (PFN3) linePrepareAddToConferenceW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) linePrepareAddToConference };
#endif

        CHK_CALL_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // First make sure we're created the call under the right line,
            // and if not move it to the right place in the widgets list
            //

            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);

            if (lineGetCallInfo ((HCALL) params[0].dwValue, &callInfo) == 0)
            {
                if (callInfo.hLine != pLineSel->hLine)
                {
                    MoveCallToLine (pNewCall, callInfo.hLine);
                }
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
#if TAPI_2_0
    case lProxyMessage:
    {
        static LOOKUP aValidProxyMsgs[] =
        {
            { LINE_AGENTSPECIFIC    ,"AGENTSPECIFIC"    },
            { LINE_AGENTSTATUS      ,"AGENTSTATUS"      },
            { 0xffffffff            ,""                 }
        };

        FUNC_PARAM params[] =
        {
            { szhLine,      PT_DWORD,   0, NULL },
            { szhCall,      PT_DWORD,   0, NULL },
            { "dwMsg",      PT_ORDINAL, LINE_AGENTSTATUS, aValidProxyMsgs },
            { "dwParam1",   PT_DWORD,   0, NULL },
            { "dwParam2",   PT_FLAGS,   0, aAgentStatus },
            { "dwParam3",   PT_ORDINAL, 0, aAgentStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineProxyMessage };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[1].dwValue = (ULONG_PTR) pCallSel->hCall;
        }

        DoFunc (&paramsHeader);

        break;
    }
    case lProxyResponse:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD,   0, NULL },
            { "lpProxyBuffer",  PT_DWORD,   0, NULL },
            { "dwResult",       PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineProxyResponse };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lRedirect:
#if TAPI_2_0
    case lRedirectW:
#endif
    {
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,  (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { "dwCountryCode",      PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lRedirect ?
                (PFN3) lineRedirect : (PFN3) lineRedirectW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineRedirect };
#endif

        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lRegisterRequestRecipient:
    {
        FUNC_PARAM params[] =
        {
            { szhLineApp,               PT_DWORD,  0, NULL },
            { "dwRegistrationInstance", PT_DWORD,  0, NULL },
            { "dwRequestMode",          PT_FLAGS,  LINEREQUESTMODE_MAKECALL, aRequestModes2 },
            { "bEnable",                PT_DWORD,  1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineRegisterRequestRecipient };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lRemoveFromConference:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineRemoveFromConference };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSecureCall:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineSecureCall };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSendUserUserInfo:
    {
        char szUserUserInfo[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpsUserUserInfo,    PT_STRING,  (ULONG_PTR) szUserUserInfo, szUserUserInfo },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) strlen(szDefUserUserInfo)+1, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSendUserUserInfo };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        strcpy (szUserUserInfo, szDefUserUserInfo);

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lSetAgentActivity:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD, 0, NULL },
            { szdwAddressID,    PT_DWORD, 0, NULL },
            { "dwActivityID",   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetAgentActivity };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
    case lSetAgentGroup:
    {
        LPLINEAGENTGROUPLIST    lpGroupList = (LPLINEAGENTGROUPLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { "lpAgentGroupList",   PT_POINTER, (ULONG_PTR) lpGroupList, lpGroupList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetAgentGroup };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

// BUGBUG SetAgentGRp: allow user to fill in agent group list

        memset (lpGroupList, 0, (size_t) dwBigBufSize);
        lpGroupList->dwTotalSize = dwBigBufSize;

        DoFunc (&paramsHeader);

        break;
    }
    case lSetAgentState:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   0, NULL },
            { szdwAddressID,        PT_DWORD,   0, NULL },
            { "dwAgentState",       PT_FLAGS,   0, aAgentStates },
            { "dwNextAgentState",   PT_FLAGS,   0, aAgentStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineSetAgentState };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetAppSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwAppSpecific",  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetAppSpecific };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lSetCallData:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpCallData", PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetCallData };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetCallParams:
    {
        LINEDIALPARAMS dialParams;
        FUNC_PARAM params[] =
        {
            { szhCall,                  PT_DWORD,   0, NULL },
            { "dwBearerMode",           PT_FLAGS,   dwDefBearerMode, aBearerModes },
            { "dwMinRate",              PT_DWORD,   3100, NULL },
            { "dwMaxRate",              PT_DWORD,   3100, NULL },
            { "lpDialParams",           PT_POINTER, 0, &dialParams },
            { "  ->dwDialPause",        PT_DWORD,   0, NULL },
            { "  ->dwDialSpeed",        PT_DWORD,   0, NULL },
            { "  ->dwDigitDuration",    PT_DWORD,   0, NULL },
            { "  ->dwWaitForDialtone",  PT_DWORD,   0, NULL }

        };
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, NULL };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        dialParams.dwDialPause       = (DWORD) params[5].dwValue;
        dialParams.dwDialSpeed       = (DWORD) params[6].dwValue;
        dialParams.dwDigitDuration   = (DWORD) params[7].dwValue;
        dialParams.dwWaitForDialtone = (DWORD) params[8].dwValue;

        lResult = lineSetCallParams(
            (HCALL) params[0].dwValue,
            (DWORD) params[1].dwValue,
            (DWORD) params[2].dwValue,
            (DWORD) params[3].dwValue,
            (LPLINEDIALPARAMS) params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case lSetCallPrivilege:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,              PT_DWORD,   0, NULL },
            { "dwCallPrivilege",    PT_ORDINAL, LINECALLPRIVILEGE_OWNER, aCallPrivileges }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetCallPrivilege };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            if (params[0].dwValue == (ULONG_PTR) pCallSel->hCall)
            {
                pCallSel->bMonitor =  (params[0].dwValue ==
                    LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                UpdateWidgetListCall (pCallSel);
            }
            else
            {
                PMYCALL pCall;


                if ((pCall = GetCall ((HCALL) params[0].dwValue)))
                {
                    pCall->bMonitor =  (params[0].dwValue ==
                        LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                    UpdateWidgetListCall (pCall);
                }
            }
        }

        break;
    }
#if TAPI_2_0
    case lSetCallQualityOfService:
    {
        char szSendingFlowspec[MAX_STRING_PARAM_SIZE] = "123";
        char szReceivingFlowspec[MAX_STRING_PARAM_SIZE] = "321";
        FUNC_PARAM params[] =
        {
            { szhCall,                  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpSendingFlowspec",      PT_STRING,  (ULONG_PTR) szSendingFlowspec, szSendingFlowspec },
            { "dwSendingFlowspecSize",  PT_DWORD,   (ULONG_PTR) 4, 0 },
            { "lpReceivingFlowspec",    PT_STRING,  (ULONG_PTR) szReceivingFlowspec, szReceivingFlowspec },
            { "dwReceivingFlowspecSize",PT_DWORD,   (ULONG_PTR) 4, 0 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineSetCallQualityOfService };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        DoFunc (&paramsHeader);

        break;
    }
    case lSetCallTreatment:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,      PT_DWORD,   0, NULL },
            { "dwTreatment",PT_ORDINAL, LINECALLTREATMENT_SILENCE, aCallTreatments }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetCallTreatment };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetCurrentLocation:
    {
        FUNC_PARAM params[] =
        {
            { szhLineApp,   PT_DWORD, 0, NULL },
            { "dwLocation", PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetCurrentLocation };


        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetDevConfig:
#if TAPI_2_0
    case lSetDevConfigW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        char szErrorMsg[] = "Bad config info in buffer";
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpDeviceConfig",     PT_POINTER, (ULONG_PTR) 0, NULL },
            { szdwSize,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass },
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lSetDevConfig ?
                (PFN4) lineSetDevConfig : (PFN4) lineSetDevConfigW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineSetDevConfig };
#endif

        //
        // Check to see if there's existing config info in the global buffer
        // (not a foolproof check, but good enough)
        //

        ShowStr ("Call lineGetDevConfig before calling lineSetDevConfig");

        if (dwBigBufSize >= sizeof (VARSTRING))
        {
            DWORD       dwMaxDataSize = dwBigBufSize - sizeof (VARSTRING);
            LPVARSTRING pVarString = (LPVARSTRING) pBigBuf;


            if (pVarString->dwStringSize > dwMaxDataSize ||

                (pVarString->dwStringSize != 0 &&
                    (pVarString->dwStringOffset < sizeof (VARSTRING) ||
                    pVarString->dwStringOffset >
                        (dwBigBufSize - pVarString->dwStringSize))))
            {
                ShowStr (szErrorMsg);
                break;
            }

            params[1].dwValue      =
            params[1].u.dwDefValue = (ULONG_PTR)
                ((LPBYTE) pBigBuf + pVarString->dwStringOffset);
            params[2].dwValue      =
            params[2].u.dwDefValue = pVarString->dwStringSize;
        }
        else
        {
            ShowStr (szErrorMsg);
            break;
        }

        strcpy (szDeviceClass, szDefLineDeviceClass);

        lResult = DoFunc (&paramsHeader);

        break;
    }
#if TAPI_2_0
    case lSetLineDevStatus:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   0, NULL },
            { "dwStatusToChange",   PT_FLAGS,   0, aLineDevStatusFlags },
            { "fStatus",            PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetLineDevStatus };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        DoFunc (&paramsHeader);

        break;
    }
#endif
    case lSetMediaControl:
    {
        LINEMEDIACONTROLDIGIT       aDigits[1];
        LINEMEDIACONTROLMEDIA       aMedias[1];
        LINEMEDIACONTROLTONE        aTones[1];
        LINEMEDIACONTROLCALLSTATE   aCallSts[1];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szhCall,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwSelect",           PT_ORDINAL, (ULONG_PTR) 0, aCallSelects },

            { "lpDigitList",        PT_POINTER, (ULONG_PTR) aDigits, aDigits },
            { "  ->dwDigit",        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwDigitModes",   PT_FLAGS,   (ULONG_PTR) 0, aDigitModes },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwDigitNumEntries",  PT_DWORD,   (ULONG_PTR) 0, NULL },

            { "lpMediaList",        PT_POINTER, (ULONG_PTR) aMedias, aMedias },
            { "  ->dwMediaModes",   PT_FLAGS,   (ULONG_PTR) 0, aMediaModes },
            { "  ->dwDuration",     PT_DWORD,   (ULONG_PTR) 0, 0 },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwMediaNumEntries",  PT_DWORD,   (ULONG_PTR) 0, NULL },

            { "lpToneList",         PT_POINTER, (ULONG_PTR) aTones, aTones },
            { "  ->dwAppSpecific",  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwDuration",     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwFrequency1",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwFrequency2",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwFrequency3",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwToneNumEntries",   PT_DWORD,   (ULONG_PTR) 0, NULL },

            { "lpCallStateList",    PT_POINTER, (ULONG_PTR) aCallSts, aCallSts },
            { "  ->dwCallStates",   PT_FLAGS,   (ULONG_PTR) 0, aCallStates },
            { "  ->dwMediaControl", PT_ORDINAL, (ULONG_PTR) 0, aMediaControls },
            { "dwCallStateNumEntries", PT_DWORD,(ULONG_PTR)  0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 26, funcIndex, params, (PFN12) lineSetMediaControl };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
            params[3].dwValue = LINECALLSELECT_CALL;
        }
        else
        {
            params[3].dwValue =  LINECALLSELECT_LINE;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            DumpParams (&paramsHeader);

            lResult = lineSetMediaControl(
                (HLINE)                       params[0].dwValue,
                (DWORD)                       params[1].dwValue,
                (HCALL)                       params[2].dwValue,
                (DWORD)                       params[3].dwValue,
                (LPLINEMEDIACONTROLDIGIT)     params[4].dwValue,
                (DWORD)                       params[8].dwValue,
                (LPLINEMEDIACONTROLMEDIA)     params[9].dwValue,
                (DWORD)                       params[13].dwValue,
                (LPLINEMEDIACONTROLTONE)      params[14].dwValue,
                (DWORD)                       params[21].dwValue,
                (LPLINEMEDIACONTROLCALLSTATE) params[22].dwValue,
                (DWORD)                       params[25].dwValue
                );

            ShowLineFuncResult (aFuncNames[funcIndex], lResult);
        }

        break;
    }
    case lSetMediaMode:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD, 0, NULL },
            { "dwMediaModes",   PT_FLAGS, dwDefMediaMode, aMediaModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSetMediaMode };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetNumRings:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD, 0, NULL },
            { szdwAddressID,    PT_DWORD, dwDefAddressID, NULL },
            { "dwNumRings",     PT_DWORD, 5, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetNumRings };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetStatusMessages:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD, 0, NULL },
            { "dwLineStates",       PT_FLAGS, 0, aLineStates },
            { "dwAddressStates",    PT_FLAGS, 0, aAddressStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetStatusMessages };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetTerminal:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   0, NULL },
            { szdwAddressID,        PT_DWORD,   dwDefAddressID, NULL },
            { szhCall,              PT_DWORD,   0, NULL },
            { "dwSelect",           PT_ORDINAL, LINECALLSELECT_LINE, aCallSelects },
            { "dwTerminalModes",    PT_FLAGS,   LINETERMMODE_BUTTONS, aTerminalModes },
            { "dwTerminalID",       PT_DWORD,   0, NULL },
            { "bEnable",            PT_DWORD,   0, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineSetTerminal };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        if (pCallSel)
        {
            params[2].dwValue = (ULONG_PTR) pCallSel->hCall;
        }

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetTollList:
#if TAPI_2_0
    case lSetTollListW:
#endif
    {
        char szAddressIn[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { "lpszAddressIn",      PT_STRING,  (ULONG_PTR) szAddressIn, szAddressIn },
            { "dwTollListOption",   PT_FLAGS,   (ULONG_PTR) LINETOLLLISTOPTION_ADD, aTollListOptions }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lSetTollList ?
                (PFN4) lineSetTollList : (PFN4) lineSetTollListW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineSetTollList };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        strcpy (szAddressIn, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lSetupConference:
#if TAPI_2_0
    case lSetupConferenceW:
#endif
    {
        PMYCALL pNewCall, pNewCall2;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,       0, NULL },
            { szhLine,          PT_DWORD,       0, NULL },
            { "lphConfCall",    PT_POINTER,     0, NULL },
            { szlphConsultCall, PT_POINTER,     0, NULL },
            { "dwNumParties",   PT_DWORD,       3, NULL },
            { szlpCallParams,   PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lSetupConference ?
                (PFN6) lineSetupConference : (PFN6) lineSetupConferenceW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineSetupConference };
#endif

        CHK_LINE_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        if (!(pNewCall2 = AllocCall (pLineSel)))
        {
            FreeCall (pNewCall);
            break;
        }

        params[0].dwValue = (ULONG_PTR) (pCallSel ? pCallSel->hCall : 0);
        params[1].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;
        params[3].dwValue =
        params[3].u.dwDefValue = (ULONG_PTR) &pNewCall2->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // Note that the hLine param is ignored if the hCall is non-NULL
            //

            if (params[0].dwValue)
            {
                if (!pCallSel ||
                    (params[0].dwValue != (ULONG_PTR) pCallSel->hCall))
                {
                    //
                    // Get the assoc pLine, if it's diff need to move new calls
                    //

                    PMYWIDGET pWidget = aWidgets;
                    PMYLINE   pLine = (PMYLINE) NULL;


                    while (1)
                    {
                        if ((pWidget->dwType == WT_CALL) &&
                            (params[0].dwValue == (ULONG_PTR)
                                ((PMYCALL)pWidget)->hCall))
                        {
                            break;
                        }
                        else if (pWidget->dwType == WT_LINE)
                        {
                            pLine = (PMYLINE) pWidget;
                        }

                        pWidget = pWidget->pNext;
                    }

                    if (pLine != pLineSel)
                    {
                        MoveCallToLine (pNewCall, pLine->hLine);
                        MoveCallToLine (pNewCall2, pLine->hLine);
                    }
                }
            }
            else if (params[1].dwValue != (ULONG_PTR) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[1].dwValue);
                MoveCallToLine (pNewCall2, (HLINE) params[1].dwValue);
            }

            pNewCall->lMakeCallReqID  =
            pNewCall2->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls += 2;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
            FreeCall (pNewCall2);
        }

        break;
    }
    case lSetupTransfer:
#if TAPI_2_0
    case lSetupTransferW:
#endif
    {
        PMYCALL pNewCall;
        FUNC_PARAM params[] =
        {
            { szhCall,          PT_DWORD,       0, NULL },
            { szlphConsultCall, PT_POINTER,     0, NULL },
            { szlpCallParams,   PT_CALLPARAMS,  0, lpCallParams }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lSetupTransfer ?
                (PFN3) lineSetupTransfer : (PFN3) lineSetupTransferW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineSetupTransfer };
#endif

        CHK_CALL_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            //
            // First make sure we're created the call under the right line,
            // and if not move it to the right place in the widgets list
            //

            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);

            if (lineGetCallInfo ((HCALL) params[0].dwValue, &callInfo) == 0)
            {
                if (callInfo.hLine != pLineSel->hLine)
                {
                    MoveCallToLine (pNewCall, callInfo.hLine);
                }
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
    case lShutdown:
    {
        FUNC_PARAM params[] =
        {
            { szhLineApp,   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineShutdown };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        if (lResult == 0)
        {
            ShowWidgetList (FALSE);
            FreeLineApp (GetLineApp((HLINEAPP) params[0].dwValue));
            ShowWidgetList (TRUE);
        }

        break;
    }
    case lSwapHold:
    {
        FUNC_PARAM params[] =
        {
            { "hActiveCall",    PT_DWORD, 0, NULL },
            { "hHeldCall",      PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineSwapHold };


        CHK_TWO_CALLS_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;
        params[1].dwValue = (ULONG_PTR) pCallSel2->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lTranslateAddress:
#if TAPI_2_0
    case lTranslateAddressW:
#endif
    {
        char szAddressIn[MAX_STRING_PARAM_SIZE];
        LPLINETRANSLATEOUTPUT lpXlatOutput = (LPLINETRANSLATEOUTPUT) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhLineApp,           PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpszAddressIn",      PT_STRING,  (ULONG_PTR) szAddressIn, szAddressIn },
            { "dwCard",             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwTranslateOptions", PT_FLAGS,   (ULONG_PTR) LINETRANSLATEOPTION_CARDOVERRIDE, aTranslateOptions },
            { "lpTranslateOutput",  PT_POINTER, (ULONG_PTR) lpXlatOutput, lpXlatOutput }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (funcIndex == lTranslateAddress ?
                (PFN7) lineTranslateAddress : (PFN7) lineTranslateAddressW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) lineTranslateAddress };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }
        else
        {
            params[0].dwValue = 0;
        }

        memset (lpXlatOutput, 0, (size_t) dwBigBufSize);
        lpXlatOutput->dwTotalSize = dwBigBufSize;

        strcpy (szAddressIn, szDefDestAddress);

        lResult = DoFunc (&paramsHeader);

        if (lResult == 0)
        {
            ShowStructByDWORDs (lpXlatOutput);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwDialableStringSize",       FT_SIZE,    lpXlatOutput->dwDialableStringSize, NULL },
                    { "dwDialableStringOffset",     FT_OFFSET,  lpXlatOutput->dwDialableStringOffset, NULL },
                    { "dwDisplayableStringSize",    FT_SIZE,    lpXlatOutput->dwDisplayableStringSize, NULL },
                    { "dwDisplayableStringOffset",  FT_OFFSET,  lpXlatOutput->dwDisplayableStringOffset, NULL },
                    { "dwCurrentCountry",           FT_DWORD,   lpXlatOutput->dwCurrentCountry, NULL },
                    { "dwDestCountry",              FT_DWORD,   lpXlatOutput->dwDestCountry, NULL },
                    { "dwTranslateResults",         FT_FLAGS,   lpXlatOutput->dwTranslateResults, aTranslateResults },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpXlatOutput,
                    "LINETRANSLATEOUTPUT",
                    7,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case lUncompleteCall:
    {
        FUNC_PARAM params[] =
        {
            { szhLine,          PT_DWORD, 0, NULL },
            { "dwCompletionID", PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineUncompleteCall };


        CHK_LINE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lUnhold:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineUnhold };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lUnpark:
#if TAPI_2_0
    case lUnparkW:
#endif
    {
        PMYCALL pNewCall;
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLine,              PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwAddressID,        PT_DWORD,   (ULONG_PTR) dwDefAddressID, NULL },
            { szlphCall,            PT_POINTER, (ULONG_PTR) 0, NULL },
            { szlpszDestAddress,    PT_STRING,  (ULONG_PTR) szDestAddress, szDestAddress }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == lUnpark ?
                (PFN4) lineUnpark : (PFN4) lineUnparkW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) lineUnpark };
#endif

        CHK_LINE_SELECTED()

        if (!(pNewCall = AllocCall (pLineSel)))
        {
            break;
        }

        params[0].dwValue = (ULONG_PTR) pLineSel->hLine;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewCall->hCall;

        strcpy (szDestAddress, szDefDestAddress);

        if ((lResult = DoFunc (&paramsHeader)) >= 0)
        {
            if (params[0].dwValue != (ULONG_PTR) pLineSel->hLine)
            {
                MoveCallToLine (pNewCall, (HLINE) params[0].dwValue);
            }

            pNewCall->lMakeCallReqID = lResult;
            dwNumPendingMakeCalls++;
            SelectWidget ((PMYWIDGET) pNewCall);
        }
        else
        {
            FreeCall (pNewCall);
        }

        break;
    }
#if TAPI_1_1
    case lAddProvider:
#if TAPI_2_0
    case lAddProviderW:
#endif
    {
#if TAPI_2_0
        char szProviderFilename[MAX_STRING_PARAM_SIZE] = "esp32.tsp";
#else
        char szProviderFilename[MAX_STRING_PARAM_SIZE] = "esp.tsp";
#endif
        DWORD dwPermanentProviderID;
        FUNC_PARAM params[] =
        {
            { "lpszProviderFilename",       PT_STRING,  (ULONG_PTR) szProviderFilename, szProviderFilename },
            { szhwndOwner,                  PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { "lpdwPermanentProviderID",    PT_POINTER, (ULONG_PTR) &dwPermanentProviderID, &dwPermanentProviderID }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lAddProvider ?
                (PFN3) lineAddProvider : (PFN3) lineAddProviderW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineAddProvider };
#endif

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineAddProvider(
            (LPCSTR) params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPDWORD) params[2].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%sdwPermanentProviderID = x%lx", szTab, dwPermanentProviderID);
        }
#endif
        break;
    }
    case lConfigDialogEdit:
#if TAPI_2_0
    case lConfigDialogEditW:
#endif
    {
        char        szDeviceClass[MAX_STRING_PARAM_SIZE];
        char        szDeviceConfigIn[MAX_STRING_PARAM_SIZE] = "";
        char        szErrorMsg[] = "Bad config info in buffer";
        LPBYTE      pDataIn;
        LPVARSTRING lpDeviceConfigOut = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,           PT_DWORD,     (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szhwndOwner,            PT_DWORD,     (ULONG_PTR) ghwndMain, NULL },
            { szlpszDeviceClass,      PT_STRING,    (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lpDeviceConfigIn",     PT_POINTER,   (ULONG_PTR) 0, NULL },
            { szdwSize,               PT_DWORD,     (ULONG_PTR) 0, NULL },
            { "lpDeviceConfigOut",    PT_POINTER,   (ULONG_PTR) lpDeviceConfigOut, lpDeviceConfigOut }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == lConfigDialogEdit ?
                (PFN6) lineConfigDialogEdit : (PFN6) lineConfigDialogEditW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) lineConfigDialogEdit };
#endif

        //
        // Check to see if there's existing config info in the global buffer
        // (not a foolproof check, but good enough), and if so alloc an
        // intermediate  buffer to use for config in data & copy the
        // existing data over
        //

        ShowStr ("Call lineGetDevConfig before calling lineConfigDialogEdit");

        if (dwBigBufSize >= sizeof (VARSTRING))
        {
            DWORD       dwMaxDataSize = dwBigBufSize - sizeof (VARSTRING);
            LPVARSTRING pVarString = (LPVARSTRING) pBigBuf;


            if (pVarString->dwStringSize > dwMaxDataSize ||

                (pVarString->dwStringSize != 0 &&
                    (pVarString->dwStringOffset < sizeof (VARSTRING) ||
                    pVarString->dwStringOffset >
                        (dwBigBufSize - pVarString->dwStringSize))))
            {
                ShowStr (szErrorMsg);
                break;
            }

            pDataIn = malloc (pVarString->dwStringSize);

            memcpy(
                pDataIn,
                (LPBYTE) pBigBuf + pVarString->dwStringOffset,
                pVarString->dwStringSize
                );

            params[3].dwValue      =
            params[3].u.dwDefValue = (ULONG_PTR) pDataIn;
        }
        else
        {
            ShowStr (szErrorMsg);
            break;
        }

        strcpy (szDeviceClass, szDefLineDeviceClass);

        memset (lpDeviceConfigOut, 0, (size_t) dwBigBufSize);

        lpDeviceConfigOut->dwTotalSize = dwBigBufSize;

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineConfigDialogEdit(
            params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPCSTR) params[2].dwValue,
            (LPVOID) params[3].dwValue,
            params[4].dwValue,
            (LPVARSTRING) params[5].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        if (lResult == 0)
        {
            ShowStructByDWORDs (lpDeviceConfigOut);

            ShowVARSTRING (lpDeviceConfigOut);
        }

        free (pDataIn);

        break;
    }
    case lConfigProvider:
    {
        FUNC_PARAM params[] =
        {
            { szhwndOwner,              PT_DWORD, (ULONG_PTR) ghwndMain, NULL },
            { "dwPermanentProviderID",  PT_DWORD, (ULONG_PTR) 2, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineConfigProvider };


#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineConfigProvider(
            (HWND) params[0].dwValue,
            params[1].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case lGetAppPriority:
#if TAPI_2_0
    case lGetAppPriorityW:
#endif
    {
        DWORD dwPriority;
        LINEEXTENSIONID extID;
        char szAppName[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpExtName = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szlpszAppName,        PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "dwMediaMode",        PT_FLAGS,   (ULONG_PTR) dwDefMediaMode, aMediaModes },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID },
            { "  ->dwExtensionID0", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID1", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID2", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID3", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRequestMode",      PT_FLAGS,   (ULONG_PTR) LINEREQUESTMODE_MAKECALL, aRequestModes },
            { "lpExtensionName",    PT_POINTER, (ULONG_PTR) lpExtName, lpExtName },
            { "lpdwPriority",       PT_POINTER, (ULONG_PTR) &dwPriority, &dwPriority }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, NULL };


        memset (lpExtName, 0, (size_t) dwBigBufSize);
        lpExtName->dwTotalSize = dwBigBufSize;

        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        extID.dwExtensionID0 = (DWORD) params[3].dwValue;
        extID.dwExtensionID1 = (DWORD) params[4].dwValue;
        extID.dwExtensionID2 = (DWORD) params[5].dwValue;
        extID.dwExtensionID3 = (DWORD) params[6].dwValue;

#if TAPI_2_0
        if (funcIndex == lGetAppPriority)
        {
            lResult = lineGetAppPriority(
                (LPCSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPVARSTRING) params[8].dwValue,
                (LPDWORD) params[9].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[0].dwValue);

            lResult = lineGetAppPriorityW(
                (LPCWSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPVARSTRING) params[8].dwValue,
                (LPDWORD) params[9].dwValue
                );
        }
#else
        lResult = lineGetAppPriority(
            (LPCSTR) params[0].dwValue,
            params[1].dwValue,
            (LPLINEEXTENSIONID) params[2].dwValue,
            params[7].dwValue,
            (LPVARSTRING) params[8].dwValue,
            (LPDWORD) params[9].dwValue
            );
#endif
        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%sdwPriority = x%lx", szTab, dwPriority);
            ShowStructByDWORDs (lpExtName);
        }

        break;
    }
    case lGetCountry:
#if TAPI_2_0
    case lGetCountryW:
#endif
    {
        LPLINECOUNTRYLIST lpCountryList = (LPLINECOUNTRYLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { "dwCountryID",       PT_DWORD,    (ULONG_PTR) 1, NULL },
            { szdwAPIVersion,      PT_ORDINAL,  (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpLineCountryList", PT_POINTER,  (ULONG_PTR) lpCountryList, lpCountryList }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == lGetCountry ?
                (PFN3) lineGetCountry : (PFN3) lineGetCountryW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) lineGetCountry };
#endif

        memset (lpCountryList, 0, (size_t) dwBigBufSize);
        lpCountryList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpCountryList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPLINECOUNTRYENTRY lpCountryEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumCountries",         FT_DWORD,   lpCountryList->dwNumCountries, NULL },
                    { "dwCountryListSize",      FT_DWORD,   lpCountryList->dwCountryListSize, NULL },
                    { "dwCountryListOffset",    FT_DWORD,   lpCountryList->dwCountryListOffset, NULL }

                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpCountryList,
                    "LINECOUNTRYLIST",
                    3,
                    fields
                };


                ShowStructByField (&fieldHeader, FALSE);

                lpCountryEntry = (LPLINECOUNTRYENTRY)
                    (((LPBYTE)lpCountryList) +
                        lpCountryList->dwCountryListOffset);

                for (i = 0; i < lpCountryList->dwNumCountries; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwCountryID",                FT_DWORD,   lpCountryEntry->dwCountryID, NULL },
                        { "dwCountryCode",              FT_DWORD,   lpCountryEntry->dwCountryCode, NULL },
                        { "dwNextCountryID",            FT_DWORD,   lpCountryEntry->dwNextCountryID, NULL },
                        { "dwCountryNameSize",          FT_SIZE,    lpCountryEntry->dwCountryNameSize, NULL },
                        { "dwCountryNameOffset",        FT_OFFSET,  lpCountryEntry->dwCountryNameOffset, NULL },
                        { "dwSameAreaRuleSize",         FT_SIZE,    lpCountryEntry->dwSameAreaRuleSize, NULL },
                        { "dwSameAreaRuleOffset",       FT_OFFSET,  lpCountryEntry->dwSameAreaRuleOffset, NULL },
                        { "dwLongDistanceRuleSize",     FT_SIZE,    lpCountryEntry->dwLongDistanceRuleSize, NULL },
                        { "dwLongDistanceRuleOffset",   FT_OFFSET,  lpCountryEntry->dwLongDistanceRuleOffset, NULL },
                        { "dwInternationalRuleSize",    FT_SIZE,    lpCountryEntry->dwInternationalRuleSize, NULL },
                        { "dwInternationalRuleOffset",  FT_OFFSET,  lpCountryEntry->dwInternationalRuleOffset, NULL }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpCountryList, // size,offset relative to ctrylist
                        buf,
                        11,
                        fields
                    };


                    sprintf (buf, "LINECOUNTRYENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpCountryEntry++;
                }
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case lGetProviderList:
#if TAPI_2_0
    case lGetProviderListW:
#endif
    {
        LPLINEPROVIDERLIST lpProviderList = (LPLINEPROVIDERLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "lpProviderList", PT_POINTER, (ULONG_PTR) lpProviderList, lpProviderList }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == lGetProviderList ?
                (PFN3) lineGetProviderList : (PFN3) lineGetProviderListW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN3) lineGetProviderList };
#endif

        memset (lpProviderList, 0, (size_t) dwBigBufSize);
        lpProviderList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpProviderList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPLINEPROVIDERENTRY lpProviderEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumProviders",         FT_DWORD,   lpProviderList->dwNumProviders, NULL },
                    { "dwProviderListSize",     FT_DWORD,   lpProviderList->dwProviderListSize, NULL },
                    { "dwProviderListOffset",   FT_DWORD,   lpProviderList->dwProviderListOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpProviderList,
                    "LINEPROVIDERLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpProviderEntry = (LPLINEPROVIDERENTRY)
                    (((LPBYTE) lpProviderList) +
                        lpProviderList->dwProviderListOffset);

                for (i = 0; i < lpProviderList->dwNumProviders; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentProviderID",      FT_DWORD,   lpProviderEntry->dwPermanentProviderID, NULL },
                        { "dwProviderFilenameSize",     FT_SIZE,    lpProviderEntry->dwProviderFilenameSize, NULL },
                        { "dwProviderFilenameOffset",   FT_OFFSET,  lpProviderEntry->dwProviderFilenameOffset, NULL }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpProviderList, // size,offset relative to ctrylist
                        buf,
                        3,
                        fields
                    };


                    sprintf (buf, "LINEPROVIDERENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpProviderEntry++;
                }

            }

            UpdateResults (FALSE);
        }

        break;
    }
    case lReleaseUserUserInfo:
    {
        FUNC_PARAM params[] =
        {
            { szhCall,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) lineReleaseUserUserInfo };


        CHK_CALL_SELECTED()

        params[0].dwValue = (ULONG_PTR) pCallSel->hCall;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case lRemoveProvider:
    {
        FUNC_PARAM params[] =
        {
            { "dwPermanentProviderID",  PT_DWORD,   (ULONG_PTR) 2, NULL },
            { szhwndOwner,              PT_DWORD,   (ULONG_PTR) ghwndMain, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) lineRemoveProvider };


#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineRemoveProvider(
            params[0].dwValue,
            (HWND) params[1].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case lSetAppPriority:
#if TAPI_2_0
    case lSetAppPriorityW:
#endif
    {
        char szAppName[MAX_STRING_PARAM_SIZE];
        char szExtName[MAX_STRING_PARAM_SIZE] = "";
        LINEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { szlpszAppName,        PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "dwMediaMode",        PT_FLAGS,   (ULONG_PTR) dwDefMediaMode, aMediaModes },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID },
            { "  ->dwExtensionID0", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID1", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID2", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwExtensionID3", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRequestMode",      PT_FLAGS,   (ULONG_PTR) LINEREQUESTMODE_MAKECALL, aRequestModes },
            { "lpszExtensionName",  PT_STRING,  (ULONG_PTR) szExtName, szExtName },
            { "dwPriority",         PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, NULL };


        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        extID.dwExtensionID0 = (DWORD) params[3].dwValue;
        extID.dwExtensionID1 = (DWORD) params[4].dwValue;
        extID.dwExtensionID2 = (DWORD) params[5].dwValue;
        extID.dwExtensionID3 = (DWORD) params[6].dwValue;

#if TAPI_2_0
        if (funcIndex == lSetAppPriority)
        {
            lResult = lineSetAppPriority(
                (LPCSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPCSTR) params[8].dwValue,
                (DWORD) params[9].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[0].dwValue);

            lResult = lineSetAppPriorityW(
                (LPCWSTR) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPLINEEXTENSIONID) params[2].dwValue,
                (DWORD) params[7].dwValue,
                (LPCWSTR) params[8].dwValue,
                (DWORD) params[9].dwValue
                );
        }
#else
        lResult = lineSetAppPriority(
            (LPCSTR) params[0].dwValue,
            params[1].dwValue,
            (LPLINEEXTENSIONID) params[2].dwValue,
            params[7].dwValue,
            (LPCSTR) params[8].dwValue,
            params[9].dwValue
            );
#endif
        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case lTranslateDialog:
#if TAPI_2_0
    case lTranslateDialogW:
#endif
    {
        char szAddressIn[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szhLineApp,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefLineDeviceID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { szhwndOwner,      PT_DWORD,   (ULONG_PTR) ghwndMain, 0 },
            { "lpszAddressIn",  PT_STRING,  (ULONG_PTR) szAddressIn, szAddressIn }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == lTranslateDialog ?
                (PFN5) lineTranslateDialog : (PFN5) lineTranslateDialogW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) lineTranslateDialog };
#endif

        if (pLineAppSel)
        {
            params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;
        }

        strcpy (szAddressIn, szDefDestAddress);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = lineTranslateDialog(
            (HLINEAPP) params[0].dwValue,
            params[1].dwValue,
            params[2].dwValue,
            (HWND) params[3].dwValue,
            (LPCSTR) params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
#endif // TAPI_1_1

#if INTERNAL_3_0

    case mmcAddProvider:
    {
        char szProviderFilename[MAX_STRING_PARAM_SIZE] = "";
        DWORD dwPermanentProviderID;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,                    PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { "lpszProviderFilename",       PT_STRING,  (ULONG_PTR) szProviderFilename, szProviderFilename },
            { szhwndOwner,                  PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { "lpdwPermanentProviderID",    PT_POINTER, (ULONG_PTR) &dwPermanentProviderID, &dwPermanentProviderID }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) MMCAddProvider };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr(
                "%sdwPermanentProviderID = x%lx",
                szTab,
                dwPermanentProviderID
                );
        }

        break;
    }
    case mmcConfigProvider:
    {
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { szhwndOwner,      PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { szdwProviderID,   PT_DWORD,   (ULONG_PTR) 2, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) MMCConfigProvider };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case mmcGetAvailableProviders:
    {
        LPAVAILABLEPROVIDERLIST lpList = (LPAVAILABLEPROVIDERLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpProviderList", PT_POINTER, (ULONG_PTR) lpList, lpList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, MMCGetAvailableProviders };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpList, 0, (size_t) dwBigBufSize);
        lpList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPAVAILABLEPROVIDERENTRY    lpEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumProviderListEntries",   FT_DWORD,   lpList->dwNumProviderListEntries, NULL },
                    { "dwProviderListSize",         FT_DWORD,   lpList->dwProviderListSize, NULL },
                    { "dwProviderListOffset",       FT_DWORD,   lpList->dwProviderListOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpList,
                    "AVAILABLEPROVIDERLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpEntry = (LPAVAILABLEPROVIDERENTRY)
                    (((LPBYTE) lpList) + lpList->dwProviderListOffset);

                for (i = 0; i < lpList->dwNumProviderListEntries; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwFileNameSize",         FT_SIZE,    lpEntry->dwFileNameSize, NULL },
                        { "dwFileNameOffset",       FT_OFFSET,  lpEntry->dwFileNameOffset, NULL },
                        { "dwFriendlyNameSize",     FT_SIZE,    lpEntry->dwFriendlyNameSize, NULL },
                        { "dwFriendlyNameOffset",   FT_OFFSET,  lpEntry->dwFriendlyNameOffset, NULL },
                        { "dwOptions",              FT_FLAGS,   lpEntry->dwOptions, aAvailableProviderOptions }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpList, // size,offset relative to list
                        buf,
                        5,
                        fields
                    };


                    sprintf (buf, "AVAILABLEPROVIDERENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpEntry++;
                }
            }

            UpdateResults (FALSE);
        }
        break;
    }
    case mmcGetLineInfo:
    case mmcGetPhoneInfo:
    {
        LPDEVICEINFOLIST pList = (LPDEVICEINFOLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,    PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { "lpInfoList", PT_POINTER, (ULONG_PTR) pList, pList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == mmcGetLineInfo ?
                (PFN5) MMCGetLineInfo : (PFN5) MMCGetPhoneInfo) };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pList, 0, (size_t) dwBigBufSize);
        pList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            LPDEVICEINFO    pInfo = (LPDEVICEINFO) (((LPBYTE)
                              pList) + pList->dwDeviceInfoOffset);


            UpdateResults (TRUE);

            ShowStructByDWORDs (pList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwNumDevInfoEntries",    FT_DWORD,   pList->dwNumDeviceInfoEntries, NULL },
                    { "dwDevInfoSize",          FT_SIZE,    pList->dwDeviceInfoSize, NULL },
                    { "dwDevInfoOffset",        FT_OFFSET,  pList->dwDeviceInfoOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    pList, "DEVICEINFOLIST", 3, fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                for (i = 0; i < pList->dwNumDeviceInfoEntries; i++, pInfo++)
                {
                    char szDevInfoN[16];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentDevID",           FT_DWORD,   pInfo->dwPermanentDeviceID, NULL },
                        { szdwProviderID,               FT_DWORD,   pInfo->dwProviderID, NULL },
                        { "dwDevNameSize",              FT_SIZE,    pInfo->dwDeviceNameSize, NULL },
                        { "dwDevNameOffset",            FT_OFFSET,  pInfo->dwDeviceNameOffset, NULL },
                        { "dwDomainUserNamesSize",      FT_SIZE,    pInfo->dwDomainUserNamesSize, NULL },
                        { "dwDomainUserNamesOffset",    FT_OFFSET,  pInfo->dwDomainUserNamesOffset, NULL },
                        { "dwFriendlyUserNamesSize",    FT_SIZE,    pInfo->dwFriendlyUserNamesSize, NULL },
                        { "dwFriendlyUserNamesOffset",  FT_OFFSET,  pInfo->dwFriendlyUserNamesOffset, NULL },
                        { "dwAddressesSize",            FT_SIZE,    pInfo->dwAddressesSize, NULL },
                        { "dwAddressesOffset",          FT_OFFSET,  pInfo->dwAddressesOffset, NULL },
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        pList,
                        szDevInfoN,
                        (funcIndex == mmcGetLineInfo ? 10 : 8),
                        fields
                    };

                    wsprintf (szDevInfoN, "DEVICEINFO[%d]", i);

                    ShowStructByField (&fieldHeader, TRUE);
                }
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case mmcGetLineStatus:
    case mmcGetPhoneStatus:
    {
        LPVARSTRING pStatus = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szhwndOwner,          PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { "dwStatusLevel",      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwProviderID,       PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwPermanentDevID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpStatusBuffer",     PT_POINTER, (ULONG_PTR) pStatus, pStatus }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (funcIndex == mmcGetLineStatus ?
                (PFN6) MMCGetLineStatus : (PFN6) MMCGetPhoneStatus) };

        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pStatus, 0, (size_t) dwBigBufSize);
        pStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (pStatus);

            ShowVARSTRING (pStatus);
        }
        break;
    }
    case mmcGetProviderList:
    {
        LPLINEPROVIDERLIST lpList = (LPLINEPROVIDERLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpProviderList", PT_POINTER, (ULONG_PTR) lpList, lpList }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, MMCGetProviderList };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (lpList, 0, (size_t) dwBigBufSize);
        lpList->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (lpList);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                LPLINEPROVIDERENTRY lpEntry;
                STRUCT_FIELD fields[] =
                {
                    { "dwNumProviders",         FT_DWORD,   lpList->dwNumProviders, NULL },
                    { "dwProviderListSize",     FT_DWORD,   lpList->dwProviderListSize, NULL },
                    { "dwProviderListOffset",   FT_DWORD,   lpList->dwProviderListOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpList,
                    "LINEPROVIDERLIST",
                    3,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);

                lpEntry = (LPLINEPROVIDERENTRY)
                    (((LPBYTE) lpList) + lpList->dwProviderListOffset);

                for (i = 0; i < lpList->dwNumProviders; i++)
                {
                    char buf[32];
                    STRUCT_FIELD fields[] =
                    {
                        { "dwPermanentProviderID",      FT_DWORD,   lpEntry->dwPermanentProviderID, NULL },
                        { "dwProviderFilenameSize",     FT_SIZE,    lpEntry->dwProviderFilenameSize, NULL },
                        { "dwProviderFilenameOffset",   FT_OFFSET,  lpEntry->dwProviderFilenameOffset, NULL }
                    };
                    STRUCT_FIELD_HEADER fieldHeader =
                    {
                        lpList, // size,offset relative to list
                        buf,
                        3,
                        fields
                    };


                    sprintf (buf, "LINEPROVIDERENTRY[%ld]", i);

                    ShowStructByField (&fieldHeader, TRUE);

                    lpEntry++;
                }
            }

            UpdateResults (FALSE);
        }
        break;
    }
    case mmcGetServerConfig:
    {
        LPTAPISERVERCONFIG  pConfig = (LPTAPISERVERCONFIG) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,    PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpConfig",   PT_POINTER, (ULONG_PTR) pConfig, pConfig }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, MMCGetServerConfig };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pConfig, 0, (size_t) dwBigBufSize);
        pConfig->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            UpdateResults (TRUE);

            ShowStructByDWORDs (pConfig);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwFlags",                FT_FLAGS,   pConfig->dwFlags, aServerConfigFlags },
                    { "dwDomainNameSize",       FT_SIZE,    pConfig->dwDomainNameSize, NULL },
                    { "dwDomainNameOffset",     FT_OFFSET,  pConfig->dwDomainNameOffset, NULL },
                    { "dwUserNameSize",         FT_SIZE,    pConfig->dwUserNameSize, NULL },
                    { "dwUserNameOffset",       FT_OFFSET,  pConfig->dwUserNameOffset, NULL },
                    { "dwPasswordSize",         FT_SIZE,    pConfig->dwPasswordSize, NULL },
                    { "dwPasswordOffset",       FT_OFFSET,  pConfig->dwPasswordOffset, NULL },
                    { "dwAdministratorsSize",   FT_SIZE,    pConfig->dwAdministratorsSize, NULL },
                    { "dwAdministratorsOffset", FT_OFFSET,  pConfig->dwAdministratorsOffset, NULL },
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    pConfig,
                    "TAPISERVERCONFIG",
                    9,
                    fields
                };

                ShowStructByField (&fieldHeader, FALSE);
            }

            UpdateResults (FALSE);
        }

        break;
    }
    case mmcInitialize:
    {
        PMYLINEAPP pNewLineApp;
        char szComputerName[MAX_STRING_PARAM_SIZE];
        DWORD dwAPIVersion, dwLength;
        FUNC_PARAM params[] =
        {
            { "lpszComputerName",   PT_STRING,  (ULONG_PTR) szComputerName, szComputerName },
            { "lphLineApp",         PT_POINTER, (ULONG_PTR) 0, NULL },
            { "lpdwAPIVersion",     PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "  ->dwAPIVersion",   PT_ORDINAL, (ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
            { "hInstance",          PT_DWORD,   (ULONG_PTR) NULL, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (!(pNewLineApp = AllocLineApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[1].dwValue =
        params[1].u.dwDefValue = (ULONG_PTR) &pNewLineApp->hLineApp;

        dwLength = sizeof (szComputerName);
        GetComputerName (szComputerName, &dwLength);

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreeLineApp (pNewLineApp);

            break;
        }

        MakeWideString (szComputerName);

        dwAPIVersion = params[3].dwValue;

        DumpParams (&paramsHeader);

        lResult = MMCInitialize(
            (LPCWSTR)   params[0].dwValue,
            (LPHMMCAPP) params[1].dwValue,
            (LPDWORD)   params[2].dwValue,
            (HANDLE)    params[4].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            UpdateWidgetList();
            SelectWidget ((PMYWIDGET) pNewLineApp);
        }
        else
        {
            FreeLineApp (pNewLineApp);
        }

        break;
    }
    case mmcRemoveProvider:
    {
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD ,  (ULONG_PTR) 0, NULL },
            { szhwndOwner,      PT_DWORD,   (ULONG_PTR) ghwndMain, NULL },
            { szdwProviderID,   PT_DWORD,   (ULONG_PTR) 2, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) MMCRemoveProvider };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case mmcSetLineInfo:
    case mmcSetPhoneInfo:
    {
        char    szDomainUser0[MAX_STRING_PARAM_SIZE] = "",
                szDomainUser1[MAX_STRING_PARAM_SIZE] = "",
                szFriendlyUser0[MAX_STRING_PARAM_SIZE] = "",
                szFriendlyUser1[MAX_STRING_PARAM_SIZE] = "";
        DWORD   dwSize;
        LPDEVICEINFO        pInfo;
        LPDEVICEINFOLIST    pList = (LPDEVICEINFOLIST) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,            PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpInfoList",         PT_POINTER, (ULONG_PTR) pList, pList },
            { "  ->dwPermDevID",    PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->dwProviderID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "  ->DomainUser0",    PT_STRING,  (ULONG_PTR) szDomainUser0, szDomainUser0 },
            { "  ->DomainUser1",    PT_STRING,  (ULONG_PTR) szDomainUser1, szDomainUser1 },
            { "  ->FriendlyUser0",  PT_STRING,  (ULONG_PTR) szFriendlyUser0, szFriendlyUser0 },
            { "  ->FriendlyUser1",  PT_STRING,  (ULONG_PTR) szFriendlyUser1, szFriendlyUser1 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 8, funcIndex, params, NULL };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pList, 0, (size_t) dwBigBufSize);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        pList->dwTotalSize = sizeof (*pList) + sizeof (DEVICEINFO);

        pList->dwNumDeviceInfoEntries = 1;
        pList->dwDeviceInfoSize       = sizeof (DEVICEINFO);
        pList->dwDeviceInfoOffset     = sizeof (*pList);

        pInfo = (LPDEVICEINFO) (pList + 1);

        pInfo->dwPermanentDeviceID = params[2].dwValue;
        pInfo->dwProviderID        = params[3].dwValue;

        MakeWideString (szDomainUser0);
        MakeWideString (szDomainUser1);
        MakeWideString (szFriendlyUser0);
        MakeWideString (szFriendlyUser1);

        if (params[3].dwValue  &&
            (dwSize = wcslen ((WCHAR *) szDomainUser0)))
        {
            //
            //
            //

            wcscpy(
                (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                (WCHAR *)  szDomainUser0
                );

            dwSize++;
            dwSize *= sizeof (WCHAR);

            pInfo->dwDomainUserNamesSize   = dwSize;
            pInfo->dwDomainUserNamesOffset = pList->dwTotalSize;

            pList->dwTotalSize += dwSize;

            if (params[4].dwValue  &&
                (dwSize = wcslen ((WCHAR *) szDomainUser1)))
            {
                wcscpy(
                    (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                    (WCHAR *)  szDomainUser1
                    );

                dwSize++;
                dwSize *= sizeof (WCHAR);

                pInfo->dwDomainUserNamesSize += dwSize;

                pList->dwTotalSize += dwSize;
            }

            *((WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize)) =
                L'\0';

            pInfo->dwDomainUserNamesSize += sizeof (WCHAR);

            pList->dwTotalSize += sizeof (WCHAR);


            //
            //
            //

            dwSize = (wcslen ((WCHAR *) szFriendlyUser0) + 1) * sizeof (WCHAR);

            wcscpy(
                (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                (WCHAR *)  szFriendlyUser0
                );

            pInfo->dwFriendlyUserNamesSize   = dwSize;
            pInfo->dwFriendlyUserNamesOffset = pList->dwTotalSize;

            pList->dwTotalSize += dwSize;

            if (params[4].dwValue  &&
                (dwSize = wcslen ((WCHAR *) szFriendlyUser1)))
            {
                wcscpy(
                    (WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize),
                    (WCHAR *)  szFriendlyUser1
                    );

                dwSize++;
                dwSize *= sizeof (WCHAR);

                pInfo->dwFriendlyUserNamesSize += dwSize;

                pList->dwTotalSize += dwSize;
            }

            *((WCHAR *) (((LPBYTE) pList) + pList->dwTotalSize)) =
                L'\0';

            pInfo->dwFriendlyUserNamesSize += sizeof (WCHAR);

            pList->dwTotalSize += sizeof (WCHAR);
        }

        DumpParams (&paramsHeader);

        if (funcIndex == mmcSetLineInfo)
        {
            lResult = MMCSetLineInfo(
                (HMMCAPP)           params[0].dwValue,
                (LPDEVICEINFOLIST)  params[1].dwValue
                );
        }
        else
        {
            lResult = MMCSetPhoneInfo(
                (HMMCAPP)           params[0].dwValue,
                (LPDEVICEINFOLIST)  params[1].dwValue
                );
        }

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case mmcSetServerConfig:
    {
        char    szDomain[MAX_STRING_PARAM_SIZE] = "",
                szUser[MAX_STRING_PARAM_SIZE] = "",
                szPassword[MAX_STRING_PARAM_SIZE] = "",
                szAdmin0[MAX_STRING_PARAM_SIZE] = "",
                szAdmin1[MAX_STRING_PARAM_SIZE] = "";
        LPTAPISERVERCONFIG  pConfig = (LPTAPISERVERCONFIG) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhMmcApp,        PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpConfig",       PT_POINTER, (ULONG_PTR) pConfig, pConfig },
            { "  ->dwFlags",    PT_FLAGS,   (ULONG_PTR) 0, aServerConfigFlags },
            { "  ->DomainName", PT_STRING,  (ULONG_PTR) szDomain, szDomain },
            { "  ->UserName",   PT_STRING,  (ULONG_PTR) szUser, szUser },
            { "  ->Password",   PT_STRING,  (ULONG_PTR) szPassword, szPassword },
            { "  ->Admin0",     PT_STRING,  (ULONG_PTR) szAdmin0, szAdmin0 },
            { "  ->Admin1",     PT_STRING,  (ULONG_PTR) szAdmin1, szAdmin1 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 8, funcIndex, params, NULL };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        memset (pConfig, 0, (size_t) dwBigBufSize);

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        pConfig->dwTotalSize = sizeof (*pConfig);

        pConfig->dwFlags = params[2].dwValue;

        if (pConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETACCOUNT)
        {
            MakeWideString (szDomain);
            MakeWideString (szUser);
            MakeWideString (szPassword);

            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szDomain
                );

            pConfig->dwDomainNameOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwDomainNameSize =
                    (wcslen ((WCHAR *) szDomain) + 1) * sizeof (WCHAR));

            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szUser
                );

            pConfig->dwUserNameOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwUserNameSize =
                    (wcslen ((WCHAR *) szUser) + 1) * sizeof (WCHAR));

            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szPassword
                );

            pConfig->dwPasswordOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwPasswordSize =
                    (wcslen ((WCHAR *) szPassword) + 1) * sizeof (WCHAR));
        }

        MakeWideString (szAdmin0);
        MakeWideString (szAdmin1);

        if ((pConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS) &&
            params[6].dwValue  &&
            wcslen ((WCHAR *) szAdmin0))
        {
            wcscpy(
                (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                (WCHAR *) szAdmin0
                );

            pConfig->dwAdministratorsOffset = pConfig->dwTotalSize;

            pConfig->dwTotalSize +=
                (pConfig->dwAdministratorsSize =
                    (wcslen ((WCHAR *) szAdmin0) + 1) * sizeof (WCHAR));

            if (params[7].dwValue  &&  wcslen ((WCHAR *) szAdmin1))
            {
                DWORD   dwSize;

                wcscpy(
                    (WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize),
                    (WCHAR *) szAdmin1
                    );

                dwSize = (wcslen ((WCHAR *) szAdmin1) + 1) * sizeof (WCHAR);

                pConfig->dwAdministratorsSize += dwSize;

                pConfig->dwTotalSize += dwSize;
            }

            *((WCHAR *) (((LPBYTE) pConfig) + pConfig->dwTotalSize)) = L'\0';

            pConfig->dwAdministratorsSize += sizeof (WCHAR);

            pConfig->dwTotalSize += sizeof (WCHAR);
        }

        DumpParams (&paramsHeader);

        lResult = MMCSetServerConfig(
            (HMMCAPP)               params[0].dwValue,
            (LPTAPISERVERCONFIG)    params[1].dwValue
            );

        ShowLineFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case mmcShutdown:
    {
        FUNC_PARAM params[] =
        {
            { szhMmcApp,   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) MMCShutdown };


        CHK_LINEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pLineAppSel->hLineApp;

        lResult = DoFunc (&paramsHeader);

        if (lResult == 0)
        {
            ShowWidgetList (FALSE);
            FreeLineApp (GetLineApp((HLINEAPP) params[0].dwValue));
            ShowWidgetList (TRUE);
        }

        break;
    }

#endif // INTERNAL_3_0

    case pClose:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) phoneClose };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if ((lResult = DoFunc(&paramsHeader)) == 0)
        {
            FreePhone (GetPhone((HPHONE) params[0].dwValue));

            // Try to auto select the next valid hPhone in the list
        }

        break;
    }
    case pConfigDialog:
#if TAPI_2_0
    case pConfigDialogW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,       PT_DWORD, (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szhwndOwner,        PT_DWORD, (ULONG_PTR) ghwndMain, NULL },
            { szlpszDeviceClass,  PT_STRING,(ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pConfigDialog ?
                (PFN3) phoneConfigDialog : (PFN3) phoneConfigDialogW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneConfigDialog };
#endif

        CHK_PHONEAPP_SELECTED()

        strcpy (szDeviceClass, szDefPhoneDeviceClass);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = phoneConfigDialog(
            params[0].dwValue,
            (HWND) params[1].dwValue,
            (LPCSTR) params[2].dwValue
            );

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);
#endif
        break;
    }
    case pDevSpecific:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szlpParams,   PT_STRING,  (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneDevSpecific };


        CHK_PHONE_SELECTED()

        memset (pBigBuf, 0, (size_t) dwBigBufSize);

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        DoFunc (&paramsHeader);

        break;
    }
    case pGetButtonInfo:
#if TAPI_2_0
    case pGetButtonInfoW:
#endif
    {
        LPPHONEBUTTONINFO lpButtonInfo = (LPPHONEBUTTONINFO) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,           PT_DWORD,     (ULONG_PTR) 0, NULL },
            { "dwButtonLampID",   PT_DWORD,     (ULONG_PTR) 0, NULL },
            { "lpButtonInfo",     PT_POINTER,   (ULONG_PTR) lpButtonInfo, lpButtonInfo }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pGetButtonInfo ?
                (PFN3) phoneGetButtonInfo : (PFN3) phoneGetButtonInfoW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetButtonInfo };
#endif

        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);
        lpButtonInfo->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpButtonInfo);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwButtonMode",           FT_FLAGS,   lpButtonInfo->dwButtonMode, aButtonModes },
                    { "dwButtonFunction",       FT_ORD,     lpButtonInfo->dwButtonFunction, aButtonFunctions },
                    { "dwButtonTextSize",       FT_SIZE,    lpButtonInfo->dwButtonTextSize, NULL },
                    { "dwButtonTextOffset",     FT_OFFSET,  lpButtonInfo->dwButtonTextOffset, NULL },
                    { "dwDevSpecificSize",      FT_SIZE,    lpButtonInfo->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",    FT_OFFSET,  lpButtonInfo->dwDevSpecificOffset, NULL }
#if TAPI_1_1
                     ,
                    { "dwButtonState",          FT_FLAGS,   lpButtonInfo->dwButtonState, aButtonStates }
#endif


                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpButtonInfo,
                    "PHONEBUTTONINFO",
#if TAPI_1_1
                    7,
#else
                    6,
#endif
                    fields
                };

#if TAPI_1_1

                // BUGBUG only show v1.0 fields if APIver == 0x10003
                //        fieldHeader.dwNumFields--;
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case pGetData:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwDataID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpData",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) (dwBigBufSize > 64 ? 64 : dwBigBufSize), 0}
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneGetData };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowBytes(
                (dwBigBufSize > (DWORD) params[3].dwValue ?
                    (DWORD) params[3].dwValue : dwBigBufSize),
                pBigBuf,
                0
                );
        }

        break;
    }
    case pGetDevCaps:
#if TAPI_2_0
    case pGetDevCapsW:
#endif
    {
        LPPHONECAPS lpDevCaps = (LPPHONECAPS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,     PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szdwAPIVersion,   PT_ORDINAL, (ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
            { "dwExtVersion",   PT_DWORD,   (ULONG_PTR) dwDefPhoneExtVersion, NULL },
            { "lpPhoneDevCaps", PT_POINTER, (ULONG_PTR) lpDevCaps, lpDevCaps }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (funcIndex == pGetDevCaps ?
                (PFN5) phoneGetDevCaps : (PFN5) phoneGetDevCapsW ) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) phoneGetDevCaps };
#endif

        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        memset (lpDevCaps, 0, (size_t) dwBigBufSize);
        lpDevCaps->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDevCaps);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwProviderInfoSize",         FT_SIZE,    lpDevCaps->dwProviderInfoSize, NULL },
                    { "dwProviderInfoOffset",       FT_OFFSET,  lpDevCaps->dwProviderInfoOffset, NULL },
                    { "dwPhoneInfoSize",            FT_SIZE,    lpDevCaps->dwPhoneInfoSize, NULL },
                    { "dwPhoneInfoOffset",          FT_OFFSET,  lpDevCaps->dwPhoneInfoOffset, NULL },
                    { "dwPermanentPhoneID",         FT_DWORD,   lpDevCaps->dwPermanentPhoneID, NULL },
                    { "dwPhoneNameSize",            FT_SIZE,    lpDevCaps->dwPhoneNameSize, NULL },
                    { "dwPhoneNameOffset",          FT_OFFSET,  lpDevCaps->dwPhoneNameOffset, NULL },
                    { "dwStringFormat",             FT_ORD,     lpDevCaps->dwStringFormat, aStringFormats },
                    { "dwPhoneStates",              FT_FLAGS,   lpDevCaps->dwPhoneStates, aPhoneStates },
                    { "dwHookSwitchDevs",           FT_FLAGS,   lpDevCaps->dwHookSwitchDevs, aHookSwitchDevs },
                    { "dwHandsetHookSwitchModes",   FT_FLAGS,   lpDevCaps->dwHandsetHookSwitchModes, aHookSwitchModes },
                    { "dwSpeakerHookSwitchModes",   FT_FLAGS,   lpDevCaps->dwSpeakerHookSwitchModes, aHookSwitchModes },
                    { "dwHeadsetHookSwitchModes",   FT_FLAGS,   lpDevCaps->dwHeadsetHookSwitchModes, aHookSwitchModes },
                    { "dwVolumeFlags",              FT_FLAGS,   lpDevCaps->dwVolumeFlags, aHookSwitchDevs },
                    { "dwGainFlags",                FT_FLAGS,   lpDevCaps->dwGainFlags, aHookSwitchDevs },
                    { "dwDisplayNumRows",           FT_DWORD,   lpDevCaps->dwDisplayNumRows, NULL },
                    { "dwDisplayNumColumns",        FT_DWORD,   lpDevCaps->dwDisplayNumColumns, NULL },
                    { "dwNumRingModes",             FT_DWORD,   lpDevCaps->dwNumRingModes, NULL },
                    { "dwNumButtonLamps",           FT_DWORD,   lpDevCaps->dwNumButtonLamps, NULL },
                    { "dwButtonModesSize",          FT_SIZE,    lpDevCaps->dwButtonModesSize, NULL },
                    { "dwButtonModesOffset",        FT_OFFSET,  lpDevCaps->dwButtonModesOffset, NULL },
                    { "dwButtonFunctionsSize",      FT_SIZE,    lpDevCaps->dwButtonFunctionsSize, NULL },
                    { "dwButtonFunctionsOffset",    FT_OFFSET,  lpDevCaps->dwButtonFunctionsOffset, NULL },
                    { "dwLampModesSize",            FT_SIZE,    lpDevCaps->dwLampModesSize, NULL },
                    { "dwLampModesOffset",          FT_OFFSET,  lpDevCaps->dwLampModesOffset, NULL },
                    { "dwNumSetData",               FT_DWORD,   lpDevCaps->dwNumSetData, NULL },
                    { "dwSetDataSize",              FT_SIZE,    lpDevCaps->dwSetDataSize, NULL },
                    { "dwSetDataOffset",            FT_OFFSET,  lpDevCaps->dwSetDataOffset, NULL },
                    { "dwNumGetData",               FT_DWORD,   lpDevCaps->dwNumGetData, NULL },
                    { "dwGetDataSize",              FT_SIZE,    lpDevCaps->dwGetDataSize, NULL },
                    { "dwGetDataOffset",            FT_OFFSET,  lpDevCaps->dwGetDataOffset, NULL },
                    { "dwDevSpecificSize",          FT_SIZE,    lpDevCaps->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",        FT_OFFSET,  lpDevCaps->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwDeviceClassesSize",        FT_SIZE,    0, NULL },
                    { "dwDeviceClassesOffset",      FT_OFFSET,  0, NULL },
                    { "dwPhoneFeatures",            FT_FLAGS,   0, aPhoneFeatures },
                    { "dwSettableHandsetHookSwitchModes",   FT_FLAGS,   0, aHookSwitchModes },
                    { "dwSettableSpeakerHookSwitchModes",   FT_FLAGS,   0, aHookSwitchModes },
                    { "dwSettableHeadsetHookSwitchModes",   FT_FLAGS,   0, aHookSwitchModes },
                    { "dwMonitoredHandsetHookSwitchModes",  FT_FLAGS,   0, aHookSwitchModes },
                    { "dwMonitoredSpeakerHookSwitchModes",  FT_FLAGS,   0, aHookSwitchModes },
                    { "dwMonitoredHeadsetHookSwitchModes",  FT_FLAGS,   0, aHookSwitchModes }
#if TAPI_2_2
                     ,
                    { "PermanentPhoneGuid(Size)",   FT_SIZE,    sizeof (lpDevCaps->PermanentPhoneGuid), NULL },
                    { "PermanentPhoneGuid(Offset)", FT_OFFSET,  ((LPBYTE) &lpDevCaps->PermanentPhoneGuid) - ((LPBYTE) lpDevCaps), NULL }
#endif
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpDevCaps, "PHONECAPS", 0, fields
                };


                if (params[2].dwValue < 0x00020000)
                {
                    fieldHeader.dwNumFields = 33;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 42;

                    fields[33].dwValue = lpDevCaps->dwDeviceClassesSize;
                    fields[34].dwValue = lpDevCaps->dwDeviceClassesOffset;
                    fields[35].dwValue = lpDevCaps->dwPhoneFeatures;
                    fields[36].dwValue = lpDevCaps->dwSettableHandsetHookSwitchModes;
                    fields[37].dwValue = lpDevCaps->dwSettableSpeakerHookSwitchModes;
                    fields[38].dwValue = lpDevCaps->dwSettableHeadsetHookSwitchModes;
                    fields[39].dwValue = lpDevCaps->dwMonitoredHandsetHookSwitchModes;
                    fields[40].dwValue = lpDevCaps->dwMonitoredSpeakerHookSwitchModes;
                    fields[41].dwValue = lpDevCaps->dwMonitoredHeadsetHookSwitchModes;
#if TAPI_2_2
                    if (params[2].dwValue >= 0x20002)
                    {
                        fieldHeader.dwNumFields += 2;
                    }
#endif
                }
#endif

                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case pGetDisplay:
    {
        LPVARSTRING lpDisplay = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpDisplay",  PT_POINTER, (ULONG_PTR) lpDisplay, lpDisplay }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) phoneGetDisplay };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);
        lpDisplay->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpDisplay);

            ShowVARSTRING (lpDisplay);
        }

        break;
    }
    case pGetGain:
    {
        DWORD dwGain;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, (ULONG_PTR) PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "lpdwGain",           PT_POINTER, (ULONG_PTR) &dwGain, &dwGain }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetGain };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwGain=x%lx", szTab, dwGain);
        }

        break;
    }
    case pGetHookSwitch:
    {
        DWORD dwHookSwitchDevs;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwHookSwitchDevs", PT_POINTER, (ULONG_PTR) &dwHookSwitchDevs, &dwHookSwitchDevs },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) phoneGetHookSwitch };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            char szDevsOnHook[32] = "";
            char szDevsOffHook[32] = "";

            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HANDSET)
            {
                strcat (szDevsOffHook, "HANDSET ");
            }
            else
            {
                strcat (szDevsOnHook, "HANDSET ");
            }

            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER)
            {
                strcat (szDevsOffHook, "SPEAKER ");
            }
            else
            {
                strcat (szDevsOnHook, "SPEAKER ");
            }

            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HEADSET)
            {
                strcat (szDevsOffHook, "HEADSET");
            }
            else
            {
                strcat (szDevsOnHook, "HEADSET");
            }

            ShowStr ("%sOn hook : %s", szTab, szDevsOnHook);
            ShowStr ("%sOff hook: %s", szTab, szDevsOffHook);
        }

        break;
    }
    case pGetIcon:
#if TAPI_2_0
    case pGetIconW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        HICON hIcon;
        FUNC_PARAM params[] =
        {
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lphIcon",            PT_POINTER, (ULONG_PTR) &hIcon, &hIcon }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pGetIcon ?
                (PFN3) phoneGetIcon : (PFN3) phoneGetIconW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetIcon };
#endif

        strcpy (szDeviceClass, szDefPhoneDeviceClass);

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            DialogBoxParam (
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG5),
                (HWND) ghwndMain,
                IconDlgProc,
                (LPARAM) hIcon
                );
        }

        break;
    }
    case pGetID:
#if TAPI_2_0
    case pGetIDW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        LPVARSTRING lpDevID = (LPVARSTRING) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpDeviceID",         PT_POINTER, (ULONG_PTR) lpDevID, lpDevID },
            { szlpszDeviceClass,    PT_STRING,  (ULONG_PTR) szDeviceClass, szDeviceClass }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (funcIndex == pGetID ?
                (PFN3) phoneGetID : (PFN3) phoneGetIDW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetID };
#endif

        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (lpDevID, 0, (size_t) dwBigBufSize);
        lpDevID->dwTotalSize = dwBigBufSize;

        strcpy (szDeviceClass, szDefPhoneDeviceClass);

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStructByDWORDs (lpDevID);

            ShowVARSTRING (lpDevID);
        }

        break;
    }
    case pGetLamp:
    {
        DWORD dwLampMode;
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwButtonLampID", PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwLampMode",   PT_POINTER, (ULONG_PTR) &dwLampMode, &dwLampMode }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetLamp };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            for (i = 0; aLampModes[i].dwVal != 0xffffffff; i++)
            {
                if (dwLampMode == aLampModes[i].dwVal)
                {
                    ShowStr ("%slamp mode = %s", szTab, aLampModes[i].lpszVal);
                    break;
                }
            }

            if (aLampModes[i].dwVal == 0xffffffff)
            {
                ShowStr ("%sdwLampMode=%xlx (invalid)", szTab, dwLampMode);
            }
        }

        break;
    }
#if TAPI_2_0
    case pGetMessage:
    {
        PHONEMESSAGE msg;
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,  PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpMessage",  PT_POINTER, (ULONG_PTR) &msg, &msg },
            { "dwTimeout",  PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        // Max timeout of 2 seconds (don't want to hang app & excite user)

        params[2].dwValue = (params[2].dwValue > 2000 ?
            2000 : params[2].dwValue);

        DumpParams (&paramsHeader);

        lResult = phoneGetMessage(
            (HPHONEAPP)      params[0].dwValue,
            (LPPHONEMESSAGE) params[1].dwValue,
            (DWORD)          params[2].dwValue
            );

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            tapiCallback(
                msg.hDevice,
                msg.dwMessageID,
                msg.dwCallbackInstance,
                msg.dwParam1,
                msg.dwParam2,
                msg.dwParam3
                );
        }

        break;
    }
#endif
    case pGetRing:
    {
        DWORD dwRingMode, dwVolume;
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwRingMode",   PT_POINTER, (ULONG_PTR) &dwRingMode, &dwRingMode },
            { "lpdwVolume",     PT_POINTER, (ULONG_PTR) &dwVolume, &dwVolume }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetRing };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr(
                "%sdwRingMode=x%lx, dwVolume=x%lx",
                szTab,
                dwRingMode,
                dwVolume
                );
        }

        break;
    }
    case pGetStatus:
#if TAPI_2_0
    case pGetStatusW:
#endif
    {
        LPPHONESTATUS lpPhoneStatus = (LPPHONESTATUS) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpPhoneStatus",  PT_POINTER, (ULONG_PTR) lpPhoneStatus, lpPhoneStatus }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == pGetStatus ?
                (PFN2) phoneGetStatus : (PFN2) phoneGetStatusW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) phoneGetStatus };
#endif
        DWORD   dwAPIVersion;


        CHK_PHONE_SELECTED()

        dwAPIVersion = pPhoneSel->dwAPIVersion;

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        memset (pBigBuf, 0, (size_t) dwBigBufSize);
        lpPhoneStatus->dwTotalSize = dwBigBufSize;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStructByDWORDs (lpPhoneStatus);

            if (dwDumpStructsFlags & DS_NONZEROFIELDS)
            {
                STRUCT_FIELD fields[] =
                {
                    { "dwStatusFlags",              FT_FLAGS,   lpPhoneStatus->dwStatusFlags, aPhoneStatusFlags },
                    { "dwNumOwners",                FT_DWORD,   lpPhoneStatus->dwNumOwners, NULL },
                    { "dwNumMonitors",              FT_DWORD,   lpPhoneStatus->dwNumMonitors, NULL },
                    { "dwRingMode",                 FT_DWORD,   lpPhoneStatus->dwRingMode, NULL },
                    { "dwRingVolume",               FT_DWORD,   lpPhoneStatus->dwRingVolume, NULL },
                    { "dwHandsetHookSwitchMode",    FT_FLAGS,   lpPhoneStatus->dwHandsetHookSwitchMode, aHookSwitchModes },
                    { "dwHandsetVolume",            FT_DWORD,   lpPhoneStatus->dwHandsetVolume, NULL },
                    { "dwHandsetGain",              FT_DWORD,   lpPhoneStatus->dwHandsetGain, NULL },
                    { "dwSpeakerHookSwitchMode",    FT_FLAGS,   lpPhoneStatus->dwSpeakerHookSwitchMode, aHookSwitchModes },
                    { "dwSpeakerVolume",            FT_DWORD,   lpPhoneStatus->dwSpeakerVolume, NULL },
                    { "dwSpeakerGain",              FT_DWORD,   lpPhoneStatus->dwSpeakerGain, NULL },
                    { "dwHeadsetHookSwitchMode",    FT_FLAGS,   lpPhoneStatus->dwHeadsetHookSwitchMode, aHookSwitchModes },
                    { "dwHeadsetVolume",            FT_DWORD,   lpPhoneStatus->dwHeadsetVolume, NULL },
                    { "dwHeadsetGain",              FT_DWORD,   lpPhoneStatus->dwHeadsetGain, NULL },
                    { "dwDisplaySize",              FT_SIZE,    lpPhoneStatus->dwDisplaySize, NULL },
                    { "dwDisplayOffset",            FT_OFFSET,  lpPhoneStatus->dwDisplayOffset, NULL },
                    { "dwLampModesSize",            FT_SIZE,    lpPhoneStatus->dwLampModesSize, NULL },
                    { "dwLampModesOffset",          FT_OFFSET,  lpPhoneStatus->dwLampModesOffset, NULL },
                    { "dwOwnerNameSize",            FT_SIZE,    lpPhoneStatus->dwOwnerNameSize, NULL },
                    { "dwOwnerNameOffset",          FT_OFFSET,  lpPhoneStatus->dwOwnerNameOffset, NULL },
                    { "dwDevSpecificSize",          FT_SIZE,    lpPhoneStatus->dwDevSpecificSize, NULL },
                    { "dwDevSpecificOffset",        FT_OFFSET,  lpPhoneStatus->dwDevSpecificOffset, NULL }
#if TAPI_2_0
                     ,
                    { "dwPhoneFeatures",            FT_FLAGS,   0, aPhoneFeatures }
#endif
                };
                STRUCT_FIELD_HEADER fieldHeader =
                {
                    lpPhoneStatus, "PHONESTATUS", 0, fields
                };


                if (dwAPIVersion < 0x00020000)
                {
                    fieldHeader.dwNumFields = 22;
                }
#if TAPI_2_0
                else
                {
                    fieldHeader.dwNumFields = 23;

                    fields[22].dwValue = lpPhoneStatus->dwPhoneFeatures;
                }
#endif
                ShowStructByField (&fieldHeader, FALSE);
            }
        }

        break;
    }
    case pGetStatusMessages:
    {
        DWORD aFlags[3];
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpdwPhoneStates",    PT_POINTER, (ULONG_PTR) &aFlags[0], &aFlags[0] },
            { "lpdwButtonModes",    PT_POINTER, (ULONG_PTR) &aFlags[1], &aFlags[1] },
            { "lpdwButtonStates",   PT_POINTER, (ULONG_PTR) &aFlags[2], &aFlags[2] }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneGetStatusMessages };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            STRUCT_FIELD fields[] =
            {
                { "dwPhoneStates",  FT_FLAGS,   aFlags[0], aPhoneStates },
                { "dwButtonModes",  FT_FLAGS,   aFlags[1], aButtonModes },
                { "dwButtonStates", FT_FLAGS,   aFlags[2], aButtonStates }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                aFlags,
                "",
                3,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);
        }

        break;
    }
    case pGetVolume:
    {
        DWORD dwVolume;
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, (ULONG_PTR) PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "lpdwVolume",         PT_POINTER, (ULONG_PTR) &dwVolume, &dwVolume }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneGetVolume };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwVolume=x%lx", szTab, dwVolume);
        }

        break;
    }
    case pInitialize:
    {
        DWORD dwNumDevs;
        PMYPHONEAPP pNewPhoneApp;
        char szAppName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "lphPhoneApp",    PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszAppName,    PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumDevs, &dwNumDevs }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) phoneInitialize };


        if (!(pNewPhoneApp = AllocPhoneApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewPhoneApp->hPhoneApp;

        strcpy (szAppName, szDefAppName);

#ifdef WIN32
        lResult = DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HINSTANCEs are 16 bits, so we've to hard code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreePhoneApp (pNewPhoneApp);
            break;
        }

        DumpParams (&paramsHeader);

        lResult = phoneInitialize(
            (LPHPHONEAPP)   params[0].dwValue,
            (HINSTANCE)     params[1].dwValue,
            (PHONECALLBACK) params[2].dwValue,
            (LPCSTR)        params[3].dwValue,
            (LPDWORD)       params[4].dwValue
            );

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);
#endif // WIN32
        if (lResult == 0)
        {
            ShowStr ("%snum phone devs=%ld", szTab, dwNumDevs);
            UpdateWidgetList();
            gdwNumPhoneDevs = dwNumDevs;
            SelectWidget ((PMYWIDGET) pNewPhoneApp);
        }
        else
        {
            FreePhoneApp (pNewPhoneApp);
        }

        break;
    }
#if TAPI_2_0
    case pInitializeEx:
    case pInitializeExW:
    {
        char                    szAppName[MAX_STRING_PARAM_SIZE];
        DWORD                   dwNumDevs, dwAPIVersion;
        PMYPHONEAPP             pNewPhoneApp;
        PHONEINITIALIZEEXPARAMS initExParams;
        FUNC_PARAM params[] =
        {
            { "lphPhoneApp",    PT_POINTER, (ULONG_PTR) 0, NULL },
            { "hInstance",      PT_DWORD,   (ULONG_PTR) ghInst, NULL },
            { "lpfnCallback",   PT_POINTER, (ULONG_PTR) tapiCallback, tapiCallback },
            { szlpszFriendlyAppName,PT_STRING,  (ULONG_PTR) szAppName, szAppName },
            { "lpdwNumDevs",    PT_POINTER, (ULONG_PTR) &dwNumDevs, &dwNumDevs },
            { "lpdwAPIVersion", PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "  ->dwAPIVersion",PT_ORDINAL,(ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
            { "lpInitExParams", PT_POINTER, (ULONG_PTR) &initExParams, &initExParams },
            { "  ->dwOptions",  PT_ORDINAL, (ULONG_PTR) PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT, aPhoneInitExOptions }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 9, funcIndex, params, NULL };


        if (!(pNewPhoneApp = AllocPhoneApp()))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue =
        params[0].u.dwDefValue = (ULONG_PTR) &pNewPhoneApp->hPhoneApp;

        strcpy (szAppName, szDefAppName);

        if (!LetUserMungeParams (&paramsHeader))
        {
            FreePhoneApp (pNewPhoneApp);

            break;
        }

        initExParams.dwTotalSize = sizeof (PHONEINITIALIZEEXPARAMS);
        initExParams.dwOptions = (DWORD) params[8].dwValue;
        initExParams.Handles.hCompletionPort = ghCompletionPort;

        dwAPIVersion = (DWORD) params[6].dwValue;

        DumpParams (&paramsHeader);

        if (funcIndex == pInitializeEx)
        {
            lResult = phoneInitializeEx(
                (LPHPHONEAPP)               params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (PHONECALLBACK)             params[2].dwValue,
                (LPCSTR)                    params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPPHONEINITIALIZEEXPARAMS) params[7].dwValue
                );
        }
        else
        {
            MakeWideString ((LPVOID) params[3].dwValue);

            lResult = phoneInitializeExW(
                (LPHPHONEAPP)               params[0].dwValue,
                (HINSTANCE)                 params[1].dwValue,
                (PHONECALLBACK)             params[2].dwValue,
                (LPCWSTR)                   params[3].dwValue,
                (LPDWORD)                   params[4].dwValue,
                (LPDWORD)                   params[5].dwValue,
                (LPPHONEINITIALIZEEXPARAMS) params[7].dwValue
                );
        }

        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);

        if (lResult == 0)
        {
            ShowStr ("%snum phone devs = %ld", szTab, dwNumDevs);

            if (params[7].dwValue != 0  &&
                (initExParams.dwOptions & 3) ==
                    PHONEINITIALIZEEXOPTION_USEEVENT)
            {
                ShowStr(
                    "hPhoneApp x%x was created with the\r\n" \
                        "USEEVENT option, so you must use\r\n" \
                        "phoneGetMessage to retrieve messages.",
                    pNewPhoneApp->hPhoneApp
                    );
            }


            //SendMessage (ghwndLineApps, LB_SETCURSEL, (WPARAM) i, 0);
            UpdateWidgetList();
            gdwNumPhoneDevs = dwNumDevs;
            SelectWidget ((PMYWIDGET) pNewPhoneApp);
        }
        else
        {
            FreePhoneApp (pNewPhoneApp);
        }

        break;
    }
#endif
    case pOpen:
    {
        PMYPHONE pNewPhone;
        FUNC_PARAM params[] =
        {
            { "hPhoneApp",          PT_DWORD,   0, NULL },
            { szdwDeviceID,         PT_DWORD,   dwDefPhoneDeviceID, NULL },
            { "lphPhone",           PT_POINTER, 0, NULL },
            { szdwAPIVersion,       PT_ORDINAL, dwDefPhoneAPIVersion, aAPIVersions },
            { "dwExtVersion",       PT_DWORD,   dwDefPhoneExtVersion, NULL },
            { "dwCallbackInstance", PT_DWORD,   0, NULL },
            { "dwPrivilege",        PT_ORDINAL, dwDefPhonePrivilege, aPhonePrivileges }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, (PFN7) phoneOpen };


        CHK_PHONEAPP_SELECTED()

        if (!(pNewPhone = AllocPhone(pPhoneAppSel)))
        {
            ErrorAlert();
            ShowStr ("error creating data structure");
            break;
        }

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;
        params[2].dwValue =
        params[2].u.dwDefValue = (ULONG_PTR) &pNewPhone->hPhone;

        if ((lResult = DoFunc(&paramsHeader)) == 0)
        {
            if ((HPHONEAPP) params[0].dwValue != pPhoneAppSel->hPhoneApp)
            {
                //
                // User has switched phone apps on us we need to recreate
                // the phone data structure under a different phone app
                //

                PMYPHONE pNewPhone2 =
                    AllocPhone (GetPhoneApp((HPHONEAPP)params[0].dwValue));

                if (pNewPhone2)
                {
                    pNewPhone2->hPhone = pNewPhone->hPhone;

                    FreePhone (pNewPhone);

                    pNewPhone = pNewPhone2;
                }
                else
                {
                    // BUGBUG show error: couldn't alloc a new phone struct

                    phoneClose (pNewPhone->hPhone);
                    FreePhone (pNewPhone);
                    break;
                }
            }


            //
            // Save info about this phone that we can display later
            //

            pNewPhone->hPhoneApp    = (HPHONEAPP) params[0].dwValue;
            pNewPhone->dwDevID      = (DWORD) params[1].dwValue;
            pNewPhone->dwAPIVersion = (DWORD) params[3].dwValue;
            pNewPhone->dwPrivilege  = (DWORD) params[6].dwValue;

            UpdateWidgetList();
            SelectWidget ((PMYWIDGET) pNewPhone);
        }
        else
        {
            FreePhone (pNewPhone);
        }

        break;
    }
    case pNegotiateAPIVersion:
    {
        DWORD dwAPIVersion;
        PHONEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { "hPhoneApp",          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { "dwAPILowVersion",    PT_DWORD,   (ULONG_PTR) 0x00010000, aAPIVersions },
            { "dwAPIHighVersion",   PT_DWORD,   (ULONG_PTR) 0x10000000, aAPIVersions },
            { "lpdwAPIVersion",     PT_POINTER, (ULONG_PTR) &dwAPIVersion, &dwAPIVersion },
            { "lpExtensionID",      PT_POINTER, (ULONG_PTR) &extID, &extID }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) phoneNegotiateAPIVersion };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if ((lResult = DoFunc (&paramsHeader)) == 0)
        {
            ShowStr ("%s%s=x%lx", szTab, szdwAPIVersion, dwAPIVersion);
            ShowStr(
                "%sextID.ID0=x%lx, .ID1=x%lx, .ID2=x%lx, .ID3=x%lx, ",
                szTab,
                extID.dwExtensionID0,
                extID.dwExtensionID1,
                extID.dwExtensionID2,
                extID.dwExtensionID3
                );
        }

        break;
    }
    case pNegotiateExtVersion:
    {
        DWORD dwExtVersion;
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { szdwDeviceID,         PT_DWORD,   (ULONG_PTR) dwDefPhoneDeviceID, NULL },
            { szdwAPIVersion,       PT_ORDINAL, (ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
            { "dwExtLowVersion",    PT_DWORD,   (ULONG_PTR) 0x00000000, NULL },
            { "dwExtHighVersion",   PT_DWORD,   (ULONG_PTR) 0x80000000, NULL },
            { "lpdwExtVersion",     PT_POINTER, (ULONG_PTR) &dwExtVersion, &dwExtVersion }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, (PFN6) phoneNegotiateExtVersion };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowStr ("%sdwExtVersion=x%lx", szTab, dwExtVersion);
        }

        break;
    }
    case pSetButtonInfo:
#if TAPI_2_0
    case pSetButtonInfoW:
#endif
    {
        char szButtonText[MAX_STRING_PARAM_SIZE] = "button text";
        char szDevSpecific[MAX_STRING_PARAM_SIZE] = "dev specific info";
        LPPHONEBUTTONINFO lpButtonInfo = (LPPHONEBUTTONINFO) pBigBuf;
        FUNC_PARAM params[] =
        {
            { szhPhone,                 PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwButtonLampID",         PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpData",                 PT_POINTER, (ULONG_PTR) lpButtonInfo, lpButtonInfo },
            { "  ->dwButtonMode",       PT_FLAGS,   (ULONG_PTR) PHONEBUTTONMODE_CALL,  aButtonModes },
            { "  ->dwButtonFunction",   PT_DWORD,   (ULONG_PTR) 0, NULL },
//            { "  ->dwButtonFunction",  PT_???,   , aButtonFunctions },
            { "  ->ButtonText",         PT_STRING,  (ULONG_PTR) szButtonText,  szButtonText },
            { "  ->DevSpecific",        PT_STRING,  (ULONG_PTR) szDevSpecific, szDevSpecific },
#if TAPI_1_1
            { "  ->dwButtonState",      PT_FLAGS,   (ULONG_PTR) 0,  aButtonStates }
#endif
        };
        FUNC_PARAM_HEADER paramsHeader =
#if TAPI_1_1
            { 8, funcIndex, params, NULL };
#else
            { 7, funcIndex, params, NULL };
#endif
        DWORD dwFixedStructSize = sizeof(PHONEBUTTONINFO), dwLength;


        // BUGBUG need a PT_ type to specify constants (ords?) for ->dwButtonFunction

        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;


        //
        // Note: the dwButtonState field in PHONEBUTTONINFO is only valid
        // in 1.4+.  It'll be ignored for phones opened w/ ver 1.3.
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        memset (lpButtonInfo, 0, (size_t) dwBigBufSize);

        if (dwBigBufSize >= 4)
        {
            lpButtonInfo->dwTotalSize = dwBigBufSize;

            if (dwBigBufSize >= 0x24) // sizeof(PHONEBUTTONINFO) in ver 0x10003
            {
                lpButtonInfo->dwButtonMode     = (DWORD) params[3].dwValue;
                lpButtonInfo->dwButtonFunction = (DWORD) params[4].dwValue;

                if ((params[5].dwValue == (ULONG_PTR) szButtonText) &&
                    (dwLength = (DWORD) strlen (szButtonText)) &&
                    (dwBigBufSize >= (dwFixedStructSize + dwLength + 1)))
                {
                    lpButtonInfo->dwButtonTextSize   = dwLength + 1;
                    lpButtonInfo->dwButtonTextOffset = dwFixedStructSize;
#if TAPI_2_0
                    if (gbWideStringParams)
                    {
                        lpButtonInfo->dwButtonTextSize *= sizeof (WCHAR);

                        MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            (LPCSTR) szButtonText,
                            -1,
                            (LPWSTR) (((char far *) lpButtonInfo) +
                                dwFixedStructSize),
                            MAX_STRING_PARAM_SIZE / 2
                            );
                    }
                    else
                    {
                        strcpy(
                            ((char far *) lpButtonInfo) + dwFixedStructSize,
                            szButtonText
                            );
                    }
#else
                    strcpy(
                        ((char far *) lpButtonInfo) + dwFixedStructSize,
                        szButtonText
                        );
#endif
                }

                if ((params[6].dwValue == (ULONG_PTR) szDevSpecific) &&
                    (dwLength = (DWORD) strlen (szDevSpecific)) &&
                    (dwBigBufSize >= (dwFixedStructSize + dwLength + 1 +
                        lpButtonInfo->dwButtonTextSize)))
                {
                    lpButtonInfo->dwDevSpecificSize   = dwLength + 1;
                    lpButtonInfo->dwDevSpecificOffset = dwFixedStructSize +
                        lpButtonInfo->dwButtonTextSize;
#if TAPI_2_0
                    if (gbWideStringParams)
                    {
                        lpButtonInfo->dwDevSpecificSize *= sizeof (WCHAR);

                        MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            (LPCSTR) szDevSpecific,
                            -1,
                            (LPWSTR) (((char far *) lpButtonInfo) +
                                lpButtonInfo->dwDevSpecificOffset),
                            MAX_STRING_PARAM_SIZE / 2
                            );
                    }
                    else
                    {
                        strcpy(
                            ((char far *) lpButtonInfo) +
                                lpButtonInfo->dwDevSpecificOffset,
                            szDevSpecific
                            );
                    }
#else
                    strcpy(
                        ((char far *) lpButtonInfo) +
                            lpButtonInfo->dwDevSpecificOffset,
                        szDevSpecific
                        );
#endif
                }
#if TAPI_1_1
                if (dwBigBufSize >= dwFixedStructSize)
                {
                    lpButtonInfo->dwButtonState = (DWORD) params[7].dwValue;
                }
#endif
            }
        }

#if TAPI_2_0
        if (funcIndex == pSetButtonInfo)
        {
            lResult = phoneSetButtonInfo(
                (HPHONE) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPPHONEBUTTONINFO) params[2].dwValue
                );
        }
        else
        {
            lResult = phoneSetButtonInfoW(
                (HPHONE) params[0].dwValue,
                (DWORD) params[1].dwValue,
                (LPPHONEBUTTONINFO) params[2].dwValue
                );
        }
#else
        lResult = phoneSetButtonInfo(
            (HPHONE) params[0].dwValue,
            params[1].dwValue,
            (LPPHONEBUTTONINFO) params[2].dwValue
            );
#endif
        ShowPhoneFuncResult (aFuncNames[funcIndex], lResult);

        break;
    }
    case pSetData:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwDataID",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpData",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneSetData };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        DoFunc (&paramsHeader);

        break;
    }
    case pSetDisplay:
    {
        char szDisplay[MAX_STRING_PARAM_SIZE] = "123";
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwRow",      PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "dwColumn",   PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "lpsDisplay", PT_STRING,  (ULONG_PTR) szDisplay, szDisplay },
            { szdwSize,     PT_DWORD,   (ULONG_PTR) 3, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, (PFN5) phoneSetDisplay };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetGain:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "dwGain",             PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetGain };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetHookSwitch:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   0, NULL },
            { "dwHookSwitchDevs",   PT_FLAGS,   PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "dwHookSwitchMode",   PT_ORDINAL, PHONEHOOKSWITCHMODE_ONHOOK, aHookSwitchModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetHookSwitch };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetLamp:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD,   0, NULL },
            { "dwButtonLampID", PT_DWORD,   0, NULL },
            { "dwLampMode",     PT_ORDINAL, PHONELAMPMODE_OFF, aLampModes }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetLamp };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetRing:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,     PT_DWORD, 0, NULL },
            { "dwRingMode", PT_DWORD, 0, NULL },
            { "dwVolume",   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetRing };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetStatusMessages:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,         PT_DWORD, 0, NULL },
            { "dwPhoneStates",  PT_FLAGS, 0, aPhoneStates },
            { "dwButtonModes",  PT_FLAGS, 0, aButtonModes },
            { "dwButtonStates", PT_FLAGS, 0, aButtonStates }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) phoneSetStatusMessages };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pSetVolume:
    {
        FUNC_PARAM params[] =
        {
            { szhPhone,             PT_DWORD,   0, NULL },
            { "dwHookSwitchDev",    PT_ORDINAL, PHONEHOOKSWITCHDEV_HANDSET, aHookSwitchDevs },
            { "dwVolume",           PT_DWORD,   0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, (PFN3) phoneSetVolume };


        CHK_PHONE_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneSel->hPhone;

        lResult = DoFunc (&paramsHeader);

        break;
    }
    case pShutdown:
    {
        FUNC_PARAM params[] =
        {
            { szhPhoneApp,   PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, (PFN1) phoneShutdown };


        CHK_PHONEAPP_SELECTED()

        params[0].dwValue = (ULONG_PTR) pPhoneAppSel->hPhoneApp;

        if (DoFunc (&paramsHeader) == 0)
        {
            ShowWidgetList (FALSE);
            FreePhoneApp (GetPhoneApp((HPHONEAPP) params[0].dwValue));
            ShowWidgetList (TRUE);
        }

        break;
    }
    case tGetLocationInfo:
#if TAPI_2_0
    case tGetLocationInfoW:
#endif
    {
        char szCountryCode[MAX_STRING_PARAM_SIZE] = "";
        char szCityCode[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { "lpszCountryCode",    PT_POINTER, (ULONG_PTR) szCountryCode, szCountryCode },
            { "lpszCityCode",       PT_POINTER, (ULONG_PTR) szCityCode, szCityCode }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (funcIndex == tGetLocationInfo ?
                (PFN2) tapiGetLocationInfo : (PFN2) tapiGetLocationInfoW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) tapiGetLocationInfo };
#endif

        if (DoFunc (&paramsHeader) == 0)
        {
#if TAPI_2_0
            ShowStr(
                (gbWideStringParams ? "%s*lpszCountryCode='%ws'" :
                    "%s*lpszCountryCode='%s'"),
                szTab,
                szCountryCode
                );

            ShowStr(
                (gbWideStringParams ? "%s*lpszCityCode='%ws'" :
                    "%s*lpszCityCode='%s'"),
                szTab,
                szCityCode
                );
#else
            ShowStr ("%s*lpszCountryCode='%s'", szTab, szCountryCode);
            ShowStr ("%s*lpszCityCode='%s'", szTab, szCityCode);
#endif
        }

        break;
    }
    case tRequestDrop:
    {
        FUNC_PARAM params[] =
        {
            { "hWnd",       PT_DWORD,   (ULONG_PTR) ghwndMain, 0 },
            { "wRequestID", PT_DWORD,   (ULONG_PTR) 0, 0 }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, (PFN2) tapiRequestDrop };

#ifdef WIN32
        DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs & WPARAMs are 16 bits, so we've to hard
        //       code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = tapiRequestDrop(
            (HWND) params[0].dwValue,
            (WPARAM) params[1].dwValue
            );

        ShowTapiFuncResult (aFuncNames[funcIndex], lResult);
#endif // WIN32
        break;
    }
    case tRequestMakeCall:
#if TAPI_2_0
    case tRequestMakeCallW:
#endif
    {
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        char szAppName[MAX_STRING_PARAM_SIZE];
        char szCalledParty[MAX_STRING_PARAM_SIZE] = "";
        char szComment[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { szlpszAppName,        PT_STRING, (ULONG_PTR) szAppName, szAppName },
            { "lpszCalledParty",    PT_STRING, (ULONG_PTR) szCalledParty, szCalledParty },
            { "lpszComment",        PT_STRING, (ULONG_PTR) szComment, szComment }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (funcIndex == tRequestMakeCall ?
                (PFN4) tapiRequestMakeCall : (PFN4) tapiRequestMakeCallW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, (PFN4) tapiRequestMakeCall };
#endif

        strcpy (szDestAddress, szDefDestAddress);
        strcpy (szAppName, szDefAppName);

        DoFunc (&paramsHeader);

        break;
    }
    case tRequestMediaCall:
#if TAPI_2_0
    case tRequestMediaCallW:
#endif
    {
        char szDeviceClass[MAX_STRING_PARAM_SIZE];
        char szDevID[MAX_STRING_PARAM_SIZE] = "0";
        char szDestAddress[MAX_STRING_PARAM_SIZE];
        char szAppName[MAX_STRING_PARAM_SIZE];
        char szCalledParty[MAX_STRING_PARAM_SIZE] = "";
        char szComment[MAX_STRING_PARAM_SIZE] = "";
        FUNC_PARAM params[] =
        {
            { "hWnd",               PT_DWORD,  (ULONG_PTR) ghwndMain, 0 },
            { "wRequestID",         PT_DWORD,  (ULONG_PTR) 0, 0 },
            { szlpszDeviceClass,    PT_STRING, (ULONG_PTR) szDeviceClass, szDeviceClass },
            { "lpDeviceID",         PT_STRING, (ULONG_PTR) szDevID, szDevID },
            { szdwSize,             PT_DWORD,  (ULONG_PTR) 0, 0 },
            { "dwSecure",           PT_DWORD,  (ULONG_PTR) 0, 0 },
            { szlpszDestAddress,    PT_STRING, (ULONG_PTR) szDestAddress, szDestAddress },
            { szlpszAppName,        PT_STRING, (ULONG_PTR) szAppName, szAppName },
            { "lpszCalledParty",    PT_STRING, (ULONG_PTR) szCalledParty, szCalledParty },
            { "lpszComment",        PT_STRING, (ULONG_PTR) szComment, szComment }
        };
#if TAPI_2_0
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, (funcIndex == tRequestMediaCall ?
                (PFN10) tapiRequestMediaCall : (PFN10) tapiRequestMediaCallW) };
#else
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, (PFN10) tapiRequestMediaCall };
#endif

        strcpy (szDeviceClass, szDefLineDeviceClass); // BUGBUG szDefTapiDeviceClass);
        strcpy (szDestAddress, szDefDestAddress);
        strcpy (szAppName, szDefAppName);

#ifdef WIN32
        DoFunc (&paramsHeader);
#else
        //
        // NOTE: on win16 HWNDSs & WPARAMs are 16 bits, so we've to hard
        //       code this
        //

        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        DumpParams (&paramsHeader);

        lResult = tapiRequestMediaCall(
            (HWND) params[0].dwValue,
            (WPARAM) params[1].dwValue,
            (LPCSTR) params[2].dwValue,
            (LPCSTR) params[3].dwValue,
            params[4].dwValue,
            params[5].dwValue,
            (LPCSTR) params[6].dwValue,
            (LPCSTR) params[7].dwValue,
            (LPCSTR) params[8].dwValue,
            (LPCSTR) params[9].dwValue
            );

        ShowTapiFuncResult (aFuncNames[funcIndex], lResult);
#endif // WIN32
        break;
    }
    case OpenAllLines:
    {
        DWORD dwDefLineDeviceIDSav = dwDefLineDeviceID;


        CHK_LINEAPP_SELECTED()

        UpdateResults (TRUE);
        ShowWidgetList (FALSE);

        for(
            dwDefLineDeviceID = 0;
            dwDefLineDeviceID < gdwNumLineDevs;
            dwDefLineDeviceID++
            )
        {
            FuncDriver (lOpen);
        }

        UpdateResults (FALSE);
        ShowWidgetList (TRUE);

        dwDefLineDeviceID = dwDefLineDeviceIDSav;

        break;
    }
    case OpenAllPhones:
    {
        DWORD dwDefPhoneDeviceIDSav = dwDefPhoneDeviceID;


        CHK_PHONEAPP_SELECTED()

        UpdateResults (TRUE);
        ShowWidgetList (FALSE);

        for(
            dwDefPhoneDeviceID = 0;
            dwDefPhoneDeviceID < gdwNumPhoneDevs;
            dwDefPhoneDeviceID++
            )
        {
            FuncDriver (pOpen);
        }

        UpdateResults (FALSE);
        ShowWidgetList (TRUE);

        dwDefPhoneDeviceID = dwDefPhoneDeviceIDSav;

        break;
    }
    case CloseHandl:
    {
#ifdef WIN32
        FUNC_PARAM params[] =
        {
            { "hObject",  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        if (CloseHandle ((HANDLE) params[0].dwValue))
        {
            ShowStr ("Handle x%lx closed", params[0].dwValue);
        }
        else
        {
            ShowStr ("CloseHandle failed, err=%lx", GetLastError());
        }
#else
        FUNC_PARAM params[] =
        {
            { "idCommDev",  PT_DWORD, 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        if (CloseComm ((int) params[0].dwValue) == 0)
        {
            ShowStr ("Comm dev x%lx closed", params[0].dwValue);
        }
        else
        {
            ShowStr ("CloseComm() failed");
        }
#endif

        break;
    }
    case DumpBuffer:

        ShowStr ("Buffer contents:");

        ShowBytes(
            (dwBigBufSize > 256 ? 256 : dwBigBufSize),
            pBigBuf,
            1
            );

        break;

#if (INTERNAL_VER >= 0x20000)

    case iNewLocationW:
    {
        char szNewLocName[MAX_STRING_PARAM_SIZE] = "NewLocN";
        LINEEXTENSIONID extID;
        FUNC_PARAM params[] =
        {
            { "lpszNewLocName", PT_STRING,  (ULONG_PTR) szNewLocName, szNewLocName}
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (!LetUserMungeParams (&paramsHeader))
        {
            break;
        }

        MakeWideString ((LPVOID) szNewLocName);

        lResult = internalNewLocationW(
            (WCHAR *) params[0].dwValue
            );

        break;
    }

#endif

    default:

        ErrorAlert();
        break;
    }
}

#pragma warning (default:4113)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\ui.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    ui.c

Abstract:

    Contains UI support for TAPI Browser util.

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


#include "tb.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <malloc.h>
#include <time.h>
#include <commdlg.h>
#include "resource.h"
#include "vars.h"


extern char szdwSize[];
extern char szdwAddressID[];


HWND    hwndEdit2;
HFONT   ghFixedFont;
char    gszEnterAs[32];

BYTE aHex[] =
{
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,
    255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
};

char *
PASCAL
GetTimeStamp(
    void
    );

void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    );

void
CompletionPortThread(
    LPVOID  pParams
    );


int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{
    MSG     msg;
    HWND    hwnd;
    HACCEL  hAccel;

    {
        DWORD d = 0x76543210;


        wsprintf(
            gszEnterAs,
            "Ex: enter x%x as %02x%02x%02x%02x",
            d,
            *((LPBYTE) &d),
            *(((LPBYTE) &d) + 1),
            *(((LPBYTE) &d) + 2),
            *(((LPBYTE) &d) + 3)
            );
    }

    ghInst = hInstance;

    hwnd = CreateDialog(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG1),
        (HWND)NULL,
        MainWndProc
        );

    hwndEdit2 = CreateWindow ("edit", "", 0, 0, 0, 0, 0, NULL, NULL, ghInst, NULL);

    if (!hwndEdit2)
    {
        MessageBox (NULL, "err creating edit ctl", "", MB_OK);
    }

    hAccel = LoadAccelerators(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDR_ACCELERATOR1)
        );

#if TAPI_2_0

    if ((ghCompletionPort = CreateIoCompletionPort(
            INVALID_HANDLE_VALUE,
            NULL,
            0,
            0
            )))
    {
        DWORD   dwTID;
        HANDLE  hThread;


        if ((hThread = CreateThread(
                (LPSECURITY_ATTRIBUTES) NULL,
                0,
                (LPTHREAD_START_ROUTINE) CompletionPortThread,
                NULL,
                0,
                &dwTID
                )))
        {
            CloseHandle (hThread);
        }
        else
        {
            ShowStr(
                "CreateThread(CompletionPortThread) failed, err=%d",
                GetLastError()
                );
        }
    }
    else
    {
        ShowStr ("CreateIoCompletionPort failed, err=%d", GetLastError());
    }

#endif

    ghFixedFont = CreateFont(
        13, 8, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 49, "Courier"
        );

    while (GetMessage (&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator (hwnd, hAccel, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }

    DestroyWindow (hwndEdit2);

    return 0;
}


void
CompletionPortThread(
    LPVOID  pParams
    )
{
    DWORD           dwNumBytesTransfered;
    ULONG_PTR       completionKey;
    LPLINEMESSAGE   pMsg;


    while (GetQueuedCompletionStatus(
                ghCompletionPort,
                &dwNumBytesTransfered,
                &completionKey,
                (LPOVERLAPPED *) &pMsg,
                INFINITE
                ))
    {
        if (pMsg)
        {
            tapiCallback(
                pMsg->hDevice,
                pMsg->dwMessageID,
                pMsg->dwCallbackInstance,
                pMsg->dwParam1,
                pMsg->dwParam2,
                pMsg->dwParam3
                );

            LocalFree (pMsg);
        }
        else
        {
            break;
        }
    }
}


void
GetCurrentSelections(
    void
    )
{
    LRESULT   lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    PMYWIDGET pWidget = aWidgets;


    //
    // Init all pXxxSel ptrs to NULL
    //

    pLineAppSel  = (PMYLINEAPP) NULL;
    pLineSel     = (PMYLINE) NULL;
    pCallSel     =
    pCallSel2    = (PMYCALL) NULL;
    pPhoneAppSel = (PMYPHONEAPP) NULL;
    pPhoneSel    = (PMYPHONE) NULL;


    if (lSel != LB_ERR)
    {
        //
        // Find the selected widget & set globals appropriately
        //

        pWidget = (PMYWIDGET) SendMessage(
            ghwndList1,
            LB_GETITEMDATA,
            (WPARAM) lSel,
            0
            );

        switch (pWidget->dwType)
        {
        case WT_LINEAPP:

            pLineAppSel = (PMYLINEAPP) pWidget;
            break;

        case WT_LINE:

            pLineSel    = (PMYLINE) pWidget;
            pLineAppSel = pLineSel->pLineApp;
            break;

        case WT_CALL:

            pCallSel    = (PMYCALL) pWidget;
            pLineSel    = pCallSel->pLine;
            pLineAppSel = pCallSel->pLine->pLineApp;

            if (pWidget->pNext && (pWidget->pNext->dwType == WT_CALL))
            {
                pCallSel2 = (PMYCALL) pWidget->pNext;
            }
            else if ((((PMYWIDGET)pLineSel)->pNext != pWidget) &&
                     (((PMYWIDGET)pLineSel)->pNext->dwType == WT_CALL))
            {
                pCallSel2 =  (PMYCALL) (((PMYWIDGET)pLineSel)->pNext);
            }

            break;

        case WT_PHONEAPP:

            pPhoneAppSel = (PMYPHONEAPP) pWidget;
            break;

        case WT_PHONE:

            pPhoneSel    = (PMYPHONE) pWidget;
            pPhoneAppSel = pPhoneSel->pPhoneApp;
            break;
        }
    }


    //
    // The following is an attempt to up the usability level a little bit.
    // Most folks are going to be messing around with 1 lineapp/line/call
    // at a time, and it'd end up being a real PITA for them to have to
    // select a widget each time (and it's fairly obvious which widget
    // are referring to).  So we're going to try to make some intelligent
    // decisions in case they haven't selected a widget... (Obviously this
    // could be cleaned up a bit, like maybe maintaining dwNumXxx as
    // globals rather than walking the list each time.)
    //

    {
        DWORD       dwNumLineApps = 0, dwNumLines = 0, dwNumCalls = 0,
                    dwNumPhoneApps = 0, dwNumPhones = 0;
        PMYPHONEAPP pPhoneApp = NULL;


        pWidget = aWidgets;

        while (pWidget)
        {
            switch (pWidget->dwType)
            {
            case WT_LINEAPP:

                dwNumLineApps++;
                break;

            case WT_LINE:

                dwNumLines++;
                break;

            case WT_CALL:

                dwNumCalls++;
                break;

            case WT_PHONEAPP:

                dwNumPhoneApps++;

                if (dwNumPhoneApps == 1)
                {
                    pPhoneApp = (PMYPHONEAPP) pWidget;
                }

                break;

            case WT_PHONE:

                dwNumPhones++;
                break;
            }

            pWidget = pWidget->pNext;
        }

        if (dwNumLineApps == 1)
        {
            pLineAppSel = (PMYLINEAPP) aWidgets;

            if (dwNumLines == 1)
            {
                pLineSel = (PMYLINE) pLineAppSel->Widget.pNext;

                if (dwNumCalls == 1)
                {
                    pCallSel = (PMYCALL) pLineSel->Widget.pNext;
                }
            }
        }

        if (dwNumPhoneApps == 1)
        {
            pPhoneAppSel = (PMYPHONEAPP) pPhoneApp;

            if (dwNumPhones == 1)
            {
                pPhoneSel = (PMYPHONE) pPhoneAppSel->Widget.pNext;
            }
        }
    }
}

/* help
VOID
MyWinHelp(
    HWND  hwndOwner,
    BOOL  bTapiHlp,
    UINT  uiCommand,
    DWORD dwData
    )
{
    char *lpszHelpFile = (bTapiHlp ? szTapiHlp : szTspiHlp);


    if (lpszHelpFile[0] == 0 || _access (lpszHelpFile, 0))
    {
        //
        // Prompt user for helpfile path
        //

        OPENFILENAME ofn;
        char szDirName[256] = ".\\";
        char szFile[256] = "tapi.hlp\0";
        char szFileTitle[256] = "";
        char szFilter[] = "Telephony API Help\0tapi.hlp\0\0";


        if (MessageBox(
                hwndOwner,
                "Help file not found- do you want to specify a new help file?",
                "Warning",
                MB_YESNO
                ) == IDNO)
        {
            return;
        }

        if (!bTapiHlp)
        {
            szFile[1] = 's';
            szFilter[10] = 'S';
            szFilter[20] = 's';
        }

        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = hwndOwner;
        ofn.lpstrFilter       = szFilter;
        ofn.lpstrCustomFilter = (LPSTR) NULL;
        ofn.nMaxCustFilter    = 0L;
        ofn.nFilterIndex      = 1;
        ofn.lpstrFile         = szFile;
        ofn.nMaxFile          = sizeof(szFile);
        ofn.lpstrFileTitle    = szFileTitle;
        ofn.nMaxFileTitle     = sizeof(szFileTitle);
        ofn.lpstrInitialDir   = szDirName;
        ofn.lpstrTitle        = (LPSTR) NULL;
        ofn.Flags             = 0L;
        ofn.nFileOffset       = 0;
        ofn.nFileExtension    = 0;
        ofn.lpstrDefExt       = "HLP";

        if (!GetOpenFileName(&ofn))
        {
            return;
        }

        strcpy (lpszHelpFile, szFile);
    }

    if (!WinHelp (ghwndMain, (LPCSTR) lpszHelpFile, uiCommand, dwData))
    {
        lpszHelpFile[0] = 0;
    }
}
*/

INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HICON  hIcon;
    static HMENU  hMenu;
    static int    icyButton, icyBorder;
    static HFONT  hFont, hFont2;

    int  i;

    static LONG cxList1, cxList2, cxWnd, xCapture, cxVScroll, lCaptureFlags = 0;
    static int cyWnd;

    typedef struct _XXX
    {
        DWORD   dwMenuID;

        DWORD   dwFlags;

    } XXX, *PXXX;

    static XXX aXxx[] =
    {
        { IDM_LOGSTRUCTDWORD        ,DS_BYTEDUMP },
        { IDM_LOGSTRUCTALLFIELD     ,DS_NONZEROFIELDS|DS_ZEROFIELDS },
        { IDM_LOGSTRUCTNONZEROFIELD ,DS_NONZEROFIELDS },
        { IDM_LOGSTRUCTNONE         ,0 }
    };

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        RECT rect;
        char buf[64];


        ghwndMain  = hwnd;
        ghwndList1 = GetDlgItem (hwnd, IDC_LIST1);
        ghwndList2 = GetDlgItem (hwnd, IDC_LIST2);
        ghwndEdit  = GetDlgItem (hwnd, IDC_EDIT1);
        hMenu      = GetMenu (hwnd);
        hIcon      = LoadIcon (ghInst, MAKEINTRESOURCE(IDI_ICON1));

        icyBorder = GetSystemMetrics (SM_CYFRAME);
        cxVScroll = 2*GetSystemMetrics (SM_CXVSCROLL);

        GetWindowRect (GetDlgItem (hwnd, IDC_BUTTON1), &rect);
        icyButton = (rect.bottom - rect.top) + icyBorder + 3;

        for (i = 0; aFuncNames[i]; i++)
        {
            SendMessage(
                ghwndList2,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) aFuncNames[i]
                );
        }

        SendMessage (ghwndList2, LB_SETCURSEL, (WPARAM) lInitialize, 0);


#ifdef WIN32
        SetWindowText (hwnd, "TAPI32 Browser");
#else
        SetWindowText (hwnd, "TAPI16 Browser");
#endif

        //
        // Read in defaults from ini file
        //

        {
            typedef struct _DEF_VALUE
            {
                char far *lpszEntry;
                char far *lpszDefValue;
                LPVOID   lp;

            } DEF_VALUE;

            DEF_VALUE aDefVals[] =
            {
                { "BufSize",            "1000", &dwBigBufSize },
                { "AddressID",          "0", &dwDefAddressID },
#if TAPI_2_0
                { "20LineAPIVersion",   "20000", &dwDefLineAPIVersion },
#else
#if TAPI_1_1
                { "14LineAPIVersion",   "10004", &dwDefLineAPIVersion },
#else
                { "13LineAPIVersion",   "10003", &dwDefLineAPIVersion },
#endif
#endif
                { "BearerMode",         "1", &dwDefBearerMode },
                { "CountryCode",        "0", &dwDefCountryCode },
                { "LineDeviceID",       "0", &dwDefLineDeviceID },
                { "LineExtVersion",     "0", &dwDefLineExtVersion },
                { "MediaMode",         "10", &dwDefMediaMode },        // DATAMODEM
                { "LinePrivilege",      "1", &dwDefLinePrivilege },    // NONE (dialout only)
#if TAPI_2_0
                { "20PhoneAPIVersion",  "20000", &dwDefPhoneAPIVersion },
#else
#if TAPI_1_1
                { "14PhoneAPIVersion",  "10004", &dwDefPhoneAPIVersion },
#else
                { "13PhoneAPIVersion",  "10003", &dwDefPhoneAPIVersion },
#endif
#endif
                { "PhoneDeviceID",      "0", &dwDefPhoneDeviceID },
                { "PhoneExtVersion",    "0", &dwDefPhoneExtVersion },
                { "PhonePrivilege",     "2", &dwDefPhonePrivilege },   // OWNER
#if TAPI_2_0
                { "20UserButton1",      "500", aUserButtonFuncs },
                { "20UserButton2",      "500", aUserButtonFuncs + 1 },
                { "20UserButton3",      "500", aUserButtonFuncs + 2 },
                { "20UserButton4",      "500", aUserButtonFuncs + 3 },
                { "20UserButton5",      "500", aUserButtonFuncs + 4 },
                { "20UserButton6",      "500", aUserButtonFuncs + 5 },
#else
#if TAPI_1_1
                { "14UserButton1",      "500", aUserButtonFuncs },
                { "14UserButton2",      "500", aUserButtonFuncs + 1 },
                { "14UserButton3",      "500", aUserButtonFuncs + 2 },
                { "14UserButton4",      "500", aUserButtonFuncs + 3 },
                { "14UserButton5",      "500", aUserButtonFuncs + 4 },
                { "14UserButton6",      "500", aUserButtonFuncs + 5 },
#else
                { "13UserButton1",      "500", aUserButtonFuncs },
                { "13UserButton2",      "500", aUserButtonFuncs + 1 },
                { "13UserButton3",      "500", aUserButtonFuncs + 2 },
                { "13UserButton4",      "500", aUserButtonFuncs + 3 },
                { "13UserButton5",      "500", aUserButtonFuncs + 4 },
                { "13UserButton6",      "500", aUserButtonFuncs + 5 },
#endif
#endif
                { "TimeStamp",          "0", &bTimeStamp },
                { "NukeIdleMonitorCalls",   "1", &bNukeIdleMonitorCalls },
                { "NukeIdleOwnedCalls",     "0", &bNukeIdleOwnedCalls },
                { "DisableHandleChecking", "0", &gbDisableHandleChecking },
                { "DumpStructsFlags",   "1",   &dwDumpStructsFlags },
                { NULL, NULL, NULL },
                { "UserUserInfo",       "my user user info", szDefUserUserInfo },
                { "DestAddress",        "55555", szDefDestAddress },
                { "LineDeviceClass",    "tapi/line", szDefLineDeviceClass },
                { "PhoneDeviceClass",   "tapi/phone", szDefPhoneDeviceClass },
                { "AppName",            "Tapi Browser", szDefAppName },
                { NULL, NULL, NULL },
#if TAPI_2_0
                { "20UserButton1Text",  "", &aUserButtonsText[0] },
                { "20UserButton2Text",  "", &aUserButtonsText[1] },
                { "20UserButton3Text",  "", &aUserButtonsText[2] },
                { "20UserButton4Text",  "", &aUserButtonsText[3] },
                { "20UserButton5Text",  "", &aUserButtonsText[4] },
                { "20UserButton6Text",  "", &aUserButtonsText[5] },
#else
#if TAPI_1_1
                { "14UserButton1Text",  "", &aUserButtonsText[0] },
                { "14UserButton2Text",  "", &aUserButtonsText[1] },
                { "14UserButton3Text",  "", &aUserButtonsText[2] },
                { "14UserButton4Text",  "", &aUserButtonsText[3] },
                { "14UserButton5Text",  "", &aUserButtonsText[4] },
                { "14UserButton6Text",  "", &aUserButtonsText[5] },
#else
                { "13UserButton1Text",  "", &aUserButtonsText[0] },
                { "13UserButton2Text",  "", &aUserButtonsText[1] },
                { "13UserButton3Text",  "", &aUserButtonsText[2] },
                { "13UserButton4Text",  "", &aUserButtonsText[3] },
                { "13UserButton5Text",  "", &aUserButtonsText[4] },
                { "13UserButton6Text",  "", &aUserButtonsText[5] },
#endif
#endif
                { NULL, NULL, NULL }
            };

            int i, j;

            #define MYSECTION "Tapi Browser"


            for (i = 0; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    buf,
                    15
                    );

                sscanf (buf, "%lx", aDefVals[i].lp);
            }

            i++;

            for (; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    (LPSTR) aDefVals[i].lp,
                    MAX_STRING_PARAM_SIZE - 1
                    );
            }

            i++;

            for (j = i; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    (LPSTR) aDefVals[i].lp,
                    MAX_USER_BUTTON_TEXT_SIZE - 1
                    );

                SetDlgItemText(
                    hwnd,
                    IDC_BUTTON13 + (i - j),
                    (LPCSTR)aDefVals[i].lp
                    );
            }

            lpszDefAppName          = szDefAppName;
            lpszDefUserUserInfo     = szDefUserUserInfo;
            lpszDefDestAddress      = szDefDestAddress;
            lpszDefLineDeviceClass  = szDefLineDeviceClass;
            lpszDefPhoneDeviceClass = szDefPhoneDeviceClass;

            if (GetProfileString (
                    MYSECTION,
                    "Version",
                    "",
                    buf,
                    15
                    ) == 0 || (strcmp (buf, szCurrVer)))
            {
                //
                // If here assume this is first time user had started
                // TB, so post a msg that will automatically bring up
                // the hlp dlg
                //

                PostMessage (hwnd, WM_COMMAND, IDM_USINGTB, 0);
            }

// help            GetProfileString (MYSECTION, "TapiHlpPath", "", szTapiHlp, 256);
// help            GetProfileString (MYSECTION, "TspiHlpPath", "", szTspiHlp, 256);
        }

        pBigBuf = malloc ((size_t)dwBigBufSize);

        {
            //HFONT hFontMenu = SendMessage (hMenu, WM_GETFONT, 0, 0);

            hFont = CreateFont(
                13, 5, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 34, "MS Sans Serif"
                );
            hFont2 = CreateFont(
                13, 8, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 49, "Courier"
                );

            for (i = 0; i < 18; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_BUTTON1 + i,
                    WM_SETFONT,
                    (WPARAM) hFont,
                    0
                    );
            }

            SendMessage (ghwndList1, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndList2, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndEdit, WM_SETFONT, (WPARAM) hFont2, 0);
        }

        GetProfileString(
            MYSECTION,
            "ControlRatios",
            "20, 20, 100",
            buf,
            63
            );

        sscanf (buf, "%ld,%ld,%ld", &cxList2, &cxList1, &cxWnd);

        GetProfileString(
            MYSECTION,
            "Position",
            "max",
            buf,
            63
            );

        if (strcmp (buf, "max") == 0)
        {
            ShowWindow (hwnd, SW_SHOWMAXIMIZED);
        }
        else
        {
            int left = 100, top = 100, right = 600, bottom = 400;


            sscanf (buf, "%d,%d,%d,%d", &left, &top, &right, &bottom);


            //
            // Check to see if wnd pos is wacky, if so reset to reasonable vals
            //

            if (left < 0 ||
                left >= (GetSystemMetrics (SM_CXSCREEN) - 32) ||
                top < 0 ||
                top >= (GetSystemMetrics (SM_CYSCREEN) - 32))
            {
                left = top = 100;
                right = 600;
                bottom = 400;
            }

            SetWindowPos(
                hwnd,
                HWND_TOP,
                left,
                top,
                right - left,
                bottom - top,
                SWP_SHOWWINDOW
                );

            GetClientRect (hwnd, &rect);

            SendMessage(
                hwnd,
                WM_SIZE,
                0,
                MAKELONG((rect.right-rect.left),(rect.bottom-rect.top))
                );

            ShowWindow (hwnd, SW_SHOW);
        }

        for (i = 0; aXxx[i].dwFlags != dwDumpStructsFlags; i++);

        CheckMenuItem (hMenu, aXxx[i].dwMenuID, MF_BYCOMMAND | MF_CHECKED);

        CheckMenuItem(
            hMenu,
            IDM_TIMESTAMP,
            MF_BYCOMMAND | (bTimeStamp ? MF_CHECKED : MF_UNCHECKED)
            );

        CheckMenuItem(
            hMenu,
            IDM_NUKEIDLEMONITORCALLS,
            MF_BYCOMMAND | (bNukeIdleMonitorCalls ? MF_CHECKED : MF_UNCHECKED)
            );

        CheckMenuItem(
            hMenu,
            IDM_NUKEIDLEOWNEDCALLS,
            MF_BYCOMMAND | (bNukeIdleOwnedCalls ? MF_CHECKED : MF_UNCHECKED)
            );

        CheckMenuItem(
            hMenu,
            IDM_NOHANDLECHK,
            MF_BYCOMMAND | (gbDisableHandleChecking ? MF_CHECKED : MF_UNCHECKED)
            );

        //
        // Alloc & init the global call params
        //

#if TAPI_2_0

        lpCallParamsW = NULL;

init_call_params:

#endif
        {
#if TAPI_2_0
            size_t callParamsSize =
                sizeof(LINECALLPARAMS) + 15 * MAX_STRING_PARAM_SIZE;
#else
            size_t callParamsSize =
                sizeof(LINECALLPARAMS) + 8 * MAX_STRING_PARAM_SIZE;
#endif

            if ((lpCallParams = (LPLINECALLPARAMS) malloc (callParamsSize)))
            {
                LPDWORD lpdwXxxOffset = &lpCallParams->dwOrigAddressOffset;


                memset (lpCallParams, 0, callParamsSize);

                lpCallParams->dwTotalSize   = (DWORD) callParamsSize;
                lpCallParams->dwBearerMode  = LINEBEARERMODE_VOICE;
                lpCallParams->dwMinRate     = 3100;
                lpCallParams->dwMaxRate     = 3100;
                lpCallParams->dwMediaMode   = LINEMEDIAMODE_INTERACTIVEVOICE;
                lpCallParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;

                for (i = 0; i < 8; i++)
                {
                    *(lpdwXxxOffset + 2*i) =
                        sizeof(LINECALLPARAMS) + i*MAX_STRING_PARAM_SIZE;
                }
#if TAPI_2_0
                {
                    LPDWORD pdwProxyRequests = (LPDWORD)
                                (((LPBYTE) lpCallParams) +
                                lpCallParams->dwDevSpecificOffset);


                    for (i = 0; i < 8; i++)
                    {
                        *(pdwProxyRequests + i) = i +
                            LINEPROXYREQUEST_SETAGENTGROUP;
                    }
                }

                lpdwXxxOffset = &lpCallParams->dwTargetAddressOffset;

                for (i = 0; i < 6; i++)
                {
                    *(lpdwXxxOffset + 2 * i) =
                        sizeof(LINECALLPARAMS) + (8+i)*MAX_STRING_PARAM_SIZE;
                }

                lpCallParams->dwCallingPartyIDOffset    =
                    sizeof(LINECALLPARAMS) + 14 * MAX_STRING_PARAM_SIZE;

                if (!lpCallParamsW)
                {
                    lpCallParamsW = lpCallParams;
                    goto init_call_params;
                }
#endif
            }
            else
            {
                // BUGBUG
            }
        }

        break;
    }
    case WM_COMMAND:
    {
        FUNC_INDEX funcIndex;
        BOOL bShowParamsSave = bShowParams;

        switch (LOWORD(wParam))
        {
        case IDC_EDIT1:

#ifdef WIN32
            if (HIWORD(wParam) == EN_CHANGE)
#else
            if (HIWORD(lParam) == EN_CHANGE)
#endif
            {
                //
                // Watch to see if the edit control is full, & if so
                // purge the top half of the text to make room for more
                //

                int length = GetWindowTextLength (ghwndEdit);


                if (length > 29998)
                {
#ifdef WIN32
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM) 0,
                        (LPARAM) 10000
                        );
#else
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM) 1,
                        (LPARAM) MAKELONG (0, 10000)
                        );
#endif

                    SendMessage(
                        ghwndEdit,
                        EM_REPLACESEL,
                        0,
                        (LPARAM) (char far *) ""
                        );

#ifdef WIN32
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)0xfffffffd,
                        (LPARAM)0xfffffffe
                        );
#else
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)1,
                        (LPARAM) MAKELONG (0xfffd, 0xfffe)
                        );
#endif
                }
            }
            break;

        case IDC_BUTTON1:

            funcIndex = lInitialize;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON2:

            funcIndex = lShutdown;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON3:

            funcIndex = lOpen;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON4:

            funcIndex = lClose;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON5:

            funcIndex = lMakeCall;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON6:

            GetCurrentSelections();

            if (pCallSel && (pCallSel->dwCallState == LINECALLSTATE_IDLE))
            {
                funcIndex = lDeallocateCall;
            }
            else
            {
                funcIndex = lDrop;
                gbDeallocateCall = TRUE;
            }

            FuncDriver (funcIndex);
            gbDeallocateCall = FALSE;
            break;

        case IDC_BUTTON7:

            funcIndex = pInitialize;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON8:

            funcIndex = pShutdown;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON9:

            funcIndex = pOpen;
            goto IDC_BUTTON10_callFuncDriver;

        case IDC_BUTTON10:

            funcIndex = pClose;

IDC_BUTTON10_callFuncDriver:

            //
            // Want to make the "hot buttons" as simple as possible, so
            // turn off the show params flag, then call FuncDriver, and
            // finally restore the flag
            //

            GetCurrentSelections ();
            FuncDriver (funcIndex);
            break;

        case IDC_BUTTON11:
        case IDM_CLEAR:

            SetWindowText (ghwndEdit, "");
            break;


        case IDM_PARAMS:
        case IDC_BUTTON12:

            bShowParams = (bShowParams ? FALSE : TRUE);

            if (bShowParams)
            {
                CheckMenuItem(
                    hMenu,
                    IDM_PARAMS,
                    MF_BYCOMMAND | MF_CHECKED
                    );

                CheckDlgButton (hwnd, IDC_BUTTON12, 1);
            }
            else
            {
                CheckMenuItem(
                    hMenu,
                    IDM_PARAMS,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );

                CheckDlgButton (hwnd, IDC_BUTTON12, 0);
            }

            break;

        case IDC_BUTTON13:
        case IDC_BUTTON14:
        case IDC_BUTTON15:
        case IDC_BUTTON16:
        case IDC_BUTTON17:
        case IDC_BUTTON18:
        {
            DWORD i = (DWORD) (LOWORD(wParam)) - IDC_BUTTON13;


            if (aUserButtonFuncs[i] >= MiscBegin)
            {
                //
                // Hot button func id is bogus, so bring
                // up hot button init dlg
                //

                DialogBoxParam(
                    ghInst,
                    (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                    (HWND) hwnd,
                    UserButtonsDlgProc,
                    (LPARAM) &i
                    );
            }
            else
            {
                //
                // Invoke the user button's corresponding func
                //

                GetCurrentSelections ();
                FuncDriver ((FUNC_INDEX) aUserButtonFuncs[i]);
            }

            break;
        }
/* help        case IDC_F1HELP:

            if ((GetFocus() == ghwndEdit) &&
                SendMessage (ghwndEdit, EM_GETSEL, 0, 0))
            {
                //
                // Display help for the selected text in the edit ctrl
                //

                char buf[32];


                //
                // Copy the selected text in the edit ctrl to our
                // temp edit control, then query the temp edit ctrl's
                // text (this seems to be the easiest way to get the
                // selected text)
                //

                SendMessage (ghwndEdit, WM_COPY, 0, 0);
                SetWindowText (hwndEdit2, "");
                SendMessage (hwndEdit2, WM_PASTE, 0, 0);


                //
                // In the interest of getting an exact match on a
                // helpfile key strip off any trailing spaces
                //

                GetWindowText (hwndEdit2, buf, 32);
                buf[31] = 0;
                for (i = 0; i < 32; i++)
                {
                    if (buf[i] == ' ')
                    {
                        buf[i] = 0;
                        break;
                    }
                }

                MyWinHelp (hwnd, TRUE, HELP_PARTIALKEY, buf);
            }
            else
            {
                //
                // Display help for the currently selected func
                //

                FUNC_INDEX funcIndex = (FUNC_INDEX)
                    SendMessage (ghwndList2, LB_GETCURSEL, 0, 0);


                MyWinHelp (hwnd, TRUE, HELP_PARTIALKEY, aFuncNames[funcIndex]);
            }

            break;
*/
        case IDC_PREVCTRL:
        {
            HWND hwndPrev = GetNextWindow (GetFocus (), GW_HWNDPREV);

            if (!hwndPrev)
            {
                hwndPrev = ghwndList2;
            }

            SetFocus (hwndPrev);
            break;
        }
        case IDC_NEXTCTRL:
        {
            HWND hwndNext = GetNextWindow (GetFocus (), GW_HWNDNEXT);

            if (!hwndNext)
            {
                hwndNext = GetDlgItem (hwnd, IDC_BUTTON12);
            }

            SetFocus (hwndNext);
            break;
        }
        case IDC_ENTER:
        {
            if (GetFocus() != ghwndEdit)
            {
                GetCurrentSelections ();
                FuncDriver(
                    (FUNC_INDEX)SendMessage(
                        ghwndList2,
                        LB_GETCURSEL,
                        0,
                        0
                        ));
            }
            else
            {
                // Send the edit ctrl a cr/lf
            }

            break;
        }
        case IDC_LIST1:

#ifdef WIN32
            switch (HIWORD(wParam))
#else
            switch (HIWORD(lParam))
#endif
            {
            case LBN_DBLCLK:
            {
                LRESULT lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
                PMYWIDGET pWidget;


                pWidget = (PMYWIDGET) SendMessage(
                    ghwndList1,
                    LB_GETITEMDATA,
                    (WPARAM) lSel,
                    0
                    );

                if ((pWidget->dwType == WT_LINEAPP)
                    || (pWidget->dwType == WT_PHONEAPP)
                    )
                {
                    break;
                }

                bShowParams = FALSE;

                UpdateResults (TRUE);

                switch (pWidget->dwType)
                {
                case WT_LINE:
                {
                    DWORD dwDefLineDeviceIDSave = dwDefLineDeviceID;
                    PMYLINE pLine = (PMYLINE) pWidget;


                    dwDefLineDeviceID = pLine->dwDevID;

                    pLineAppSel = GetLineApp (pLine->hLineApp);
                    pLineSel = pLine;

                    FuncDriver (lGetDevCaps);
                    FuncDriver (lGetLineDevStatus);

                    dwDefLineDeviceID = dwDefLineDeviceIDSave;
                    break;
                }
                case WT_CALL:
                {
                    PMYCALL pCall = (PMYCALL) pWidget;


                    pCallSel = pCall;
                    pLineSel = pCall->pLine;

                    FuncDriver (lGetCallInfo);
                    FuncDriver (lGetCallStatus);

                    break;
                }
                case WT_PHONE:
                {
                    DWORD dwDefPhoneDeviceIDSave = dwDefPhoneDeviceID;
                    PMYPHONE pPhone = (PMYPHONE) pWidget;


                    dwDefPhoneDeviceID = pPhone->dwDevID;

                    pPhoneAppSel = GetPhoneApp (pPhone->hPhoneApp);
                    pPhoneSel = pPhone;

                    FuncDriver (pGetDevCaps);
                    FuncDriver (pGetStatus);

                    dwDefPhoneDeviceID = dwDefPhoneDeviceIDSave;
                    break;
                }
                }

                UpdateResults (FALSE);

                bShowParams = bShowParamsSave;

                break;
            }
            } // switch

            break;

        case IDC_LIST2:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_DBLCLK)
#else
            if (HIWORD(lParam) == LBN_DBLCLK)
#endif
            {
                GetCurrentSelections ();
                FuncDriver(
                    (FUNC_INDEX)SendMessage(
                        ghwndList2,
                        LB_GETCURSEL,
                        0,
                        0
                        ));
            }

            break;

        case IDM_EXIT:
        {
            PostMessage (hwnd, WM_CLOSE, 0, 0);
            break;
        }
        case IDM_DEFAULTVALUES:
        {
            char szTmpAppName[MAX_STRING_PARAM_SIZE];
            char szTmpUserUserInfo[MAX_STRING_PARAM_SIZE];
            char szTmpDestAddress[MAX_STRING_PARAM_SIZE];
            char szTmpLineDeviceClass[MAX_STRING_PARAM_SIZE];
            char szTmpPhoneDeviceClass[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "Buffer size",            PT_DWORD,  (ULONG_PTR) dwBigBufSize, NULL },
                { "lpszAppName",            PT_STRING, (ULONG_PTR) lpszDefAppName, szTmpAppName },

                { "line: dwAddressID",      PT_DWORD,  (ULONG_PTR) dwDefAddressID, NULL },
                { "line: dwAPIVersion",     PT_ORDINAL,(ULONG_PTR) dwDefLineAPIVersion, aAPIVersions },
                { "line: dwBearerMode",     PT_FLAGS,  (ULONG_PTR) dwDefBearerMode, aBearerModes },
                { "line: dwCountryCode",    PT_DWORD,  (ULONG_PTR) dwDefCountryCode, NULL },
                { "line: dwDeviceID",       PT_DWORD,  (ULONG_PTR) dwDefLineDeviceID, NULL },
                { "line: dwExtVersion",     PT_DWORD,  (ULONG_PTR) dwDefLineExtVersion, NULL },
                { "line: dwMediaMode",      PT_FLAGS,  (ULONG_PTR) dwDefMediaMode, aMediaModes },
                { "line: dwPrivileges",     PT_FLAGS,  (ULONG_PTR) dwDefLinePrivilege, aLineOpenOptions },
                { "line: lpsUserUserInfo",  PT_STRING, (ULONG_PTR) lpszDefUserUserInfo, szTmpUserUserInfo },
                { "line: lpszDestAddress",  PT_STRING, (ULONG_PTR) lpszDefDestAddress, szTmpDestAddress },
                { "line: lpszDeviceClass",  PT_STRING, (ULONG_PTR) lpszDefLineDeviceClass, szTmpLineDeviceClass },
                { "phone: dwAPIVersion",    PT_ORDINAL,(ULONG_PTR) dwDefPhoneAPIVersion, aAPIVersions },
                { "phone: dwDeviceID",      PT_DWORD,  (ULONG_PTR) dwDefPhoneDeviceID, NULL },
                { "phone: dwExtVersion",    PT_DWORD,  (ULONG_PTR) dwDefPhoneExtVersion, NULL },
                { "phone: dwPrivilege",     PT_FLAGS,  (ULONG_PTR) dwDefPhonePrivilege, aPhonePrivileges },
                { "phone: lpszDeviceClass", PT_STRING, (ULONG_PTR) lpszDefPhoneDeviceClass, szTmpPhoneDeviceClass }
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 18, DefValues, params, NULL };
            BOOL bShowParamsSave = bShowParams;

            bShowParams = TRUE;

            strcpy (szTmpAppName, szDefAppName);
            strcpy (szTmpUserUserInfo, szDefUserUserInfo);
            strcpy (szTmpDestAddress, szDefDestAddress);
            strcpy (szTmpLineDeviceClass, szDefLineDeviceClass);
            strcpy (szTmpPhoneDeviceClass, szDefPhoneDeviceClass);

            if (LetUserMungeParams (&paramsHeader))
            {
                if (params[0].dwValue != dwBigBufSize)
                {
                    LPVOID pTmpBigBuf = malloc ((size_t) params[0].dwValue);

                    if (pTmpBigBuf)
                    {
                        free (pBigBuf);
                        pBigBuf = pTmpBigBuf;
                        dwBigBufSize = (DWORD) params[0].dwValue;
                    }
                }

                strcpy (szDefAppName, szTmpAppName);

                dwDefAddressID      = (DWORD) params[2].dwValue;
                dwDefLineAPIVersion = (DWORD) params[3].dwValue;
                dwDefBearerMode     = (DWORD) params[4].dwValue;
                dwDefCountryCode    = (DWORD) params[5].dwValue;
                dwDefLineDeviceID   = (DWORD) params[6].dwValue;
                dwDefLineExtVersion = (DWORD) params[7].dwValue;
                dwDefMediaMode      = (DWORD) params[8].dwValue;
                dwDefLinePrivilege  = (DWORD) params[9].dwValue;

                strcpy (szDefUserUserInfo, szTmpUserUserInfo);
                strcpy (szDefDestAddress, szTmpDestAddress);
                strcpy (szDefLineDeviceClass, szTmpLineDeviceClass);

                dwDefPhoneAPIVersion = (DWORD) params[13].dwValue;
                dwDefPhoneDeviceID   = (DWORD) params[14].dwValue;
                dwDefPhoneExtVersion = (DWORD) params[15].dwValue;
                dwDefPhonePrivilege  = (DWORD) params[16].dwValue;

                strcpy (szDefPhoneDeviceClass, szTmpPhoneDeviceClass);

                if (params[1].dwValue && (params[1].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefAppName = szDefAppName;
                }
                else
                {
                    lpszDefAppName = (char far *) params[1].dwValue;
                }

                if (params[10].dwValue &&
                    (params[10].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefUserUserInfo = szDefUserUserInfo;
                }
                else
                {
                    lpszDefUserUserInfo = (char far *) params[10].dwValue;
                }

                if (params[11].dwValue &&
                    (params[11].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefDestAddress = szDefDestAddress;
                }
                else
                {
                    lpszDefDestAddress = (char far *) params[11].dwValue;
                }

                if (params[12].dwValue &&
                    (params[12].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefLineDeviceClass  = szDefLineDeviceClass;
                }
                else
                {
                    lpszDefLineDeviceClass  = (char far *) params[12].dwValue;
                }

                if (params[17].dwValue &&
                    (params[17].dwValue != (ULONG_PTR) -1))
                {
                    lpszDefPhoneDeviceClass = szDefPhoneDeviceClass;
                }
                else
                {
                    lpszDefPhoneDeviceClass = (char far *) params[17].dwValue;
                }
            }

            bShowParams = bShowParamsSave;

            break;
        }
        case IDM_USERBUTTONS:

            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                (HWND) hwnd,
                UserButtonsDlgProc,
                (LPARAM) NULL
                );

            break;

        case IDM_DUMPPARAMS:

            bDumpParams = (bDumpParams ? FALSE : TRUE);

            CheckMenuItem(
                hMenu,
                IDM_DUMPPARAMS,
                MF_BYCOMMAND | (bDumpParams ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_LOGSTRUCTDWORD:
        case IDM_LOGSTRUCTALLFIELD:
        case IDM_LOGSTRUCTNONZEROFIELD:
        case IDM_LOGSTRUCTNONE:

            for (i = 0; aXxx[i].dwFlags != dwDumpStructsFlags; i++);

            CheckMenuItem(
                hMenu,
                aXxx[i].dwMenuID,
                MF_BYCOMMAND | MF_UNCHECKED
                );

            for (i = 0; aXxx[i].dwMenuID != LOWORD(wParam); i++);

            CheckMenuItem(
                hMenu,
                aXxx[i].dwMenuID,
                MF_BYCOMMAND | MF_CHECKED
                );

            dwDumpStructsFlags = aXxx[i].dwFlags;

            break;

        case IDM_TIMESTAMP:

            bTimeStamp = (bTimeStamp ? FALSE : TRUE);

            CheckMenuItem(
                hMenu,
                IDM_TIMESTAMP,
                MF_BYCOMMAND | (bTimeStamp ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_LOGFILE:
        {
            if (hLogFile)
            {
                fclose (hLogFile);
                hLogFile = (FILE *) NULL;
                CheckMenuItem(
                    hMenu,
                    IDM_LOGFILE,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );
            }
            else
            {
                OPENFILENAME ofn;
                char szDirName[256] = ".\\";
                char szFile[256] = "tb.log\0";
                char szFileTitle[256] = "";
                static char *szFilter =
                    "Log files (*.log)\0*.log\0All files (*.*)\0*.*\0\0";


                ofn.lStructSize       = sizeof(OPENFILENAME);
                ofn.hwndOwner         = hwnd;
                ofn.lpstrFilter       = szFilter;
                ofn.lpstrCustomFilter = (LPSTR) NULL;
                ofn.nMaxCustFilter    = 0L;
                ofn.nFilterIndex      = 1;
                ofn.lpstrFile         = szFile;
                ofn.nMaxFile          = sizeof(szFile);
                ofn.lpstrFileTitle    = szFileTitle;
                ofn.nMaxFileTitle     = sizeof(szFileTitle);
                ofn.lpstrInitialDir   = szDirName;
                ofn.lpstrTitle        = (LPSTR) NULL;
                ofn.Flags             = 0L;
                ofn.nFileOffset       = 0;
                ofn.nFileExtension    = 0;
                ofn.lpstrDefExt       = "LOG";

                if (!GetOpenFileName(&ofn))
                {
                    return 0L;
                }

                if ((hLogFile = fopen (szFile, "at")) == (FILE *) NULL)
                {
                    MessageBox(
                        hwnd,
                        "Error creating log file",
#ifdef WIN32
                        "TB32.EXE",
#else
                        "TB.EXE",
#endif
                        MB_OK
                        );
                }
                else
                {
                    struct tm *newtime;
                    time_t aclock;


                    time (&aclock);
                    newtime = localtime (&aclock);
                    fprintf(
                        hLogFile,
                        "\n---Log opened: %s\n",
                        asctime (newtime)
                        );

                    CheckMenuItem(
                        hMenu,
                        IDM_LOGFILE,
                        MF_BYCOMMAND | MF_CHECKED
                        );
                }
            }
            break;
        }
        case IDM_USINGTB:
        {
            static char szUsingTB[] =

                "ABSTRACT:\r\n"                                         \
                "    TB (TAPI Browser) is an application that\r\n"      \
                "allows a user to interactively call into the\r\n"      \
                "Windows Telephony interface and inspect all\r\n"       \
                "returned information. The following versions\r\n"      \
                "of TB are available:\r\n\r\n"                          \
                "    TB13.EXE: 16-bit app, TAPI v1.0\r\n"               \
                "    TB14.EXE: 32-bit app, <= TAPI v1.4\r\n"            \
                "    TB20.EXE: 32-bit app, <= TAPI v2.0\r\n"            \

                "\r\n"                                                  \
                "GETTING STARTED:\r\n"                                  \
                "1. Press the 'LAp+' button to initialize TAPI \r\n"    \
                "2. Press the 'Line+' button to open a line device\r\n" \
                "3. Press the 'Call+' button to make a call\r\n"        \
                "*  Pressing the 'LAp-' button will shutdown TAPI\r\n"  \

                "\r\n"                                                  \
                "MORE INFO:\r\n"                                        \
                "*  Double-clicking on one of the items in the\r\n"     \
                "functions listbox (far left) will invoke that \r\n"    \
                "function. Check the 'Params' checkbox to enable\r\n"   \
                "parameter modification.\r\n"                           \
                "*  Choose 'Options/Default values...' to modify\r\n"   \
                "default parameter values (address,device ID, etc).\r\n"\
                "*  Choose 'Options/Record log file' to save all\r\n"   \
                "output to a file.\r\n"                                 \
                "*  All parameter values in hexadecimal unless\r\n"     \
                "specified (strings displayed by contents, not \r\n"    \
                "pointer value).\r\n"                                   \
                "*  All 'Xxx+' and 'Xxx-' buttons are essentially \r\n" \
                "hot-links to items in the functions listbox.\r\n"      \
                "*  Choose 'Options/User buttons...' or press\r\n"      \
                "one of the buttons on right side of toolbar to\r\n"    \
                "create a personal hot-link between a button and a\r\n" \
                "particular function.\r\n"                              \

                "\r\n"                                                  \
                "  *  Note: Selecting a API version parameter value\r\n"\
                "which is newer than that for which TB application\r\n" \
                "is targeted will result in erroneous dumps of some\r\n"\
                "structures (e.g. specifying an API version of\r\n"     \
                "0x10004 and calling lineGetTranslateCaps in TB13).\r\n";

            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG6),
                (HWND)hwnd,
                AboutDlgProc,
                (LPARAM) szUsingTB
                );

            break;
        }
// help        case IDM_TAPIHLP:
// help
// help            MyWinHelp (hwnd, TRUE, HELP_CONTENTS, 0);
// help            break;

// help        case IDM_TSPIHLP:
// help
// help            MyWinHelp (hwnd, FALSE, HELP_CONTENTS, 0);
// help            break;

        case IDM_NUKEIDLEMONITORCALLS:

            bNukeIdleMonitorCalls = (bNukeIdleMonitorCalls ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NUKEIDLEMONITORCALLS,
                MF_BYCOMMAND |
                    (bNukeIdleMonitorCalls ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_NUKEIDLEOWNEDCALLS:

            bNukeIdleOwnedCalls = (bNukeIdleOwnedCalls ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NUKEIDLEOWNEDCALLS,
                MF_BYCOMMAND |
                    (bNukeIdleOwnedCalls ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_NOHANDLECHK:

            gbDisableHandleChecking = (gbDisableHandleChecking ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NOHANDLECHK,
                MF_BYCOMMAND |
                    (gbDisableHandleChecking ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_ABOUT:
        {
            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG4),
                (HWND)hwnd,
                AboutDlgProc,
                0
                );

            break;
        }
        } // switch

        break;
    }
#ifdef WIN32
    case WM_CTLCOLORBTN:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_BTN)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif

    case WM_MOUSEMOVE:
    {
        LONG x = (LONG)((short)LOWORD(lParam));
        int y = (int)((short)HIWORD(lParam));


        if ((y > icyButton) || lCaptureFlags)
        {
            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE(IDC_SIZEWE)));
        }

        if (lCaptureFlags == 1)
        {
            int cxList2New;


            x = (x > (cxList1 + cxList2 - cxVScroll) ?
                    (cxList1 + cxList2 - cxVScroll) : x);
            x = (x < cxVScroll ? cxVScroll : x);

            cxList2New = (int) (cxList2 + x - xCapture);

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton,
                cxList2New,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                cxList2New + icyBorder,
                icyButton,
                (int) (cxList1 - (x - xCapture)),
                cyWnd,
                SWP_SHOWWINDOW
                );
        }
        else if (lCaptureFlags == 2)
        {
            int cxList1New;


            x = (x < (cxList2 + cxVScroll) ?  (cxList2 + cxVScroll) : x);
            x = (x > (cxWnd - cxVScroll) ?  (cxWnd - cxVScroll) : x);

            cxList1New = (int) (cxList1 + x - xCapture);

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton,
                cxList1New,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) (cxList1New + cxList2) + 2*icyBorder,
                icyButton,
                (int)cxWnd - (cxList1New + (int)cxList2 + 2*icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );
        }

        break;
    }
    case WM_LBUTTONDOWN:
    {
        if ((int)((short)HIWORD(lParam)) > icyButton)
        {
            xCapture = (LONG)LOWORD(lParam);

            SetCapture (hwnd);

            lCaptureFlags = ((xCapture < cxList1 + cxList2) ? 1 : 2);
        }

        break;
    }
    case WM_LBUTTONUP:
    {
        if (lCaptureFlags)
        {
            POINT p;
            LONG  x;
            RECT  rect = { 0, icyButton, 2000, 2000 };

            GetCursorPos (&p);
            MapWindowPoints (HWND_DESKTOP, hwnd, &p, 1);
            x = (LONG) p.x;

            ReleaseCapture();

            if (lCaptureFlags == 1)
            {
                x = (x < cxVScroll ? cxVScroll : x);
                x = (x > (cxList1 + cxList2 - cxVScroll) ?
                    (cxList1 + cxList2 - cxVScroll) : x);

                cxList2 = cxList2 + (x - xCapture);
                cxList1 = cxList1 - (x - xCapture);

                rect.right = (int) (cxList1 + cxList2) + icyBorder;
            }
            else
            {
                x = (x < (cxList2 + cxVScroll) ?
                    (cxList2 + cxVScroll) : x);
                x = (x > (cxWnd - cxVScroll) ?
                    (cxWnd - cxVScroll) : x);

                cxList1 = cxList1 + (x - xCapture);

                rect.left = (int)cxList2 + icyBorder;
            }

            lCaptureFlags = 0;

            InvalidateRect (hwnd, &rect, TRUE);
        }

        break;
    }
    case WM_SIZE:
    {
        if (wParam != SIZE_MINIMIZED)
        {
            LONG width = (LONG)LOWORD(lParam);


            //
            // Adjust globals based on new size
            //

            cxWnd = (cxWnd ? cxWnd : 1); // avoid div by 0

            cxList1 = (cxList1 * width) / cxWnd;
            cxList2 = (cxList2 * width) / cxWnd;
            cxWnd = width;
            cyWnd = ((int)HIWORD(lParam)) - icyButton;


            //
            // Now reposition the child windows
            //

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton,
                (int) cxList2,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton,
                (int) cxList1,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) (cxList1 + cxList2) + 2*icyBorder,
                icyButton,
                (int)width - ((int)(cxList1 + cxList2) + 2*icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );

            InvalidateRect (hwnd, NULL, TRUE);
        }

        break;
    }
    case WM_PAINT:
    {
        PAINTSTRUCT ps;


        BeginPaint (hwnd, &ps);

        if (IsIconic (hwnd))
        {
            DrawIcon (ps.hdc, 0, 0, hIcon);
        }
        else
        {
            FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
#ifdef WIN32
            MoveToEx (ps.hdc, 0, 0, NULL);
#else
            MoveTo (ps.hdc, 0, 0);
#endif
            LineTo (ps.hdc, 5000, 0);

#ifdef WIN32
            MoveToEx (ps.hdc, 0, icyButton - 4, NULL);
#else
            MoveTo (ps.hdc, 0, icyButton - 4);
#endif
            LineTo (ps.hdc, 5000, icyButton - 4);
        }

        EndPaint (hwnd, &ps);

        break;
    }
    case WM_CLOSE:
    {
        BOOL bAutoShutdown = FALSE;
        RECT rect;


        //
        // Save defaults in ini file
        //

        {
            char buf[32];
            typedef struct _DEF_VALUE2
            {
                char far    *lpszEntry;
                ULONG_PTR   dwValue;

            } DEF_VALUE2;

            DEF_VALUE2 aDefVals[] =
            {
                { "BufSize",            dwBigBufSize },
                { "AddressID",          dwDefAddressID },
#if TAPI_2_0
                { "20LineAPIVersion",   dwDefLineAPIVersion },
#else
#if TAPI_1_1
                { "14LineAPIVersion",   dwDefLineAPIVersion },
#else
                { "13LineAPIVersion",   dwDefLineAPIVersion },
#endif
#endif
                { "BearerMode",         dwDefBearerMode },
                { "CountryCode",        dwDefCountryCode },
                { "LineDeviceID",       dwDefLineDeviceID },
                { "LineExtVersion",     dwDefLineExtVersion },
                { "MediaMode",          dwDefMediaMode },
                { "LinePrivilege",      dwDefLinePrivilege },
#if TAPI_2_0
                { "20PhoneAPIVersion",  dwDefPhoneAPIVersion },
#else
#if TAPI_1_1
                { "14PhoneAPIVersion",  dwDefPhoneAPIVersion },
#else
                { "13PhoneAPIVersion",  dwDefPhoneAPIVersion },
#endif
#endif
                { "PhoneDeviceID",      dwDefPhoneDeviceID },
                { "PhoneExtVersion",    dwDefPhoneExtVersion },
                { "PhonePrivilege",     dwDefPhonePrivilege },
#if TAPI_2_0
                { "20UserButton1",      aUserButtonFuncs[0] },
                { "20UserButton2",      aUserButtonFuncs[1] },
                { "20UserButton3",      aUserButtonFuncs[2] },
                { "20UserButton4",      aUserButtonFuncs[3] },
                { "20UserButton5",      aUserButtonFuncs[4] },
                { "20UserButton6",      aUserButtonFuncs[5] },
#else
#if TAPI_1_1
                { "14UserButton1",      aUserButtonFuncs[0] },
                { "14UserButton2",      aUserButtonFuncs[1] },
                { "14UserButton3",      aUserButtonFuncs[2] },
                { "14UserButton4",      aUserButtonFuncs[3] },
                { "14UserButton5",      aUserButtonFuncs[4] },
                { "14UserButton6",      aUserButtonFuncs[5] },
#else
                { "13UserButton1",      aUserButtonFuncs[0] },
                { "13UserButton2",      aUserButtonFuncs[1] },
                { "13UserButton3",      aUserButtonFuncs[2] },
                { "13UserButton4",      aUserButtonFuncs[3] },
                { "13UserButton5",      aUserButtonFuncs[4] },
                { "13UserButton6",      aUserButtonFuncs[5] },
#endif
#endif
                { "TimeStamp",          bTimeStamp },
                { "NukeIdleMonitorCalls",  bNukeIdleMonitorCalls },
                { "NukeIdleOwnedCalls",    bNukeIdleOwnedCalls },
                { "DisableHandleChecking", gbDisableHandleChecking },
                { "DumpStructsFlags",   dwDumpStructsFlags },
                { NULL, 0 },
                { "Version",            (ULONG_PTR) szCurrVer },
                { "UserUserInfo",       (ULONG_PTR) szDefUserUserInfo },
                { "DestAddress",        (ULONG_PTR) szDefDestAddress },
                { "LineDeviceClass",    (ULONG_PTR) szDefLineDeviceClass },
                { "PhoneDeviceClass",   (ULONG_PTR) szDefPhoneDeviceClass },
                { "AppName",            (ULONG_PTR) szDefAppName },
#if TAPI_2_0
                { "20UserButton1Text",  (ULONG_PTR) &aUserButtonsText[0] },
                { "20UserButton2Text",  (ULONG_PTR) &aUserButtonsText[1] },
                { "20UserButton3Text",  (ULONG_PTR) &aUserButtonsText[2] },
                { "20UserButton4Text",  (ULONG_PTR) &aUserButtonsText[3] },
                { "20UserButton5Text",  (ULONG_PTR) &aUserButtonsText[4] },
                { "20UserButton6Text",  (ULONG_PTR) &aUserButtonsText[5] },
#else
#if TAPI_1_1
                { "14UserButton1Text",  (ULONG_PTR) &aUserButtonsText[0] },
                { "14UserButton2Text",  (ULONG_PTR) &aUserButtonsText[1] },
                { "14UserButton3Text",  (ULONG_PTR) &aUserButtonsText[2] },
                { "14UserButton4Text",  (ULONG_PTR) &aUserButtonsText[3] },
                { "14UserButton5Text",  (ULONG_PTR) &aUserButtonsText[4] },
                { "14UserButton6Text",  (ULONG_PTR) &aUserButtonsText[5] },
#else
                { "13UserButton1Text",  (ULONG_PTR) &aUserButtonsText[0] },
                { "13UserButton2Text",  (ULONG_PTR) &aUserButtonsText[1] },
                { "13UserButton3Text",  (ULONG_PTR) &aUserButtonsText[2] },
                { "13UserButton4Text",  (ULONG_PTR) &aUserButtonsText[3] },
                { "13UserButton5Text",  (ULONG_PTR) &aUserButtonsText[4] },
                { "13UserButton6Text",  (ULONG_PTR) &aUserButtonsText[5] },
#endif
#endif
// help                { "TapiHlpPath",        (ULONG_PTR) szTapiHlp },
// help                { "TspiHlpPath",        (ULONG_PTR) szTspiHlp },
                { NULL, 0 }
            };

            int i;

            for (i = 0; aDefVals[i].lpszEntry; i++)
            {
                sprintf (buf, "%lx", aDefVals[i].dwValue);

                WriteProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    buf
                    );
            }

            i++;

            for (; aDefVals[i].lpszEntry; i++)
            {
                WriteProfileString(
                    MYSECTION,
                    aDefVals[i].lpszEntry,
                    (LPCSTR) aDefVals[i].dwValue
                    );
            }


            //
            // Save the window dimensions (if iconic then don't bother)
            //

            if (!IsIconic (hwnd))
            {
                if (IsZoomed (hwnd))
                {
                    strcpy (buf, "max");
                }
                else
                {
                    GetWindowRect (hwnd, &rect);

                    sprintf(
                        buf,
                        "%d,%d,%d,%d",
                        rect.left,
                        rect.top,
                        rect.right,
                        rect.bottom
                        );
                }

                WriteProfileString(
                    MYSECTION,
                    "Position",
                    (LPCSTR) buf
                    );

                sprintf (buf, "%ld,%ld,%ld", cxList2, cxList1, cxWnd);

                WriteProfileString(
                    MYSECTION,
                    "ControlRatios",
                    (LPCSTR) buf
                    );
            }
        }



        //
        // Give user chance to auto-shutdown any active line/phone apps
        //

        if (aWidgets)
        {
            if (MessageBox(
                    hwnd,
                    "Shutdown all hLineApps/hPhoneApps? (recommended)",
                    "Tapi Browser closing",
                    MB_YESNO
                    ) == IDNO)
            {
                goto WM_CLOSE_freeBigBuf;
            }

            bShowParams = FALSE;

            while (aWidgets)
            {
                PMYWIDGET pWidgetToClose = aWidgets;


                if (aWidgets->dwType == WT_LINEAPP)
                {
                    pLineAppSel = (PMYLINEAPP) aWidgets;
                    FuncDriver (lShutdown);
                }
                else if (aWidgets->dwType == WT_PHONEAPP)
                {
                    pPhoneAppSel = (PMYPHONEAPP) aWidgets;
                    FuncDriver (pShutdown);
                }

                if (pWidgetToClose == aWidgets)
                {
                    //
                    // The shutdown wasn't successful (or our list is
                    // messed up an it'd not a LINEAPP or PHONEAPP widget),
                    // so manually nuke this widget so we don't hang in
                    // this loop forever
                    //

                    RemoveWidgetFromList (pWidgetToClose);
                }
            }
        }

WM_CLOSE_freeBigBuf:

        if (hLogFile)
        {
            fclose (hLogFile);
        }
        DestroyIcon (hIcon);
        free (pBigBuf);
        free (lpCallParams);
//        if (aSelWidgets)
//        {
//            free (aSelWidgets);
//        }
//        if (aSelWidgetsPrev)
//        {
//            free (aSelWidgetsPrev);
//        }
        DeleteObject (hFont);
        DeleteObject (hFont2);
        PostQuitMessage (0);
        break;

    }
    } //switch

    return 0;
}


INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:

        if (lParam)
        {
            SetDlgItemText (hwnd, IDC_EDIT1, (LPCSTR) lParam);
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return 0;
}


void
FAR
ShowStr(
    LPCSTR format,
    ...
    )
{
    char buf[256];
    va_list ap;


    va_start(ap, format);
    wvsprintf (buf, format, ap);

    if (hLogFile)
    {
        fprintf (hLogFile, "%s\n", buf);
    }

    strcat (buf, "\r\n");


    //
    // Insert text at end
    //

#ifdef WIN32
    SendMessage (ghwndEdit, EM_SETSEL, (WPARAM)0xfffffffd, (LPARAM)0xfffffffe);
#else
    SendMessage(
        ghwndEdit,
        EM_SETSEL,
        (WPARAM)0,
        (LPARAM) MAKELONG(0xfffd,0xfffe)
        );
#endif

    SendMessage (ghwndEdit, EM_REPLACESEL, 0, (LPARAM) buf);


#ifdef WIN32

    //
    // Scroll to end of text
    //

    SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
#endif

    va_end(ap);
}


VOID
UpdateWidgetListCall(
    PMYCALL pCall
    )
{
    LONG    i;
    char    buf[64];
    LRESULT lSel;


    for (i = 0; aCallStates[i].dwVal != 0xffffffff; i++)
    {
        if (pCall->dwCallState == aCallStates[i].dwVal)
        {
            break;
        }
    }

    sprintf(
        buf,
        "    Call=x%lx %s %s",
        pCall->hCall,
        aCallStates[i].lpszVal,
        (pCall->bMonitor ? "Monitor" : "Owner")
        );

    i = (LONG) GetWidgetIndex ((PMYWIDGET) pCall);

    lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    SendMessage (ghwndList1, LB_DELETESTRING, (WPARAM) i, 0);
    SendMessage (ghwndList1, LB_INSERTSTRING, (WPARAM) i, (LPARAM) buf);
    SendMessage (ghwndList1, LB_SETITEMDATA, (WPARAM) i, (LPARAM) pCall);

    if (lSel == i)
    {
        SendMessage (ghwndList1, LB_SETCURSEL, (WPARAM) i, 0);
    }
}


VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    typedef struct _MSG_PARAMS
    {
        char    *lpszMsg;

        LPVOID  aParamFlagTables[3];

    } MSG_PARAMS, *PMSG_PARAMS;

    static MSG_PARAMS msgParams[] =
    {
        { "LINE_ADDRESSSTATE",       { NULL, aAddressStates, NULL } },
        { "LINE_CALLINFO",           { aCallInfoStates, NULL, NULL } },
        { "LINE_CALLSTATE",          { aCallStates, NULL, aCallPrivileges } },
        { "LINE_CLOSE",              { NULL, NULL, NULL } },
        { "LINE_DEVSPECIFIC",        { NULL, NULL, NULL } },
        { "LINE_DEVSPECIFICFEATURE", { NULL, NULL, NULL } },
        { "LINE_GATHERDIGITS",       { aGatherTerms, NULL, NULL } },
        { "LINE_GENERATE",           { aGenerateTerms, NULL, NULL } },
        { "LINE_LINEDEVSTATE",       { aLineStates, NULL, NULL } },
        { "LINE_MONITORDIGITS",      { NULL, aDigitModes, NULL } },
        { "LINE_MONITORMEDIA",       { aMediaModes, NULL, NULL } },
        { "LINE_MONITORTONE",        { NULL, NULL, NULL } },
        { "LINE_REPLY",              { NULL, NULL, NULL } },
        { "LINE_REQUEST",            { aRequestModes, NULL, NULL } }
         ,
        { "PHONE_BUTTON",            { NULL, aButtonModes, aButtonStates } },
        { "PHONE_CLOSE",             { NULL, NULL, NULL } },
        { "PHONE_DEVSPECIFIC",       { NULL, NULL, NULL } },
        { "PHONE_REPLY",             { NULL, NULL, NULL } },
        { "PHONE_STATE",             { aPhoneStates, NULL, NULL } }

#if TAPI_1_1
         ,
        { "LINE_CREATE",             { NULL, NULL, NULL } },
        { "PHONE_CREATE",            { NULL, NULL, NULL } }

#if TAPI_2_0
         ,
        { "LINE_AGENTSPECIFIC",      { NULL, NULL, NULL } },
        { "LINE_AGENTSTATUS",        { NULL, NULL, NULL } },
        { "LINE_APPNEWCALL",         { NULL, NULL, aCallPrivileges } },
        { "LINE_PROXYREQUEST",       { NULL, NULL, NULL } },
        { "LINE_REMOVE",             { NULL, NULL, NULL } },
        { "PHONE_REMOVE",            { NULL, NULL, NULL } }
#endif
#endif

    };
    int     i, j;
    LONG    lResult;


    UpdateResults (TRUE);

#if TAPI_1_1
#if TAPI_2_0
    if (dwMsg <= PHONE_REMOVE)
#else
    if (dwMsg <= PHONE_CREATE)
#endif
#else
    if (dwMsg <= PHONE_STATE)
#endif
    {
        ULONG_PTR   aParams[3] = { Param1, Param2, Param3 };


        {
            char *pszTimeStamp = GetTimeStamp();

            ShowStr(
                "%sreceived %s",
                pszTimeStamp,
                msgParams[dwMsg].lpszMsg
                );
        }

        ShowStr ("%sdevice=x%lx", szTab, hDevice);
        ShowStr ("%scbInst=x%lx", szTab, CallbackInstance);

        if (dwMsg == LINE_CALLSTATE)
        {
            msgParams[2].aParamFlagTables[1] = NULL;

            switch (Param1)
            {
            case LINECALLSTATE_BUSY:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aBusyModes;
                break;

            case LINECALLSTATE_DIALTONE:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aDialToneModes;
                break;

            case LINECALLSTATE_SPECIALINFO:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aSpecialInfo;
                break;

            case LINECALLSTATE_DISCONNECTED:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aDisconnectModes;
                break;

#if TAPI_1_1

            case LINECALLSTATE_CONNECTED:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aConnectedModes;
                break;

            case LINECALLSTATE_OFFERING:

                msgParams[2].aParamFlagTables[1] = (LPVOID) aOfferingModes;
                break;

#endif // TAPI_1_1

            } // switch
        }

        else if (dwMsg == PHONE_STATE)
        {
            msgParams[18].aParamFlagTables[1] = NULL;

            switch (Param1)
            {
            case PHONESTATE_HANDSETHOOKSWITCH:
            case PHONESTATE_SPEAKERHOOKSWITCH:
            case PHONESTATE_HEADSETHOOKSWITCH:

                msgParams[18].aParamFlagTables[1] = aHookSwitchModes;
                break;

            } // switch
        }

        for (i = 0; i < 3; i++)
        {
            char buf[80];


            sprintf (buf, "%sparam%d=x%lx, ", szTab, i+1, aParams[i]);

            if (msgParams[dwMsg].aParamFlagTables[i])
            {
                PLOOKUP pLookup = (PLOOKUP)
                    msgParams[dwMsg].aParamFlagTables[i];


                for (j = 0; aParams[i], pLookup[j].dwVal != 0xffffffff; j++)
                {
                    if (aParams[i] & pLookup[j].dwVal)
                    {
                        if (buf[0] == 0)
                        {
                            sprintf (buf, "%s%s", szTab, szTab);
                        }

                        strcat (buf, pLookup[j].lpszVal);
                        strcat (buf, " ");
                        aParams[i] = aParams[i] &
                            ~((ULONG_PTR) pLookup[j].dwVal);

                        if (strlen (buf) > 50)
                        {
                            //
                            // We don't want strings getting so long that
                            // they're going offscreen, so break them up.
                            //

                            ShowStr (buf);
                            buf[0] = 0;
                        }
                    }
                }

                if (aParams[i])
                {
                    strcat (buf, "<unknown flag(s)>");
                }

            }

            if (buf[0])
            {
                ShowStr (buf);
            }
        }
    }
    else
    {
        ShowStr ("ERROR! callback received unknown msg=x%lx", dwMsg);
        ShowStr ("%shDev=x%lx,  cbInst=x%lx, p1=x%lx, p2=x%lx, p3=x%lx",
            szTab,
            hDevice,
            CallbackInstance,
            Param1,
            Param2,
            Param3
            );

        return;
    }

    UpdateResults (FALSE);

    switch (dwMsg)
    {
    case LINE_CALLSTATE:
    {
        PMYLINE pLine;
        PMYCALL pCall = GetCall ((HCALL) hDevice);


        //
        // If the call state is idle & we're in "nuke idle xxx calls"
        // mode then determine the privilege of this callto see if we
        // need to nuke it
        //

        if ((Param1 == LINECALLSTATE_IDLE) &&
            (bNukeIdleMonitorCalls || bNukeIdleOwnedCalls))
        {
            BOOL            bNukeCall = FALSE;
            LINECALLSTATUS  callStatus;


            callStatus.dwTotalSize = (DWORD) sizeof(LINECALLSTATUS);

            lResult = lineGetCallStatus ((HCALL) hDevice, &callStatus);

            ShowLineFuncResult ("lineGetCallStatus", lResult);

            if (lResult == 0)
            {
                if ((callStatus.dwCallPrivilege & LINECALLPRIVILEGE_OWNER))
                {
                    if (bNukeIdleOwnedCalls)
                    {
                        bNukeCall = TRUE;
                    }
                }
                else
                {
                    if (bNukeIdleMonitorCalls)
                    {
                        bNukeCall = TRUE;
                    }
                }
            }

            if (bNukeCall)
            {
                if ((lResult = lineDeallocateCall ((HCALL) hDevice)) == 0)
                {
                    ShowStr ("Call x%lx deallocated on IDLE", hDevice);

                    if (pCall)
                    {
                        FreeCall (pCall);
                    }

                    break;
                }
                else
                {
                    ShowLineFuncResult ("lineDeallocateCall", lResult);
                }
            }
        }


        //
        // Find call in the widget list, save the call state, &
        // update it's text in the widget list.
        //

        if (pCall)
        {
            //
            // If dwNumPendingDrops is non-zero, then user previously
            // pressed "Call-" button and we're waiting for a call to
            // go IDLE so we can deallocate it. Check to see if this
            // is the call we want to nuke. (Note: we used to nuke the
            // call when we got a successful REPLY msg back from the
            // drop request; the problem with that is some SPs complete
            // the drop request *before* they set the call state to
            // IDLE, and our call to lineDeallocateCall would fail
            // since TAPI won't let a call owner deallocate a call if
            // it's not IDLE.)
            //

            if (dwNumPendingDrops &&
                (Param1 == LINECALLSTATE_IDLE) &&
                pCall->lDropReqID)
            {
                dwNumPendingDrops--;

                ShowStr(
                    "Deallocating hCall x%lx " \
                        "(REPLY for requestID x%lx might be filtered)",
                    pCall->hCall,
                    pCall->lDropReqID
                    );

                lResult = lineDeallocateCall (pCall->hCall);

                ShowLineFuncResult ("lineDeallocateCall", lResult);

                if (lResult == 0)
                {
                    FreeCall (pCall);
                    break;
                }
                else
                {
                    pCall->lDropReqID = 0;
                }
            }

            pCall->dwCallState = (DWORD) Param1;
            UpdateWidgetListCall (pCall);
        }


        //
        // If here this is the first we've heard of this this call,
        // so find out which line it's on & create a call widget
        // for it
        //

        else if (Param3 != 0)
        {
            LINECALLINFO callInfo;


            memset (&callInfo, 0, sizeof(LINECALLINFO));
            callInfo.dwTotalSize = sizeof(LINECALLINFO);
            lResult = lineGetCallInfo ((HCALL)hDevice, &callInfo);

            ShowStr(
                "%slineGetCallInfo returned x%lx, hLine=x%lx",
                szTab,
                lResult,
                callInfo.hLine
                );

            if (lResult == 0)
            {
                if ((pLine = GetLine (callInfo.hLine)))
                {
                    if ((pCall = AllocCall (pLine)))
                    {
                        pCall->hCall       = (HCALL) hDevice;
                        pCall->dwCallState = (DWORD) Param1;
                        pCall->bMonitor    = (Param3 ==
                            LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                        UpdateWidgetListCall (pCall);
                    }
                }
            }
        }

        break;
    }
    case LINE_GATHERDIGITS:
    {
        PMYCALL pCall;


        if ((pCall = GetCall ((HCALL) hDevice)) && pCall->lpsGatheredDigits)
        {
            ShowStr ("%sGathered digits:", szTab);
            ShowBytes (pCall->dwNumGatheredDigits, pCall->lpsGatheredDigits, 2);
            free (pCall->lpsGatheredDigits);
            pCall->lpsGatheredDigits = NULL;
        }

        break;
    }
    case LINE_REPLY:

        if (dwNumPendingMakeCalls)
        {
            //
            // Check to see if this is a reply for a lineMakeCall request
            //

            PMYWIDGET pWidget = aWidgets;


            while (pWidget && (pWidget->dwType != WT_PHONEAPP))
            {
                if (pWidget->dwType == WT_CALL)
                {
                    PMYCALL pCall = (PMYCALL) pWidget;

                    if ((DWORD)pCall->lMakeCallReqID == Param1)
                    {
                        //
                        // The reply id matches the make call req id
                        //

                        dwNumPendingMakeCalls--;

                        if (Param2 || !pCall->hCall)
                        {
                            //
                            // Request error or no call created, so free
                            // up the struct & update the hCalls listbox
                            //

                            if (Param2 == 0)
                            {
                                ShowStr(
                                    "    NOTE: *lphCall==NULL, "\
                                        "freeing call data structure"
                                    );
                            }

                            pWidget = pWidget->pNext;

                            FreeCall (pCall);

                            continue;
                        }
                        else
                        {
                            //
                            // Reset this field so we don't run into
                            // problems later with another of the same
                            // request id
                            //

                            pCall->lMakeCallReqID = 0;

                            UpdateWidgetListCall (pCall);
                        }
                    }
                }

                pWidget = pWidget->pNext;
            }
        }

        if (Param2)
        {
            //
            // Dump the error in a readable format
            //

            if (Param2 > LAST_LINEERR)
            {
                ShowStr ("inval err code (x%lx)", Param2);
            }
            else
            {
                ShowStr(
                    "    %s%s",
                    "LINEERR_", // ...to shrink the aszLineErrs array
                    aszLineErrs[LOWORD(Param2)]
                    );
            }
        }

        break;

    case PHONE_REPLY:

        if (Param2)
        {
            //
            // Dump the error in a readable format
            //

            ErrorAlert();

            if (Param2 > PHONEERR_REINIT)
            {
                ShowStr ("inval err code (x%lx)", Param2);
            }
            else
            {
                ShowStr(
                    "    %s%s",
                    "PHONEERR_", // ...to shrink the aszPhoneErrs array
                    aszPhoneErrs[LOWORD(Param2)]
                    );
            }
        }

        break;

    case LINE_CLOSE:

        FreeLine (GetLine ((HLINE) hDevice));
        break;

    case PHONE_CLOSE:

        FreePhone (GetPhone ((HPHONE) hDevice));
        break;

#if TAPI_2_0

    case LINE_APPNEWCALL:
    {
        PMYLINE pLine;
        PMYCALL pCall;


        if ((pLine = GetLine ((HLINE) hDevice)))
        {
            if ((pCall = AllocCall (pLine)))
            {
                pCall->hCall       = (HCALL) Param2;
                pCall->dwCallState = LINECALLSTATE_UNKNOWN;
                pCall->bMonitor    = (Param3 ==
                    LINECALLPRIVILEGE_MONITOR ? TRUE : FALSE);
                UpdateWidgetListCall (pCall);
            }
        }

        break;
    }
    case LINE_PROXYREQUEST:
    {
        LPLINEPROXYREQUEST  pRequest = (LPLINEPROXYREQUEST) Param1;
        STRUCT_FIELD fields[] =
        {
            { szdwSize,                     FT_DWORD,   pRequest->dwSize, NULL },
            { "dwClientMachineNameSize",    FT_SIZE,    pRequest->dwClientMachineNameSize, NULL },
            { "dwClientMachineNameOffset",  FT_OFFSET,  pRequest->dwClientMachineNameOffset, NULL },
            { "dwClientUserNameSize",       FT_SIZE,    pRequest->dwClientUserNameSize, NULL },
            { "dwClientUserNameOffset",     FT_OFFSET,  pRequest->dwClientUserNameOffset, NULL },
            { "dwClientAppAPIVersion",      FT_DWORD,   pRequest->dwClientAppAPIVersion, NULL },
            { "dwRequestType",              FT_ORD,     pRequest->dwRequestType, aProxyRequests }
        };
        STRUCT_FIELD_HEADER fieldHeader =
        {
            pRequest,
            "LINEPROXYREQUEST",
            7,
            fields
        };


        ShowStructByField (&fieldHeader, TRUE);

        switch (pRequest->dwRequestType)
        {
        case LINEPROXYREQUEST_SETAGENTGROUP:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->SetAgentGroup.dwAddressID, NULL }

// BUGBUG LINE_PROXYREQUEST: dump agent grp list

            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "SetAgentGroup",
                1,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_SETAGENTSTATE:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,        FT_DWORD,   pRequest->SetAgentState.dwAddressID, NULL },
                { "dwAgentState",       FT_ORD,     pRequest->SetAgentState.dwAgentState, aAgentStates },
                { "dwNextAgentState",   FT_ORD,     pRequest->SetAgentState.dwNextAgentState, aAgentStates }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "SetAgentState",
                3,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_SETAGENTACTIVITY:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->SetAgentActivity.dwAddressID, NULL },
                { "dwActivityID",   FT_DWORD,   pRequest->SetAgentActivity.dwActivityID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "SetAgentActivity",
                2,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTCAPS:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentCaps.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentCaps",
                1,
                fields
            };


// BUGBUG LINE_PROXYREQUEST: fill in agent caps?

            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTSTATUS:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentStatus.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentStatus",
                1,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_AGENTSPECIFIC:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,                FT_DWORD,   (DWORD) pRequest->AgentSpecific.dwAddressID, NULL },
                { "dwAgentExtensionIDIndex",    FT_DWORD,   (DWORD) pRequest->AgentSpecific.dwAgentExtensionIDIndex, NULL },
                { szdwSize,                     FT_SIZE,    (DWORD) pRequest->AgentSpecific.dwSize, NULL },
                { "Params",                     FT_OFFSET,  (DWORD) (pRequest->AgentSpecific.Params - (LPBYTE) pRequest), NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "AgentSpecific",
                4,
                fields
            };


            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentActivityList.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentActivityList",
                1,
                fields
            };


// BUGBUG LINE_PROXYREQUEST: fill in agent activity list?

            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        case LINEPROXYREQUEST_GETAGENTGROUPLIST:
        {
            STRUCT_FIELD fields[] =
            {
                { szdwAddressID,    FT_DWORD,   pRequest->GetAgentGroupList.dwAddressID, NULL }
            };
            STRUCT_FIELD_HEADER fieldHeader =
            {
                pRequest,
                "GetAgentGroupList",
                1,
                fields
            };


// BUGBUG LINE_PROXYREQUEST: fill in agent grp list?

            ShowStructByField (&fieldHeader, TRUE);

            break;
        }
        } // switch (pRequest->dwRequestType)

        break;
    }

#endif

    }
}


INT_PTR
CALLBACK
ParamsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD  i;

    typedef struct _DLG_INST_DATA
    {
        PFUNC_PARAM_HEADER  pParamsHeader;

        LRESULT             lLastSel;

        char                szComboText[MAX_STRING_PARAM_SIZE];

    } DLG_INST_DATA, *PDLG_INST_DATA;

    PDLG_INST_DATA  pDlgInstData = (PDLG_INST_DATA)
                        GetWindowLongPtr (hwnd, GWLP_USERDATA);

    static int icxList2, icyList2, icyEdit1;

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        //
        // Alloc a dlg instance data struct, init it, & save a ptr to it
        //

        pDlgInstData = (PDLG_INST_DATA) malloc (sizeof(DLG_INST_DATA));

        // BUGBUG if (!pDlgInstData)

        pDlgInstData->pParamsHeader = (PFUNC_PARAM_HEADER) lParam;
        pDlgInstData->lLastSel = -1;

        SetWindowLongPtr (hwnd, GWLP_USERDATA, (LONG_PTR) pDlgInstData);


        //
        // Stick all the param names in the listbox, & for each PT_DWORD
        // param save it's default value
        //

        for (i = 0; i < pDlgInstData->pParamsHeader->dwNumParams; i++)
        {
            SendDlgItemMessage(
                hwnd,
                IDC_LIST1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) pDlgInstData->pParamsHeader->aParams[i].szName
                );

            if (pDlgInstData->pParamsHeader->aParams[i].dwType == PT_DWORD)
            {
                pDlgInstData->pParamsHeader->aParams[i].u.dwDefValue =
                    pDlgInstData->pParamsHeader->aParams[i].dwValue;
            }
        }


        //
        // Set the dlg title as appropriate
        //

// help        if (pDlgInstData->pParamsHeader->FuncIndex == DefValues)
// help        {
// help            EnableWindow (GetDlgItem (hwnd, IDC_TB_HELP), FALSE);
// help        }

        SetWindowText(
            hwnd,
            aFuncNames[pDlgInstData->pParamsHeader->FuncIndex]
            );


        //
        // Limit the max text length for the combobox's edit field
        // (NOTE: A combobox ctrl actually has two child windows: a
        // edit ctrl & a listbox.  We need to get the hwnd of the
        // child edit ctrl & send it the LIMITTEXT msg.)
        //

        {
            HWND hwndChild =
                GetWindow (GetDlgItem (hwnd, IDC_COMBO1), GW_CHILD);


            while (hwndChild)
            {
                char buf[8];


                GetClassName (hwndChild, buf, 7);

                if (_stricmp (buf, "edit") == 0)
                {
                    break;
                }

                hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
            }

            SendMessage(
                hwndChild,
                EM_LIMITTEXT,
                (WPARAM) (gbWideStringParams ?
                    (MAX_STRING_PARAM_SIZE/2 - 1) : MAX_STRING_PARAM_SIZE - 1),
                0
                );
        }

        {
            RECT    rect;


            GetWindowRect (GetDlgItem (hwnd, IDC_LIST2), &rect);

            SetWindowPos(
                GetDlgItem (hwnd, IDC_LIST2),
                NULL,
                0,
                0,
                0,
                0,
                SWP_NOMOVE | SWP_NOZORDER
                );

            icxList2 = rect.right - rect.left;
            icyList2 = rect.bottom - rect.top;

            GetWindowRect (GetDlgItem (hwnd, 58), &rect);

            icyEdit1 = icyList2 - (rect.bottom - rect.top);
        }

        SendDlgItemMessage(
            hwnd,
            IDC_EDIT1,
            WM_SETFONT,
            (WPARAM) ghFixedFont,
            0
            );

        break;
    }
    case WM_COMMAND:
    {
        LRESULT             lLastSel      = pDlgInstData->lLastSel;
        char far           *lpszComboText = pDlgInstData->szComboText;
        PFUNC_PARAM_HEADER  pParamsHeader = pDlgInstData->pParamsHeader;


        switch (LOWORD(wParam))
        {
        case IDC_EDIT1:
        {
            if (HIWORD(wParam) == EN_CHANGE)
            {
                //
                // Don't allow the user to enter characters other than
                // 0-9, a-f, or A-F in the edit control (do this by
                // hiliting other letters and cutting them).
                //

                HWND    hwndEdit = GetDlgItem (hwnd, IDC_EDIT1);
                DWORD   dwLength, j;
                BYTE   *p;


                dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                if (dwLength  &&  (p = malloc (dwLength + 1)))
                {
                    GetWindowText (hwndEdit, p, dwLength + 1);

                    for (i = j = 0; i < dwLength ; i++, j++)
                    {
                        if (aHex[p[i]] == 255)
                        {
                            SendMessage(
                                hwndEdit,
                                EM_SETSEL,
                                (WPARAM) j,
                                (LPARAM) j + 1  // 0xfffffffe
                                );

                            SendMessage (hwndEdit, EM_REPLACESEL, 0, (LPARAM) "");
                            SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);

                            j--;
                        }
                    }

                    free (p);
                }
            }

            break;
        }
        case IDOK:

            if (lLastSel != -1)
            {
                //
                // Save val of currently selected param
                //

                char buf[MAX_STRING_PARAM_SIZE];


                i = GetDlgItemText (hwnd, IDC_COMBO1, buf, MAX_STRING_PARAM_SIZE-1);

                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_STRING:
                {
                    LRESULT lComboSel;


                    lComboSel = SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_GETCURSEL,
                        0,
                        0
                        );

                    if (lComboSel == 0) // "NULL pointer"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR) 0;
                    }
                    else if (lComboSel == 2) // "Invalid string pointer"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            -1;
                    }
                    else // "Valid string pointer"
                    {
                        strncpy(
                            pParamsHeader->aParams[lLastSel].u.buf,
                            buf,
                            MAX_STRING_PARAM_SIZE - 1
                            );

                        pParamsHeader->aParams[lLastSel].u.buf[MAX_STRING_PARAM_SIZE-1] = 0;

                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            pParamsHeader->aParams[lLastSel].u.buf;
                    }

                    break;
                }
                case PT_POINTER:
                {
                    //
                    // If there is any text in the "Buffer byte editor"
                    // window then retrieve it, convert it to hexadecimal,
                    // and copy it to the buffer
                    //

                    DWORD     dwLength;
                    BYTE     *p, *p2,
                             *pBuf = pParamsHeader->aParams[lLastSel].u.ptr;
                    HWND      hwndEdit = GetDlgItem (hwnd,IDC_EDIT1);


                    dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                    if (dwLength  &&  (p = malloc (dwLength + 1)))
                    {
                        GetWindowText (hwndEdit, p, dwLength + 1);
                        SetWindowText (hwndEdit, "");

                        p2 = p;

                        p[dwLength] = (BYTE) '0';
                        dwLength = (dwLength + 1) & 0xfffffffe;

                        for (i = 0; i < dwLength; i++, i++)
                        {
                            BYTE b;

                            b = aHex[*p] << 4;
                            p++;

                            b |= aHex[*p];
                            p++;

                            *pBuf = b;
                            pBuf++;
                        }

                        free (p2);
                    }

                    // fall thru to code below
                }
                case PT_DWORD:
                case PT_FLAGS:
                case PT_CALLPARAMS: // ??? BUGBUG
                case PT_FORWARDLIST: // ??? BUGBUG
                case PT_ORDINAL:
                {
                    if (!sscanf(
                            buf,
                            "%08lx",
                            &pParamsHeader->aParams[lLastSel].dwValue
                            ))
                    {
                        //
                        // Default to 0
                        //

                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }

                    break;
                }
                } // switch
            }

            free (pDlgInstData);
            EndDialog (hwnd, TRUE);
            break;

        case IDCANCEL:

            free (pDlgInstData);
            EndDialog (hwnd, FALSE);
            break;

// help        case IDC_TB_HELP:
// help
// help            MyWinHelp(
// help                hwnd,
// help                TRUE,
// help                HELP_PARTIALKEY,
// help                (DWORD) aFuncNames[pParamsHeader->FuncIndex]
// help                );
// help
// help            break;

        case IDC_LIST1:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                char buf[MAX_STRING_PARAM_SIZE] = "";
                LPCSTR lpstr = buf;
                LRESULT lSel =
                    SendDlgItemMessage (hwnd, IDC_LIST1, LB_GETCURSEL, 0, 0);


                if (lLastSel != -1)
                {
                    //
                    // Save the old param value
                    //

                    i = GetDlgItemText(
                        hwnd,
                        IDC_COMBO1,
                        buf,
                        MAX_STRING_PARAM_SIZE - 1
                        );

                    switch (pParamsHeader->aParams[lLastSel].dwType)
                    {
                    case PT_STRING:
                    {
                        LRESULT lComboSel;


                        lComboSel = SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_GETCURSEL,
                            0,
                            0
                            );

                        if (lComboSel == 0) // "NULL pointer"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR) 0;
                        }
                        else if (lComboSel == 2) // "Invalid string pointer"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR) -1;
                        }
                        else // "Valid string pointer" or no sel
                        {
                            strncpy(
                                pParamsHeader->aParams[lLastSel].u.buf,
                                buf,
                                MAX_STRING_PARAM_SIZE - 1
                                );

                            pParamsHeader->aParams[lLastSel].u.buf[MAX_STRING_PARAM_SIZE - 1] = 0;

                            pParamsHeader->aParams[lLastSel].dwValue =
                                (ULONG_PTR)
                                    pParamsHeader->aParams[lLastSel].u.buf;
                        }

                        break;
                    }
                    case PT_POINTER:
                    {
                        //
                        // If there is any text in the "Buffer byte editor"
                        // window then retrieve it, convert it to hexadecimal,
                        // and copy it to the buffer
                        //

                        DWORD     dwLength;
                        BYTE     *p, *p2,
                                 *pBuf = pParamsHeader->aParams[lLastSel].u.ptr;
                        HWND      hwndEdit = GetDlgItem (hwnd,IDC_EDIT1);


                        dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                        if (dwLength  &&  (p = malloc (dwLength + 1)))
                        {
                            GetWindowText (hwndEdit, p, dwLength + 1);
                            SetWindowText (hwndEdit, "");

                            p2 = p;

                            p[dwLength] = (BYTE) '0';
                            dwLength = (dwLength + 1) & 0xfffffffe;

                            for (i = 0; i < dwLength; i+= 2)
                            {
                                BYTE b;

                                b = aHex[*p] << 4;
                                p++;

                                b |= aHex[*p];
                                p++;

                                *pBuf = b;
                                pBuf++;
                            }

                            free (p2);
                        }

                        // fall thru to code below
                    }
                    case PT_DWORD:
                    case PT_FLAGS:
                    case PT_CALLPARAMS: // ??? BUGBUG
                    case PT_FORWARDLIST: // ??? BUGBUG
                    case PT_ORDINAL:
                    {
                        if (!sscanf(
                                buf,
                                "%08lx",
                                &pParamsHeader->aParams[lLastSel].dwValue
                                ))
                        {
                            //
                            // Default to 0
                            //

                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }

                        break;
                    }
                    } // switch
                }


                SendDlgItemMessage (hwnd, IDC_LIST2, LB_RESETCONTENT, 0, 0);
                SendDlgItemMessage (hwnd, IDC_COMBO1, CB_RESETCONTENT, 0, 0);

                {
                    int         icxL2 = 0, icyL2 = 0, icxE1 = 0, icyE1 = 0;
                    char FAR   *pszS1 = NULL, *pszS2 = NULL;
                    static char szBitFlags[] = "Bit flags:";
                    static char szOrdinalValues[] = "Ordinal values:";
                    static char szBufByteEdit[] =
                                    "Buffer byte editor (use 0-9, a-f, A-F)";

                    switch (pParamsHeader->aParams[lSel].dwType)
                    {
                    case PT_FLAGS:

                        icxL2 = icxList2;
                        icyL2 = icyList2;
                        pszS1 = szBitFlags;
                        break;

                    case PT_POINTER:

                        icxE1 = icxList2;
                        icyE1 = icyEdit1;;
                        pszS1 = szBufByteEdit;
                        pszS2 = gszEnterAs;
                        break;

                    case PT_ORDINAL:

                        icxL2 = icxList2;
                        icyL2 = icyList2;
                        pszS1 = szOrdinalValues;
                        break;

                    default:

                        break;
                    }

                    SetWindowPos(
                        GetDlgItem (hwnd, IDC_LIST2),
                        NULL,
                        0,
                        0,
                        icxL2,
                        icyL2,
                        SWP_NOMOVE | SWP_NOZORDER
                        );

                    SetWindowPos(
                        GetDlgItem (hwnd, IDC_EDIT1),
                        NULL,
                        0,
                        0,
                        icxE1,
                        icyE1,
                        SWP_NOMOVE | SWP_NOZORDER
                        );

                    SetDlgItemText (hwnd, 57, pszS1);
                    SetDlgItemText (hwnd, 58, pszS2);
                }

                switch (pParamsHeader->aParams[lSel].dwType)
                {
                case PT_STRING:
                {
                    char * aszOptions[] =
                    {
                        "NULL pointer",
                        "Valid string pointer",
                        "Invalid string pointer"
                    };


                    for (i = 0; i < 3; i++)
                    {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) aszOptions[i]
                            );
                    }

                    if (pParamsHeader->aParams[lSel].dwValue == 0)
                    {
                        i = 0;
                        buf[0] = 0;
                    }
                    else if (pParamsHeader->aParams[lSel].dwValue !=
                                (ULONG_PTR) -1)
                    {
                        i = 1;
                        lpstr = (LPCSTR) pParamsHeader->aParams[lSel].dwValue;
                    }
                    else
                    {
                        i = 2;
                        buf[0] = 0;
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_SETCURSEL,
                        (WPARAM) i,
                        0
                        );

                    break;
                }
                case PT_POINTER:
                case PT_CALLPARAMS: // ??? BUGBUG
                case PT_FORWARDLIST: // ??? BUGBUG
                {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "00000000"
                        );

                    sprintf(
                        buf,
                        "%08lx (valid pointer)",
                        pParamsHeader->aParams[lSel].u.dwDefValue
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) buf
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "ffffffff"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_DWORD:
                {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "0000000"
                        );

                    if (pParamsHeader->aParams[lSel].u.dwDefValue)
                    {
                        //
                        // Add the default val string to the combo
                        //

                        sprintf(
                            buf,
                            "%08lx",
                            pParamsHeader->aParams[lSel].u.dwDefValue
                            );

                        SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) buf
                            );
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "ffffffff"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_FLAGS:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].u.pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_LIST2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue &
                            pLookup[i].dwVal)
                        {
                            SendDlgItemMessage(
                                hwnd,
                                IDC_LIST2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "select none"
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "select all"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_ORDINAL:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    HWND hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].u.pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue ==
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    wsprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                } //switch

                SetDlgItemText (hwnd, IDC_COMBO1, lpstr);

                pDlgInstData->lLastSel = lSel;
            }
            break;

        case IDC_LIST2:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                PLOOKUP pLookup = (PLOOKUP)
                    pParamsHeader->aParams[lLastSel].u.pLookup;
                char buf[16];
                DWORD dwValue = 0;
                int far *ai;
                LONG    i;
                LRESULT lSelCount =
                    SendDlgItemMessage (hwnd, IDC_LIST2, LB_GETSELCOUNT, 0, 0);


                if (lSelCount)
                {
                    ai = (int far *) malloc ((size_t)lSelCount * sizeof(int));

                    SendDlgItemMessage(
                        hwnd,
                        IDC_LIST2,
                        LB_GETSELITEMS,
                        (WPARAM) lSelCount,
                        (LPARAM) ai
                        );

                    if (pParamsHeader->aParams[lLastSel].dwType == PT_FLAGS)
                    {
                        for (i = 0; i < lSelCount; i++)
                        {
                            dwValue |= pLookup[ai[i]].dwVal;
                        }
                    }
                    else // if (.dwType == PT_ORDINAL)
                    {
                        if (lSelCount == 1)
                        {
                            dwValue = pLookup[ai[0]].dwVal;
                        }
                        else if (lSelCount == 2)
                        {
                            //
                            // Figure out which item we need to de-select,
                            // since we're doing ords & only want 1 item
                            // selected at a time
                            //

                            GetDlgItemText (hwnd, IDC_COMBO1, buf, 16);

                            if (sscanf (buf, "%lx", &dwValue))
                            {
                                if (pLookup[ai[0]].dwVal == dwValue)
                                {
                                    SendDlgItemMessage(
                                        hwnd,
                                        IDC_LIST2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[0]
                                        );

                                    dwValue = pLookup[ai[1]].dwVal;
                                }
                                else
                                {
                                    SendDlgItemMessage(
                                        hwnd,
                                        IDC_LIST2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[1]
                                        );

                                    dwValue = pLookup[ai[0]].dwVal;
                                }
                            }
                            else
                            {
                                // BUGBUG de-select items???

                                dwValue = 0;
                            }
                        }
                    }

                    free (ai);
                }

                sprintf (buf, "%08lx", dwValue);
                SetDlgItemText (hwnd, IDC_COMBO1, buf);
            }
            break;

        case IDC_COMBO1:

#ifdef WIN32
            switch (HIWORD(wParam))
#else
            switch (HIWORD(lParam))
#endif
            {
            case CBN_SELCHANGE:
            {
                LRESULT lSel =
                    SendDlgItemMessage (hwnd, IDC_COMBO1, CB_GETCURSEL, 0, 0);


                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_POINTER:
                {
                    if (lSel == 1)
                    {
                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf(
                            lpszComboText,
                            "%08lx",
                            pParamsHeader->aParams[lLastSel].u.ptr
                            );

                        PostMessage (hwnd, WM_USER+55, 0, 0);
                    }

                    break;
                }
                case PT_FLAGS:
                {
                    BOOL bSelect = (lSel ? TRUE : FALSE);

                    SendDlgItemMessage(
                        hwnd,
                        IDC_LIST2,
                        LB_SETSEL,
                        (WPARAM) bSelect,
                        (LPARAM) -1
                        );

                    if (bSelect)
                    {
                        PLOOKUP pLookup = (PLOOKUP)
                                    pParamsHeader->aParams[lLastSel].u.pLookup;
                        DWORD   dwValue = 0;
                        int far *ai;
                        LONG    i;
                        LRESULT lSelCount =
                            SendDlgItemMessage (hwnd, IDC_LIST2, LB_GETSELCOUNT, 0, 0);


                        if (lSelCount)
                        {
                            ai = (int far *) malloc ((size_t)lSelCount * sizeof(int));

                            SendDlgItemMessage(
                                hwnd,
                                IDC_LIST2,
                                LB_GETSELITEMS,
                                (WPARAM) lSelCount,
                                (LPARAM) ai
                                );

                            for (i = 0; i < lSelCount; i++)
                            {
                                dwValue |= pLookup[ai[i]].dwVal;
                            }

                            free (ai);
                        }

                        sprintf (lpszComboText, "%08lx", dwValue);

                    }
                    else
                    {
                        strcpy (lpszComboText, "00000000");
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;
                }
                case PT_STRING:

                    if (lSel == 1)
                    {
                        strncpy(
                            lpszComboText,
                            pParamsHeader->aParams[lLastSel].u.buf,
                            MAX_STRING_PARAM_SIZE
                            );

                        lpszComboText[MAX_STRING_PARAM_SIZE-1] = 0;
                    }
                    else
                    {
                        lpszComboText[0] = 0;
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;

                case PT_DWORD:

                    break;

                case PT_CALLPARAMS:
                {
                    if (lSel == 1)
                    {
#if TAPI_2_0
                        LPLINECALLPARAMS lpCP = (gbWideStringParams ?
                                            lpCallParamsW : lpCallParams);
#else
                        LPLINECALLPARAMS lpCP = lpCallParams;
#endif
                        char *p = (char *) lpCP;

#if TAPI_2_0
                        char    asz[14][MAX_STRING_PARAM_SIZE];
                        LPDWORD pdwProxyRequests = (LPDWORD) (((LPBYTE) lpCP) +
                                    lpCP->dwDevSpecificOffset);
#else
                        char asz[7][MAX_STRING_PARAM_SIZE];
#endif
                        FUNC_PARAM params[] =
                        {
                            { "dwBearerMode",                   PT_FLAGS,  (ULONG_PTR) lpCP->dwBearerMode, aBearerModes },
                            { "dwMinRate",                      PT_DWORD,  (ULONG_PTR) lpCP->dwMinRate, NULL },
                            { "dwMaxRate",                      PT_DWORD,  (ULONG_PTR) lpCP->dwMaxRate, NULL },
                            { "dwMediaMode",                    PT_FLAGS,  (ULONG_PTR) lpCP->dwMediaMode, aMediaModes },
                            { "dwCallParamFlags",               PT_FLAGS,  (ULONG_PTR) lpCP->dwCallParamFlags, aCallParamFlags },
                            { "dwAddressMode",                  PT_ORDINAL,(ULONG_PTR) lpCP->dwAddressMode, aAddressModes },
                            { "dwAddressID",                    PT_DWORD,  (ULONG_PTR) lpCP->dwAddressID, NULL },
                            { "DIALPARAMS.dwDialPause",         PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwDialPause, NULL },
                            { "DIALPARAMS.dwDialSpeed",         PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwDialSpeed, NULL },
                            { "DIALPARAMS.dwDigitDuration",     PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwDigitDuration, NULL },
                            { "DIALPARAMS.dwWaitForDialtone",   PT_DWORD,  (ULONG_PTR) lpCP->DialParams.dwWaitForDialtone, NULL },
                            { "szOrigAddress",                  PT_STRING, (ULONG_PTR) asz[0], asz[0] },
                            { "szDisplayableAddress",           PT_STRING, (ULONG_PTR) asz[1], asz[1] },
                            { "szCalledParty",                  PT_STRING, (ULONG_PTR) asz[2], asz[2] },
                            { "szComment",                      PT_STRING, (ULONG_PTR) asz[3], asz[3] },
                            { "szUserUserInfo",                 PT_STRING, (ULONG_PTR) asz[4], asz[4] },
                            { "szHighLevelComp",                PT_STRING, (ULONG_PTR) asz[5], asz[5] },
                            { "szLowLevelComp",                 PT_STRING, (ULONG_PTR) asz[6], asz[6] }
#if TAPI_2_0
                             ,
                            { "dwPredictiveAutoTransferStates", PT_FLAGS,  (ULONG_PTR) lpCP->dwPredictiveAutoTransferStates, aCallStates },
                            { "szTargetAddress",                PT_STRING, (ULONG_PTR) asz[7], asz[7] },
                            { "szSendingFlowspec",              PT_STRING, (ULONG_PTR) asz[8], asz[8] },
                            { "szReceivingFlowspec",            PT_STRING, (ULONG_PTR) asz[9], asz[9] },
                            { "szDeviceClass",                  PT_STRING, (ULONG_PTR) asz[10], asz[10] },
                            { "szDeviceConfig",                 PT_STRING, (ULONG_PTR) asz[11], asz[11] },
                            { "szCallData",                     PT_STRING, (ULONG_PTR) asz[12], asz[12] },
                            { "dwNoAnswerTimeout",              PT_DWORD,  (ULONG_PTR) lpCP->dwNoAnswerTimeout, NULL },
                            { "szCallingPartyID",               PT_STRING, (ULONG_PTR) asz[13], asz[13] },
                            { "NumProxyRequests",               PT_DWORD,  (ULONG_PTR) lpCP->dwDevSpecificSize / 4, NULL },
                            { "  ProxyRequest1",                PT_ORDINAL,(ULONG_PTR) *pdwProxyRequests, aProxyRequests },
                            { "  ProxyRequest2",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 1), aProxyRequests },
                            { "  ProxyRequest3",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 2), aProxyRequests },
                            { "  ProxyRequest4",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 3), aProxyRequests },
                            { "  ProxyRequest5",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 4), aProxyRequests },
                            { "  ProxyRequest6",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 5), aProxyRequests },
                            { "  ProxyRequest7",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 6), aProxyRequests },
                            { "  ProxyRequest8",                PT_ORDINAL,(ULONG_PTR) *(pdwProxyRequests + 7), aProxyRequests }
#endif
                        };
                        FUNC_PARAM_HEADER paramsHeader =
                            { 0, lCallParams, params, NULL };
                        int     i;

                        LPDWORD apXxxSize[] =
                        {
                            &lpCP->dwOrigAddressSize,
                            &lpCP->dwDisplayableAddressSize,
                            &lpCP->dwCalledPartySize,
                            &lpCP->dwCommentSize,
                            &lpCP->dwUserUserInfoSize,
                            &lpCP->dwHighLevelCompSize,
                            &lpCP->dwLowLevelCompSize,
#if TAPI_2_0
                            &lpCP->dwTargetAddressSize,
                            &lpCP->dwSendingFlowspecSize,
                            &lpCP->dwReceivingFlowspecSize,
                            &lpCP->dwDeviceClassSize,
                            &lpCP->dwDeviceConfigSize,
                            &lpCP->dwCallDataSize,
                            &lpCP->dwCallingPartyIDSize,
#endif
                            NULL
                        };
                        static DWORD   dwAPIVersion, adwStrParamIndices[] =
                        {
                            11, 12, 13, 14, 15, 16, 17,
#if TAPI_2_0
                            19, 20, 21, 22, 23, 24, 26,
#endif
                            0
                        };



                        //
                        // Init the tmp string params
                        //

                        for (i = 0; apXxxSize[i]; i++)
                        {
                            if (*apXxxSize[i])
                            {
#if TAPI_2_0
                                if (gbWideStringParams)
                                {
                                    WideCharToMultiByte(
                                        CP_ACP,
                                        0,
                                        (LPCWSTR) (p + *(apXxxSize[i] + 1)),
                                        -1,
                                        asz[i],
                                        MAX_STRING_PARAM_SIZE,
                                        NULL,
                                        NULL
                                        );
                                }
                                else
                                {
                                    strcpy (asz[i], p + *(apXxxSize[i] + 1));
                                }
#else
                                strcpy (asz[i], p + *(apXxxSize[i] + 1));
#endif
                            }
                            else
                            {
                                asz[i][0] = 0;
                            }
                        }

                        if (pDlgInstData->pParamsHeader->FuncIndex == lOpen)
                        {
                            dwAPIVersion = (DWORD) pDlgInstData->
                                pParamsHeader->aParams[3].dwValue;
                        }
                        else
                        {
#if TAPI_2_0
                            dwAPIVersion = 0x00020000;
#else
                            dwAPIVersion = 0x00010004;
#endif
                        }

                        if (dwAPIVersion < 0x00020000)
                        {
                            paramsHeader.dwNumParams = 18;
                            apXxxSize[8] = NULL;
                        }
#if TAPI_2_0
                        else if (pDlgInstData->pParamsHeader->FuncIndex ==
                                    lOpen)
                        {
                            paramsHeader.dwNumParams = 36;
                        }
                        else
                        {
                            paramsHeader.dwNumParams = 27;
                        }
#endif
                        if (DialogBoxParam(
                                ghInst,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
                                hwnd,
                                ParamsDlgProc,
                                (LPARAM) &paramsHeader
                                ))
                        {
                            LPDWORD lpdwXxx = &lpCP->dwBearerMode;


                            //
                            // Save the DWORD params
                            //

                            for (i = 0; i < 11; i++)
                            {
                                *(lpdwXxx + i) = (DWORD) params[i].dwValue;
                            }
#if TAPI_2_0
                            if (paramsHeader.dwNumParams > 18)
                            {
                                lpCP->dwPredictiveAutoTransferStates = (DWORD)
                                    params[18].dwValue;
                                lpCP->dwNoAnswerTimeout = (DWORD)
                                    params[25].dwValue;

                                if (paramsHeader.dwNumParams > 27)
                                {
                                    lpCP->dwDevSpecificSize = (DWORD)
                                        (4 * params[27].dwValue);

                                    for (i = 0; i < 8; i++)
                                    {
                                        *(pdwProxyRequests + i) = (DWORD)
                                            params[28+i].dwValue;
                                    }
                                }
                            }
#endif

                            //
                            // Save the string params
                            //

                            for (i = 0; apXxxSize[i]; i++)
                            {
                                DWORD   length, index = adwStrParamIndices[i];


                                if (params[index].dwValue &&
                                    (params[index].dwValue != (ULONG_PTR) -1))
                                {
#if TAPI_2_0
                                    if (gbWideStringParams)
                                    {
                                        length = MultiByteToWideChar(
                                            CP_ACP,
                                            MB_PRECOMPOSED,
                                            (LPCSTR) asz[i],
                                            -1,
                                            (LPWSTR) (p + *(apXxxSize[i] + 1)),
                                                                     // offset
                                            MAX_STRING_PARAM_SIZE/2
                                            );

                                        length *= sizeof (WCHAR);
                                    }
                                    else
                                    {
                                        strcpy(
                                            p + *(apXxxSize[i] + 1), // offset
                                            asz[i]
                                            );

                                        length = (DWORD) strlen (asz[i]) + 1;
                                    }
#else
                                    strcpy(
                                        p + *(apXxxSize[i] + 1), // offset
                                        asz[i]
                                        );

                                    length = (DWORD) strlen (asz[i]) + 1;
#endif
                                }
                                else
                                {
                                    length = 0;
                                }

                                *apXxxSize[i] = length;
                            }
                        }

                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf (lpszComboText, "%08lx", lpCP);
                        PostMessage (hwnd, WM_USER+55, 0, 0);

                        pParamsHeader->aParams[lLastSel].dwValue =
                            (ULONG_PTR) lpCP;
                    }

                    break;
                }
                case PT_FORWARDLIST:
                {
                    if (lSel == 1)
                    {
                        char asz[MAX_LINEFORWARD_ENTRIES][2][MAX_STRING_PARAM_SIZE];
                        FUNC_PARAM params[] =
                        {
                            { "dwNumEntries",             PT_DWORD,  0, 0 },
                            { "[0].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[0].lpszCallerAddress",    PT_STRING, 0, asz[0][0] },
                            { "[0].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[0].lpszDestAddress",      PT_STRING, 0, asz[0][1] },
                            { "[1].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[1].lpszCallerAddress",    PT_STRING, 0, asz[1][0] },
                            { "[1].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[1].lpszDestAddress",      PT_STRING, 0, asz[1][1] },
                            { "[2].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[2].lpszCallerAddress",    PT_STRING, 0, asz[2][0] },
                            { "[2].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[2].lpszDestAddress",      PT_STRING, 0, asz[2][1] },
                            { "[3].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[3].lpszCallerAddress",    PT_STRING, 0, asz[3][0] },
                            { "[3].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[3].lpszDestAddress",      PT_STRING, 0, asz[3][1] },
                            { "[4].dwFowardMode",         PT_FLAGS,  0, aForwardModes },
                            { "[4].lpszCallerAddress",    PT_STRING, 0, asz[4][0] },
                            { "[4].dwDestCountryCode",    PT_DWORD,  0, 0 },
                            { "[4].lpszDestAddress",      PT_STRING, 0, asz[4][1] },

                        };
                        FUNC_PARAM_HEADER paramsHeader =
                            { 21, lForwardList, params, NULL };


                        memset(
                            asz,
                            0,
                            MAX_LINEFORWARD_ENTRIES*2*MAX_STRING_PARAM_SIZE
                            );

                        if (DialogBoxParam(
                                ghInst,
                                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
                                hwnd,
                                ParamsDlgProc,
                                (LPARAM) &paramsHeader
                                ))
                        {

                            LPLINEFORWARDLIST lpForwardList =
                                (LPLINEFORWARDLIST)
                                    pParamsHeader->aParams[lLastSel].u.ptr;
                            LPLINEFORWARD lpEntry = lpForwardList->ForwardList;
                            DWORD dwNumEntriesToInit =
                                (params[0].dwValue > MAX_LINEFORWARD_ENTRIES ?
                                    MAX_LINEFORWARD_ENTRIES :
                                    (DWORD) params[0].dwValue);
                            DWORD i, dwFixedSize = sizeof(LINEFORWARDLIST) +
                                (MAX_LINEFORWARD_ENTRIES-1)*sizeof(LINEFORWARD);


                            lpForwardList->dwNumEntries = (DWORD)
                                params[0].dwValue;

                            for (i = 0; i < dwNumEntriesToInit; i++)
                            {
                                lpEntry->dwForwardMode = (DWORD)
                                    params[1 + 4*i].dwValue;

                                if (params[2 + 4*i].dwValue &&
                                    params[2 + 4*i].dwValue != (ULONG_PTR) -1)
                                {
                                    lpEntry->dwCallerAddressSize =
                                        strlen (asz[i][0]) + 1;

                                    lpEntry->dwCallerAddressOffset =
                                        dwFixedSize +
                                            2*i*MAX_STRING_PARAM_SIZE;
#if TAPI_2_0
                                    if (gbWideStringParams)
                                    {
                                        lpEntry->dwCallerAddressSize *=
                                            sizeof (WCHAR);

                                        MultiByteToWideChar(
                                            CP_ACP,
                                            MB_PRECOMPOSED,
                                            (LPCSTR) asz[i][0],
                                            -1,
                                            (LPWSTR) ((char *) lpForwardList +
                                                lpEntry->dwCallerAddressOffset),
                                            MAX_STRING_PARAM_SIZE / 2
                                            );
                                    }
                                    else
                                    {
                                        strcpy(
                                            (char *) lpForwardList +
                                                lpEntry->dwCallerAddressOffset,
                                            asz[i][0]
                                            );
                                    }
#else
                                    strcpy(
                                        (char *) lpForwardList +
                                            lpEntry->dwCallerAddressOffset,
                                        asz[i][0]
                                        );
#endif
                                }

                                lpEntry->dwDestCountryCode = (DWORD)
                                    params[3 + 4*i].dwValue;

                                if (params[4 + 4*i].dwValue &&
                                    params[4 + 4*i].dwValue != (ULONG_PTR) -1)
                                {
                                    lpEntry->dwDestAddressSize =
                                        strlen (asz[i][1]) + 1;

                                    lpEntry->dwDestAddressOffset =
                                        dwFixedSize +
                                            (2*i + 1)*MAX_STRING_PARAM_SIZE;

#if TAPI_2_0
                                    if (gbWideStringParams)
                                    {
                                        lpEntry->dwDestAddressSize *=
                                            sizeof (WCHAR);

                                        MultiByteToWideChar(
                                            CP_ACP,
                                            MB_PRECOMPOSED,
                                            (LPCSTR) asz[i][1],
                                            -1,
                                            (LPWSTR) ((char *) lpForwardList +
                                                lpEntry->dwDestAddressOffset),
                                            MAX_STRING_PARAM_SIZE / 2
                                            );
                                    }
                                    else
                                    {
                                        strcpy(
                                            (char *) lpForwardList +
                                                lpEntry->dwDestAddressOffset,
                                            asz[i][1]
                                            );
                                    }
#else
                                    strcpy(
                                        (char *) lpForwardList +
                                            lpEntry->dwDestAddressOffset,
                                        asz[i][1]
                                        );
#endif
                                }

                                lpEntry++;
                            }
                        }

                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf(
                            lpszComboText,
                            "%08lx",
                            pParamsHeader->aParams[lLastSel].u.ptr
                            );

                        PostMessage (hwnd, WM_USER+55, 0, 0);
                    }

                    break;
                }
                case PT_ORDINAL:

                    //
                    // The only option here is "select none"
                    //

                    strcpy (lpszComboText, "00000000");
                    PostMessage (hwnd, WM_USER+55, 0, 0);
                    break;

                } // switch

                break;
            }
            case CBN_EDITCHANGE:
            {
                //
                // If user entered text in the edit field then copy the
                // text to our buffer
                //

                if (pParamsHeader->aParams[lLastSel].dwType == PT_STRING)
                {
                    char buf[MAX_STRING_PARAM_SIZE];


                    GetDlgItemText(
                        hwnd,
                        IDC_COMBO1,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    strncpy(
                        pParamsHeader->aParams[lLastSel].u.buf,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    pParamsHeader->aParams[lLastSel].u.buf
                        [MAX_STRING_PARAM_SIZE-1] = 0;
                }
                break;
            }
            } // switch

        } // switch

        break;
    }
    case WM_USER+55:

        SetDlgItemText (hwnd, IDC_COMBO1, pDlgInstData->szComboText);
        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch

    return 0;
}


INT_PTR
CALLBACK
IconDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static HICON hIcon;

    switch (msg)
    {
    case WM_INITDIALOG:

        hIcon = (HICON) lParam;

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
#ifdef WIN32
        MoveToEx (ps.hdc, 6, 6, (LPPOINT) NULL);
#else
        MoveTo (ps.hdc, 6, 6);
#endif
        LineTo (ps.hdc, 42, 6);
        LineTo (ps.hdc, 42, 42);
        LineTo (ps.hdc, 6, 42);
        LineTo (ps.hdc, 6, 6);
        DrawIcon (ps.hdc, 8, 8, hIcon);
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return 0;
}


INT_PTR
CALLBACK
UserButtonsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static int iButtonIndex;

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        int i;
        char buf[32];

        if (lParam)
        {
            //
            // The dlg was invoked because someone pressed a user button
            // that was uninitialized, so only allow chgs on this button
            //

            iButtonIndex = *((int *) lParam);

            _itoa (iButtonIndex + 1, buf, 10);

            SendDlgItemMessage(
                hwnd,
                IDC_LIST1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) buf
                );
        }
        else
        {
            //
            // The dlg was invoked because the user chose a menuitem,
            // so allow chgs on all buttons
            //

            iButtonIndex = MAX_USER_BUTTONS;

            for (i = 1; i <= MAX_USER_BUTTONS; i++)
            {
                _itoa (i, buf, 10);

                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_INSERTSTRING,
                    (WPARAM) -1,
                    (LPARAM) buf
                    );
            }

        }

        SendDlgItemMessage(
            hwnd,
            IDC_LIST1,
            LB_SETCURSEL,
            (WPARAM) 0,
            0
            );

        for (i = 0; aFuncNames[i]; i++)
        {
            SendDlgItemMessage(
                hwnd,
                IDC_LIST2,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) aFuncNames[i]
                );
        }

        SendDlgItemMessage(
            hwnd,
            IDC_LIST2,
            LB_INSERTSTRING,
            (WPARAM) -1,
            (LPARAM) "<none>"
            );

        if (!lParam)
        {
#ifdef WIN32
            wParam = (WPARAM) MAKELONG (0, LBN_SELCHANGE);
#else
            lParam = (LPARAM) MAKELONG (0, LBN_SELCHANGE);
#endif
            goto IDC_LIST1_selchange;
        }

        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            LRESULT lFuncSel;


            lFuncSel = SendDlgItemMessage(hwnd, IDC_LIST2, LB_GETCURSEL, 0, 0);

            if (lFuncSel == LB_ERR)
            {
                MessageBox (hwnd, "Select a function", "", MB_OK);
                break;
            }

            if (iButtonIndex == MAX_USER_BUTTONS)
            {
                iButtonIndex = (int) SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_GETCURSEL,
                    0,
                    0
                    );
            }

            aUserButtonFuncs[iButtonIndex] = (DWORD) lFuncSel;

            if (lFuncSel == MiscBegin)
            {
                //
                // User selected "<none>" option so nullify string
                //

                aUserButtonsText[iButtonIndex][0] = 0;
            }
            else
            {
                GetDlgItemText(
                    hwnd,
                    IDC_EDIT1,
                    (LPSTR) &aUserButtonsText[iButtonIndex],
                    MAX_USER_BUTTON_TEXT_SIZE - 1
                    );

                aUserButtonsText[iButtonIndex][MAX_USER_BUTTON_TEXT_SIZE - 1] =
                    0;
            }

            SetDlgItemText(
                ghwndMain,
                IDC_BUTTON13 + iButtonIndex,
                (LPSTR) &aUserButtonsText[iButtonIndex]
                );

            // Fall thru to IDCANCEL code
        }
        case IDCANCEL:

            EndDialog (hwnd, FALSE);
            break;

        case IDC_LIST1:

IDC_LIST1_selchange:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                LRESULT lButtonSel =
                    SendDlgItemMessage(hwnd, IDC_LIST1, LB_GETCURSEL, 0, 0);


                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_SETCURSEL,
                    (WPARAM) aUserButtonFuncs[lButtonSel],
                    0
                    );

                SetDlgItemText(
                    hwnd,
                    IDC_EDIT1,
                    aUserButtonsText[lButtonSel]
                    );
            }
            break;

        } // switch

        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\vars.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    vars.c

Abstract:

    Globals for TAPI Browser util.

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


#include <stdio.h>
#include "tb.h"

#ifdef WIN32
#define my_far
#else
#define my_far _far
#endif


PMYWIDGET   aWidgets = (PMYWIDGET) NULL;

FILE        *hLogFile = (FILE *) NULL;
HANDLE      ghInst;
HWND        ghwndMain, ghwndEdit, ghwndList1, ghwndList2;
BOOL        bShowParams = FALSE;
BOOL        gbDeallocateCall = FALSE;
BOOL        gbDisableHandleChecking;
LPVOID      pBigBuf;
DWORD       dwBigBufSize;
DWORD       dwNumPendingMakeCalls = 0;
DWORD       dwNumPendingDrops = 0;
DWORD       gdwNumLineDevs = 0;
DWORD       gdwNumPhoneDevs = 0;
BOOL        bDumpParams = FALSE;
BOOL        bTimeStamp;
DWORD       bNukeIdleMonitorCalls;
DWORD       bNukeIdleOwnedCalls;
DWORD       dwDumpStructsFlags;

LPLINECALLPARAMS    lpCallParams;

#if TAPI_2_0
BOOL        gbWideStringParams = FALSE;
LPLINECALLPARAMS    lpCallParamsW;
#endif

DWORD       aUserButtonFuncs[MAX_USER_BUTTONS];
char        aUserButtonsText[MAX_USER_BUTTONS][MAX_USER_BUTTON_TEXT_SIZE];

PMYLINEAPP  pLineAppSel;
PMYLINE     pLineSel;
PMYCALL     pCallSel, pCallSel2;
PMYPHONEAPP pPhoneAppSel;
PMYPHONE    pPhoneSel;

char my_far szDefAppName[MAX_STRING_PARAM_SIZE];
char my_far szDefUserUserInfo[MAX_STRING_PARAM_SIZE];
char my_far szDefDestAddress[MAX_STRING_PARAM_SIZE];
char my_far szDefLineDeviceClass[MAX_STRING_PARAM_SIZE];
char my_far szDefPhoneDeviceClass[MAX_STRING_PARAM_SIZE];

char far   *lpszDefAppName;
char far   *lpszDefUserUserInfo;
char far   *lpszDefDestAddress;
char far   *lpszDefLineDeviceClass;
char far   *lpszDefPhoneDeviceClass;

char my_far szTab[] = "  ";
char my_far szCurrVer[] = "1.1";


// help char my_far szTapiHlp[256] = "";
// help char my_far szTspiHlp[256] = "";

DWORD       dwDefAddressID;
DWORD       dwDefLineAPIVersion;
DWORD       dwDefBearerMode;
DWORD       dwDefCountryCode;
DWORD       dwDefLineDeviceID;
DWORD       dwDefLineExtVersion;
DWORD       dwDefMediaMode;
DWORD       dwDefLinePrivilege;
DWORD       dwDefPhoneAPIVersion;
DWORD       dwDefPhoneDeviceID;
DWORD       dwDefPhoneExtVersion;
DWORD       dwDefPhonePrivilege;

#if TAPI_2_0
HANDLE      ghCompletionPort;
#endif

char aAscii[] =
{
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126, 46,

     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46
};



LOOKUP my_far aAddressCapFlags[] =
{
    { LINEADDRCAPFLAGS_FWDNUMRINGS      ,"FWDNUMRINGS"      },
    { LINEADDRCAPFLAGS_PICKUPGROUPID    ,"PICKUPGROUPID"    },
    { LINEADDRCAPFLAGS_SECURE           ,"SECURE"           },
    { LINEADDRCAPFLAGS_BLOCKIDDEFAULT   ,"BLOCKIDDEFAULT"   },
    { LINEADDRCAPFLAGS_BLOCKIDOVERRIDE  ,"BLOCKIDOVERRIDE"  },
    { LINEADDRCAPFLAGS_DIALED           ,"DIALED"           },
    { LINEADDRCAPFLAGS_ORIGOFFHOOK      ,"ORIGOFFHOOK"      },
    { LINEADDRCAPFLAGS_DESTOFFHOOK      ,"DESTOFFHOOK"      },
    { LINEADDRCAPFLAGS_FWDCONSULT       ,"FWDCONSULT"       },
    { LINEADDRCAPFLAGS_SETUPCONFNULL    ,"SETUPCONFNULL"    },
    { LINEADDRCAPFLAGS_AUTORECONNECT    ,"AUTORECONNECT"    },
    { LINEADDRCAPFLAGS_COMPLETIONID     ,"COMPLETIONID"     },
    { LINEADDRCAPFLAGS_TRANSFERHELD     ,"TRANSFERHELD"     },
    { LINEADDRCAPFLAGS_TRANSFERMAKE     ,"TRANSFERMAKE"     },
    { LINEADDRCAPFLAGS_CONFERENCEHELD   ,"CONFERENCEHELD"   },
    { LINEADDRCAPFLAGS_CONFERENCEMAKE   ,"CONFERENCEMAKE"   },
    { LINEADDRCAPFLAGS_PARTIALDIAL      ,"PARTIALDIAL"      },
    { LINEADDRCAPFLAGS_FWDSTATUSVALID   ,"FWDSTATUSVALID"   },
    { LINEADDRCAPFLAGS_FWDINTEXTADDR    ,"FWDINTEXTADDR"    },
    { LINEADDRCAPFLAGS_FWDBUSYNAADDR    ,"FWDBUSYNAADDR"    },
    { LINEADDRCAPFLAGS_ACCEPTTOALERT    ,"ACCEPTTOALERT"    },
    { LINEADDRCAPFLAGS_CONFDROP         ,"CONFDROP"         },
    { LINEADDRCAPFLAGS_PICKUPCALLWAIT   ,"PICKUPCALLWAIT"   },
#if TAPI_2_0
    { LINEADDRCAPFLAGS_PREDICTIVEDIALER ,"PREDICTIVEDIALER" },
    { LINEADDRCAPFLAGS_QUEUE            ,"QUEUE"            },
    { LINEADDRCAPFLAGS_ROUTEPOINT       ,"ROUTEPOINT"       },
    { LINEADDRCAPFLAGS_HOLDMAKESNEW     ,"HOLDMAKESNEW"     },
    { LINEADDRCAPFLAGS_NOINTERNALCALLS  ,"NOINTERNALCALLS"  },
    { LINEADDRCAPFLAGS_NOEXTERNALCALLS  ,"NOEXTERNALCALLS"  },
    { LINEADDRCAPFLAGS_SETCALLINGID     ,"SETCALLINGID"     },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressModes[] =
{
    { LINEADDRESSMODE_ADDRESSID         ,"ADDRESSID"        },
    { LINEADDRESSMODE_DIALABLEADDR      ,"DIALABLEADDR"     },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressSharing[] =
{
    { LINEADDRESSSHARING_PRIVATE        ,"PRIVATE"          },
    { LINEADDRESSSHARING_BRIDGEDEXCL    ,"BRIDGEDEXCL"      },
    { LINEADDRESSSHARING_BRIDGEDNEW     ,"BRIDGEDNEW"       },
    { LINEADDRESSSHARING_BRIDGEDSHARED  ,"BRIDGEDSHARED"    },
    { LINEADDRESSSHARING_MONITORED      ,"MONITORED"        },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER            ,"OTHER"            },
    { LINEADDRESSSTATE_DEVSPECIFIC      ,"DEVSPECIFIC"      },
    { LINEADDRESSSTATE_INUSEZERO        ,"INUSEZERO"        },
    { LINEADDRESSSTATE_INUSEONE         ,"INUSEONE"         },
    { LINEADDRESSSTATE_INUSEMANY        ,"INUSEMANY"        },
    { LINEADDRESSSTATE_NUMCALLS         ,"NUMCALLS"         },
    { LINEADDRESSSTATE_FORWARD          ,"FORWARD"          },
    { LINEADDRESSSTATE_TERMINALS        ,"TERMINALS"        },
#if TAPI_1_1
    { LINEADDRESSSTATE_CAPSCHANGE       ,"CAPSCHANGE"       },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAddressFeatures[] =
{
    { LINEADDRFEATURE_FORWARD           ,"FORWARD"          },
    { LINEADDRFEATURE_MAKECALL          ,"MAKECALL"         },
    { LINEADDRFEATURE_PICKUP            ,"PICKUP"           },
    { LINEADDRFEATURE_SETMEDIACONTROL   ,"SETMEDIACONTROL"  },
    { LINEADDRFEATURE_SETTERMINAL       ,"SETTERMINAL"      },
    { LINEADDRFEATURE_SETUPCONF         ,"SETUPCONF"        },
    { LINEADDRFEATURE_UNCOMPLETECALL    ,"UNCOMPLETECALL"   },
    { LINEADDRFEATURE_UNPARK            ,"UNPARK"           },
#if TAPI_2_0
    { LINEADDRFEATURE_PICKUPHELD        ,"PICKUPHELD   "    },
    { LINEADDRFEATURE_PICKUPGROUP       ,"PICKUPGROUP  "    },
    { LINEADDRFEATURE_PICKUPDIRECT      ,"PICKUPDIRECT "    },
    { LINEADDRFEATURE_PICKUPWAITING     ,"PICKUPWAITING"    },
    { LINEADDRFEATURE_FORWARDFWD        ,"FORWARDFWD   "    },
    { LINEADDRFEATURE_FORWARDDND        ,"FORWARDDND   "    },
#endif
    { 0xffffffff                        ,""                 }
};

#ifdef TAPI_2_0
LOOKUP my_far aAgentStates[] =
{
    { LINEAGENTSTATE_LOGGEDOFF          ,"LOGGEDOFF"        },
    { LINEAGENTSTATE_NOTREADY           ,"NOTREADY"         },
    { LINEAGENTSTATE_READY              ,"READY"            },
    { LINEAGENTSTATE_BUSYACD            ,"BUSYACD"          },
    { LINEAGENTSTATE_BUSYINCOMING       ,"BUSYINCOMING"     },
    { LINEAGENTSTATE_BUSYOUTBOUND       ,"BUSYOUTBOUND"     },
    { LINEAGENTSTATE_BUSYOTHER          ,"BUSYOTHER"        },
    { LINEAGENTSTATE_WORKINGAFTERCALL   ,"WORKINGAFTERCALL" },
    { LINEAGENTSTATE_UNKNOWN            ,"UNKNOWN"          },
    { LINEAGENTSTATE_UNAVAIL            ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAgentStatus[] =
{
    { LINEAGENTSTATUS_GROUP             ,"GROUP"            },
    { LINEAGENTSTATUS_STATE             ,"STATE"            },
    { LINEAGENTSTATUS_NEXTSTATE         ,"NEXTSTATE"        },
    { LINEAGENTSTATUS_ACTIVITY          ,"ACTIVITY"         },
    { LINEAGENTSTATUS_ACTIVITYLIST      ,"ACTIVITYLIST"     },
    { LINEAGENTSTATUS_GROUPLIST         ,"GROUPLIST"        },
    { LINEAGENTSTATUS_CAPSCHANGE        ,"CAPSCHANGE"       },
    { LINEAGENTSTATUS_VALIDSTATES       ,"VALIDSTATES"      },
    { LINEAGENTSTATUS_VALIDNEXTSTATES   ,"VALIDNEXTSTATES"  },
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aAnswerModes[] =
{
    { LINEANSWERMODE_NONE               ,"NONE"             },
    { LINEANSWERMODE_DROP               ,"DROP"             },
    { LINEANSWERMODE_HOLD               ,"HOLD"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aAPIVersions[] =
{
    { 0x00010003                        ,"TAPI 1.0"         },
#if TAPI_1_1
    { 0x00010004                        ,"TAPI 1.4"         },
#if TAPI_2_0
    { 0x00020000                        ,"TAPI 2.0"         },
#if TAPI_2_1
    { 0x00020001                        ,"TAPI 2.1"         },
#if TAPI_2_2
    { 0x00020002                        ,"TAPI 2.2"         },
#endif
#endif
#endif
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aBearerModes[] =
{
    { LINEBEARERMODE_VOICE              ,"VOICE"            },
    { LINEBEARERMODE_SPEECH             ,"SPEECH"           },
    { LINEBEARERMODE_MULTIUSE           ,"MULTIUSE"         },
    { LINEBEARERMODE_DATA               ,"DATA"             },
    { LINEBEARERMODE_ALTSPEECHDATA      ,"ALTSPEECHDATA"    },
    { LINEBEARERMODE_NONCALLSIGNALING   ,"NONCALLSIGNALING" },
#if TAPI_1_1
    { LINEBEARERMODE_PASSTHROUGH        ,"PASSTHROUGH"      },
#if TAPI_2_0
    { LINEBEARERMODE_RESTRICTEDDATA     ,"RESTRICTEDDATA"   },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aBusyModes[] =
{
    { LINEBUSYMODE_STATION              ,"STATION"          },
    { LINEBUSYMODE_TRUNK                ,"TRUNK"            },
    { LINEBUSYMODE_UNKNOWN              ,"UNKNOWN"          },
    { LINEBUSYMODE_UNAVAIL              ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallComplConds[] =
{
    { LINECALLCOMPLCOND_BUSY            ,"BUSY"             },
    { LINECALLCOMPLCOND_NOANSWER        ,"NOANSWER"         },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallComplModes[] =
{
    { LINECALLCOMPLMODE_CAMPON          ,"CAMPON"           },
    { LINECALLCOMPLMODE_CALLBACK        ,"CALLBACK"         },
    { LINECALLCOMPLMODE_INTRUDE         ,"INTRUDE"          },
    { LINECALLCOMPLMODE_MESSAGE         ,"MESSAGE"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallFeatures[] =
{
    { LINECALLFEATURE_ACCEPT            ,"ACCEPT"           },
    { LINECALLFEATURE_ADDTOCONF         ,"ADDTOCONF"        },
    { LINECALLFEATURE_ANSWER            ,"ANSWER"           },
    { LINECALLFEATURE_BLINDTRANSFER     ,"BLINDTRANSFER"    },
    { LINECALLFEATURE_COMPLETECALL      ,"COMPLETECALL"     },
    { LINECALLFEATURE_COMPLETETRANSF    ,"COMPLETETRANSF"   },
    { LINECALLFEATURE_DIAL              ,"DIAL"             },
    { LINECALLFEATURE_DROP              ,"DROP"             },
    { LINECALLFEATURE_GATHERDIGITS      ,"GATHERDIGITS"     },
    { LINECALLFEATURE_GENERATEDIGITS    ,"GENERATEDIGITS"   },
    { LINECALLFEATURE_GENERATETONE      ,"GENERATETONE"     },
    { LINECALLFEATURE_HOLD              ,"HOLD"             },
    { LINECALLFEATURE_MONITORDIGITS     ,"MONITORDIGITS"    },
    { LINECALLFEATURE_MONITORMEDIA      ,"MONITORMEDIA"     },
    { LINECALLFEATURE_MONITORTONES      ,"MONITORTONES"     },
    { LINECALLFEATURE_PARK              ,"PARK"             },
    { LINECALLFEATURE_PREPAREADDCONF    ,"PREPAREADDCONF"   },
    { LINECALLFEATURE_REDIRECT          ,"REDIRECT"         },
    { LINECALLFEATURE_REMOVEFROMCONF    ,"REMOVEFROMCONF"   },
    { LINECALLFEATURE_SECURECALL        ,"SECURECALL"       },
    { LINECALLFEATURE_SENDUSERUSER      ,"SENDUSERUSER"     },
    { LINECALLFEATURE_SETCALLPARAMS     ,"SETCALLPARAMS"    },
    { LINECALLFEATURE_SETMEDIACONTROL   ,"SETMEDIACONTROL"  },
    { LINECALLFEATURE_SETTERMINAL       ,"SETTERMINAL"      },
    { LINECALLFEATURE_SETUPCONF         ,"SETUPCONF"        },
    { LINECALLFEATURE_SETUPTRANSFER     ,"SETUPTRANSFER"    },
    { LINECALLFEATURE_SWAPHOLD          ,"SWAPHOLD"         },
    { LINECALLFEATURE_UNHOLD            ,"UNHOLD"           },
#if TAPI_1_1
    { LINECALLFEATURE_RELEASEUSERUSERINFO   ,"RELEASEUSERUSERINFO"  },
#if TAPI_2_0
    { LINECALLFEATURE_SETTREATMENT      ,"SETTREATMENT"     },
    { LINECALLFEATURE_SETQOS            ,"SETQOS"           },
    { LINECALLFEATURE_SETCALLDATA       ,"SETCALLDATA"      },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aCallFeatures2[] =
{
    { LINECALLFEATURE2_NOHOLDCONFERENCE ,"NOHOLDCONFERENCE" },
    { LINECALLFEATURE2_ONESTEPTRANSFER  ,"ONESTEPTRANSFER " },
    { LINECALLFEATURE2_COMPLCAMPON      ,"COMPLCAMPON"      },
    { LINECALLFEATURE2_COMPLCALLBACK    ,"COMPLCALLBACK"    },
    { LINECALLFEATURE2_COMPLINTRUDE     ,"COMPLINTRUDE"     },
    { LINECALLFEATURE2_COMPLMESSAGE     ,"COMPLMESSAGE"     },
    { LINECALLFEATURE2_TRANSFERNORM     ,"TRANSFERNORM"     },
    { LINECALLFEATURE2_TRANSFERCONF     ,"TRANSFERCONF"     },
    { LINECALLFEATURE2_PARKDIRECT       ,"PARKDIRECT"       },
    { LINECALLFEATURE2_PARKNONDIRECT    ,"PARKNONDIRECT"    },

    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER           ,"OTHER"            },
    { LINECALLINFOSTATE_DEVSPECIFIC     ,"DEVSPECIFIC"      },
    { LINECALLINFOSTATE_BEARERMODE      ,"BEARERMODE"       },
    { LINECALLINFOSTATE_RATE            ,"RATE"             },
    { LINECALLINFOSTATE_MEDIAMODE       ,"MEDIAMODE"        },
    { LINECALLINFOSTATE_APPSPECIFIC     ,"APPSPECIFIC"      },
    { LINECALLINFOSTATE_CALLID          ,"CALLID"           },
    { LINECALLINFOSTATE_RELATEDCALLID   ,"RELATEDCALLID"    },
    { LINECALLINFOSTATE_ORIGIN          ,"ORIGIN"           },
    { LINECALLINFOSTATE_REASON          ,"REASON"           },
    { LINECALLINFOSTATE_COMPLETIONID    ,"COMPLETIONID"     },
    { LINECALLINFOSTATE_NUMOWNERINCR    ,"NUMOWNERINCR"     },
    { LINECALLINFOSTATE_NUMOWNERDECR    ,"NUMOWNERDECR"     },
    { LINECALLINFOSTATE_NUMMONITORS     ,"NUMMONITORS"      },
    { LINECALLINFOSTATE_TRUNK           ,"TRUNK"            },
    { LINECALLINFOSTATE_CALLERID        ,"CALLERID"         },
    { LINECALLINFOSTATE_CALLEDID        ,"CALLEDID"         },
    { LINECALLINFOSTATE_CONNECTEDID     ,"CONNECTEDID"      },
    { LINECALLINFOSTATE_REDIRECTIONID   ,"REDIRECTIONID"    },
    { LINECALLINFOSTATE_REDIRECTINGID   ,"REDIRECTINGID"    },
    { LINECALLINFOSTATE_DISPLAY         ,"DISPLAY"          },
    { LINECALLINFOSTATE_USERUSERINFO    ,"USERUSERINFO"     },
    { LINECALLINFOSTATE_HIGHLEVELCOMP   ,"HIGHLEVELCOMP"    },
    { LINECALLINFOSTATE_LOWLEVELCOMP    ,"LOWLEVELCOMP"     },
    { LINECALLINFOSTATE_CHARGINGINFO    ,"CHARGINGINFO"     },
    { LINECALLINFOSTATE_TERMINAL        ,"TERMINAL"         },
    { LINECALLINFOSTATE_DIALPARAMS      ,"DIALPARAMS"       },
    { LINECALLINFOSTATE_MONITORMODES    ,"MONITORMODES"     },
#if TAPI_2_0
    { LINECALLINFOSTATE_TREATMENT       ,"TREATMENT"        },
    { LINECALLINFOSTATE_QOS             ,"QOS"              },
    { LINECALLINFOSTATE_CALLDATA        ,"CALLDATA"         },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallOrigins[] =
{
    { LINECALLORIGIN_OUTBOUND           ,"OUTBOUND"         },
    { LINECALLORIGIN_INTERNAL           ,"INTERNAL"         },
    { LINECALLORIGIN_EXTERNAL           ,"EXTERNAL"         },
    { LINECALLORIGIN_UNKNOWN            ,"UNKNOWN"          },
    { LINECALLORIGIN_UNAVAIL            ,"UNAVAIL"          },
    { LINECALLORIGIN_CONFERENCE         ,"CONFERENCE"       },
#if TAPI_1_1
    { LINECALLORIGIN_INBOUND            ,"INBOUND"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallParamFlags[] =
{
    { LINECALLPARAMFLAGS_SECURE         ,"SECURE"           },
    { LINECALLPARAMFLAGS_IDLE           ,"IDLE"             },
    { LINECALLPARAMFLAGS_BLOCKID        ,"BLOCKID"          },
    { LINECALLPARAMFLAGS_ORIGOFFHOOK    ,"ORIGOFFHOOK"      },
    { LINECALLPARAMFLAGS_DESTOFFHOOK    ,"DESTOFFHOOK"      },
#if TAPI_2_0
    { LINECALLPARAMFLAGS_NOHOLDCONFERENCE   ,"NOHOLDCONFERENCE" },
    { LINECALLPARAMFLAGS_PREDICTIVEDIAL ,"PREDICTIVEDIAL"   },
    { LINECALLPARAMFLAGS_ONESTEPTRANSFER,"ONESTEPTRANSFER"  },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallerIDFlags[] =
{
    { LINECALLPARTYID_BLOCKED           ,"BLOCKED"          },
    { LINECALLPARTYID_OUTOFAREA         ,"OUTOFAREA"        },
    { LINECALLPARTYID_NAME              ,"NAME"             },
    { LINECALLPARTYID_ADDRESS           ,"ADDRESS"          },
    { LINECALLPARTYID_PARTIAL           ,"PARTIAL"          },
    { LINECALLPARTYID_UNKNOWN           ,"UNKNOWN"          },
    { LINECALLPARTYID_UNAVAIL           ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallPrivileges[] =
{
    { LINECALLPRIVILEGE_NONE            ,"NONE"             },
    { LINECALLPRIVILEGE_MONITOR         ,"MONITOR"          },
    { LINECALLPRIVILEGE_OWNER           ,"OWNER"            },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallReasons[] =
{
    { LINECALLREASON_DIRECT             ,"DIRECT"           },
    { LINECALLREASON_FWDBUSY            ,"FWDBUSY"          },
    { LINECALLREASON_FWDNOANSWER        ,"FWDNOANSWER"      },
    { LINECALLREASON_FWDUNCOND          ,"FWDUNCOND"        },
    { LINECALLREASON_PICKUP             ,"PICKUP"           },
    { LINECALLREASON_UNPARK             ,"UNPARK"           },
    { LINECALLREASON_REDIRECT           ,"REDIRECT"         },
    { LINECALLREASON_CALLCOMPLETION     ,"CALLCOMPLETION"   },
    { LINECALLREASON_TRANSFER           ,"TRANSFER"         },
    { LINECALLREASON_REMINDER           ,"REMINDER"         },
    { LINECALLREASON_UNKNOWN            ,"UNKNOWN"          },
    { LINECALLREASON_UNAVAIL            ,"UNAVAIL"          },
#if TAPI_1_1
    { LINECALLREASON_INTRUDE            ,"INTRUDE"          },
    { LINECALLREASON_PARKED             ,"PARKED"           },
#if TAPI_2_0
    { LINECALLREASON_CAMPEDON           ,"CAMPEDON"         },
    { LINECALLREASON_ROUTEREQUEST       ,"ROUTEREQUEST"     },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallSelects[] =
{
    { LINECALLSELECT_LINE               ,"LINE"             },
    { LINECALLSELECT_ADDRESS            ,"ADDRESS"          },
    { LINECALLSELECT_CALL               ,"CALL"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aCallStates[] =
{
    { LINECALLSTATE_IDLE                ,"IDLE"             },
    { LINECALLSTATE_OFFERING            ,"OFFERING"         },
    { LINECALLSTATE_ACCEPTED            ,"ACCEPTED"         },
    { LINECALLSTATE_DIALTONE            ,"DIALTONE"         },
    { LINECALLSTATE_DIALING             ,"DIALING"          },
    { LINECALLSTATE_RINGBACK            ,"RINGBACK"         },
    { LINECALLSTATE_BUSY                ,"BUSY"             },
    { LINECALLSTATE_SPECIALINFO         ,"SPECIALINFO"      },
    { LINECALLSTATE_CONNECTED           ,"CONNECTED"        },
    { LINECALLSTATE_PROCEEDING          ,"PROCEEDING"       },
    { LINECALLSTATE_ONHOLD              ,"ONHOLD"           },
    { LINECALLSTATE_CONFERENCED         ,"CONFERENCED"      },
    { LINECALLSTATE_ONHOLDPENDCONF      ,"ONHOLDPENDCONF"   },
    { LINECALLSTATE_ONHOLDPENDTRANSFER  ,"ONHOLDPENDTRANSFER" },
    { LINECALLSTATE_DISCONNECTED        ,"DISCONNECTED"     },
    { LINECALLSTATE_UNKNOWN             ,"UNKNOWN"          },
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aCallTreatments[] =
{
    { LINECALLTREATMENT_SILENCE         ,"SILENCE"          },
    { LINECALLTREATMENT_RINGBACK        ,"RINGBACK"         },
    { LINECALLTREATMENT_BUSY            ,"BUSY"             },
    { LINECALLTREATMENT_MUSIC           ,"MUSIC"            },
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aCardOptions[] =
{
#if TAPI_1_1
    { LINECARDOPTION_PREDEFINED         ,"PREDEFINED"       },
    { LINECARDOPTION_HIDDEN             ,"HIDDEN"           },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aConnectedModes[] =
{
#if TAPI_1_1
    { LINECONNECTEDMODE_ACTIVE          ,"ACTIVE"           },
    { LINECONNECTEDMODE_INACTIVE        ,"INACTIVE"         },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDevCapsFlags[] =
{
    { LINEDEVCAPFLAGS_CROSSADDRCONF     ,"CROSSADDRCONF"    },
    { LINEDEVCAPFLAGS_HIGHLEVCOMP       ,"HIGHLEVCOMP"      },
    { LINEDEVCAPFLAGS_LOWLEVCOMP        ,"LOWLEVCOMP"       },
    { LINEDEVCAPFLAGS_MEDIACONTROL      ,"MEDIACONTROL"     },
    { LINEDEVCAPFLAGS_MULTIPLEADDR      ,"MULTIPLEADDR"     },
    { LINEDEVCAPFLAGS_CLOSEDROP         ,"CLOSEDROP"        },
    { LINEDEVCAPFLAGS_DIALBILLING       ,"DIALBILLING"      },
    { LINEDEVCAPFLAGS_DIALQUIET         ,"DIALQUIET"        },
    { LINEDEVCAPFLAGS_DIALDIALTONE      ,"DIALDIALTONE"     },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLineDevStatusFlags[] =
{
    { LINEDEVSTATUSFLAGS_CONNECTED      ,"CONNECTED"        },
    { LINEDEVSTATUSFLAGS_MSGWAIT        ,"MSGWAIT"          },
    { LINEDEVSTATUSFLAGS_INSERVICE      ,"INSERVICE"        },
    { LINEDEVSTATUSFLAGS_LOCKED         ,"LOCKED"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDialToneModes[] =
{
    { LINEDIALTONEMODE_NORMAL           ,"NORMAL"           },
    { LINEDIALTONEMODE_SPECIAL          ,"SPECIAL"          },
    { LINEDIALTONEMODE_INTERNAL         ,"INTERNAL"         },
    { LINEDIALTONEMODE_EXTERNAL         ,"EXTERNAL"         },
    { LINEDIALTONEMODE_UNKNOWN          ,"UNKNOWN"          },
    { LINEDIALTONEMODE_UNAVAIL          ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDigitModes[] =
{
    { LINEDIGITMODE_PULSE               ,"PULSE"            },
    { LINEDIGITMODE_DTMF                ,"DTMF"             },
    { LINEDIGITMODE_DTMFEND             ,"DTMFEND"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aDisconnectModes[] =
{
    { LINEDISCONNECTMODE_NORMAL         ,"NORMAL"           },
    { LINEDISCONNECTMODE_UNKNOWN        ,"UNKNOWN"          },
    { LINEDISCONNECTMODE_REJECT         ,"REJECT"           },
    { LINEDISCONNECTMODE_PICKUP         ,"PICKUP"           },
    { LINEDISCONNECTMODE_FORWARDED      ,"FORWARDED"        },
    { LINEDISCONNECTMODE_BUSY           ,"BUSY"             },
    { LINEDISCONNECTMODE_NOANSWER       ,"NOANSWER"         },
    { LINEDISCONNECTMODE_BADADDRESS     ,"BADADDRESS"       },
    { LINEDISCONNECTMODE_UNREACHABLE    ,"UNREACHABLE"      },
    { LINEDISCONNECTMODE_CONGESTION     ,"CONGESTION"       },
    { LINEDISCONNECTMODE_INCOMPATIBLE   ,"INCOMPATIBLE"     },
    { LINEDISCONNECTMODE_UNAVAIL        ,"UNAVAIL"          },
#if TAPI_1_1
    { LINEDISCONNECTMODE_NODIALTONE     ,"NODIALTONE"       },
#if TAPI_2_0
    { LINEDISCONNECTMODE_NUMBERCHANGED  ,"NUMBERCHANGED"    },
    { LINEDISCONNECTMODE_OUTOFORDER     ,"OUTOFORDER"       },
    { LINEDISCONNECTMODE_TEMPFAILURE    ,"TEMPFAILURE"      },
    { LINEDISCONNECTMODE_QOSUNAVAIL     ,"QOSUNAVAIL"       },
    { LINEDISCONNECTMODE_BLOCKED        ,"BLOCKED"          },
    { LINEDISCONNECTMODE_DONOTDISTURB   ,"DONOTDISTURB"     },
#endif
#endif
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aLineInitExOptions[] =
{
    { LINEINITIALIZEEXOPTION_USEHIDDENWINDOW
                                        ,"USEHIDDENWINDOW"  },
    { LINEINITIALIZEEXOPTION_USEEVENT   ,"USEEVENT"         },
    { LINEINITIALIZEEXOPTION_USECOMPLETIONPORT
                                        ,"USECOMPLETIONPORT"},
    { 0xffffffff                        ,""                 }
};
#endif

#if TAPI_2_0
LOOKUP my_far aPhoneInitExOptions[] =
{
    { PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW
                                        ,"USEHIDDENWINDOW"  },
    { PHONEINITIALIZEEXOPTION_USEEVENT   ,"USEEVENT"         },
    { PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT
                                        ,"USECOMPLETIONPORT"},
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aLineFeatures[] =
{
    { LINEFEATURE_DEVSPECIFIC           ,"DEVSPECIFIC"      },
    { LINEFEATURE_DEVSPECIFICFEAT       ,"DEVSPECIFICFEAT"  },
    { LINEFEATURE_FORWARD               ,"FORWARD"          },
    { LINEFEATURE_MAKECALL              ,"MAKECALL"         },
    { LINEFEATURE_SETMEDIACONTROL       ,"SETMEDIACONTROL"  },
    { LINEFEATURE_SETTERMINAL           ,"SETTERMINAL"      },
#if TAPI_2_0
    { LINEFEATURE_SETDEVSTATUS          ,"SETDEVSTATUS"     },
    { LINEFEATURE_FORWARDFWD            ,"FORWARDFWD"       },
    { LINEFEATURE_FORWARDDND            ,"FORWARDDND"       },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aForwardModes[] =
{
    { LINEFORWARDMODE_UNCOND            ,"UNCOND"           },
    { LINEFORWARDMODE_UNCONDINTERNAL    ,"UNCONDINTERNAL"   },
    { LINEFORWARDMODE_UNCONDEXTERNAL    ,"UNCONDEXTERNAL"   },
    { LINEFORWARDMODE_UNCONDSPECIFIC    ,"UNCONDSPECIFIC"   },
    { LINEFORWARDMODE_BUSY              ,"BUSY"             },
    { LINEFORWARDMODE_BUSYINTERNAL      ,"BUSYINTERNAL"     },
    { LINEFORWARDMODE_BUSYEXTERNAL      ,"BUSYEXTERNAL"     },
    { LINEFORWARDMODE_BUSYSPECIFIC      ,"BUSYSPECIFIC"     },
    { LINEFORWARDMODE_NOANSW            ,"NOANSW"           },
    { LINEFORWARDMODE_NOANSWINTERNAL    ,"NOANSWINTERNAL"   },
    { LINEFORWARDMODE_NOANSWEXTERNAL    ,"NOANSWEXTERNAL"   },
    { LINEFORWARDMODE_NOANSWSPECIFIC    ,"NOANSWSPECIFIC"   },
    { LINEFORWARDMODE_BUSYNA            ,"BUSYNA"           },
    { LINEFORWARDMODE_BUSYNAINTERNAL    ,"BUSYNAINTERNAL"   },
    { LINEFORWARDMODE_BUSYNAEXTERNAL    ,"BUSYNAEXTERNAL"   },
    { LINEFORWARDMODE_BUSYNASPECIFIC    ,"BUSYNASPECIFIC"   },
#if TAPI_1_1
    { LINEFORWARDMODE_UNKNOWN           ,"UNKNOWN"          },
    { LINEFORWARDMODE_UNAVAIL           ,"UNAVAIL"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aGatherTerms[] =
{
    { LINEGATHERTERM_BUFFERFULL         ,"BUFFERFULL"       },
    { LINEGATHERTERM_TERMDIGIT          ,"TERMDIGIT"        },
    { LINEGATHERTERM_FIRSTTIMEOUT       ,"FIRSTTIMEOUT"     },
    { LINEGATHERTERM_INTERTIMEOUT       ,"INTERTIMEOUT"     },
    { LINEGATHERTERM_CANCEL             ,"CANCEL"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aGenerateTerms[] =
{
    { LINEGENERATETERM_DONE             ,"DONE"             },
    { LINEGENERATETERM_CANCEL           ,"CANCEL"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP aLineOpenOptions[] =
{
    { LINECALLPRIVILEGE_NONE            ,"NONE"             },
    { LINECALLPRIVILEGE_MONITOR         ,"MONITOR"          },
    { LINECALLPRIVILEGE_OWNER           ,"OWNER"            },
#if TAPI_2_0
    { LINEOPENOPTION_PROXY              ,"PROXY"            },
    { LINEOPENOPTION_SINGLEADDRESS      ,"SINGLEADDRESS"    },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLineRoamModes[] =
{
    { LINEROAMMODE_UNKNOWN              ,"UNKNOWN"          },
    { LINEROAMMODE_UNAVAIL              ,"UNAVAIL"          },
    { LINEROAMMODE_HOME                 ,"HOME"             },
    { LINEROAMMODE_ROAMA                ,"ROAMA"            },
    { LINEROAMMODE_ROAMB                ,"ROAMB"            },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLineStates[] =
{
    { LINEDEVSTATE_OTHER                ,"OTHER"            },
    { LINEDEVSTATE_RINGING              ,"RINGING"          },
    { LINEDEVSTATE_CONNECTED            ,"CONNECTED"        },
    { LINEDEVSTATE_DISCONNECTED         ,"DISCONNECTED"     },
    { LINEDEVSTATE_MSGWAITON            ,"MSGWAITON"        },
    { LINEDEVSTATE_MSGWAITOFF           ,"MSGWAITOFF"       },
    { LINEDEVSTATE_INSERVICE            ,"INSERVICE"        },
    { LINEDEVSTATE_OUTOFSERVICE         ,"OUTOFSERVICE"     },
    { LINEDEVSTATE_MAINTENANCE          ,"MAINTENANCE"      },
    { LINEDEVSTATE_OPEN                 ,"OPEN"             },
    { LINEDEVSTATE_CLOSE                ,"CLOSE"            },
    { LINEDEVSTATE_NUMCALLS             ,"NUMCALLS"         },
    { LINEDEVSTATE_NUMCOMPLETIONS       ,"NUMCOMPLETIONS"   },
    { LINEDEVSTATE_TERMINALS            ,"TERMINALS"        },
    { LINEDEVSTATE_ROAMMODE             ,"ROAMMODE"         },
    { LINEDEVSTATE_BATTERY              ,"BATTERY"          },
    { LINEDEVSTATE_SIGNAL               ,"SIGNAL"           },
    { LINEDEVSTATE_DEVSPECIFIC          ,"DEVSPECIFIC"      },
    { LINEDEVSTATE_REINIT               ,"REINIT"           },
    { LINEDEVSTATE_LOCK                 ,"LOCK"             },
#if TAPI_1_1
    { LINEDEVSTATE_CAPSCHANGE           ,"CAPSCHANGE"       },
    { LINEDEVSTATE_CONFIGCHANGE         ,"CONFIGCHANGE"     },
    { LINEDEVSTATE_TRANSLATECHANGE      ,"TRANSLATECHANGE"  },
    { LINEDEVSTATE_COMPLCANCEL          ,"COMPLCANCEL"      },
    { LINEDEVSTATE_REMOVED              ,"REMOVED"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLocationOptions[] =
{
#if TAPI_1_1
    { LINELOCATIONOPTION_PULSEDIAL      ,"PULSEDIAL"        },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN             ,"UNKNOWN"          },
    { LINEMEDIAMODE_INTERACTIVEVOICE    ,"INTERACTIVEVOICE" },
    { LINEMEDIAMODE_AUTOMATEDVOICE      ,"AUTOMATEDVOICE"   },
    { LINEMEDIAMODE_DATAMODEM           ,"DATAMODEM"        },
    { LINEMEDIAMODE_G3FAX               ,"G3FAX"            },
    { LINEMEDIAMODE_TDD                 ,"TDD"              },
    { LINEMEDIAMODE_G4FAX               ,"G4FAX"            },
    { LINEMEDIAMODE_DIGITALDATA         ,"DIGITALDATA"      },
    { LINEMEDIAMODE_TELETEX             ,"TELETEX"          },
    { LINEMEDIAMODE_VIDEOTEX            ,"VIDEOTEX"         },
    { LINEMEDIAMODE_TELEX               ,"TELEX"            },
    { LINEMEDIAMODE_MIXED               ,"MIXED"            },
    { LINEMEDIAMODE_ADSI                ,"ADSI"             },
#if TAPI_1_1
    { LINEMEDIAMODE_VOICEVIEW           ,"VOICEVIEW"        },
#endif
#if TAPI_2_1
    { LINEMEDIAMODE_VIDEO               ,"VIDEO"            },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aMediaControls[] =
{
    { LINEMEDIACONTROL_NONE             ,"NONE"             },
    { LINEMEDIACONTROL_START            ,"START"            },
    { LINEMEDIACONTROL_RESET            ,"RESET"            },
    { LINEMEDIACONTROL_PAUSE            ,"PAUSE"            },
    { LINEMEDIACONTROL_RESUME           ,"RESUME"           },
    { LINEMEDIACONTROL_RATEUP           ,"RATEUP"           },
    { LINEMEDIACONTROL_RATEDOWN         ,"RATEDOWN"         },
    { LINEMEDIACONTROL_RATENORMAL       ,"RATENORMAL"       },
    { LINEMEDIACONTROL_VOLUMEUP         ,"VOLUMEUP"         },
    { LINEMEDIACONTROL_VOLUMEDOWN       ,"VOLUMEDOWN"       },
    { LINEMEDIACONTROL_VOLUMENORMAL     ,"VOLUMENORMAL"     },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aOfferingModes[] =
{
#if TAPI_1_1
    { LINEOFFERINGMODE_ACTIVE           ,"ACTIVE"           },
    { LINEOFFERINGMODE_INACTIVE         ,"INACTIVE"         },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aParkModes[] =
{
    { LINEPARKMODE_DIRECTED             ,"DIRECTED"         },
    { LINEPARKMODE_NONDIRECTED          ,"NONDIRECTED"      },
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aProxyRequests[] =
{
    { LINEPROXYREQUEST_SETAGENTGROUP        ,"SETAGENTGROUP"        },
    { LINEPROXYREQUEST_SETAGENTSTATE        ,"SETAGENTSTATE"        },
    { LINEPROXYREQUEST_SETAGENTACTIVITY     ,"SETAGENTACTIVITY"     },
    { LINEPROXYREQUEST_GETAGENTCAPS         ,"GETAGENTCAPS"         },
    { LINEPROXYREQUEST_GETAGENTSTATUS       ,"GETAGENTSTATUS"       },
    { LINEPROXYREQUEST_AGENTSPECIFIC        ,"AGENTSPECIFIC"        },
    { LINEPROXYREQUEST_GETAGENTACTIVITYLIST ,"GETAGENTACTIVITYLIST" },
    { LINEPROXYREQUEST_GETAGENTGROUPLIST    ,"GETAGENTGROUPLIST"    },
    { 0xffffffff                            ,""                     }
};
#endif

LOOKUP my_far aRemoveFromConfCaps[] =
{
    { LINEREMOVEFROMCONF_NONE           ,"NONE"             },
    { LINEREMOVEFROMCONF_LAST           ,"LAST"             },
    { LINEREMOVEFROMCONF_ANY            ,"ANY"              },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aRequestModes[] =
{
    { LINEREQUESTMODE_MAKECALL          ,"MAKECALL"         },
    { LINEREQUESTMODE_MEDIACALL         ,"MEDIACALL"        },
    { LINEREQUESTMODE_DROP              ,"DROP"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aRequestModes2[] =
{
    { LINEREQUESTMODE_MAKECALL          ,"MAKECALL"         },
    { LINEREQUESTMODE_MEDIACALL         ,"MEDIACALL"        },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aSpecialInfo[] =
{
    { LINESPECIALINFO_NOCIRCUIT         ,"NOCIRCUIT"        },
    { LINESPECIALINFO_CUSTIRREG         ,"CUSTIRREG"        },
    { LINESPECIALINFO_REORDER           ,"REORDER"          },
    { LINESPECIALINFO_UNKNOWN           ,"UNKNOWN"          },
    { LINESPECIALINFO_UNAVAIL           ,"UNAVAIL"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS              ,"BUTTONS"          },
    { LINETERMMODE_LAMPS                ,"LAMPS"            },
    { LINETERMMODE_DISPLAY              ,"DISPLAY"          },
    { LINETERMMODE_RINGER               ,"RINGER"           },
    { LINETERMMODE_HOOKSWITCH           ,"HOOKSWITCH"       },
    { LINETERMMODE_MEDIATOLINE          ,"MEDIATOLINE"      },
    { LINETERMMODE_MEDIAFROMLINE        ,"MEDIAFROMLINE"    },
    { LINETERMMODE_MEDIABIDIRECT        ,"MEDIABIDIRECT"    },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTollListOptions[] =
{
    { LINETOLLLISTOPTION_ADD            ,"ADD"              },
    { LINETOLLLISTOPTION_REMOVE         ,"REMOVE"           },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aToneModes[] =
{
    { LINETONEMODE_CUSTOM               ,"CUSTOM"           },
    { LINETONEMODE_RINGBACK             ,"RINGBACK"         },
    { LINETONEMODE_BUSY                 ,"BUSY"             },
    { LINETONEMODE_BEEP                 ,"BEEP"             },
    { LINETONEMODE_BILLING              ,"BILLING"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER         ,"TRANSFER"         },
    { LINETRANSFERMODE_CONFERENCE       ,"CONFERENCE"       },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTranslateOptions[] =
{
    { LINETRANSLATEOPTION_CARDOVERRIDE  ,"CARDOVERRIDE"     },
#if TAPI_1_1
    { LINETRANSLATEOPTION_CANCELCALLWAITING ,"CANCELCALLWAITING" },
    { LINETRANSLATEOPTION_FORCELOCAL    ,"FORCELOCAL" },
    { LINETRANSLATEOPTION_FORCELD       ,"FORCELD" },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aTranslateResults[] =
{
    { LINETRANSLATERESULT_CANONICAL     ,"CANONICAL"        },
    { LINETRANSLATERESULT_INTERNATIONAL ,"INTERNATIONAL"    },
    { LINETRANSLATERESULT_LONGDISTANCE  ,"LONGDISTANCE"     },
    { LINETRANSLATERESULT_LOCAL         ,"LOCAL"            },
    { LINETRANSLATERESULT_INTOLLLIST    ,"INTOLLLIST"       },
    { LINETRANSLATERESULT_NOTINTOLLLIST ,"NOTINTOLLLIST"    },
    { LINETRANSLATERESULT_DIALBILLING   ,"DIALBILLING"      },
    { LINETRANSLATERESULT_DIALQUIET     ,"DIALQUIET"        },
    { LINETRANSLATERESULT_DIALDIALTONE  ,"DIALDIALTONE"     },
    { LINETRANSLATERESULT_DIALPROMPT    ,"DIALPROMPT"       },
#if TAPI_2_0
    { LINETRANSLATERESULT_VOICEDETECT   ,"VOICEDETECT"      },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aButtonFunctions[] =
{
    { PHONEBUTTONFUNCTION_UNKNOWN       ,"UNKNOWN"          },
    { PHONEBUTTONFUNCTION_CONFERENCE    ,"CONFERENCE"       },
    { PHONEBUTTONFUNCTION_TRANSFER      ,"TRANSFER"         },
    { PHONEBUTTONFUNCTION_DROP          ,"DROP"             },
    { PHONEBUTTONFUNCTION_HOLD          ,"HOLD"             },
    { PHONEBUTTONFUNCTION_RECALL        ,"RECALL"           },
    { PHONEBUTTONFUNCTION_DISCONNECT    ,"DISCONNECT"       },
    { PHONEBUTTONFUNCTION_CONNECT       ,"CONNECT"          },
    { PHONEBUTTONFUNCTION_MSGWAITON     ,"MSGWAITON"        },
    { PHONEBUTTONFUNCTION_MSGWAITOFF    ,"MSGWAITOFF"       },
    { PHONEBUTTONFUNCTION_SELECTRING    ,"SELECTRING"       },
    { PHONEBUTTONFUNCTION_ABBREVDIAL    ,"ABBREVDIAL"       },
    { PHONEBUTTONFUNCTION_FORWARD       ,"FORWARD"          },
    { PHONEBUTTONFUNCTION_PICKUP        ,"PICKUP"           },
    { PHONEBUTTONFUNCTION_RINGAGAIN     ,"RINGAGAIN"        },
    { PHONEBUTTONFUNCTION_PARK          ,"PARK"             },
    { PHONEBUTTONFUNCTION_REJECT        ,"REJECT"           },
    { PHONEBUTTONFUNCTION_REDIRECT      ,"REDIRECT"         },
    { PHONEBUTTONFUNCTION_MUTE          ,"MUTE"             },
    { PHONEBUTTONFUNCTION_VOLUMEUP      ,"VOLUMEUP"         },
    { PHONEBUTTONFUNCTION_VOLUMEDOWN    ,"VOLUMEDOWN"       },
    { PHONEBUTTONFUNCTION_SPEAKERON     ,"SPEAKERON"        },
    { PHONEBUTTONFUNCTION_SPEAKEROFF    ,"SPEAKEROFF"       },
    { PHONEBUTTONFUNCTION_FLASH         ,"FLASH"            },
    { PHONEBUTTONFUNCTION_DATAON        ,"DATAON"           },
    { PHONEBUTTONFUNCTION_DATAOFF       ,"DATAOFF"          },
    { PHONEBUTTONFUNCTION_DONOTDISTURB  ,"DONOTDISTURB"     },
    { PHONEBUTTONFUNCTION_INTERCOM      ,"INTERCOM"         },
    { PHONEBUTTONFUNCTION_BRIDGEDAPP    ,"BRIDGEDAPP"       },
    { PHONEBUTTONFUNCTION_BUSY          ,"BUSY"             },
    { PHONEBUTTONFUNCTION_CALLAPP       ,"CALLAPP"          },
    { PHONEBUTTONFUNCTION_DATETIME      ,"DATETIME"         },
    { PHONEBUTTONFUNCTION_DIRECTORY     ,"DIRECTORY"        },
    { PHONEBUTTONFUNCTION_COVER         ,"COVER"            },
    { PHONEBUTTONFUNCTION_CALLID        ,"CALLID"           },
    { PHONEBUTTONFUNCTION_LASTNUM       ,"LASTNUM"          },
    { PHONEBUTTONFUNCTION_NIGHTSRV      ,"NIGHTSRV"         },
    { PHONEBUTTONFUNCTION_SENDCALLS     ,"SENDCALLS"        },
    { PHONEBUTTONFUNCTION_MSGINDICATOR  ,"MSGINDICATOR"     },
    { PHONEBUTTONFUNCTION_REPDIAL       ,"REPDIAL"          },
    { PHONEBUTTONFUNCTION_SETREPDIAL    ,"SETREPDIAL"       },
    { PHONEBUTTONFUNCTION_SYSTEMSPEED   ,"SYSTEMSPEED"      },
    { PHONEBUTTONFUNCTION_STATIONSPEED  ,"STATIONSPEED"     },
    { PHONEBUTTONFUNCTION_CAMPON        ,"CAMPON"           },
    { PHONEBUTTONFUNCTION_SAVEREPEAT    ,"SAVEREPEAT"       },
    { PHONEBUTTONFUNCTION_QUEUECALL     ,"QUEUECALL"        },
    { PHONEBUTTONFUNCTION_NONE          ,"NONE"             },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY             ,"DUMMY"            },
    { PHONEBUTTONMODE_CALL              ,"CALL"             },
    { PHONEBUTTONMODE_FEATURE           ,"FEATURE"          },
    { PHONEBUTTONMODE_KEYPAD            ,"KEYPAD"           },
    { PHONEBUTTONMODE_LOCAL             ,"LOCAL"            },
    { PHONEBUTTONMODE_DISPLAY           ,"DISPLAY"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP               ,"UP"               },
    { PHONEBUTTONSTATE_DOWN             ,"DOWN"             },
#if TAPI_1_1
    { PHONEBUTTONSTATE_UNKNOWN          ,"UNKNOWN"          },
    { PHONEBUTTONSTATE_UNAVAIL          ,"UNAVAIL"          },
#endif
    { 0xffffffff                        ,""                 }
};

#if TAPI_2_0
LOOKUP my_far aPhoneFeatures[] =
{
    { PHONEFEATURE_GETBUTTONINFO        ,"GETBUTTONINFO"    },
    { PHONEFEATURE_GETDATA              ,"GETDATA"          },
    { PHONEFEATURE_GETDISPLAY           ,"GETDISPLAY"       },
    { PHONEFEATURE_GETGAINHANDSET       ,"GETGAINHANDSET"   },
    { PHONEFEATURE_GETGAINSPEAKER       ,"GETGAINSPEAKER"   },
    { PHONEFEATURE_GETGAINHEADSET       ,"GETGAINHEADSET"   },
    { PHONEFEATURE_GETHOOKSWITCHHANDSET ,"GETHOOKSWITCHHANDSET" },
    { PHONEFEATURE_GETHOOKSWITCHSPEAKER ,"GETHOOKSWITCHSPEAKER" },
    { PHONEFEATURE_GETHOOKSWITCHHEADSET ,"GETHOOKSWITCHHEADSET" },
    { PHONEFEATURE_GETLAMP              ,"GETLAMP"          },
    { PHONEFEATURE_GETRING              ,"GETRING"          },
    { PHONEFEATURE_GETVOLUMEHANDSET     ,"GETVOLUMEHANDSET" },
    { PHONEFEATURE_GETVOLUMESPEAKER     ,"GETVOLUMESPEAKER" },
    { PHONEFEATURE_GETVOLUMEHEADSET     ,"GETVOLUMEHEADSET" },
    { PHONEFEATURE_SETBUTTONINFO        ,"SETBUTTONINFO"    },
    { PHONEFEATURE_SETDATA              ,"SETDATA"          },
    { PHONEFEATURE_SETDISPLAY           ,"SETDISPLAY"       },
    { PHONEFEATURE_SETGAINHANDSET       ,"SETGAINHANDSET"   },
    { PHONEFEATURE_SETGAINSPEAKER       ,"SETGAINSPEAKER"   },
    { PHONEFEATURE_SETGAINHEADSET       ,"SETGAINHEADSET"   },
    { PHONEFEATURE_SETHOOKSWITCHHANDSET ,"SETHOOKSWITCHHANDSET" },
    { PHONEFEATURE_SETHOOKSWITCHSPEAKER ,"SETHOOKSWITCHSPEAKER" },
    { PHONEFEATURE_SETHOOKSWITCHHEADSET ,"SETHOOKSWITCHHEADSET" },
    { PHONEFEATURE_SETLAMP              ,"SETLAMP"          },
    { PHONEFEATURE_SETRING              ,"SETRING"          },
    { PHONEFEATURE_SETVOLUMEHANDSET     ,"SETVOLUMEHANDSET" },
    { PHONEFEATURE_SETVOLUMESPEAKER     ,"SETVOLUMESPEAKER" },
    { PHONEFEATURE_SETVOLUMEHEADSET     ,"SETVOLUMEHEADSET" },
    { 0xffffffff                        ,""                 }
};
#endif

LOOKUP my_far aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET        ,"HANDSET"          },
    { PHONEHOOKSWITCHDEV_SPEAKER        ,"SPEAKER"          },
    { PHONEHOOKSWITCHDEV_HEADSET        ,"HEADSET"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK        ,"ONHOOK"           },
    { PHONEHOOKSWITCHMODE_MIC           ,"MIC"              },
    { PHONEHOOKSWITCHMODE_SPEAKER       ,"SPEAKER"          },
    { PHONEHOOKSWITCHMODE_MICSPEAKER    ,"MICSPEAKER"       },
    { PHONEHOOKSWITCHMODE_UNKNOWN       ,"UNKNOWN"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aLampModes[] =
{
    { PHONELAMPMODE_DUMMY               ,"DUMMY"            },
    { PHONELAMPMODE_OFF                 ,"OFF"              },
    { PHONELAMPMODE_STEADY              ,"STEADY"           },
    { PHONELAMPMODE_WINK                ,"WINK"             },
    { PHONELAMPMODE_FLASH               ,"FLASH"            },
    { PHONELAMPMODE_FLUTTER             ,"FLUTTER"          },
    { PHONELAMPMODE_BROKENFLUTTER       ,"BROKENFLUTTER"    },
    { PHONELAMPMODE_UNKNOWN             ,"UNKNOWN"          },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aPhonePrivileges[] =
{
    { PHONEPRIVILEGE_MONITOR            ,"MONITOR"          },
    { PHONEPRIVILEGE_OWNER              ,"OWNER"            },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aPhoneStates[] =
{
    { PHONESTATE_OTHER                  ,"OTHER"            },
    { PHONESTATE_CONNECTED              ,"CONNECTED"        },
    { PHONESTATE_DISCONNECTED           ,"DISCONNECTED"     },
    { PHONESTATE_OWNER                  ,"OWNER"            },
    { PHONESTATE_MONITORS               ,"MONITORS"         },
    { PHONESTATE_DISPLAY                ,"DISPLAY"          },
    { PHONESTATE_LAMP                   ,"LAMP"             },
    { PHONESTATE_RINGMODE               ,"RINGMODE"         },
    { PHONESTATE_RINGVOLUME             ,"RINGVOLUME"       },
    { PHONESTATE_HANDSETHOOKSWITCH      ,"HANDSETHOOKSWITCH"},
    { PHONESTATE_HANDSETVOLUME          ,"HANDSETVOLUME"    },
    { PHONESTATE_HANDSETGAIN            ,"HANDSETGAIN"      },
    { PHONESTATE_SPEAKERHOOKSWITCH      ,"SPEAKERHOOKSWITCH"},
    { PHONESTATE_SPEAKERVOLUME          ,"SPEAKERVOLUME"    },
    { PHONESTATE_SPEAKERGAIN            ,"SPEAKERGAIN"      },
    { PHONESTATE_HEADSETHOOKSWITCH      ,"HEADSETHOOKSWITCH"},
    { PHONESTATE_HEADSETVOLUME          ,"HEADSETVOLUME"    },
    { PHONESTATE_HEADSETGAIN            ,"HEADSETGAIN"      },
    { PHONESTATE_SUSPEND                ,"SUSPEND"          },
    { PHONESTATE_RESUME                 ,"RESUME"           },
    { PHONESTATE_DEVSPECIFIC            ,"DEVSPECIFIC"      },
    { PHONESTATE_REINIT                 ,"REINIT"           },
#if TAPI_1_1
    { PHONESTATE_CAPSCHANGE             ,"CAPSCHANGE"       },
    { PHONESTATE_REMOVED                ,"REMOVED"          },
#endif
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aPhoneStatusFlags[] =
{
    { PHONESTATUSFLAGS_CONNECTED        ,"CONNECTED"        },
    { PHONESTATUSFLAGS_SUSPENDED        ,"SUSPENDED"        },
    { 0xffffffff                        ,""                 }
};

LOOKUP my_far aStringFormats[] =
{
    { STRINGFORMAT_ASCII                ,"ASCII"            },
    { STRINGFORMAT_DBCS                 ,"DBCS"             },
    { STRINGFORMAT_UNICODE              ,"UNICODE"          },
    { STRINGFORMAT_BINARY               ,"BINARY"           },
    { 0xffffffff                        ,""                 }
};

#if INTERNAL_3_0
LOOKUP my_far aServerConfigFlags[] =
{
    { TAPISERVERCONFIGFLAGS_ISSERVER              ,"ISSERVER"      },
    { TAPISERVERCONFIGFLAGS_ENABLESERVER          ,"ENABLESERVER"  },
    { TAPISERVERCONFIGFLAGS_SETACCOUNT            ,"SETACCOUNT"    },
    { TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS ,"SETTAPIADMINS" },
    { 0xffffffff                                  ,""              }
};

LOOKUP my_far aAvailableProviderOptions[] =
{
    { AVAILABLEPROVIDER_INSTALLABLE     ,"INSTALLABLE "     },
    { AVAILABLEPROVIDER_CONFIGURABLE    ,"CONFIGURABLE"     },
    { AVAILABLEPROVIDER_REMOVABLE       ,"REMOVABLE   "     },
    { 0xffffffff                        ,""                 }
};
#endif

char *aszLineErrs[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "BEARERMODEUNAVAIL",
    "inval err code (0x80000004)",      // 0x80000004 isn't valid err code
    "CALLUNAVAIL",
    "COMPLETIONOVERRUN",
    "CONFERENCEFULL",
    "DIALBILLING",
    "DIALDIALTONE",
    "DIALPROMPT",
    "DIALQUIET",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALADDRESS",                     // 0x80000010
    "INVALADDRESSID",
    "INVALADDRESSMODE",
    "INVALADDRESSSTATE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBEARERMODE",
    "INVALCALLCOMPLMODE",
    "INVALCALLHANDLE",
    "INVALCALLPARAMS",
    "INVALCALLPRIVILEGE",
    "INVALCALLSELECT",
    "INVALCALLSTATE",
    "INVALCALLSTATELIST",
    "INVALCARD",
    "INVALCOMPLETIONID",
    "INVALCONFCALLHANDLE",              // 0x80000020
    "INVALCONSULTCALLHANDLE",
    "INVALCOUNTRYCODE",
    "INVALDEVICECLASS",
    "INVALDEVICEHANDLE",
    "INVALDIALPARAMS",
    "INVALDIGITLIST",
    "INVALDIGITMODE",
    "INVALDIGITS",
    "INVALEXTVERSION",
    "INVALGROUPID",
    "INVALLINEHANDLE",
    "INVALLINESTATE",
    "INVALLOCATION",
    "INVALMEDIALIST",
    "INVALMEDIAMODE",
    "INVALMESSAGEID",                   // 0x80000030
    "inval err code (0x80000031)",      // 0x80000031 isn't valid err code
    "INVALPARAM",
    "INVALPARKID",
    "INVALPARKMODE",
    "INVALPOINTER",
    "INVALPRIVSELECT",
    "INVALRATE",
    "INVALREQUESTMODE",
    "INVALTERMINALID",
    "INVALTERMINALMODE",
    "INVALTIMEOUT",
    "INVALTONE",
    "INVALTONELIST",
    "INVALTONEMODE",
    "INVALTRANSFERMODE",
    "LINEMAPPERFAILED",                 // 0x80000040
    "NOCONFERENCE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOREQUEST",
    "NOTOWNER",
    "NOTREGISTERED",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "RATEUNAVAIL",
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",
    "STRUCTURETOOSMALL",
    "TARGETNOTFOUND",
    "TARGETSELF",
    "UNINITIALIZED",                    // 0x80000050
    "USERUSERINFOTOOBIG",
    "REINIT",
    "ADDRESSBLOCKED",
    "BILLINGREJECTED",
    "INVALFEATURE",
    "NOMULTIPLEINSTANCE"

#if TAPI_2_0
    ,
    "INVALAGENTID",
    "INVALAGENTGROUP",
    "INVALPASSWORD",
    "INVALAGENTSTATE",
    "INVALAGENTACTIVITY",
    "DIALVOICEDETECT"
#endif
};

char *aszPhoneErrs[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBUTTONLAMPID",
    "INVALBUTTONMODE",
    "INVALBUTTONSTATE",
    "INVALDATAID",
    "INVALDEVICECLASS",
    "INVALEXTVERSION",
    "INVALHOOKSWITCHDEV",
    "INVALHOOKSWITCHMODE",              // 0x90000010
    "INVALLAMPMODE",
    "INVALPARAM",
    "INVALPHONEHANDLE",
    "INVALPHONESTATE",
    "INVALPOINTER",
    "INVALPRIVILEGE",
    "INVALRINGMODE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOTOWNER",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "inval err code (0x9000001E)",      // 0x9000001e isn't valid err code
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",                   // 0x90000020
    "STRUCTURETOOSMALL",
    "UNINITIALIZED",
    "REINIT"
};

char *aszTapiErrs[] =
{
    "SUCCESS",
    "DROPPED",
    "NOREQUESTRECIPIENT",
    "REQUESTQUEUEFULL",
    "INVALDESTADDRESS",
    "INVALWINDOWHANDLE",
    "INVALDEVICECLASS",
    "INVALDEVICEID",
    "DEVICECLASSUNAVAIL",
    "DEVICEIDUNAVAIL",
    "DEVICEINUSE",
    "DESTBUSY",
    "DESTNOANSWER",
    "DESTUNAVAIL",
    "UNKNOWNWINHANDLE",
    "UNKNOWNREQUESTID",
    "REQUESTFAILED",
    "REQUESTCANCELLED",
    "INVALPOINTER"
};

char *aFuncNames[] =
{
    "lineAccept",
#if TAPI_1_1
    "lineAddProvider",
#if TAPI_2_0
    "lineAddProviderW",
#endif
#endif
    "lineAddToConference",
#if TAPI_2_0
    "lineAgentSpecific",
#endif
    "lineAnswer",
    "lineBlindTransfer",
#if TAPI_2_0
    "lineBlindTransferW",
#endif
    "lineClose",
    "lineCompleteCall",
    "lineCompleteTransfer",
    "lineConfigDialog",
#if TAPI_2_0
    "lineConfigDialogW",
#endif
#if TAPI_1_1
    "lineConfigDialogEdit",
#if TAPI_2_0
    "lineConfigDialogEditW",
#endif
    "lineConfigProvider",
#endif
    "lineDeallocateCall",
    "lineDevSpecific",
    "lineDevSpecificFeature",
    "lineDial",
#if TAPI_2_0
    "lineDialW",
#endif
    "lineDrop",
    "lineForward",
#if TAPI_2_0
    "lineForwardW",
#endif
    "lineGatherDigits",
#if TAPI_2_0
    "lineGatherDigitsW",
#endif
    "lineGenerateDigits",
#if TAPI_2_0
    "lineGenerateDigitsW",
#endif
    "lineGenerateTone",
    "lineGetAddressCaps",
#if TAPI_2_0
    "lineGetAddressCapsW",
#endif
    "lineGetAddressID",
#if TAPI_2_0
    "lineGetAddressIDW",
#endif
    "lineGetAddressStatus",
#if TAPI_2_0
    "lineGetAddressStatusW",
#endif
#if TAPI_2_0
    "lineGetAgentActivityList",
    "lineGetAgentActivityListW",
    "lineGetAgentCaps",
    "lineGetAgentGroupList",
    "lineGetAgentStatus",
#endif
#if TAPI_1_1
    "lineGetAppPriority",
#if TAPI_2_0
    "lineGetAppPriorityW",
#endif
#endif
    "lineGetCallInfo",
#if TAPI_2_0
    "lineGetCallInfoW",
#endif
    "lineGetCallStatus",
    "lineGetConfRelatedCalls",
#if TAPI_1_1
    "lineGetCountry",
#if TAPI_2_0
    "lineGetCountryW",
#endif
#endif
    "lineGetDevCaps",
#if TAPI_2_0
    "lineGetDevCapsW",
#endif
    "lineGetDevConfig",
#if TAPI_2_0
    "lineGetDevConfigW",
#endif
    "lineGetIcon",
#if TAPI_2_0
    "lineGetIconW",
#endif
    "lineGetID",
#if TAPI_2_0
    "lineGetIDW",
#endif
    "lineGetLineDevStatus",
#if TAPI_2_0
    "lineGetLineDevStatusW",
    "lineGetMessage",
#endif
    "lineGetNewCalls",
    "lineGetNumRings",
#if TAPI_1_1
    "lineGetProviderList",
#if TAPI_2_0
    "lineGetProviderListW",
#endif
#endif
    "lineGetRequest",
#if TAPI_2_0
    "lineGetRequestW",
#endif
    "lineGetStatusMessages",
    "lineGetTranslateCaps",
#if TAPI_2_0
    "lineGetTranslateCapsW",
#endif
    "lineHandoff",
#if TAPI_2_0
    "lineHandoffW",
#endif
    "lineHold",
    "lineInitialize",
#if TAPI_2_0
    "lineInitializeEx",
    "lineInitializeExW",
#endif
    "lineMakeCall",
#if TAPI_2_0
    "lineMakeCallW",
#endif
    "lineMonitorDigits",
    "lineMonitorMedia",
    "lineMonitorTones",
    "lineNegotiateAPIVersion",
    "lineNegotiateExtVersion",
    "lineOpen",
#if TAPI_2_0
    "lineOpenW",
#endif
    "linePark",
#if TAPI_2_0
    "lineParkW",
#endif
    "linePickup",
#if TAPI_2_0
    "linePickupW",
#endif
    "linePrepareAddToConference",
#if TAPI_2_0
    "linePrepareAddToConferenceW",
    "lineProxyMessage",
    "lineProxyResponse",
#endif
    "lineRedirect",
#if TAPI_2_0
    "lineRedirectW",
#endif
    "lineRegisterRequestRecipient",
#if TAPI_1_1
    "lineReleaseUserUserInfo",
#endif
    "lineRemoveFromConference",
#if TAPI_1_1
    "lineRemoveProvider",
#endif
    "lineSecureCall",
    "lineSendUserUserInfo",
#if TAPI_2_0
    "lineSetAgentActivity",
    "lineSetAgentGroup",
    "lineSetAgentState",
#endif
#if TAPI_1_1
    "lineSetAppPriority",
#if TAPI_2_0
    "lineSetAppPriorityW",
#endif
#endif
    "lineSetAppSpecific",
#if TAPI_2_0
    "lineSetCallData",
#endif
    "lineSetCallParams",
    "lineSetCallPrivilege",
#if TAPI_2_0
    "lineSetCallQualityOfService",
    "lineSetCallTreatment",
#endif
    "lineSetCurrentLocation",
    "lineSetDevConfig",
#if TAPI_2_0
    "lineSetDevConfigW",
    "lineSetLineDevStatus",
#endif
    "lineSetMediaControl",
    "lineSetMediaMode",
    "lineSetNumRings",
    "lineSetStatusMessages",
    "lineSetTerminal",
    "lineSetTollList",
#if TAPI_2_0
    "lineSetTollListW",
#endif
    "lineSetupConference",
#if TAPI_2_0
    "lineSetupConferenceW",
#endif
    "lineSetupTransfer",
#if TAPI_2_0
    "lineSetupTransferW",
#endif
    "lineShutdown",
    "lineSwapHold",
    "lineTranslateAddress",
#if TAPI_2_0
    "lineTranslateAddressW",
#endif
#if TAPI_1_1
    "lineTranslateDialog",
#if TAPI_2_0
    "lineTranslateDialogW",
#endif
#endif
    "lineUncompleteCall",
    "lineUnhold",
    "lineUnpark",
#if TAPI_2_0
    "lineUnparkW",
#endif

#if INTERNAL_3_0
    "MMCAddProviderW",
    "MMCConfigProviderW",
    "MMCGetAvailableProviders",
    "MMCGetLineInfoW",
    "MMCGetLineStatusW",
    "MMCGetPhoneInfoW",
    "MMCGetPhoneStatusW",
    "MMCGetProviderListW",
    "MMCGetServerConfigW",
    "MMCInitializeW",
    "MMCRemoveProviderW",
    "MMCSetLineInfoW",
    "MMCSetPhoneInfoW",
    "MMCSetServerConfigW",
    "MMCShutdownW",
#endif

    "phoneClose",
    "phoneConfigDialog",
#if TAPI_2_0
    "phoneConfigDialogW",
#endif
    "phoneDevSpecific",
    "phoneGetButtonInfo",
#if TAPI_2_0
    "phoneGetButtonInfoW",
#endif
    "phoneGetData",
    "phoneGetDevCaps",
#if TAPI_2_0
    "phoneGetDevCapsW",
#endif
    "phoneGetDisplay",
    "phoneGetGain",
    "phoneGetHookSwitch",
    "phoneGetIcon",
#if TAPI_2_0
    "phoneGetIconW",
#endif
    "phoneGetID",
#if TAPI_2_0
    "phoneGetIDW",
#endif
    "phoneGetLamp",
#if TAPI_2_0
    "phoneGetMessage",
#endif
    "phoneGetRing",
    "phoneGetStatus",
#if TAPI_2_0
    "phoneGetStatusW",
#endif
    "phoneGetStatusMessages",
    "phoneGetVolume",
    "phoneInitialize",
#if TAPI_2_0
    "phoneInitializeEx",
    "phoneInitializeExW",
#endif
    "phoneOpen",
    "phoneNegotiateAPIVersion",
    "phoneNegotiateExtVersion",
    "phoneSetButtonInfo",
#if TAPI_2_0
    "phoneSetButtonInfoW",
#endif
    "phoneSetData",
    "phoneSetDisplay",
    "phoneSetGain",
    "phoneSetHookSwitch",
    "phoneSetLamp",
    "phoneSetRing",
    "phoneSetStatusMessages",
    "phoneSetVolume",
    "phoneShutdown",

    "tapiGetLocationInfo",
#if TAPI_2_0
    "tapiGetLocationInfoW",
#endif
    "tapiRequestDrop",
    "tapiRequestMakeCall",
#if TAPI_2_0
    "tapiRequestMakeCallW",
#endif
    "tapiRequestMediaCall",
#if TAPI_2_0
    "tapiRequestMediaCallW",
#endif

    "Open all lines",
    "Open all phones",
    "Close handle (comm, etc)",
    "Dump buffer contents",
#if (INTERNAL_VER >= 0x20000)
    "internalNewLocationW",
#endif

    NULL,
    "Default values",
    "LINECALLPARAMS",
    "LINEFORWARDLIST",
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tapiupr\tapiupr.c ===
#define STRICT

#include <windows.h>
#include <windowsx.h>

#include "location.h"



#if DBG

#define DBGOUT(arg) DbgPrt arg

void
DbgPrt(
    DWORD  dwDbgLevel,
    PSTR DbgMessage,
    ...
    );

#else

#define DBGOUT(_x_)
#endif




const TCHAR gszName[]               = "Name";
const TCHAR gszID[]                 = "ID";
const TCHAR gszAreaCode[]           = "AreaCode";
const TCHAR gszCountry[]            = "Country";
const TCHAR gszOutsideAccess[]      = "OutsideAccess";
const TCHAR gszLongDistanceAccess[] = "LongDistanceAccess";
const TCHAR gszFlags[]              = "Flags";
const TCHAR gszCallingCard[]        = "CallingCard";
const TCHAR gszDisableCallWaiting[] = "DisableCallWaiting";
const TCHAR gszTollList[]           = "TollList";
//const TCHAR gszNumLocations[]       = "NumLocations";
//const TCHAR gszCurrLocation[]       = "CurrLocation";
//const TCHAR gszNextLocationID[]     = "NextLocationID";

const TCHAR gszCard[]               = "Card";
const TCHAR gszPin[]                = "Pin";
const TCHAR gszCards[]              = "Cards";
//const TCHAR gszNumCards[]           = "NumCards";
//const TCHAR gszCurrCard[]           = "CurrCard";
const TCHAR gszLocalRule[]          = "LocalRule";
const TCHAR gszLDRule[]             = "LDRule";
const TCHAR gszInternationalRule[]  = "InternationalRule";

const TCHAR gszNumEntries[]         = "NumEntries";
const TCHAR gszCurrentID[]          = "CurrentID";
const TCHAR gszNextID[]             = "NextID";


const TCHAR gszEmpty[]     =  "";

const TCHAR gszLocations[] =  "Locations";
const TCHAR gszLocation[]  =  "Location";
const TCHAR gszCurrentLocation[] = "CurrentLocation";


const TCHAR gszHandoffPriorities[] = "HandoffPriorities";

const TCHAR gszProviders[] = "Providers";
const TCHAR gszProvider[]  = "Provider%d";

const TCHAR gszTelephonIni[] =  "Telephon.ini";


const TCHAR gszTelephony[]    = "Software\\Microsoft\\Windows\\"
                                "CurrentVersion\\Telephony";



       const CHAR *gaszMediaModes[] =
       {
           "",
           "unknown",
           "interactivevoice",
           "automatedvoice",
           "datamodem",
           "g3fax",
           "tdd",
           "g4fax",
           "digitaldata",
           "teletex",
           "videotex",
           "telex",
           "mixed",
           "adsi",
           "voiceview",
           NULL
       };
       
       const CHAR    *gszRequestMakeCallW = "RequestMakeCall";
       const CHAR    *gszRequestMediaCallW = "RequestMediaCall";
       const CHAR    *gszRegKeyHandoffPriorities = "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities";
       const CHAR    *gszRegKeyHandoffPrioritiesMediaModes = "MediaModes";
       


void FixPriorityList(HKEY hKeyHandoffPriorities,
                     LPCSTR pszListName);

void FixMediaModesPriorityLists();

#pragma check_stack ( off )

//***************************************************************************
//***************************************************************************
//***************************************************************************
BOOL ParseSomething( LPCSTR pFormat, LPCSTR pInputString, LPVOID pOutputPtr )
{
   BYTE c;
   LPBYTE pOutput = (LPBYTE)pOutputPtr;
   LPBYTE pInput = (LPBYTE)pInputString;


   while ( (c = *pFormat) && *pInput )
   {
#if DBG
DBGOUT((11, "Inputstring[%s]\r\n   Format[%s]\r\n",
              pInput, pFormat));
#endif

      switch ( c )
      {
         case 'n':
         {
            DWORD dwValue = 0;
            BYTE bDigit;

            //
            // Parse value from the string
            //
            while ( ((bDigit = *pInput) != '\0') && bDigit != ',' )
            {
               dwValue = (dwValue * 10) + ( bDigit - '0' );
#if DBG
DBGOUT((11, "val of bDigit=%d dwValue=%ld\r\n", (int)bDigit, dwValue));
#endif

               bDigit = *(++pInput);
            }

            *(LPDWORD)pOutput = dwValue;

            pOutput += sizeof(DWORD);

         }
         break;


         case 's':
         {
            //
            // If the caller is looking for a string, the first char
            // MUST be a quotes.  So, just step past it.
            //
            pInput++;

            //
            // Ok, _now_ we're into the meat of the string (if there _is_
            // any...)
            //

            while ( *pInput != '\0' && *pInput != '"' )
            {
               *pOutput = *pInput;
               pOutput++;
               pInput++;
            }

            //
            // Don't forget to put a cap on that thing.
            //
            *pOutput = '\0';
            pOutput++;

            // The input should now be at a ->"<-  if it's not, the ini
            // file was hosed, and I'm not fixing it.
            // So, we step past it, and we're done
            //
            if ( *pInput == '"' )
            {
               pInput++;
            }

         }
         break;


      }

      //
      // Step past the comma...
      //
      //
      if ( *pInput == ',' )
      {
         pInput++;
      }

      pFormat++;
   }

   return TRUE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
//VOID __cdecl main( void )
void __cdecl main( void )
{

   DWORD dw;
   DWORD dwNumEntries;
   DWORD dwCurrentID;
   DWORD dwNextID;

   DWORD dwSize;
   DWORD dwType;
   DWORD dwValue;

   DWORD dwArray[10];
   BYTE  *bBigArray;
   BYTE  *Buffer;
   LPBYTE  pSource;

   HKEY  hKey3;
   HKEY  hKey2;
   HKEY  hKey;
   DWORD dwDisposition;

#define BUFFER_SIZE (5120)

   bBigArray = LocalAlloc( LPTR, BUFFER_SIZE );

   if ( !bBigArray )
   {
       return;
   }

   Buffer = LocalAlloc( LPTR, BUFFER_SIZE ); //Might needs tons of room for tolllist

   if ( !Buffer )
   {
       return;
   }

   dw = GetPrivateProfileString(
                               gszCards,
                               gszCards,
                               gszEmpty,
                               Buffer,
                               BUFFER_SIZE,
                               gszTelephonIni
                             );


   //
   // Is there an existing AND valid TELEPHON.INI file?
   // There would HAVE TO be at least one card.  The SYSTEM cards cannot
   // be deleted, only hidden.
   //
   if ( 0 != dw )
   {



//[Cards]
//Cards=23,23
//Card0=0,"None (Direct Dial)","","","","",1
//Card1=1,"AT&T Direct Dial via 10ATT1","","G","102881FG","10288011EFG",1
#define CARD_INI_ID         (0)
#define CARD_INI_NAME       (1)
#define CARD_INI_SNUMBER    (2)
#define CARD_INI_SARULE     (3)
#define CARD_INI_LDRULE     (4)
#define CARD_INI_INTNLRULE  (5)
#define CARD_INI_HIDDEN     (6)


#define PC_INI_ID           (0)
#define PC_INI_NEXTID       (1)
#define PC_INI_NAME         (2)
#define PC_INI_SARULE       (3)
#define PC_INI_LDRULE       (4)
#define PC_INI_INTNLRULE    (5)


      //
      // Move CARDS entries to registry
      //



      ParseSomething( "nn", Buffer, &dwArray);

      dwNumEntries = dwArray[0];
      dwNextID = dwArray[1];


      RegCreateKeyEx(
                      HKEY_CURRENT_USER,
                      gszTelephony,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey3,
                      &dwDisposition
                    );

      RegCreateKeyEx(
                      hKey3,
                      gszCards,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey2,
                      &dwDisposition
                    );

      //
      // Don't wipe out an existing card section
      //
      dwSize = sizeof(dwValue);

      dw = RegQueryValueEx(
                     hKey2,
                     gszNumEntries,
                     0,
                     &dwType,
                     (LPBYTE)&dwValue,
                     &dwSize
                   );

      if ( 0 != dw )
      {

         RegSetValueEx(
                        hKey2,
                        gszNumEntries,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNumEntries,
                        sizeof(DWORD)
                     );

         RegSetValueEx(
                        hKey2,
                        gszNextID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNextID,
                        sizeof(DWORD)
                     );



         for ( dw=0; dw<dwNumEntries; dw++ )
         {
            TCHAR Temp[18];

            wsprintf(Temp, "%s%d", gszCard, dw);

            //
            // Create the key for this Card
            //
            RegCreateKeyEx(
                           hKey2,
                           Temp,
                           0,
                           "",   //Class?  What class?
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           0,
                           &hKey,
                           &dwDisposition
                        );


            GetPrivateProfileString(
                                    gszCards,
                                    Temp,
                                    gszEmpty,
                                    Buffer,
                                    BUFFER_SIZE,
                                    gszTelephonIni
                                 );

            ParseSomething("nsssssn", Buffer, bBigArray);


            pSource = bBigArray;

            RegSetValueEx(
                           hKey,
                           gszID,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);

            RegSetValueEx(
                           hKey,
                           gszName,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszPin,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszLocalRule,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszLDRule,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszInternationalRule,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszFlags,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            RegCloseKey( hKey );
         }

      }

      RegCloseKey( hKey2 );
      RegCloseKey( hKey3 );


//---------------------------------------------------------------------------



      GetPrivateProfileString(
                               gszLocations,
                               gszCurrentLocation,
                               gszEmpty,
                               Buffer,
                               BUFFER_SIZE,
                               gszTelephonIni
                             );

      ParseSomething( "nn", Buffer, &dwArray);

      dwCurrentID = dwArray[0];


      GetPrivateProfileString(
                               gszLocations,
                               gszLocations,
                               gszEmpty,
                               Buffer,
                               BUFFER_SIZE,
                               gszTelephonIni
                             );

      ParseSomething( "nn", Buffer, &dwArray);

      dwNumEntries = dwArray[0];
      dwNextID = dwArray[1];


      RegCreateKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszTelephony,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey3,
                      &dwDisposition
                    );


      RegCreateKeyEx(
                      hKey3,
                      gszLocations,
                      0,
                      "",   //Class?  What class?
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hKey2,
                      &dwDisposition
                    );




      //
      // Don't wipe out an existing card section
      //
      dwSize = sizeof(dwValue);

      dw = RegQueryValueEx(
                     hKey2,
                     gszNumEntries,
                     0,
                     &dwType,
                     (LPBYTE)&dwValue,
                     &dwSize
                   );

      if ( 0 != dw )
      {

         RegSetValueEx(
                        hKey2,
                        gszCurrentID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwCurrentID,
                        sizeof(DWORD)
                     );

         RegSetValueEx(
                        hKey2,
                        gszNumEntries,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNumEntries,
                        sizeof(DWORD)
                     );

         RegSetValueEx(
                        hKey2,
                        gszNextID,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNextID,
                        sizeof(DWORD)
                     );



         for ( dw=0; dw<dwNumEntries; dw++ )
         {
            TCHAR Temp[18];
            DWORD dwFlags = 0;

            wsprintf(Temp, "%s%d", gszLocation, dw);

            //
            // Create the key for this Location
            //
            RegCreateKeyEx(
                           hKey2,
                           Temp,
                           0,
                           "",   //Class?  What class?
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           0,
                           &hKey,
                           &dwDisposition
                        );



            GetPrivateProfileString(
                                    gszLocations,
                                    Temp,
                                    gszEmpty,
                                    Buffer,
                                    BUFFER_SIZE,
                                    gszTelephonIni
                                 );

            ParseSomething("nssssnnnnsns", Buffer, bBigArray);
//NOTE if this is upgrade over 3.1, the last 2 fields don't exist



//[Locations]
//CurrentLocation=1,2
//Locations=3,4
//Location0=0,"Work","9","9","206",1,0,0,1,"",0,""
//Location1=3,"RoadHouse","","","215",1,0,0,0,"",0,""
//Location2=1,"Home","","","206",1,0,0,0,"",0," "
//  Positions in ini file entries for locations,cards,countries
//  NOTE: dialing rules are in same positions for locations and cards!

//#define LOC_INI_ID            (0)
//#define   LOC_INI_NAME        (1)
//#define   LOC_INI_LPREFIX     (2)
//#define LOC_INI_LDPREFIX  (3)
//#define   LOC_INI_AREACODE    (4)
//#define   LOC_INI_COUNTRYCODE (5)
//#define   LOC_INI_CARDID      (6)
//#define LOC_INI_CARDHINT  (7)
//#define   LOC_INI_INSERTAC    (8)
//#define   LOC_INI_TOLLLIST    (9)
//
//#define   LOC_INI_PULSE       (10)
//#define   LOC_INI_CALLWAITING (11)


            pSource = bBigArray;

            RegSetValueEx(
                           hKey,
                           gszID,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);

            RegSetValueEx(
                           hKey,
                           gszName,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszOutsideAccess,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszLongDistanceAccess,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszAreaCode,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            RegSetValueEx(
                           hKey,
                           gszCountry,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            //
            // If the callingcard == 0, it means this location does not
            // use a calling card.
            //
            if ( *(LPDWORD)pSource != 0 )
            {
               dwFlags |= LOCATION_USECALLINGCARD;
            }

            RegSetValueEx(
                           hKey,
                           gszCallingCard,
                           0,
                           REG_DWORD,
                           pSource,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            pSource += sizeof(DWORD);
            pSource += sizeof(DWORD);


            RegSetValueEx(
                           hKey,
                           gszTollList,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;

            //
            // pSource is currently pointing to the old dwFlags.  However,
            // the only flag that was used was bit 1 which indicated
            // tone dialing.  As luck (yeah, right) would have it, we
            // use bit 1 to indicate tone dialing as well.
            //
            dwFlags |= !((*(LPDWORD)pSource) & 1);

            pSource += sizeof(DWORD);

            //
            // Is there a disablecallwaiting string
            //
            dwFlags |= ( lstrlen( pSource ) == 0 ) ?
                                                   0 :
                                                   LOCATION_HASCALLWAITING;

            RegSetValueEx(
                           hKey,
                           gszDisableCallWaiting,
                           0,
                           REG_SZ,
                           pSource,
                           lstrlen(pSource)+1
                        );
            pSource += lstrlen(pSource)+1;


            RegSetValueEx(
                           hKey,
                           gszFlags,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwFlags,
                           sizeof(DWORD)
                        );
            pSource += sizeof(DWORD);


            RegCloseKey( hKey );
         }

      }



      //
      // Q: How do we update COUNTRY OVERRIDES?
      // A: We don't.  We assume we've corrected everything by now...
      //


//      RegCloseKey( hKey );
      RegCloseKey( hKey2 );
      RegCloseKey( hKey3 );

   }
   

   {
       int      i;
       HKEY     hKeyHandoffPriorities;
       if (RegOpenKeyEx(
                        HKEY_CURRENT_USER,
                        gszRegKeyHandoffPriorities,
                        0,
                        KEY_ALL_ACCESS,
                        &hKeyHandoffPriorities

                       ) == ERROR_SUCCESS)
       {


           for (i = 1; gaszMediaModes[i] != NULL; i++)
           {
               FixPriorityList(
                               hKeyHandoffPriorities,
                               (LPCSTR)gaszMediaModes[i]
                              );
           }

           FixPriorityList(
                           hKeyHandoffPriorities,
                           (LPCSTR)gszRequestMakeCallW
                          );

           FixPriorityList(
                           hKeyHandoffPriorities,
                           (LPCSTR)gszRequestMediaCallW
                          );


           RegCloseKey (hKeyHandoffPriorities);

       }
   }
         
   FixMediaModesPriorityLists();

#ifdef TAPI_NT
   {
      //----------------------------------------------------------------------
      //----------------------------------------------------------------------
      //----------------------------------------------------------------------
      //
      // Now we discuss someone who is upgrading from beta 2 to RTM.  They have
      // "EVERYONE:FULL CONTROL" access on the LOCATIONS key.  Let's change that
      // to have the same security as the TELEPHONY key.
      //
      
      SECURITY_INFORMATION SecInf;
      PSECURITY_DESCRIPTOR pSecDesc;
      DWORD                cbSecDesc = 65535;
      
      
      pSecDesc = LocalAlloc( LPTR, cbSecDesc );
      if ( pSecDesc )
      {
         
      
      
         RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         gszTelephony,
                         0,
                         KEY_ALL_ACCESS,
                         &hKey
                       );

         RegCreateKeyEx(
                         hKey,
                         gszLocations,
                         0,
                         "",   //Class?  What class?
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         0,
                         &hKey2,
                         &dwDisposition
                       );
                       
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            OWNER_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            OWNER_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            GROUP_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            GROUP_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            DACL_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            DACL_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
         cbSecDesc = 65535;
         dw = RegGetKeySecurity( hKey,
                            SACL_SECURITY_INFORMATION,
                            pSecDesc,
                            &cbSecDesc
                          );
   
         if ( ERROR_SUCCESS == dw )
            RegSetKeySecurity( hKey2,
                            SACL_SECURITY_INFORMATION,
                            pSecDesc
                          );
   
   
         RegCloseKey( hKey );
         RegCloseKey( hKey2);
         
         
         LocalFree( pSecDesc );
      }
   }                          
#endif

   LocalFree( bBigArray );
   LocalFree( Buffer );

   return;
}

void FixPriorityList(HKEY hKeyHandoffPriorities,
                     LPCSTR pszListName)
{
    DWORD   dwType, dwNumBytes;
    LPSTR  pszPriorityList, pszHold;

    if (RegQueryValueEx(
            hKeyHandoffPriorities,
            pszListName,
            NULL,
            &dwType,
            NULL,
            &dwNumBytes
                        ) == ERROR_SUCCESS &&

        (dwNumBytes != 0))
    {
        pszPriorityList = (LPSTR) GlobalAlloc ( GPTR, dwNumBytes );

        if (pszPriorityList)
        {
            pszHold = pszPriorityList;
            
            if ( RegQueryValueEx(
                    hKeyHandoffPriorities,
                    pszListName,
                    NULL,
                    &dwType,
                    (LPBYTE)(pszPriorityList),
                    &dwNumBytes

                                 ) == ERROR_SUCCESS)
            {
                while (*pszPriorityList != '\0')
                {
                    if (*pszPriorityList == ',')
                    {
                        *pszPriorityList = '"';
                    }

                    pszPriorityList++;
                }

                pszPriorityList = pszHold;

                RegSetValueEx(
                               hKeyHandoffPriorities,
                               pszListName,
                               0,
                               REG_SZ,
                               (LPBYTE)pszPriorityList,
                               (lstrlen(pszPriorityList) + 1) * sizeof(CHAR));
            }

            GlobalFree(pszPriorityList);
        }
    }

}


void FixMediaModesPriorityLists()
{
    HKEY     hKeyHandoffPriorities;
    HKEY     hKeyMediaModes;
    DWORD    dwDisp;

    // open the handoff priorities key
    if (RegOpenKeyEx(
                     HKEY_CURRENT_USER,
                     gszRegKeyHandoffPriorities,
                     0,
                     KEY_ALL_ACCESS,
                     &hKeyHandoffPriorities

                    ) == ERROR_SUCCESS)
    {
        if (RegOpenKeyEx(
                         hKeyHandoffPriorities,
                         gszRegKeyHandoffPrioritiesMediaModes,
                         0,
                         KEY_ALL_ACCESS,
                         &hKeyMediaModes
                        ) == ERROR_SUCCESS)
        {
            // key already exists, so don't do anything
            RegCloseKey( hKeyHandoffPriorities );
            RegCloseKey( hKeyMediaModes );

            return;
        }
        
        // create the mediamodes priority key
        if (RegCreateKeyEx(
                           hKeyHandoffPriorities,
                           gszRegKeyHandoffPrioritiesMediaModes,
                           0,
                           "",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKeyMediaModes,
                           &dwDisp
                           ) == ERROR_SUCCESS)
        {
            // go through all the
            // media modes

            int i;
            int j = 2; //LINEMEDIAMODE_UNKNOWN;
            for (i = 1; gaszMediaModes[i] != NULL; i++)
            {
                CHAR    szName[64];
                LPSTR   pszPriorityList;
                DWORD   dwNumBytes, dwType;

                // query for the priority list
                if ( (RegQueryValueEx(
                                      hKeyHandoffPriorities,
                                      gaszMediaModes[i],
                                      NULL,
                                      &dwType,
                                      NULL,
                                      &dwNumBytes
                                     ) == ERROR_SUCCESS) && (dwNumBytes != 0))
                {
                    pszPriorityList = (LPSTR) GlobalAlloc ( GPTR, dwNumBytes );

                    if (NULL != pszPriorityList)
                    {
                        if ( RegQueryValueEx(
                                             hKeyHandoffPriorities,
                                             gaszMediaModes[i],
                                             NULL,
                                             &dwType,
                                             (LPBYTE)(pszPriorityList),
                                             &dwNumBytes
                                            ) == ERROR_SUCCESS)
                        {

                            // if it exists, write out the new one
                            wsprintf(szName, "%d", j);
                            RegSetValueEx(
                                          hKeyMediaModes,
                                          szName,
                                          0,
                                          REG_SZ,
                                          pszPriorityList,
                                          lstrlen(pszPriorityList)+1
                                         );

                            // delete the old one
                            RegDeleteValue(
                                           hKeyHandoffPriorities,
                                           gaszMediaModes[i]
                                          );
                        }

                        GlobalFree( pszPriorityList );
                    }
                }

                j<<=1; // shift to next media mode

            }

            RegCloseKey(hKeyMediaModes);
        }

        RegCloseKey(hKeyHandoffPriorities);
    }
}

#if DBG


#include "stdarg.h"
#include "stdio.h"


VOID
DbgPrt(
    DWORD  dwDbgLevel,
    PSTR   lpszFormat,
    ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = 0;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[256] = "TAPIUPR: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[8],
                  lpszFormat,
                  ap
                  );

        lstrcat (buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\tb.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    tb.h

Abstract:

    Header file for the TAPI Browser util

Author:

    Dan Knudson (DanKn)    23-Aug-1994

Revision History:

--*/


#include <windows.h>
#include <tapi.h>

#if INTERNAL_3_0
#include <tapimmc.h>
#endif


//
// Symbolic constants
//

#define DS_NONZEROFIELDS            0x00000001
#define DS_ZEROFIELDS               0x00000002
#define DS_BYTEDUMP                 0x00000004

#define WT_LINEAPP                  1
#define WT_LINE                     2
#define WT_CALL                     3
#define WT_PHONEAPP                 4
#define WT_PHONE                    5

#define PT_DWORD                    1
#define PT_FLAGS                    2
#define PT_POINTER                  3
#define PT_STRING                   4
#define PT_CALLPARAMS               5
#define PT_FORWARDLIST              6
#define PT_ORDINAL                  7

#define FT_DWORD                    1
#define FT_FLAGS                    2
#define FT_ORD                      3
#define FT_SIZE                     4
#define FT_OFFSET                   5

#define MAX_STRING_PARAM_SIZE       96

#define MAX_USER_BUTTONS            6

#define MAX_USER_BUTTON_TEXT_SIZE   8

#define MAX_LINEFORWARD_ENTRIES     5

#define TABSIZE 4

#if TAPI_2_0
#define LAST_LINEERR                LINEERR_DIALVOICEDETECT
#else
#define LAST_LINEERR                LINEERR_NOMULTIPLEINSTANCE
#endif


//
//
//

typedef LONG (WINAPI *PFN1)(ULONG_PTR);
typedef LONG (WINAPI *PFN2)(ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN3)(ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN4)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN5)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR);
typedef LONG (WINAPI *PFN6)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN7)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN8)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN9)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR);
typedef LONG (WINAPI *PFN10)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR);
typedef LONG (WINAPI *PFN12)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);


typedef struct _MYWIDGET
{
    DWORD       dwType;

    struct _MYWIDGET   *pNext;

} MYWIDGET, *PMYWIDGET;


typedef struct _MYLINEAPP
{
    MYWIDGET    Widget;

    HLINEAPP    hLineApp;

} MYLINEAPP, *PMYLINEAPP;


typedef struct _MYLINE
{
    MYWIDGET    Widget;

    HLINE       hLine;

    HLINEAPP    hLineApp;

    DWORD       dwDevID;

    DWORD       dwPrivileges;

    DWORD       dwMediaModes;

    DWORD       dwAPIVersion;

    PMYLINEAPP  pLineApp;

} MYLINE, *PMYLINE;


typedef struct _MYCALL
{
    MYWIDGET    Widget;

    HCALL       hCall;

    DWORD       dwCallState;

    LONG        lMakeCallReqID;

    LONG        lDropReqID;

    DWORD       dwCompletionID;

    DWORD       dwNumGatheredDigits;

    char        *lpsGatheredDigits;

    PMYLINE     pLine;

    BOOL        bMonitor;

} MYCALL, *PMYCALL;


typedef struct _MYPHONEAPP
{
    MYWIDGET    Widget;

    HPHONEAPP   hPhoneApp;

} MYPHONEAPP, *PMYPHONEAPP;


typedef struct _MYPHONE
{
    MYWIDGET    Widget;

    HPHONE      hPhone;

    HPHONEAPP   hPhoneApp;

    DWORD       dwDevID;

    DWORD       dwPrivilege;

    DWORD       dwAPIVersion;

    PMYPHONEAPP pPhoneApp;

} MYPHONE, *PMYPHONE;


typedef struct _LOOKUP
{
    DWORD       dwVal;

    char        lpszVal[20];

} LOOKUP, *PLOOKUP;


typedef enum
{
    lAccept,
#if TAPI_1_1
    lAddProvider,
#if TAPI_2_0
    lAddProviderW,
#endif
#endif
    lAddToConference,
#if TAPI_2_0
    lAgentSpecific,
#endif
    lAnswer,
    lBlindTransfer,
#if TAPI_2_0
    lBlindTransferW,
#endif
    lClose,
    lCompleteCall,
    lCompleteTransfer,
    lConfigDialog,
#if TAPI_2_0
    lConfigDialogW,
#endif
#if TAPI_1_1
    lConfigDialogEdit,
#if TAPI_2_0
    lConfigDialogEditW,
#endif
    lConfigProvider,
#endif
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
#if TAPI_2_0
    lDialW,
#endif
    lDrop,
    lForward,
#if TAPI_2_0
    lForwardW,
#endif
    lGatherDigits,
#if TAPI_2_0
    lGatherDigitsW,
#endif
    lGenerateDigits,
#if TAPI_2_0
    lGenerateDigitsW,
#endif
    lGenerateTone,
    lGetAddressCaps,
#if TAPI_2_0
    lGetAddressCapsW,
#endif
    lGetAddressID,
#if TAPI_2_0
    lGetAddressIDW,
#endif
    lGetAddressStatus,
#if TAPI_2_0
    lGetAddressStatusW,
    lGetAgentActivityList,
    lGetAgentActivityListW,
    lGetAgentCaps,
    lGetAgentGroupList,
    lGetAgentStatus,
#endif
#if TAPI_1_1
    lGetAppPriority,
#if TAPI_2_0
    lGetAppPriorityW,
#endif
#endif
    lGetCallInfo,
#if TAPI_2_0
    lGetCallInfoW,
#endif
    lGetCallStatus,
    lGetConfRelatedCalls,
#if TAPI_1_1
    lGetCountry,
#if TAPI_2_0
    lGetCountryW,
#endif
#endif
    lGetDevCaps,
#if TAPI_2_0
    lGetDevCapsW,
#endif
    lGetDevConfig,
#if TAPI_2_0
    lGetDevConfigW,
#endif
    lGetIcon,
#if TAPI_2_0
    lGetIconW,
#endif
    lGetID,
#if TAPI_2_0
    lGetIDW,
#endif
    lGetLineDevStatus,
#if TAPI_2_0
    lGetLineDevStatusW,
    lGetMessage,
#endif
    lGetNewCalls,
    lGetNumRings,
#if TAPI_1_1
    lGetProviderList,
#if TAPI_2_0
    lGetProviderListW,
#endif
#endif
    lGetRequest,
#if TAPI_2_0
    lGetRequestW,
#endif
    lGetStatusMessages,
    lGetTranslateCaps,
#if TAPI_2_0
    lGetTranslateCapsW,
#endif
    lHandoff,
#if TAPI_2_0
    lHandoffW,
#endif
    lHold,
    lInitialize,
#if TAPI_2_0
    lInitializeEx,
    lInitializeExW,
#endif
    lMakeCall,
#if TAPI_2_0
    lMakeCallW,
#endif
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
#if TAPI_2_0
    lOpenW,
#endif
    lPark,
#if TAPI_2_0
    lParkW,
#endif
    lPickup,
#if TAPI_2_0
    lPickupW,
#endif
    lPrepareAddToConference,
#if TAPI_2_0
    lPrepareAddToConferenceW,
    lProxyMessage,
    lProxyResponse,
#endif
    lRedirect,
#if TAPI_2_0
    lRedirectW,
#endif
    lRegisterRequestRecipient,
#if TAPI_1_1
    lReleaseUserUserInfo,
#endif
    lRemoveFromConference,
#if TAPI_1_1
    lRemoveProvider,
#endif
    lSecureCall,
    lSendUserUserInfo,
#if TAPI_2_0
    lSetAgentActivity,
    lSetAgentGroup,
    lSetAgentState,
#endif
#if TAPI_1_1
    lSetAppPriority,
#if TAPI_2_0
    lSetAppPriorityW,
#endif
#endif
    lSetAppSpecific,
#if TAPI_2_0
    lSetCallData,
#endif
    lSetCallParams,
    lSetCallPrivilege,
#if TAPI_2_0
    lSetCallQualityOfService,
    lSetCallTreatment,
#endif
    lSetCurrentLocation,
    lSetDevConfig,
#if TAPI_2_0
    lSetDevConfigW,
    lSetLineDevStatus,
#endif
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
    lSetTollList,
#if TAPI_2_0
    lSetTollListW,
#endif
    lSetupConference,
#if TAPI_2_0
    lSetupConferenceW,
#endif
    lSetupTransfer,
#if TAPI_2_0
    lSetupTransferW,
#endif
    lShutdown,
    lSwapHold,
    lTranslateAddress,
#if TAPI_2_0
    lTranslateAddressW,
#endif
#if TAPI_1_1
    lTranslateDialog,
#if TAPI_2_0
    lTranslateDialogW,
#endif
#endif
    lUncompleteCall,
    lUnhold,
    lUnpark,
#if TAPI_2_0
    lUnparkW,
#endif

#if INTERNAL_3_0
    mmcAddProvider,
    mmcConfigProvider,
    mmcGetAvailableProviders,
    mmcGetLineInfo,
    mmcGetLineStatus,
    mmcGetPhoneInfo,
    mmcGetPhoneStatus,
    mmcGetProviderList,
    mmcGetServerConfig,
    mmcInitialize,
    mmcRemoveProvider,
    mmcSetLineInfo,
    mmcSetPhoneInfo,
    mmcSetServerConfig,
    mmcShutdown,
#endif

    pClose,
    pConfigDialog,
#if TAPI_2_0
    pConfigDialogW,
#endif
    pDevSpecific,
    pGetButtonInfo,
#if TAPI_2_0
    pGetButtonInfoW,
#endif
    pGetData,
    pGetDevCaps,
#if TAPI_2_0
    pGetDevCapsW,
#endif
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetIcon,
#if TAPI_2_0
    pGetIconW,
#endif
    pGetID,
#if TAPI_2_0
    pGetIDW,
#endif
    pGetLamp,
#if TAPI_2_0
    pGetMessage,
#endif
    pGetRing,
    pGetStatus,
#if TAPI_2_0
    pGetStatusW,
#endif
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
#if TAPI_2_0
    pInitializeEx,
    pInitializeExW,
#endif
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
    pSetButtonInfo,
#if TAPI_2_0
    pSetButtonInfoW,
#endif
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

    tGetLocationInfo,
#if TAPI_2_0
    tGetLocationInfoW,
#endif
    tRequestDrop,
    tRequestMakeCall,
#if TAPI_2_0
    tRequestMakeCallW,
#endif
    tRequestMediaCall,
#if TAPI_2_0
    tRequestMediaCallW,
#endif

    OpenAllLines,
    OpenAllPhones,
    CloseHandl,
    DumpBuffer,
#if (INTERNAL_VER >= 0x20000)
    iNewLocationW,
#endif

    MiscBegin,

    DefValues,
    lCallParams,
    lForwardList

} FUNC_INDEX;


typedef struct _FUNC_PARAM
{
    char far        *szName;

    DWORD           dwType;

    ULONG_PTR       dwValue;

    union
    {
        LPVOID      pLookup;

        char far    *buf;

        LPVOID      ptr;

        ULONG_PTR   dwDefValue;

    } u;

} FUNC_PARAM, *PFUNC_PARAM;


typedef struct _FUNC_PARAM_HEADER
{
    DWORD       dwNumParams;

    FUNC_INDEX  FuncIndex;

    PFUNC_PARAM aParams;

    union
    {
        PFN1    pfn1;
        PFN2    pfn2;
        PFN3    pfn3;
        PFN4    pfn4;
        PFN5    pfn5;
        PFN6    pfn6;
        PFN7    pfn7;
        PFN8    pfn8;
        PFN9    pfn9;
        PFN10   pfn10;
        PFN12   pfn12;

    } u;

} FUNC_PARAM_HEADER, *PFUNC_PARAM_HEADER;


typedef struct _STRUCT_FIELD
{
    char far    *szName;

    DWORD       dwType;

    DWORD       dwValue;

    LPVOID      pLookup;

} STRUCT_FIELD, *PSTRUCT_FIELD;


typedef struct _STRUCT_FIELD_HEADER
{
    LPVOID      pStruct;

    char far    *szName;

    DWORD       dwNumFields;

    PSTRUCT_FIELD   aFields;

} STRUCT_FIELD_HEADER, *PSTRUCT_FIELD_HEADER;


//
// Func prototypes
//

INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

void
FAR
ShowStr(
    LPCSTR format,
    ...
    );

void
ShowBytes(
    DWORD   dwSize,
    LPVOID  lp,
    DWORD   dwNumTabs
    );

VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

INT_PTR
CALLBACK
ParamsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
IconDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
IsLineAppSelected(
    void
    );

BOOL
IsLineSelected(
    void
    );

BOOL
IsCallSelected(
    void
    );

BOOL
IsTwoCallsSelected(
    void
    );

BOOL
IsPhoneAppSelected(
    void
    );

BOOL
IsPhoneSelected(
    void
    );

LONG
DoFunc(
    PFUNC_PARAM_HEADER pHeader
    );

INT_PTR
LetUserMungeParams(
    PFUNC_PARAM_HEADER pParamsHeader
    );

void
ShowLineFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

void
FuncDriver(
    FUNC_INDEX funcIndex
    );

void
UpdateWidgetList(
    void
    );

void
InsertWidgetInList(
    PMYWIDGET pNewWidget,
    PMYWIDGET pWidgetInsertBefore
    );

BOOL
RemoveWidgetFromList(
    PMYWIDGET pWidgetToRemove
    );

PMYLINEAPP
AllocLineApp(
    void
    );

PMYLINEAPP
GetLineApp(
    HLINEAPP hLineApp
    );

VOID
FreeLineApp(
    PMYLINEAPP pLineApp
    );

PMYLINE
AllocLine(
    PMYLINEAPP pLineApp
    );

PMYLINE
GetLine(
    HLINE hLine
    );

VOID
FreeLine(
    PMYLINE pLine
    );

PMYCALL
AllocCall(
    PMYLINE pLine
    );

PMYCALL
GetCall(
    HCALL hCall
    );

VOID
FreeCall(
    PMYCALL pCall
    );

VOID
MoveCallToLine(
    PMYCALL pCall,
    HLINE hLine
    );

PMYPHONEAPP
AllocPhoneApp(
    void
    );

PMYPHONEAPP
GetPhoneApp(
    HPHONEAPP hPhoneApp
    );

VOID
FreePhoneApp(
    PMYPHONEAPP pPhoneApp
    );

PMYPHONE
AllocPhone(
    PMYPHONEAPP pPhoneApp
    );

PMYPHONE
GetPhone(
    HPHONE hPhone
    );

VOID
FreePhone(
    PMYPHONE pPhone
    );

int
GetWidgetIndex(
    PMYWIDGET pWidget
    );

void
SelectWidget(
    PMYWIDGET pWidget
    );

void
UpdateResults(
    BOOL bBegin
    );

INT_PTR
CALLBACK
UserButtonsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

void
ErrorAlert(
    void
    );

//
// Macros
//

#define CHK_LINEAPP_SELECTED()                      \
        if (!IsLineAppSelected())                   \
        {                                           \
            break;                                  \
        }

#define CHK_LINE_SELECTED()                         \
        if (!IsLineSelected())                      \
        {                                           \
            break;                                  \
        }

#define CHK_CALL_SELECTED()                         \
        if (!IsCallSelected())                      \
        {                                           \
            break;                                  \
        }

#define CHK_TWO_CALLS_SELECTED()                    \
        if (!IsTwoCallsSelected())                  \
        {                                           \
            break;                                  \
        }

#define CHK_PHONEAPP_SELECTED()                     \
        if (!IsPhoneAppSelected())                  \
        {                                           \
            break;                                  \
        }

#define CHK_PHONE_SELECTED()                        \
        if (!IsPhoneSelected())                     \
        {                                           \
            break;                                  \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\vars.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-97  Microsoft Corporation

Module Name:

    vars.h

Abstract:

    Header file for the TAPI Browser util globals

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


#ifdef WIN32
#define my_far
#else
#define my_far _far
#endif

extern PMYWIDGET   aWidgets;

extern FILE        *hLogFile;
extern HANDLE      ghInst;
extern HWND        ghwndMain, ghwndEdit, ghwndList1, ghwndList2;
extern BOOL        bShowParams;
extern BOOL        gbDeallocateCall;
extern BOOL        gbDisableHandleChecking;
extern LPVOID      pBigBuf;
extern DWORD       dwBigBufSize;
extern DWORD       dwNumPendingMakeCalls;
extern DWORD       dwNumPendingDrops;
extern DWORD       gdwNumLineDevs;
extern DWORD       gdwNumPhoneDevs;
extern BOOL        bDumpParams;
extern BOOL        bTimeStamp;
extern DWORD       bNukeIdleMonitorCalls;
extern DWORD       bNukeIdleOwnedCalls;
extern DWORD       dwDumpStructsFlags;

extern LPLINECALLPARAMS    lpCallParams;

#if TAPI_2_0
extern BOOL                gbWideStringParams;
extern LPLINECALLPARAMS    lpCallParamsW;
#endif

extern DWORD       aUserButtonFuncs[MAX_USER_BUTTONS];
extern char        aUserButtonsText[MAX_USER_BUTTONS][MAX_USER_BUTTON_TEXT_SIZE];

extern PMYLINEAPP  pLineAppSel;
extern PMYLINE     pLineSel;
extern PMYCALL     pCallSel, pCallSel2;
extern PMYPHONEAPP pPhoneAppSel;
extern PMYPHONE    pPhoneSel;

extern char my_far szDefAppName[];
extern char my_far szDefUserUserInfo[];
extern char my_far szDefDestAddress[];
extern char my_far szDefLineDeviceClass[];
extern char my_far szDefPhoneDeviceClass[];

extern char far   *lpszDefAppName;
extern char far   *lpszDefUserUserInfo;
extern char far   *lpszDefDestAddress;
extern char far   *lpszDefLineDeviceClass;
extern char far   *lpszDefPhoneDeviceClass;

extern char my_far szTab[];
extern char my_far szCurrVer[];

// help extern char my_far szTapiHlp[];
// help extern char my_far szTspiHlp[];

extern DWORD       dwDefAddressID;
extern DWORD       dwDefLineAPIVersion;
extern DWORD       dwDefBearerMode;
extern DWORD       dwDefCountryCode;
extern DWORD       dwDefLineDeviceID;
extern DWORD       dwDefLineExtVersion;
extern DWORD       dwDefMediaMode;
extern DWORD       dwDefLinePrivilege;
extern DWORD       dwDefPhoneAPIVersion;
extern DWORD       dwDefPhoneDeviceID;
extern DWORD       dwDefPhoneExtVersion;
extern DWORD       dwDefPhonePrivilege;

#if TAPI_2_0
extern HANDLE      ghCompletionPort;
#endif

extern char aAscii[];

extern LOOKUP my_far aButtonFunctions[];
extern LOOKUP my_far aButtonModes[];
extern LOOKUP my_far aButtonStates[];
extern LOOKUP my_far aHookSwitchDevs[];
extern LOOKUP my_far aHookSwitchModes[];
extern LOOKUP my_far aLampModes[];
extern LOOKUP my_far aPhonePrivileges[];
extern LOOKUP my_far aPhoneStatusFlags[];
extern LOOKUP my_far aPhoneStates[];

extern LOOKUP my_far aStringFormats[];
extern LOOKUP my_far aAddressCapFlags[];
extern LOOKUP my_far aAddressFeatures[];
extern LOOKUP my_far aAgentStates[];
extern LOOKUP my_far aAgentStatus[];
extern LOOKUP my_far aAddressModes[];
extern LOOKUP my_far aAddressSharing[];
extern LOOKUP my_far aAddressStates[];
extern LOOKUP my_far aAnswerModes[];
extern LOOKUP my_far aAPIVersions[];
extern LOOKUP my_far aBearerModes[];
extern LOOKUP my_far aBusyModes[];
extern LOOKUP my_far aCallComplConds[];
extern LOOKUP my_far aCallComplModes[];
extern LOOKUP my_far aCallerIDFlags[];
extern LOOKUP my_far aCallFeatures[];
extern LOOKUP my_far aCallFeatures2[];
extern LOOKUP my_far aCallInfoStates[];
extern LOOKUP my_far aCallOrigins[];
extern LOOKUP my_far aCallParamFlags[];
extern LOOKUP my_far aCallPrivileges[];
extern LOOKUP my_far aCallReasons[];
extern LOOKUP my_far aCallSelects[];
extern LOOKUP my_far aCallStates[];
extern LOOKUP my_far aCallTreatments[];
extern LOOKUP my_far aCardOptions[];
extern LOOKUP my_far aConnectedModes[];
extern LOOKUP my_far aDevCapsFlags[];
extern LOOKUP my_far aDialToneModes[];
extern LOOKUP my_far aDigitModes[];
extern LOOKUP my_far aDisconnectModes[];
extern LOOKUP my_far aForwardModes[];
extern LOOKUP my_far aGatherTerms[];
extern LOOKUP my_far aGenerateTerms[];
extern LOOKUP my_far aLineInitExOptions[];
extern LOOKUP my_far aPhoneInitExOptions[];
extern LOOKUP my_far aLineDevStatusFlags[];
extern LOOKUP my_far aLineFeatures[];
extern LOOKUP my_far aLineOpenOptions[];
extern LOOKUP my_far aLineRoamModes[];
extern LOOKUP my_far aLineStates[];
extern LOOKUP my_far aLocationOptions[];
extern LOOKUP my_far aMediaControls[];
extern LOOKUP my_far aMediaModes[];
extern LOOKUP my_far aOfferingModes[];
extern LOOKUP my_far aParkModes[];
extern LOOKUP my_far aProxyRequests[];
extern LOOKUP my_far aRemoveFromConfCaps[];
extern LOOKUP my_far aRequestModes[];
extern LOOKUP my_far aRequestModes2[];
extern LOOKUP my_far aSpecialInfo[];
extern LOOKUP my_far aTerminalModes[];
extern LOOKUP my_far aTollListOptions[];
extern LOOKUP my_far aToneModes[];
extern LOOKUP my_far aTransferModes[];
extern LOOKUP my_far aTranslateOptions[];
extern LOOKUP my_far aTranslateResults[];

#if INTERNAL_3_0
extern LOOKUP my_far aServerConfigFlags[];
extern LOOKUP my_far aAvailableProviderOptions[];
#endif

#if TAPI_2_0
extern LOOKUP my_far aPhoneFeatures[];
#endif

extern char *aszLineErrs[];

extern char *aszPhoneErrs[];
extern char *aszTapiErrs[];

extern char *aFuncNames[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tb\widget.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    widget.c

Abstract:

    Widget creation/management/deletion support for TAPI Browser util.

Author:

    Dan Knudson (DanKn)    23-Aug-1994

Revision History:

--*/


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include "tb.h"
#include "vars.h"



void
UpdateWidgetList(
    void
    )
{
    int         i;
    LRESULT     lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    PMYWIDGET   pWidget = aWidgets, pSelWidget = (PMYWIDGET) NULL;


    if (lSel != LB_ERR)
    {
        pSelWidget = (PMYWIDGET) SendMessage(
            ghwndList1,
            LB_GETITEMDATA,
            (WPARAM) lSel,
            0
            );
    }

    SendMessage (ghwndList1, LB_RESETCONTENT, 0, 0);

    for (i = 0; pWidget; i++)
    {
        char buf[64];


        switch (pWidget->dwType)
        {
        case WT_LINEAPP:

            sprintf (buf, "LineApp=x%lx", ((PMYLINEAPP) pWidget)->hLineApp);
            break;

        case WT_LINE:
        {
            PMYLINE pLine = (PMYLINE) pWidget;


            sprintf(
                buf,
                "  Line=x%lx id=%ld ",
                pLine->hLine,
                pLine->dwDevID
                );

            if (pLine->dwPrivileges & LINECALLPRIVILEGE_NONE)
            {
                strcat (buf, "DialOut");
            }
            else
            {
                if (pLine->dwPrivileges & LINECALLPRIVILEGE_OWNER)
                {
                    strcat (buf, "DialInOut");
                }

                if (pLine->dwPrivileges & LINECALLPRIVILEGE_MONITOR)
                {
                    strcat (buf, " Monitor");
                }
            }

            if (pLine->dwPrivileges & LINEOPENOPTION_PROXY)
            {
                strcat (buf, " Proxy");
            }

            break;
        }
        case WT_CALL:
        {
            PMYCALL pCall = (PMYCALL) pWidget;


            if (pCall->hCall)
            {
                int i;

                for (i = 0; aCallStates[i].dwVal != 0xffffffff; i++)
                {
                    if (pCall->dwCallState == aCallStates[i].dwVal)
                    {
                        break;
                    }
                }

                sprintf(
                    buf,
                    "    Call=x%lx %s %s",
                    pCall->hCall,
                    aCallStates[i].lpszVal,
                    (pCall->bMonitor ? "Monitor" : "Owner")
                    );
            }
            else
            {
                strcpy (buf, "    <MakeCall reply pending>");
            }

            break;
        }
        case WT_PHONEAPP:

            sprintf (buf, "PhoneApp=x%lx", ((PMYPHONEAPP) pWidget)->hPhoneApp);
            break;

        case WT_PHONE:

            sprintf(
                buf,
                "  Phone=x%lx id=%ld",
                ((PMYPHONE) pWidget)->hPhone,
                ((PMYPHONE) pWidget)->dwDevID
                );

            break;
        }

        SendMessage (ghwndList1, LB_INSERTSTRING, (WPARAM) -1, (LPARAM) buf);
        SendMessage (ghwndList1, LB_SETITEMDATA, (WPARAM) i, (LPARAM) pWidget);

        pWidget = pWidget->pNext;
    }


    //
    // Restore selection if appropriate
    //

    if ((lSel != LB_ERR) && ((lSel = (LONG) GetWidgetIndex (pSelWidget)) >= 0))
    {
        SendMessage (ghwndList1, LB_SETCURSEL, (WPARAM) lSel, 0);
    }
}


void
InsertWidgetInList(
    PMYWIDGET pNewWidget,
    PMYWIDGET pWidgetInsertBefore
    )
{
    pNewWidget->pNext = pWidgetInsertBefore;

    if ((aWidgets == NULL) || (pWidgetInsertBefore == aWidgets))
    {
        aWidgets = pNewWidget;
    }
    else
    {
        PMYWIDGET pPrevWidget = aWidgets;


        while (pPrevWidget->pNext &&
               (pPrevWidget->pNext != pWidgetInsertBefore))
        {
            pPrevWidget = pPrevWidget->pNext;
        }

        pPrevWidget->pNext = pNewWidget;
    }

    UpdateWidgetList();
}


BOOL
RemoveWidgetFromList(
    PMYWIDGET pWidgetToRemove
    )
{
    if (aWidgets == NULL)
    {
        goto RemoveWidgetFromList_error;
    }

    if (pWidgetToRemove == aWidgets)
    {
        aWidgets = pWidgetToRemove->pNext;
    }
    else
    {
        PMYWIDGET pPrevWidget = aWidgets;


        while (pPrevWidget->pNext && (pPrevWidget->pNext != pWidgetToRemove))
        {
            pPrevWidget = pPrevWidget->pNext;
        }

        if (pPrevWidget->pNext == NULL)
        {
            goto RemoveWidgetFromList_error;
        }

        pPrevWidget->pNext = pWidgetToRemove->pNext;
    }

    free (pWidgetToRemove);

    UpdateWidgetList();

    return TRUE;

RemoveWidgetFromList_error:

    ShowStr ("Error: pWidget x%lx not found in list", pWidgetToRemove);

    return FALSE;
}


PMYLINEAPP
AllocLineApp(
    void
    )
{
    PMYLINEAPP pNewLineApp = (PMYLINEAPP) malloc (sizeof(MYLINEAPP));


    if (pNewLineApp)
    {
        PMYWIDGET pWidget = aWidgets;


        memset (pNewLineApp, 0, sizeof(MYLINEAPP));
        pNewLineApp->Widget.dwType = WT_LINEAPP;


        //
        // Insert new line app after all existing line apps, lines, & calls,
        // and before any existing phone apps
        //

        while (pWidget && (pWidget->dwType != WT_PHONEAPP))
        {
            // assert (pWidget->dwType != WT_PHONE)

            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewLineApp, pWidget);
    }

    return pNewLineApp;
}


PMYLINEAPP
GetLineApp(
    HLINEAPP hLineApp
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_LINEAPP)
        {
            PMYLINEAPP pLineApp = (PMYLINEAPP) pWidget;


            if (pLineApp->hLineApp == hLineApp)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYLINEAPP) pWidget);
}


VOID
FreeLineApp(
    PMYLINEAPP pLineApp
    )
{
    PMYWIDGET pWidget = pLineApp->Widget.pNext;


    // BUGBUG chk validity of pLineApp

    if (RemoveWidgetFromList ((PMYWIDGET) pLineApp))
    {
        while (pWidget &&
               (pWidget->dwType != WT_LINEAPP) &&
               (pWidget->dwType != WT_PHONEAPP))
        {
            PMYWIDGET pWidget2 = pWidget->pNext;


            // assert (pWidget->dwType != WT_PHONE)

            RemoveWidgetFromList (pWidget);
            pWidget = pWidget2;
        }
    }
}


PMYLINE
AllocLine(
    PMYLINEAPP pLineApp
    )
{
    PMYLINE pNewLine = (PMYLINE) malloc (sizeof(MYLINE));


    if (pNewLine)
    {
        PMYWIDGET pWidget = (PMYWIDGET) pLineApp->Widget.pNext;


        memset (pNewLine, 0, sizeof(MYLINE));
        pNewLine->Widget.dwType = WT_LINE;
        pNewLine->pLineApp = pLineApp;


        //
        // Insert new line after all existing lines & calls on specfied
        // line app, but before the next line app or phone app
        //

        while (pWidget &&
               (pWidget->dwType != WT_LINEAPP) &&
               (pWidget->dwType != WT_PHONEAPP))
        {
            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewLine, pWidget);
    }

    return pNewLine;
}


PMYLINE
GetLine(
    HLINE hLine
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_LINE)
        {
            PMYLINE pLine = (PMYLINE) pWidget;


            if (pLine->hLine == hLine)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYLINE) pWidget);
}


VOID
FreeLine(
    PMYLINE pLine
    )
{
    PMYWIDGET pWidget = pLine->Widget.pNext;


    if (RemoveWidgetFromList ((PMYWIDGET) pLine))
    {
        while (pWidget &&
               (pWidget->dwType == WT_CALL))
        {
            PMYWIDGET pWidget2 = pWidget->pNext;


            RemoveWidgetFromList (pWidget);
            pWidget = pWidget2;
        }
    }
}


PMYCALL
AllocCall(
    PMYLINE pLine
    )
{
    PMYCALL pNewCall = (PMYCALL) malloc (sizeof(MYCALL));


    if (pNewCall)
    {
        PMYWIDGET pWidget = (PMYWIDGET) pLine->Widget.pNext;


        memset (pNewCall, 0, sizeof(MYCALL));
        pNewCall->Widget.dwType = WT_CALL;
        pNewCall->pLine = pLine;

        //
        // Insert new call after all existing calls on specified line,
        // and before the next line, line app, or phone app
        //

        while (pWidget && (pWidget->dwType == WT_CALL))
        {
            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewCall, pWidget);
    }

    return pNewCall;
}


PMYCALL
GetCall(
    HCALL hCall
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_CALL)
        {
            PMYCALL pCall = (PMYCALL) pWidget;


            if (pCall->hCall == hCall)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYCALL) pWidget);
}


VOID
FreeCall(
    PMYCALL pCall
    )
{
    // BUGBUG chk validity of pCall

    RemoveWidgetFromList ((PMYWIDGET) pCall);
}


VOID
MoveCallToLine(
    PMYCALL pCall,
    HLINE hLine
    )
{
    //
    // This func gets called when a user has invoked an op that requires
    // creating a call, and we did an AllocCall() based on the currently
    // selected line/calls, but in the call params dlg the user overrode
    // the default hLine/hCall, and so we need to move the call widget
    // in the global list from under the orig specified line widget to
    // the line widget corresponding to the specified "hLine". (Note that
    // this is not a simple matter of free-ing & realloc-ing another call,
    // since TAPI saved the &pCall->hCall.)
    //

    PMYWIDGET pWidget = aWidgets;


    //
    // Remove call widget from the global list
    //

    while (pWidget->pNext != (PMYWIDGET) pCall)
    {
        pWidget = pWidget->pNext;
    }

    pWidget->pNext = pCall->Widget.pNext;


    //
    // Find the right place to insert it in list, then insert it
    //

    pWidget = (PMYWIDGET) GetLine (hLine);

    pCall->pLine = (PMYLINE) pWidget;

    while (pWidget->pNext && (pWidget->pNext->dwType == WT_CALL))
    {
        pWidget = pWidget->pNext;
    }

    pCall->Widget.pNext = pWidget->pNext;
    pWidget->pNext = (PMYWIDGET) pCall;

    UpdateWidgetList();
}


PMYPHONEAPP
AllocPhoneApp(
    void
    )
{
    PMYPHONEAPP pNewPhoneApp = (PMYPHONEAPP) malloc (sizeof(MYPHONEAPP));


    if (pNewPhoneApp)
    {
        PMYWIDGET pWidget = aWidgets;


        memset (pNewPhoneApp, 0, sizeof(MYPHONEAPP));
        pNewPhoneApp->Widget.dwType = WT_PHONEAPP;


        //
        // Insert new phone app at end of list
        //

        InsertWidgetInList ((PMYWIDGET) pNewPhoneApp, (PMYWIDGET) NULL);
    }

    return pNewPhoneApp;
}


PMYPHONEAPP
GetPhoneApp(
    HPHONEAPP hPhoneApp
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_PHONEAPP)
        {
            PMYPHONEAPP pPhoneApp = (PMYPHONEAPP) pWidget;


            if (pPhoneApp->hPhoneApp == hPhoneApp)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYPHONEAPP) pWidget);
}


VOID
FreePhoneApp(
    PMYPHONEAPP pPhoneApp
    )
{
    PMYWIDGET pWidget = pPhoneApp->Widget.pNext;


    if (RemoveWidgetFromList ((PMYWIDGET) pPhoneApp))
    {
        while (pWidget && (pWidget->dwType == WT_PHONE))
        {
            PMYWIDGET pWidget2 = pWidget->pNext;


            RemoveWidgetFromList (pWidget);
            pWidget = pWidget2;
        }
    }
}


PMYPHONE
AllocPhone(
    PMYPHONEAPP pPhoneApp
    )
{
    PMYPHONE pNewPhone = (PMYPHONE) malloc (sizeof(MYPHONE));


    if (pNewPhone)
    {
        PMYWIDGET pWidget = (PMYWIDGET) pPhoneApp->Widget.pNext;


        memset (pNewPhone, 0, sizeof(MYPHONE));
        pNewPhone->Widget.dwType = WT_PHONE;
        pNewPhone->pPhoneApp = pPhoneApp;


        //
        // Insert new phone after all phones on the specified phone app,
        // and before the next phone app
        //

        while (pWidget && (pWidget->dwType == WT_PHONE))
        {
            pWidget = pWidget->pNext;
        }

        InsertWidgetInList ((PMYWIDGET) pNewPhone, pWidget);
    }

    return pNewPhone;
}


PMYPHONE
GetPhone(
    HPHONE hPhone
    )
{
    PMYWIDGET pWidget = aWidgets;


    while (pWidget)
    {
        if (pWidget->dwType == WT_PHONE)
        {
            PMYPHONE pPhone = (PMYPHONE) pWidget;


            if (pPhone->hPhone == hPhone)
            {
                break;
            }
        }

        pWidget = pWidget->pNext;
    }

    return ((PMYPHONE) pWidget);
}


VOID
FreePhone(
    PMYPHONE pPhone
    )
{
    RemoveWidgetFromList ((PMYWIDGET) pPhone);
}


int
GetWidgetIndex(
    PMYWIDGET pWidget
    )
{
    int i;
    PMYWIDGET pWidget2 = aWidgets;


    for (i = 0; (pWidget2 && (pWidget != pWidget2)); i++)
    {
        pWidget2 = pWidget2->pNext;
    }

    if (!pWidget2)
    {
        i = -1;
    }

    return i;
}


void
SelectWidget(
    PMYWIDGET pWidget
    )
{
    int i;
    PMYWIDGET pWidget2 = aWidgets;


    for (i = 0; pWidget2; i++)
    {
        if (pWidget == pWidget2)
        {
            SendMessage (ghwndList1, LB_SETCURSEL, (WPARAM) i, 0);
            break;
        }

        pWidget2 = pWidget2->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\mmcmgmt.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    mmcmgmt.h

Abstract:

    Header file for MMC manipulation

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/

#ifndef __MMCMGMT_H__
#define __MMCMGMT_H__

#include "tapi.h"
#include "tapimmc.h"
#include "util.h"

typedef struct _USERNAME_TUPLE
{
    LPTSTR  pDomainUserNames;

    LPTSTR  pFriendlyUserNames;

} USERNAME_TUPLE, *LPUSERNAME_TUPLE;

typedef LONG (WINAPI * PMMCGETDEVICEFLAGS)(
    HMMCAPP             hMmcApp,
    BOOL                bLine,
    DWORD               dwProviderID,
    DWORD               dwPermanentDeviceID,
    DWORD               * pdwFlags,
    DWORD               * pdwDeviceID
    );

class CMMCManagement
{
public:
    CMMCManagement ()
    {
        HMODULE         hTapi32;
    
        m_pDeviceInfoList   = NULL;
        m_pUserTuple        = NULL;
        m_pProviderList     = NULL;
        m_pProviderName     = NULL;
        m_hMmc              = NULL;
        m_bMarkedBusy       = FALSE;

        hTapi32 = LoadLibrary (TEXT("tapi32.dll"));
        if (hTapi32)
        {
            m_pFuncGetDeviceFlags = (PMMCGETDEVICEFLAGS)GetProcAddress (
                hTapi32, 
                "MMCGetDeviceFlags"
                );
            FreeLibrary (hTapi32);
        }
        else
        {
            m_pFuncGetDeviceFlags = NULL;
        }
    }
    
    ~CMMCManagement ()
    {
        FreeMMCData ();
    }

    HRESULT GetMMCData ();
    HRESULT RemoveLinesForUser (LPTSTR szDomainUser);
    HRESULT IsValidPID (DWORD dwPermanentID);
    HRESULT IsValidAddress (LPTSTR szAddr);
    HRESULT AddLinePIDForUser (
        DWORD dwPermanentID, 
        LPTSTR szDomainUser,
        LPTSTR szFriendlyName
        );
    HRESULT AddLineAddrForUser (
        LPTSTR szAddr,
        LPTSTR szDomainUser,
        LPTSTR szFriendlyName
        );
    HRESULT RemoveLinePIDForUser (
        DWORD dwPermanentID,
        LPTSTR szDomainUser
        );
    HRESULT RemoveLineAddrForUser (
        LPTSTR szAddr,
        LPTSTR szDomainUser
        );

    HRESULT DisplayMMCData ();
    
    HRESULT FreeMMCData ();

private:
    
    HRESULT FindEntryFromAddr (LPTSTR szAddr, DWORD * pdwIndex);
    HRESULT FindEntryFromPID (DWORD dwPID, DWORD * pdwIndex);
    HRESULT FindEntriesForUser (
        LPTSTR      szDomainUser, 
        LPDWORD     * padwIndex,
        DWORD       * pdwNumEntries
        );
    
    HRESULT AddEntryForUser (
        DWORD   dwIndex,
        LPTSTR  szDomainUser,
        LPTSTR  szFriendlyName
        );
    HRESULT RemoveEntryForUser (
        DWORD   dwIndex,
        LPTSTR  szDomainUser
        );
    HRESULT WriteMMCEntry (DWORD dwIndex);
    BOOL IsDeviceLocalOnly (DWORD dwProviderID, DWORD dwDeviceID);

private:
    HMMCAPP             m_hMmc;
    BOOL                m_bMarkedBusy;
    DEVICEINFOLIST      * m_pDeviceInfoList;
    USERNAME_TUPLE      * m_pUserTuple;
    LINEPROVIDERLIST    * m_pProviderList;
    LPTSTR              * m_pProviderName;

    PMMCGETDEVICEFLAGS  m_pFuncGetDeviceFlags;
};

#endif // mmcmgmt.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\mmcmgmt.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    mmcmgmt.cpp

Abstract:

    Source file module for MMC manipulation

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#include <stdio.h>
#include "windows.h"
#include "objbase.h"
#include "tapi.h"

#include "mmcmgmt.h"
#include "error.h"
#include "tchar.h"
#include <locale.h>
#include <winnlsp.h>

///////////////////////////////////////////////////////////
//
//  CMMCManagement implementation
//
///////////////////////////////////////////////////////////

HRESULT CMMCManagement::GetMMCData ()
{
    HRESULT                 hr = S_OK;
    DWORD                   dwAPIVersion = TAPI_CURRENT_VERSION;
    DWORD                   dw, dw1, dw2;
    LPDEVICEINFO            pDeviceInfo;
    TAPISERVERCONFIG        cfg;
    LINEPROVIDERLIST        tapiProviderList = {0};
    LPLINEPROVIDERENTRY     pProvider;
    AVAILABLEPROVIDERLIST   tapiAvailProvList = {0};
    LPAVAILABLEPROVIDERLIST pAvailProvList = NULL;
    AVAILABLEPROVIDERENTRY  *pAvailProv;

    hr = MMCInitialize (
        NULL,           // Local computer
        &m_hMmc,        // HMMCAPP to return 
        &dwAPIVersion,  // API version
        NULL
    );
    if (FAILED(hr) || m_hMmc == NULL)
    {
        goto ExitHere;
    }

    //  Mark MMC to be busy
    cfg.dwTotalSize = sizeof(TAPISERVERCONFIG);
    hr = MMCGetServerConfig (m_hMmc, &cfg);
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    cfg.dwFlags |= TAPISERVERCONFIGFLAGS_LOCKMMCWRITE;
    hr = MMCSetServerConfig (m_hMmc, &cfg);
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    m_bMarkedBusy = TRUE;

    //  Get the DEVICEINFOLIST structure
    m_pDeviceInfoList = (LPDEVICEINFOLIST) new BYTE[sizeof(DEVICEINFOLIST)];
    if (m_pDeviceInfoList == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    m_pDeviceInfoList->dwTotalSize = sizeof(DEVICEINFOLIST);
    hr = MMCGetLineInfo (
        m_hMmc,
        m_pDeviceInfoList
        );
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    else if (m_pDeviceInfoList->dwNeededSize > m_pDeviceInfoList->dwTotalSize)
    {
        dw = m_pDeviceInfoList->dwNeededSize;
        delete [] m_pDeviceInfoList;
        m_pDeviceInfoList = (LPDEVICEINFOLIST) new BYTE[dw];
        if (m_pDeviceInfoList == NULL)
        {
            hr = TSECERR_NOMEM;
            goto ExitHere;
        }
        m_pDeviceInfoList->dwTotalSize = dw;
        hr = MMCGetLineInfo (
            m_hMmc,
            m_pDeviceInfoList
            );
        if (FAILED(hr))
        {
            goto ExitHere;
        }
    }
    if (m_pDeviceInfoList->dwNumDeviceInfoEntries == 0)
    {
        delete [] m_pDeviceInfoList;
        if (m_hMmc)
        {
            cfg.dwFlags &= (~TAPISERVERCONFIGFLAGS_LOCKMMCWRITE);
            cfg.dwFlags |= TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE;
            MMCSetServerConfig (m_hMmc, &cfg);
            m_bMarkedBusy = FALSE;
            MMCShutdown (m_hMmc);
            m_hMmc = NULL;
        }
        goto ExitHere;
    }

    //  Build the user name tuple
    m_pUserTuple = 
        new USERNAME_TUPLE[m_pDeviceInfoList->dwNumDeviceInfoEntries];
    if (m_pUserTuple == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    pDeviceInfo = (LPDEVICEINFO)(((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset);
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries; 
        ++dw, ++pDeviceInfo)
    {
        if (pDeviceInfo->dwDomainUserNamesSize == 0)
        {
            m_pUserTuple[dw].pDomainUserNames = NULL;
            m_pUserTuple[dw].pFriendlyUserNames = NULL;
        }
        else
        {
            m_pUserTuple[dw].pDomainUserNames = 
                (LPTSTR) new BYTE[pDeviceInfo->dwDomainUserNamesSize];
            m_pUserTuple[dw].pFriendlyUserNames =
                (LPTSTR) new BYTE[pDeviceInfo->dwFriendlyUserNamesSize];
            if (m_pUserTuple[dw].pDomainUserNames == NULL ||
                m_pUserTuple[dw].pFriendlyUserNames == NULL)
            {
                hr = TSECERR_NOMEM;
                goto ExitHere;
            }
            memcpy (
                m_pUserTuple[dw].pDomainUserNames,
                (((LPBYTE)m_pDeviceInfoList) + 
                    pDeviceInfo->dwDomainUserNamesOffset),
                pDeviceInfo->dwDomainUserNamesSize
                );
            memcpy (
                m_pUserTuple[dw].pFriendlyUserNames,
                (((LPBYTE)m_pDeviceInfoList) + 
                    pDeviceInfo->dwFriendlyUserNamesOffset),
                pDeviceInfo->dwFriendlyUserNamesSize
                );
        }
    }

    // Get the provider list
    tapiProviderList.dwTotalSize = sizeof(LINEPROVIDERLIST);
    hr = MMCGetProviderList( m_hMmc, &tapiProviderList);
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    m_pProviderList = (LPLINEPROVIDERLIST) new BYTE[tapiProviderList.dwNeededSize];
    if (NULL == m_pProviderList)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    memset(m_pProviderList, 0, tapiProviderList.dwNeededSize);
    m_pProviderList->dwTotalSize = tapiProviderList.dwNeededSize;

    hr = MMCGetProviderList( m_hMmc, m_pProviderList);
    if (FAILED(hr) || !m_pProviderList->dwNumProviders)
    {
        goto ExitHere;
    }

    // Get the available providers

    tapiAvailProvList.dwTotalSize = sizeof(LINEPROVIDERLIST);
    hr = MMCGetAvailableProviders (m_hMmc, &tapiAvailProvList);
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    pAvailProvList = (LPAVAILABLEPROVIDERLIST) new BYTE[tapiAvailProvList.dwNeededSize];
    if (NULL == pAvailProvList)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    memset(pAvailProvList, 0, tapiAvailProvList.dwNeededSize);
    pAvailProvList->dwTotalSize = tapiAvailProvList.dwNeededSize;

    hr = MMCGetAvailableProviders (m_hMmc, pAvailProvList);
    if (FAILED(hr) || !pAvailProvList->dwNumProviderListEntries)
    {
        delete [] pAvailProvList;
        goto ExitHere;
    }

    m_pProviderName = new LPTSTR[ m_pProviderList->dwNumProviders ];
    if (NULL == m_pProviderName)
    {
        hr = TSECERR_NOMEM;
        delete [] pAvailProvList;
        goto ExitHere;
    }
    memset(m_pProviderName, 0, m_pProviderList->dwNumProviders * sizeof (LPTSTR) );

    // find providers friendly name 
    LPTSTR szAvailProvFilename;
    LPTSTR szProviderFilename;
    LPTSTR szAvailProvFriendlyName;

    pProvider = (LPLINEPROVIDERENTRY) 
                    ((LPBYTE) m_pProviderList + m_pProviderList->dwProviderListOffset);

    for( dw1=0; dw1 < m_pProviderList->dwNumProviders; dw1++, pProvider++ )
    {
        szProviderFilename = 
            (LPTSTR) ((LPBYTE) m_pProviderList + pProvider->dwProviderFilenameOffset);

        for ( dw2=0; dw2 < pAvailProvList->dwNumProviderListEntries; dw2++ )
        {
            pAvailProv = (LPAVAILABLEPROVIDERENTRY) 
                        (( LPBYTE) pAvailProvList + pAvailProvList->dwProviderListOffset) + dw2;
            szAvailProvFilename = 
                (LPTSTR) ((LPBYTE) pAvailProvList + pAvailProv->dwFileNameOffset);
            if (_tcsicmp(szAvailProvFilename, szProviderFilename) == 0)
            {
                szAvailProvFriendlyName = 
                    (LPTSTR) ((LPBYTE) pAvailProvList + pAvailProv->dwFriendlyNameOffset);
                m_pProviderName[ dw1 ] = new TCHAR[ _tcslen( szAvailProvFriendlyName ) + 1 ];
                if (m_pProviderName[ dw1 ])
                {
                    _tcscpy( m_pProviderName[ dw1 ], szAvailProvFriendlyName );
                }
                break;
            }
        }
    }

    delete [] pAvailProvList;

ExitHere:
    if (FAILED(hr))
    {
        FreeMMCData ();
    }
    return hr;
}

HRESULT CMMCManagement::FreeMMCData ()
{
    DWORD       dw;
    
    if (m_pUserTuple && m_pDeviceInfoList)
    {
        for (dw = 0; 
            dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
            ++dw)
        {
            if (m_pUserTuple[dw].pDomainUserNames)
            {
                delete [] m_pUserTuple[dw].pDomainUserNames;
            }
            if (m_pUserTuple[dw].pFriendlyUserNames)
            {
                delete [] m_pUserTuple[dw].pFriendlyUserNames;
            }
        }
        delete [] m_pUserTuple;
        m_pUserTuple = NULL;
    }
    if (m_pDeviceInfoList)
    {
        delete [] m_pDeviceInfoList;
        m_pDeviceInfoList = NULL;
    }
    if (m_pProviderList)
    {
        delete [] m_pProviderList;
        m_pProviderList = NULL;
    }
    if (m_pProviderName)
    {
        for ( DWORD dw=0; dw < sizeof( m_pProviderName ) / sizeof(LPTSTR); dw++ )
        {
            if (m_pProviderName[ dw ])
            {
                delete [] m_pProviderName[ dw ];
            }
        }
        delete [] m_pProviderName;
    }

    if (m_bMarkedBusy && m_hMmc)
    {
        TAPISERVERCONFIG            cfg;
    
        cfg.dwTotalSize = sizeof(TAPISERVERCONFIG);
        if (S_OK == MMCGetServerConfig (m_hMmc, &cfg))
        {
            cfg.dwFlags |= TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE;
            MMCSetServerConfig (m_hMmc, &cfg);
        }
        m_bMarkedBusy = FALSE;
    }
    if (m_hMmc)
    {
        MMCShutdown (m_hMmc);
        m_hMmc = NULL;
    }

    return S_OK;
}

HRESULT CMMCManagement::RemoveLinesForUser (LPTSTR szDomainUser)
{
    HRESULT             hr = S_OK;
    LPDWORD             adwIndex = NULL;
    DWORD               dwNumEntries;
    DWORD               dw;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntriesForUser (szDomainUser, &adwIndex, &dwNumEntries);
    if (hr)
    {
        goto ExitHere;
    }
    for (dw = 0; dw < dwNumEntries; ++dw)
    {
        hr = RemoveEntryForUser (
            adwIndex[dw],
            szDomainUser
            );
        if(FAILED(hr))
        {
            goto ExitHere;
        }
    }

ExitHere:
    if (adwIndex)
    {
        delete [] adwIndex;
    }
    return hr;
}

HRESULT CMMCManagement::IsValidPID (
    DWORD   dwPermanentID
    )
{
    DWORD   dwEntry;

    return FindEntryFromPID (dwPermanentID, &dwEntry);
}

HRESULT CMMCManagement::IsValidAddress (
    LPTSTR  szAddr
    )
{
    DWORD   dwEntry;

    return FindEntryFromAddr (szAddr, &dwEntry);
}

HRESULT CMMCManagement::AddLinePIDForUser (
    DWORD dwPermanentID, 
    LPTSTR szDomainUser,
    LPTSTR szFriendlyName
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromPID (dwPermanentID, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = AddEntryForUser (dwEntry, szDomainUser, szFriendlyName);

ExitHere:
    return hr;
}

HRESULT CMMCManagement::AddLineAddrForUser (
    LPTSTR szAddr,
    LPTSTR szDomainUser,
    LPTSTR szFriendlyName
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromAddr (szAddr, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = AddEntryForUser (dwEntry, szDomainUser, szFriendlyName);

ExitHere:
    return hr;
}

HRESULT CMMCManagement::RemoveLinePIDForUser (
    DWORD dwPermanentID,
    LPTSTR szDomainUser
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromPID (dwPermanentID, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = RemoveEntryForUser (dwEntry, szDomainUser);

ExitHere:
    return hr;
}

HRESULT CMMCManagement::RemoveLineAddrForUser (
    LPTSTR szAddr,
    LPTSTR szDomainUser
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwEntry;

    // Ensure we are properly initialized
    if (m_hMmc == NULL)
    {
        goto ExitHere;
    }
    hr = FindEntryFromAddr (szAddr, &dwEntry);
    if (hr)
    {
        goto ExitHere;
    }
    hr = RemoveEntryForUser (dwEntry, szDomainUser);

ExitHere:
    return hr;
}

BOOL CMMCManagement::IsDeviceLocalOnly (DWORD dwProviderID, DWORD dwDeviceID)
{
    HRESULT             hr;
    DWORD               dwFlags, dwDev;

    if (m_pFuncGetDeviceFlags == NULL)
    {
        return TRUE;
    }

    hr = (*m_pFuncGetDeviceFlags)(
        m_hMmc,
        TRUE,
        dwProviderID,
        dwDeviceID,
        &dwFlags,
        &dwDev
        );
    if (hr || dwFlags & LINEDEVCAPFLAGS_LOCAL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


HRESULT CMMCManagement::FindEntryFromAddr (LPTSTR szAddr, DWORD * pdwIndex)
{
    HRESULT             hr = S_FALSE;
    DWORD               dw;
    LPDEVICEINFO        pDevInfo;
    LPTSTR              szAddr2;

    pDevInfo = (LPDEVICEINFO) (((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset);
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
        ++dw, ++pDevInfo)
    {
        szAddr2 = (LPTSTR)(((LPBYTE)m_pDeviceInfoList) +
            pDevInfo->dwAddressesOffset);
        while (*szAddr2)
        {
            if (_tcsicmp (szAddr, szAddr2) == 0)
            {
                if (IsDeviceLocalOnly (
                    pDevInfo->dwProviderID,
                    pDevInfo->dwPermanentDeviceID
                    ))
                {
                    hr = TSECERR_DEVLOCALONLY;
                }
                else
                {
                    hr = S_OK;
                    *pdwIndex = dw;
                }
                goto ExitHere;
            }
            szAddr2 += _tcslen (szAddr2) + 1;
        }
    }
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::FindEntryFromPID (DWORD dwPID, DWORD * pdwIndex)
{
    HRESULT             hr = S_FALSE;
    DWORD               dw;
    LPDEVICEINFO        pDevInfo;

    pDevInfo = (LPDEVICEINFO) (((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset);
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
        ++dw, ++pDevInfo)
    {
        if (dwPID == pDevInfo->dwPermanentDeviceID)
        {
            if (IsDeviceLocalOnly (
                pDevInfo->dwProviderID,
                pDevInfo->dwPermanentDeviceID
                ))
            {
                hr = TSECERR_DEVLOCALONLY;
            }
            else
            {
                *pdwIndex = dw;
                hr = S_OK;
            }
            goto ExitHere;
        }
    }
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::FindEntriesForUser (
    LPTSTR      szDomainUser, 
    LPDWORD     * padwIndex,
    DWORD       * pdwNumEntries
    )
{
    HRESULT             hr = S_OK;
    DWORD               dw;
    LPTSTR              szUsers;
    LPDWORD             adw;

    *padwIndex = NULL;
    *pdwNumEntries = 0;
    for (dw = 0; 
        dw < m_pDeviceInfoList->dwNumDeviceInfoEntries;
        ++dw)
    {
        szUsers = m_pUserTuple[dw].pDomainUserNames;
        while (szUsers && *szUsers)
        {
            if (_tcsicmp (szDomainUser, szUsers) == 0)
            {
                hr = S_OK;
                adw = new DWORD[*pdwNumEntries + 1];
                if (adw == NULL)
                {
                    hr = TSECERR_NOMEM;
                    goto ExitHere;
                }
                if (*pdwNumEntries > 0)
                {
                    memcpy (adw, *padwIndex, sizeof(DWORD) * (*pdwNumEntries));
                }
                if (*padwIndex)
                {
                    delete [] (*padwIndex);
                }
                *padwIndex = adw;
                adw[*pdwNumEntries] = dw;
                *pdwNumEntries += 1;
            }
            szUsers += _tcslen (szUsers) + 1;
        }
    }
    
ExitHere:
    if (FAILED(hr))
    {
        *pdwNumEntries = 0;
        if (*padwIndex)
        {
            delete [] (*padwIndex);
        }
    }
    else if (*pdwNumEntries == 0)
    {
        hr = S_FALSE;
    }
    return hr;
}
    
HRESULT CMMCManagement::AddEntryForUser (
    DWORD   dwIndex,
    LPTSTR  szDomainUser,
    LPTSTR  szFriendlyName
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwSize, dw;
    LPTSTR              szUsers, szNewUsers = NULL, szNewFriendlyNames = NULL;

    if (dwIndex >= m_pDeviceInfoList->dwNumDeviceInfoEntries ||
        szDomainUser[0] == 0 ||
        szFriendlyName[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    //
    //  Add szDomainUser into the user tuple
    //

    //  Computer the existing domain user size and make sure
    //  this user is not there already
    dwSize = 0;
    szUsers = m_pUserTuple[dwIndex].pDomainUserNames;
    while (szUsers && *szUsers)
    {
        if (_tcsicmp (szDomainUser, szUsers) == 0)
        {
            goto ExitHere;
        }
        dw = _tcslen (szUsers) + 1;
        dwSize += dw;
        szUsers += dw;
    }
    
    //  Extra space for double zero terminating
    dw = _tcslen (szDomainUser);
    szNewUsers = new TCHAR[dwSize + dw + 2];
    if (szNewUsers == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  copy over the old domain users
    if (dwSize > 0)
    {
        memcpy (
            szNewUsers, 
            m_pUserTuple[dwIndex].pDomainUserNames, 
            dwSize * sizeof(TCHAR)
            );
    }

    //  Append the new domain user
    memcpy (
        szNewUsers + dwSize, 
        szDomainUser, 
        (dw + 1) * sizeof(TCHAR)
        );

    //  double zero terminate and assign the data
    szNewUsers[dwSize + dw + 1] = 0;

    //
    //  Add the szFriendlyName into the user tuple
    //

    //  Compute the existing friendly names size
    dwSize = 0;
    szUsers = m_pUserTuple[dwIndex].pFriendlyUserNames;
    while (szUsers && *szUsers)
    {
        dw = _tcslen (szUsers) + 1;
        dwSize += dw;
        szUsers += dw;
    }

    //  Extra space for double zero terminating
    dw = _tcslen (szFriendlyName);
    szNewFriendlyNames = new TCHAR[dwSize + dw + 2];
    if (szNewFriendlyNames == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  Copy over the old friendly names
    if (dwSize > 0)
    {
        memcpy (
            szNewFriendlyNames,
            m_pUserTuple[dwIndex].pFriendlyUserNames,
            dwSize * sizeof(TCHAR)
            );
    }

    //  Append the new friendly name
    memcpy (
        szNewFriendlyNames + dwSize,
        szFriendlyName,
        (dw + 1) * sizeof(TCHAR)
        );

    //  Double zero terminate the friend names
    szNewFriendlyNames[dwSize + dw + 1] = 0;

    //
    //  Everything is fine, set the new data in
    //
    if (m_pUserTuple[dwIndex].pDomainUserNames)
    {
        delete [] m_pUserTuple[dwIndex].pDomainUserNames;
    }
    m_pUserTuple[dwIndex].pDomainUserNames = szNewUsers;
    if (m_pUserTuple[dwIndex].pFriendlyUserNames)
    {
        delete [] m_pUserTuple[dwIndex].pFriendlyUserNames;
    }
    m_pUserTuple[dwIndex].pFriendlyUserNames = szNewFriendlyNames;
    
    //  Call WriteMMCEntry
    hr = WriteMMCEntry (dwIndex);
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::RemoveEntryForUser (
    DWORD   dwIndex,
    LPTSTR  szDomainUser
    )
{
    HRESULT             hr = S_OK;
    LPTSTR              szLoc, szUsers;
    DWORD               dwLoc, dw, dwSize;
    BOOL                bFound;

    if (dwIndex >= m_pDeviceInfoList->dwNumDeviceInfoEntries ||
        szDomainUser[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    
    //  Locate the domain user and its index in the array
    //  of domain users
    szUsers = m_pUserTuple[dwIndex].pDomainUserNames;
    dwLoc = 0;
    dwSize = 0;
    bFound = FALSE;
    while (szUsers && *szUsers)
    {
        dw = _tcslen (szUsers) + 1;
        if (bFound)
        {
            dwSize += dw;
        }
        else
        {
            if (_tcsicmp (szDomainUser, szUsers) == 0)
            {
                bFound = TRUE;
                szLoc = szUsers;
            }
            else
            {
                ++dwLoc;
            }
        }
        szUsers += dw;
    }
    if (!bFound)
    {
        goto ExitHere;
    }

    //  Move down the pszDomainUserNames
    if (dwSize > 0)
    {
        dw = _tcslen (szDomainUser);
        //  Memory copy includes the double zero terminator
        memmove (szLoc, szLoc + dw + 1, (dwSize + 1) * sizeof(TCHAR));
    }
    else
    {
        // The is the last item, simple double zero terminate
        *szLoc = 0;
    }

    //  Now find corresponding friendly name based on dwLoc
    szUsers = m_pUserTuple[dwIndex].pFriendlyUserNames;
    while (szUsers && *szUsers && dwLoc > 0)
    {
        --dwLoc;
        szUsers += _tcslen (szUsers) + 1;
    }
    //  bail if not exist, otherwise, remember the location
    if (szUsers == NULL || *szUsers == 0)
    {
        goto ExitHere;
    }
    szLoc = szUsers;
    //  Go to the next item
    szUsers += _tcslen (szUsers) + 1;
    //  This is the last item
    if (*szUsers == 0)
    {
        *szLoc = 0;
    }
    //  Otherwise compute the remaining size to move
    else
    {
        dwSize = 0;
        while (*szUsers)
        {
            dw = _tcslen (szUsers) + 1;
            dwSize += dw;
            szUsers += dw;
        }
        //  Compensate for the double zero terminating
        dwSize++;
        //  Do the memory move
        memmove (
            szLoc, 
            szLoc + _tcslen (szLoc) + 1,
            dwSize * sizeof(TCHAR)
            );
    }
    
    //  Call WriteMMCEntry
    hr = WriteMMCEntry (dwIndex);
    
ExitHere:
    return hr;
}

HRESULT CMMCManagement::WriteMMCEntry (DWORD dwIndex)
{
    HRESULT             hr = S_OK;
    DWORD               dwSize, dwSizeDU, dwSizeFU;
    LPUSERNAME_TUPLE    pUserTuple;
    LPTSTR              szUsers;
    DWORD               dw;
    LPDEVICEINFOLIST    pDevList = NULL;
    LPDEVICEINFO        pDevInfo, pDevInfoOld;
    LPBYTE              pDest;

    if (dwIndex >= m_pDeviceInfoList->dwNumDeviceInfoEntries)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    pUserTuple = m_pUserTuple + dwIndex;

    //  Computer domain user name size
    dwSizeDU = 0;
    if (pUserTuple->pDomainUserNames != NULL &&
        *pUserTuple->pDomainUserNames != 0)
    {
        szUsers = pUserTuple->pDomainUserNames;
        while (*szUsers)
        {
            dw = _tcslen (szUsers) + 1;
            szUsers += dw;
            dwSizeDU += dw;
        }
        dwSizeDU++; //  double zero terminator
    }

    //  Computer the friendly user name size
    dwSizeFU = 0;
    if (pUserTuple->pFriendlyUserNames != NULL &&
        *pUserTuple->pFriendlyUserNames != 0)
    {
        szUsers = pUserTuple->pFriendlyUserNames;
        while (*szUsers)
        {
            dw = _tcslen (szUsers) + 1;
            szUsers += dw;
            dwSizeFU += dw;
        }
        dwSizeFU++; //  double zero terminator
    }

    //  Computer the total size
    dwSize = sizeof(DEVICEINFOLIST) + sizeof(DEVICEINFO) + 
        (dwSizeDU + dwSizeFU) * sizeof(TCHAR);

    //  Allocate the structure
    pDevList = (LPDEVICEINFOLIST) new BYTE[dwSize];
    if (pDevList == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  Set the data member of DEVICEINFOLIST
    pDevList->dwTotalSize = dwSize;
    pDevList->dwNeededSize = dwSize;
    pDevList->dwUsedSize = dwSize;
    pDevList->dwNumDeviceInfoEntries = 1;
    pDevList->dwDeviceInfoSize = sizeof(DEVICEINFO);
    pDevList->dwDeviceInfoOffset = sizeof(DEVICEINFOLIST);

    //  Set the member of DEVICEINFO
    pDevInfo = (LPDEVICEINFO)(((LPBYTE)pDevList) + 
        pDevList->dwDeviceInfoOffset);
    pDevInfoOld = (LPDEVICEINFO)(((LPBYTE)m_pDeviceInfoList) + 
        m_pDeviceInfoList->dwDeviceInfoOffset) + dwIndex;
    memset (pDevInfo, 0, sizeof(DEVICEINFO));
    
    pDevInfo->dwPermanentDeviceID = pDevInfoOld->dwPermanentDeviceID;
    pDevInfo->dwProviderID = pDevInfoOld->dwProviderID;

    if (dwSizeDU > 0)
    {
        pDevInfo->dwDomainUserNamesSize = dwSizeDU * sizeof(TCHAR);
        pDevInfo->dwDomainUserNamesOffset = 
            sizeof(DEVICEINFOLIST) + sizeof(DEVICEINFO);
        pDest = ((LPBYTE)pDevList) + pDevInfo->dwDomainUserNamesOffset;
        memcpy (
            pDest,
            pUserTuple->pDomainUserNames,
            dwSizeDU * sizeof(TCHAR)
            );
    }

    if (dwSizeFU)
    {
        pDevInfo->dwFriendlyUserNamesSize = dwSizeFU * sizeof(TCHAR);
        pDevInfo->dwFriendlyUserNamesOffset = 
            pDevInfo->dwDomainUserNamesOffset + dwSizeDU * sizeof(TCHAR);
        pDest = ((LPBYTE)pDevList) + pDevInfo->dwFriendlyUserNamesOffset;
        memcpy (
            pDest,
            pUserTuple->pFriendlyUserNames,
            dwSizeFU * sizeof(TCHAR)
            );
    }

    hr = MMCSetLineInfo (
        m_hMmc,
        pDevList
        );

ExitHere:
    if (pDevList)
    {
        delete [] pDevList;
    }
    return hr;
}

HRESULT CMMCManagement::DisplayMMCData ()
{
    HRESULT             hr = S_OK;
    LPDEVICEINFO        pDeviceInfo;
    DWORD *             pdwIndex = NULL;
    DWORD               dwProviderId;
    DWORD               dwAddressCount,dw1,dw2;
    LPLINEPROVIDERENTRY pProvider;
    LPTSTR              pUserName;
    LPTSTR              pAddress, 
                        pAddressFirst, 
                        pAddressLast;
    UINT                Codepage;
    char                achCodepage[12] = ".OCP"; 

    if ( !m_pDeviceInfoList || !m_pDeviceInfoList->dwNumDeviceInfoEntries )
    {
        CIds IdsNoDevices (IDS_NODEVICES);
        _tprintf ( IdsNoDevices.GetString () );
        return hr;
    }

    //
    // Build an index by provider ID
    //
    pdwIndex = new DWORD [ m_pDeviceInfoList->dwNumDeviceInfoEntries ];
    if ( !pdwIndex )
    {
        hr = TSECERR_NOMEM;
        return hr;
    }

    for ( dw1=0; dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries; dw1++ )
    {
        pdwIndex[ dw1 ] = dw1;
    }

    if (Codepage = GetConsoleOutputCP()) {
        wsprintfA(achCodepage, ".%u", Codepage);
        setlocale(LC_ALL, achCodepage);
    }
    else
    {
        setlocale (LC_COLLATE, achCodepage );  
        setlocale (LC_MONETARY, achCodepage ); 
        setlocale (LC_NUMERIC, achCodepage );  
        setlocale (LC_TIME, achCodepage );     
    }

    SetThreadUILanguage(0);


    dw1 = 0;
    while ( dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries )
    {

        pDeviceInfo = (LPDEVICEINFO)((LPBYTE)m_pDeviceInfoList +
                    m_pDeviceInfoList->dwDeviceInfoOffset) + pdwIndex[ dw1 ];
        dwProviderId = pDeviceInfo->dwProviderID;
        dw1++;

        for ( dw2=dw1; dw2 < m_pDeviceInfoList->dwNumDeviceInfoEntries; dw2++ )
        {
            pDeviceInfo = (LPDEVICEINFO)((LPBYTE)m_pDeviceInfoList +
                    m_pDeviceInfoList->dwDeviceInfoOffset) + pdwIndex[ dw2 ];

            if ( dwProviderId == pDeviceInfo->dwProviderID )
            {
                DWORD   dwTemp  = pdwIndex[ dw2 ];
                pdwIndex[ dw2 ] = pdwIndex[ dw1 ];
                pdwIndex[ dw1 ] = dwTemp;
                dw1++;
            }
        }
    }

    //
    // Display the device list
    //
    dw1 = 0;
    while ( dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries )
    {
        pDeviceInfo = (LPDEVICEINFO)((LPBYTE)m_pDeviceInfoList +
                    m_pDeviceInfoList->dwDeviceInfoOffset) + pdwIndex[ dw1 ];
        dwProviderId = pDeviceInfo->dwProviderID;

        // find the provider entry
        pProvider = (LPLINEPROVIDERENTRY) ((LPBYTE) m_pProviderList + m_pProviderList->dwProviderListOffset);
        for( dw2=0; dw2 < m_pProviderList->dwNumProviders; dw2++, pProvider++ )
        {
            if ( dwProviderId == pProvider->dwPermanentProviderID )
            {
                break;
            }
        }

        // display the provider name
        if ( dw2 < m_pProviderList->dwNumProviders )
        {
            // provider entry found
            _tprintf( 
                _T("\n%s\n"), 
                m_pProviderName[ dw2 ] ? m_pProviderName[ dw2 ] : 
                    (LPTSTR)((LPBYTE) m_pProviderList + pProvider->dwProviderFilenameOffset)
                );
        }
        else 
        {
            CIds IdsProvider (IDS_PROVIDER);
            _tprintf( IdsProvider.GetString(), dwProviderId );
        }

        // list devices / users for this provider
        do
        {
            CIds IdsLine (IDS_LINE);
            CIds IdsPermanentID (IDS_PID);
            CIds IdsAddresses (IDS_ADDRESSES);

            _tprintf( IdsLine.GetString(),
                (LPTSTR)((LPBYTE)m_pDeviceInfoList + pDeviceInfo->dwDeviceNameOffset));
            _tprintf( IdsPermanentID.GetString(), pDeviceInfo->dwPermanentDeviceID);
            if ( pDeviceInfo->dwFriendlyUserNamesSize )
            {
                CIds IdsUsers (IDS_USERS);
                _tprintf ( IdsUsers.GetString () );

                pUserName = (LPTSTR) (((LPBYTE) m_pDeviceInfoList) +
                    pDeviceInfo->dwFriendlyUserNamesOffset);
                while ( *pUserName != _T('\0') )
                {
                    _tprintf( _T("\t\t\t%s\n"), pUserName );
                    pUserName += _tcslen (pUserName) + 1;
                }
            }
            if ( pDeviceInfo->dwAddressesSize )
            {
                _tprintf( IdsAddresses.GetString() );
                pAddress = (LPTSTR) (((LPBYTE) m_pDeviceInfoList) +
                    pDeviceInfo->dwAddressesOffset);
                while ( *pAddress != _T('\0') )
                {
                    _tprintf( _T("\t\t\t%s\n"), pAddress );
                    pAddress += _tcslen (pAddress) + 1;
                }
            }

            dw1++;
            pDeviceInfo++;        
        }
        while ( dw1 < m_pDeviceInfoList->dwNumDeviceInfoEntries &&
                pDeviceInfo->dwProviderID == dwProviderId );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\error.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    error.h

Abstract:

    Header file for errors in this module

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#ifndef __ERROR_H__
#define __ERROR_H__

#include "tsecerr.h"

#define FACILITY_TSEC_CODE  0x100

#define HRESULT_FROM_TSEC(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_TSEC_CODE << 16) | 0x80000000)))

#define TSECERR_SUCCESS         HRESULT_FROM_TSEC(TSEC_SUCCESS)
#define TSECERR_NOMEM           HRESULT_FROM_TSEC(TSEC_NOMEM)
#define TSECERR_BADFILENAME     HRESULT_FROM_TSEC(TSEC_BADFILENAME)
#define TSECERR_FILENOTEXIST    HRESULT_FROM_TSEC(TSEC_FILENOTEXIST)
#define TSECERR_INVALFILEFORMAT HRESULT_FROM_TSEC(TSEC_INVALFILEFORMAT)
#define TSECERR_DEVLOCALONLY    HRESULT_FROM_TSEC(TSEC_DEVLOCALONLY)

#endif // error.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\parser.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    parser.h

Abstract:

    Header file for parsing XML file

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/

#ifndef __PARSER_H__
#define __PARSER_H__

#include "windows.h"
#include "objbase.h"
#include "msxml.h"

class CXMLLine
{
public:
    CXMLLine (IXMLDOMNode * pNode)
    {
        m_pLineNode = pNode;
    }

    ~CXMLLine ()
    {
        if (m_pLineNode)
        {
            m_pLineNode->Release();
        }
    }

    HRESULT GetNextLine (CXMLLine ** ppLine);

    HRESULT GetAddress (LPTSTR szBuf, DWORD cch);
    HRESULT GetPermanentID (ULONG * pID);
    HRESULT IsPermanentID (BOOL *pb);
    HRESULT IsRemove (BOOL *pb);
    
private:
    IXMLDOMNode     * m_pLineNode;
};

class CXMLUser
{
public:
    CXMLUser (IXMLDOMNode * pNode)
    {
        m_pUserNode = pNode;
    }

    ~CXMLUser ()
    {
        if (m_pUserNode)
        {
            m_pUserNode->Release();
        }
    }

    HRESULT GetFirstLine (CXMLLine ** ppLine);
    
    HRESULT GetNextUser (CXMLUser **ppNextUser);

    HRESULT GetDomainUser (LPTSTR szBuf, DWORD cch);
    HRESULT GetFriendlyName (LPTSTR szBuf, DWORD cch);
    HRESULT IsNoMerge (BOOL *pb);
    
private:
    IXMLDOMNode     * m_pUserNode;
};

class CXMLParser 
{
public:

    //
    //  Constructors / destructors
    //
    
    CXMLParser (void);
    ~CXMLParser ();

    //
    //  Public functions
    //

    HRESULT SetXMLFile (LPCTSTR szFile);
    HRESULT GetXMLFile (LPTSTR szFile, DWORD cch);

    HRESULT Parse (void);
    HRESULT ReportParsingError ();

    void Release()
    {
        if (m_pDocInput)
        {
            m_pDocInput->Release();
            m_pDocInput = NULL;
        }
    }

    //
    //  User transversal
    //
    HRESULT GetFirstUser (CXMLUser ** ppUser);

protected:

private:
    HRESULT CreateTempFiles ();

private:
    BOOL            m_bInited;
    
    TCHAR           m_szXMLFile[MAX_PATH];
    IXMLDOMDocument * m_pDocInput;

    TCHAR           m_szTempSchema[MAX_PATH];
    TCHAR           m_szTempXML[MAX_PATH];
};

#endif // parser.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\ids.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    ids.cpp

Abstract:

    Source file module for string resource manipulation

Author:

    Elena Apreutesei (elenaap)    30-October-2000

Revision History:

--*/

#include "windows.h"
#include "util.h"

HMODULE CIds::m_hModule = NULL;

void CIds::GetModuleHnd (void)
{
    if (!m_hModule)
    {
        m_hModule = GetModuleHandle(NULL);
    }
}

void CIds::LoadIds (UINT resourceID)
{
    TCHAR szBuffer[ MAX_IDS_BUFFER_SIZE ];

    if (m_hModule != NULL &&
        LoadString (
            m_hModule,
            resourceID,
            szBuffer,
            MAX_IDS_BUFFER_SIZE - 1 ) > 0)
    {
        m_szString = new TCHAR [ _tcslen( szBuffer ) + 1 ];
        if ( m_szString )
        {
            _tcscpy( m_szString, szBuffer );
        }
    }
    else
    {
        m_szString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\resource.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource header file for the TAPI security file importing

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/

#ifndef __TSECIMP_RESOURCE_H__
#define __TSECIMP_RESOURCE_H__

#define SCHEMARES                       300

#define IDD_MSGBOX                      100

#define IDC_MSGBOX_TEXT                 100

#define IDS_SECFILE_SCHEMA              1000
#define IDR_SCHEMA                      1001
#define IDS_PRODUCTNAME                 1002
#define IDS_USAGE                       1003
#define IDS_ERRORPOS                    1004
#define IDS_FINSUCCESS                  1005
#define IDS_VALIDSUCCESS                1006
#define IDS_INVALADDR                   1007
#define IDS_INVALPID                    1008
#define IDS_INVALIDUSER                 1009
#define IDS_LOCALONLYPID                1010
#define IDS_LOCALONLYADDR               1011
#define IDS_HASERROR                    1012
#define IDS_PROVIDER                    1013
#define IDS_LINE                        1014
#define IDS_ADDRESSES                   1015
#define IDS_NODEVICES                   1016
#define IDS_ERROR                       1017
#define IDS_USERS                       1018
#define IDS_PID                         1019

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\parser.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    parser.cpp

Abstract:

    Source file module for parsing XML file

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#include "windows.h"
#include "objbase.h"
#include "msxml.h"

#include "error.h"
#include "parser.h"
#include "resource.h"
#include "tchar.h"
#include "util.h"

const TCHAR CIds::m_szEmptyString[2] = _T("");

void WINAPI FormatString (
    LPTSTR          szFmt,
    LPTSTR          szOutput,
    DWORD           cchOutput,
    ...
    )
{
    va_list             ap;

    va_start (ap, cchOutput);

    FormatMessage (
        FORMAT_MESSAGE_FROM_STRING,
        szFmt,
        0,
        0,
        szOutput,
        cchOutput,
        &ap
        );
 
    va_end (ap);
}

///////////////////////////////////////////////////////////
//
//  CXMLParser implementation
//
///////////////////////////////////////////////////////////

//
//  With the XML file provided by the user, we create a temporary file
//  with the format of
//      <TsecRoot xmlns="x-schema:file://c:\temp\Sche1111.tmp">
//          Original XML file goes here
//      </TsecRoot>
//  for validating with the schema
//
char       gszXMLHeader1[] = "<TsecRoot xmlns=\"x-schema:file://";
char       gszXMLHeader2[] = "\">\r\n";
char       gszXMLTail[] = "\r\n</TsecRoot>";

//
//  Constructor / Destructor
//

CXMLParser::CXMLParser (void)
{
    m_bInited = FALSE;
    m_szXMLFile[0] = 0;
    m_szTempSchema[0] = 0;
    m_szTempXML[0] = 0;
    m_pDocInput = NULL;
}

CXMLParser::~CXMLParser ()
{
    if (m_pDocInput)
        m_pDocInput->Release();
}

//
//  Public functions
//

HRESULT CXMLParser::SetXMLFile (LPCTSTR szFile)
{
    HRESULT     hr = S_OK;
    OFSTRUCT    ofs;
    HANDLE      hFile;

    if (szFile == NULL ||
        _tcslen(szFile) > sizeof(m_szXMLFile)/sizeof(TCHAR) - 1)
    {
        hr = TSECERR_BADFILENAME;
        goto ExitHere;
    }
    if ((hFile = CreateFile (
        szFile,
        0,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        )) == INVALID_HANDLE_VALUE)
    {
        hr = TSECERR_FILENOTEXIST;
        goto ExitHere;
    }
    else
    {
        CloseHandle (hFile);
    }
    _tcscpy (m_szXMLFile, szFile);

ExitHere:
    return hr;
}

HRESULT CXMLParser::GetXMLFile (LPTSTR szFile, DWORD cch)
{
    return E_NOTIMPL;
}

HRESULT CXMLParser::CreateTempFiles ()
{
    HRESULT             hr = S_OK;
    
    TCHAR               szTempPath[MAX_PATH];
    char                szAnsiFile[MAX_PATH * sizeof(TCHAR)];

    HINSTANCE           hModule;
    HRSRC               hRes;
    HGLOBAL             hSchema;
    LPVOID              lpSchema;
    DWORD               dwSchemaSize;

    HANDLE              hFileSchema = NULL;
    DWORD               dwBytesWritten;
    HANDLE              hFileXML = NULL;

    HANDLE              hFileUserXML = NULL;
    DWORD               dwBytesRead;

    TCHAR               szBuf[256];
    
    //
    //  Prepare temporary file path
    //
    if (GetTempPath (sizeof(szTempPath)/sizeof(TCHAR), szTempPath) == 0 ||
        GetTempFileName (
            szTempPath,
            TEXT("Schema"),
            0,
            m_szTempSchema
            ) == 0 ||
        GetTempFileName (
            szTempPath,
            TEXT("XML"),
            0,
            m_szTempXML
            ) == 0
        )
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //
    //  Prepare the temporary file containing the schema
    //

    //  Load the schema.xml resource
    hModule = GetModuleHandle (NULL);
    if (hModule == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    hRes = FindResource (
        hModule,
        MAKEINTRESOURCE(IDR_SCHEMA),
        MAKEINTRESOURCE(SCHEMARES)
        );
    if (hRes == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    hSchema = LoadResource (
        hModule,
        hRes);
    if (hSchema == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    lpSchema = LockResource (hSchema);
    if (lpSchema == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    dwSchemaSize = SizeofResource (hModule, hRes);
    if (dwSchemaSize == 0)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Copy schema.xml into the temporary file
    hFileSchema = CreateFile (
        m_szTempSchema,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS | TRUNCATE_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileSchema == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    if (!WriteFile (
        hFileSchema,
        lpSchema,
        dwSchemaSize,
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    CloseHandle (hFileSchema);
    hFileSchema = INVALID_HANDLE_VALUE;

	//
	//	Now create the temp file for the XML file to be parsed
	//
    hFileXML = CreateFile (
        m_szTempXML,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS | TRUNCATE_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileXML == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Write the XML header
    if (!WriteFile (
        hFileXML,
        gszXMLHeader1,
        lstrlenA(gszXMLHeader1),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
#ifdef UNICODE
    if (WideCharToMultiByte (
            CP_ACP,
            0,
            m_szTempSchema,
            -1,
            szAnsiFile,
            sizeof(szAnsiFile),
            NULL,
            NULL
            ) == 0)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
#else
    lstrcpy (szAnsiFile, m_szTempSchema);
#endif
    if (!WriteFile (
        hFileXML,
        szAnsiFile,
        lstrlenA (szAnsiFile),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    if (!WriteFile (
        hFileXML,
        gszXMLHeader2,
        lstrlenA(gszXMLHeader2),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Copy over the input XML file
    hFileUserXML = CreateFile (
        m_szXMLFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileUserXML == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    while (ReadFile (
        hFileUserXML,
        szBuf,
        sizeof(szBuf),
        &dwBytesRead,
        NULL) &&
        dwBytesRead > 0)
    {
        if (!WriteFile (
            hFileXML,
            szBuf,
            dwBytesRead,
            &dwBytesWritten,
            NULL
            ))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
    }
    CloseHandle (hFileUserXML);
    hFileUserXML = INVALID_HANDLE_VALUE;

    //  Write the XML tail
    if (!WriteFile (
        hFileXML,
        gszXMLTail,
        lstrlenA(gszXMLTail),
        &dwBytesWritten,
        NULL
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    
    CloseHandle (hFileXML);
    hFileXML = INVALID_HANDLE_VALUE;

ExitHere:
    if (FAILED (hr))
    {
        m_szTempSchema[0] = 0;
        m_szTempXML[0] = 0;
    }
    if (hFileSchema != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileSchema);
    }
    if (hFileXML != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileXML);
    }
    if (hFileUserXML != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileUserXML);
    }
    return hr;
}

HRESULT CXMLParser::ReportParsingError ()
{
    HRESULT             hr = S_OK;
    IXMLDOMParseError   * pError = NULL;
    long                lErrCode;
    long                lLineNum;
    long                lLinePos;
    BSTR                szReason = NULL;
    BSTR                szSrc =NULL;
    LPTSTR              szError = NULL;
    TCHAR               szBuf[256];
    TCHAR               szBuf2[256];
    HINSTANCE           hModule;
    CIds                IdsError (IDS_ERROR);

    //  Check to make sure we have a document to work on
    if (m_pDocInput == NULL)
    {
        goto ExitHere;
    }

    //  Make sure we do have an error to report
    hr = m_pDocInput->get_parseError (&pError);
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    hr = pError->get_errorCode (&lErrCode);
    if (FAILED (hr) || lErrCode == 0)
    {
        goto ExitHere;
    }

    //  Collect error information
    if (
        (hr = pError->get_line (&lLineNum)) != 0 ||
        (hr = pError->get_linepos (&lLinePos)) != 0 ||
        (hr = pError->get_reason (&szReason)) != 0 ||
        (hr = pError->get_srcText (&szSrc)) != 0)
    {
        goto ExitHere;
    }

    //  adjust line number because we added one line
    --lLineNum;

    //
    //  Format error report
    //
    //  The format is similar to the following
    //
    //      Invalid XML file format
    //
    //      Failure reason goes here
    //
    //      Line 2, Pos 12
    //
    //      Failure source goes here
    //      -----^
    //
    hModule = GetModuleHandle (NULL);
    if (hModule == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //  Get the text of "Invalid XML file format"
    if (FormatMessage (
        FORMAT_MESSAGE_FROM_HMODULE, 
        hModule, 
        TSEC_INVALFILEFORMAT,
        0,
        szBuf,
        sizeof(szBuf)/sizeof(TCHAR),
        NULL
        ) == 0)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    szError = AppendStringAndFree (szError, szBuf);

    //  Put in the failure reason
    if (szError == NULL ||
        ((szError = AppendStringAndFree (szError, TEXT("\r\n"))) == NULL) ||
        ((szError = AppendStringAndFree (szError, szReason)) == NULL) ||
        ((szError = AppendStringAndFree (szError, TEXT("\r\n"))) == NULL)
        )
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  Get the error position string
    if (LoadString (
            hModule,
            IDS_ERRORPOS,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR)
            ) == 0
        )
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    FormatString (
        szBuf,
        szBuf2,
        sizeof(szBuf2)/sizeof(TCHAR),
        lLineNum,
        lLinePos
        );
    
    //  Put error position text & error source text
    if (
        ((szError = AppendStringAndFree (szError, szBuf2)) == NULL) ||
        ((szError = AppendStringAndFree (szError, TEXT("\r\n\r\n"))) == NULL) ||
        ((szError = AppendStringAndFree (szError, szSrc)) == NULL)
        )
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }

    //  If the error position is not too large, put ----^ to intuitively point
    //  to the place error occurred
    if (lLinePos < sizeof(szBuf)/sizeof(TCHAR) - 1 && lLinePos > 0)
    {
        szBuf[lLinePos] = 0;
        szBuf[--lLinePos] = TEXT('^');
        while (lLinePos > 0)
        {
            szBuf[--lLinePos] = TEXT('-');
        }
        if (
            ((szError = AppendStringAndFree (szError, TEXT("\r\n"))) == NULL) ||
            ((szError = AppendStringAndFree (szError, szBuf)) == NULL)
            )
        {
            hr = TSECERR_NOMEM;
            goto ExitHere;
        }
    }

    //
    //  Now report the error
    //
    MessagePrint (szError, IdsError.GetString ());

ExitHere:
    if (pError)
    {
        pError->Release ();
    }
    SysFreeString (szReason);
    SysFreeString (szSrc);
    if (szError)
    {
        delete [] szError;
    }
    return hr;
}

HRESULT CXMLParser::Parse (void)
{
    HRESULT             hr = S_OK;
    IXMLDOMDocument     * pDocInput = NULL;
    VARIANT_BOOL        bSuccess;
    VARIANT             varXMLFile;

    //  Ensure we have an xml file to process
    if (*m_szXMLFile == 0)
    {
        hr = TSECERR_BADFILENAME;
        goto ExitHere;
    }

    hr = CreateTempFiles ();
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    //  Create XMLDOMDocument object
    hr = CoCreateInstance (
        CLSID_DOMFreeThreadedDocument,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IXMLDOMDocument,
        (void **)&pDocInput
        );
    if (FAILED (hr) || pDocInput == NULL)
    {
        goto ExitHere;
    }

    //   Set the validateOnParse property
    hr = pDocInput->put_validateOnParse(VARIANT_TRUE);
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    //  We do a synchronous load for now
    hr = pDocInput->put_async (VARIANT_TRUE);
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    
    //  Parse the document
    VariantInit (&varXMLFile);
    V_VT(&varXMLFile) = VT_BSTR;
    V_BSTR(&varXMLFile) = SysAllocString (m_szTempXML);
    hr = pDocInput->load (
        varXMLFile,
        &bSuccess
        );
    SysFreeString (V_BSTR(&varXMLFile));
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    if (bSuccess != VARIANT_TRUE)
    {
        hr = TSECERR_INVALFILEFORMAT;
    }
    m_pDocInput = pDocInput;
    pDocInput = NULL;

ExitHere:
    if (pDocInput != NULL)
    {
        pDocInput->Release();
    }
    if (m_szTempSchema[0] != 0)
    {
        DeleteFile (m_szTempSchema);
    }
    if (m_szTempXML[0] != 0)
    {
        DeleteFile (m_szTempXML);
    }
    return hr;
}

HRESULT CXMLParser::GetFirstUser (CXMLUser ** ppUser)
{
    HRESULT             hr = S_OK;
    IXMLDOMElement      * pEleRoot = NULL;
    IXMLDOMNode         * pFirstNode = NULL;
    BSTR                bstr = NULL;

    *ppUser = NULL;
    if (m_pDocInput == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    if (FAILED(hr = m_pDocInput->get_documentElement(&pEleRoot)) || 
        pEleRoot == NULL)
    {
        goto ExitHere;
    }
    if ((bstr = SysAllocString (L"UserList/User")) == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    if (FAILED(hr = pEleRoot->selectSingleNode (bstr, &pFirstNode)) ||
        pFirstNode == NULL)
    {
        goto ExitHere;
    }
    *ppUser = new CXMLUser (pFirstNode);
    if (*ppUser == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    else
    {
        pFirstNode->AddRef();
    }

ExitHere:
    if (pEleRoot)
    {
        pEleRoot->Release();
    }
    if (bstr)
    {
        SysFreeString (bstr);
    }
    if (pFirstNode)
    {
        pFirstNode->Release();
    }
    return hr;
}

///////////////////////////////////////////////////////////
//
//  CXMLUser implementation
//
///////////////////////////////////////////////////////////

HRESULT CXMLUser::GetNextUser (CXMLUser **ppNextUser)
{
    HRESULT             hr = S_OK;
    IXMLDOMNode         * pNodeNext = NULL;

    *ppNextUser = NULL;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    if (FAILED(hr = m_pUserNode->get_nextSibling (&pNodeNext)) ||
        pNodeNext == NULL)
    {
        goto ExitHere;
    }
    *ppNextUser = new CXMLUser (pNodeNext);
    if (*ppNextUser == NULL)
    {
        hr = TSECERR_NOMEM;
//        goto ExitHere;
    }
    else
    {
        pNodeNext->AddRef();
    }
    
ExitHere:
    if (pNodeNext)
    {
        pNodeNext->Release();
    }
    return hr;
}

HRESULT CXMLUser::GetDomainUser (LPTSTR szBuf, DWORD cch)
{
    HRESULT             hr = S_OK;
    IXMLDOMNode         * pNodeDU = NULL;
    BSTR                bstrDU = NULL;
    BSTR                bstrText = NULL;

    szBuf[0] = 0;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrDU = SysAllocString (L"DomainUser");
    if (bstrDU == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pUserNode->selectSingleNode (bstrDU, &pNodeDU);
    if (FAILED (hr) || pNodeDU == NULL)
    {
        goto ExitHere;
    }
    hr = pNodeDU->get_text (&bstrText);
    if (FAILED (hr) || bstrText == NULL)
    {
        goto ExitHere;
    }
    _tcsncpy (szBuf, bstrText, cch);
    szBuf[cch - 1] = 0;
    
ExitHere:
    if (pNodeDU)
    {
        pNodeDU->Release();
    }
    if (bstrDU)
    {
        SysFreeString (bstrDU);
    }
    if (bstrText)
    {
        SysFreeString (bstrText);
    }
    if (szBuf[0] == 0)
    {
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CXMLUser::GetFriendlyName (LPTSTR szBuf, DWORD cch)
{
    HRESULT             hr = S_OK;
    IXMLDOMNode         * pNodeFN = NULL;
    BSTR                bstrFN = NULL;
    BSTR                bstrText = NULL;

    szBuf[0] = 0;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrFN = SysAllocString (L"FriendlyName");
    if (bstrFN == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pUserNode->selectSingleNode (bstrFN, &pNodeFN);
    if (FAILED (hr) || pNodeFN == NULL)
    {
        goto ExitHere;
    }
    hr = pNodeFN->get_text (&bstrText);
    if (FAILED (hr) || bstrText == NULL)
    {
        goto ExitHere;
    }
    _tcsncpy (szBuf, bstrText, cch);
    szBuf[cch - 1] = 0;
    
ExitHere:
    if (pNodeFN)
    {
        pNodeFN->Release();
    }
    if (bstrFN)
    {
        SysFreeString (bstrFN);
    }
    if (bstrText)
    {
        SysFreeString (bstrText);
    }
    return hr;
}

HRESULT CXMLUser::IsNoMerge (BOOL *pb)
{
    HRESULT             hr = S_OK;
    IXMLDOMNamedNodeMap * pAttribs = NULL;
    IXMLDOMNode         * pAttrib = NULL;
    BSTR                bstrNM = NULL;
    VARIANT             varNM;

    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    hr = m_pUserNode->get_attributes(&pAttribs);
    if (FAILED (hr) || pAttribs == NULL)
    {
        goto ExitHere;
    }
    bstrNM = SysAllocString (L"NoMerge");
    if (bstrNM == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = pAttribs->getNamedItem(bstrNM, &pAttrib);
    if (FAILED (hr) || pAttrib == NULL)
    {
        goto ExitHere;
    }
    VariantInit (&varNM);
    hr = pAttrib->get_nodeTypedValue (&varNM);
    if (FAILED(hr))
    {
        VariantClear (&varNM);
        goto ExitHere;
    }
    if (V_VT(&varNM) == VT_BOOL)
    {
        *pb = (V_BOOL(&varNM) == VARIANT_TRUE) ? TRUE : FALSE;
    }
    else if (V_VT(&varNM) == VT_BSTR)
    {
        *pb = (V_BSTR(&varNM)[0] == L'1') ? TRUE : FALSE;
    }
    else
    {
        *pb = FALSE;
    }
    VariantClear (&varNM);
    
ExitHere:
    if (bstrNM)
    {
        SysFreeString (bstrNM);
    }
    if (pAttrib)
    {
        pAttrib->Release();
    }
    if (pAttribs)
    {
        pAttribs->Release();
    }
    return hr;
}

HRESULT CXMLUser::GetFirstLine (CXMLLine ** ppLine)
{
    HRESULT             hr = S_OK;
    BSTR                bstrLine = NULL;
    IXMLDOMNode         * pNodeLine = NULL;

    *ppLine = NULL;
    if (m_pUserNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    
    bstrLine = SysAllocString (L"LineList/Line");
    if (bstrLine == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pUserNode->selectSingleNode (bstrLine, &pNodeLine);
    if (FAILED(hr) || pNodeLine == NULL)
    {
        goto ExitHere;
    }
    *ppLine = new CXMLLine (pNodeLine);
    if (*ppLine == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    else
    {
        pNodeLine->AddRef();
    }
    
ExitHere:
    if (pNodeLine)
    {
        pNodeLine->Release();
    }
    if (bstrLine)
    {
        SysFreeString (bstrLine);
    }
    return hr;
}

///////////////////////////////////////////////////////////
//
//  CXMLLine implementation
//
///////////////////////////////////////////////////////////

HRESULT CXMLLine::GetNextLine (CXMLLine ** ppLine)
{
    HRESULT         hr = S_OK;
    IXMLDOMNode     * pNodeNext = NULL;

    *ppLine = NULL;
    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    hr = m_pLineNode->get_nextSibling (&pNodeNext);
    if (FAILED(hr) || pNodeNext == NULL)
    {
        goto ExitHere;
    }
    *ppLine = new CXMLLine (pNodeNext);
    if (*ppLine == NULL)
    {
        hr = TSECERR_NOMEM;
    }
    else
    {
        pNodeNext->AddRef();
    }

ExitHere:
    if (pNodeNext)
    {
        pNodeNext->Release();
    }
    return hr;
}

HRESULT CXMLLine::GetAddress (LPTSTR szBuf, DWORD cch)
{
    HRESULT         hr = S_OK;
    BSTR            bstrAddr = NULL;
    BSTR            bstrText = NULL;
    IXMLDOMNode     * pNodeAddr = NULL;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrAddr = SysAllocString (L"Address");
    if (bstrAddr == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pLineNode->selectSingleNode (bstrAddr, &pNodeAddr);
    if (FAILED(hr) || pNodeAddr == NULL)
    {
        goto ExitHere;
    }
    hr = pNodeAddr->get_text(&bstrText);
    if (FAILED(hr) || bstrText == NULL)
    {
        goto ExitHere;
    }
    _tcsncpy (szBuf, bstrText, cch);
    szBuf[cch - 1] = 0;

ExitHere:
    if (bstrAddr)
    {
        SysFreeString (bstrAddr);
    }
    if (bstrText)
    {
        SysFreeString (bstrText);
    }
    if (pNodeAddr)
    {
        pNodeAddr->Release();
    }
    return hr;
}

HRESULT CXMLLine::GetPermanentID (ULONG * pID)
{
    HRESULT         hr = S_OK;
    BSTR            bstrPID = NULL;
    IXMLDOMNode     * pNodePID = NULL;
    VARIANT         varPID;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrPID = SysAllocString (L"PermanentID");
    if (bstrPID == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pLineNode->selectSingleNode (bstrPID, &pNodePID);
    if (FAILED(hr) || pNodePID == NULL)
    {
        goto ExitHere;
    }
    VariantInit (&varPID);
    hr = pNodePID->get_nodeTypedValue(&varPID);
    if (FAILED(hr))
    {
        VariantClear (&varPID);
        goto ExitHere;
    }
    if (V_VT(&varPID) == VT_UI4)
    {
        *pID = (ULONG) V_UI4(&varPID);
    }
    else
    {
        hr = S_FALSE;
        *pID = 0;
    }
    VariantClear (&varPID);

ExitHere:
    if (bstrPID)
    {
        SysFreeString (bstrPID);
    }
    if (pNodePID)
    {
        pNodePID->Release();
    }
    return hr;
}

HRESULT CXMLLine::IsPermanentID (BOOL *pb)
{
    HRESULT         hr = S_OK;
    BSTR            bstrPID = NULL;
    IXMLDOMNode     * pNodePID = NULL;
    VARIANT         varPID;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    bstrPID = SysAllocString (L"PermanentID");
    if (bstrPID == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = m_pLineNode->selectSingleNode (bstrPID, &pNodePID);
    if (FAILED(hr) || pNodePID == NULL)
    {
        *pb = FALSE;
        hr = S_OK;
    }
    else
    {
        *pb = TRUE;
    }

ExitHere:
    if (pNodePID)
    {
        pNodePID->Release();
    }
    if (bstrPID)
    {
        SysFreeString (bstrPID);
    }
    return hr;
}

HRESULT CXMLLine::IsRemove (BOOL *pb)
{
    HRESULT             hr = S_OK;
    IXMLDOMNamedNodeMap * pAttribs = NULL;
    IXMLDOMNode         * pAttrib = NULL;
    BSTR                bstrRM = NULL;
    VARIANT             varRM;

    if (m_pLineNode == NULL)
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    hr = m_pLineNode->get_attributes(&pAttribs);
    if (FAILED (hr) || pAttribs == NULL)
    {
        goto ExitHere;
    }
    bstrRM = SysAllocString (L"Remove");
    if (bstrRM == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = pAttribs->getNamedItem(bstrRM, &pAttrib);
    if (FAILED (hr) || pAttrib == NULL)
    {
        goto ExitHere;
    }
    VariantInit (&varRM);
    hr = pAttrib->get_nodeTypedValue (&varRM);
    if (FAILED(hr))
    {
        VariantClear (&varRM);
        goto ExitHere;
    }
    if (V_VT(&varRM) == VT_BOOL)
    {
        *pb = (V_BOOL(&varRM) == VARIANT_TRUE) ? TRUE : FALSE;
    }
    else if(V_VT(&varRM) == VT_BSTR)
    {
        *pb = (V_BSTR(&varRM)[0] == L'1') ? TRUE : FALSE;
    }
    else
    {
        *pb = FALSE;
    }
    VariantClear (&varRM);
    
ExitHere:
    if (bstrRM)
    {
        SysFreeString (bstrRM);
    }
    if (pAttrib)
    {
        pAttrib->Release();
    }
    if (pAttribs)
    {
        pAttribs->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\watchit\watchit.cpp ===
#define STRICT

#include "windows.h"
#include "windowsx.h"
#include "tapi.h"
#include "shellapi.h"

#include "watchit.h"
#include "tapiperf.h"


#if DBG
#define DBGOUT(arg) DbgPrt arg
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PCHAR DbgMessage,
    IN ...
    );
#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)
#else
#define DBGOUT(arg)
#define DOFUNC(arg1,arg2) DoFunc(arg1)
#endif


//***************************************************************************
static TCHAR gszHELPfilename [] = TEXT("watchit.HLP");
static TCHAR gszwatchitClassName[] = TEXT("WATCHIT_Class");
static TCHAR gszAppName[64];


#define MAXBUFSIZE (256)

typedef  LONG (* PERFPROC)(PERFBLOCK *);
PERFPROC    glpfnInternalPerformance = NULL;
BOOL        gfTapiSrvRunning = FALSE;
PPERFBLOCK  gpPerfBlock = NULL;

HWND       ghWndMain;
HINSTANCE  ghInst;
HINSTANCE  ghTapiInst;
HLINEAPP   ghLineApp;

TCHAR      gszBuf[MAXBUFSIZE];


//***************************************************************************
//***************************************************************************
//***************************************************************************
UINT LoadUI()
{
    return(0);
}



//***************************************************************************
UINT ReadINI()
{
    return( 0 );
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
void CheckForTapiSrv()
{
    SC_HANDLE               sc, scTapiSrv;
    SERVICE_STATUS          ServStat;

    sc = OpenSCManager(NULL,
                       NULL,
                       GENERIC_READ);

    if (NULL == sc)
    {
        return;
    }

    gfTapiSrvRunning = FALSE;

    scTapiSrv = OpenService(sc,
                            TEXT("TAPISRV"),
                            SERVICE_QUERY_STATUS);


    if (!QueryServiceStatus(scTapiSrv,
                            &ServStat))
    {
    }

    if (ServStat.dwCurrentState != SERVICE_RUNNING)
    {
    }
    else
    {
        gfTapiSrvRunning = TRUE;
    }

    if (gfTapiSrvRunning)
    {
        ghTapiInst = LoadLibrary(TEXT("tapi32.dll"));

        if (!ghTapiInst)
        {
        }
        else
        {
            glpfnInternalPerformance = (PERFPROC)GetProcAddress( ghTapiInst,
                                                             "internalPerformance");
        }


        if (!glpfnInternalPerformance)
        {
           //TODO: Say something!
        }

    }

    CloseServiceHandle(sc);

}





//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
        static HICON hIconLarge;
        static HICON hIconSmall;
        static HICON hIconDeadTapiSrv;
        static BOOL  fStarted = FALSE;
        static BOOL fDoSmall = FALSE;
        static const DWORD aMenuHelpIDs[] =
        {
//              IDD_DBUTTONPOUND,    IDH_DIALER_DIAL_KEYPAD,
                0,                   0
        };

//MessageBox(GetFocus(), "WM_INI", "Hitting", MB_OK);
        switch (msg)
        {
            case WM_ERASEBKGND:
                return( 1 );  // We handled it.  No, really... would I lie? :-)


            case WM_TIMER:
            {
                RECT rect;

                if ( fStarted )
                {
//                    SetDlgItemText( ghWndMain, IDC_AVG_TIME_TO_NEXT_CUE, szInfo );
                    fStarted = TRUE;
                }

                DBGOUT((0, "Heartbeat..."));

//                InvalidateRect( ghWndMain, NULL, TRUE );

                rect.left = 0;
                rect.top = 0;
                rect.right = 32;
                rect.bottom = 32;
                InvalidateRect( ghWndMain, &rect, FALSE );

                fDoSmall = !(fDoSmall);
            }
            break;


            case WM_INITDIALOG:
            {
//MessageBox(GetFocus(), "WM_INI", "Hitting", MB_OK);

                hIconLarge = LoadIcon( ghInst, (LPCTSTR) MAKEINTRESOURCE( IDI_LARGE ) );
                hIconSmall = LoadIcon( ghInst, (LPCTSTR) MAKEINTRESOURCE( IDI_SMALL ) );
                hIconDeadTapiSrv = LoadIcon( ghInst, (LPCTSTR) MAKEINTRESOURCE( IDI_DEADTAPISRV ) );

                SetTimer( hwnd, 1, 1000, NULL );

                return TRUE;
            }


            case WM_SYSCOMMAND:
                switch( (DWORD) wParam )
                {
                    case SC_CLOSE:
                        PostQuitMessage(0);
                }
                break;


            //
            // processes clicks on controls when
            // context mode help is selected
            //
            case WM_HELP:
                WinHelp (
                         (HWND)( (LPHELPINFO) lParam)->hItemHandle,
                         gszHELPfilename,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPVOID) aMenuHelpIDs
                        );
                return TRUE;


            //
            // processes right-clicks on controls
            //
            case WM_CONTEXTMENU:
                WinHelp (
                         (HWND)wParam,
                         gszHELPfilename,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aMenuHelpIDs
                        );
                return TRUE;


            case WM_COMMAND:
            {

                switch( LOWORD( (DWORD)wParam ) )
                {
                    // FILE menu
                    case IDM_EXIT:
                        PostQuitMessage(0);
                        return TRUE;


                    // HELP menu
                    case IDM_HELP_CONTENTS:
                        WinHelp(ghWndMain, gszHELPfilename, HELP_CONTENTS, 0);
                        return TRUE;


                    case IDM_HELP_WHATSTHIS:
                        PostMessage(ghWndMain, WM_SYSCOMMAND, SC_CONTEXTHELP, 0);
                        return TRUE;


                    case IDM_ABOUT:
                        ShellAbout(
                                   ghWndMain,
                                   gszAppName,
                                   TEXT(""),
                                   LoadIcon(ghInst, (LPCTSTR)IDI_LARGE)
                                  );
//                        DialogBoxParam(
//                                       ghInst,
//                                       MAKEINTRESOURCE(IDD_ABOUT),
//                                       ghWndMain,
//                                       AboutProc,
//                                       0
//                                      );
                        return TRUE;


                } // end switch (LOWORD((DWORD)wParam)) { ... }
                break; // end case WM_COMMAND

            }


           case WM_PAINT:
            {
                PAINTSTRUCT ps;
                RECT rc;
                HDC hdcMem;
                HBITMAP hbmMem, hbmOld;


                BeginPaint(hwnd, &ps);


                //
                // Get the size of the client rectangle.
                //

                GetClientRect(hwnd, &rc);

                //
                // Create a compatible DC.
                //

                hdcMem = CreateCompatibleDC(ps.hdc);

                //
                // Create a bitmap big enough for our client rectangle.
                //

                hbmMem = CreateCompatibleBitmap(ps.hdc,
                                                rc.right-rc.left,
                                                rc.bottom-rc.top);

                //
                // Select the bitmap into the off-screen DC.
                //

                hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);

                //
                // Erase the background.
                //

//                hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
//                hbrBkGnd = CreateSolidBrush(COLOR_3DFACE + 1);
//                FillRect(hdcMem, &rc, hbrBkGnd);
                FillRect(hdcMem, &rc, (HBRUSH)(COLOR_3DFACE + 1) );
//                DeleteObject(hbrBkGnd);

                //
                // Render the image into the offscreen DC.
                //

                SetBkMode(hdcMem, TRANSPARENT);



//                if(IsIconic(ghWndMain))
//                    DrawIcon(ps.hdc, 0, 0, fDoSmall ? hIconSmall : hIconLarge);
//                else
                {
                   int nSize;

                   if ( gpPerfBlock )
                   {
                     if (
                           ( NULL == glpfnInternalPerformance )
                         ||
                           ( LINEERR_OPERATIONFAILED ==
                                  glpfnInternalPerformance(gpPerfBlock) )
                        )
                     {
                           gpPerfBlock->dwClientApps = 1;

                           DrawIcon( hdcMem,
                                  0,
                                  0,
                                  hIconDeadTapiSrv
                                );

                           //
                           // Check again so that next time around, we'll
                           // display stuff if TAPISRV has started
                           //
                           CheckForTapiSrv();

                     }
                     else
                     {
                        DrawIcon( hdcMem,
                                  0,
                                  0,
                                  fDoSmall ? hIconSmall : hIconLarge
                                );

                     }


                     //
                     // Blt the changes to the screen DC.
                     //

                     BitBlt(ps.hdc,
                            rc.left, rc.top,
                            rc.right-rc.left, rc.bottom-rc.top,
                            hdcMem,
                            0, 0,
                            SRCCOPY);


                     nSize = wsprintf( gszBuf,
                                       TEXT("%ld"),
                                       gpPerfBlock->dwClientApps - 1 // don't count me
                                     );

                     SetDlgItemText( ghWndMain, IDC_NUMCLIENTSTEXT, gszBuf );

                     nSize = wsprintf( gszBuf,
                                       TEXT("%ld"),
                                       gpPerfBlock->dwCurrentOutgoingCalls
                                     );

                     SetDlgItemText( ghWndMain, IDC_NUMOUTCALLSTEXT, gszBuf );

                     nSize = wsprintf( gszBuf,
                                       TEXT("%ld"),
                                       gpPerfBlock->dwCurrentIncomingCalls
                                     );

                     SetDlgItemText( ghWndMain, IDC_NUMINCALLSTEXT, gszBuf );

                   }

                }


                //
                // Done with off-screen bitmap and DC.
                //

                SelectObject(hdcMem, hbmOld);
                DeleteObject(hbmMem);
                DeleteDC(hdcMem);


                EndPaint(ghWndMain, &ps);

                return TRUE;
            }



            default:
                ;
                //            return DefDlgProc( hwnd, msg, wParam, lParam );
                //            return DefWindowProc( hwnd, msg, wParam, lParam );


        } // switch (msg) { ... }

        return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
void FAR PASCAL TAPICallback( DWORD hDevice,
                              DWORD dwMsg,
                              DWORD dwCallbackInstance,
                              DWORD dwParam1,
                              DWORD dwParam2,
                              DWORD dwParam3
                            )
{
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
int WINAPI WinMain (
                                        HINSTANCE hInstance,
                                        HINSTANCE hPrevInstance,
                                        LPSTR lpCmdLine,
                                        int nCmdShow
                                   )
{
//      HACCEL hAccel;
        MSG msg;
//      DWORD errCode;
//      HANDLE hImHere;
//        DWORD dwNumDevs;
//        DWORD dwAPIVersion = 0x00020000;
//        LINEINITIALIZEEXPARAMS LineInitializeExParams = {
//                                   sizeof( LINEINITIALIZEEXPARAMS ),
//                                   0,
//                                   0,
//                                   0,
//                                   0,
//                                   0
//                                   };

//    MessageBox(GetFocus(), "Starting", "Starting", MB_OK);

DBGOUT((0, "starting"));

        ghInst = GetModuleHandle( NULL );
        LoadString( ghInst,
                    WATCHIT_STRING_FRIENDLYNAME,
                    gszAppName,
                    sizeof(gszAppName)/sizeof(TCHAR)
                  );


//
//      //
//      // Now, let's see if we've already got an instance of ourself
//  //
//      hImHere = CreateMutex(NULL, TRUE, "watchit_IveBeenStartedMutex");
//
//
//      //
//      // Is there another one of us already here?
//      if ( ERROR_ALREADY_EXISTS == GetLastError() )
//      {
//        HWND        hDialerWnd;
//
//        hDialerWnd = FindWindow(gszDialerClassName,
//                                NULL);
//
//        SetForegroundWindow(hDialerWnd);
//
//         CloseHandle( hImHere );
//         return 0;
//      }


        {
                WNDCLASS wc;
                wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;
                wc.lpfnWndProc = DefDlgProc;
                wc.cbClsExtra = 0;
                wc.cbWndExtra = DLGWINDOWEXTRA;
                wc.hInstance = ghInst;
                wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_LARGE) );
                wc.hCursor = LoadCursor(NULL, IDC_ARROW);

                wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);

                wc.lpszMenuName = NULL;
                wc.lpszClassName = gszwatchitClassName;
                if ( 0 == RegisterClass(&wc) )
                {
                   DBGOUT((0, "RegisterClass failed.  GetLastError() = 0x%08lx",
                       GetLastError() ));

                   return 0;
                }
        }


DBGOUT((0, "about to create"));

        // create the dialog box and set it with info
        // from the .INI file
        ghWndMain = CreateDialog (
            ghInst,
            (LPCTSTR)MAKEINTRESOURCE(IDD_MAIN_WATCHIT),
            (HWND)NULL,
            MainWndProc
            );

        if ( ReadINI() )
    {
        MessageBox( GetFocus(),
                    TEXT("INI File is broken."),
                    TEXT("This is not good"),
                    MB_OK
                  );
    }

    if ( LoadUI() )
    {
        MessageBox( GetFocus(),
                    TEXT("UI Load is broken."),
                    TEXT("This is not good"),
                    MB_OK
                  );
    }


    CheckForTapiSrv();

    gpPerfBlock = (PPERFBLOCK)LocalAlloc(LPTR, sizeof(PERFBLOCK));

//      errCode = lineInitializeEx(
//                                &ghLineApp,
//                                NULL,
//                                TAPICallback,
//                                gszAppName,
//                                &dwNumDevs,
//                                &dwAPIVersion,
//                                &LineInitializeExParams
//                              );

        ShowWindow(ghWndMain, SW_SHOW);

        UpdateWindow(ghWndMain);

//      hAccel = LoadAccelerators(ghInst, gszAppName);

        while ( GetMessage( &msg, NULL, 0, 0 ) )
        {
                if ( ghWndMain == NULL || !IsDialogMessage( ghWndMain, &msg ) )
                {
//                      if(!TranslateAccelerator(ghWndMain, hAccel, &msg))
                        {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                        }
                }
        }


//
//      CloseHandle( hImHere );
//

    KillTimer( ghWndMain, 1);

    if ( gpPerfBlock )
    {
       LocalFree( gpPerfBlock );
    }

    if ( ghTapiInst )
    {
       FreeLibrary( ghTapiInst );
    }


    return (int) msg.wParam;
}






#if DBG


#include "stdarg.h"
#include "stdio.h"


VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static DWORD gdwDebugLevel = 0;   //HACKHACK


    if (dwDbgLevel <= gdwDebugLevel)
    {
        CHAR    buf[256] = "WATCHIT: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintfA (&buf[8],
                  lpszFormat,
                  ap
                  );

        lstrcatA(buf, "\n");

        OutputDebugStringA(buf);

        va_end(ap);
    }
}
#endif









// //***************************************************************************
// //***************************************************************************
// //***************************************************************************
// BOOL CALLBACK AboutProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
//     {
//     switch(msg)
//         {
//         case WM_INITDIALOG:
//             {
//             TCHAR sz[MAXBUFSIZE];
//             TCHAR szLabel[MAXBUFSIZE];
//
//             // sets up the version number for Windows
//             GetDlgItemText(hwnd, IDD_ATEXTTITLE, sz, MAXBUFSIZE);
//             wsprintf(
//                 szLabel,
//                 sz,
//                 LOWORD(GetVersion()) & 0xFF,
//                 HIBYTE(LOWORD(GetVersion)) == 10 ? 1 : 0
//                 );
//             SetDlgItemText(hwnd, IDD_ATEXTTITLE, szLabel);
//
// /*            // sets up version number for Dialer
//             GetDlgItemText(hwnd, IDD_ATEXTVERSION, sz, MAXBUFSIZE);
//             wsprintf(szLabel, sz, VER_MAJOR, VER_MINOR, VER_BUILD);
//
//
//             { // strip off build number for release copies
//             DWORD i;
//             LPSTR ch = szLabel;
//
//             for (i = 0; i < 2 && *ch; ++ch)
//                 {
//                 if(*ch == '.')
//                     ++i;
//                 if(i == 2)
//                     *ch = 0;
//                 }
//
//             SetDlgItemText(hwnd ,IDD_ATEXTVERSION, szLabel);
//             } */
//
//
// /*            // get free memory information
//             GetDlgItemText(hwnd, IDD_ATEXTFREEMEM, sz, MAXBUFSIZE);
//             wsprintf(szLabel, sz, GetFreeSpace(0)>>10);
//             SetDlgItemText(hwnd, IDD_ATEXTFREEMEM, szLabel);
//
//             // get free resources information
//             GetDlgItemText(hwnd, IDD_ATEXTRESOURCE, sz,MAXBUFSIZE);
//             wsprintf(szLabel, sz, GetFreeSystemResources(0));
//             SetDlgItemText(hwnd, IDD_ATEXTRESOURCE, szLabel); */
//
//             return TRUE;
//             }
//
//         case WM_COMMAND:
//             if(LOWORD((DWORD)wParam) == IDOK)
//                 {
//                 EndDialog(hwnd, TRUE);
//                 return TRUE;
//                 }
//             break;
//         }
//     return FALSE;
//     }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\card.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  card.cpp
                                                              
     Abstract:  Calling Card Object implementation
                                                              
       Author:  noela - 09/11/98
              
        Notes:

        
  Rev History:

****************************************************************************/

#include <windows.h>
#include <windowsx.h>

#if WINNT
#else
#include <help.h>
#endif

#include <tchar.h>
#include <prsht.h>
#include <stdlib.h>
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "cplResource.h"
#include "client.h"
#include "clntprivate.h"
#include "card.h"
#include "location.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "rules.h"

#include "tregupr2.h"

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#ifdef DBG
#define assert(condition)   if(condition);else  \
        { DebugAssertFailure (__FILE__, __LINE__, #condition); }

static void DebugAssertFailure (LPCSTR file, DWORD line, LPCSTR condition);

#else

#define assert(condition)

#endif


#define CLIENT_FREE(x)  \
    if (x) { ClientFree(x); (x)=NULL;} else;

#define TRACE_DWERROR() LOG((TL_ERROR, "Error %x at line %d in file %hs", dwError, __LINE__, __FILE__))
#define TRACE_HRESULT() LOG((TL_ERROR, "Error %x at line %d in file %hs", Result, __LINE__, __FILE__))

#define EXIT_IF_DWERROR()     \
    if(dwError !=ERROR_SUCCESS)  \
    {                               \
        TRACE_DWERROR();            \
        goto forced_exit;           \
    }   

#define EXIT_IF_FAILED()     \
    if(FAILED(Result))        \
    {                               \
        TRACE_HRESULT();            \
        goto forced_exit;           \
    }   


#define MAX_NUMBER_LEN      15



const TCHAR gszCardsPath[]        = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards");
const TCHAR gszTelephonyPath[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");

const TCHAR gszCardW[]              = TEXT("Card");
const TCHAR gszCardNameW[]          = TEXT("Name");
const TCHAR gszLocalRuleW[]         = TEXT("LocalRule");
const TCHAR gszLDRuleW[]            = TEXT("LDRule");
const TCHAR gszInternationalRuleW[] = TEXT("InternationalRule");
const TCHAR gszLocalAccessNumberW[] = TEXT("LocalAccessNumber");
const TCHAR gszLDAccessNumberW[]    = TEXT("LDAccessNumber");
const TCHAR gszInternationalAccessNumberW[] = TEXT("InternationalAccessNumber");
const TCHAR gszAccountNumberW[]     = TEXT("AccountNumber");
const TCHAR gszPinW[]               = TEXT("Pin");

const TCHAR gszFlags[]              = TEXT("Flags");
const TCHAR gszCard[]               = TEXT("Card");
const TCHAR gszCards[]              = TEXT("Cards");
const TCHAR gszNextID[]             = TEXT("NextID");
const TCHAR gszCardListVersion[]    = TEXT("CardListVersion");

const TCHAR gszResourceLibrary[]    = TEXT("TAPIUI.DLL");

const TCHAR gszSystemSetupPath[]    = TEXT("System\\Setup");
const TCHAR gszSystemSetupInProgress[] = TEXT("SystemSetupInProgress"); 

static BOOL ValidValue(PWSTR);

/****************************************************************************

    Class : CCallingCard        
   Method : Constructor

****************************************************************************/
CCallingCard::CCallingCard()
{
    m_dwCardID = 0;
    m_pszCardName = NULL;;
    
    m_pszPIN = NULL;
    m_pszEncryptedPIN = NULL;
    m_pszAccountNumber = NULL;

    m_pszLocalAccessNumber = NULL;
    m_pszLongDistanceAccessNumber = NULL;
    m_pszInternationalAccessNumber = NULL;

    m_pszCardPath = NULL;
    m_hCard = NULL;

    m_bDirty = FALSE;
    m_bDeleted = FALSE;

    m_dwFlags = 0; // by default

    m_dwCryptInitResult = TapiCryptInitialize();
}



/****************************************************************************

    Class : CCallingCard         
   Method : Destructor

****************************************************************************/
CCallingCard::~CCallingCard()
{
    CleanUp();

    TapiCryptUninitialize();
}


/****************************************************************************

    Class : CCallingCard         
   Method : CleanUp

            Clean up memory allocations

****************************************************************************/


void  CCallingCard::CleanUp(void)
{
    CLIENT_FREE(m_pszCardName);
    CLIENT_FREE(m_pszPIN);
    CLIENT_FREE(m_pszEncryptedPIN);
    CLIENT_FREE(m_pszAccountNumber);
    CLIENT_FREE(m_pszLocalAccessNumber);
    CLIENT_FREE(m_pszLongDistanceAccessNumber);
    CLIENT_FREE(m_pszInternationalAccessNumber);

    CLIENT_FREE(m_Rules.m_pszInternationalRule);
    CLIENT_FREE(m_Rules.m_pszLongDistanceRule);
    CLIENT_FREE(m_Rules.m_pszLocalRule);

    CLIENT_FREE(m_pszCardPath);
    CloseCardKey();
}


/****************************************************************************

    Class : CCallingCard         
   Method : Initialize - external parameters

            Only for new calling cards (not present in registry)

****************************************************************************/
HRESULT CCallingCard::Initialize
                  (
                   DWORD dwCardID,
                   PWSTR pszCardName,
                   DWORD dwFlags,
                   PWSTR pszPIN,
                   PWSTR pszAccountNumber,
                   PWSTR pszInternationalRule,
                   PWSTR pszLongDistanceRule,
                   PWSTR pszLocalRule,
                   PWSTR pszInternationalAccessNumber,
                   PWSTR pszLongDistanceAccessNumber,
                   PWSTR pszLocalAccessNumber
                  )
{
    HRESULT     Result = S_OK;
    
#define CALLING_CARD_INIT(param)                                                            \
    m_##param = ClientAllocString(param);                                                   \
    if(m_##param == NULL)                                                                   \
    {                                                                                       \
        LOG((TL_ERROR, "Initialize create m_%s failed", _T(#param)));    \
        CleanUp();                                                                          \
        return E_OUTOFMEMORY;                                                               \
    }

    CALLING_CARD_INIT(pszCardName)
    CALLING_CARD_INIT(pszPIN)
    CALLING_CARD_INIT(pszAccountNumber)
    CALLING_CARD_INIT(pszInternationalAccessNumber)
    CALLING_CARD_INIT(pszLongDistanceAccessNumber)
    CALLING_CARD_INIT(pszLocalAccessNumber)

#undef CALLING_CARD_INIT

    //////////////////////////////////////////////////
    // copy the set of three Rules
    //
    Result = m_Rules.Initialize(    pszInternationalRule,
                                    pszLongDistanceRule,
                                    pszLocalRule );
    if(FAILED(Result))
    {
        LOG((TL_ERROR, "Initialize create m_Rules failed" ));
        CleanUp();
        return Result;
    }

    m_dwCardID = dwCardID;
    m_dwFlags = dwFlags;

    m_bDirty = TRUE;


    return Result;

}
        

/****************************************************************************

    Class : CCallingCard         
   Method : Initialize - from registry


****************************************************************************/
HRESULT CCallingCard::Initialize
                    (
                     DWORD dwCardID
                    )
{

    DWORD       dwError;
    DWORD       dwType;
    DWORD       dwLength;

    m_dwCardID = dwCardID;

    // open the registry key
    dwError = OpenCardKey(FALSE);

    if(dwError != ERROR_SUCCESS)
    {
        // If the key does not exist, it will be created at the first save
        if(dwError==ERROR_FILE_NOT_FOUND)
        {
            m_bDirty = TRUE;
        }
        return(HRESULT_FROM_WIN32(dwError));
    }

#define READ_CARD_VAL(Member, Name)      \
    dwError = ReadOneStringValue(&##Member, Name);  \
    if(dwError != ERROR_SUCCESS)                    \
    {                                               \
        TRACE_DWERROR();                            \
        CleanUp();                                  \
        return HRESULT_FROM_WIN32(dwError);         \
    }
    
    READ_CARD_VAL(m_pszCardName,                    gszCardNameW);
    READ_CARD_VAL(m_pszEncryptedPIN,                gszPinW);
//    READ_CARD_VAL(m_pszPIN,                gszPinW);
    READ_CARD_VAL(m_pszAccountNumber,               gszAccountNumberW);
    READ_CARD_VAL(m_pszLocalAccessNumber,           gszLocalAccessNumberW);
    READ_CARD_VAL(m_pszLongDistanceAccessNumber,    gszLDAccessNumberW);
    READ_CARD_VAL(m_pszInternationalAccessNumber,   gszInternationalAccessNumberW);
    READ_CARD_VAL(m_Rules.m_pszLocalRule,           gszLocalRuleW);
    READ_CARD_VAL(m_Rules.m_pszLongDistanceRule,    gszLDRuleW);
    READ_CARD_VAL(m_Rules.m_pszInternationalRule,   gszInternationalRuleW);

#undef READ_CARD_VAL

    // Decrypt the PIN number 
    dwError = DecryptPIN();
    if(dwError != ERROR_SUCCESS)
    {
        TRACE_DWERROR();
        CleanUp();
        return HRESULT_FACILITY(dwError)==0 ? HRESULT_FROM_WIN32(dwError) : dwError;
    }

    dwLength = sizeof(m_dwFlags);
    dwError = RegQueryValueEx ( m_hCard,
                                gszFlags,
                                NULL,
                                &dwType,
                                (PBYTE)&m_dwFlags,
                                &dwLength
                                );
    
    if(dwError != ERROR_SUCCESS)
    {
        TRACE_DWERROR();
        CleanUp();
        return HRESULT_FROM_WIN32(dwError);
    }

    CloseCardKey();

    return S_OK;

}

/****************************************************************************

    Class : CCallingCard         
   Method : SaveToRegistry
        

****************************************************************************/

HRESULT     CCallingCard::SaveToRegistry(void)
{
    DWORD   dwError;

    if(!m_bDirty)
        // nothing to save
        return S_OK;
    //open/create the registry key
    dwError = OpenCardKey(TRUE);
    if(dwError != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(dwError);

    assert(m_hCard);
    assert(m_pszCardPath);

    if(m_bDeleted)
    {
        CloseCardKey();

        dwError = RegDeleteKey (HKEY_CURRENT_USER,
                                m_pszCardPath);

        if(dwError != ERROR_SUCCESS)
            return HRESULT_FROM_WIN32(dwError);

        m_bDirty = FALSE;

        return S_OK;
    }
    // Encrypt the PIN number 
    dwError = EncryptPIN();
    if(dwError != ERROR_SUCCESS)
    {
        TRACE_DWERROR();
        return HRESULT_FACILITY(dwError)==0 ? HRESULT_FROM_WIN32(dwError) : dwError;
    }

    // Save !
    
#define CARD_SAVE_STRING(Member, Name)          \
    dwError = TAPIRegSetValueExW(   m_hCard,    \
                                    Name,       \
                                    0,          \
                                    REG_SZ,     \
                                    (PBYTE) Member, \
                                    (wcslen(Member)+1)*sizeof(WCHAR)  \
                                ) ;             \
    if(dwError != ERROR_SUCCESS)                \
    {                                           \
        TRACE_DWERROR();                        \
        CloseCardKey();                         \
        return HRESULT_FROM_WIN32(dwError);     \
    }

    CARD_SAVE_STRING(m_pszCardName,                    gszCardNameW);
    CARD_SAVE_STRING(m_pszEncryptedPIN,                gszPinW);
    CARD_SAVE_STRING(m_pszAccountNumber,               gszAccountNumberW);
    CARD_SAVE_STRING(m_pszLocalAccessNumber,           gszLocalAccessNumberW);
    CARD_SAVE_STRING(m_pszLongDistanceAccessNumber,    gszLDAccessNumberW);
    CARD_SAVE_STRING(m_pszInternationalAccessNumber,   gszInternationalAccessNumberW);
    CARD_SAVE_STRING(m_Rules.m_pszLocalRule,           gszLocalRuleW);
    CARD_SAVE_STRING(m_Rules.m_pszLongDistanceRule,    gszLDRuleW);
    CARD_SAVE_STRING(m_Rules.m_pszInternationalRule,   gszInternationalRuleW);
        
#undef CARD_SAVE_STRING

    dwError = RegSetValueEx (   m_hCard,
                                gszFlags,
                                0,
                                REG_DWORD,
                                (PBYTE)&m_dwFlags,
                                sizeof(m_dwFlags)
                           );
    if(dwError != ERROR_SUCCESS)                
    {                                           
        TRACE_DWERROR();
        CloseCardKey();                         
        return HRESULT_FROM_WIN32(dwError);     
    }

    m_bDirty = FALSE;

    CloseCardKey();

    return S_OK;
}


/****************************************************************************

    Class : CCallingCard         
   Method : MarkDeleted

            Mark the card as deleted

****************************************************************************/

HRESULT CCallingCard::MarkDeleted(void)
{
    m_bDirty = TRUE;
    
    if (m_dwFlags & CARD_BUILTIN)
    {
        // a builtin card is only hidden, not deleted
        m_dwFlags |= CARD_HIDE;
        return S_OK;
    }
    
    m_bDeleted = TRUE;

    return S_OK;
}


/****************************************************************************

    Class : CCallingCard         
   Method : Validate

            Returns 0 if the card contains complete and valid rules, or
            a series of flags if the card is missing any required data.

****************************************************************************/

DWORD CCallingCard::Validate(void)
{
    DWORD dwResult = 0;

    // Does the card have a name?
    if (!*m_pszCardName)
    {
        dwResult |= CCVF_NOCARDNAME;
    }

    // Does the card have any rules?
    if (!*(m_Rules.m_pszInternationalRule) &&
        !*(m_Rules.m_pszLocalRule) &&
        !*(m_Rules.m_pszLongDistanceRule) )
    {
        dwResult |= CCVF_NOCARDRULES;
    }
    else
    {
        DWORD dwFieldsToCheck = 0;;

        struct
        {
            PWSTR   pwszRule;
            DWORD   dwAccesFlag;
        }
        aData[] =
        {
            {m_Rules.m_pszInternationalRule, CCVF_NOINTERNATIONALACCESSNUMBER},
            {m_Rules.m_pszLocalRule,         CCVF_NOLOCALACCESSNUMBER},
            {m_Rules.m_pszLongDistanceRule,  CCVF_NOLONGDISTANCEACCESSNUMBER},
        };

        // Foreach rule, is the required rule data available?  We need to check
        // for use of the PIN number, CardNumber, and all three access numbers.
        // If any of these fields is used, then we need to verify that data has
        // been entered for those fields.  The data is only required if it is
        // actually used in a rule.
        for (int i=0; i<ARRAYSIZE(aData); i++)
        {
            if (StrChrW(aData[i].pwszRule, L'K'))
            {
                dwFieldsToCheck |= CCVF_NOCARDNUMBER;
            }
            if (StrChrW(aData[i].pwszRule, L'H'))
            {
                dwFieldsToCheck |= CCVF_NOPINNUMBER;
            }
            if (StrChrW(aData[i].pwszRule, L'J'))
            {
                dwFieldsToCheck |= aData[i].dwAccesFlag;
            }
        }
        if (dwFieldsToCheck & CCVF_NOCARDNUMBER)
        {
            if (!ValidValue(m_pszAccountNumber))
            {
                dwResult |= CCVF_NOCARDNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOPINNUMBER)
        {
            if (!ValidValue(m_pszPIN))
            {
                dwResult |= CCVF_NOPINNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOINTERNATIONALACCESSNUMBER)
        {
            if (!ValidValue(m_pszInternationalAccessNumber))
            {
                dwResult |= CCVF_NOINTERNATIONALACCESSNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOLOCALACCESSNUMBER)
        {
            if (!ValidValue(m_pszLocalAccessNumber))
            {
                dwResult |= CCVF_NOLOCALACCESSNUMBER;
            }
        }
        if (dwFieldsToCheck & CCVF_NOLONGDISTANCEACCESSNUMBER)
        {
            if (!ValidValue(m_pszLongDistanceAccessNumber))
            {
                dwResult |= CCVF_NOLONGDISTANCEACCESSNUMBER;
            }
        }
    }

    return dwResult;
}

/****************************************************************************

    Class : CCallingCard         
   Method : Set##Member 

****************************************************************************/

#define     SET_METHOD(Member)                  \
HRESULT CCallingCard::Set##Member(PWSTR Value)  \
{                                               \
    PWSTR   pszTemp = NULL;                     \
                                                \
    if(Value == NULL)                           \
        return E_INVALIDARG;                    \
                                                \
    pszTemp = ClientAllocString(Value);         \
    if(pszTemp==NULL)                           \
    {                                           \
        return E_OUTOFMEMORY;                   \
    }                                           \
                                                \
    CLIENT_FREE(m_psz##Member);                 \
    m_psz##Member = pszTemp;                    \
                                                \
    m_bDirty = TRUE;                            \
                                                \
    return S_OK;                                \
}

SET_METHOD(CardName);
SET_METHOD(PIN);
SET_METHOD(AccountNumber);
SET_METHOD(InternationalAccessNumber);
SET_METHOD(LongDistanceAccessNumber);
SET_METHOD(LocalAccessNumber);

#define m_pszInternationalRule  m_Rules.m_pszInternationalRule
#define m_pszLongDistanceRule   m_Rules.m_pszLongDistanceRule
#define m_pszLocalRule          m_Rules.m_pszLocalRule

SET_METHOD(InternationalRule);
SET_METHOD(LongDistanceRule);
SET_METHOD(LocalRule);

#undef m_pszInternationalRule
#undef m_pszLongDistanceRule
#undef m_pszLocalRule

#undef SET_METHOD

                    




/****************************************************************************

    Class : CCallingCard         
   Method : OpenCardKey

            Opens the registry key for the card

****************************************************************************/

DWORD CCallingCard::OpenCardKey(BOOL bWrite)
{
    DWORD   dwDisp;
    DWORD   dwError;
     
    if(m_pszCardPath==NULL)
    {
        DWORD   dwLength;
        
        // Absolute path: Software.....Cards\CardX
        dwLength = ARRAYSIZE(gszCardsPath)+ARRAYSIZE(gszCard)+MAX_NUMBER_LEN;
 
        m_pszCardPath = (PTSTR)ClientAlloc(dwLength*sizeof(TCHAR));
        if (m_pszCardPath==NULL)
            return ERROR_OUTOFMEMORY;

        wsprintf(m_pszCardPath, TEXT("%s\\%s%d"), gszCardsPath, gszCard, m_dwCardID);
    }
    
    if(bWrite)
    {
        // Creates the key if it does not exist
        dwError = RegCreateKeyEx ( HKEY_CURRENT_USER,
                                   m_pszCardPath,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_QUERY_VALUE | KEY_SET_VALUE,
                                   NULL,
                                   &m_hCard,
                                   &dwDisp
                                  );
    }
    else
    {
        dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                                m_pszCardPath,
                                0,
                                KEY_QUERY_VALUE,
                                &m_hCard
                                );
    }
    return dwError;

}

/****************************************************************************

    Class : CCallingCard         
   Method : CloseCardKey

            Opens the registry key for the card

****************************************************************************/

DWORD CCallingCard::CloseCardKey(void)
{
    if(m_hCard)
    {
        RegCloseKey(m_hCard);
        m_hCard = NULL;
    }
    return ERROR_SUCCESS;
}

/****************************************************************************

    Class : CCallingCard         
   Method : ReadOneStringValue

            Read and allocates a string value

****************************************************************************/

DWORD CCallingCard::ReadOneStringValue(PWSTR *pMember, const TCHAR *pszName)
{
    DWORD   dwError;
    DWORD   dwLength;
    DWORD   dwType;
    PTSTR   pszBuffer;
    
    assert(m_hCard);
    assert(pMember);
    assert(pszName);

    // find the length needed
    dwError = RegQueryValueEx ( m_hCard,
                                pszName,
                                NULL,
                                &dwType,
                                NULL,
                                &dwLength
                                );
    if (dwError != ERROR_SUCCESS)
        return dwError;
    if (dwType != REG_SZ)
        return ERROR_INVALID_DATA;

    pszBuffer = (PTSTR)ClientAlloc(dwLength);
    if (pszBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    dwError = RegQueryValueEx ( m_hCard,
                                pszName,
                                NULL,
                                &dwType,
                                (PBYTE)(pszBuffer),
                                &dwLength
                                );
    if(dwError != ERROR_SUCCESS)
    {
        ClientFree(pszBuffer);
        return dwError;
    }

    // convert the required bytes for the TCHAR string into the number of characters in the string.
    dwLength = dwLength / sizeof(TCHAR);
    *pMember = (PWSTR)ClientAlloc( dwLength * sizeof(WCHAR) );
    if ( NULL == *pMember )
    {
        ClientFree(pszBuffer);
        return ERROR_OUTOFMEMORY;
    }
    SHTCharToUnicode(pszBuffer, *pMember, dwLength);

    ClientFree(pszBuffer);
    return ERROR_SUCCESS;
}

/****************************************************************************

    Class : CCallingCard         
   Method : EncryptPIN

            Encrypts the PIN

****************************************************************************/


DWORD CCallingCard::EncryptPIN(void)
{
    DWORD   dwError;
    DWORD   dwLength;
    PWSTR   pszTemp = NULL;

    // free any existing encrypted string
    CLIENT_FREE(m_pszEncryptedPIN);

    dwError = TapiEncrypt(m_pszPIN, m_dwCardID, NULL, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "EncryptPIN: TapiEncrypt (1) failed"));
        return dwError;
    }

    pszTemp = (PWSTR)ClientAlloc(dwLength*sizeof(WCHAR));
    if(pszTemp==NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    dwError = TapiEncrypt(m_pszPIN, m_dwCardID, pszTemp, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "EncryptPIN: TapiEncrypt (2) failed"));
        ClientFree(pszTemp);
        return dwError;
    }
    
    m_pszEncryptedPIN = pszTemp;   

    return dwError;

}

/****************************************************************************

    Class : CCallingCard         
   Method : DecryptPIN

            Decrypts the PIN

****************************************************************************/

DWORD CCallingCard::DecryptPIN(void)
{
    DWORD   dwError;
    DWORD   dwLength;
    PWSTR   pszTemp = NULL;

    // free any existing string
    CLIENT_FREE(m_pszPIN);
 
    dwError = TapiDecrypt(m_pszEncryptedPIN, m_dwCardID, NULL, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "DecryptPIN: TapiDecrypt (1) failed"));
        return dwError;
    }

    pszTemp = (PWSTR)ClientAlloc(dwLength*sizeof(WCHAR));
    if(pszTemp==NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    dwError = TapiDecrypt(m_pszEncryptedPIN, m_dwCardID, pszTemp, &dwLength);
    if(dwError != ERROR_SUCCESS)
    {
        LOG((TL_ERROR, "DecryptPIN: TapiDecrypt (2) failed"));
        // return a NULL PIN
        *pszTemp = L'\0';
        dwError = ERROR_SUCCESS;
    }
    
    m_pszPIN = pszTemp;   

    return dwError;

}



/****************************************************************************

    Class : CCallingCards        
   Method : Constructor

****************************************************************************/

CCallingCards::CCallingCards()
{
    m_dwNumEntries = 0;
    m_dwNextID = 0;

    m_hCards = NULL;

    m_hEnumNode = m_CallingCardList.head();
    
}


/****************************************************************************

    Class : CCallingCards        
   Method : Destructor

****************************************************************************/

CCallingCards::~CCallingCards()
{
    CCallingCardNode *node;

    node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_CallingCardList.flush();

    
    node = m_DeletedCallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_DeletedCallingCardList.flush();

    if(m_hCards)
        RegCloseKey(m_hCards);
}

/****************************************************************************

    Class : CCallingCards        
   Method : Initialize

            Checks the presence of the Cards key. If not present, it creates 
        and populates it from string resources.
            Verify the format of the registry config. If it is the old
        one, it converts it to the new one.
            Reads the cards from registry

****************************************************************************/

HRESULT CCallingCards::Initialize(void)
{
    DWORD       dwError;
    DWORD       dwDisp;
    BOOL        bNewCards = FALSE;
    DWORD       dwIndex;
    DWORD       dwLength;
    DWORD       dwType;
    CCallingCard    *pCard = NULL;
    HRESULT     Result = S_OK;
    BOOL        bNeedToConvert = FALSE;
    BOOL        bNeedToGenerateDefault = FALSE;

    // Test the presence of the Cards key
    dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                            gszCardsPath,
                            0,
                            KEY_READ,
                            &m_hCards
                            );
    if(dwError==ERROR_SUCCESS)
    {
        // Read the NextID value
        dwLength = sizeof(m_dwNextID);
        dwError = RegQueryValueEx ( m_hCards,
                                    gszNextID,
                                    NULL,
                                    &dwType,
                                    (PBYTE)&m_dwNextID,
                                    &dwLength
                                  );
        if(dwError==ERROR_SUCCESS)
        {
            if(dwType == REG_DWORD)
            {
                // Test the registry format and upgrade if necessary
                if(IsCardListInOldFormat(m_hCards))
                {   
                    bNeedToConvert = TRUE;
                }
            }
            else
            {
                dwError = ERROR_INVALID_DATA;
            }
        }
    }

    if(dwError != ERROR_SUCCESS)
        bNeedToGenerateDefault = TRUE;

    if(bNeedToGenerateDefault || bNeedToConvert)
    {
        // If the Cards key is missing or it has bad info, so we create a fresh, default set of cards.
        // If the cards key is in the old format, it have to be converted.
        // There's an excepted case, though: during the system setup no cards should be created or converted.
        // So detect setup case first:
        // 
        //

        HKEY    hSetupKey;
        DWORD   dwSetupValue;

        // close the cards key handle 
        if(m_hCards)
        {
            RegCloseKey(m_hCards);
            m_hCards = NULL;
        }
        
        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                gszSystemSetupPath,
                                0,
                                KEY_QUERY_VALUE,
                                &hSetupKey
                                );
        if(dwError == ERROR_SUCCESS)
        {
            dwLength = sizeof(dwSetupValue);
            dwSetupValue = 0;

            dwError = RegQueryValueEx(  hSetupKey,
                                        gszSystemSetupInProgress,
                                        NULL,
                                        &dwType,
                                        (PBYTE)&dwSetupValue,
                                        &dwLength
                                        );
            RegCloseKey(hSetupKey);
                                        
            if(dwError == ERROR_SUCCESS && dwType == REG_DWORD)
            {
                if(dwSetupValue == 1)
                {
                    // Setup time !
                    dwError = ERROR_SUCCESS;
                    goto forced_exit;
                }
            }
        }

        if(dwError != ERROR_SUCCESS)
        {
            // Hmm, cannot open the key or read the value...
            TRACE_DWERROR();
        }

        if(bNeedToConvert)
        {
            dwError = ConvertCallingCards(HKEY_CURRENT_USER);
            if(dwError!=ERROR_SUCCESS)
            {
                // fallback to default cards
                bNeedToGenerateDefault = TRUE;
            }
        }
                

        if(bNeedToGenerateDefault)   
        {
            dwError = CreateFreshCards();
            EXIT_IF_DWERROR();
        }

        // Reopen Cards key
        dwError = RegOpenKeyEx( HKEY_CURRENT_USER,
                                gszCardsPath,
                                0,
                                KEY_READ,
                                &m_hCards
                              );
        EXIT_IF_DWERROR();
  
        // ReRead the NextID value
        dwLength = sizeof(m_dwNextID);
        dwError = RegQueryValueEx ( m_hCards,
                                    gszNextID,
                                    NULL,
                                    &dwType,
                                    (PBYTE)&m_dwNextID,
                                    &dwLength
                                  );
        EXIT_IF_DWERROR();
       
    }

    // Read all entries
    dwIndex = 0;
    while(TRUE) 
    {
        TCHAR   szKeyName[ARRAYSIZE(gszCard)+MAX_NUMBER_LEN];
        DWORD   dwKeyLength;
        DWORD   dwCardID;

        // Enumerate next entry
        dwKeyLength = sizeof(szKeyName)/sizeof(TCHAR);
        dwError = RegEnumKeyEx (m_hCards,
                                dwIndex,
                                szKeyName,
                                &dwKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
                        
        if(dwError == ERROR_NO_MORE_ITEMS)
        {
            m_dwNumEntries = dwIndex;
            dwError = ERROR_SUCCESS;
            break;
        }
        
        EXIT_IF_DWERROR();

        // Create a CCallingCard object
        dwCardID = StrToInt(szKeyName+ARRAYSIZE(gszCard)-1);
        pCard = new CCallingCard;
        if(pCard != NULL)
        {
        
            // Read the card information from registry
            Result = pCard->Initialize(dwCardID);
            if(SUCCEEDED(Result))
            {
                // Add it to the list
                m_CallingCardList.tail()->insert_after(pCard);
            }
            else
            {
                LOG((TL_ERROR, "Error %x reading card %d", Result, dwCardID));
                delete pCard;
                pCard=NULL;
            }
        }

        dwIndex++;
    }
  
forced_exit:

    if(m_hCards)
    {
        RegCloseKey(m_hCards);
        m_hCards = NULL;
    }

    if(dwError != ERROR_SUCCESS)
        Result = HRESULT_FROM_WIN32(dwError);

    return Result;
}

/****************************************************************************

    Class : CCallingCards         
   Method : RemoveCard

****************************************************************************/
void CCallingCards::RemoveCard(CCallingCard *pCard)
{
    CCallingCardNode *node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        if ( pCard == node->value() ) 
        {
            InternalDeleteCard(node);
            return;
        }
        node = node->next();
    }
    assert(FALSE);
}


/****************************************************************************

    Class : CCallingCards         
   Method : RemoveCard

****************************************************************************/
void CCallingCards::RemoveCard(DWORD dwID)
{
    CCallingCardNode *node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        if ( dwID == (node->value())->GetCardID()  ) 
        {
            InternalDeleteCard(node);
            return;
        }
        node = node->next();
    }
    assert(FALSE);
}

/****************************************************************************

    Class : CCallingCards         
   Method : GetCallingCard

****************************************************************************/
CCallingCard * CCallingCards::GetCallingCard(DWORD  dwID)
{
    CCallingCardNode *node = m_CallingCardList.head(); 

    while( !node->beyond_tail() )
    {
        if ( dwID == (node->value())->GetCardID() ) 
        {
            return node->value();
        }
        node = node->next();

    }

    return NULL;


}

/****************************************************************************

    Class : CCallingCards        
   Method : SaveToRegistry


****************************************************************************/
HRESULT     CCallingCards::SaveToRegistry(void)
{
    DWORD       dwError = ERROR_SUCCESS;
    HRESULT     Result = S_OK;
    CCallingCardNode    *node;

    // Open the Cards key
    dwError = RegOpenKeyEx (HKEY_CURRENT_USER,
                            gszCardsPath,
                            0,
                            KEY_SET_VALUE,
                            &m_hCards);
    EXIT_IF_DWERROR();
 
    //first - save the next ID
    dwError = RegSetValueEx (   m_hCards,
                                gszNextID,
                                0,
                                REG_DWORD,
                                (PBYTE)&m_dwNextID,
                                sizeof(m_dwNextID)
                                );
    EXIT_IF_DWERROR();

    // save all cards (from both lists)
    node = m_CallingCardList.head();
    while( !node->beyond_tail() )
    {
        Result = node->value()->SaveToRegistry();
        EXIT_IF_FAILED();

        node = node->next();
    }

    node = m_DeletedCallingCardList.head();
    while( !node->beyond_tail() )
    {
        Result = node->value()->SaveToRegistry();
        EXIT_IF_FAILED();

        node = node->next();
    }


forced_exit:

    if(m_hCards)
    {
        RegCloseKey(m_hCards);
        m_hCards = NULL;
    }

    if(dwError != ERROR_SUCCESS)
        Result = HRESULT_FROM_WIN32(dwError);

    return Result;


}

/****************************************************************************

    Class : CCallingCards        
   Method : Reset


****************************************************************************/
HRESULT     CCallingCards::Reset(BOOL bInclHidden)
{
    m_hEnumNode = m_CallingCardList.head();
    m_bEnumInclHidden = bInclHidden;
    return S_OK;
}

/****************************************************************************

    Class : CCallingCards        
   Method : Next


****************************************************************************/
HRESULT     CCallingCards::Next(DWORD  NrElem, CCallingCard **ppCard, DWORD *pNrElemFetched)
{
    
    DWORD   dwIndex = 0;
    
    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;
    if(ppCard==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        CCallingCard    *pCard;
        
        pCard = m_hEnumNode->value();
        
        if(m_bEnumInclHidden || !pCard->IsMarkedHidden())
        {
            *ppCard++ = pCard;
            dwIndex++;
        }
        
        m_hEnumNode = m_hEnumNode->next();
    }
    
    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
}

/****************************************************************************

    Class : CCallingCards        
   Method : Skip


****************************************************************************/
HRESULT     CCallingCards::Skip(DWORD  NrElem)
{
    
    DWORD   dwIndex = 0;
    
    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
       
        if(m_bEnumInclHidden || !m_hEnumNode->value()->IsMarkedHidden())
        {
            dwIndex++;
        }
        
        m_hEnumNode = m_hEnumNode->next();
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}


 
/****************************************************************************

    Class : CCallingCards        
   Method : CreateFreshCards


****************************************************************************/

DWORD CCallingCards::CreateFreshCards(void)
{
    
    DWORD       dwError = ERROR_SUCCESS;
    HRESULT     Result = S_OK;
    HKEY        hTelephony = NULL;
    HINSTANCE   hTapiui = NULL;
    int         iNrChars;
    DWORD       dwNumCards;
    DWORD       dwDisp;
    DWORD       dwIndex;
    DWORD       dwValue;

    WCHAR       wBuffer[512];
    PWSTR       pTemp;

    CCallingCard    *pCard = NULL;

    // Open/Create the Telephony key
    dwError = RegCreateKeyEx(   HKEY_CURRENT_USER,
                                gszTelephonyPath,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                NULL,
                                &hTelephony,
                                &dwDisp
                                );
    EXIT_IF_DWERROR();

    // Delete any existing tree
    RegDeleteKeyRecursive( hTelephony, gszCards);

    // Open/Create the Cards key
    dwError = RegCreateKeyEx(   hTelephony,
                                gszCards,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE | KEY_READ,
                                NULL,
                                &m_hCards,
                                &dwDisp
                                );
    EXIT_IF_DWERROR();

    // Write the version
    dwValue = TAPI_CARD_LIST_VERSION;
    dwError = RegSetValueEx (   m_hCards,
                                gszCardListVersion,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue)
                                );
    EXIT_IF_DWERROR();

    // Load the TAPIUI.DLL resource library
    hTapiui = LoadLibrary(gszResourceLibrary);
    if(hTapiui==NULL)
        dwError = GetLastError();
    EXIT_IF_DWERROR();

    // Load the number of cards. Use wBuffer as a temporary space
    assert( MAX_NUMBER_LEN <= ARRAYSIZE(wBuffer) );
    iNrChars = LoadString( hTapiui, RC_CARD_ID_BASE, (PTSTR)wBuffer, MAX_NUMBER_LEN);
    if(iNrChars==0)
        dwError = GetLastError();
    EXIT_IF_DWERROR();

    dwNumCards = StrToInt( (PTSTR)wBuffer );

    //Read cards from string resources and write them to registry
    for(dwIndex = 0; dwIndex<dwNumCards; dwIndex++)
    {
        PWSTR pszName;
        PWSTR pszPin;
        PWSTR pszLocalRule;
        PWSTR pszLDRule;
        PWSTR pszInternationalRule;
        PWSTR pszAccountNumber;
        PWSTR pszLocalAccessNumber;
        PWSTR pszLDAccessNumber;
        PWSTR pszInternationalAccessNumber;
        DWORD dwFlags;

        // read the card description
        iNrChars = TAPILoadStringW( hTapiui,
                                    RC_CARD_ID_BASE + dwIndex + 1,
                                    wBuffer,
                                    ARRAYSIZE(wBuffer)
                                    );
        if(iNrChars==0)
            dwError = GetLastError();
        EXIT_IF_DWERROR();

        // tokenize it
#define TOKENIZE(Pointer)                       \
        Pointer = (wcschr(pTemp+1, L'"'))+1;    \
        pTemp = wcschr(Pointer, L'"');          \
        *pTemp = L'\0';

        pTemp = wBuffer-1;

        TOKENIZE(pszName);
        TOKENIZE(pszPin);
        TOKENIZE(pszLocalRule);
        TOKENIZE(pszLDRule);
        TOKENIZE(pszInternationalRule);
        TOKENIZE(pszAccountNumber);
        TOKENIZE(pszLocalAccessNumber);
        TOKENIZE(pszLDAccessNumber);
        TOKENIZE(pszInternationalAccessNumber);

#undef TOKENIZE
        // don't forget the flags
        dwFlags = _wtoi(pTemp+2);
        
        // create the card object
        pCard = new CCallingCard();
        if(pCard==NULL)
            dwError = ERROR_OUTOFMEMORY;
        EXIT_IF_DWERROR();

        Result = pCard->Initialize( dwIndex,
                                    pszName,
                                    dwFlags,
                                    pszPin,
                                    pszAccountNumber,
                                    pszInternationalRule,
                                    pszLDRule,
                                    pszLocalRule,
                                    pszInternationalAccessNumber,
                                    pszLDAccessNumber,
                                    pszLocalAccessNumber
                                    );
        EXIT_IF_FAILED();

        // save it
        Result = pCard->SaveToRegistry();

        EXIT_IF_FAILED();

        delete pCard;
        pCard = NULL;
    }

    // Write NextID value
    dwError = RegSetValueEx (   m_hCards,
                                gszNextID,
                                0,
                                REG_DWORD,
                                (PBYTE)&dwNumCards,
                                sizeof(dwNumCards)
                                );
    EXIT_IF_DWERROR();


forced_exit:

    if(hTelephony)
        RegCloseKey(hTelephony);
    if(m_hCards)
    {
        RegCloseKey(m_hCards);
        m_hCards = NULL;
    }
    if(pCard)
        delete pCard;
    if(hTapiui)
        FreeLibrary(hTapiui);

    if(FAILED(Result))
        dwError = HRESULT_CODE(Result);

    return dwError;
}

/****************************************************************************

    Class : CCallingCards        
   Method : InternalDeleteCard


****************************************************************************/

void CCallingCards::InternalDeleteCard(CCallingCardNode *pNode)
{

    CCallingCard *pCard = pNode->value();
    
    pCard->MarkDeleted();

    if(!pCard->IsMarkedHidden())
    {
        pNode->remove();
        m_dwNumEntries--;
        m_DeletedCallingCardList.tail()->insert_after(pCard);
    }
}


/****************************************************************************

    Helpers

****************************************************************************/

BOOL ValidValue(PWSTR pwszString)
{
    // An empty string or with spaces only is not valid
    WCHAR const * pwcCrt = pwszString;
    while(*pwcCrt)
        if(*pwcCrt++ != L' ')
            return TRUE;

    return FALSE;        
}






#ifdef DBG

static void DebugAssertFailure (LPCSTR file, DWORD line, LPCSTR condition)
{
    DbgPrt (0, TEXT("%hs(%d) : Assertion failed, condition: %hs\n"), file, line, condition);

    DebugBreak();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\watchit\watchit.h ===
#define IDD_MAIN_WATCHIT   1000
#define IDD_ABOUT          1001
#define IDD_ATEXTTITLE     1002
#define IDD_ATEXTCOPYRIGHT 1003


#define IDM_EXIT                 100
#define IDM_HELP_CONTENTS        101
#define IDM_HELP_WHATSTHIS       102
#define IDM_ABOUT                103


#define IDC_NUMCLIENTSTEXT    3000
#define IDC_NUMOUTCALLSTEXT   3001
#define IDC_NUMINCALLSTEXT	  3002


#define IDI_MAIN              2000
#define IDI_LARGE             2001
#define IDI_SMALL             2002
#define IDI_DEADTAPISRV       2003


#define WATCHIT_STRING_APPNAME         600
#define WATCHIT_STRING_FRIENDLYNAME    601
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\tsecimp.cpp ===
#include <windows.h>
#include <stdio.h>
#include "resource.h"
#include <tapi.h>
#include <objbase.h>
#include <activeds.h>
#include <lmerr.h>

#include "util.h"
#include "parser.h"
#include "mmcmgmt.h"
#include <locale.h>
#include <winnlsp.h>

const TCHAR         gszUserDNFmt[] = TEXT("WinNT://%s/%s,user");


// Unicode to Unicode
void Convert (LPWSTR wszIn, LPWSTR * pwszOut)
{
    if (NULL == wszIn)
    {
        * pwszOut = NULL;
        return;
    }

    *pwszOut = new WCHAR [ wcslen (wszIn) + 1 ];
    if (*pwszOut)
    {
        wcscpy (*pwszOut, wszIn);
    }

    return;
}

// Ansi to Unicode
void Convert (LPSTR szIn, LPWSTR * pwszOut)
{
    if (NULL == szIn)
    {
        * pwszOut = NULL;
        return;
    }

    *pwszOut = new WCHAR [ strlen (szIn) + 1 ];
    if (*pwszOut)
    {
        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    szIn,
                    -1,
                    *pwszOut,
                    strlen (szIn) + 1
                    )
            )
        {
            // the conversion failed
            delete [] *pwszOut;
            *pwszOut = NULL;
        }
    }

    return;
}

void UnicodeToOEM (LPWSTR wszIn, LPSTR *pszOut)
{
    int iSize;

    if (NULL == wszIn)
    {
        * pszOut = NULL;
        return;
    }

    // get the required buffer size
    iSize = WideCharToMultiByte(
                CP_OEMCP,
                0,
                wszIn,
                -1,
                NULL,
                0,
                NULL,
                NULL
                );

    if (0 == iSize)
    {
        *pszOut = NULL;
    }
    else
    {
        *pszOut = new char [ iSize ];
        if (*pszOut)
        {
            if ( 0 == WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        wszIn,
                        -1,
                        *pszOut,
                        iSize,
                        NULL,
                        NULL
                        )
                 )
            {
                // the conversion failed
                delete [] *pszOut;
                *pszOut = NULL;
            }
        }
    }

    return;
}

int MessagePrint(
                 LPTSTR szText,
                 LPTSTR szTitle
                 )
{
    LPTSTR szOutput = NULL;
    LPWSTR wszOutput = NULL;
    LPSTR  szOemOutput = NULL;
    UINT Codepage;
    char achCodepage[12] = ".OCP"; 

    // make it one TCHAR string
    szOutput = new TCHAR [ _tcslen(szText) + _tcslen(szTitle) + 3 ];

    if (!szOutput)
        return -1;

    _stprintf ( szOutput, _T("%s\n%s\n"), szTitle, szText );
    
    // convert the string to unicode
    Convert (szOutput, &wszOutput);
    delete [] szOutput;

    if (!wszOutput)
        return -1;

    // set the locale
    if (Codepage = GetConsoleOutputCP()) {
        wsprintfA(achCodepage, ".%u", Codepage);
        setlocale(LC_ALL, achCodepage);
    }
    else
    {
        setlocale (LC_COLLATE, achCodepage );  
        setlocale (LC_MONETARY, achCodepage ); 
        setlocale (LC_NUMERIC, achCodepage );  
        setlocale (LC_TIME, achCodepage );     
    }

    SetThreadUILanguage(0);

    // now print
    wprintf (_T("%s"), wszOutput);
    delete [] wszOutput;

    return 0;
}

int MessagePrintIds (
    int             idsText
    )
{
    CIds        IdsTitle (IDS_PRODUCTNAME);
    CIds        IdsText ( idsText );

    if ( IdsTitle.StringFound () && IdsText.StringFound () )
    {
        return MessagePrint (
                IdsText.GetString (),
                IdsTitle.GetString ()
                );
    }
    return 0;
}

//
//  Report an error resource string with one %s in it
//
void ReportSz1 (
    HANDLE      hLogFile,
    UINT        idsError,
    LPTSTR      szParam
    )
{
    TCHAR           szText[256];
    TCHAR           szBuf2[128];
    CIds            IdsError (idsError);
    CIds            IdsTitle (IDS_PRODUCTNAME);

    if ( IdsError.StringFound () && IdsTitle.StringFound () )
    {
        _tcsncpy (szBuf2, szParam, sizeof(szBuf2) / sizeof(TCHAR));
        szBuf2[sizeof(szBuf2) / sizeof(TCHAR) - 1] = 0;
        wsprintf (szText, IdsError.GetString (), szBuf2);
        if (hLogFile != NULL && hLogFile != INVALID_HANDLE_VALUE)
        {
            char    szAnsiBuf[256];
            DWORD   dwNumOfBytesWritten;
        
            WideCharToMultiByte (
                        CP_ACP,
                        0,
                        szText,
                        -1,
                        szAnsiBuf,
                        sizeof(szAnsiBuf),
                        NULL,
                        NULL
                        );
            lstrcatA (szAnsiBuf, "\n");
            WriteFile (
                        hLogFile,
                        szAnsiBuf,
                        lstrlenA (szAnsiBuf),
                        &dwNumOfBytesWritten,
                        NULL
                        );
        }
        else
        {
            MessagePrint (szText, IdsTitle.GetString ());
        }
    }
}

//
//  IsValidDomainUser
//      Check if a domain user like redmond\jonsmith specified in szDomainUser
//  is valid or not. returns S_FALSE if it is invalid, S_OK for valid user.
//
//  szFullName      ----    To return the user's full name
//  cch             ----    count of characters pointed to by szFullName
//
//  if szFullName is NULL or cch is zero, no full name is returned
//

HRESULT IsValidDomainUser (
    LPCTSTR szDomainUser,
    LPTSTR  szFullName,
    DWORD   cch
    )
{
    HRESULT             hr = S_OK;
    TCHAR               szDN[256];
    TCHAR               szDomain[256];
    LPTSTR              szSep;
    LPCTSTR             szUser;
    DWORD               dw;

    IADsUser            * pUser = NULL;
    BSTR                bstrFullName = NULL;

    //  Sanity check
    if (szDomainUser == NULL || szDomainUser[0] == 0)
    {
        hr = S_FALSE;
        goto ExitHere;
    }

    //
    //  Construct the user DN as <WINNT://domain/user,user>
    //
    szSep = _tcschr (szDomainUser, TEXT('\\'));
    if (szSep == NULL)
    {
        //  No '\' is given, assume a local user ,domain is local computer
        szUser = szDomainUser;
        dw = sizeof(szDomain)/sizeof(TCHAR);
        if (GetComputerName (szDomain, &dw) == 0)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
    }
    else
    {
        //  assume invalid domain name if longer than 255
        if (szSep - szDomainUser >= sizeof(szDomain)/sizeof(TCHAR))
        {
            hr = S_FALSE;
            goto ExitHere;
        }
        _tcsncpy (szDomain, szDomainUser, szSep - szDomainUser);
        szDomain[szSep - szDomainUser] = 0;
        szUser = szSep + 1;
    }
    if (_tcslen (gszUserDNFmt) + _tcslen (szDomain) + _tcslen (szUser) > 
        sizeof(szDN) / sizeof(TCHAR))
    {
        hr = S_FALSE;
        goto ExitHere;
    }
    wsprintf (szDN, gszUserDNFmt, szDomain, szUser);

    //
    //  Try to bind to the user object
    //
    hr = ADsGetObject (szDN, IID_IADsUser, (void **)&pUser);
    if (FAILED(hr))
    {
        if (hr == E_ADS_INVALID_USER_OBJECT ||
            hr == E_ADS_UNKNOWN_OBJECT ||
            hr == E_ADS_BAD_PATHNAME ||
            HRESULT_CODE(hr) == NERR_UserNotFound)
        {
            hr = S_FALSE;   // The user does not exist
        }
        goto ExitHere;
    }

    //
    //  If the user exists, get its full name
    //
    if (cch > 0)
    {
        hr = pUser->get_FullName (&bstrFullName);
        szFullName[0] = 0;
        if (hr == S_OK)
        {
            _tcsncpy (szFullName, bstrFullName, cch);
            szFullName[cch - 1] = 0;
        }
    }

ExitHere:
    if (pUser)
    {
        pUser->Release();
    }
    if (bstrFullName)
    {
        SysFreeString (bstrFullName);
    }
    return hr;
}

LPTSTR AppendStringAndFree (LPTSTR szOld, LPTSTR szToAppend)
{
    LPTSTR      szNew;
    DWORD       dwLen;

    dwLen = ((szOld == NULL) ? 0 : _tcslen (szOld)) + _tcslen (szToAppend) + 1;
    szNew = new TCHAR[dwLen * sizeof(TCHAR)];
    if (szNew == NULL)
    {
        goto ExitHere;
    }

    if (szOld)
    {
        _tcscpy (szNew, szOld);
        _tcscat (szNew, szToAppend);
    }
    else
    {
        _tcscpy (szNew, szToAppend);
    }

ExitHere:
    if (szOld)
    {
        delete [] szOld;
    }
    return szNew;
}


void
TsecCommandLine::ParseCommandLine (LPTSTR szCommand)
{
    if (szCommand == NULL)
    {
        goto ExitHere;
    }

    //
    //  Skip the first segment which is the executable itself
    //
    if (*szCommand == TEXT('\"'))
    {
        ++szCommand;
        while (*szCommand &&
            *szCommand != TEXT('\"'))
        {
            ++szCommand;
        }
        if (*szCommand == TEXT('\"'))
        {
            ++szCommand;
        }
    }
    else
    {
        while (
            *szCommand  &&
            *szCommand != TEXT(' ') &&
            *szCommand != TEXT('\t') &&
            *szCommand != 0x0a &&
            *szCommand != 0x0d)
        {
            ++szCommand;
        }
    }

    while (*szCommand)
    {
        //
        //  Search for / or - as the start of option
        //
        while (*szCommand &&
           *szCommand != TEXT('/') &&
           *szCommand != TEXT('-')
          )
        {
            szCommand++;
        }

        if (*szCommand == 0)
        {
            break;
        }
        ++szCommand;

        //
        //  -h, -H, -? means help
        //
        if (*szCommand == TEXT('h') ||
            *szCommand == TEXT('H') ||
            *szCommand == TEXT('?'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fShowHelp = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -v or -V followed by white space means validating only
        //
        else if (*szCommand == TEXT('v') ||
            *szCommand == TEXT('V'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fValidateOnly = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -u, -U means to validate domain user account
        //
        else if (*szCommand == TEXT('u') ||
            *szCommand == TEXT('U'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fValidateDU = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -d or -D followed by white space means dump current configuration
        //
        else if (*szCommand == TEXT('d') ||
            *szCommand == TEXT('D'))
        {
            ++szCommand;
            if (*szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0 ||
                *szCommand == 0x0d)
            {
                m_fDumpConfig = TRUE;
            }
            else
            {
                m_fError = TRUE;
                m_fShowHelp = TRUE;
            }
        }
        //
        //  -f is followed by a xml file name
        //
        else if (*szCommand == TEXT('f') ||
            *szCommand == TEXT('F'))
        {
            ++szCommand;
            //  skip white spaces
            while (*szCommand != 0 && (
                *szCommand == TEXT(' ') ||
                *szCommand == TEXT('\t') ||
                *szCommand == 0x0a ||
                *szCommand == 0x0d))
            {
                ++szCommand;
            }
            if (*szCommand == 0)
            {
                //  no file name specified for -f, error
                m_fError = TRUE;
            }
            else
            {
                LPTSTR      szBeg;
                int         cch;
        
                szBeg = szCommand;
                cch = 0;
                //  A quote means file name might contain space
                //  search until the matchint quote of end
                if (*szCommand == TEXT('\"'))
                {
                    ++szCommand;
                    while (*szCommand != 0 && 
                        *szCommand != TEXT('\"'))
                    {
                        ++szCommand;
                        ++cch;
                    }
                }
                else
                {
                    while (*szCommand != 0 &&
                        *szCommand != TEXT(' ') &&
                        *szCommand != TEXT('\t') &&
                        *szCommand != TEXT('\r') &&
                        *szCommand != TEXT('\n'))
                    {
                        ++szCommand;
                        ++cch;
                    }
                }
                if (cch == 0)
                {
                    m_fError = TRUE;
                }
                else
                {
                    m_szInFile = new TCHAR[cch+1];
                    if (m_szInFile != NULL)
                    {
                        memcpy (m_szInFile, szBeg, cch * sizeof(TCHAR));
                        m_szInFile[cch] = 0;
                    }
                }
            }
        }
        else if(*szCommand)
        {
            m_fError = TRUE;
            ++szCommand;
        }
    }

ExitHere:
    return;
}

int _cdecl wmain( void )
{
    HRESULT         hr = S_OK;
    BOOL            bUninit = FALSE;
    CXMLParser      parser;
    CXMLUser        * pCurUser = NULL, *pNextUser;
    CMMCManagement  * pMmc = NULL;
    BOOL            bNoMerge, bRemove, bPID;
    TCHAR           szBufDU[256];
    TCHAR           szBufFN[256];
    TCHAR           szBufAddr[128];
    DWORD           dwPID;
    HWND            hwndDump = NULL;
    HANDLE          hLogFile = INVALID_HANDLE_VALUE;
    BOOL            bRecordedError = FALSE, bValidUser;
    TsecCommandLine cmd (GetCommandLine ());

    CXMLLine        * pCurLine = NULL, * pNextLine;

    //
    //  Create a dump window so that tlist.exe will report a title
    //
    if (LoadString (
        GetModuleHandle(NULL),
        IDS_PRODUCTNAME,
        szBufFN,
        sizeof(szBufFN)/sizeof(TCHAR)))
    {
        hwndDump = CreateWindow (
            TEXT("STATIC"),
            szBufFN,
            0,
            0, 0, 0, 0,
            NULL,
            NULL,
            NULL,
            NULL
            );
    }

    //
    //  Check the command line options
    //
    if (cmd.FError ()                           || 
        cmd.FShowHelp ()                        || 
        !cmd.FDumpConfig () && !cmd.FHasFile () ||
        cmd.FDumpConfig () && cmd.FHasFile ()   ||
        ( cmd.FValidateOnly () || cmd.FValidateUser () ) && !cmd.FHasFile ()
       )
    {
        cmd.PrintUsage();
        goto ExitHere;
    }

    hr = CoInitializeEx (
        NULL,
        COINIT_MULTITHREADED 
        );
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    bUninit = TRUE;

    //
    //  Prepare the MMC component
    //
    pMmc = new CMMCManagement ();
    if (pMmc == NULL)
    {
        hr = TSECERR_NOMEM;
        goto ExitHere;
    }
    hr = pMmc->GetMMCData ();
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    //
    // Dump the current config if this option was present
    //
    if ( cmd.FDumpConfig() )
    {
        hr = pMmc->DisplayMMCData ();
            goto ExitHere;
    }

    //
    //  Set the XML file name and parse it, report error if any
    //
    
    hr = parser.SetXMLFile (cmd.GetInFileName ());
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    hr = parser.Parse ();
    //  Report parsing error if any
    if (hr == TSECERR_INVALFILEFORMAT)
    {
        hr = parser.ReportParsingError ();
        goto ExitHere;
    }
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    //
    //  Create the log file for reporting errors during
    //  MMC processing
    //
    hLogFile = CreateFile (
        _T("tsecimp.log"),
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }

    //
    //  Loop through each user and device, based on the user's
    //  request, add or remove lines
    //
    hr = parser.GetFirstUser (&pCurUser);
    if (FAILED(hr))
    {
        goto ExitHere;
    }
    while (pCurUser != NULL)
    {
        if (FAILED(hr = pCurUser->GetDomainUser(
                szBufDU, sizeof(szBufDU)/sizeof(TCHAR))) ||
            FAILED(hr = pCurUser->GetFriendlyName(
                szBufFN, sizeof(szBufFN)/sizeof(TCHAR))))
        {
            goto ExitHere;
        }

        bValidUser = TRUE;

        if (cmd.FValidateUser())
        {
            hr = IsValidDomainUser(
                szBufDU, 
                szBufAddr,  //  Borrowing szBufAddr for returning full name
                sizeof(szBufAddr) / sizeof(TCHAR)
                );
            if (FAILED(hr))
            {
                goto ExitHere;
            }
            //  Not a valid domain user, report it
            if (hr == S_FALSE)
            {
                //  domain user <%s> is invalid
                ReportSz1 (hLogFile, IDS_INVALIDUSER, szBufDU);
                bRecordedError = TRUE;
                bValidUser = FALSE;
            }
            if (szBufFN[0] == 0)
            {
                if (szBufAddr[0] != 0)
                {
                    //  Got a friendly name from DS, use it
                    _tcscpy (szBufFN, szBufAddr);
                }
            }
        }
        //  Still got no friendly name? use the domain user name
        if (szBufFN[0] == 0)
        {
            _tcscpy (szBufFN, szBufDU);
        }
    
        hr = pCurUser->IsNoMerge (&bNoMerge);
        if (FAILED(hr))
        {
            goto ExitHere;
        }
        if (bNoMerge && !cmd.FValidateOnly())
        {
            hr = pMmc->RemoveLinesForUser(szBufDU);
            if (FAILED(hr))
            {
                goto ExitHere;
            }
        }

        //
        //  Loop through each line, add or remove the device
        //
        if (pCurLine)
        {
            delete pCurLine;
        }
        hr = pCurUser->GetFirstLine (&pCurLine);
        if (FAILED(hr))
        {
            goto ExitHere;
        }
        while (pCurLine != NULL)
        {
            if (FAILED(hr = pCurLine->IsRemove(&bRemove)) ||
                FAILED(hr = pCurLine->IsPermanentID(&bPID)))
            {
                goto ExitHere;
            }
            if (bPID)
            {
                hr = pCurLine->GetPermanentID(&dwPID);
            }
            else
            {
                hr = pCurLine->GetAddress(
                    szBufAddr, 
                    sizeof(szBufAddr)/sizeof(TCHAR)
                    );
            }
            if (FAILED(hr))
            {
                goto ExitHere;
            }

            if (!cmd.FValidateOnly() && bValidUser)
            {
                if (bRemove)
                {
                    if (bPID)
                    {
                        hr = pMmc->RemoveLinePIDForUser (
                            dwPID,
                            szBufDU
                            );
                    }
                    else
                    {
                        hr = pMmc->RemoveLineAddrForUser (
                            szBufAddr,
                            szBufDU
                            );
                    }
                }
                else
                {
                    if (bPID)
                    {
                        hr = pMmc->AddLinePIDForUser (
                            dwPID,
                            szBufDU,
                            szBufFN
                            );
                    }
                    else
                    {
                        hr = pMmc->AddLineAddrForUser (
                            szBufAddr,
                            szBufDU,
                            szBufFN
                            );
                    }
                }
            }
            else
            {
                if (bPID)
                {
                    hr = pMmc->IsValidPID (dwPID);
                }
                else
                {
                    hr = pMmc->IsValidAddress (szBufAddr);
                }
            }

            if( hr == S_FALSE || hr == TSECERR_DEVLOCALONLY)
            {
                //  An invalid permanent ID or address is given
                //  report the error and quit
                TCHAR           szText[256];
                CIds            IdsTitle (IDS_PRODUCTNAME);

                if ( IdsTitle.StringFound () )
                {
                    szText[0] = 0;

                    if (bPID)
                    {
                        CIds IdsError (TSECERR_DEVLOCALONLY ? IDS_LOCALONLYPID : IDS_INVALPID);
                    
                        if ( IdsError.StringFound () )
                        {
                            wsprintf (szText, IdsError.GetString (), dwPID);
                        }
                    }
                    else if (!bPID)
                    {   
                        CIds IdsError (TSECERR_DEVLOCALONLY ? IDS_LOCALONLYADDR : IDS_INVALADDR);

                        if ( IdsError.StringFound () )
                        {
                            wsprintf (szText, IdsError.GetString (), szBufAddr);
                        }
                    }
                    if (hLogFile != NULL && hLogFile != INVALID_HANDLE_VALUE)
                    {
                        char    szAnsiBuf[256];
                        DWORD   dwNumOfBytesWritten;

                        WideCharToMultiByte (
                            CP_ACP,
                            0,
                            szText,
                            -1,
                            szAnsiBuf,
                            sizeof(szAnsiBuf),
                            NULL,
                            NULL
                            );
                        lstrcatA (szAnsiBuf, "\n");
                        WriteFile (
                            hLogFile,
                            szAnsiBuf,
                            lstrlenA (szAnsiBuf),
                            &dwNumOfBytesWritten,
                            NULL
                            );
                    }
                    else
                    {
                        MessagePrint (szText, IdsTitle.GetString ());
                    }
                }
                bRecordedError = TRUE;
                hr = S_OK;
            }
            else if(FAILED(hr))
            {
                goto ExitHere;
            }
        
            hr = pCurLine->GetNextLine (&pNextLine);
            if (FAILED(hr))
            {
                goto ExitHere;
            }
            delete pCurLine;
            pCurLine = pNextLine;
        }

        hr = pCurUser->GetNextUser (&pNextUser);
        if (FAILED(hr))
        {
            goto ExitHere;
        }
        delete pCurUser;
        pCurUser = pNextUser;
    }

    //  If error happend, we aready exited, reset warnings
    hr = S_OK;
    //  We are done if we are asked to do validating only
    if (bRecordedError)
    {
        MessagePrintIds (IDS_HASERROR);
    }
    else if (cmd.FValidateOnly())
    {
        MessagePrintIds (IDS_VALIDSUCCESS);
    }
    else
    {
        MessagePrintIds (IDS_FINSUCCESS);
    }

ExitHere:

    //
    //  Report error if any here
    //
    if(FAILED(hr))
    {
        ReportError (NULL, hr);
    }

    if (hwndDump)
    {
        DestroyWindow (hwndDump);
    }

    if (hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hLogFile);
    }

    if (pCurLine)
    {
        delete pCurLine;
    }
    if (pCurUser)
    {
        delete pCurUser;
    }
    if (pMmc)
    {
        delete pMmc;
    }
    parser.Release();
    if (bUninit)
    {
        CoUninitialize ();
    }
    return 0;
}

void ReportError (
    HANDLE          hFile,
    HRESULT         hr
    )
{
    TCHAR       szTitle[128];
    TCHAR       szBuf[512];
    HINSTANCE   hModule = GetModuleHandle (NULL);

    if (LoadString (
        hModule,
        IDS_PRODUCTNAME,
        szTitle,
        sizeof(szTitle)/sizeof(TCHAR)
        ) == 0)
    {
        goto ExitHere;
    }
    
   //  Is this our own error
    if (HRESULT_FACILITY(hr) == FACILITY_TSEC_CODE)
    {
        if (FormatMessage (
            FORMAT_MESSAGE_FROM_HMODULE, 
            hModule, 
            HRESULT_CODE(hr),
            0,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR),
            NULL
            ) == 0)
        {
            goto ExitHere;
        }
    }
    //  Is this TAPI error?
    else if ((hr < 0 && hr > -100) || HRESULT_FACILITY(hr) == 0)
    {
        hModule = LoadLibrary (TEXT("TAPIUI.DLL"));
        if (hModule == NULL)
        {
            goto ExitHere;
        }
        if (FormatMessage (
            FORMAT_MESSAGE_FROM_HMODULE, 
            hModule, 
            TAPIERROR_FORMATMESSAGE(hr),
            0,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR),
            NULL
            ) == 0)
        {
            FreeLibrary (hModule);
            goto ExitHere;
        }
        FreeLibrary (hModule);
    }
    //  Assume system error
    else
    {
        if (FormatMessage (
            FORMAT_MESSAGE_FROM_SYSTEM, 
            NULL, 
            HRESULT_CODE(hr),
            0,
            szBuf,
            sizeof(szBuf)/sizeof(TCHAR),
            NULL
            ) == 0)
        {
            goto ExitHere;
        }
    }
    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE)
    {
        MessagePrint (szBuf, szTitle);
    }
    else
    {
        char    szAnsiBuf[1024];
        DWORD   dwNumOfBytesWritten;

        WideCharToMultiByte (
            CP_ACP,
            0,
            szBuf,
            -1,
            szAnsiBuf,
            sizeof(szAnsiBuf),
            NULL,
            NULL
            );
        lstrcatA (szAnsiBuf, "\n");
        WriteFile (
            hFile,
            szAnsiBuf,
            lstrlenA (szAnsiBuf),
            &dwNumOfBytesWritten,
            NULL
            );
    }

ExitHere:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\tsecimp\util.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Header file for utility functions / classes

Author:

    Xiaohai Zhang (xzhang)    22-March-2000

Revision History:

--*/
#ifndef __UTIL_H__
#define __UTIL_H__

#include "tchar.h"
#include "error.h"
#include "resource.h"

int MessagePrint(
    LPTSTR szText,
    LPTSTR szTitle
    );

int MessagePrintIds (
    int             idsText
    );

LPTSTR AppendStringAndFree (
    LPTSTR szOld, 
    LPTSTR szToAppend
    );

void ReportError (
    HANDLE  hFile,
    HRESULT hr
    );

class TsecCommandLine
{
public:
    //
    //  Constructor/destructor
    //
    TsecCommandLine (LPTSTR szCommand)
    {
        m_fShowHelp     = FALSE;
        m_fError        = FALSE;
        m_fValidateOnly = FALSE;
        m_fValidateDU   = FALSE;
        m_fDumpConfig   = FALSE;
        m_szInFile      = NULL;

        ParseCommandLine (szCommand);
    }
    
    ~TsecCommandLine ()
    {
        if (m_szInFile)
        {
            delete [] m_szInFile;
        }
    }

    BOOL FShowHelp ()
    {
        return m_fShowHelp;
    }

    BOOL FValidateOnly()
    {
        return m_fValidateOnly;
    }

    BOOL FError()
    {
        return m_fError;
    }

    BOOL FValidateUser ()
    {
        return m_fValidateDU;
    }

    BOOL FDumpConfig ()
    {
        return m_fDumpConfig;
    }

    BOOL FHasFile ()
    {
        return ((m_szInFile != NULL) && (*m_szInFile != 0));
    }

    LPCTSTR GetInFileName ()
    {
        return m_szInFile;
    }

    void PrintUsage()
    {
        MessagePrintIds (IDS_USAGE);
    }

private:
    void ParseCommandLine (LPTSTR szCommand);

private:
    BOOL        m_fShowHelp;
    BOOL        m_fValidateOnly;
    BOOL        m_fError;
    BOOL        m_fValidateDU;
    BOOL        m_fDumpConfig;
    LPTSTR      m_szInFile;
};

#define MAX_IDS_BUFFER_SIZE     512

class CIds
{
public:

    //
    //  Constructor/destructor
    //
    CIds (UINT resourceID)
    {
        GetModuleHnd ();
        LoadIds (resourceID);
    }
    
    ~CIds ()
    {
        if (m_szString)
        {
            delete [] m_szString;
        }
    }

    LPTSTR GetString (void)
    {
        return (m_szString ? m_szString : (LPTSTR) m_szEmptyString);
    }

    BOOL StringFound (void)
    {
        return (m_szString != NULL);
    }

private:

    void LoadIds (UINT resourceID);
    void GetModuleHnd (void);

private:

    LPTSTR              m_szString;

    static const TCHAR  m_szEmptyString[2];
    static HMODULE      m_hModule;

};

#endif // util.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\card.h ===
/****************************************************************************
 
  Copyright (c) 1998  Microsoft Corporation
                                                              
  Module Name:  card.h
                                                              
     Abstract:  Calling Card Object definitions
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#ifndef __CARD_H_
#define __CARD_H_

#include "utils.h"
#include "rules.h"



#define MAXLEN_CARDNAME            96
#define MAXLEN_PIN                 128
#define MAXLEN_RULE                128

#define CARD_BUILTIN  1
#define CARD_HIDE     2

// Calling Card Validation Flags
#define CCVF_NOCARDNAME                     0x01
#define CCVF_NOCARDRULES                    0x02
#define CCVF_NOCARDNUMBER                   0x04
#define CCVF_NOPINNUMBER                    0x08
#define CCVF_NOINTERNATIONALACCESSNUMBER    0x10
#define CCVF_NOLOCALACCESSNUMBER            0x20
#define CCVF_NOLONGDISTANCEACCESSNUMBER     0x40


//***************************************************************************
//
//  Class Definition - CCallingCard
//
//***************************************************************************
class CCallingCard
{
private:

    DWORD       m_dwCardID;
    PWSTR       m_pszCardName;
    
    DWORD       m_dwFlags;

    PWSTR       m_pszPIN;
    PWSTR       m_pszEncryptedPIN;
    PWSTR       m_pszAccountNumber;

    PWSTR       m_pszLocalAccessNumber;
    PWSTR       m_pszLongDistanceAccessNumber;
    PWSTR       m_pszInternationalAccessNumber;
    
    CRuleSet    m_Rules;

    HKEY        m_hCard;
    PTSTR       m_pszCardPath;

    BOOL        m_bDirty;
    BOOL        m_bDeleted;
    
    DWORD       m_dwCryptInitResult;

private:
    void        CleanUp(void);
    DWORD       OpenCardKey(BOOL bWrite);
    DWORD       CloseCardKey();
    DWORD       ReadOneStringValue(PWSTR *pMember, const TCHAR *pszName);

    DWORD       EncryptPIN(void);
    DWORD       DecryptPIN(void);

public:
    CCallingCard(); 

    ~CCallingCard();

	DECLARE_TRACELOG_CLASS(CCallingCard)

	HRESULT Initialize   (
                            DWORD dwCardID,
                            PWSTR pszCardName,
                            DWORD dwFlags,
                            PWSTR pszPIN,
                            PWSTR pszAccountNumber,
                            PWSTR pszInternationalRule,
                            PWSTR pszLongDistanceRule,
                            PWSTR pszLocalRule,
                            PWSTR pszInternationalAccessNumber,
                            PWSTR pszLongDistanceAccessNumber,
                            PWSTR pszLocalAccessNumber
                         );
    HRESULT Initialize  (  DWORD dwCardID);

    HRESULT SaveToRegistry(void);
    HRESULT MarkDeleted(void);
    DWORD   IsMarkedDeleted(void) const {return m_bDeleted || (m_dwFlags & CARD_HIDE);};
    DWORD   IsMarkedHidden(void) const {return (m_dwFlags & CARD_HIDE) != 0;};
    DWORD   IsMarkedPermanent(void) const {return (m_dwFlags & CARD_BUILTIN) != 0;};

    DWORD   Validate(void);

#define GET_SET_METHOD(Member)                                 \
    PWSTR   Get##Member(void) const { return m_psz##Member; }; \
    HRESULT Set##Member(PWSTR) ;                        

    GET_SET_METHOD(CardName)
    GET_SET_METHOD(PIN);
    GET_SET_METHOD(AccountNumber);
    GET_SET_METHOD(InternationalAccessNumber);
    GET_SET_METHOD(LongDistanceAccessNumber);
    GET_SET_METHOD(LocalAccessNumber);


#define m_pszInternationalRule  m_Rules.m_pszInternationalRule
#define m_pszLongDistanceRule   m_Rules.m_pszLongDistanceRule
#define m_pszLocalRule          m_Rules.m_pszLocalRule

    GET_SET_METHOD(InternationalRule);
    GET_SET_METHOD(LongDistanceRule);
    GET_SET_METHOD(LocalRule);

#undef m_pszInternationalRule
#undef m_pszLongDistanceRule
#undef m_pszLocalRule

#undef GET_SET_METHOD

    CRuleSet * GetRuleSet(){return &m_Rules;}

    DWORD   GetCardID(void) const {return m_dwCardID;}
    HRESULT SetCardID(DWORD dwCardID) {m_dwCardID=dwCardID; return S_OK;}
};

//***************************************************************************
// Fill out the list template

typedef LinkedList<CCallingCard *> CCallingCardList;
typedef ListNode<CCallingCard *> CCallingCardNode;

//***************************************************************************
//
//  Class Definition - CCallingCards
//
//***************************************************************************
class CCallingCards
{
private:

    DWORD               m_dwNumEntries;
    DWORD               m_dwNextID;
    CCallingCardList    m_CallingCardList;
    CCallingCardList    m_DeletedCallingCardList;
    HKEY                m_hCards;

    CCallingCardNode    *m_hEnumNode;
    BOOL                m_bEnumInclHidden;
    
private:
    DWORD               CreateFreshCards(void);

    void                InternalDeleteCard(CCallingCardNode *);

public:
    CCallingCards();
    ~CCallingCards();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCallingCards)
#endif

    HRESULT     Initialize(void);
    HRESULT     SaveToRegistry(void);

    void        AddCard(CCallingCard *pNewCard) {m_CallingCardList.tail()->insert_after(pNewCard); m_dwNumEntries++;};
    void        RemoveCard(CCallingCard *pCard);
    void        RemoveCard(DWORD dwID);

    DWORD       AllocNewCardID(void) { return m_dwNextID++; };
    DWORD       GetNumCards(void) const { return m_dwNumEntries; } ;

    CCallingCard    *GetCallingCard(DWORD   dwID);
    // a sort of enumerator
    HRESULT     Reset(BOOL bInclHidden);
    HRESULT     Next(DWORD  NrElem, CCallingCard **, DWORD *pNrElemFetched);
    HRESULT     Skip(DWORD  NrElem);
    

};





#endif //__CARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\countrygroup.h ===
/****************************************************************************
 
  Copyright (c) 2000  Microsoft Corporation
                                                              
  Module Name:  countrygroup.h
                                                              
     Abstract:  Internal country entry and country list definitions 
                for country groups support
                                                              
****************************************************************************/

#ifndef __COUNTRYGROUP_H_
#define __COUNTRYGROUP_H_


//
// This structure is the same as LINECOUNTRYENTRY
// The only difference is that dwNextCountryID has been replaced by dwCountryGroup
//
typedef struct _linecountryentry_internal
{
    DWORD       dwCountryID;                                    
    DWORD       dwCountryCode;                                  
    DWORD       dwCountryGroup;                                
    DWORD       dwCountryNameSize;                              
    DWORD       dwCountryNameOffset;                            
    DWORD       dwSameAreaRuleSize;                             
    DWORD       dwSameAreaRuleOffset;                           
    DWORD       dwLongDistanceRuleSize;                         
    DWORD       dwLongDistanceRuleOffset;                       
    DWORD       dwInternationalRuleSize;                        
    DWORD       dwInternationalRuleOffset;                      

} LINECOUNTRYENTRY_INTERNAL, FAR *LPLINECOUNTRYENTRY_INTERNAL;

typedef struct _linecountrylist_internal
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumCountries;
    DWORD       dwCountryListSize;
    DWORD       dwCountryListOffset;

} LINECOUNTRYLIST_INTERNAL, FAR *LPLINECOUNTRYLIST_INTERNAL;


LONG PASCAL ReadCountriesAndGroups( LPLINECOUNTRYLIST_INTERNAL *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\client.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the tapi.dll implementation (client-side tapi)

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:


Notes:

    1. Make all funcArg structs STATIC, & just do whatever mov's necessary
       for the params (saves mov's for flags, pfnPostProcess, funcName, &
       argTypes)

--*/


#include "windows.h"
#include "wownt32.h"
#include "stdarg.h"
#include "stdio.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "clntprivate.h"
#include "tapsrv.h"
#include "loc_comn.h"
#include "prsht.h"
#include "shellapi.h"
#include "tapiperf.h"
#include "tlnklist.h"
#include "tapihndl.h"
#include "resource.h"
#include "tchar.h"
#include "shfusion.h"
#include <shlwapi.h>
#include <shlwapip.h>   // from private\inc
#include <MMSYSTEM.H>
#include <mmddk.h>
#include "tregupr2.h"

#undef   lineBlindTransfer
#undef   lineConfigDialog
#undef   lineConfigDialogEdit
#undef   lineDial
#undef   lineForward
#undef   lineGatherDigits
#undef   lineGenerateDigits
#undef   lineGetAddressCaps
#undef   lineGetAddressID
#undef   lineGetAddressStatus
#undef   lineGetCallInfo
#undef   lineGetDevCaps
#undef   lineGetDevConfig
#undef   lineGetIcon
#undef   lineGetID
#undef   lineGetLineDevStatus
#undef   lineGetRequest
#undef   lineGetTranslateCaps
#undef   lineHandoff
#undef   lineMakeCall
#undef   lineOpen
#undef   linePark
#undef   linePickup
#undef   linePrepareAddToConference
#undef   lineRedirect
#undef   lineSetDevConfig
#undef   lineSetTollList
#undef   lineSetupConference
#undef   lineSetupTransfer
#undef   lineTranslateAddress
#undef   lineUnpark
#undef   phoneConfigDialog
#undef   phoneGetButtonInfo
#undef   phoneGetDevCaps
#undef   phoneGetIcon
#undef   phoneGetID
#undef   phoneGetStatus
#undef   phoneSetButtonInfo
#undef   tapiGetLocationInfo
#undef   tapiRequestMakeCall
#undef   tapiRequestMediaCall
#undef   lineAddProvider
#undef   lineGetAppPriority
#undef   lineGetCountry
#undef   lineGetProviderList
#undef   lineSetAppPriority
#undef   lineTranslateDialog


//
//
//

#define HUB_MONITOR_LINE_CONTEXT_BASE   0xc0000000

#define ASNYC_MSG_BUF_SIZE 1024

typedef struct _ASYNC_EVENTS_THREAD_PARAMS
{
    BOOL    bExitThread;

    DWORD   dwBufSize;

    HANDLE  hTapi32;

    HANDLE  hWow32;

    LPBYTE  pBuf;

} ASYNC_EVENTS_THREAD_PARAMS, *PASYNC_EVENTS_THREAD_PARAMS;



#if DBG

//
// N.B. This structure MUST be a multiple of 8 bytes in size.
//

typedef struct _MYMEMINFO
{
    struct _MYMEMINFO * pNext;
    struct _MYMEMINFO * pPrev;
    DWORD               dwSize;
    DWORD               dwLine;
    PSTR                pszFile;
    DWORD               dwAlign;

//    LPTSTR              pName;
} MYMEMINFO, *PMYMEMINFO;

PMYMEMINFO            gpMemFirst = NULL, gpMemLast = NULL;
CRITICAL_SECTION      csMemoryList;
BOOL                  gbBreakOnLeak = FALSE;

void
DumpMemoryList();
#endif

//
// Global vars
//

BOOL    gbHiddenWndClassRegistered = FALSE;
BOOL    gbNTVDMClient        = FALSE;
DWORD   gdwRpcRefCount       = 0;
BOOL    gbDisableGetTranslateCapsHack = FALSE;
DWORD   gdwNumInits          = 0;
DWORD   gdwTlsIndex;
DWORD   gdwTlsIndexRpcCtx;
DWORD   gdwNumLineDevices    = 0;
DWORD   gdwNumPhoneDevices   = 0;
DWORD   gdwInitialTickCount;
HANDLE  ghAsyncEventsEvent   = NULL;
HANDLE  ghInitMutex;

#if DBG
DWORD gdwDebugLevel = 0;
#endif

TCHAR gszLCRDLL[] = TEXT("LeastCostRoutingDLL");
TCHAR gszRemoteSP[] = TEXT("RemoteSP.TSP");


LONG
(WINAPI
*pfnLineOpenWLCR)(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
(WINAPI
*pfnLineOpenALCR)(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
(WINAPI
*pfnLineTranslateAddressWLCR)(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

LONG EnsureOneLocation (HWND hwnd);

extern BOOL     gbTranslateSimple;
extern BOOL     gbTranslateSilent;

HINSTANCE  g_hInst;

PASYNC_EVENTS_THREAD_PARAMS gpAsyncEventsThreadParams = NULL;

#if DBG
const TCHAR   gszTapi32DebugLevel[] = TEXT("Tapi32DebugLevel");
#endif
const TCHAR   gszTapi32MaxNumRequestRetries[] = TEXT("Tapi32MaxNumRequestRetries");
const TCHAR   gszTapi32RequestRetryTimeout[] =  TEXT("Tapi32RequestRetryTimeout");
extern TCHAR gszTelephonyKey[];

DWORD   gdwMaxNumRequestRetries;
DWORD   gdwRequestRetryTimeout;

const TCHAR    szTapi32WndClass[]    = TEXT("Tapi32WndClass");

// These all get passed to GetProcAddress so they stay as ANSI
const CHAR  gszTUISPI_providerConfig[]        = "TUISPI_providerConfig";
const CHAR  gszTUISPI_providerGenericDialog[] = "TUISPI_providerGenericDialog";
const CHAR  gszTUISPI_providerGenericDialogData[] = "TUISPI_providerGenericDialogData";
const CHAR  gszTUISPI_providerInstall[]       = "TUISPI_providerInstall";
const CHAR  gszTUISPI_providerRemove[]        = "TUISPI_providerRemove";
const CHAR  gszTUISPI_lineConfigDialog[]      = "TUISPI_lineConfigDialog";
const CHAR  gszTUISPI_lineConfigDialogEdit[]  = "TUISPI_lineConfigDialogEdit";
const CHAR  gszTUISPI_phoneConfigDialog[]     = "TUISPI_phoneConfigDialog";

extern TCHAR  gszLocations[];

HANDLE      ghHandleTable;

HINSTANCE   ghWow32Dll = NULL;
FARPROC     gpfnWOWGetVDMPointer = NULL;

static FARPROC  gpPostQueuedCompletionStatus = NULL;

PUITHREADDATA   gpUIThreadInstances = NULL;

CRITICAL_SECTION        gCriticalSection;
CRITICAL_SECTION        gUICriticalSection;
PCONTEXT_HANDLE_TYPE    gphCx = (PCONTEXT_HANDLE_TYPE) NULL;

LIST_ENTRY              gTlsListHead;
CRITICAL_SECTION        gTlsCriticalSection;

#if DBG
// All the debug only stuff stays as ANSI (just because it was easier than chagning it).
const char *aszMsgs[] =
{
    "LINE_ADDRESSSTATE",
    "LINE_CALLINFO",
    "LINE_CALLSTATE",
    "LINE_CLOSE",
    "LINE_DEVSPECIFIC",
    "LINE_DEVSPECIFICFEATURE",
    "LINE_GATHERDIGITS",
    "LINE_GENERATE",
    "LINE_LINEDEVSTATE",
    "LINE_MONITORDIGITS",
    "LINE_MONITORMEDIA",
    "LINE_MONITORTONE",
    "LINE_REPLY",
    "LINE_REQUEST",
    "PHONE_BUTTON",
    "PHONE_CLOSE",
    "PHONE_DEVSPECIFIC",
    "PHONE_REPLY",
    "PHONE_STATE",
    "LINE_CREATE",
    "PHONE_CREATE",
    "LINE_AGENTSPECIFIC",
    "LINE_AGENTSTATUS",
    "LINE_APPNEWCALL",
    "LINE_PROXYREQUEST",
    "LINE_REMOVE",
    "PHONE_REMOVE"
};
#endif

LONG gaNoMemErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_NOMEM,
    PHONEERR_NOMEM
};

LONG gaInvalHwndErrors[3] =
{
    TAPIERR_INVALWINDOWHANDLE,
    LINEERR_INVALPARAM,
    PHONEERR_INVALPARAM
};

LONG gaInvalPtrErrors[3] =
{
    TAPIERR_INVALPOINTER,
    LINEERR_INVALPOINTER,
    PHONEERR_INVALPOINTER
};

LONG gaOpFailedErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_OPERATIONFAILED,
    PHONEERR_OPERATIONFAILED
};

LONG gaStructTooSmallErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_STRUCTURETOOSMALL,
    PHONEERR_STRUCTURETOOSMALL
};

LONG gaServiceNotRunningErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_SERVICE_NOT_RUNNING,
    PHONEERR_SERVICE_NOT_RUNNING
};

#define AllInitExOptions2_0                           \
        (LINEINITIALIZEEXOPTION_USEHIDDENWINDOW     | \
        LINEINITIALIZEEXOPTION_USEEVENT             | \
        LINEINITIALIZEEXOPTION_USECOMPLETIONPORT)


//
// Function prototypes
//

void
PASCAL
lineMakeCallPostProcess(
    PASYNCEVENTMSG  pMsg
    );

LONG
WINAPI
AllocClientResources(
    DWORD   dwErrorClass
    );

LONG
WINAPI
ReAllocClientResources(
    DWORD dwErrorClass
    );

BOOL
WINAPI
_CRT_INIT(
    HINSTANCE   hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    );

LONG
CreateHiddenWindow(
    HWND   *lphwnd,
    DWORD   dwErrorClass
    );

void
FreeInitData(
    PINIT_DATA  pInitData
    );

LONG
WINAPI
FreeClientResources(
    void
    );

LONG
CALLBACK
TUISPIDLLCallback(
    DWORD   dwObjectID,
    DWORD   dwObjectType,
    LPVOID  lpParams,
    DWORD   dwSize
    );

BOOL
CALLBACK
TranslateDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

void
UIThread(
    LPVOID  pParams
    );

char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );

void
PASCAL
lineDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    );

BOOL 
WaveStringIdToDeviceId(
    LPWSTR  pwszStringID,
    LPCWSTR  pwszDeviceType,
    LPDWORD pdwDeviceId
    );

LONG
PASCAL
xxxShutdown(
    HLINEAPP    hXXXApp,
    BOOL        bLineShutdown
    );

LONG
PASCAL
xxxGetMessage(
    BOOL            bLine,
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   pMsg,
    DWORD           dwTimeout
    );
    
void
PASCAL
lineGetAgentActivityListAPostProcess(
    PASYNCEVENTMSG pMsg
    );

void
PASCAL
lineCompleteCallPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGatherDigitsPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGatherDigitsWPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetAgentCapsAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetAgentGroupListAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetQueueListAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineGetAgentStatusAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineParkAPostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
lineSetupConferencePostProcess(
    PASYNCEVENTMSG  pMsg
    );

void
PASCAL
phoneDevSpecificPostProcess(
    PASYNCEVENTMSG  pMsg
    );


POSTPROCESSPROC gPostProcessingFunctions[] = 
{
    NULL,
    lineGetAgentActivityListAPostProcess,
    lineCompleteCallPostProcess,
    lineDevSpecificPostProcess,
    lineGatherDigitsPostProcess,
    lineGatherDigitsWPostProcess,
    lineGetAgentCapsAPostProcess,
    lineGetAgentGroupListAPostProcess,
    lineGetAgentStatusAPostProcess,
    lineGetQueueListAPostProcess,
    lineMakeCallPostProcess,
    lineParkAPostProcess,
    lineSetupConferencePostProcess,
    phoneDevSpecificPostProcess
};


//
// The code...
//

/////////////////////////////////////
//
//  GetFunctionIndex
// 
//  find the array index of the function. 
//
//  returns 0 if the function was not found in the array
//

DWORD GetFunctionIndex(POSTPROCESSPROC Function)
{

    int i;
    const int nArraySize = 
        sizeof(gPostProcessingFunctions)/sizeof(POSTPROCESSPROC);


    for (i = 0; i < nArraySize; i++)
    {

        if (Function == gPostProcessingFunctions[i])
        {

            break;
        }
    }



    //
    // the function that is passed in had better be in the array. if not -- this should be caught in testing!
    //
#if DBG
    if (0 == i)
    {
        DebugBreak ();
    }
#endif

    if (i == nArraySize)
    {

        LOG((TL_ERROR,
            "GetFunctionIndex: function %p is not found in the array of functions!",
            Function));

        i = 0;
    }


    LOG((TL_ERROR, 
        "GetFunctionIndex: function %p mapped to index %d.", Function, i));

    return i;

}



PWSTR
PASCAL
NotSoWideStringToWideString(
    LPCSTR  lpStr,
    DWORD   dwLength
    )
{
    DWORD dwSize;
    PWSTR pwStr;


    if (IsBadStringPtrA (lpStr, dwLength))
    {
        return NULL;
    }

    dwSize = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpStr,
        dwLength,
        NULL,
        0
        );

    pwStr = ClientAlloc( dwSize * sizeof(WCHAR) );

    if (NULL != pwStr)
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpStr,
            dwLength,
            pwStr,
            dwSize
            );
    }

    return pwStr;
}


//
//NOTE: This function requires that lpBase is a pointer to the start of
//      a TAPI struct that has dwTotalSize as the first DWORD
//
void
PASCAL
WideStringToNotSoWideString(
    LPBYTE  lpBase,
    LPDWORD lpdwXxxSize
    )
{
    DWORD  dwSize;
    DWORD  dwNewSize;
    DWORD  dwOffset;
    DWORD  dwTotalSize;
    DWORD  dwUsedSize;
    PWSTR  pString;
    char   szStackBuf[64];
    PSTR   lpszStringA;


    if ((dwSize = *lpdwXxxSize) != 0)
    {
        dwTotalSize = *((LPDWORD) lpBase);

        dwUsedSize = *(((LPDWORD) lpBase)+2);

        dwOffset = *(lpdwXxxSize + 1);

        pString = (PWSTR)(lpBase + dwOffset);


        if (TAPIIsBadStringPtrW (pString, dwSize))
        {
           LOG((TL_ERROR,
               "The service provider returned an invalid field " \
               "in the structure 0x%p : 0x%p",
               lpBase,
               lpdwXxxSize
               ));

           *lpdwXxxSize     = 0;
           *(lpdwXxxSize+1) = 0;

           return;
        }


        //
        // Did we get enough chars?
        //

        if (dwUsedSize > dwOffset )
        {
            dwNewSize = WideCharToMultiByte(
                GetACP(),
                0,
                pString,
                ( dwUsedSize >= (dwOffset+dwSize)) ?
                    (dwSize/sizeof(WCHAR)) :
                    (dwUsedSize - dwOffset) / sizeof(WCHAR),
                NULL,
                0,
                NULL,
                NULL
                );

            lpszStringA = (dwNewSize <= sizeof (szStackBuf) ?
                (PSTR) szStackBuf : ClientAlloc (dwNewSize) );

            if ( NULL == lpszStringA )
            {
               *lpdwXxxSize     = 0;
               *(lpdwXxxSize+1) = 0;

               return;
            }

            WideCharToMultiByte(
                GetACP(),
                0,
                pString,
//                dwSize,
                ( dwUsedSize >= (dwOffset+dwSize)) ?
                    (dwSize/sizeof(WCHAR)) :
                    (dwUsedSize - dwOffset) / sizeof(WCHAR),
                lpszStringA,
                dwNewSize,
                NULL,
                NULL
                );

            //
            // Copy the new ANSI string back to where the Unicode string was
//            // and write out NULL terminator if possible.
            //

            CopyMemory ( (LPBYTE) pString,
                         lpszStringA,
                         dwNewSize  // + (
                                    //  ((dwNewSize + dwOffset) < dwUsedSize ) ?
                                    //  1 :
                                    //  0
                                    // )
                          );

            if (lpszStringA != (PSTR) szStackBuf)
            {
                ClientFree (lpszStringA);
            }


            //
            // Update the number of bytes
            //

            *lpdwXxxSize = dwNewSize;
        }
    }
}


VOID
CALLBACK
FreeContextCallback(
    LPVOID      Context,
    LPVOID      Context2
    )
{
    //ClientFree (Context);
}


BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    static DWORD dwInitFlags;
    const  DWORD dwInitgCriticalSection     = 0x1;
    const  DWORD dwInitgUICriticalSection   = 0x2;
    const  DWORD dwInitgTlsCriticalSection  = 0x4;
    const  DWORD dwInitcsMemoryList         = 0x8;
    const  DWORD dwInitTapiCrypt            = 0x10;
    const  DWORD dwInitFusion               = 0x20;
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        dwInitFlags = 0;

        g_hInst = hDLL;
        InitializeListHead (&gTlsListHead);

        if (!SHFusionInitializeFromModuleID (hDLL,124))
        {
            return FALSE;
        }
        dwInitFlags |= dwInitFusion;

        gdwInitialTickCount = GetTickCount();

        ghHandleTable = CreateHandleTable(
            GetProcessHeap(),
            FreeContextCallback,
            0x80000000,
            0x8fffffff
            );

        if (NULL == ghHandleTable)
        {
            return FALSE;
        }

        //
        // Init CRT
        //

        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            return FALSE;
        }

        {
            HKEY  hKey;


#if DBG
            gdwDebugLevel = 0;
#endif
            gdwMaxNumRequestRetries = 40;
            gdwRequestRetryTimeout = 250; // milliseconds

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszTelephonyKey,
                    0,
                    KEY_READ,
                    &hKey

                    ) == ERROR_SUCCESS)
            {
                DWORD dwDataSize = sizeof(DWORD), dwDataType;

#if DBG
                RegQueryValueEx(
                    hKey,
                    gszTapi32DebugLevel,
                    0,
                    &dwDataType,
                    (LPBYTE) &gdwDebugLevel,
                    &dwDataSize
                    );

                dwDataSize = sizeof(DWORD);
#endif

                RegQueryValueEx(
                    hKey,
                    gszTapi32MaxNumRequestRetries,
                    0,
                    &dwDataType,
                    (LPBYTE) &gdwMaxNumRequestRetries,
                    &dwDataSize
                    );

                RegQueryValueEx(
                    hKey,
                    gszTapi32RequestRetryTimeout,
                    0,
                    &dwDataType,
                    (LPBYTE) &gdwRequestRetryTimeout,
                    &dwDataSize
                    );

                RegCloseKey (hKey);
            }
        }


        //
        // Alloc a Tls index
        //

        if ((gdwTlsIndex = TlsAlloc()) == 0xffffffff ||
            (gdwTlsIndexRpcCtx = TlsAlloc()) == 0xffffffff)
        {
            return FALSE;
        }


        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);
        TlsSetValue (gdwTlsIndexRpcCtx, NULL);


        //
        //
        //

        ghInitMutex = CreateMutex (NULL, FALSE, NULL);

        try
        {
            InitializeCriticalSection (&gCriticalSection);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }
        dwInitFlags |= dwInitgCriticalSection;

        try
        {
            InitializeCriticalSection (&gUICriticalSection);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }
        dwInitFlags |= dwInitgUICriticalSection;

        try
        {
            InitializeCriticalSection (&gTlsCriticalSection);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }
        dwInitFlags |= dwInitgTlsCriticalSection;
#if DBG
        try
        {
            InitializeCriticalSection( &csMemoryList);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }
        dwInitFlags |= dwInitcsMemoryList;
#endif

        ListNodePoolsInitialize();

        if (ERROR_SUCCESS != TapiCryptInit())
        {
            return FALSE;
        }
        dwInitFlags |= dwInitTapiCrypt;
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        PCLIENT_THREAD_INFO pTls;

        //
        // Clean up any Tls (no need to enter crit sec since process detaching)
        //

        while (!IsListEmpty (&gTlsListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList (&gTlsListHead);

            pTls = CONTAINING_RECORD (pEntry, CLIENT_THREAD_INFO, TlsList);

            ClientFree (pTls->pBuf);
            ClientFree (pTls);
        }

        //
        // If gpAsyncEventsThreadParams is non-NULL it means the AsyncEventsThread 
        // is still running (an ill-behaved app is trying to unload us
        // without calling shutdown) so go thru the motions of getting
        // the thread to terminate (like we do in xxxShutdown)
        //
        // Otherwise close our handle to the shared event
        //

        if (gpAsyncEventsThreadParams)
        {
            gpAsyncEventsThreadParams->bExitThread = TRUE;
            SetEvent (ghAsyncEventsEvent);
            gpAsyncEventsThreadParams = NULL;
            gdwNumInits = 0;

        }
        else if (gphCx && ghAsyncEventsEvent)
        {
            CloseHandle (ghAsyncEventsEvent);
            ghAsyncEventsEvent = NULL;
        }

        //
        // Free up any other resources we were using
        //

        if (ghWow32Dll)
        {
            FreeLibrary (ghWow32Dll);
            ghWow32Dll = NULL;
        }

        TlsFree (gdwTlsIndex);
        TlsFree (gdwTlsIndexRpcCtx);

        _CRT_INIT (hDLL, dwReason, lpReserved);

        if (ghInitMutex) CloseHandle (ghInitMutex);

        if (dwInitFlags & dwInitgCriticalSection)
            DeleteCriticalSection (&gCriticalSection);

        if (dwInitFlags & dwInitgUICriticalSection)
            DeleteCriticalSection (&gUICriticalSection);

        if (dwInitFlags & dwInitgTlsCriticalSection)
            DeleteCriticalSection (&gTlsCriticalSection);
#if DBG
        DumpMemoryList();
        if (dwInitFlags & dwInitcsMemoryList)
            DeleteCriticalSection( &csMemoryList);
#endif
        if (dwInitFlags & dwInitTapiCrypt)
            TapiCryptShutdown();

        ListNodePoolsUninitialize();

        DeleteHandleTable (ghHandleTable);

        if (dwInitFlags & dwInitFusion)
            SHFusionUninitialize();

        break;
    }
    case DLL_THREAD_ATTACH:

        //
        // First must init CRT
        //

        if (!_CRT_INIT (hDLL, dwReason, lpReserved))
        {
            return FALSE;
        }

        //
        // Initialize Tls to NULL for this thread
        //

        TlsSetValue (gdwTlsIndex, NULL);

        break;

    case DLL_THREAD_DETACH:
    {
        PCLIENT_THREAD_INFO pTls;


        //
        // Clean up any Tls
        //

        if ((pTls = (PCLIENT_THREAD_INFO) TlsGetValue (gdwTlsIndex)))
        {
            EnterCriticalSection (&gTlsCriticalSection);

            RemoveEntryList (&pTls->TlsList);

            LeaveCriticalSection (&gTlsCriticalSection);

            if (pTls->pBuf)
            {
                ClientFree (pTls->pBuf);
            }

            ClientFree (pTls);
        }


        //
        // Finally, alert CRT
        //

        _CRT_INIT (hDLL, dwReason, lpReserved);

        break;
    }

    } // switch

    return TRUE;
}


BOOL
IsLeastCostRoutingEnabled(
    void
    )
{
    static BOOL bInited = FALSE, bEnabled = FALSE;

    HKEY    hKey;
    TCHAR   szPath[MAX_PATH];
    DWORD   dwDataSize, dwDataType;
    HANDLE  hDll;


    if (!bInited)
    {
        //
        // Check the registry to see if there's an LCR DLL registered
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszTelephonyKey,
                0,
                KEY_QUERY_VALUE,
                &hKey

                ) == ERROR_SUCCESS)
        {
            dwDataSize = sizeof (szPath);
            szPath[0] = 0;

            if (RegQueryValueEx(
                    hKey,
                    gszLCRDLL,
                    0,
                    &dwDataType,
                    (LPBYTE) szPath,
                    &dwDataSize

                    ) == ERROR_SUCCESS)
            {
                //
                // Try to load the LCR DLL.
                //
                // Note that we will never explicitly free the DLL,
                // since there is no well-defined time at which we'd
                // know to free it.  (Apps can can lineTranslateAddress
                // without having done a lineInitialize(Ex), so that
                // could happen at any time between us being loaded
                // & unloaded, and doing Load/FreeLibrary from within
                // a DLLEntryPoint is not a good idea)
                //

                if ((hDll = LoadLibrary (szPath)))
                {
                    //
                    // Get the hook addresses & increment our own ref
                    // count (via LoadLibrary) so we'll never get
                    // unloaded (since we never unload the LCR DLL
                    // it might call back in to us at any time, & if
                    // an app unloaded us that would be a problem)
                    //

                    if (hDll)
                    {
                        (FARPROC) pfnLineOpenWLCR =  GetProcAddress(
                            hDll,
                            "lineOpenW"
                            );

                        (FARPROC) pfnLineOpenALCR =  GetProcAddress(
                            hDll,
                            "lineOpenA"
                            );

                        (FARPROC) pfnLineTranslateAddressWLCR = GetProcAddress(
                            hDll,
                            "lineTranslateAddressW"
                            );

                        if (pfnLineOpenWLCR ||
                            pfnLineOpenALCR ||
                            pfnLineTranslateAddressWLCR)
                        {
                            LoadLibrary (TEXT("tapi32"));

                            bEnabled = TRUE;
                        }
                    }
                }
                else
                {
                    LOG((TL_ERROR,
                        "IsLeastCostRoutingEnabled: LoadLibrary() " \
                            "failed, err=%d",
                        GetLastError()
                        ));
                }
            }

            RegCloseKey (hKey);
        }

        bInited = TRUE;
    }

    return bEnabled;
}


void
AsyncEventsThread(
    PASYNC_EVENTS_THREAD_PARAMS pAsyncEventsThreadParams
    );


void NonAsyncEventThread( void )
{
   if ( gpAsyncEventsThreadParams )
       AsyncEventsThread( (LPVOID) gpAsyncEventsThreadParams );
}


void
AsyncEventsThread(
    PASYNC_EVENTS_THREAD_PARAMS pAsyncEventsThreadParams
    )
{
    BOOL           *pbExitThread = &pAsyncEventsThreadParams->bExitThread,
                    bRetry;
    DWORD           dwBufSize    = pAsyncEventsThreadParams->dwBufSize;
    LPBYTE          pBuf         = pAsyncEventsThreadParams->pBuf;
    PTAPI32_MSG     pMsg         = (PTAPI32_MSG) pBuf;


    LOG((TL_TRACE, "AsyncEventsThread: enter"));


    //
    // Just loop reading async events/completions from server &
    // handling them
    //

    while (1)
    {
        DWORD           dwUsedSize, dwNeededSize;
        ASYNC_EVENT_PARAMS AsyncEventParams;
        PASYNCEVENTMSG  pAsyncEventMsg;
        HANDLE          hAsyncEvents = NULL;
        HANDLE          hProcess = GetCurrentProcess();

        //
        // Check to see if xxxShutdown or DllMain
        // is signaling us to exit 
        // Also we need to deal with an event setting/resetting
        // race condition between FreeClientResources & Tapisrv)
        //

        EnterCriticalSection (&gCriticalSection);

        if (*pbExitThread)
        {
            LeaveCriticalSection (&gCriticalSection);

            break;
        }

        LeaveCriticalSection (&gCriticalSection);

        // Acquire ghInitMutex to serialize with FreeClientResources and ReallocClientResources
        WaitForSingleObject (ghInitMutex, INFINITE);

        if (*pbExitThread)
        {
            ReleaseMutex (ghInitMutex);
            break;
        }

        // if here, ghAsyncEventsEvent should not be NULL
        if (!DuplicateHandle (
                hProcess,
                ghAsyncEventsEvent,
                hProcess,
                &hAsyncEvents,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                ))
        {
            LOG((TL_ERROR,  "DuplicateHandle failed with 0x%x", GetLastError()));
        }

        ReleaseMutex (ghInitMutex);        

        //
        // Block until tapisrv signals us that it has some event data for us
        //
        if (hAsyncEvents)
        {
            WaitForSingleObject (hAsyncEvents, INFINITE);
            CloseHandle (hAsyncEvents);
        }

        //
        // Check to see if xxxShutdown or DllMain
        // is signaling us to exit
        //

        if (*pbExitThread)
        {
            break;
        }


        //
        // Retrieve the data from tapisrv
        //

AsyncEventsThread_clientRequest:

        do
        {
            pMsg->u.Req_Func     = xGetAsyncEvents;
            pMsg->Params[0]      = dwBufSize - sizeof (TAPI32_MSG);

            dwUsedSize = sizeof (TAPI32_MSG);

            // Acquire ghInitMutex to serialize with FreeClientResources so we prevent 
            // the RPC Context handle from being destroyed while the request is in progress
            WaitForSingleObject (ghInitMutex, INFINITE);

            RpcTryExcept
            {
                ClientRequest (gphCx, (char *) pMsg, dwBufSize, &dwUsedSize);
                bRetry = FALSE;
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                bRetry = !(*pbExitThread);
                LOG((TL_INFO,
                    "AsyncEventsThread: rpc exception %d handled",
                    RpcExceptionCode()
                    ));
                Sleep (10);
            }
            RpcEndExcept

            ReleaseMutex (ghInitMutex);

        } while (bRetry);

#if DBG
        if (
              ( dwUsedSize > dwBufSize )
            ||
              ( pMsg->Params[2] > dwBufSize )
           )
        {
            LOG((TL_ERROR,  "OVERFLOW!!!"));

            LOG((TL_ERROR,  "Watch this..."));
            ClientFree( ClientAlloc( 0x10000 ) );
        }
#endif

        if ((dwUsedSize = (DWORD) pMsg->Params[2]) == 0 &&
            (dwNeededSize = (DWORD) pMsg->Params[1]) != 0)
        {
            //
            // There's a msg waiting for us that is bigger than our buffer,
            // so alloc a larger buffer & try again
            //

            LPBYTE  pNewBuf;


            LOG((TL_INFO,
                "AsyncEventsThread: allocating larger event buf (size=x%x)",
                dwNeededSize
                ));

            dwNeededSize += sizeof (TAPI32_MSG) + 128;

            if (!(pNewBuf = ClientAlloc (dwNeededSize)))
            {
                goto AsyncEventsThread_clientRequest;
            }

            dwBufSize = dwNeededSize;
            ClientFree (pBuf);
            pBuf = pNewBuf;
            pMsg = (PTAPI32_MSG) pBuf;
            goto AsyncEventsThread_clientRequest;
        }


        //
        // Handle the events
        //

        pAsyncEventMsg = (PASYNCEVENTMSG) (pBuf + sizeof (TAPI32_MSG));

        while (dwUsedSize)
        {
            PINIT_DATA  pInitData = (PINIT_DATA)ReferenceObject (ghHandleTable, pAsyncEventMsg->InitContext, INITDATA_KEY);

            if (NULL == pInitData)
            {
                // There is something very wrong with this
                // message. Skip to the next one.
                goto AsyncEventsThread_nextMessage;
            }

#ifdef _WIN64
            // For win64 we need to convert DWORDs to ULONG_PTRs (64 bit values)
            AsyncEventParams.hDevice            = pAsyncEventMsg->hDevice;
            AsyncEventParams.dwMsg              = pAsyncEventMsg->Msg;
            AsyncEventParams.dwCallbackInstance = pAsyncEventMsg->OpenContext;
            AsyncEventParams.dwParam1           = pAsyncEventMsg->Param1;
            AsyncEventParams.dwParam2           = pAsyncEventMsg->Param2;
            AsyncEventParams.dwParam3           = pAsyncEventMsg->Param3;
#else // not _WIN64
            CopyMemory (&AsyncEventParams.hDevice,
                        &pAsyncEventMsg->hDevice,
                        sizeof (ASYNC_EVENT_PARAMS));
#endif // _WIN64

            switch (pAsyncEventMsg->Msg)
            {
                case LINE_REMOVE:
                case PHONE_REMOVE:
                case LINE_CREATE:
                case LINE_REQUEST:
                case PHONE_CREATE:
                    // For all messages EXCEPT these, pAsyncEventMsg is a handle
                    // to the callbackInstance value passed in line/phoneOpen.
                    // For these messages, do nothing!
                    break;

                default:
                    // We need to get the CallbackInstance value back.
                    if (0 != pAsyncEventMsg->OpenContext)
                    {
                        AsyncEventParams.dwCallbackInstance = (ULONG_PTR)
                            ReferenceObject (ghHandleTable, pAsyncEventMsg->OpenContext, 0);
                        DereferenceObject (ghHandleTable, pAsyncEventMsg->OpenContext, 1);
                        if (LINE_CLOSE == pAsyncEventMsg->Msg ||
                            PHONE_CLOSE ==  pAsyncEventMsg->Msg)
                        {
                            // for these messages, we need to get rid of
                            // the handle to the callback instance, so
                            // dereference it once more.
                            DereferenceObject (ghHandleTable, pAsyncEventMsg->OpenContext, 1);
                        }
                    }

            }

            LOG((TL_INFO,
                "AsyncEventsThread: msg=%d, hDev=x%x, p1=x%x, p2=x%x, p3=x%x",
                AsyncEventParams.dwMsg,
                AsyncEventParams.hDevice,
                AsyncEventParams.dwParam1,
                AsyncEventParams.dwParam2,
                AsyncEventParams.dwParam3
                ));

            //
            // Special case for UI msgs (not fwd'd to client)
            //

            switch (pAsyncEventMsg->Msg)
            {
            case LINE_CREATEDIALOGINSTANCE:
            {
                DWORD           dwThreadID,
                                dwDataOffset = pAsyncEventMsg->Param1,
                                dwDataSize   = pAsyncEventMsg->Param2,
                                dwUIDllNameOffset = pAsyncEventMsg->Param3;
                PUITHREADDATA   pUIThreadData;


                if (!(pUIThreadData = ClientAlloc (sizeof (UITHREADDATA))))
                {
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if ((pUIThreadData->dwSize = dwDataSize) != 0)
                {
                    if (!(pUIThreadData->pParams = ClientAlloc (dwDataSize)))
                    {
                        goto LINE_CREATEDIALOGINSTANCE_error;
                    }

                    CopyMemory(
                        pUIThreadData->pParams,
                        ((LPBYTE)pAsyncEventMsg) + dwDataOffset,
                        dwDataSize
                        );
                }

                if (!(pUIThreadData->hUIDll = TAPILoadLibraryW(
                        (PWSTR)(((LPBYTE) pAsyncEventMsg) +
                                  dwUIDllNameOffset)
                        )))
                {
                    LOG((TL_ERROR,
                        "LoadLibraryW(%ls) failed, err=%d",
                        ((LPBYTE)pAsyncEventMsg + dwUIDllNameOffset),
                        GetLastError()
                        ));

                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if (!(pUIThreadData->pfnTUISPI_providerGenericDialog =
                        (TUISPIPROC) GetProcAddress(
                            pUIThreadData->hUIDll,
                            (LPCSTR) gszTUISPI_providerGenericDialog
                            )))
                {
                    LOG((TL_ERROR,
                        "GetProcAddr(TUISPI_providerGenericDialog) failed"
                        ));

                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                pUIThreadData->pfnTUISPI_providerGenericDialogData =
                    (TUISPIPROC) GetProcAddress(
                        pUIThreadData->hUIDll,
                        (LPCSTR) gszTUISPI_providerGenericDialogData
                        );

                if (!(pUIThreadData->hEvent = CreateEvent(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        TRUE,   // manual reset
                        FALSE,  // non-signaled
                        NULL    // unnamed
                        )))
                {
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                pUIThreadData->htDlgInst = (HTAPIDIALOGINSTANCE)
                    pAsyncEventMsg->hDevice;


                //
                // Safely add this instance to the global list
                // (check if gdwNumInits == 0, & if so fail)
                //

                EnterCriticalSection (&gCriticalSection);

                if (gdwNumInits != 0)
                {
                    if ((pUIThreadData->pNext = gpUIThreadInstances))
                    {
                        pUIThreadData->pNext->pPrev = pUIThreadData;
                    }

                    gpUIThreadInstances  = pUIThreadData;
                    LeaveCriticalSection (&gCriticalSection);
                }
                else
                {
                    LeaveCriticalSection (&gCriticalSection);
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if ((pUIThreadData->hThread = CreateThread(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) UIThread,
                        (LPVOID) pUIThreadData,
                        0,
                        &dwThreadID
                        )))
                {
                    goto AsyncEventsThread_decrUsedSize;
                }


                //
                // If here an error occured, so safely remove the ui
                // thread data struct from the global list
                //

                EnterCriticalSection (&gCriticalSection);

                if (pUIThreadData->pNext)
                {
                    pUIThreadData->pNext->pPrev = pUIThreadData->pPrev;
                }

                if (pUIThreadData->pPrev)
                {
                    pUIThreadData->pPrev->pNext = pUIThreadData->pNext;
                }
                else
                {
                    gpUIThreadInstances = pUIThreadData->pNext;
                }

                LeaveCriticalSection (&gCriticalSection);


LINE_CREATEDIALOGINSTANCE_error:

                if (pUIThreadData)
                {
                    if (pUIThreadData->pParams)
                    {
                        ClientFree (pUIThreadData->pParams);
                    }

                    if (pUIThreadData->hUIDll)
                    {
                        FreeLibrary (pUIThreadData->hUIDll);
                    }

                    if (pUIThreadData->hEvent)
                    {
                        CloseHandle (pUIThreadData->hEvent);
                    }

                    ClientFree (pUIThreadData);
                }

                {
                    FUNC_ARGS funcArgs =
                    {
                        MAKELONG (LINE_FUNC | SYNC | 1, xFreeDialogInstance),

                        {
                            (DWORD) pAsyncEventMsg->hDevice
                        },

                        {
                            Dword
                        }
                    };


                    DOFUNC (&funcArgs, "FreeDialogInstance");
                }

                goto AsyncEventsThread_decrUsedSize;
            }
            case LINE_SENDDIALOGINSTANCEDATA:
            {
                PUITHREADDATA       pUIThreadData = gpUIThreadInstances;
                HTAPIDIALOGINSTANCE htDlgInst = (HTAPIDIALOGINSTANCE)
                                        pAsyncEventMsg->hDevice;


                EnterCriticalSection (&gCriticalSection);

                while (pUIThreadData)
                {
                    if (pUIThreadData->htDlgInst == htDlgInst)
                    {
                        WaitForSingleObject (pUIThreadData->hEvent, INFINITE);

                        (*pUIThreadData->pfnTUISPI_providerGenericDialogData)(
                            htDlgInst,
                            ((LPBYTE) pAsyncEventMsg) +
                                pAsyncEventMsg->Param1,     // data offset
                            pAsyncEventMsg->Param2          // data size
                            );

                        break;
                    }

                    pUIThreadData = pUIThreadData->pNext;
                }

                LeaveCriticalSection (&gCriticalSection);

                goto AsyncEventsThread_decrUsedSize;
            }
            }

            //
            // Enter the critical section so we've exclusive access
            // to the init data, & verify it
            //

            EnterCriticalSection (&gCriticalSection);

            try
            {
#if defined(_M_IX86) && _MSC_FULL_VER <= 13008806

                  DWORD dw= pInitData->dwKey;        // workaround compiler bug.

                  if (dw != INITDATA_KEY)

#else
                if (pInitData->dwKey != INITDATA_KEY)
#endif
                {
                    LOG((TL_ERROR, "Bad pInitInst, discarding msg"));
                    goto AsyncEventsThread_leaveCritSec;
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                goto AsyncEventsThread_leaveCritSec;
            }


            //
            // Special case for PROXYREQUEST
            //

            if (pAsyncEventMsg->Msg == LINE_PROXYREQUEST)
            {
                PPROXYREQUESTHEADER     pProxyRequestHeader;
                LPLINEPROXYREQUEST      pProxyRequest = (LPLINEPROXYREQUEST)
                                            (pAsyncEventMsg + 1),
                                        pProxyRequestApp;


                switch (pProxyRequest->dwRequestType)
                {
                    case LINEPROXYREQUEST_SETAGENTGROUP:
                    case LINEPROXYREQUEST_SETAGENTSTATE:
                    case LINEPROXYREQUEST_SETAGENTACTIVITY:
                    case LINEPROXYREQUEST_AGENTSPECIFIC:
                    case LINEPROXYREQUEST_CREATEAGENT:
                    case LINEPROXYREQUEST_CREATEAGENTSESSION:
                    case LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD:
                    case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
                    case LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD:
                    case LINEPROXYREQUEST_SETAGENTSTATEEX:

                        //
                        // For these msgs the proxy request as received from
                        // the tapisrv already contains the exact bits we want
                        // to pass on to the app, so we just alloc a buffer of
                        // the same size (plus a little extra for the key at
                        // the head of the buffer) and copy the data to it
                        //

                        if (!(pProxyRequestHeader = ClientAlloc(
                                sizeof (PROXYREQUESTHEADER) + pProxyRequest->dwSize
                                )))
                        {
                            // Could not allocate memory;
                            // skip this...
                            goto AsyncEventsThread_leaveCritSec;
                        }

                        pProxyRequestApp = (LPLINEPROXYREQUEST)
                            (pProxyRequestHeader + 1);

                        CopyMemory(
                            pProxyRequestApp,
                            pProxyRequest,
                            pProxyRequest->dwSize
                            );

                        break;

                    case LINEPROXYREQUEST_GETAGENTCAPS:
                    case LINEPROXYREQUEST_GETAGENTSTATUS:
                    case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
                    case LINEPROXYREQUEST_GETAGENTGROUPLIST:
                    case LINEPROXYREQUEST_GETQUEUEINFO:
                    case LINEPROXYREQUEST_GETGROUPLIST:
                    case LINEPROXYREQUEST_GETQUEUELIST:
                    case LINEPROXYREQUEST_GETAGENTINFO:
                    case LINEPROXYREQUEST_GETAGENTSESSIONINFO:
                    case LINEPROXYREQUEST_GETAGENTSESSIONLIST:
                    {
                        DWORD dwSizeToCopy = 0;

                        //
                        // For these msgs tapisrv only embedded the dwTotalSize
                        // field of the corresponding structure (to save having
                        // to send us a bunch of unused bits), so we want to
                        // increase the pProxyRequest->dwSize by the dwTotalSize
                        // - sizeof (DWORD), alloc a buffer (including a little
                        // extra space for the key at the head of the buffer),
                        // and rebuild the request
                        //

                        if ( pProxyRequest->dwRequestType ==
                             LINEPROXYREQUEST_GETGROUPLIST )
                        {
                            pProxyRequest->dwSize +=
                                  (pProxyRequest->GetGroupList.GroupList.dwTotalSize)&TALIGN_MASK;

                            dwSizeToCopy = 8 * sizeof(DWORD);
                        }
                        else if ( pProxyRequest->dwRequestType ==
                             LINEPROXYREQUEST_GETQUEUELIST )
                        {
                            pProxyRequest->dwSize +=
                                  (pProxyRequest->GetQueueList.QueueList.dwTotalSize)&TALIGN_MASK;

                            dwSizeToCopy = 8 * sizeof(DWORD) + sizeof(GUID);
                        }
                        else
                        {
                            //
                            // all of the rest of the structures have the
                            // same format
                            //
                            pProxyRequest->dwSize +=
                                  (pProxyRequest->GetAgentCaps.AgentCaps.dwTotalSize)&TALIGN_MASK;

                            dwSizeToCopy = 9 * sizeof(DWORD);
                        }

                        if (!(pProxyRequestHeader = ClientAlloc(
                            sizeof (PROXYREQUESTHEADER) + pProxyRequest->dwSize
                            + sizeof(DWORD) + sizeof(DWORD)
                            )))
                        {
                            // Could not allocate memory;
                            // skip this...
                            goto AsyncEventsThread_leaveCritSec;
                        }

                        pProxyRequestApp = (LPLINEPROXYREQUEST)
                            (pProxyRequestHeader + 1);


                        //
                        // The following will copy the non-union fields in the
                        // proxy message, as well as the first two DWORD in the
                        // union (which currently are the dwAddressID and the
                        // dwTotalSize field of the corresponding structure)
                        //

                        CopyMemory(
                            pProxyRequestApp,
                            pProxyRequest,
                            dwSizeToCopy
                            );

                        //
                        // Relocate the machine & user names to the end of the
                        // structure
                        //

                        pProxyRequestApp->dwClientMachineNameOffset =
                            pProxyRequest->dwSize -
                                pProxyRequest->dwClientMachineNameSize;

                        wcscpy(
                            (WCHAR *)(((LPBYTE) pProxyRequestApp) +
                                pProxyRequestApp->dwClientMachineNameOffset),
                            (WCHAR *)(((LPBYTE) pProxyRequest) +
                                pProxyRequest->dwClientMachineNameOffset)
                            );

                        pProxyRequestApp->dwClientUserNameOffset =
                            pProxyRequestApp->dwClientMachineNameOffset -
                                pProxyRequest->dwClientUserNameSize;

                        wcscpy(
                            (WCHAR *)(((LPBYTE) pProxyRequestApp) +
                                pProxyRequestApp->dwClientUserNameOffset),
                            (WCHAR *)(((LPBYTE) pProxyRequest) +
                                pProxyRequest->dwClientUserNameOffset)
                            );

                        break;
                    }
                }

                pProxyRequestHeader->dwKey      = TPROXYREQUESTHEADER_KEY;
                pProxyRequestHeader->dwInstance = pAsyncEventMsg->Param1;

                AsyncEventParams.dwParam1 = (ULONG_PTR) pProxyRequestApp;
            }

            //
            // Call the post processing proc if there is one
            //

            if (pAsyncEventMsg->fnPostProcessProcHandle)
            {

                (*(gPostProcessingFunctions[
                    pAsyncEventMsg->fnPostProcessProcHandle]))(pAsyncEventMsg);
            }


            //
            // If this init instance is using a completion port then
            // alloc msg struct & post the msg to the completion port,
            // then jump down below to exit the critsec, etc
            //

            if ((pInitData->dwInitOptions & 0x3) ==
                    LINEINITIALIZEEXOPTION_USECOMPLETIONPORT)
            {
             LPLINEMESSAGE pMsg;

                if ((pMsg = LocalAlloc (LMEM_FIXED, sizeof(LINEMESSAGE))))
                {
                    CopyMemory (pMsg, &AsyncEventParams, sizeof(LINEMESSAGE));

                    if (gpPostQueuedCompletionStatus &&
                        !gpPostQueuedCompletionStatus(
                            pInitData->hCompletionPort,
                            sizeof (LINEMESSAGE),
                            pInitData->dwCompletionKey,
                            (LPOVERLAPPED) pMsg
                            ))
                    {
                        LocalFree (pMsg);
                        LOG((TL_ERROR,
                            "AsyncEventsThread: PostQueuedCompletionStatus " \
                                "failed, err=%d",
                            GetLastError()
                            ));
                    }
                    else
                    {
                        LOG((TL_INFO,
                            "AsyncEventsThread: posted complPort msg\n",
                                "\thDev=x%x, ctx=x%x, p1=x%x, p2=x%x, p3=x%x",
                            AsyncEventParams.hDevice,
                            AsyncEventParams.dwCallbackInstance,
                            AsyncEventParams.dwParam1,
                            AsyncEventParams.dwParam2,
                            AsyncEventParams.dwParam3
                            ));
                    }
                }

                goto AsyncEventsThread_leaveCritSec;
            }


            //
            // See if we need to increase the msg queue size, and if
            // so alloc a new buf, copy the existing msgs over (careful
            // to preserve order in a wrapped buffer), free the old buf
            // and reset the appropriate fields in the init data struct
            //

            if (pInitData->dwNumTotalEntries ==
                    pInitData->dwNumUsedEntries)
            {
                DWORD               dwNumTotalEntries =
                                        pInitData->dwNumTotalEntries;
                PASYNC_EVENT_PARAMS pNewEventBuffer;


                if ((pNewEventBuffer = ClientAlloc(
                        2 * dwNumTotalEntries * sizeof (ASYNC_EVENT_PARAMS)
                        )))
                {
                    DWORD   dwNumWrappedEntries = (DWORD)
                                (pInitData->pValidEntry -
                                    pInitData->pEventBuffer);


                    CopyMemory(
                        pNewEventBuffer,
                        pInitData->pValidEntry,
                        (dwNumTotalEntries - dwNumWrappedEntries)
                            * sizeof (ASYNC_EVENT_PARAMS)
                        );

                    if (dwNumWrappedEntries)
                    {
                        CopyMemory(
                            pNewEventBuffer +
                                (dwNumTotalEntries - dwNumWrappedEntries),
                            pInitData->pEventBuffer,
                            dwNumWrappedEntries * sizeof (ASYNC_EVENT_PARAMS)
                            );
                    }

                    ClientFree (pInitData->pEventBuffer);

                    pInitData->pEventBuffer =
                    pInitData->pValidEntry  = pNewEventBuffer;
                    pInitData->pFreeEntry   =
                        pNewEventBuffer + dwNumTotalEntries;

                    pInitData->dwNumTotalEntries *= 2;
                }
                else
                {
                    // Could not allocate memory,
                    // skip this message...
                    goto AsyncEventsThread_leaveCritSec;
                }
            }


            //
            // Copy the msg to the hidden window's msg queue,
            // and update that queue's pointers
            //

            CopyMemory(
                pInitData->pFreeEntry,
                &AsyncEventParams,
                sizeof (ASYNC_EVENT_PARAMS)
                );

            pInitData->dwNumUsedEntries++;

            pInitData->pFreeEntry++;

            if (pInitData->pFreeEntry >= (pInitData->pEventBuffer +
                    pInitData->dwNumTotalEntries))
            {
                pInitData->pFreeEntry = pInitData->pEventBuffer;
            }


            //
            // If this init instance is using events for msg notification
            // then see if we need to signal the app that there's an
            // event waiting for it
            //
            // Else, post a msg to the hidden window (if there's not
            // already one outstanding) to alert it that there's some
            // events it needs to pass on to the app's callback
            //

            if ((pInitData->dwInitOptions & 0x3)
                    == LINEINITIALIZEEXOPTION_USEEVENT)
            {
                if (pInitData->dwNumUsedEntries > 0)
                {
                    SetEvent (pInitData->hEvent);
                }
            }
            else // HIDDENWINDOW
            {
                if (pInitData->bPendingAsyncEventMsg == FALSE)
                {
                    LOG((TL_INFO,
                        "AsyncEventsThread: posting msg, hwnd=x%lx",
                        pInitData->hwnd
                        ));

                    PostMessage(
                        pInitData->hwnd,
                        WM_ASYNCEVENT,
                        0,
                        (LPARAM) pInitData
                        );

                    pInitData->bPendingAsyncEventMsg = TRUE;
                }
            }

AsyncEventsThread_leaveCritSec:

            LeaveCriticalSection (&gCriticalSection);

AsyncEventsThread_decrUsedSize:

            DereferenceObject (ghHandleTable, pAsyncEventMsg->InitContext, 1);

AsyncEventsThread_nextMessage:
            dwUsedSize -= (DWORD) pAsyncEventMsg->TotalSize;

            pAsyncEventMsg = (PASYNCEVENTMSG)
                ((LPBYTE) pAsyncEventMsg + pAsyncEventMsg->TotalSize);

            if ( (LONG)dwUsedSize < 0 )
            {
                LOG((TL_ERROR, "dwUsedSize went negative!!!"));
            }
        }
    }

    {
        //
        // Free our resources, and then exit
        //

        HANDLE  hTapi32 = pAsyncEventsThreadParams->hTapi32;


        if (pAsyncEventsThreadParams->hWow32)
        {
            FreeLibrary (pAsyncEventsThreadParams->hWow32);
        }

        ClientFree (pBuf);
        ClientFree (pAsyncEventsThreadParams);

        LOG((TL_TRACE, "AsyncEventsThread: exit"));

        FreeLibraryAndExitThread (hTapi32, 0);
    }
}


BOOL
PASCAL
IsBadDwordPtr(
    LPDWORD p
    )
{
    //
    // Since IsBadWritePtr won't tell us if "p" is not DWORD-aligned (an
    // issue on non-x86 platforms), we use the following to determine
    // if the pointer is good.  Note that DWORD p points at will get
    // overwritten on successful completion of the request anyway, so
    // preserving the original value is not important.
    //

    DWORD dwError;
    BOOL  bRet = FALSE;


    try
    {
        *p = *p + 1;
        *p = *p - 1;
    }
    except ((((dwError = GetExceptionCode()) == EXCEPTION_ACCESS_VIOLATION) ||
             dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        bRet = TRUE;
    }


    return bRet;
}


BOOL
WINAPI
GrowBuf(
    LPBYTE *ppBuf,
    LPDWORD pdwBufSize,
    DWORD   dwCurrValidBytes,
    DWORD   dwBytesToAdd
    )
{
    DWORD   dwCurrBufSize, dwNewBufSize;
    LPBYTE  pNewBuf;


    //
    // Try to get a new buffer big enough to hold everything
    //

    for(
        dwNewBufSize = 2 * (dwCurrBufSize = *pdwBufSize);
        dwNewBufSize < (dwCurrBufSize + dwBytesToAdd);
        dwNewBufSize *= 2
        );

    if (!(pNewBuf = ClientAlloc (dwNewBufSize)))
    {
        return FALSE;
    }


    //
    // Copy the "valid" bytes in the old buf to the new buf,
    // then free the old buf
    //

    CopyMemory (pNewBuf, *ppBuf, dwCurrValidBytes);

    ClientFree (*ppBuf);


    //
    // Reset the pointers to the new buf & buf size
    //

    *ppBuf = pNewBuf;
    *pdwBufSize = dwNewBufSize;

    return TRUE;
}


PCLIENT_THREAD_INFO
WINAPI
GetTls(
    void
    )
{
    PCLIENT_THREAD_INFO pClientThreadInfo;


    if (!(pClientThreadInfo = TlsGetValue (gdwTlsIndex)))
    {
        pClientThreadInfo = (PCLIENT_THREAD_INFO)
            ClientAlloc (sizeof(CLIENT_THREAD_INFO));

        if (!pClientThreadInfo)
        {
            return NULL;
        }

        pClientThreadInfo->pBuf = ClientAlloc (INITIAL_CLIENT_THREAD_BUF_SIZE);

        if (!pClientThreadInfo->pBuf)
        {
            ClientFree (pClientThreadInfo);

            return NULL;
        }

        pClientThreadInfo->dwBufSize = INITIAL_CLIENT_THREAD_BUF_SIZE;

        TlsSetValue (gdwTlsIndex, (LPVOID) pClientThreadInfo);

        EnterCriticalSection (&gTlsCriticalSection);

        InsertHeadList (&gTlsListHead, &pClientThreadInfo->TlsList);

        LeaveCriticalSection (&gTlsCriticalSection);
    }

    return pClientThreadInfo;
}

PCONTEXT_HANDLE_TYPE
WINAPI
GetTlsPCtxHandle(
    void
    )
{
    return TlsGetValue (gdwTlsIndexRpcCtx);
}

BOOL
WINAPI
SetTlsPCtxHandle(
    PCONTEXT_HANDLE_TYPE phCtxHandle
    )
{
    return TlsSetValue(gdwTlsIndexRpcCtx, phCtxHandle);
}

#if DBG

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    )

#else

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    )

#endif
{
    DWORD       dwFuncClassErrorIndex = (pFuncArgs->Flags & 0x00000030) >> 4;
    LONG        lResult;
    BOOL        bCopyOnSuccess = FALSE;
    BOOL        bResAllocated = FALSE;
    DWORD       i, j, dwUsedSize, dwNeededSize;
    ULONG_PTR   value;
    PCONTEXT_HANDLE_TYPE    phCtx;


    PCLIENT_THREAD_INFO pTls;

#if DBG
    LOG((TL_TRACE, "About to call %hs", pszFuncName));
#else
    LOG((TL_TRACE, "DoFunc  -- enter"));
#endif
    //
    // Check to make sure resources allocated
    // (TAPISRV started, pipes opened, etc.)
    //

    if ( (lResult = AllocClientResources (dwFuncClassErrorIndex))
            != TAPI_SUCCESS)
    {
        goto DoFunc_return;
    }

    bResAllocated = TRUE;

    //
    // Get the tls
    //

    if (!(pTls = GetTls()))
    {
        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
        goto DoFunc_return;
    }


    //
    // The first arg of all async msg blocks is a remote request id; set
    // this to zero to indicate that we are a local client (not remotesp)
    //

    if (pFuncArgs->Flags & ASYNC)
    {
        ((PTAPI32_MSG) pTls->pBuf)->Params[0] = 0;
    }


    //
    // Validate all the func args
    //

    dwNeededSize = dwUsedSize = ALIGN(sizeof (TAPI32_MSG));

    for(
        i = 0, j = (pFuncArgs->Flags & ASYNC ? 1 : 0);
        i < (pFuncArgs->Flags & NUM_ARGS_MASK);
        i++, j++
        )
    {
        value = /*((PTAPI32_MSG) pTls->pBuf)->Params[j] =*/ pFuncArgs->Args[i];

        switch (pFuncArgs->ArgTypes[i])
        {
        case Dword:

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__);
            continue;

        case hXxxApp_NULLOK:
        case hXxxApp:
        {
            //
            // Verify that the hXxxApp is a pointer to a valid InitData
            // struct, then retrieve the real hXxxApp from that struct.
            // If the hXxxApp is bad, pass the server 0xffffffff so that
            // it can figure out whether to return an UNINITIALIZED error
            // or a INVALAPPHANDLE error.
            //

            DWORD       dwError;
            PINIT_DATA  pInitData;


            if ((0 == pFuncArgs->Args[i])   &&
                (hXxxApp_NULLOK == pFuncArgs->ArgTypes[i]))
            {
                //
                // Looks good to me...
                //
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0;
                continue;
            }

            if ((pInitData = (PINIT_DATA) ReferenceObject(
                    ghHandleTable,
                    DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__),
                    INITDATA_KEY
                    )))
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pInitData->hXxxApp;

                DereferenceObject (ghHandleTable, DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__), 1);
            }
            else
            {
                //
                // Fill in with a bogus hXxxApp so tapisrv can decide which
                // error it wants to return
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0xffffffff;
            }

            continue;
        }

        case Hwnd:

            if (!IsWindow ((HWND) value))
            {
                LOG((TL_ERROR, "Bad hWnd in dofunc"));
                lResult = gaInvalHwndErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            // The only functions that pass in Hwnd are
            // tapiRequestDrop and tapiRequestMediaCall;
            // both of these are non functional on the server side
            // (correctly noted by the documentation). Parameters
            // are not checked. Simply passing in 0 for the Hwnd will
            // not affect functionality in any way, and will save a lot
            // of grief coming from the 32 / 64 bit conversions (hwnd are
            // 64 bits on 64 bit system, and the params we're using over
            // the wire are only 32 bits).
            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0;
            continue;


        case lpDword:

            if (IsBadDwordPtr ((LPDWORD) value))
            {
                LOG((TL_ERROR, "Bad lpdword in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            bCopyOnSuccess = TRUE;

            continue;


        case lpszW:

            //
            // Check if value is a valid string ptr and if so
            // copy the contents of the string to the extra data
            // buffer passed to the server
            //

            try
            {
                DWORD   n = (lstrlenW((WCHAR *) value) + 1) * sizeof(WCHAR),
                        nAligned = ALIGN(n);


                if ((nAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            nAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto DoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, n);


                //
                // Pass the server the offset of the string in the var data
                // portion of the buffer
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);


                //
                // Increment the total number of data bytes
                //

                dwUsedSize   += nAligned;
                dwNeededSize += nAligned;
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            continue;

        case lpGet_Struct:
        case lpGet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpGet_SizeToFollow);
            DWORD dwSize;


            if (bSizeToFollow)
            {
#if DBG
                //
                // Check to make sure the following arg is of type Size
                //

                if ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                    (pFuncArgs->ArgTypes[i + 1] != Size))
                {
                    LOG((TL_ERROR,
                        "DoFunc: error, lpGet_SizeToFollow !followed by Size"
                        ));

                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }
#endif
                dwSize = DWORD_CAST(pFuncArgs->Args[i + 1],__FILE__,__LINE__);
            }
            else
            {
                DWORD   dwError;

                try
                {
                    dwSize = *((LPDWORD) value);
                }
                except ((((dwError = GetExceptionCode())
                            == EXCEPTION_ACCESS_VIOLATION) ||
                         dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    LOG((TL_ERROR, "Bad get struct/size in dofunc"));
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

            }

            if (IsBadWritePtr ((LPVOID) value, dwSize))
            {
                LOG((TL_ERROR, "Bad get size/struct2 in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            if (bSizeToFollow)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
                ++j;++i;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = dwSize;
            }


            //
            // Now set the bCopyOnSuccess flag to indicate that we've data
            // to copy back on successful completion, and add to the
            // dwNeededSize field
            //

            bCopyOnSuccess = TRUE;

            dwNeededSize += ALIGN(dwSize);

            continue;
        }
        case lpSet_Struct:
        case lpSet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpSet_SizeToFollow);
            DWORD dwSize, dwError, dwSizeAligned;

#if DBG
            //
            // Check to make sure the following arg is of type Size
            //

            if (bSizeToFollow &&
                ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                (pFuncArgs->ArgTypes[i + 1] != Size)))
            {
                LOG((TL_ERROR,
                    "DoFunc: error, lpSet_SizeToFollow !followed by Size"
                    ));

                lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }
#endif
            try
            {
                //
                // First determine the data size & if the ptr is bad
                //

                dwSize = (bSizeToFollow ? DWORD_CAST(pFuncArgs->Args[i + 1],__FILE__,__LINE__) :
                     *((LPDWORD) value));

                if (IsBadReadPtr ((LPVOID) value, dwSize))
                {
                    LOG((TL_ERROR, "Bad set size/struct in dofunc"));
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                dwSizeAligned = ALIGN(dwSize);


                //
                // Special case if the size isn't even big enough to pass
                // over a complete DWORD for the dwTotalSize field
                //

                if (!bSizeToFollow && (dwSize < sizeof (DWORD)))
                {
                      static DWORD dwZeroTotalSize = 0;


                      dwSize = dwSizeAligned = sizeof (DWORD);
                      value = (ULONG_PTR) &dwZeroTotalSize;

//                    LOG((TL_ERROR, TEXT("Bad set size/struct2 in dofunc")));
//                    lResult = gaStructTooSmallErrors[dwFuncClassErrorIndex];
//                    goto DoFunc_return;
                }


                //
                // Grow the buffer if necessary, & do the copy
                //

                if ((dwSizeAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            dwSizeAligned
                            ))
                    {
                        LOG((TL_ERROR, "Nomem set size/struct in dofunc"));
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto DoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) value, dwSize);
            }
            except ((((dwError = GetExceptionCode())
                        == EXCEPTION_ACCESS_VIOLATION) ||
                     dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                LOG((TL_ERROR, "Bad pointer in get size/struct in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            //
            // Pass the server the offset of the data in the var data
            // portion of the buffer
            //

            if (dwSize)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }


            //
            // Increment the dwXxxSize vars appropriately
            //

            dwUsedSize   += dwSizeAligned;
            dwNeededSize += dwSizeAligned;


            //
            // Since we already know the next arg (Size) just handle
            // it here so we don't have to run thru the loop again
            //

            if (bSizeToFollow)
            {
                ++i;++j;
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i],__FILE__,__LINE__);
            }

            continue;
        }
#if DBG
        case Size:

            LOG((TL_ERROR, "DoFunc: error, hit case Size"));

            continue;

        default:

            LOG((TL_ERROR, "DoFunc: error, unknown arg type"));

            continue;
#endif
        } // switch

    } // for


    //
    // Now make the request
    //

    if (dwNeededSize > pTls->dwBufSize)
    {
        if (!GrowBuf(
                &pTls->pBuf,
                &pTls->dwBufSize,
                dwUsedSize,
                dwNeededSize - pTls->dwBufSize
                ))
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto DoFunc_return;
        }
    }

    ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func = (DWORD)HIWORD(pFuncArgs->Flags);

    {
        DWORD   dwRetryCount = 0;
        BOOL    bReinitResource;
        PCONTEXT_HANDLE_TYPE    phCtxTmp = GetTlsPCtxHandle();

        do
        {
            phCtx = (phCtxTmp != NULL)?phCtxTmp : gphCx;
            bReinitResource = FALSE;
            RpcTryExcept
            {
                ClientRequest (phCtx, pTls->pBuf, dwNeededSize, &dwUsedSize);
                lResult = (LONG) ((PTAPI32_MSG) pTls->pBuf)->u.Ack_ReturnValue;
                if (lResult == TAPIERR_INVALRPCCONTEXT)
                {
                    if (dwRetryCount ++ >= gdwMaxNumRequestRetries)
                    {
                        bReinitResource = FALSE;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                        dwRetryCount = 0;
                    }
                    else
                    {
                        ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func =
                            (DWORD)HIWORD(pFuncArgs->Flags);
                        bReinitResource = TRUE;
                    }
                }
                else
                {
                    bReinitResource = FALSE;
                    dwRetryCount = 0;
                }
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                unsigned long rpcException = RpcExceptionCode();

                if (rpcException == RPC_S_SERVER_TOO_BUSY)
                {
                    if (dwRetryCount++ < gdwMaxNumRequestRetries)
                    {
                        Sleep (gdwRequestRetryTimeout);
                    }
                    else
                    {
                        dwRetryCount = 0;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    }
                }
                else if ((rpcException == RPC_S_SERVER_UNAVAILABLE) ||
                         (rpcException == RPC_S_CALL_FAILED_DNE) ||
                         (rpcException == RPC_S_UNKNOWN_IF) ||
                         (rpcException == ERROR_INVALID_HANDLE))
                {
                    if (dwRetryCount ++ >= gdwMaxNumRequestRetries)
                    {
                        bReinitResource = FALSE;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                        dwRetryCount = 0;
                    }
                    else
                    {
                        bReinitResource = TRUE;
                    }
                }
                else
                {
                    LOG((TL_ERROR, "DoFunc: rpcException # %d", rpcException));
                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    dwRetryCount = 0;
                }
            }
            RpcEndExcept

            if (bReinitResource)
            {
                if (ReAllocClientResources(dwFuncClassErrorIndex) != TAPI_SUCCESS)
                {
                    LOG((TL_ERROR, "DoFunc: ReAllocClientResources failed"));
                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    dwRetryCount = 0;
                    bResAllocated = FALSE;
                }
            }
        } while (dwRetryCount != 0);
    }

// note: 99.99% of the time this result dump will == the one at end of the
// func (only when ptrs have gone bad will the result differ), no reason
// to dump 2x unless doing internal dbgging
//
    LOG((TL_TRACE, "DoFunc: back from srv- return code=0x%08lx", lResult));


    //
    // If request completed successfully and the bCopyOnSuccess flag
    // is set then we need to copy data back to client buffer(s)
    //

    if ((lResult == TAPI_SUCCESS) && bCopyOnSuccess)
    {
        for (i = 0, j = 0; i < (pFuncArgs->Flags & NUM_ARGS_MASK); i++, j++)
        {
            PTAPI32_MSG pMsg = (PTAPI32_MSG) pTls->pBuf;


            switch (pFuncArgs->ArgTypes[i])
            {
            case Dword:
            case Hwnd:
//            case lpsz:
            case lpszW:
            case lpSet_Struct:

                continue;

            case lpDword:

                try
                {
                    //
                    // Fill in the pointer with the return value
                    //

                    *((LPDWORD) pFuncArgs->Args[i]) = (DWORD) pMsg->Params[j];
                }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                continue;

            case lpGet_SizeToFollow:

                try
                {
                    //
                    // Fill in the pointer with the return value
                    //

                    CopyMemory(
                        (LPBYTE) pFuncArgs->Args[i],
                        pTls->pBuf + (DWORD)pMsg->Params[j] + sizeof(TAPI32_MSG),
                        pMsg->Params[j+1]
                        );
                }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }


                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpSet_SizeToFollow:

                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpGet_Struct:

                try
                {
                    //
                    // Params[j] contains the offset in the var data
                    // portion of pTls->pBuf of some TAPI struct.
                    // Get the dwUsedSize value from this struct &
                    // copy that many bytes from pTls->pBuf to client buf
                    //

                    if ((DWORD)pMsg->Params[j] != TAPI_NO_DATA)
                    {

                        LPDWORD pStruct;


                        pStruct = (LPDWORD) (pTls->pBuf + sizeof(TAPI32_MSG) +
                            (DWORD)pMsg->Params[j]);

                        CopyMemory(
                            (LPBYTE) pFuncArgs->Args[i],
                            (LPBYTE) pStruct,
                            *(pStruct + 2)      // ptr to dwUsedSize field
                            );
                    }
                }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                continue;

            default:

                continue;
            }
        }
    }



DoFunc_return:

    if (bResAllocated)
    {
        FreeClientResources();
    }

#if DBG
    {
        char szResult[32];

        LOG((TL_TRACE,
            "%hs: result = %hs",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "DoFunc: result = x%x",
            lResult
            ));
#endif

    return lResult;
}


LONG
LoadUIDll(
    HWND        hwndOwner,
    DWORD       dwWidgetID,
    DWORD       dwWidgetType,
    HANDLE     *phDll,
    LPCSTR      pszTUISPI_xxx,      // use for GetProcAddress, leave as ANSI
    TUISPIPROC *ppfnTUISPI_xxx
    )
{
    LONG    lResult;
    HANDLE  hDll = NULL;
    WCHAR   szUIDllName[MAX_PATH];
    HANDLE  hProvidersMutex;
    
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, xGetUIDllName),

        {
            (ULONG_PTR) dwWidgetID,
            (ULONG_PTR) dwWidgetType,
            (ULONG_PTR) szUIDllName,
            (ULONG_PTR) MAX_PATH
        },

        {
            Dword,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (hwndOwner && !IsWindow (hwndOwner))
    {
       lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
           PHONEERR_INVALPARAM : LINEERR_INVALPARAM);

       goto LoadUIDll_return;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );

    if (NULL == hProvidersMutex)
    {
        lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
           PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);

        goto LoadUIDll_return;
    }
    
    WaitForSingleObject (hProvidersMutex, INFINITE);
        
    if ((lResult = DOFUNC (&funcArgs, "GetUIDllName")) == 0)
    {
        if (hDll = TAPILoadLibraryW(szUIDllName))
        {
            if ((*ppfnTUISPI_xxx = (TUISPIPROC) GetProcAddress(
                hDll,
                pszTUISPI_xxx
                )))
            {
                *phDll = hDll;
                lResult = 0;
            }
            else
            {
                LOG((TL_ERROR,
                        "LoadUIDll: GetProcAddress(%ls,%hs) failed, err=%d",
                        szUIDllName,
                        pszTUISPI_xxx,
                        GetLastError()
                       ));

                FreeLibrary (hDll);
                lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
                    PHONEERR_OPERATIONUNAVAIL : LINEERR_OPERATIONUNAVAIL);
            }
        }
        else
        {
            LOG((TL_ERROR,
                    "LoadLibraryW(%ls) failed, err=%d",
                    szUIDllName,
                    GetLastError()
                   ));

            lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
                PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);
        }

    }

    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }

LoadUIDll_return:

    return lResult;
}


LONG
PASCAL
lineXxxProvider(
    LPCSTR  pszTUISPI_providerXxx,
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    DWORD   dwPermProviderID,
    LPDWORD lpdwPermProviderID
    )
{
    BOOL                bAddProvider = (pszTUISPI_providerXxx ==
                            gszTUISPI_providerInstall);
    WCHAR               szUIDllName[MAX_PATH];
    LONG                lResult;
    HINSTANCE           hDll;
    TUISPIPROC          pfnTUISPI_providerXxx;
    HTAPIDIALOGINSTANCE htDlgInst;
    LPTSTR              tszProviderFilename;
#ifdef UNICODE
    WCHAR               wszProviderFilename[255];
    HANDLE              hProvidersMutex;

    if (lpszProviderFilename)
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpszProviderFilename,
            lstrlenA (lpszProviderFilename) + 1,
            wszProviderFilename,
            sizeof(wszProviderFilename) / sizeof(WCHAR)
            );
    }
    else
    {
        wszProviderFilename[0] = 0;
    }
    tszProviderFilename = wszProviderFilename;
#else
    tszProviderFilename = lpszProviderFilename;
#endif

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );

    if (NULL == hProvidersMutex)
    {
        return LINEERR_OPERATIONFAILED;
    }

    lResult = AllocClientResources(0);
    if (lResult)
    {
        return lResult;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);

    if (bAddProvider && IsBadDwordPtr (lpdwPermProviderID))
    {
        LOG((TL_ERROR, "Bad lpdwPermProviderID pointer"));
        if (hProvidersMutex)
        {
            ReleaseMutex (hProvidersMutex);
            CloseHandle (hProvidersMutex);
        }
        FreeClientResources ();
        return LINEERR_INVALPOINTER;
    }
    else if (hwndOwner && !IsWindow (hwndOwner))
    {
        LOG((TL_ERROR, "hwndOwner is not a window"));
        if (hProvidersMutex)
        {
            ReleaseMutex (hProvidersMutex);
            CloseHandle (hProvidersMutex);
        }
        FreeClientResources ();
        return LINEERR_INVALPARAM;
    }

    {
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 7, xGetUIDllName),

            {
                (bAddProvider ? (ULONG_PTR) &dwPermProviderID :
                                (ULONG_PTR) dwPermProviderID),
                (ULONG_PTR) TUISPIDLL_OBJECT_PROVIDERID,
                (ULONG_PTR) szUIDllName,
                (ULONG_PTR) MAX_PATH,
                (bAddProvider ? (ULONG_PTR) tszProviderFilename :
                                (ULONG_PTR) TAPI_NO_DATA),
                (ULONG_PTR) (pszTUISPI_providerXxx==gszTUISPI_providerRemove ?
                                1 : 0),
                (ULONG_PTR) &htDlgInst
            },

            {
                (bAddProvider ? lpDword : Dword),
                Dword,
                lpGet_SizeToFollow,
                Size,
                (bAddProvider ? lpszW : Dword),
                Dword,
                lpDword
            }
        };


        if ((lResult = DOFUNC (&funcArgs,"lineXxxProvider/GetUIDllName")) != 0)
        {
            if (lResult == TAPI16BITSUCCESS)
            {
                // 16 bit sp success
                // set result correctly, and return here
                lResult = 0;
            }
            if (hProvidersMutex)
            {
                ReleaseMutex (hProvidersMutex);
                CloseHandle (hProvidersMutex);
            }
            FreeClientResources ();
            return lResult;
        }
    }

    if ((hDll = TAPILoadLibraryW(szUIDllName)))
    {
        if ((pfnTUISPI_providerXxx = (TUISPIPROC) GetProcAddress(
                hDll,
                pszTUISPI_providerXxx
                )))
        {
            LOG((TL_TRACE, "Calling %hs...", pszTUISPI_providerXxx));

            lResult = (*pfnTUISPI_providerXxx)(
                TUISPIDLLCallback,
                hwndOwner,
                dwPermProviderID
                );
#if DBG
            {
                char szResult[32];

                LOG((TL_TRACE,
                    "%hs: result = %hs",
                    pszTUISPI_providerXxx,
                    MapResultCodeToText (lResult, szResult)
                    ));
            }
#else
                LOG((TL_TRACE,
                    ": result = x%x",
                    lResult
                    ));
#endif
        }
        else
        {
            LOG((TL_ERROR,
                "lineXxxProvider: GetProcAddr(%ls,%hs) failed, err=%d",
                szUIDllName,
                pszTUISPI_providerXxx,
                GetLastError()
                ));
        
            //
            //  HACK ALERT !
            //  Even though remotesp.tsp does not have the add/remove/config
            //  provider function, we silently allow it to be added from 
            //  tcmsetup.exe
            //
            if (lstrcmpi (gszRemoteSP, szUIDllName) != 0)
            {
                lResult = LINEERR_OPERATIONUNAVAIL;
            }
        }

        FreeLibrary (hDll);
    }
    else
    {
        LOG((TL_ERROR,
            "lineXxxProvider: LoadLibraryW('%ls') failed, err=%d",
            szUIDllName,
            GetLastError()
            ));

        lResult = LINEERR_OPERATIONFAILED;
    }

    {
        LONG    lResult2;
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 2, xFreeDialogInstance),

            {
                (ULONG_PTR) htDlgInst,
                (ULONG_PTR) (ULONG)lResult
            },

            {
                Dword,
                Dword
            }
        };


        //
        // If TUISPI_providerXxx failed then we want to pass that error back
        // to the app, else if it succeeded & FreeDlgInst failed then pass
        // that error back to the app
        //

        if ((lResult2 = DOFUNC(
                &funcArgs,
                "lineXxxProvider/FreeDialogInstance"

                )) == 0)
        {
            if (bAddProvider)
            {
                *lpdwPermProviderID = dwPermProviderID;
            }
        }
        else if (lResult == 0)
        {
            lResult = lResult2;
        }
    }

    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }
    FreeClientResources ();
    return lResult;
}


LONG
PASCAL
ValidateXxxInitializeParams(
    DWORD                       dwAPIVersion,
    BOOL                        bLine,
    LPLINEINITIALIZEEXPARAMS    pXxxInitExParams,
    LINECALLBACK                pfnCallback
    )
{
    DWORD dwError;


    try
    {
        DWORD   dwTotalSize = pXxxInitExParams->dwTotalSize;


        if (dwTotalSize < sizeof (LINEINITIALIZEEXPARAMS))
        {
            return (bLine ? LINEERR_STRUCTURETOOSMALL :
                PHONEERR_STRUCTURETOOSMALL);
        }

        if (IsBadWritePtr (pXxxInitExParams, dwTotalSize))
        {
            return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        }


        //
        // When checking the dwOptions field be careful about compatibility
        // with future vers, so we only look at the currently valid bits
        //

        switch ((pXxxInitExParams->dwOptions & 0xf))
        {
        case 0:
        case LINEINITIALIZEEXOPTION_USEHIDDENWINDOW:

            if (IsBadCodePtr ((FARPROC) pfnCallback))
            {
                return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            }
            break;


        case LINEINITIALIZEEXOPTION_USECOMPLETIONPORT:

            if ( !gpPostQueuedCompletionStatus )
            {
                HINSTANCE hInst;

                hInst = GetModuleHandle( TEXT("Kernel32.dll") );

                {
                    gpPostQueuedCompletionStatus = GetProcAddress(
                        hInst,
                        "PostQueuedCompletionStatus"
                        );

                    if ( NULL == gpPostQueuedCompletionStatus )
                    {
                        LOG((TL_ERROR,
                            "GetProcAddr(PostQueuedCompletionStatus) failed"
                             ));

                        return (bLine ?
                            LINEERR_INVALFEATURE : PHONEERR_OPERATIONFAILED);
                    }
                }

            }
            break;

        case LINEINITIALIZEEXOPTION_USEEVENT:

            break;

        default:

            if ((TAPI_VERSION2_2 == dwAPIVersion) ||
                (TAPI_VERSION2_1 == dwAPIVersion) ||
                (TAPI_VERSION2_0 == dwAPIVersion))
            {
                //
                // Invalid parameter for these versions
                //

                return (bLine ? LINEERR_INVALPARAM : PHONEERR_INVALPARAM);
            }
            else
            {
                //
                // This app is asking for something we can't do.
                //

                return (bLine ? LINEERR_INCOMPATIBLEAPIVERSION :
                                PHONEERR_INCOMPATIBLEAPIVERSION);
            }

        }

        pXxxInitExParams->dwNeededSize =
        pXxxInitExParams->dwUsedSize = sizeof (LINEINITIALIZEEXPARAMS);
    }
    except ((((dwError = GetExceptionCode()) == EXCEPTION_ACCESS_VIOLATION) ||
               dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
    }

    return 0;
}


LONG
WINAPI
xxxInitialize(
    BOOL                        bLine,
    LPVOID                      phXxxApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                pfnCallback,
    LPCWSTR                     pszAppName,
    LPDWORD                     pdwNumDevs,
    LPDWORD                     pdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    pXxxInitExParams
#if DBG
    ,char                      *pszFuncName
#endif
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG ((bLine ? LINE_FUNC : PHONE_FUNC) | SYNC | 7,
            (bLine ? lInitialize : pInitialize)),

        {
            (ULONG_PTR) phXxxApp,
            (ULONG_PTR) 0,          // hInstance is ignored by tapisrv, so pass 0,
                                    // to save ourselves grief over HINSTANCE -> DWORD conversion
            (ULONG_PTR) 0,          // pfnCallback, we subst pInitData in here
            (ULONG_PTR) pszAppName,
            (ULONG_PTR) pdwNumDevs,
            (ULONG_PTR) 0,          // pszModuleName
            (ULONG_PTR) TAPI_VERSION1_0
        },

        {
            lpDword,
            Dword,
            Dword,
            lpszW,
            lpDword,
            lpszW,
            Dword
        }
    };

    WCHAR       *pszModuleNamePathW = NULL;
    WCHAR       *pszModuleNameW = NULL;
    LONG         lResult;
    BOOL         bReleaseMutex = FALSE;
    BOOL         bResAllocated = FALSE;
    PINIT_DATA   pInitData = (PINIT_DATA) NULL;
    BOOL         fIs16bitCaller = FALSE;
    DWORD        dwAllInitExOptions;


    EnterCriticalSection (&gCriticalSection);
    if (gdwNumInits == 0)
    {
        TRACELOGREGISTER (_T("tapi32"));
    }
    LeaveCriticalSection (&gCriticalSection);

    if (phXxxApp == (LPVOID) pdwNumDevs)
    {
#if DBG
        LOG((TL_TRACE, "%hs: error, lphApp == lpdwNumDevs", pszFuncName));
#else
        LOG((TL_TRACE, ": error, lphApp == lpdwNumDevs"));
#endif
		lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxInitialize_return;
    }

    if (pdwAPIVersion)
    {
        if (phXxxApp == (LPVOID) pdwAPIVersion  ||
            phXxxApp == (LPVOID) pXxxInitExParams  ||
            pdwNumDevs == pdwAPIVersion  ||
            pdwNumDevs == (LPDWORD) pXxxInitExParams  ||
            pdwAPIVersion == (LPDWORD) pXxxInitExParams)
        {
            lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            goto xxxInitialize_return;
        }


        //
        // line- & phoneInitializeEx both require a valid lpdwAPIVersion
        // pointer parameter, and the value it points to on the way in
        // must be >= 0x00020000. (Careful to allow for future vers of TAPI.)
        //

        if (*pdwAPIVersion < TAPI_VERSION2_0)
        {
            LOG((TL_ERROR,
                "%InitializeEx: error, *lpdwAPIVersion = x%x, " \
                    "must be set >= 0x20000",
                *pdwAPIVersion,
                (bLine ? "line" : "phone")
                ));

            lResult = (bLine ? LINEERR_INCOMPATIBLEAPIVERSION :
                PHONEERR_INCOMPATIBLEAPIVERSION);
            goto xxxInitialize_return;
        }


        //
        // Validate the InitEx params, or if the pointer is NULL (implying
        // that app wants to use "old" hidden window scheme) validate
        // the pfnCallback
        //

        if (pXxxInitExParams)
        {
            if ((lResult = ValidateXxxInitializeParams(
                    (*pdwAPIVersion),
                    bLine,
                    pXxxInitExParams,
                    pfnCallback

                    ))  != 0)
            {
                goto xxxInitialize_return;
            }
        }
        else if (IsBadCodePtr ((FARPROC) pfnCallback))
        {
#if DBG
            LOG((TL_ERROR, "%hs: bad lpfnCallback", pszFuncName));
#else
            LOG((TL_ERROR, ": bad lpfnCallback"));
#endif
            lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            goto xxxInitialize_return;
        }


        //
        // Now fill in *pdwAPIVersion with the version # we support, and
        // also indicate this in the params we pass to tapisrv.exe (so
        // it knows it can start sending us 2.0 msgs right away)
        //

        // bug #69742.  don't assume version 2.0
        if ( (*pdwAPIVersion == TAPI_VERSION2_2) ||
             (*pdwAPIVersion == TAPI_VERSION2_1) ||
             (*pdwAPIVersion == TAPI_VERSION2_0))
        {
            funcArgs.Args[6] = *pdwAPIVersion;
        }
        else
        {
            //
            // the app is at least 2.0 if they are calling lineIntializeEx,
            // but they passed in a bogus tapi version, so set it correctly.
            //

            funcArgs.Args[6] = *pdwAPIVersion = TAPI_CURRENT_VERSION;
        }
    }

#ifndef _WIN64

    else if ((((DWORD) pfnCallback) & 0xffff0000) == 0xffff0000)
    {
        //
        // This is a 16-bit client going through the thunk.  The
        // pfnCallback var is actually a window handle.
        //
        // Note: On NT, 32-bit code can talk to 16-bit HWNDs
        //       by setting the hi-word to 0xffff.
        //
        //       On Win95, 32-bit can talk to 16-bit HWNDs
        //       by setting the hi-word to 0x0000.
        //

//<!         ((DWORD) pfnCallback) = HWND_32( pfnCallback );
//<!
//<!

        if (!IsWindow ((HWND) pfnCallback))
        {
            //
            // If here chances are it's a 32-bit app passing in a bad
            // pfnCallback
            //

#if DBG
            LOG((TL_ERROR, "%hs: bad lpfnCallback", pszFuncName));
#else
            LOG((TL_ERROR, ": bad lpfnCallback"));
#endif
            lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            goto xxxInitialize_return;
        }

        if (!ghWow32Dll &&

            !(ghWow32Dll = LoadLibrary (TEXT("wow32.dll"))))
        {
#if DBG
            LOG((TL_ERROR,
                "%hs: LoadLib(wow32.dll) failed, err=%d",
                pszFuncName,
                GetLastError()
                ));
#else
            LOG((TL_ERROR,
                ": LoadLib(wow32.dll) failed, err=%d",
                GetLastError()
                ));
#endif

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_return;
        }

        if (!gpfnWOWGetVDMPointer &&

            !(gpfnWOWGetVDMPointer = GetProcAddress(
                ghWow32Dll,
                "WOWGetVDMPointer"
                )))
        {
#if DBG
            LOG((TL_ERROR,
                "%hs: GetProcAddr(WOWGetVDMPointer) failed, err=%d",
                pszFuncName,
                GetLastError()
                ));
#else
            LOG((TL_ERROR,
                ": GetProcAddr(WOWGetVDMPointer) failed, err=%d",
                GetLastError()
                ));
#endif

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_return;
        }

        gbNTVDMClient = TRUE;


        //
        // For 16-bit clients the module name will follow the app name
        //
        // HACK ALERT!
        //
        // Since the lpszAppName pointer was already converted to a
        // unicode string by the calling function, the following
        // module name part was lost.  So, we pass the original
        // (16->32 mapped) lpszAppName pointer in pXxxInitExParams
        // so we can discover the module name
        //

        {
            char   *pszAppName2 = (char *) pXxxInitExParams;


            pXxxInitExParams = NULL; // so we don't blow up below

            pszModuleNamePathW = NotSoWideStringToWideString(
                pszAppName2 + lstrlenA (pszAppName2) + 1,
                (DWORD) -1
                );

            funcArgs.Args[5] = (ULONG_PTR) pszModuleNamePathW;

            LOG((TL_INFO,
                "FName='%ls', MName='%ls'",
                pszAppName,
                funcArgs.Args[5]
                ));

        }
    }

#endif

    else if (IsBadCodePtr ((FARPROC) pfnCallback))
    {
        //
        // If here a 32-bit app is call line/phoneInitialize
        //

#if DBG
        LOG((TL_ERROR, "%hs: bad lpfnCallback", pszFuncName));
#else
        LOG((TL_ERROR, ": bad lpfnCallback"));
#endif
        lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxInitialize_return;
    }



    //
    // Check to see if hInstance is bad by getting the module name
    //
    // Note: We now allow a NULL hInstance (16-bit TAPI didn't)
    //

    if (gbNTVDMClient == FALSE)
    {
        DWORD   dwSize = MAX_PATH, dwLength;


alloc_module_name_buf:

        if (!(pszModuleNamePathW = ClientAlloc (dwSize*sizeof(WCHAR))))
        {
            lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
            goto xxxInitialize_return;
        }

        //
        // We're on WinNT - do Unicode
        //
        if ((dwLength = GetModuleFileNameW(
                hInstance,
                pszModuleNamePathW,
                dwSize

                )) == 0)
        {
#if DBG
            LOG((TL_ERROR,
                "%hs: GetModuleFileNameW(x%p, ...) failed, err=%d",
                pszFuncName,
                hInstance,
                GetLastError()
                ));
#else
            LOG((TL_ERROR,
                ": GetModuleFileNameW(x%p, ...) failed, err=%d",
                hInstance,
                GetLastError()
                ));
#endif

            lResult = (bLine ? LINEERR_INVALPARAM : PHONEERR_INVALPARAM);
            goto xxxInitialize_cleanup;
        }
        else if (dwLength >= dwSize)
        {
            ClientFree (pszModuleNamePathW);
            dwSize *= 2;
            goto alloc_module_name_buf;
        }

        pszModuleNameW = wcsrchr (pszModuleNamePathW, '\\') + 1;

        // For MSWORKS.EXE, the behavior of lineGetTranslateCaps 
        // will be different
        
        if(0 == _wcsicmp(pszModuleNameW, L"MSWORKS.EXE"))
        {
            LOG((TL_ERROR, "MSWORKS detected..."));
            gbDisableGetTranslateCapsHack = TRUE;
        }
        else
        {
            gbDisableGetTranslateCapsHack = FALSE;   
        }
            
        funcArgs.Args[5] = (ULONG_PTR) pszModuleNameW;
                                           
        if (!pszAppName)
        {
            funcArgs.Args[3] = funcArgs.Args[5];
        }
    }

    if (!(pInitData = ClientAlloc (sizeof(INIT_DATA))) ||

        !(pInitData->pEventBuffer = ClientAlloc(
            DEF_NUM_EVENT_BUFFER_ENTRIES * sizeof (ASYNC_EVENT_PARAMS))) ||

        !(pInitData->hInitData = NewObject (ghHandleTable, pInitData, NULL)))
    {
        lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
        goto xxxInitialize_cleanup;
    }


    //
    // When checking the dwOptions field be careful about compatibility
    // with future vers, so we only look at the currently valid bits
    // (The ExOptions are currently ordinals, but we track bits here just
    // in case we wanna use high bits later.)
    //

    dwAllInitExOptions = AllInitExOptions2_0;

    pInitData->dwInitOptions = (pXxxInitExParams ?
        (pXxxInitExParams->dwOptions & dwAllInitExOptions) :
        LINEINITIALIZEEXOPTION_USEHIDDENWINDOW);


    switch (pInitData->dwInitOptions & 0xf)
    {
    case LINEINITIALIZEEXOPTION_USECOMPLETIONPORT:

        //
        // Be libertarian- if the app wants to hose itself by passing
        // a bad hCompletionPort then so be it
        //

        pInitData->hCompletionPort =
            pXxxInitExParams->Handles.hCompletionPort;
        pInitData->dwCompletionKey = pXxxInitExParams->dwCompletionKey;
        break;

    case LINEINITIALIZEEXOPTION_USEEVENT:

        if ((pInitData->hEvent = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,
                TRUE,   // manual reset
                FALSE,  // unsignaled
                NULL    // unnamed

                )) == NULL)
        {
            lResult = (bLine ? LINEERR_OPERATIONFAILED :
                PHONEERR_OPERATIONFAILED);
            goto xxxInitialize_cleanup;
        }

        pXxxInitExParams->Handles.hEvent = pInitData->hEvent;
        break;

    default: // case LINEINITIALIZEEXOPTION_USEHIDDENWINDOW:

        pInitData->dwInitOptions |= LINEINITIALIZEEXOPTION_USEHIDDENWINDOW;

        if (gbNTVDMClient == FALSE)
        {
            if ((lResult = CreateHiddenWindow(
                    &pInitData->hwnd,
                    (bLine ? 1 : 2)
                    )) != 0)
            {
                goto xxxInitialize_cleanup;
            }
        }
        else
        {
            pInitData->hwnd = (HWND) pfnCallback;
        }

        pInitData->lpfnCallback          = pfnCallback;
        pInitData->bPendingAsyncEventMsg = FALSE;
        break;
    }

    pInitData->dwKey                 = INITDATA_KEY;
    pInitData->dwNumTotalEntries     = DEF_NUM_EVENT_BUFFER_ENTRIES;
    pInitData->dwNumUsedEntries      = 0;
    pInitData->pValidEntry           =
    pInitData->pFreeEntry            = pInitData->pEventBuffer;
    pInitData->bLine                 = bLine;
    pInitData->dwThreadID            = GetCurrentThreadId();


    //
    // We want to pass TAPISRV pInitData so that later when it does async
    // completion/event notification it can pass pInitData along too so
    // we know which init instance to talk to
    //

    funcArgs.Args[2] = (ULONG_PTR) pInitData->hInitData;

    WaitForSingleObject (ghInitMutex, INFINITE);

    bReleaseMutex = TRUE;

    //
    // Need to hold a reference of the Rpc connection
    // so we don't close it until lineShutdown
    //
    bResAllocated = (0 == AllocClientResources(bLine ? 1 : 2));
    if (bResAllocated)
    {
        lResult = DOFUNC (&funcArgs, pszFuncName);
    }
    else
    {
        lResult = (bLine ? LINEERR_OPERATIONFAILED :
                PHONEERR_OPERATIONFAILED);
    }

xxxInitialize_cleanup:

    if (pszModuleNamePathW)
    {
        ClientFree (pszModuleNamePathW);
    }

    if (lResult == 0)
    {
        //
        // If total number of init instances is 0 we need to start a
        // new async events thread
        //

        EnterCriticalSection (&gCriticalSection);
        if (gdwNumInits == 0)
        {
            DWORD   dwThreadID;
            HANDLE  hThread;


            //
            // Alloc resources for a new async events thread, then
            // create the thread
            //

            if ((gpAsyncEventsThreadParams = ClientAlloc(
                    sizeof (ASYNC_EVENTS_THREAD_PARAMS)
                    )))
            {
                //
                // Load ourself to increment our usage count. This is
                // done to give the AsyncEventThread a chance to
                // terminate cleanly if an app thread calls xxxShutdown
                // and then immediately unloads tapi32.dll.
                //
                // (For a while we were doing a Wait on this thread's
                // handle in xxxShutdown waiting for it to terminate,
                // but if xxxShutdown was being called from another DLL's
                // DllEntryPoint then deadlock occured, because
                // DllEntryPoint's aren't reentrant.)
                //

                if ((gpAsyncEventsThreadParams->hTapi32 = LoadLibrary(
                        TEXT("tapi32.dll")
                        )))
                {
                    //
                    // If we're supporting a 16-bit client we want to inc
                    // the usage count for wow32 too
                    //

                    if (ghWow32Dll == NULL ||

                        (gpAsyncEventsThreadParams->hWow32 = LoadLibrary(
                            TEXT("wow32.dll")
                            )))
                    {
                        //
                        // Create the initial buffer the thread will use for
                        // retreiving async events
                        //

                        gpAsyncEventsThreadParams->dwBufSize =
                            ASNYC_MSG_BUF_SIZE;

                        if ((gpAsyncEventsThreadParams->pBuf = ClientAlloc(
                                gpAsyncEventsThreadParams->dwBufSize
                                )))
                        {
                            //
                            // Now that we've all the resources try to exec
                            // the thread
                            //

                            if ((hThread = CreateThread(
                                    NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) AsyncEventsThread,
                                    (LPVOID) gpAsyncEventsThreadParams,
                                    0,
                                    &dwThreadID

                                    )) != NULL)

                            {
                                CloseHandle (hThread);
                                gdwNumInits++;
                                LeaveCriticalSection(&gCriticalSection);
                                goto xxxInitialize_releaseMutex;
                            }


                            ClientFree (gpAsyncEventsThreadParams->pBuf);

#if DBG
                            LOG((TL_ERROR,
                                "%hs: CreateThread(AsyncEventsThread) " \
                                    "failed, err=%d",
                                pszFuncName,
                                GetLastError()
                                ));
#else
                            LOG((TL_ERROR,
                                ": CreateThread(AsyncEventsThread) " \
                                    "failed, err=%d",
                                GetLastError()
                                ));
#endif
                        }

                        if (ghWow32Dll)
                        {
                            FreeLibrary (gpAsyncEventsThreadParams->hWow32);
                        }
                    }

                    FreeLibrary (gpAsyncEventsThreadParams->hTapi32);
                }
                else
                {
#if DBG
                    LOG((TL_ERROR,
                        "%hs: LoadLibrary('tapi32.dll') failed, err=%d",
                        pszFuncName,
                        GetLastError()
                        ));
#else
                    LOG((TL_ERROR,
                        ": LoadLibrary('tapi32.dll') failed, err=%d",
                        GetLastError()
                        ));
#endif
				}

                ClientFree (gpAsyncEventsThreadParams);
            }

            gpAsyncEventsThreadParams = NULL;

            lResult =
                (bLine ? LINEERR_OPERATIONFAILED : PHONEERR_OPERATIONFAILED);
        }
        else
        {
            gdwNumInits++;
        }
        LeaveCriticalSection(&gCriticalSection);
    }

    if (lResult != 0)
    {
        if (gbNTVDMClient && pInitData)
        {
            pInitData->hwnd = (HWND) NULL;
        }

        FreeInitData (pInitData);
    }

xxxInitialize_releaseMutex:

    if (bReleaseMutex)
    {
        ReleaseMutex (ghInitMutex);
    }

    if (lResult == 0)
    {
        //
        // Save the hLineApp returned by TAPISRV in our InitData struct,
        // and give the app back a unique handle
        //

        pInitData->hXxxApp = *((LPHLINEAPP) phXxxApp);

        *((LPHLINEAPP) phXxxApp) = pInitData->hInitData;
    }

xxxInitialize_return:

    //
    // if we failed, we need to release the RPC ref count,
    // nobody will call lineShutdown
    //
    if (bResAllocated &&
        lResult !=0)
    {
        FreeClientResources();
    }

#if DBG
    {
        char szResult[32];

        LOG((TL_TRACE,
            "%hs: exit, result=%hs",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            ": exit, result=x%x",
            lResult
            ));
#endif

    return lResult;
}


//
// --------------------------------- lineXxx ----------------------------------
//

LONG
WINAPI
lineAccept(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAccept),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1]  = Dword;
        funcArgs.Args[1]      = TAPI_NO_DATA;
        funcArgs.ArgTypes[2]  = Dword;
    }

    return (DOFUNC (&funcArgs, "lineAccept"));
}

LONG
WINAPI
lineAddProviderA(
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    LPDWORD lpdwPermanentProviderID
    )
{
    LONG    lResult;


    LOG((TL_TRACE, "lineAddProviderA: enter"));
    LOG((TL_INFO, "  lpszProviderFilename=0x%p", lpszProviderFilename));

#if DBG
    if (!IsBadStringPtrA(lpszProviderFilename, (UINT)-1) )
    {
        LOG((TL_INFO, "    *lpszProviderFilename=[%hs]", lpszProviderFilename));
    }
#endif

    LOG((TL_INFO, "  hwndOwner=0x%p", hwndOwner));
    LOG((TL_INFO, "  lpdwPermanentProviderID=0x%p", lpdwPermanentProviderID));


    if ( IsBadStringPtrA(lpszProviderFilename, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszProviderFilename (0x%p)", lpszProviderFilename));
        return LINEERR_INVALPOINTER;
    }

    lResult = lineXxxProvider(
        gszTUISPI_providerInstall,  // funcName
        lpszProviderFilename,       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        0,                          // dwPermProviderID
        lpdwPermanentProviderID     // lpdwPermProviderID
        );

#if DBG
    {
        char szResult[32];

        LOG((TL_TRACE,
            "lineAddProvider: result = %hs",
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "lineAddProvider: result = x%x",
            lResult
            ));
#endif

    return lResult;
}

LONG
WINAPI
lineAddProviderW(
    LPCWSTR  lpszProviderFilename,
    HWND     hwndOwner,
    LPDWORD  lpdwPermanentProviderID
    )
{
    LONG            lResult;
    LPBYTE          pszTempPtr;
    DWORD           dwSize;


    LOG((TL_TRACE, "Entering lineAddProvider"));
    LOG((TL_INFO, "  lpszProviderFilename=0x%p", lpszProviderFilename));

    if ( TAPIIsBadStringPtrW(lpszProviderFilename, (UINT)-1) )
    {
        LOG((TL_ERROR,
            "Bad lpszProviderFilename [0x%p] passed to lineAddProviderW",
            lpszProviderFilename
            ));

        return( LINEERR_INVALPOINTER );
    }

    LOG((TL_INFO, "    *lpszProviderFilename=[%ls]", lpszProviderFilename));
    LOG((TL_INFO, "  hwndOwner=0x%p", hwndOwner));
    LOG((TL_INFO, "  lpdwPermanentProviderID=0x%p", lpdwPermanentProviderID));

    dwSize = lstrlenW(lpszProviderFilename) + 1;

    pszTempPtr = ClientAlloc(dwSize * sizeof (WCHAR));
    if (NULL == pszTempPtr)
    {
        return LINEERR_NOMEM;
    }

    // can't use this because this is for strings
    // embedded in structures.
    // WideStringToNotSoWideString (pszTempPtr, &dwSize);

    WideCharToMultiByte(
                        GetACP(),
                        0,
                        lpszProviderFilename,
                        -1,
                        pszTempPtr,
                        dwSize * sizeof(WCHAR),
                        NULL,
                        NULL
                       );

    lResult = lineAddProviderA(
        (LPCSTR) pszTempPtr,
        hwndOwner,
        lpdwPermanentProviderID
        );

    ClientFree(pszTempPtr);

    return lResult;
}




LONG
WINAPI
lineAddProvider(
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    LPDWORD lpdwPermanentProviderID
    )
{
    return lineAddProviderA(
               lpszProviderFilename,
               hwndOwner,
               lpdwPermanentProviderID
    );
}


LONG
WINAPI
lineAddToConference(
    HCALL   hConfCall,
    HCALL   hConsultCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lAddToConference),

        {
            (ULONG_PTR) hConfCall ,
            (ULONG_PTR) hConsultCall
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineAddToConference"));
}


LONG
WINAPI
lineAgentSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lAgentSpecific),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAgentExtensionIDIndex,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    DWORD hPointer = 0;
    LONG lResult;

    if ( !hLine )
    {
        return LINEERR_INVALLINEHANDLE;
    }

    if ( 0 == dwSize) 
    {
        return LINEERR_INVALPARAM;
    }

    if ( !lpParams )
    {
        return LINEERR_INVALPOINTER;
    }

    // Since we're passing lpParams twice, once a handle to it
    // and another time unchanged, we rely on DoFunc to test it.
    hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    if (0 > (lResult = DOFUNC (&funcArgs, "lineAgentSpecific")))
    {
        // There was an error, free the handle...
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineAnswer(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAnswer),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1]  = Dword;
        funcArgs.Args[1]      = TAPI_NO_DATA;
        funcArgs.ArgTypes[2]  = Dword;
    }

    return (DOFUNC (&funcArgs, "lineAnswer"));
}


LONG
WINAPI
lineBlindTransferW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lBlindTransfer),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if ( TAPIIsBadStringPtrW( lpszDestAddress, (UINT)-1 ) )
    {
        LOG((TL_ERROR,
            "lineBlindTransferW: bad lpszDestAddress: 0x%p",
            lpszDestAddress
            ));

        return(LINEERR_INVALPOINTER);
    }

    return (DOFUNC (&funcArgs, "lineBlindTransfer"));
}


LONG
WINAPI
lineBlindTransferA(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if ( IsBadStringPtrA( lpszDestAddress, (UINT)-1 ) )
    {
        LOG((TL_ERROR,
            "lineBlindTransferA: bad lpszDestAddress: 0x%08lx",
            lpszDestAddress
            ));

        return(LINEERR_INVALPOINTER);
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    if ( !szTempPtr )
    {
        LOG((TL_ERROR,
            "lineBlindTransferA: NotSoWideStringToWideString returned NULL"
            ));

        return(LINEERR_INVALPOINTER);
    }


    lResult = lineBlindTransferW (hCall, szTempPtr, dwCountryCode);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineBlindTransfer(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    return lineBlindTransferA(
                hCall,
                lpszDestAddress,
                dwCountryCode
    );
}


LONG
WINAPI
lineClose(
    HLINE   hLine
    )
{
    LONG lResult;
    DWORD Handle = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lClose),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) &Handle
        },

        {
            Dword,
            lpDword
        }
    };


    lResult = DOFUNC (&funcArgs, "lineClose");

    if (0 == lResult &&
        0 != Handle)
    {
        DereferenceObject (ghHandleTable, Handle, 1);
    }

    return lResult;
}


void
PASCAL
lineCompleteCallPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineCompleteCallPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwCompletionID   = (DWORD) pMsg->Param3;
        LPDWORD lpdwCompletionID = (LPDWORD) ReferenceObject (ghHandleTable, pMsg->Param4, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param4, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPDWORD lpdwCompletionIDVDM = (LPDWORD) gpfnWOWGetVDMPointer (
                    (DWORD) lpdwCompletionID,
                    sizeof(DWORD),
                    TRUE // fProtectedMode
                    );


                if (lpdwCompletionIDVDM)
                {
                    *lpdwCompletionIDVDM = dwCompletionID;
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                *lpdwCompletionID = dwCompletionID;
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineCompleteCall(
    HCALL   hCall,
    LPDWORD lpdwCompletionID,
    DWORD   dwCompletionMode,
    DWORD   dwMessageID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCompleteCall),

        {
            (ULONG_PTR) GetFunctionIndex(lineCompleteCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpdwCompletionID,
            (ULONG_PTR) dwCompletionMode,
            (ULONG_PTR) dwMessageID
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lpdwCompletionID))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lpdwCompletionID, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }

        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }


    lResult = DOFUNC (&funcArgs, "lineCompleteCall");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineCompleteTransfer(
    HCALL   hCall,
    HCALL   hConsultCall,
    LPHCALL lphConfCall,
    DWORD   dwTransferMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCompleteTransfer),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) lphConfCall,
            (ULONG_PTR) dwTransferMode,
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (dwTransferMode == LINETRANSFERMODE_TRANSFER)
    {
        //
        // lphCall should be ignored
        //

        funcArgs.Args[0] = 0; // (POSTPROCESSPROC) NULL;
    }
    else if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConfCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConfCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineCompleteTransfer");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_lineConfigDialog;


    if (lpszDeviceClass && TAPIIsBadStringPtrW (lpszDeviceClass, 256))
    {
        return LINEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_LINEID,
            &hDll,
            gszTUISPI_lineConfigDialog,
            &pfnTUISPI_lineConfigDialog

            )) == 0)
    {
        LOG((TL_TRACE, "Calling TUISPI_lineConfigDialog..."));

        lResult = (*pfnTUISPI_lineConfigDialog)(
            TUISPIDLLCallback,
            dwDeviceID,
            hwndOwner,
            lpszDeviceClass
            );

#if DBG
        {
            char szResult[32];

            LOG((TL_TRACE,
                "TUISPI_lineConfigDialog: result = %hs",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
            LOG((TL_TRACE,
                "TUISPI_lineConfigDialog: result = x%x",
                lResult
                ));
#endif

        FreeLibrary (hDll);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogA(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    PWSTR szTempString = NULL;
    LONG  lResult;


    if (lpszDeviceClass && IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempString = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);

    lResult = lineConfigDialogW (dwDeviceID, hwndOwner, szTempString);

    if (szTempString)
    {
        ClientFree (szTempString);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    return lineConfigDialogA(
               dwDeviceID,
               hwndOwner,
               lpszDeviceClass
               );
}


LONG
WINAPI
lineConfigDialogEditW(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCWSTR         lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING     lpDeviceConfigOut
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_lineConfigDialogEdit;


    if (lpszDeviceClass && TAPIIsBadStringPtrW (lpszDeviceClass, (UINT) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    if (IsBadReadPtr (lpDeviceConfigIn, dwSize))
    {
        return LINEERR_INVALPOINTER;
    }

    if (IsBadWritePtr (lpDeviceConfigOut, sizeof (VARSTRING)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpDeviceConfigOut->dwTotalSize < sizeof (VARSTRING))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (IsBadWritePtr (lpDeviceConfigOut, lpDeviceConfigOut->dwTotalSize))
    {
        return LINEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_LINEID,
            &hDll,
            gszTUISPI_lineConfigDialogEdit,
            &pfnTUISPI_lineConfigDialogEdit

            )) == 0)
    {
        LOG((TL_TRACE, "Calling TUISPI_lineConfigDialogEdit..."));

        lResult = (*pfnTUISPI_lineConfigDialogEdit)(
            TUISPIDLLCallback,
            dwDeviceID,
            hwndOwner,
            lpszDeviceClass,
            lpDeviceConfigIn,
            dwSize,
            lpDeviceConfigOut
            );

#if DBG
        {
            char szResult[32];

            LOG((TL_TRACE,
                "TUISPI_lineConfigDialogEdit: result = %hs",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
            LOG((TL_TRACE,
                "TUISPI_lineConfigDialogEdit: result = x%x",
                lResult
                ));
#endif
        FreeLibrary (hDll);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogEditA(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCSTR          lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING     lpDeviceConfigOut
    )
{
    PWSTR szTempString;
    LONG  lResult;


    if (lpszDeviceClass && IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempString = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);


    lResult = lineConfigDialogEditW(
        dwDeviceID,
        hwndOwner,
        szTempString,
        lpDeviceConfigIn,
        dwSize,
        lpDeviceConfigOut
        );

    if (szTempString)
    {
        ClientFree (szTempString);
    }

    return lResult;
}


LONG
WINAPI
lineConfigDialogEdit(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCSTR          lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING     lpDeviceConfigOut
    )
{
    return lineConfigDialogEditA(
                    dwDeviceID,
                    hwndOwner,
                    lpszDeviceClass,
                    lpDeviceConfigIn,
                    dwSize,
                    lpDeviceConfigOut
    );
}


LONG
WINAPI
lineConfigProvider(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    return (lineXxxProvider(
        gszTUISPI_providerConfig,   // func name
        NULL,                       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        dwPermanentProviderID,      // dwPermProviderID
        NULL                        // lpdwPermProviderID
        ));
}


LONG
WINAPI
lineCreateAgentW(
    HLINE       hLine,
    LPWSTR      lpszAgentID,
    LPWSTR      lpszAgentPIN,
    LPHAGENT    lphAgent
    )
{
    DWORD hPointer = 0;
    LONG  lResult;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCreateAgent),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpszAgentID,
            (ULONG_PTR) lpszAgentPIN,
            (ULONG_PTR) lphAgent
        },

        {
            Dword,
            Dword,
            lpszAgentID?lpszW:Dword,
            lpszAgentPIN?lpszW:Dword,
            Dword,
        }
    };

    if ( NULL == lpszAgentID )
    {
        funcArgs.Args[2] = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }
    else if ( TAPIIsBadStringPtrW(lpszAgentID, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAgentID in lineCreateAgentW"));
        return( LINEERR_INVALPOINTER );
    }

    if ( NULL == lpszAgentPIN )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }
    else if ( TAPIIsBadStringPtrW(lpszAgentPIN, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentW"));
        return( LINEERR_INVALPOINTER );
    }

    if (IsBadDwordPtr (lphAgent))
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lphAgent, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineCreateAgentW");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineCreateAgentA(
    HLINE       hLine,
    LPSTR       lpszAgentID,
    LPSTR       lpszAgentPIN,
    LPHAGENT    lphAgent
    )
{
    PWSTR       pwAgentID;
    PWSTR       pwAgentPIN;
    LONG        lResult;



    if (lpszAgentID)
    {
        if ( IsBadStringPtrA(lpszAgentID, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszAgentID in lineCreateAgentA"));
            return( LINEERR_INVALPOINTER );
        }
        pwAgentID = NotSoWideStringToWideString (lpszAgentID, (DWORD) -1);
    }
    else
    {
        pwAgentID = NULL;
    }

    if (lpszAgentPIN)
    {
        if ( IsBadStringPtrA(lpszAgentPIN, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentA"));
            return( LINEERR_INVALPOINTER );
        }
        pwAgentPIN = NotSoWideStringToWideString (lpszAgentPIN, (DWORD) -1);
    }
    else
    {
        pwAgentPIN = NULL;
    }

    lResult = lineCreateAgentW (hLine, pwAgentID, pwAgentPIN, lphAgent);

    if (pwAgentPIN)
    {
        ClientFree (pwAgentPIN);
    }

    if (pwAgentID)
    {
        ClientFree (pwAgentID);
    }

    return lResult;
}


LONG
WINAPI
lineCreateAgentSessionW(
    HLINE           hLine,
    HAGENT          hAgent,
    LPWSTR          lpszAgentPIN,
    DWORD           dwWorkingAddressID,
    LPGUID          lpGroupID,
    LPHAGENTSESSION lphAgentSession
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lCreateAgentSession),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) lpszAgentPIN,
            (ULONG_PTR) dwWorkingAddressID,
            (ULONG_PTR) lpGroupID,
            (ULONG_PTR) sizeof( GUID ),
            (ULONG_PTR) lphAgentSession
        },

        {
            Dword,
            Dword,
            Dword,
            lpszAgentPIN?lpszW:Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( NULL == lpszAgentPIN )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }
    else if ( TAPIIsBadStringPtrW(lpszAgentPIN, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentSessionW"));
        return( LINEERR_INVALPOINTER );
    }

    if (IsBadDwordPtr (lphAgentSession))
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lphAgentSession, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[7] = (ULONG_PTR)hPointer;


    lResult = DOFUNC (&funcArgs, "lineCreateAgentSessionW");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}

LONG
WINAPI
lineCreateAgentSessionA(
    HLINE           hLine,
    HAGENT          hAgent,
    LPSTR           lpszAgentPIN,
    DWORD           dwWorkingAddressID,
    LPGUID          lpGroupID,
    LPHAGENTSESSION lphAgentSession
    )
{
    LONG    lResult;
    PWSTR   pwAgentPIN;



    if (lpszAgentPIN)
    {
        if ( IsBadStringPtrA(lpszAgentPIN, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszAgentPIN in lineCreateAgentSessionA"));
            return( LINEERR_INVALPOINTER );
        }
        pwAgentPIN = NotSoWideStringToWideString (lpszAgentPIN, (DWORD) -1);
    }
    else
    {
        pwAgentPIN = NULL;
    }

    lResult = lineCreateAgentSessionW(
        hLine,
        hAgent,
        pwAgentPIN,
        dwWorkingAddressID,
        lpGroupID,
        lphAgentSession
        );

    if (pwAgentPIN)
    {
        ClientFree (pwAgentPIN);
    }

    return lResult;
}


LONG
WINAPI
lineDeallocateCall(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, lDeallocateCall),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };

    LOG((TL_TRACE,
        "lineDeallocateCall: enter on thread: 0x%08lx",
        GetCurrentThreadId()
        ));

    LOG((TL_INFO, "  hCall = 0x%08lx", hCall));

    return (DOFUNC (&funcArgs, "lineDeallocateCall"));
}


void
PASCAL
lineDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineDevSpecificPostProcess: enter"));

    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = (DWORD) pMsg->Param4;

        if (dwSize != 0)
        {
            LPBYTE  pParams = (LPBYTE) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

            // We don't need the handle to the pointer any more...
            DereferenceObject (ghHandleTable, pMsg->Param3, 2);

            try
            {
                if (gbNTVDMClient)
                {
#ifndef _WIN64

                    LPBYTE pParamsVDM = (LPBYTE) gpfnWOWGetVDMPointer(
                        (DWORD) pParams,
                        dwSize,
                        TRUE // fProtectedMode
                        );


                    if (pParamsVDM)
                    {
                        CopyMemory (pParamsVDM, (LPBYTE) (pMsg + 1), dwSize);
                    }
                    else
                    {
                        pMsg->Param2 = LINEERR_INVALPOINTER;
                    }
#endif
                }
                else
                {
                    CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                pMsg->Param2 = LINEERR_INVALPOINTER;
            }
        }
    }
}


LONG
WINAPI
lineDevSpecific(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lDevSpecific),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpParams, // pass the actual pointer (for post proc'g)
            (ULONG_PTR) lpParams, // pass data
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (gbNTVDMClient)
    {
#ifndef _WIN64
        if (!gpfnWOWGetVDMPointer  ||

            !(funcArgs.Args[5] = gpfnWOWGetVDMPointer(
                (DWORD)  lpParams,
                dwSize,
                TRUE // fProtectedMode
                )))
#endif
        {
            return LINEERR_OPERATIONFAILED;
        }
    }

    if ( !lpParams && dwSize > 0)
    {
        return LINEERR_INVALPOINTER;
    }

    if (dwSize > 0)
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineDevSpecific");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineDevSpecificFeature(
    HLINE   hLine,
    DWORD   dwFeature,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lDevSpecificFeature),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwFeature,
            (ULONG_PTR) lpParams, // pass the actual pointer (for post processing)
            (ULONG_PTR) lpParams, // pass data
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (gbNTVDMClient)
    {
#ifndef _WIN64
        if (!gpfnWOWGetVDMPointer ||

            !(funcArgs.Args[4] = gpfnWOWGetVDMPointer(
                (DWORD) lpParams,
                dwSize,
                TRUE // fProtectedMode
                )))
#endif
        {
            return LINEERR_OPERATIONFAILED;
        }
    }

    if ( !lpParams && dwSize > 0)
    {
        return LINEERR_INVALPOINTER;
    }

    if (dwSize > 0)
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineDevSpecificFeature");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineDialW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lDial),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if ( TAPIIsBadStringPtrW(lpszDestAddress, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineDialW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineDial"));
}


LONG
WINAPI
lineDialA(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if ( IsBadStringPtrA(lpszDestAddress, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineDialA"));
        return( LINEERR_INVALPOINTER );
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    if ( !szTempPtr )
    {
        LOG((TL_ERROR, "lineDialA: NotSoWideStringToWideString returned NULL"));
        return( LINEERR_INVALPOINTER );
    }

    lResult = lineDialW (hCall, szTempPtr, dwCountryCode);

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineDial(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    return lineDialA(
            hCall,
            lpszDestAddress,
            dwCountryCode
    );
}


LONG
WINAPI
lineDrop(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lDrop),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineDrop"));
}


LONG
WINAPI
lineForwardW(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 9, lForward),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) bAllAddresses,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpForwardList,
            (ULONG_PTR) dwNumRingsNoAnswer,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpForwardList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[7] = Dword;
        funcArgs.Args[7]     = TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[6] = (ULONG_PTR)hPointer;
    }

    lResult = DOFUNC (&funcArgs, "lineForwardW");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


// void
// LayDownNewString(
//     LPBYTE  pOldBase,
//     LPDWORD pdwOldSizeOffset,
//     LPBYTE  pNewBase,
//     LPDWORD pdwNewSizeOffset,
//     LPDWORD pdwNewOffset
//     )
// {
//     LPBYTE pOldString;
//     DWORD  dwNewStringSize;
//
//
//     pOldString =  pOldBase + *(pdwOldSizeOffset + 1);
//
//     *(pdwNewSizeOffset + 1) = *pdwNewOffset;
//
//     if ( IsBadStringPtr( pOldString, 256) )
//     {
//         return;
//     }
//
//     dwNewStringSize = sizeof(WCHAR) * MultiByteToWideChar(
//         GetACP(),
//         MB_PRECOMPOSED,
//         pOldString,
//         *pdwOldSizeOffset,
//         (PWSTR)(pNewBase + *(pdwNewSizeOffset + 1)),
//         *pdwOldSizeOffset
//         );
//
//     *pdwNewSizeOffset = dwNewStringSize;
//
//     *pdwNewOffset = (*pdwNewOffset + dwNewStringSize + 3) & 0xfffffffc;
// }


LONG
WINAPI
lineForwardA(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 9, lForward),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) bAllAddresses,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpForwardList,
            (ULONG_PTR) dwNumRingsNoAnswer,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpForwardList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[7] = Dword;
        funcArgs.Args[7]     = TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[6] = (ULONG_PTR)hPointer;
    }


    lResult = DOFUNC (&funcArgs, "lineForward");

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}



LONG
WINAPI
lineForward(
    HLINE   hLine,
    DWORD   bAllAddresses,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return lineForwardA(
             hLine,
             bAllAddresses,
             dwAddressID,
             lpForwardList,
             dwNumRingsNoAnswer,
             lphConsultCall,
             lpCallParams
    );
}


void
PASCAL
lineGatherDigitsWPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineGatherDigitsWPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param1 & (LINEGATHERTERM_BUFFERFULL | LINEGATHERTERM_CANCEL |
            LINEGATHERTERM_TERMDIGIT | LINEGATHERTERM_INTERTIMEOUT))
    {
        LPSTR   lpsDigits = (LPSTR) ReferenceObject (ghHandleTable, pMsg->Param2, 0);
        DWORD   dwNumDigits = (DWORD) pMsg->Param4;
#if NEWTAPI32
        LPBYTE   lpBuf = (LPBYTE)(((ULONG_PTR *)(pMsg + 1)) + 2);
#endif

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param2, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPSTR lpsDigitsVDM = (LPSTR) gpfnWOWGetVDMPointer(
                    (DWORD) lpsDigits,
                    dwNumDigits * sizeof(WCHAR),
                    TRUE // fProtectedMode
                    );


                if (lpsDigitsVDM)
                {
#if NEWTAPI32
                    CopyMemory(
                        lpsDigitsVDM,
                        lpBuf,
                        dwNumDigits * sizeof (WCHAR)
                        );
#else
                    CopyMemory(
                        lpsDigitsVDM,
                        pMsg + 1,
                        dwNumDigits * sizeof (WCHAR)
                        );
#endif

                }
                else
                {
                }
#endif
            }
            else
            {
                CopyMemory (lpsDigits, lpBuf, dwNumDigits * sizeof(WCHAR));
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // Don't do anything if we GPF
            //
        }
    }

    pMsg->Param2 = 0;
}


LONG
WINAPI
lineGatherDigitsW(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPWSTR  lpsDigits,
    DWORD   dwNumDigits,
    LPCWSTR lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    FUNC_ARGS funcArgs =
    {
#if NEWTAPI32
        MAKELONG (LINE_FUNC | SYNC | 9, lGatherDigits),
#else
        MAKELONG (LINE_FUNC | SYNC | 8, lGatherDigits),
#endif

        {
            (ULONG_PTR) GetFunctionIndex(lineGatherDigitsWPostProcess),
            (ULONG_PTR) hCall,
#if NEWTAPI32
            (ULONG_PTR) 0,  // this is the dwendtoendid for remotesp
#endif
            (ULONG_PTR) dwDigitModes,
            (ULONG_PTR) lpsDigits,
            (ULONG_PTR) dwNumDigits,
            (ULONG_PTR) lpszTerminationDigits,
            (ULONG_PTR) dwFirstDigitTimeout,
            (ULONG_PTR) dwInterDigitTimeout
        },

        {

            Dword,
            Dword,
#if NEWTAPI32
            Dword,
#endif
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    //
    // Note: we do the ptr check here rather than in DOFUNC because we're
    //       not passing any digits data within the context of this func
    //

    if (lpsDigits && IsBadWritePtr (lpsDigits, dwNumDigits * sizeof (WCHAR)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpszTerminationDigits == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //
#if NEWTAPI32
        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
#else
        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = TAPI_NO_DATA;
#endif
    }
    else
    {
        if ( TAPIIsBadStringPtrW(lpszTerminationDigits, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszDestAddress in lineGatherDigitsW"));
            return( LINEERR_INVALPOINTER );
        }
    }

    if ( lpsDigits )
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpsDigits, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;
    }
    else
    {
        funcArgs.Args[4] = (ULONG_PTR) 0;
    }


    lResult = DOFUNC (&funcArgs, "lineGatherDigits");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGatherDigitsPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineGatherDigitsPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param1 & (LINEGATHERTERM_BUFFERFULL | LINEGATHERTERM_CANCEL |
            LINEGATHERTERM_TERMDIGIT | LINEGATHERTERM_INTERTIMEOUT))
    {
        LPSTR   lpsDigits = (LPSTR) ReferenceObject (ghHandleTable, pMsg->Param2, 0);
        DWORD   dwNumDigits = (DWORD) pMsg->Param4;
        LPWSTR  pBuffer = (LPWSTR) (((ULONG_PTR *)(pMsg + 1)) + 2);


        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param2, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPSTR lpsDigitsVDM = (LPSTR) gpfnWOWGetVDMPointer(
                    (DWORD) lpsDigits,
                    dwNumDigits * sizeof(WCHAR),
                    TRUE // fProtectedMode
                    );


                if (lpsDigitsVDM)
                {
                      WideCharToMultiByte(
                          GetACP(),
                          0,
#if NEWTAPI32
                          pBuffer,
#else
                          (LPCWSTR)(pMsg + 1),
#endif
                          dwNumDigits,
                          lpsDigitsVDM,
                          dwNumDigits,
                          NULL,
                          NULL
                          );
                }
                else
                {
                }
#endif
            }
            else
            {
                  WideCharToMultiByte(
                      GetACP(),
                      0,
#if NEWTAPI32
                      pBuffer,
#else
                      (LPCWSTR)(pMsg + 1),
#endif
                      dwNumDigits,
                      lpsDigits,
                      dwNumDigits,
                      NULL,
                      NULL
                      );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // Don't do anything if we GPF
            //
        }
    }

    pMsg->Param2 = 0;
}


LONG
WINAPI
lineGatherDigitsA(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPSTR   lpsDigits,
    DWORD   dwNumDigits,
    LPCSTR  lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    LONG lResult;
    DWORD hPointer = 0;

    FUNC_ARGS funcArgs =
    {
#if NEWTAPI32
        MAKELONG (LINE_FUNC | SYNC | 9, lGatherDigits),
#else
        MAKELONG (LINE_FUNC | SYNC | 8, lGatherDigits),
#endif

        {
            (ULONG_PTR) GetFunctionIndex(lineGatherDigitsPostProcess),
            (ULONG_PTR) hCall,
#if NEWTAPI32
            (ULONG_PTR) 0,              // dw end to end id for remotesp
#endif
            (ULONG_PTR) dwDigitModes,
            (ULONG_PTR) lpsDigits,
            (ULONG_PTR) dwNumDigits,
//BJM 06/04/97  what was this?   0, // (DWORD) lpszTerminationDigits,
            (ULONG_PTR) lpszTerminationDigits,
            (ULONG_PTR) dwFirstDigitTimeout,
            (ULONG_PTR) dwInterDigitTimeout
        },

        {
            Dword,
            Dword,
#if NEWTAPI32
            Dword,
#endif
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    //
    // Note: we do the ptr check here rather than in DOFUNC because we're
    //       not passing any digits data within the context of this func
    //

    if (gbNTVDMClient == FALSE)
    {
        if (lpsDigits && IsBadWritePtr (lpsDigits, dwNumDigits))
        {
            return LINEERR_INVALPOINTER;
        }
    }

    if (lpszTerminationDigits == (LPCSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

#if NEWTAPI32
        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
#else
        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = TAPI_NO_DATA;
#endif
    }
    else
    {
        if ( IsBadStringPtrA(lpszTerminationDigits, (UINT)-1) )
        {
            LOG((TL_ERROR, "Bad lpszDestAddress in lineGatherDigitsA"));
            return( LINEERR_INVALPOINTER );
        }

#if NEWTAPI32
        funcArgs.Args[6] = (ULONG_PTR)  NotSoWideStringToWideString(
            lpszTerminationDigits,
            (DWORD) -1
            );
#else
        funcArgs.Args[5] = (ULONG_PTR)  NotSoWideStringToWideString(
            lpszTerminationDigits,
            (DWORD) -1
            );
#endif
    }

    if ( lpsDigits )
    {
        hPointer = NewObject (ghHandleTable, (PVOID)lpsDigits, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;
    }
    else
    {
        funcArgs.Args[4] = (ULONG_PTR) 0;
    }

    lResult = (DOFUNC (&funcArgs, "lineGatherDigits"));

    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

#if NEWTAPI32
    if ( funcArgs.Args[6] && (funcArgs.Args[6] != TAPI_NO_DATA) )
    {
       ClientFree( (LPVOID)funcArgs.Args[6] );
    }
#else
    if ( funcArgs.Args[5] && (funcArgs.Args[5] != TAPI_NO_DATA) )
    {
       ClientFree( (LPVOID)funcArgs.Args[5] );
    }
#endif

    return lResult;
}


LONG
WINAPI
lineGatherDigits(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPSTR   lpsDigits,
    DWORD   dwNumDigits,
    LPCSTR  lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{
    return lineGatherDigitsA(
              hCall,
              dwDigitModes,
              lpsDigits,
              dwNumDigits,
              lpszTerminationDigits,
              dwFirstDigitTimeout,
              dwInterDigitTimeout
    );
}


LONG
WINAPI
lineGenerateDigitsW(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCWSTR lpszDigits,
    DWORD   dwDuration
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGenerateDigits),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwDigitMode,
            (ULONG_PTR) lpszDigits,
            (ULONG_PTR) dwDuration,
            (ULONG_PTR) 0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    if (!lpszDigits)
    {
        funcArgs.Args[2]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineGenerateDigits"));
}


LONG
WINAPI
lineGenerateDigitsA(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCSTR  lpszDigits,
    DWORD   dwDuration
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGenerateDigits),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwDigitMode,
            (ULONG_PTR) 0,              // (DWORD) lpszDigits,
            (ULONG_PTR) dwDuration,
            (ULONG_PTR) 0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    if (lpszDigits)
    {
        if (IsBadStringPtrA (lpszDigits, (DWORD) -1))
        {
            return LINEERR_INVALPOINTER;
        }
        else if (!(funcArgs.Args[2] = (ULONG_PTR) NotSoWideStringToWideString(
                    lpszDigits,
                    (DWORD) -1
                    )))
        {
            return LINEERR_NOMEM;
        }
    }
    else
    {
        funcArgs.Args[2]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    lResult = (DOFUNC (&funcArgs, "lineGenerateDigits"));

    if (funcArgs.Args[2] != TAPI_NO_DATA)
    {
        ClientFree ((LPVOID) funcArgs.Args[2]);
    }

    return lResult;
}


LONG
WINAPI
lineGenerateDigits(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCSTR  lpszDigits,
    DWORD   dwDuration
    )
{
    return lineGenerateDigitsA(
              hCall,
              dwDigitMode,
              lpszDigits,
              dwDuration
    );
}


LONG
WINAPI
lineGenerateTone(
    HCALL   hCall,
    DWORD   dwToneMode,
    DWORD   dwDuration,
    DWORD   dwNumTones,
    LPLINEGENERATETONE const lpTones
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGenerateTone),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwToneMode,
            (ULONG_PTR) dwDuration,
            (ULONG_PTR) dwNumTones,
            (ULONG_PTR) TAPI_NO_DATA,   // (DWORD) lpTones,
            (ULONG_PTR) 0,              // dwNumTones * sizeof(LINEGENERATETONE)
            (ULONG_PTR) 0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,      // lpSet_SizeToFollow,
            Dword,      // Size
            Dword
        }
    };


    if (dwToneMode == LINETONEMODE_CUSTOM)
    {
        //
        // Set lpTones (& following Size arg) since in this case
        // they are valid args
        //

        funcArgs.ArgTypes[4] = lpSet_SizeToFollow;
        funcArgs.Args[4]     = (ULONG_PTR) lpTones;
        funcArgs.ArgTypes[5] = Size;
        funcArgs.Args[5]     = dwNumTones * sizeof(LINEGENERATETONE);
    }

    return (DOFUNC (&funcArgs, "lineGenerateTone"));
}


LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetAddressCaps),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) lpAddressCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetAddressCaps"));
}


LONG
WINAPI
lineGetAddressCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    LONG lResult;


    lResult = lineGetAddressCapsW(
        hLineApp,
        dwDeviceID,
        dwAddressID,
        dwAPIVersion,
        dwExtVersion,
        lpAddressCaps
        );

    if (lResult == 0)
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpAddressCaps,
            &lpAddressCaps->dwAddressSize
            );

        //
        // WideChar to multibyte translation of the completion message
        // array is somewhat problematic in that we can't be sure
        // the msgs will all be the same size after translation.  So
        // we'll translate them, pad the remainder of each msg entry
        // with 0's, and not bother touching any of the size or
        // offset values.
        //

        if (lpAddressCaps->dwNumCompletionMessages  &&
            lpAddressCaps->dwCompletionMsgTextEntrySize)
        {
            PWSTR   pStrW;
            PSTR    pStrA;
            DWORD   dwMsgSize = lpAddressCaps->dwCompletionMsgTextEntrySize,
                    dwNewSize, i;


            if ((pStrA = ClientAlloc (dwMsgSize)))
            {
                pStrW = (PWSTR) (((LPBYTE) lpAddressCaps) +
                    lpAddressCaps->dwCompletionMsgTextOffset);

                for (i = 0; i < lpAddressCaps->dwNumCompletionMessages; i++)
                {
                    dwNewSize = WideCharToMultiByte(
                        GetACP(),
                        0,
                        pStrW,
                        dwMsgSize / sizeof(WCHAR),
                        pStrA,
                        dwMsgSize,
                        NULL,
                        NULL
                        );

                    CopyMemory (pStrW, pStrA, dwNewSize);

                    ZeroMemory(
                        ((LPBYTE) pStrW) + dwNewSize,
                        dwMsgSize - dwNewSize
                        );

                    pStrW = (PWSTR) (((LPBYTE) pStrW) + dwMsgSize);
                }

                ClientFree (pStrA);
            }
            else
            {
                lpAddressCaps->dwNumCompletionMessages      =
                lpAddressCaps->dwCompletionMsgTextEntrySize =
                lpAddressCaps->dwCompletionMsgTextSize      =
                lpAddressCaps->dwCompletionMsgTextOffset    = 0;
            }
        }

        if (dwAPIVersion >= 0x00020000)
        {
            WideStringToNotSoWideString(
                    (LPBYTE)lpAddressCaps,
                    &lpAddressCaps->dwDeviceClassesSize
                    );
        }

    }

    return lResult;
}


LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
    return lineGetAddressCapsA(
                         hLineApp,
                         dwDeviceID,
                         dwAddressID,
                         dwAPIVersion,
                         dwExtVersion,
                         lpAddressCaps
    );
}


LONG
WINAPI
lineGetAddressIDW(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCWSTR lpsAddress,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetAddressID),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpdwAddressID,
            (ULONG_PTR) dwAddressMode,
            (ULONG_PTR) lpsAddress,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpDword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "lineGetAddressID"));
}


LONG
WINAPI
lineGetAddressIDA(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCSTR  lpsAddress,
    DWORD   dwSize
    )
{
    LONG    lResult;
    DWORD   dwNumChars;
    PWSTR   szTempPtr;


    //
    // Special case for dwSize = -1 (implies a NULL-terminated string as
    // far as IsBadStringPtrA is concerned)
    //

    if (dwSize == 0  ||  IsBadReadPtr (lpsAddress, dwSize))
    {
       LOG((TL_ERROR, "lineGetAddressID: Bad lpsAddress or dwSize"));
       return LINEERR_INVALPOINTER;
    }

    dwNumChars = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpsAddress,
        dwSize,
        NULL,
        0
        );

    if (!(szTempPtr = ClientAlloc (dwNumChars * sizeof (WCHAR))))
    {
        return LINEERR_NOMEM;
    }

    MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpsAddress,
        dwSize,
        szTempPtr,
        dwNumChars
        );

    lResult = lineGetAddressIDW(
        hLine,
        lpdwAddressID,
        dwAddressMode,
        szTempPtr,
        dwNumChars * sizeof (WCHAR)
        );

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineGetAddressID(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCSTR  lpsAddress,
    DWORD   dwSize
    )
{
    return lineGetAddressIDA(
              hLine,
              lpdwAddressID,
              dwAddressMode,
              lpsAddress,
              dwSize
    );
}


LONG
WINAPI
lineGetAddressStatusW(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetAddressStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAddressStatus
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetAddressStatus"));
}


LONG
WINAPI
lineGetAddressStatusA(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    LONG    lResult;
    PWSTR   szTempPtr = NULL;


    if ( IsBadWritePtr(lpAddressStatus, sizeof(LINEADDRESSSTATUS)) )
    {
       LOG((TL_ERROR, "lineGetAddressStatus: Bad lpAddressStatus pointer"));
       return LINEERR_INVALPOINTER;
    }

    lResult = lineGetAddressStatusW(
        hLine,
        dwAddressID,
        lpAddressStatus
        );


    if (lResult == 0)
    {
        DWORD         i;
        LPLINEFORWARD lplf;


        lplf = (LPLINEFORWARD) (((LPBYTE)lpAddressStatus) +
                                 lpAddressStatus->dwForwardOffset);

        for (i = 0; i < lpAddressStatus->dwForwardNumEntries;  i++, lplf++)
        {
            WideStringToNotSoWideString(
                (LPBYTE) lpAddressStatus,
                &(lplf->dwCallerAddressSize)
                );

            WideStringToNotSoWideString(
                (LPBYTE) lpAddressStatus,
                &(lplf->dwDestAddressSize)
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetAddressStatus(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
    return lineGetAddressStatusA(
              hLine,
              dwAddressID,
              lpAddressStatus
    );
}


LONG
WINAPI
lineGetAgentActivityListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentActivityList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentActivityList,// pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentActivityList // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentActivityList || IsBadWritePtr(lpAgentActivityList, sizeof(LINEAGENTACTIVITYLIST)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentActivityList->dwTotalSize < sizeof(LINEAGENTACTIVITYLIST))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentActivityList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetAgentActivityListW"));

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentActivityListAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentActivityListAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD                   dwSize  = (DWORD) pMsg->Param4;
        LPLINEAGENTACTIVITYLIST lpAgentActivityList = (LPLINEAGENTACTIVITYLIST)
                                    ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD                       dw, dwNumEntries;
            LPLINEAGENTACTIVITYENTRY    lplaae;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentActivityList, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lplaae = (LPLINEAGENTACTIVITYENTRY)(((LPBYTE)lpAgentActivityList) +
                lpAgentActivityList->dwListOffset);

            dwNumEntries = lpAgentActivityList->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lplaae++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpAgentActivityList,
                    &(lplaae->dwNameSize)
                    );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentActivityListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentActivityList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentActivityListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentActivityList,// pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentActivityList // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentActivityList )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentActivityList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentActivityListA");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lGetAgentCaps),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAppAPIVersion,
            (ULONG_PTR) lpAgentCaps,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentCaps         // pass data
        },

        {
            Dword,
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };

    DWORD hPointer = 0;
    LONG  lResult;


    if ( !lpAgentCaps || IsBadWritePtr(lpAgentCaps, sizeof(LINEAGENTCAPS)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentCaps->dwTotalSize < sizeof(LINEAGENTCAPS))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentCaps, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[5] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentCapsW");

    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentCapsAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentCapsAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD           dwSize  = (DWORD) pMsg->Param4;
        LPLINEAGENTCAPS lpAgentCaps = (LPLINEAGENTCAPS) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentCaps, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            WideStringToNotSoWideString(
                (LPBYTE) lpAgentCaps,
                &lpAgentCaps->dwAgentHandlerInfoSize
                );
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lGetAgentCaps),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentCapsAPostProcess),
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAppAPIVersion,
            (ULONG_PTR) lpAgentCaps,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentCaps         // pass data
        },

        {
            Dword,
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if ( !lpAgentCaps )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentCaps, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[5] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentCapsA");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentGroupListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList,   // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentGroupList    // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentGroupList || IsBadWritePtr(lpAgentGroupList, sizeof(LINEAGENTGROUPLIST)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentGroupList->dwTotalSize < sizeof(LINEAGENTGROUPLIST))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentGroupListW");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentGroupListAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentGroupListAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD                   dwSize = (DWORD) pMsg->Param4;
        LPLINEAGENTGROUPLIST    lpAgentGroupList = (LPLINEAGENTGROUPLIST)
                                    ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD                   dw, dwNumEntries;
            LPLINEAGENTGROUPENTRY   lplage;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentGroupList, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lplage = (LPLINEAGENTGROUPENTRY)(((LPBYTE) lpAgentGroupList) +
                lpAgentGroupList->dwListOffset);

            dwNumEntries = lpAgentGroupList->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lplage++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpAgentGroupList,
                    &(lplage->dwNameSize)
                    );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentGroupListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentGroupListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList,   // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentGroupList    // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if ( !lpAgentGroupList )
    {
        return LINEERR_INVALPOINTER;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentGroupListA");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentInfo(
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTINFO         lpAgentInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentInfo),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) lpAgentInfo,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentInfo || IsBadWritePtr(lpAgentInfo, sizeof(LINEAGENTINFO)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentInfo->dwTotalSize < sizeof(LINEAGENTINFO))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentInfo, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentInfo");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentSessionInfo(
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentSessionInfo),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgentSession,
            (ULONG_PTR) lpAgentSessionInfo, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentSessionInfo  // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentSessionInfo || IsBadWritePtr(lpAgentSessionInfo, sizeof(LINEAGENTSESSIONINFO)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentSessionInfo->dwTotalSize < sizeof(LINEAGENTSESSIONINFO))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentSessionInfo, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentSessionInfo");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentSessionList(
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTSESSIONLIST  lpAgentSessionList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentSessionList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) lpAgentSessionList, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentSessionList  // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentSessionList || IsBadWritePtr(lpAgentSessionList, sizeof(LINEAGENTSESSIONLIST)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentSessionList->dwTotalSize < sizeof(LINEAGENTSESSIONLIST))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }


    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentSessionList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentSessionList");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentStatus),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentStatus,      // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentStatus       // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpAgentStatus || IsBadWritePtr(lpAgentStatus, sizeof(LINEAGENTSTATUS)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpAgentStatus->dwTotalSize < sizeof(LINEAGENTSTATUS))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }


    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentStatus, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = DOFUNC (&funcArgs, "lineGetAgentStatusW");
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


void
PASCAL
lineGetAgentStatusAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetAgentStatusAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD               dwSize = (DWORD) pMsg->Param4;
        LPLINEAGENTSTATUS   lpAgentStatus = (LPLINEAGENTSTATUS) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD                   dw, dwNumEntries;
            LPLINEAGENTGROUPENTRY   lplage;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpAgentStatus, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lplage = (LPLINEAGENTGROUPENTRY) (((LPBYTE) lpAgentStatus) +
                lpAgentStatus->dwGroupListOffset);

            dwNumEntries = lpAgentStatus->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lplage++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE)lpAgentStatus,
                    &(lplage->dwNameSize)
                    );
            }

            WideStringToNotSoWideString(
                (LPBYTE)lpAgentStatus,
                &lpAgentStatus->dwActivitySize
                );

        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetAgentStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentStatus),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentStatusAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentStatus,      // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentStatus       // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpAgentStatus, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetAgentStatusA"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetAppPriorityW(
    LPCWSTR             lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGetAppPriority),

        {
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) dwMediaMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpdwPriority
        },

        {
            lpszW,      // app name
            Dword,      // media mode
            Dword,      // ext id (offset)
            Dword,      // ext id (size)
            Dword,      // request mode
            Dword,      // ext name total size
            lpDword     // lp pri
        }
    };


    if (dwMediaMode & 0xff000000)
    {
        if ((LPVOID) lpExtensionName == (LPVOID) lpdwPriority)
        {
            return LINEERR_INVALPOINTER;
        }


        //
        // We have to do some arg list munging here (adding an extra arg)
        //

        //
        // Set lpExtensionID, the following Size arg,
        // lpExtensionName, and the following MinSize
        // Type's and Value appropriately since they're
        // valid args in this case
        //

        funcArgs.ArgTypes[2] = lpSet_SizeToFollow;
        funcArgs.Args[2]     = (ULONG_PTR) lpExtensionID;
        funcArgs.ArgTypes[3] = Size;
        funcArgs.Args[3]     = (ULONG_PTR) sizeof (LINEEXTENSIONID);
        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpExtensionName;
    }

    if ( TAPIIsBadStringPtrW(lpszAppName, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetAppPriorityW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineGetAppPriority"));
}


LONG
WINAPI
lineGetAppPriorityA(
    LPCSTR              lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGetAppPriority),

        {
            (ULONG_PTR) 0,                  //  (DWORD) lpszAppName,
            (ULONG_PTR) dwMediaMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpdwPriority
        },

        {
            lpszW,      // app name
            Dword,      // media mode
            Dword,      // ext id (offset)
            Dword,      // ext id (size)
            Dword,      // request mode
            Dword,      // ext name total size
            lpDword     // lp pri
        }
    };


    if (dwMediaMode & 0xff000000)
    {
        //
        // We have to do some arg list munging here (adding an extra arg)
        //

        //
        // Set lpExtensionID, the following Size arg,
        // lpExtensionName, and the following MinSize
        // Type's and Value appropriately since they're
        // valid args in this case
        //

        funcArgs.ArgTypes[2] = lpSet_SizeToFollow;
        funcArgs.Args[2]     = (ULONG_PTR) lpExtensionID;
        funcArgs.ArgTypes[3] = Size;
        funcArgs.Args[3]     = (ULONG_PTR) sizeof (LINEEXTENSIONID);
        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpExtensionName;
    }

    if ( IsBadStringPtrA(lpszAppName, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetAppPriorityA"));
        return( LINEERR_INVALPOINTER );
    }

    funcArgs.Args[0] = (ULONG_PTR) NotSoWideStringToWideString(
        lpszAppName,
        (DWORD) -1
        );

    lResult = (DOFUNC (&funcArgs, "lineGetAppPriority"));

    if (funcArgs.Args[0])
    {
        ClientFree ((LPVOID) funcArgs.Args[0]);
    }

    return lResult;
}


LONG
WINAPI
lineGetAppPriority(
    LPCSTR              lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
    return lineGetAppPriorityA(
              lpszAppName,
              dwMediaMode,
              lpExtensionID,
              dwRequestMode,
              lpExtensionName,
              lpdwPriority
    );
}


LONG
WINAPI
lineGetCallInfoW(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallInfo),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallInfo
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetCallInfo"));
}


LONG
WINAPI
lineGetCallInfoA(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    LONG lResult;

    lResult = lineGetCallInfoW(
                    hCall,
                    lpCallInfo
                    );

    if ( 0 == lResult )
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCallerIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCallerIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCalledIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCalledIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwConnectedIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwConnectedIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectionIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectionIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectingIDSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwRedirectingIDNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwAppNameSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwDisplayableAddressSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCalledPartySize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwCommentSize)
            );

/*
        //
        // Note: per TNixon (3/21/96), none of the following are guaranteed
        //       to be in ascii format, so we don't want to convert them
        //

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwDisplaySize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwHighLevelCompSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwLowLevelCompSize)
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpCallInfo,
            &(lpCallInfo->dwChargingInfoSize)
            );
*/
    }

    return lResult;
}


LONG
WINAPI
lineGetCallInfo(
    HCALL   hCall,
    LPLINECALLINFO  lpCallInfo
    )
{
    return lineGetCallInfoA(
              hCall,
              lpCallInfo
    );
}


LONG
WINAPI
lineGetCallStatus(
    HCALL   hCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallStatus),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetCallStatus"));
}


LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL   hCall,
    LPLINECALLLIST  lpCallList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC| 2, lGetConfRelatedCalls),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallList
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetConfRelatedCalls"));
}


LONG
WINAPI
lineGetCountryW(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountry),

        {
            (ULONG_PTR) dwCountryID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpLineCountryList
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    if (
          ( TAPI_CURRENT_VERSION != dwAPIVersion )
        &&
          ( 0x00020001 != dwAPIVersion )
        &&
          ( 0x00020000 != dwAPIVersion )
        &&
          ( 0x00010004 != dwAPIVersion )
        &&
          ( 0x00010003 != dwAPIVersion )
       )
    {
       LOG((TL_ERROR, "lineGetCountryW - bad API version 0x%08lx", dwAPIVersion));
       return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetCountry"));
}


LONG
WINAPI
lineGetCountryA(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    LONG    lResult;
    DWORD   n;


    lResult = lineGetCountryW (dwCountryID, dwAPIVersion, lpLineCountryList);

    if (lResult == 0)
    {
        //
        // Go through the list of countries and change from Unicode to ANSI
        //

        LPLINECOUNTRYENTRY lpce;


        lpce = (LPLINECOUNTRYENTRY) (((LPBYTE) lpLineCountryList) +
            lpLineCountryList->dwCountryListOffset);

        for (n = 0; n < lpLineCountryList->dwNumCountries; n++, lpce++)
        {
            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwCountryNameSize
                );

            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwSameAreaRuleSize
                );

            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwLongDistanceRuleSize
                );

            WideStringToNotSoWideString(
                (LPBYTE)lpLineCountryList,
                &lpce->dwInternationalRuleSize
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetCountry(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    LPLINECOUNTRYLIST pTempList;
    LONG  lResult;
    DWORD             dwSize;

    if ( IsBadWritePtr(lpLineCountryList, sizeof(LINECOUNTRYLIST)) )
    {
        LOG((TL_ERROR,
            "lineGetCountry - bad pointer: lpLineCountryList [0x%p]",
            lpLineCountryList
            ));

        return LINEERR_INVALPOINTER;
    }

    if ( lpLineCountryList->dwTotalSize < sizeof(LINECOUNTRYLIST) )
    {
        LOG((TL_ERROR,
            "lineGetCountry - dwTotalSize less than sizeof(LINECOUNTRYLIST)"
            ));

        return LINEERR_INVALPOINTER;
    }

    dwSize = lpLineCountryList->dwTotalSize * 2;

    while (TRUE)
    {
        pTempList = ClientAlloc( dwSize );

        if (NULL == pTempList)
        {
            LOG((TL_ERROR,
                "lineGetCountry - alloc failed for [x%lx] bytes",
                dwSize
                ));

            return( LINEERR_NOMEM );
        }

        pTempList->dwTotalSize = dwSize;

        lResult = lineGetCountryA(
                                  dwCountryID,
                                  dwAPIVersion,
                                  pTempList
                                 );

        // hack - if the structure isn't big enough
        // realloc ourselves.
        if (pTempList->dwNeededSize <= pTempList->dwTotalSize)
        {
            break;
        }

        dwSize = pTempList->dwNeededSize;

        ClientFree( pTempList );

        pTempList = NULL;

    } // while


    if ( 0 == lResult )
    {
        DWORD dwNewUsedSize = 0; // = sizeof(LINECOUNTRYLIST);
        DWORD i;
        DWORD dwCurrentOffset = sizeof(LINECOUNTRYLIST) +
                    (sizeof(LINECOUNTRYENTRY) * pTempList->dwNumCountries);
        LPLINECOUNTRYENTRY pOldCountryEntry;
        LPLINECOUNTRYENTRY pNewCountryEntry;

        for (
              i=0;
              (i < pTempList->dwNumCountries);
              i++
            )
        {
            pOldCountryEntry = (LPLINECOUNTRYENTRY)
                ((PBYTE)(lpLineCountryList + 1) +
                    (i * sizeof(LINECOUNTRYENTRY)));

            pNewCountryEntry = (LPLINECOUNTRYENTRY)
                   ((PBYTE)(pTempList + 1) + (i * sizeof(LINECOUNTRYENTRY)));


            // check to see if there is enough space in the buffer.
            // add 1 because we're starting with an offset, and we
            // need to convert it to a size.
            dwNewUsedSize = dwCurrentOffset +
                            pNewCountryEntry->dwCountryNameSize +
                            pNewCountryEntry->dwSameAreaRuleSize +
                            pNewCountryEntry->dwLongDistanceRuleSize +
                            pNewCountryEntry->dwInternationalRuleSize +
                            1;

            if (lpLineCountryList->dwTotalSize < dwNewUsedSize)
            {
                // i is checked at the end, so
                // subtract one here, because we're
                // not actually copying this entry
//                i--;
                break;
            }

            pOldCountryEntry->dwCountryID =
                pNewCountryEntry->dwCountryID;
            pOldCountryEntry->dwCountryCode =
                pNewCountryEntry->dwCountryCode;
            pOldCountryEntry->dwNextCountryID =
                pNewCountryEntry->dwNextCountryID;
            pOldCountryEntry->dwCountryNameSize =
                pNewCountryEntry->dwCountryNameSize;
            pOldCountryEntry->dwSameAreaRuleSize =
                pNewCountryEntry->dwSameAreaRuleSize;
            pOldCountryEntry->dwLongDistanceRuleSize =
                pNewCountryEntry->dwLongDistanceRuleSize;
            pOldCountryEntry->dwInternationalRuleSize =
                pNewCountryEntry->dwInternationalRuleSize;


            //
            // Copy Country name
            //

            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwCountryNameOffset,
                pNewCountryEntry->dwCountryNameSize
                );

            pOldCountryEntry->dwCountryNameOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwCountryNameSize;


            //
            // Copy same area rule
            //
            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwSameAreaRuleOffset,
                pNewCountryEntry->dwSameAreaRuleSize
                );

            pOldCountryEntry->dwSameAreaRuleOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwSameAreaRuleSize;


            //
            // Copy long distance rule
            //
            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwLongDistanceRuleOffset,
                pNewCountryEntry->dwLongDistanceRuleSize
                );

            pOldCountryEntry->dwLongDistanceRuleOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwLongDistanceRuleSize;


            //
            // Copy international rule
            //
            CopyMemory(
                (PBYTE)lpLineCountryList + dwCurrentOffset,
                (PBYTE)pTempList + pNewCountryEntry->dwInternationalRuleOffset,
                pNewCountryEntry->dwInternationalRuleSize
                );

            pOldCountryEntry->dwInternationalRuleOffset = dwCurrentOffset;
            dwCurrentOffset += pNewCountryEntry->dwInternationalRuleSize;


//            dwNewUsedSize += sizeof(LINECOUNTRYENTRY) +
//                pOldCountryEntry->dwCountryNameSize       +
//                pOldCountryEntry->dwSameAreaRuleSize      +
//                pOldCountryEntry->dwLongDistanceRuleSize  +
//                pOldCountryEntry->dwInternationalRuleSize ;

        }


        //
        // Did we stop short?
        //
        if ( i < pTempList->dwNumCountries )
        {
            lpLineCountryList->dwNeededSize = pTempList->dwNeededSize;
        }
        else
        {
            lpLineCountryList->dwNeededSize = dwNewUsedSize;
            lpLineCountryList->dwUsedSize = dwNewUsedSize;
            lpLineCountryList->dwNumCountries = pTempList->dwNumCountries;
            lpLineCountryList->dwCountryListSize =
                pTempList->dwNumCountries * sizeof(LINECOUNTRYENTRY);
            lpLineCountryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);
        }
    }


    ClientFree( pTempList );


    return lResult;
}


LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP        hLineApp,
    DWORD           dwDeviceID,
    DWORD           dwAPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetDevCaps),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) lpLineDevCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        goto ExitHere;
    }

    lResult = (DOFUNC (&funcArgs, "lineGetDevCaps"));

    if ( 0 == lResult )
    {
        lpLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
lineGetDevCapsA(
    HLINEAPP        hLineApp,
    DWORD           dwDeviceID,
    DWORD           dwAPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    LONG lResult;

    lResult = lineGetDevCapsW(
                    hLineApp,
                    dwDeviceID,
                    dwAPIVersion,
                    dwExtVersion,
                    lpLineDevCaps
                    );

    if (lResult == 0)
    {
        lpLineDevCaps->dwStringFormat = STRINGFORMAT_ASCII;

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwProviderInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwSwitchInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwLineNameSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpLineDevCaps,
            &lpLineDevCaps->dwTerminalTextSize
            );

        if (lpLineDevCaps->dwTerminalTextEntrySize)
        {
            lpLineDevCaps->dwTerminalTextEntrySize /= sizeof(WCHAR);
        }

        if (dwAPIVersion >= 0x00020000)
        {
            WideStringToNotSoWideString(
                (LPBYTE) lpLineDevCaps,
                &lpLineDevCaps->dwDeviceClassesSize
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP        hLineApp,
    DWORD           dwDeviceID,
    DWORD           dwAPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
    )
{
    return lineGetDevCapsA(
                 hLineApp,
                 dwDeviceID,
                 dwAPIVersion,
                 dwExtVersion,
                 lpLineDevCaps
    );
}


LONG
WINAPI
lineGetDevConfigW(
    DWORD   dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCWSTR  lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetDevConfig),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };


    if ( lpszDeviceClass && TAPIIsBadStringPtrW(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetDevConfigW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineGetDevConfig"));
}


LONG
WINAPI
lineGetDevConfigA(
    DWORD   dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCSTR  lpszDeviceClass
    )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetDevConfig),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            0                        //  (DWORD) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };


    if ( lpszDeviceClass && IsBadStringPtrA(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetDevConfigA"));
        return( LINEERR_INVALPOINTER );
    }

    funcArgs.Args[2] = (ULONG_PTR) NotSoWideStringToWideString(
        lpszDeviceClass,
        (DWORD) -1
        );

    lResult = (DOFUNC (&funcArgs, "lineGetDevConfig"));

    if ((LPVOID)funcArgs.Args[2])
    {
        ClientFree ((LPVOID)funcArgs.Args[2]);
    }

    return lResult;
}


LONG
WINAPI
lineGetDevConfig(
    DWORD   dwDeviceID,
    LPVARSTRING lpDeviceConfig,
    LPCSTR  lpszDeviceClass
    )
{
    return lineGetDevConfigA(
              dwDeviceID,
              lpDeviceConfig,
              lpszDeviceClass
    );
}


LONG
WINAPI
lineGetGroupListA(
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lGetGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetAgentGroupListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpGroupList         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[2] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetGroupListA"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetGroupListW(
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lGetGroupList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpGroupList         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpGroupList || IsBadWritePtr(lpGroupList, sizeof(LINEAGENTGROUPLIST)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpGroupList->dwTotalSize < sizeof(LINEAGENTGROUPLIST))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpGroupList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[2] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetAgentGroupListW"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetIconW(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetIcon),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) lphIcon
        },

        {
            Dword,
            lpszW,
            lpDword
        }
    };


    if (IsBadDwordPtr ((LPDWORD) lphIcon))
    {
        LOG((TL_ERROR, "lphIcon is an invalid pointer [0x%p]!", lphIcon));
        return LINEERR_INVALPOINTER;
    }

    if (lpszDeviceClass == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
    }

    return DOFUNC (&funcArgs, "lineGetIcon");
}


LONG
WINAPI
lineGetIconA(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszDeviceClass  &&  IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        LOG((TL_ERROR,
            "Bad class name pointer passed into lineGetIconA [0x%p]",
            lpszDeviceClass
            ));

        return LINEERR_INVALPOINTER;
    }

    szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);

    lResult = lineGetIconW (dwDeviceID, szTempPtr, lphIcon);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}



LONG
WINAPI
lineGetIcon(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    return (lineGetIconA (dwDeviceID, lpszDeviceClass, lphIcon));
}


LONG
WINAPI
lineGetIDW(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR lpszDeviceClass
    )
{

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetID),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
            lpszW
        }
    };

    LPVARSTRING lpDeviceIDTemp = NULL;
    DWORD       dwNumDevices;
    DWORD       dwBufSize;
    DWORD       dwResult;
    DWORD       dwDeviceId1, dwDeviceId2;
    BOOL        bDoItAgain = FALSE;

    if (TAPIIsBadStringPtrW (lpszDeviceClass, (UINT)-1) ||
        lstrlenW(lpszDeviceClass) == 0)
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in lineGetIDW"));
        return( LINEERR_INVALPOINTER);
    }

    if ( IsBadWritePtr(lpDeviceID, sizeof(VARSTRING)) )
    {
        LOG((TL_ERROR, "Bad lpDeviceID in lineGetIDW"));
        return( LINEERR_INVALPOINTER);
    }

    //
    // if the request is for a wave device, call LGetIDEx
    //
    if (!_wcsicmp(lpszDeviceClass, L"wave/in")  ||
        !_wcsicmp(lpszDeviceClass, L"wave/out") ||
        !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
        !_wcsicmp(lpszDeviceClass, L"midi/out") ||
        !_wcsicmp(lpszDeviceClass, L"wave/in/out")
       )
    {
        dwNumDevices = _wcsicmp(lpszDeviceClass, L"wave/in/out") ? 1 : 2;
        dwBufSize = lpDeviceID->dwTotalSize + dwNumDevices * WAVE_STRING_ID_BUFFER_SIZE;
        do
        {
            //
            // Allocate additional memory for the device string ID
            //
            lpDeviceIDTemp = (LPVARSTRING)ClientAlloc (dwBufSize);
            if (!lpDeviceIDTemp)
            {
                LOG((TL_ERROR, "Failed to allocate memory"));
                return( LINEERR_NOMEM );
            }
            lpDeviceIDTemp->dwTotalSize = dwBufSize;
            funcArgs.Flags = MAKELONG (LINE_FUNC | SYNC | 6, lGetIDEx);
            funcArgs.Args[4] = (ULONG_PTR)lpDeviceIDTemp;

            //
            // Call LGetIDEx
            //
            dwResult = DOFUNC (&funcArgs, "lineGetIDEx");
            if (dwResult)
            {
                LOG((TL_ERROR, "lineGetIDEx failed with x%x", dwResult));
                ClientFree (lpDeviceIDTemp);
                return dwResult;
            }

            if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize && !bDoItAgain)
            {
                LOG((TL_INFO, 
                     "lineGetIDEx returned needed size (%d) bigger than total size (%d) -> need to realloc", 
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
                dwBufSize = lpDeviceIDTemp->dwNeededSize;
                ClientFree ( lpDeviceIDTemp );
                bDoItAgain = TRUE;
            }
            else
            {
                bDoItAgain = FALSE;
            }
            
        } while (bDoItAgain);

        if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize)
        {
            LOG((TL_ERROR, "needed size (%d) still bigger than total size (%d)",
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
            ClientFree (lpDeviceIDTemp);
            return LINEERR_OPERATIONFAILED;
        }

        //
        // Get the device ID from string ID
        //
        if (dwNumDevices == 1)
        {
            if (!WaveStringIdToDeviceId (
                (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset),
                lpszDeviceClass,
                &dwDeviceId1)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return LINEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
            }
        }
        else
        {
            LPWSTR szString1 = (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset);

            if (!WaveStringIdToDeviceId (
                    szString1,
                    L"wave/in",
                    &dwDeviceId1) ||
                !WaveStringIdToDeviceId (
                    (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset + wcslen(szString1)),
                    L"wave/out",
                    &dwDeviceId2)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return LINEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + 2 * sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = 2 * sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
                *((DWORD *)(lpDeviceID + 1) + 1) = dwDeviceId2;
            }
        }
        ClientFree (lpDeviceIDTemp);
        return NO_ERROR;
    }
    else
    {
        return (DOFUNC (&funcArgs, "lineGetID"));
    }

}


LONG
WINAPI
lineGetIDA(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCSTR  lpszDeviceClass
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDeviceClass, (UINT)-1) ||
        lstrlenA(lpszDeviceClass) == 0)
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in lineGetIDA"));
        return( LINEERR_INVALPOINTER);
    }

    szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);
    if (NULL == szTempPtr)
    {
        return LINEERR_NOMEM;
    }

    lResult = lineGetIDW(
        hLine,
        dwAddressID,
        hCall,
        dwSelect,
        lpDeviceID,
        szTempPtr
        );

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineGetID(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPVARSTRING lpDeviceID,
    LPCSTR  lpszDeviceClass
    )
{
    return lineGetIDA(
              hLine,
              dwAddressID,
              hCall,
              dwSelect,
              lpDeviceID,
              lpszDeviceClass
    );
}


LONG
WINAPI
lineGetLineDevStatusW(
    HLINE   hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpLineDevStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetLineDevStatus"));
}


LONG
WINAPI
lineGetLineDevStatusA(
    HLINE   hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    DWORD   dwAPIVersion;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpLineDevStatus,
            (ULONG_PTR) &dwAPIVersion
        },

        {
            Dword,
            lpGet_Struct,
            lpDword
        }
    };
    LONG lResult;


    if ((lResult = DOFUNC (&funcArgs, "lineGetLineDevStatus")) == 0)
    {
        if (dwAPIVersion >= 0x00020000)
        {
            DWORD           i;
            LPLINEAPPINFO   lplai;


            lplai = (LPLINEAPPINFO) (((LPBYTE)lpLineDevStatus) +
                lpLineDevStatus->dwAppInfoOffset);

            for (i = 0; i < lpLineDevStatus->dwNumOpens; i++, lplai++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwMachineNameSize
                    );

                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwUserNameSize
                    );

                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwModuleFilenameSize
                    );

                WideStringToNotSoWideString(
                    (LPBYTE) lpLineDevStatus,
                    &lplai->dwFriendlyNameSize
                    );
            }
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetLineDevStatus(
    HLINE           hLine,
    LPLINEDEVSTATUS lpLineDevStatus
    )
{
    return lineGetLineDevStatusA (hLine, lpLineDevStatus);
}


LONG
WINAPI
lineGetMessage(
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    )
{
    return (xxxGetMessage (TRUE, hLineApp, lpMessage, dwTimeout));
}


LONG
WINAPI
lineGetNewCalls(
    HLINE           hLine,
    DWORD           dwAddressID,
    DWORD           dwSelect,
    LPLINECALLLIST  lpCallList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetNewCalls),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) lpCallList
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetNewCalls"));
}


LONG
WINAPI
lineGetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPDWORD lpdwNumRings
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetNumRings),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpdwNumRings
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "lineGetNumRings"));
}


LONG
WINAPI
lineGetProviderListW(
    DWORD   dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    HANDLE      hProvidersMutex;
    LONG        lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetProviderList),

        {
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) lpProviderList
        },

        {
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT ("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        return LINEERR_OPERATIONFAILED;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);

    lResult = DOFUNC (&funcArgs, "lineGetProviderList");
    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }
    return lResult;
}


LONG
WINAPI
lineGetProviderListA(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    LONG lResult;


    lResult = lineGetProviderListW (dwAPIVersion, lpProviderList);

    if (lResult == 0)
    {
        DWORD               i;
        LPLINEPROVIDERENTRY lplpe;


        lplpe = (LPLINEPROVIDERENTRY) (((LPBYTE)lpProviderList) +
            lpProviderList->dwProviderListOffset);

        for (i = 0; i < lpProviderList->dwNumProviders; i++, lplpe++)
        {
            WideStringToNotSoWideString(
                (LPBYTE)lpProviderList,
                &(lplpe->dwProviderFilenameSize)
                );
        }
    }

    return lResult;
}


LONG
WINAPI
lineGetProviderList(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    return lineGetProviderListA (dwAPIVersion, lpProviderList);
}


LONG
WINAPI
lineGetProxyStatus(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAppAPIVersion,
    LPLINEPROXYREQUESTLIST  lpLineProxyReqestList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetProxyStatus),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAppAPIVersion,
            (ULONG_PTR) lpLineProxyReqestList
        },

        {
            hXxxApp,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAppAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetProxyStatus"));
}


LONG
WINAPI
lineGetQueueInfo(
    HLINE               hLine,
    DWORD               dwQueueID,
    LPLINEQUEUEINFO     lpLineQueueInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetQueueInfo),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwQueueID,
            (ULONG_PTR) lpLineQueueInfo,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpLineQueueInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpLineQueueInfo || IsBadWritePtr(lpLineQueueInfo, sizeof(LINEQUEUEINFO)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpLineQueueInfo->dwTotalSize < sizeof(LINEQUEUEINFO))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpLineQueueInfo, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[3] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetQueueInfo"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}

void
PASCAL
lineGetQueueListAPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineGetQueueListAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD           dwSize  = (DWORD) pMsg->Param4;
        LPLINEQUEUELIST lpQueueList = (LPLINEQUEUELIST) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            DWORD               dw, dwNumEntries;
            LPLINEQUEUEENTRY    lpqe;


            //
            // Note: the agent APIs are not exposed to 16-bit apps, so
            // there's no reason to special case on gbNTVDMClient like
            // lineDevSpecificPostProcess does
            //

            CopyMemory (lpQueueList, (LPBYTE) (pMsg + 1), dwSize);


            //
            // Now some unicode->ascii post processing on embedded strings
            //

            lpqe = (LPLINEQUEUEENTRY)(((LPBYTE)lpQueueList) +
                lpQueueList->dwListOffset);

            dwNumEntries = lpQueueList->dwNumEntries;

            for (dw = 0; dw < dwNumEntries; dw++, lpqe++)
            {
                WideStringToNotSoWideString(
                    (LPBYTE) lpQueueList,
                    &(lpqe->dwNameSize)
                    );
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineGetQueueListA(
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lGetQueueList),

        {
            (ULONG_PTR) GetFunctionIndex(lineGetQueueListAPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupID,
            (ULONG_PTR) sizeof( GUID ),
            (ULONG_PTR) lpQueueList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpQueueList         // pass data
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    hPointer = NewObject (ghHandleTable, (PVOID)lpQueueList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetQueueListA"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetQueueListW(
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lGetQueueList),

        {
            (ULONG_PTR) GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupID,
            (ULONG_PTR) sizeof( GUID ),
            (ULONG_PTR) lpQueueList,        // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpQueueList         // pass data
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword,
            lpGet_Struct,
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if ( !lpQueueList || IsBadWritePtr(lpQueueList, sizeof(LINEQUEUELIST)) )
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpQueueList->dwTotalSize < sizeof(LINEQUEUELIST))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    hPointer = NewObject (ghHandleTable, (PVOID)lpQueueList, NULL);
    if (0 == hPointer)
    {
        return LINEERR_NOMEM;
    }
    funcArgs.Args[4] = (ULONG_PTR)hPointer;

    lResult = (DOFUNC (&funcArgs, "lineGetQueueList"));
    if (0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineGetRequestW(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPVOID      lpRequestBuffer
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetRequest),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) lpRequestBuffer,
            (ULONG_PTR) 0
        },

        {
            hXxxApp,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMAKECALLW);
    }
    else if (dwRequestMode == LINEREQUESTMODE_MEDIACALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMEDIACALLW);
    }

    return (DOFUNC (&funcArgs, "lineGetRequest"));
}


LONG
WINAPI
lineGetRequestA(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPVOID      lpRequestBuffer
    )
{
    LONG lResult;
    LPVOID pszTempPtr = NULL;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetRequest),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) 0,                //  (DWORD) lpRequestBuffer,
            (ULONG_PTR) 0
        },

        {
            hXxxApp,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (IsBadWritePtr(
            lpRequestBuffer,
            (dwRequestMode == LINEREQUESTMODE_MAKECALL ?
                sizeof (LINEREQMAKECALL) : sizeof (LINEREQMEDIACALL))
            ))
    {
        return LINEERR_INVALPOINTER;
    }

    if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMAKECALLW);

        pszTempPtr = ClientAlloc( sizeof(LINEREQMAKECALLW) );
        if (NULL == pszTempPtr)
        {
            return LINEERR_NOMEM;
        }
    }
    else if (dwRequestMode == LINEREQUESTMODE_MEDIACALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = (ULONG_PTR) sizeof(LINEREQMEDIACALLW);

        pszTempPtr = ClientAlloc( sizeof(LINEREQMEDIACALLW) );
        if (NULL == pszTempPtr)
        {
            return LINEERR_NOMEM;
        }
    }

    funcArgs.Args[2] = (ULONG_PTR) pszTempPtr;


    lResult = (DOFUNC (&funcArgs, "lineGetRequest"));


    if ( 0 == lResult )
    {
        if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
        {
            LPLINEREQMAKECALLW lplrmc = pszTempPtr;

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szDestAddress,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szDestAddress,
                TAPIMAXDESTADDRESSSIZE,
                NULL,
                NULL
                );

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szAppName,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szAppName,
                TAPIMAXAPPNAMESIZE,
                NULL,
                NULL
                );

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szCalledParty,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szCalledParty,
                TAPIMAXCALLEDPARTYSIZE,
                NULL,
                NULL
                );

            WideCharToMultiByte(
                GetACP(),
                0,
                lplrmc->szComment,
                -1,
                ((LPLINEREQMAKECALL)lpRequestBuffer)->szComment,
                TAPIMAXCOMMENTSIZE,
                NULL,
                NULL
                );

        }
        else
        {

        // We don't currently support this...

//typedef struct linereqmediacallW_tag
//{
//    HWND        hWnd;
//    WPARAM      wRequestID;
//    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
//    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
//    DWORD       dwSize;
//    DWORD       dwSecure;
//    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
//    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
//    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
//    WCHAR       szComment[TAPIMAXCOMMENTSIZE];
//}

        }
    }


    if ( pszTempPtr )
    {
        ClientFree( pszTempPtr );
    }

    return lResult;
}


LONG
WINAPI
lineGetRequest(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPVOID      lpRequestBuffer
    )
{
    return lineGetRequestA (hLineApp, dwRequestMode, lpRequestBuffer);
}


LONG
WINAPI
lineGetStatusMessages(
    HLINE       hLine,
    LPDWORD     lpdwLineStates,
    LPDWORD     lpdwAddressStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetStatusMessages),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpdwLineStates,
            (ULONG_PTR) lpdwAddressStates
        },

        {
            Dword,
            lpDword,
            lpDword
        }
    };


    if (lpdwLineStates == lpdwAddressStates)
    {
        return LINEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "lineGetStatusMessages"));
}



LONG
WINAPI
lineHandoffW(
    HCALL   hCall,
    LPCWSTR lpszFileName,
    DWORD   dwMediaMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lHandoff),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszFileName,
            (ULONG_PTR) dwMediaMode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if (lpszFileName == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    return (DOFUNC (&funcArgs, "lineHandoff"));
}


LONG
WINAPI
lineHandoffA(
    HCALL   hCall,
    LPCSTR  lpszFileName,
    DWORD   dwMediaMode
    )
{
    LONG    lResult;
    LPWSTR  pTempPtr;


    if (lpszFileName)
    {
        if (IsBadStringPtrA (lpszFileName, (DWORD) -1))
        {
            return LINEERR_INVALPOINTER;
        }
        else if (!(pTempPtr = NotSoWideStringToWideString(
                        lpszFileName,
                        (DWORD) -1
                        )))
        {
            return LINEERR_NOMEM;
        }
    }
    else
    {
        pTempPtr = NULL;
    }

    lResult = lineHandoffW (hCall, pTempPtr, dwMediaMode);

    if (pTempPtr)
    {
        ClientFree (pTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineHandoff(
    HCALL   hCall,
    LPCSTR  lpszFileName,
    DWORD   dwMediaMode
    )
{
    return lineHandoffA (hCall, lpszFileName, dwMediaMode);
}


LONG
WINAPI
lineHold(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lHold),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineHold"));
}


PWSTR
PASCAL
MultiToWide(
    LPCSTR  lpStr
    )
{
    DWORD dwSize;
    PWSTR szTempPtr;


    dwSize = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpStr,
        -1,
        NULL,
        0
        );

    if ((szTempPtr = ClientAlloc ((dwSize + 1) * sizeof (WCHAR))))
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpStr,
            -1,
            szTempPtr,
            dwSize + 1
            );
    }

    return szTempPtr;
}


// Don't need this 'cause 2.0 apps must use lineInitializeEx()
//
//LONG
//WINAPI
//lineInitializeW(
//    LPHLINEAPP      lphLineApp,
//    HINSTANCE       hInstance,
//    LINECALLBACK    lpfnCallback,
//    LPCWSTR         lpszAppName,
//    LPDWORD         lpdwNumDevs
//    )
//{
//    return (xxxInitialize(
//        TRUE,
//        (LPVOID) lphLineApp,
//        hInstance,
//        lpfnCallback,
//        lpszAppName,
//        lpdwNumDevs,
//        NULL,
//        NULL
//#if DBG
//        ,"lineInitializeW"
//#endif
//        ));
//}


LONG
WINAPI
lineInitialize(
    LPHLINEAPP      lphLineApp,
    HINSTANCE       hInstance,
    LINECALLBACK    lpfnCallback,
    LPCSTR          lpszAppName,
    LPDWORD         lpdwNumDevs
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszAppName )
    {
        if ( IsBadStringPtrA (lpszAppName, (DWORD) -1))
        {
           LOG((TL_ERROR, "lineInitialize: Bad lpszAddName pointer"));
           return LINEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    }
    else
    {
        szTempPtr = NULL;
    }


    //
    // NOTE: the hack below for the lpInitExParam is for 16-bit apps,
    //       since the lpszAppName really points at a
    //       <friendly name>\0<module name>\0 string and we need the
    //       module name in xxxInitialize()
    //

    lResult = (xxxInitialize(
        TRUE,
        (LPVOID) lphLineApp,
        hInstance,
        lpfnCallback,
        szTempPtr,
        lpdwNumDevs,
        NULL,
#ifdef _WIN64
        NULL
#else
        (LPLINEINITIALIZEEXPARAMS)
            (((DWORD) lpfnCallback & 0xffff0000) == 0xffff0000 ?
                lpszAppName : NULL)
#endif
#if DBG
        ,"lineInitialize"
#endif
        ));

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineInitializeExW(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{

    if (IsBadDwordPtr (lpdwAPIVersion))
    {
        LOG((TL_ERROR,
            "lineInitializeExW: bad lpdwAPIVersion pointer (x%p)",
            lpdwAPIVersion
            ));

        return LINEERR_INVALPOINTER;
    }

    return (xxxInitialize(
        TRUE,
        (LPVOID) lphLineApp,
        hInstance,
        lpfnCallback,
        lpszFriendlyAppName,
        lpdwNumDevs,
        lpdwAPIVersion,
        (LPVOID) lpLineInitializeExParams
#if DBG
        ,"lineInitializeExW"
#endif
        ));
}


LONG
WINAPI
lineInitializeExA(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{
    LONG    lResult;
    WCHAR  *pszFriendlyAppNameW;


    if (lpszFriendlyAppName)
    {
        if (IsBadStringPtrA (lpszFriendlyAppName, (DWORD) -1))
        {
            LOG((TL_ERROR,
                "lineInitializeEx: bad lpszFriendlyAppName (x%p)",
                lpszFriendlyAppName
                ));

            return LINEERR_INVALPOINTER;
        }

        if (!(pszFriendlyAppNameW = MultiToWide (lpszFriendlyAppName)))
        {
            return LINEERR_INVALPOINTER;
        }
    }
    else
    {
        pszFriendlyAppNameW = NULL;
    }

    lResult = lineInitializeExW(
        lphLineApp,
        hInstance,
        lpfnCallback,
        pszFriendlyAppNameW,
        lpdwNumDevs,
        lpdwAPIVersion,
        lpLineInitializeExParams
        );

    if (pszFriendlyAppNameW)
    {
        ClientFree (pszFriendlyAppNameW);
    }

    return lResult;
}


void
PASCAL
lineMakeCallPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineMakeCallPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        HCALL   hCall   = (HCALL) pMsg->Param3;
        LPHCALL lphCall = (LPDWORD) ReferenceObject (ghHandleTable, pMsg->Param4, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param4, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPHCALL lphCallVDM = (LPHCALL) gpfnWOWGetVDMPointer (
                    (DWORD) lphCall,
                    sizeof(HCALL),
                    TRUE // fProtectedMode
                    );


                if (lphCallVDM)
                {
                    *lphCallVDM = hCall;
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                *lphCall = hCall;
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineMakeCallW(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lMakeCall),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    lResult = (DOFUNC (&funcArgs, "lineMakeCall"));
    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineMakeCallA(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    LONG    lResult;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lMakeCall),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) 0,
            (ULONG_PTR) dwCountryCode,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;


    LOG((TL_TRACE, "Entering lineMakeCallA"));
    LOG((TL_INFO, "  hLine= 0x%08lx", hLine));

    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }
    else if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1))
    {
       LOG((TL_ERROR, "lineMakeCall: Bad lpszDestAddress pointer"));
       return LINEERR_INVALPOINTER;
    }
    else  if (!(funcArgs.Args[3] = (ULONG_PTR)  NotSoWideStringToWideString(
                    lpszDestAddress,
                    (DWORD) -1
                    )))
    {
       return LINEERR_OPERATIONFAILED; // really either NOMEM. INVALPOINTER
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            lResult = LINEERR_NOMEM;
            goto _return;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    lResult = DOFUNC (&funcArgs, "lineMakeCall");
    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

_return:
    if (funcArgs.Args[3] != (ULONG_PTR) TAPI_NO_DATA)
    {
       ClientFree ((LPVOID) funcArgs.Args[3]);
    }

    return lResult;
}


LONG
WINAPI
lineMakeCall(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    return lineMakeCallA(
                hLine,
                lphCall,
                lpszDestAddress,
                dwCountryCode,
                lpCallParams
                );
}


LONG
WINAPI
lineMonitorDigits(
    HCALL   hCall,
    DWORD   dwDigitModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorDigits),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwDigitModes
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineMonitorDigits"));
}


LONG
WINAPI
lineMonitorMedia(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorMedia),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwMediaModes
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineMonitorMedia"));
}


LONG
WINAPI
lineMonitorTones(
    HCALL   hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD   dwNumEntries
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lMonitorTones),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpToneList,
            (ULONG_PTR) dwNumEntries * sizeof(LINEMONITORTONE),
            (ULONG_PTR) 0                   // dwToneListID, remotesp only
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword
        }
    };


    if (!lpToneList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineMonitorTones"));
}


LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lNegotiateAPIVersion),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPILowVersion,
            (ULONG_PTR) dwAPIHighVersion,
            (ULONG_PTR) lpdwAPIVersion,
            (ULONG_PTR) lpExtensionID,
            (ULONG_PTR) sizeof(LINEEXTENSIONID)
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        }
    };

    if (dwAPIHighVersion > TAPI_CURRENT_VERSION)
    {
        funcArgs.Args[3] = TAPI_CURRENT_VERSION;
    }

    if ((LPVOID) lpdwAPIVersion == (LPVOID) lpExtensionID)
    {
        return LINEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "lineNegotiateAPIVersion"));
}


LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtLowVersion,
    DWORD       dwExtHighVersion,
    LPDWORD     lpdwExtVersion
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lNegotiateExtVersion),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtLowVersion,
            (ULONG_PTR) dwExtHighVersion,
            (ULONG_PTR) lpdwExtVersion
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpDword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineNegotiateExtVersion"));
}


LONG
WINAPI
lineOpenW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    LPHLINE                 lphLine,
    DWORD                   dwAPIVersion,
    DWORD                   dwExtVersion,
    DWORD_PTR               dwCallbackInstance,
    DWORD                   dwPrivileges,
    DWORD                   dwMediaModes,
    LPLINECALLPARAMS const  lpCallParams
    )
{
    LONG lResult;
    DWORD hCallbackInstance = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lOpen),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lphLine,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) dwCallbackInstance,
            (ULONG_PTR) dwPrivileges,
            (ULONG_PTR) dwMediaModes,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA,       // dwAsciiCallParamsCodePage
            (ULONG_PTR) 0,
            (ULONG_PTR) 0                   // LINEOPEN_PARAMS.hRemoteLine
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            Dword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    if (dwDeviceID != LINEMAPPER &&
        !(dwPrivileges &
            (LINEOPENOPTION_PROXY|LINEOPENOPTION_SINGLEADDRESS)))
    {
        //
        // Reset Arg & ArgType so no inval ptr err,
        // & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (0 != dwCallbackInstance)
    {
        hCallbackInstance = NewObject (ghHandleTable, (PVOID)dwCallbackInstance, (PVOID)UIntToPtr(hLineApp));
        if (0 == hCallbackInstance)
        {
            return LINEERR_NOMEM;
        }

        funcArgs.Args[5] = hCallbackInstance;
    }

    lResult = (DOFUNC (&funcArgs, "lineOpen"));


    //
    // If we we managed a successful LINEMAPPER & there's an LCR hook
    // for this function then call it to allow it to override our
    // results if it wants to. (One good thing about calling it after
    // the fact is that we leverage our param checking.)
    //

    if (dwDeviceID == LINEMAPPER  &&
        lResult == 0  &&
        IsLeastCostRoutingEnabled()  &&
        pfnLineOpenWLCR)
    {
        lResult = (*pfnLineOpenWLCR)(
            hLineApp,
            dwDeviceID,
            lphLine,
            dwAPIVersion,
            dwExtVersion,
            dwCallbackInstance,
            dwPrivileges,
            dwMediaModes,
            lpCallParams
            );
    }

#if DBG

    if ( !IsBadWritePtr( (LPBYTE)lphLine, 4 ) )
    {
        LOG((TL_TRACE,
            "Returning from lineOpenW, *lphLine = 0x%08lx",
            *lphLine
            ));
    }

    LOG((TL_TRACE, "Returning from lineOpenW, retcode = 0x%08lx", lResult));

#endif

    if (lResult && 0 != hCallbackInstance)
    {
        DereferenceObject (ghHandleTable, hCallbackInstance, 1);
    }

    return( lResult );
}


LONG
WINAPI
lineOpenA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    LPHLINE                 lphLine,
    DWORD                   dwAPIVersion,
    DWORD                   dwExtVersion,
    DWORD_PTR               dwCallbackInstance,
    DWORD                   dwPrivileges,
    DWORD                   dwMediaModes,
    LPLINECALLPARAMS const  lpCallParams
    )
{
    LONG lResult;
    DWORD hCallbackInstance = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lOpen),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lphLine,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) dwCallbackInstance,
            (ULONG_PTR) dwPrivileges,
            (ULONG_PTR) dwMediaModes,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP(),           // dwAsciiCallParamsCodePage
            (ULONG_PTR) 0,
            (ULONG_PTR) 0                   // LINEOPEN_PARAMS.hRemoteLine
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            Dword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    if (dwDeviceID != LINEMAPPER &&
        !(dwPrivileges & (LINEOPENOPTION_PROXY|LINEOPENOPTION_SINGLEADDRESS)))
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (0 != dwCallbackInstance)
    {
        hCallbackInstance = NewObject (ghHandleTable, (PVOID)dwCallbackInstance, (PVOID)UIntToPtr(hLineApp));
        if (0 == hCallbackInstance)
        {
            return LINEERR_NOMEM;
        }

        funcArgs.Args[5] = hCallbackInstance;
    }

    lResult = (DOFUNC (&funcArgs, "lineOpen"));

    //
    // If we we managed a successful LINEMAPPER & there's an LCR hook
    // for this function then call it to allow it to override our
    // results if it wants to. (One good thing about calling it after
    // the fact is that we leverage our param checking.)
    //

    if (dwDeviceID == LINEMAPPER  &&
        lResult == 0  &&
        IsLeastCostRoutingEnabled()  &&
        pfnLineOpenALCR)
    {
        lResult = (*pfnLineOpenALCR)(
            hLineApp,
            dwDeviceID,
            lphLine,
            dwAPIVersion,
            dwExtVersion,
            dwCallbackInstance,
            dwPrivileges,
            dwMediaModes,
            lpCallParams
            );
    }

#if DBG

    if ( !IsBadWritePtr( (LPBYTE)lphLine, 4 ) )
    {
        LOG((TL_TRACE,
            "Returning from lineOpenA, *lphLine = 0x%08lx",
            *lphLine
            ));
    }

    LOG((TL_TRACE, "Returning from lineOpenA, retcode = 0x%08lx", lResult));

#endif

    if (lResult && 0 != hCallbackInstance)
    {
        DereferenceObject (ghHandleTable, hCallbackInstance, 1);
    }

    return( lResult );
}


LONG
WINAPI
lineOpen(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    LPHLINE                 lphLine,
    DWORD                   dwAPIVersion,
    DWORD                   dwExtVersion,
    DWORD_PTR               dwCallbackInstance,
    DWORD                   dwPrivileges,
    DWORD                   dwMediaModes,
    LPLINECALLPARAMS const  lpCallParams
    )
{
    return lineOpenA(
                hLineApp,
                dwDeviceID,
                lphLine,
                dwAPIVersion,
                dwExtVersion,
                dwCallbackInstance,
                dwPrivileges,
                dwMediaModes,
                lpCallParams
                );
}


void
PASCAL
lineParkAPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineParkAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD       dwSize = (DWORD) pMsg->Param4;
        LPVARSTRING pNonDirAddress = (LPVARSTRING) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPVARSTRING pNonDirAddressVDM = (LPVARSTRING)
                    gpfnWOWGetVDMPointer(
                        (DWORD) pNonDirAddress,
                        dwSize,
                        TRUE // fProtectedMode
                        );


                if (pNonDirAddressVDM)
                {
                    CopyMemory(
                        pNonDirAddressVDM,
                        (LPBYTE) (pMsg + 1),
                        dwSize
                        );

                    if (pNonDirAddressVDM->dwUsedSize >= sizeof (VARSTRING)  &&
                        pNonDirAddressVDM->dwStringSize != 0)
                    {
                        TCHAR     *p;
                        DWORD     dwStringSize =
                                      pNonDirAddressVDM->dwStringSize /
                                          sizeof (WCHAR);


                        if ((p = ClientAlloc(pNonDirAddressVDM->dwStringSize)))
                        {
                            pNonDirAddressVDM->dwStringFormat =
                                STRINGFORMAT_ASCII;
                            pNonDirAddressVDM->dwStringSize =
                                dwStringSize;

                            WideCharToMultiByte(
                                GetACP(),
                                0,
                                (LPCWSTR) (((LPBYTE) pNonDirAddressVDM) +
                                    pNonDirAddressVDM->dwStringOffset),
                                dwStringSize,
                                (LPSTR) p,
                                dwStringSize,
                                NULL,
                                NULL
                                );

                            CopyMemory(
                                (((LPBYTE) pNonDirAddressVDM) +
                                    pNonDirAddressVDM->dwStringOffset),
                                p,
                                dwStringSize
                                );

                            ClientFree (p);
                        }
                    }
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                CopyMemory (pNonDirAddress, (LPBYTE) (pMsg + 1), dwSize);

                if (pNonDirAddress->dwUsedSize >= sizeof (VARSTRING)  &&
                    pNonDirAddress->dwStringSize != 0)
                {
                      TCHAR     *p;
                      DWORD     dwStringSize = pNonDirAddress->dwStringSize /
                                    sizeof (WCHAR);


                      if ((p = ClientAlloc (pNonDirAddress->dwStringSize)))
                      {
                          pNonDirAddress->dwStringFormat = STRINGFORMAT_ASCII;
                          pNonDirAddress->dwStringSize = dwStringSize;

                          WideCharToMultiByte(
                              GetACP(),
                              0,
                              (LPCWSTR) (((LPBYTE) pNonDirAddress) +
                                  pNonDirAddress->dwStringOffset),
                              dwStringSize,
                              (LPSTR) p,
                              dwStringSize,
                              NULL,
                              NULL
                              );

                          CopyMemory(
                              (((LPBYTE) pNonDirAddress) +
                                  pNonDirAddress->dwStringOffset),
                              p,
                              dwStringSize
                              );

                          ClientFree (p);
                      }
                }
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineParkW(
    HCALL       hCall,
    DWORD       dwParkMode,
    LPCWSTR     lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPark),

        {
            (ULONG_PTR) 0,                  // post process proc
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwParkMode,
            (ULONG_PTR) TAPI_NO_DATA,       // lpszDirAddress,
            (ULONG_PTR) lpNonDirAddress,    // pass ptr as Dword for post proc
            (ULONG_PTR) TAPI_NO_DATA,       // lpNonDirAddress, pass ptr as
                                            //   lpGet_Xx for IsValPtr chk
        },

        {
            Dword,
            Dword,
            Dword,
            Dword, // lpszW,
            Dword,
            Dword, // lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (dwParkMode == LINEPARKMODE_DIRECTED)
    {
        funcArgs.ArgTypes[3] = lpszW;
        funcArgs.Args[3]     = (ULONG_PTR) lpszDirAddress;
    }
    else if (dwParkMode == LINEPARKMODE_NONDIRECTED)
    {
        if ( !lpNonDirAddress || IsBadWritePtr(lpNonDirAddress, sizeof(VARSTRING)) )
        {
            return LINEERR_INVALPOINTER;
        }

        if (lpNonDirAddress->dwTotalSize < sizeof(VARSTRING))
        {
            return LINEERR_STRUCTURETOOSMALL;
        }

        //
        // Set post process proc
        //
        hPointer = NewObject (ghHandleTable, (PVOID)lpNonDirAddress, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;

        funcArgs.Args[0] = (ULONG_PTR)
            GetFunctionIndex(lineDevSpecificPostProcess);

        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpNonDirAddress;
    }

    lResult = (DOFUNC (&funcArgs, "linePark"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineParkA(
    HCALL       hCall,
    DWORD       dwParkMode,
    LPCSTR      lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPark),

        {
            (ULONG_PTR) 0,                  // post process proc
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwParkMode,
            (ULONG_PTR) TAPI_NO_DATA,       // lpszDirAddress,
            (ULONG_PTR) lpNonDirAddress,    // pass ptr as Dword for post proc
            (ULONG_PTR) TAPI_NO_DATA,       // lpNonDirAddress, pass ptr as
                                            //   lpGet_Xx for IsValPtr chk
        },

        {
            Dword,
            Dword,
            Dword,
            Dword, // lpszW,
            Dword,
            Dword, // lpGet_Struct
        }
    };
    LONG    lResult;
    PWSTR   szTempPtr = NULL;
    DWORD   hPointer = 0;

    switch (dwParkMode)
    {
        case LINEPARKMODE_DIRECTED:
        {
            if (IsBadStringPtrA (lpszDirAddress, (DWORD) -1))
            {
                return LINEERR_INVALPOINTER;
            }

            szTempPtr = NotSoWideStringToWideString (lpszDirAddress, (DWORD) -1);
            funcArgs.ArgTypes[3] = lpszW;
            funcArgs.Args[3]     = (ULONG_PTR) szTempPtr;

            break;
        }

        case LINEPARKMODE_NONDIRECTED:
        {
            if ( !lpNonDirAddress )
            {
                return LINEERR_INVALPOINTER;
            }

            //
            // Set post process proc
            //
            hPointer = NewObject (ghHandleTable, (PVOID)lpNonDirAddress, NULL);
            if (0 == hPointer)
            {
                return LINEERR_NOMEM;
            }
            funcArgs.Args[4] = (ULONG_PTR)hPointer;


            funcArgs.Args[0] = (ULONG_PTR)
                GetFunctionIndex(lineParkAPostProcess);
            funcArgs.ArgTypes[5] = lpGet_Struct;

            if (gbNTVDMClient == FALSE)
            {
                funcArgs.Args[5] = (ULONG_PTR) lpNonDirAddress;
            }
            else
            {
#ifndef _WIN64
                if (!gpfnWOWGetVDMPointer  ||

                    !(funcArgs.Args[5] = (ULONG_PTR) gpfnWOWGetVDMPointer(
                        (DWORD) lpNonDirAddress,
                        sizeof (VARSTRING),     // what if it's > sizeof(VARS)?
                        TRUE // fProtectedMode
                        )))
#endif
                {
                    return LINEERR_OPERATIONFAILED;
                }
            }

            break;
        }

        default:

            return LINEERR_INVALPARKMODE;
    }


    lResult = (DOFUNC (&funcArgs, "linePark"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
linePark(
    HCALL       hCall,
    DWORD       dwParkMode,
    LPCSTR      lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    return lineParkA (hCall, dwParkMode, lpszDirAddress, lpNonDirAddress);
}


LONG
WINAPI
linePickupW(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCWSTR lpszDestAddress,
    LPCWSTR lpszGroupID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPickup),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszGroupID
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW,
            lpszW
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszGroupID)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }


    lResult = (DOFUNC (&funcArgs, "linePickup"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
linePickupA(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszGroupID
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;
    PWSTR   szTempPtr2;


    if ((lpszDestAddress && IsBadStringPtrA (lpszDestAddress, (DWORD) -1)) ||
        (lpszGroupID && IsBadStringPtrA (lpszGroupID, (DWORD) -1)))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);
    szTempPtr2 = NotSoWideStringToWideString (lpszGroupID, (DWORD) -1);

    lResult = linePickupW (hLine, dwAddressID, lphCall, szTempPtr, szTempPtr2);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }

    return lResult;
}


LONG
WINAPI
linePickup(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszGroupID
    )
{
    return linePickupA(
                hLine,
                dwAddressID,
                lphCall,
                lpszDestAddress,
                lpszGroupID
                );
}


LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lPrepareAddToConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "linePrepareAddToConferenceW"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
linePrepareAddToConferenceA(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lPrepareAddToConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "linePrepareAddToConference"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
linePrepareAddToConference(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return linePrepareAddToConferenceA(
              hConfCall,
              lphConsultCall,
              lpCallParams
    );
}


LONG
WINAPI
lineProxyMessage(
    HLINE   hLine,
    HCALL   hCall,
    DWORD   dwMsg,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lProxyMessage),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwMsg,
            (ULONG_PTR) dwParam1,
            (ULONG_PTR) dwParam2,
            (ULONG_PTR) dwParam3
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "lineProxyMessage"));
}


LONG
WINAPI
lineProxyResponse(
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    )
{
    LONG    lResult = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lProxyResponse),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpProxyRequest,
            (ULONG_PTR) dwResult
        },

        {
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    PPROXYREQUESTHEADER pProxyRequestHeader;


    //
    // The following is not the most thorough checking, but it's close
    // enough that a client app won't get a totally unexpected value
    // back
    //

    if (dwResult != 0  &&
        (dwResult < LINEERR_ALLOCATED  ||
            dwResult > LINEERR_DIALVOICEDETECT))
    {
        return LINEERR_INVALPARAM;
    }


    //
    // Backtrack a little bit to get the pointer to what ought to be
    // the proxy header, and then make sure we're dealing with a valid
    // proxy request
    //

    pProxyRequestHeader = (PPROXYREQUESTHEADER)
        (((LPBYTE) lpProxyRequest) - sizeof (PROXYREQUESTHEADER));

    try
    {
        //
        // Make sure we've a valid pProxyRequestHeader, then invalidate
        // the key so subsequent attempts to call lineProxyResponse with
        // the same lpProxyRequest fail
        //

        if (pProxyRequestHeader->dwKey != TPROXYREQUESTHEADER_KEY)
        {
            lResult = LINEERR_INVALPOINTER;
        }

        pProxyRequestHeader->dwKey = 0xefefefef;

        funcArgs.Args[1] = (ULONG_PTR) pProxyRequestHeader->dwInstance;


        //
        // See if this is one of the requests that don't require
        // any data to get passed back & reset the appropriate
        // params if so
        //

        switch (lpProxyRequest->dwRequestType)
        {
        case LINEPROXYREQUEST_SETAGENTGROUP:
        case LINEPROXYREQUEST_SETAGENTSTATE:
        case LINEPROXYREQUEST_SETAGENTACTIVITY:
        case LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD:
        case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
        case LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD:
        case LINEPROXYREQUEST_SETAGENTSTATEEX:

            funcArgs.Args[2]     = (ULONG_PTR) TAPI_NO_DATA;
            funcArgs.ArgTypes[2] = Dword;

            break;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        lResult = LINEERR_INVALPOINTER;
    }


    if (lResult == 0)
    {
        lResult = DOFUNC (&funcArgs, "lineProxyResponse");


        //
        // If we've gotten this far we want to free the buffer
        // unconditionally
        //

        ClientFree (pProxyRequestHeader);
    }

    return lResult;
}


LONG
WINAPI
lineRedirectW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lRedirect),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRedirect"));
}


LONG
WINAPI
lineRedirectA(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    lResult = lineRedirectW (hCall, szTempPtr, dwCountryCode);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineRedirect(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    return lineRedirectA (hCall, lpszDestAddress, dwCountryCode);
}


LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP    hLineApp,
    DWORD       dwRegistrationInstance,
    DWORD       dwRequestMode,
    DWORD       bEnable
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lRegisterRequestRecipient),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwRegistrationInstance,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) bEnable
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRegisterRequestRecipient"));
}


LONG
WINAPI
lineReleaseUserUserInfo(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lReleaseUserUserInfo),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "lineReleaseUserUserInfo"));
}


LONG
WINAPI
lineRemoveFromConference(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lRemoveFromConference),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRemoveFromConference"));
}


LONG
WINAPI
lineRemoveProvider(
    DWORD   dwPermanentProviderID,
    HWND    hwndOwner
    )
{
    return (lineXxxProvider(
        gszTUISPI_providerRemove,   // func name
        NULL,                       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        dwPermanentProviderID,      // dwPermProviderID
        NULL                        // lpdwPermProviderID
        ));
}


LONG
WINAPI
lineSecureCall(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lSecureCall),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSecureCall"));
}


LONG
WINAPI
lineSendUserUserInfo(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSendUserUserInfo),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineSendUserUserInfo"));
}


LONG
WINAPI
lineSetAgentActivity(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwActivityID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentActivity),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwActivityID
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentActivity"));
}


LONG
WINAPI
lineSetAgentGroup(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    static LINEAGENTGROUPLIST EmptyGroupList =
    {
        sizeof (LINEAGENTGROUPLIST),    // dwTotalSize
        sizeof (LINEAGENTGROUPLIST),    // dwNeededSize
        sizeof (LINEAGENTGROUPLIST),    // dwUsedSize
        0,                              // dwNumEntries
        0,                              // dwListSize
        0                               // dwListOffset
    };
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentGroup),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList
        },

        {
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    if (!lpAgentGroupList)
    {
        funcArgs.Args[2] = (ULONG_PTR) &EmptyGroupList;
    }

    return (DOFUNC (&funcArgs, "lineSetAgentGroup"));
}


LONG
WINAPI
lineSetAgentMeasurementPeriod(
    HLINE   hLine,
    HAGENT  hAgent,
    DWORD   dwMeasurementPeriod
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentMeasurementPeriod),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) dwMeasurementPeriod
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentMeasurementPeriod"));
}


LONG
WINAPI
lineSetAgentSessionState(
    HLINE           hLine,
    HAGENTSESSION   hAgentSession,
    DWORD           dwSessionState,
    DWORD           dwNextSessionState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentSessionState),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgentSession,
            (ULONG_PTR) dwSessionState,
            (ULONG_PTR) dwNextSessionState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentSessionState"));
}


LONG
WINAPI
lineSetAgentState(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwAgentState,
    DWORD   dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentState),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAgentState,
            (ULONG_PTR) dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentState"));
}


LONG
WINAPI
lineSetAgentStateEx(
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentStateEx),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) dwAgentState,
            (ULONG_PTR) dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentStateEx"));
}


LONG
WINAPI
lineSetAppPriorityW(
    LPCWSTR             lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCWSTR             lpszExtensionName,
    DWORD               dwPriority
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lSetAppPriority),

        {
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) dwMediaMode,
            (ULONG_PTR) TAPI_NO_DATA,       // (DWORD) lpExtensionID,
            (ULONG_PTR) 0,                  // (DWORD) sizeof(LINEEXTENSIONID),
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) TAPI_NO_DATA,       // (DWORD) lpszExtensionName,
            (ULONG_PTR) dwPriority
        },

        {
            lpszW,
            Dword,
            Dword,  // lpSet_SizeToFollow,
            Dword,  // Size,
            Dword,
            Dword,  // lpsz,
            Dword
        }
    };

    return (DOFUNC (&funcArgs, "lineSetAppPriority"));
}


LONG
WINAPI
lineSetAppPriorityA(
    LPCSTR              lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;

    szTempPtr = NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    lResult = lineSetAppPriorityW(
        szTempPtr,
        dwMediaMode,
        lpExtensionID,
        dwRequestMode,
        NULL, //szTempPtr2,
        dwPriority
        );

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineSetAppPriority(
    LPCSTR  lpszAppName,
    DWORD   dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD   dwRequestMode,
    LPCSTR  lpszExtensionName,
    DWORD   dwPriority
    )
{
    return lineSetAppPriorityA(
                lpszAppName,
                dwMediaMode,
                lpExtensionID,
                dwRequestMode,
                lpszExtensionName,
                dwPriority
                );
}


LONG
WINAPI
lineSetAppSpecific(
    HCALL   hCall,
    DWORD   dwAppSpecific
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetAppSpecific),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwAppSpecific
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAppSpecific"));
}


LONG
WINAPI
lineSetCallData(
    HCALL   hCall,
    LPVOID  lpCallData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetCallData),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallData,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (dwSize == 0)
    {
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[1] =
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineSetCallData"));
}


LONG
WINAPI
lineSetCallParams(
    HCALL   hCall,
    DWORD   dwBearerMode,
    DWORD   dwMinRate,
    DWORD   dwMaxRate,
    LPLINEDIALPARAMS const lpDialParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lSetCallParams),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwBearerMode,
            (ULONG_PTR) dwMinRate,
            (ULONG_PTR) dwMaxRate,
            (ULONG_PTR) lpDialParams,
            (ULONG_PTR) sizeof(LINEDIALPARAMS)
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpDialParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[5] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineSetCallParams"));
}


LONG
WINAPI
lineSetCallPrivilege(
    HCALL   hCall,
    DWORD   dwCallPrivilege
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetCallPrivilege),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwCallPrivilege
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallPrivilege"));
}


LONG
WINAPI
lineSetCallQualityOfService(
    HCALL   hCall,
    LPVOID  lpSendingFlowspec,
    DWORD   dwSendingFlowspecSize,
    LPVOID  lpReceivingFlowspec,
    DWORD   dwReceivingFlowspecSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetCallQualityOfService),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpSendingFlowspec,
            (ULONG_PTR) dwSendingFlowspecSize,
            (ULONG_PTR) lpReceivingFlowspec,
            (ULONG_PTR) dwReceivingFlowspecSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpSet_SizeToFollow,
            Size,
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallQualityOfService"));
}


LONG
WINAPI
lineSetCallTreatment(
    HCALL   hCall,
    DWORD   dwTreatment
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSetCallTreatment),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwTreatment
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallTreatment"));
}


LONG
WINAPI
lineSetDevConfigW(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lSetDevConfig),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpszW
        }
    };


    return (DOFUNC (&funcArgs, "lineSetDevConfig"));
}


LONG
WINAPI
lineSetDevConfigA(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCSTR  lpszDeviceClass
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }
    else if (!(szTempPtr = NotSoWideStringToWideString(
                lpszDeviceClass,
                (DWORD) -1
                )))
    {
        return LINEERR_NOMEM;
    }

    lResult = lineSetDevConfigW(
        dwDeviceID,
        lpDeviceConfig,
        dwSize,
        szTempPtr
        );

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCSTR  lpszDeviceClass
    )
{
    return lineSetDevConfigA(
                dwDeviceID,
                lpDeviceConfig,
                dwSize,
                lpszDeviceClass
                );
}


LONG
WINAPI
lineSetLineDevStatus(
    HLINE   hLine,
    DWORD   dwStatusToChange,
    DWORD   fStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwStatusToChange,
            (ULONG_PTR) fStatus
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetLineDevStatus"));
}


LONG
WINAPI
lineSetMediaControl(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPLINEMEDIACONTROLDIGIT const lpDigitList,
    DWORD   dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA const lpMediaList,
    DWORD   dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE  const lpToneList,
    DWORD   dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD   dwCallStateNumEntries
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lSetMediaControl),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwDigitNumEntries * sizeof(LINEMEDIACONTROLDIGIT),
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwMediaNumEntries * sizeof(LINEMEDIACONTROLMEDIA),
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwToneNumEntries * sizeof(LINEMEDIACONTROLTONE),
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwCallStateNumEntries * sizeof(LINEMEDIACONTROLCALLSTATE)
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    //
    // If lpXxxList is non-NULL reset Arg & ArgType, and check
    // to see that dwXxxNumEntries is not unacceptably large
    //

    if (lpDigitList)
    {
            if (dwDigitNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLDIGIT)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[4] = lpSet_SizeToFollow;
            funcArgs.Args[4]     = (ULONG_PTR) lpDigitList;
            funcArgs.ArgTypes[5] = Size;
    }

    if (lpMediaList)
    {
            if (dwMediaNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLMEDIA)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[6] = lpSet_SizeToFollow;
            funcArgs.Args[6]     = (ULONG_PTR) lpMediaList;
            funcArgs.ArgTypes[7] = Size;
    }

    if (lpToneList)
    {
            if (dwToneNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLTONE)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[8] = lpSet_SizeToFollow;
            funcArgs.Args[8]     = (ULONG_PTR) lpToneList;
            funcArgs.ArgTypes[9] = Size;
    }

    if (lpCallStateList)
    {
            if (dwCallStateNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLCALLSTATE)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[10] = lpSet_SizeToFollow;
            funcArgs.Args[10]     = (ULONG_PTR) lpCallStateList;
            funcArgs.ArgTypes[11] = Size;
    }

    return (DOFUNC (&funcArgs, "lineSetMediaControl"));
}


LONG
WINAPI
lineSetMediaMode(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetMediaMode),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwMediaModes
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetMediaMode"));
}


LONG
WINAPI
lineSetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwNumRings
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetNumRings),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwNumRings
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetNumRings"));
}


LONG
WINAPI
lineSetQueueMeasurementPeriod(
    HLINE   hLine,
    DWORD   dwQueueID,
    DWORD   dwMeasurementPeriod
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetQueueMeasurementPeriod),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwQueueID,
            (ULONG_PTR) dwMeasurementPeriod
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetQueueMeasurementPeriod"));
}


LONG
WINAPI
lineSetStatusMessages(
    HLINE hLine,
    DWORD dwLineStates,
    DWORD dwAddressStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetStatusMessages),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwLineStates,
            (ULONG_PTR) dwAddressStates
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetStatusMessages"));
}


LONG
WINAPI
lineSetTerminal(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    DWORD   dwTerminalModes,
    DWORD   dwTerminalID,
    DWORD   bEnable
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lSetTerminal),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) dwTerminalModes,
            (ULONG_PTR) dwTerminalID,
            (ULONG_PTR) bEnable
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetTerminal"));
}


void
PASCAL
lineSetupConferencePostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineSetupConfPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        HCALL   hConfCall      = (HCALL) pMsg->Param3,
                hConsultCall   = (HCALL) *(&pMsg->Param4 + 1);
        LPHCALL lphConfCall    = (LPHCALL) ReferenceObject (ghHandleTable, pMsg->Param4, 0),
                lphConsultCall = (LPHCALL) ReferenceObject (ghHandleTable, *(&pMsg->Param4 + 2), 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param4, 2);
        DereferenceObject (ghHandleTable, *(&pMsg->Param4 + 2), 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64
                LPHCALL lphConfCallVDM = (LPHCALL) gpfnWOWGetVDMPointer(
                            (DWORD) lphConfCall,
                            sizeof (HCALL),
                            TRUE // fProtectedMode
                            ),
                        lphConsultCallVDM = (LPHCALL) gpfnWOWGetVDMPointer(
                            (DWORD) lphConsultCall,
                            sizeof (HCALL),
                            TRUE // fProtectedMode
                            );

                if (lphConfCallVDM && lphConsultCallVDM)
                {
                    *lphConfCallVDM = hConfCall;
                    *lphConsultCallVDM = hConsultCall;
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                *lphConfCall = hConfCall;
                *lphConsultCall = hConsultCall;
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineSetupConferenceW(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lSetupConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineSetupConferencePostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) dwNumParties,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer1 = 0, hPointer2 = 0;
    LONG  lResult;


    if (lphConfCall == lphConsultCall)
    {
        return LINEERR_INVALPOINTER;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConfCall) ||
            IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer1 = NewObject (ghHandleTable, (PVOID)lphConfCall, NULL);
        if (0 == hPointer1)
        {
            return LINEERR_NOMEM;
        }
        hPointer2 = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer2)
        {
            DereferenceObject (ghHandleTable, hPointer1, 1);
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer1;
        funcArgs.Args[4] = (ULONG_PTR)hPointer2;
    }


    lResult = (DOFUNC (&funcArgs, "lineSetupConferenceW"));
    if (0 > lResult && hPointer1)
    {
        DereferenceObject (ghHandleTable, hPointer1, 1);
        DereferenceObject (ghHandleTable, hPointer2, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupConferenceA(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lSetupConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineSetupConferencePostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) dwNumParties,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer1 = 0, hPointer2 = 0;
    LONG  lResult;


    if (lphConfCall == lphConsultCall)
    {
        return LINEERR_INVALPOINTER;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConfCall) ||
            IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer1 = NewObject (ghHandleTable, (PVOID)lphConfCall, NULL);
        if (0 == hPointer1)
        {
            return LINEERR_NOMEM;
        }
        hPointer2 = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer2)
        {
            DereferenceObject (ghHandleTable, hPointer1, 1);
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer1;
        funcArgs.Args[4] = (ULONG_PTR)hPointer2;
    }


    lResult = (DOFUNC (&funcArgs, "lineSetupConference"));
    if (0 > lResult && hPointer1)
    {
        DereferenceObject (ghHandleTable, hPointer1, 1);
        DereferenceObject (ghHandleTable, hPointer2, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupConference(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return lineSetupConferenceA(
                hCall,
                hLine,
                lphConfCall,
                lphConsultCall,
                dwNumParties,
                lpCallParams
                );
}


LONG
WINAPI
lineSetupTransferW(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetupTransfer),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "lineSetupTransferW"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupTransferA(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetupTransfer),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "lineSetupTransferW"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupTransfer(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return lineSetupTransferA (hCall, lphConsultCall, lpCallParams);
}


LONG
WINAPI
lineShutdown(
    HLINEAPP    hLineApp
    )
{
    return (xxxShutdown (hLineApp, TRUE));
}


LONG
WINAPI
lineSwapHold(
    HCALL   hActiveCall,
    HCALL   hHeldCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSwapHold),

        {
            (ULONG_PTR) hActiveCall,
            (ULONG_PTR) hHeldCall
        },

        {
            Dword,
            Dword
        }
    };

    return (DOFUNC (&funcArgs, "lineSwapHold"));
}


LONG
WINAPI
lineUncompleteCall(
    HLINE   hLine,
    DWORD   dwCompletionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lUncompleteCall),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwCompletionID
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineUncompleteCall"));
}


LONG
WINAPI
lineUnhold(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lUnhold),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineUnhold"));
}


LONG
WINAPI
lineUnparkW(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCWSTR lpszDestAddress
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lUnpark),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) lpszDestAddress
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }


    lResult = (DOFUNC (&funcArgs, "lineUnpark"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineUnparkA(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }
    else if (!(szTempPtr = NotSoWideStringToWideString(
                    lpszDestAddress,
                    (DWORD) -1
                    )))
    {
        return LINEERR_NOMEM;
    }

    lResult = lineUnparkW (hLine, dwAddressID, lphCall, szTempPtr);

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineUnpark(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress
    )
{
    return  lineUnparkA (hLine, dwAddressID, lphCall, lpszDestAddress);

}

//
// ------------------------------- phoneXxx -----------------------------------
//

LONG
WINAPI
phoneClose(
    HPHONE  hPhone
    )
{
    LONG lResult;
    DWORD Handle = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pClose),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) &Handle
        },

        {
            Dword,
            lpDword
        }
    };


    lResult = DOFUNC (&funcArgs, "phoneClose");

    if (0 == lResult &&
        0 != Handle)
    {
        DereferenceObject (ghHandleTable, Handle, 1);
    }

    return lResult;
}


LONG
WINAPI
phoneConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_phoneConfigDialog;


    if (lpszDeviceClass && TAPIIsBadStringPtrW (lpszDeviceClass, (UINT) -1))
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in phoneConfigDialogW [%p]",
                   lpszDeviceClass ));
        return PHONEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_PHONEID,
            &hDll,
            gszTUISPI_phoneConfigDialog,
            &pfnTUISPI_phoneConfigDialog

            )) == 0)
    {
        LOG((TL_TRACE, "Calling TUISPI_phoneConfigDialog..."));

        lResult = (*pfnTUISPI_phoneConfigDialog)(
            TUISPIDLLCallback,
            dwDeviceID,
            hwndOwner,
            lpszDeviceClass
            );

#if DBG
        {
            char szResult[32];

            LOG((TL_TRACE,
                "TUISPI_phoneConfigDialog: result = %hs",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
            LOG((TL_TRACE,
                "TUISPI_phoneConfigDialog: result = x%x",
                lResult
                ));
#endif
        FreeLibrary (hDll);
    }

    return lResult;
}


LONG
WINAPI
phoneConfigDialogA(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    LONG  lResult;
    PWSTR szTempString;


    if (lpszDeviceClass && IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return PHONEERR_INVALPOINTER;
    }

    szTempString = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);


    lResult = phoneConfigDialogW (dwDeviceID, hwndOwner, szTempString);

    if (szTempString)
    {
        ClientFree (szTempString);
    }

    return lResult;
}


LONG
WINAPI
phoneConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    return phoneConfigDialogA (dwDeviceID, hwndOwner, lpszDeviceClass);
}


void
PASCAL
phoneDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "phoneDevSpecificPostProcess: enter"));
    LOG((TL_INFO,
		"\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = (DWORD) pMsg->Param4;

        if (dwSize > 0)
        {
            LPBYTE  pParams = (LPBYTE) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

            // We don't need the handle to the pointer any more...
            DereferenceObject (ghHandleTable, pMsg->Param3, 2);

            try
            {
                if (gbNTVDMClient)
                {
#ifndef _WIN64

                    LPVARSTRING pParamsVDM = (LPVARSTRING) gpfnWOWGetVDMPointer(
                        (DWORD) pParams,
                        dwSize,
                        TRUE // fProtectedMode
                        );


                    if (pParamsVDM)
                    {
                        CopyMemory (pParamsVDM, (LPBYTE) (pMsg + 1), dwSize);
                    }
                    else
                    {
                        pMsg->Param2 = PHONEERR_INVALPOINTER;
                    }
#endif
                }
                else
                {
                    CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                pMsg->Param2 = PHONEERR_INVALPOINTER;
            }
        }
    }
}


LONG
WINAPI
phoneDevSpecific(
    HPHONE  hPhone,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pDevSpecific),

        {
            (ULONG_PTR) GetFunctionIndex(phoneDevSpecificPostProcess),
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpParams,   // passed as Dword for post processing
            (ULONG_PTR) lpParams,   // passed as LpSet_Xxx for IsValidPtr chk
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (gbNTVDMClient)
    {
#ifndef _WIN64
        if (!gpfnWOWGetVDMPointer  ||

            !(funcArgs.Args[3] = (ULONG_PTR) gpfnWOWGetVDMPointer(
                (DWORD) lpParams,
                dwSize,
                TRUE // fProtectedMode
                )))
#endif
        {
            return PHONEERR_OPERATIONFAILED;
        }
    }

    if (!gbNTVDMClient)
    {
        if ( !lpParams && dwSize > 0 )
        {
            return PHONEERR_INVALPOINTER;
        }

        if (lpParams)
        {
            hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
            if (0 == hPointer)
            {
                return PHONEERR_NOMEM;
            }
            funcArgs.Args[2] = (ULONG_PTR)hPointer;
        }
    }

    lResult = (DOFUNC (&funcArgs, "phoneDevSpecific"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetButtonInfo),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) lpButtonInfo
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetButtonInfo"));
}


LONG
WINAPI
phoneGetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    LONG lResult;


    lResult = phoneGetButtonInfoW (hPhone, dwButtonLampID, lpButtonInfo);

    if ( 0 == lResult )
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpButtonInfo,
            &lpButtonInfo->dwButtonTextSize
            );
    }

    return lResult;
}


LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    return phoneGetButtonInfoA (hPhone, dwButtonLampID, lpButtonInfo);
}


LONG
WINAPI
phoneGetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  lpData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetData),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwDataID,
            (ULONG_PTR) lpData,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetData"));
}


LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 5, pGetDevCaps),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) lpPhoneCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return PHONEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "phoneGetDevCaps"));
}


LONG
WINAPI
phoneGetDevCapsA(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    LONG lResult;


    lResult = phoneGetDevCapsW(
        hPhoneApp,
        dwDeviceID,
        dwAPIVersion,
        dwExtVersion,
        lpPhoneCaps
        );

    if (lResult == 0)
    {
        lpPhoneCaps->dwStringFormat = STRINGFORMAT_ASCII;

        WideStringToNotSoWideString(
            (LPBYTE) lpPhoneCaps,
            &lpPhoneCaps->dwProviderInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE) lpPhoneCaps,
            &lpPhoneCaps->dwPhoneInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE) lpPhoneCaps,
            &lpPhoneCaps->dwPhoneNameSize
            );

        if (dwAPIVersion >= 0x00020000)
        {
            WideStringToNotSoWideString(
                (LPBYTE) lpPhoneCaps,
                &lpPhoneCaps->dwDeviceClassesSize
                );
        }
    }


    return lResult;
}


LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    return phoneGetDevCapsA(
                hPhoneApp,
                dwDeviceID,
                dwAPIVersion,
                dwExtVersion,
                lpPhoneCaps
                );
}


LONG
WINAPI
phoneGetDisplay(
    HPHONE  hPhone,
    LPVARSTRING lpDisplay
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetDisplay),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpDisplay
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetDisplay"));
}


LONG
WINAPI
phoneGetGain(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwGain
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetGain),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) lpdwGain
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetGain"));
}


LONG
WINAPI
phoneGetHookSwitch(
    HPHONE hPhone,
    LPDWORD lpdwHookSwitchDevs
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetHookSwitch),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwHookSwitchDevs
        },

        {
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetHookSwitch"));
}


LONG
WINAPI
phoneGetIconW(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetIcon),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) lphIcon
        },

        {
            Dword,
            lpszW,
            lpDword
        }
    };


    if (IsBadDwordPtr ((LPDWORD) lphIcon))
    {
        LOG((TL_ERROR,
            "Bad icon pointer passed into PhoneGetIconA [0x%p]",
            lphIcon
            ));

        return PHONEERR_INVALPOINTER;
    }

    if (lpszDeviceClass == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    return DOFUNC (&funcArgs, "phoneGetIcon");
}


LONG
WINAPI
phoneGetIconA(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszDeviceClass)
    {
        if (IsBadStringPtrA (lpszDeviceClass, (DWORD) (DWORD) -1))
        {
            return PHONEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);
    }
    else
    {
        szTempPtr = NULL;
    }

    lResult = phoneGetIconW (dwDeviceID, szTempPtr, lphIcon);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneGetIcon(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    return (phoneGetIconA (dwDeviceID, lpszDeviceClass, lphIcon));
}


LONG
WINAPI
phoneGetIDW(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetID),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };

    LPVARSTRING lpDeviceIDTemp = NULL;
    DWORD       dwNumDevices;
    DWORD       dwBufSize;
    DWORD       dwResult;
    DWORD       dwDeviceId1, dwDeviceId2;
    BOOL        bDoItAgain = FALSE;


    if ( TAPIIsBadStringPtrW(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in phoneGetIDW"));
        return( PHONEERR_INVALPOINTER );
    }

    if ( IsBadWritePtr(lpDeviceID, sizeof(VARSTRING)) )
    {
        LOG((TL_ERROR, "Bad lpDeviceID in lineGetIDW"));
        return( PHONEERR_INVALPOINTER);
    }

    //
    // if the request is for a wave device, call LGetIDEx
    //
    if (!_wcsicmp(lpszDeviceClass, L"wave/in")  ||
        !_wcsicmp(lpszDeviceClass, L"wave/out") ||
        !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
        !_wcsicmp(lpszDeviceClass, L"midi/out") ||
        !_wcsicmp(lpszDeviceClass, L"wave/in/out")
       )
    {
        dwNumDevices = _wcsicmp(lpszDeviceClass, L"wave/in/out") ? 1 : 2;
        dwBufSize = lpDeviceID->dwTotalSize + dwNumDevices * WAVE_STRING_ID_BUFFER_SIZE;
        do
        {
            //
            // Allocate additional memory for the device string ID
            //
            lpDeviceIDTemp = (LPVARSTRING)ClientAlloc (dwBufSize);
            if (!lpDeviceIDTemp)
            {
                LOG((TL_ERROR, "Failed to allocate memory"));
                return( PHONEERR_NOMEM );
            }
            lpDeviceIDTemp->dwTotalSize = dwBufSize;
            funcArgs.Flags = MAKELONG (PHONE_FUNC | SYNC | 3, pGetIDEx);
            funcArgs.Args[1] = (ULONG_PTR)lpDeviceIDTemp;

            //
            // Call LGetIDEx
            //
            dwResult = DOFUNC (&funcArgs, "phoneGetIDEx");
            if (dwResult)
            {
                LOG((TL_ERROR, "phoneGetIDEx failed with x%x", dwResult));
                ClientFree (lpDeviceIDTemp);
                return dwResult;
            }

            if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize && !bDoItAgain)
            {
                LOG((TL_INFO, 
                     "phoneGetIDEx returned needed size (%d) bigger than total size (%d) -> need to realloc", 
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
                dwBufSize = lpDeviceIDTemp->dwNeededSize;
                ClientFree ( lpDeviceIDTemp );
                bDoItAgain = TRUE;
            }
            else
            {
                bDoItAgain = FALSE;
            }
            
        } while (bDoItAgain);

        if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize)
        {
            LOG((TL_ERROR, "needed size (%d) still bigger than total size (%d)",
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
            ClientFree (lpDeviceIDTemp);
            return PHONEERR_OPERATIONFAILED;
        }

        //
        // Get the device ID from string ID
        //
        if (dwNumDevices == 1)
        {
            if (!WaveStringIdToDeviceId (
                (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset),
                lpszDeviceClass,
                &dwDeviceId1)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return PHONEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
            }
        }
        else
        {
            LPWSTR szString1 = (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset);

            if (!WaveStringIdToDeviceId (
                    szString1,
                    L"wave/in",
                    &dwDeviceId1) ||
                !WaveStringIdToDeviceId (
                    (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset + wcslen(szString1)),
                    L"wave/out",
                    &dwDeviceId2)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return PHONEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + 2 * sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = 2 * sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
                *((DWORD *)(lpDeviceID + 1) + 1) = dwDeviceId2;
            }
        }
        ClientFree (lpDeviceIDTemp);
        return NO_ERROR;
    }
    else
    {
        return (DOFUNC (&funcArgs, "phoneGetID"));
    }
}


LONG
WINAPI
phoneGetIDA(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCSTR      lpszDeviceClass
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if ( IsBadStringPtrA(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in phoneGetIDA"));
        return( PHONEERR_INVALPOINTER );
    }

    szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);

    lResult = phoneGetIDW (hPhone, lpDeviceID, szTempPtr);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneGetID(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCSTR      lpszDeviceClass
    )
{
    return phoneGetIDA (hPhone, lpDeviceID, lpszDeviceClass);
}


LONG
WINAPI
phoneGetLamp(
    HPHONE hPhone,
    DWORD dwButtonLampID,
    LPDWORD lpdwLampMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetLamp),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) lpdwLampMode
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetLamp"));
}



LONG
WINAPI
phoneGetMessage(
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    )
{
    return (xxxGetMessage(
                FALSE,
                (HLINEAPP) hPhoneApp,
                (LPLINEMESSAGE) lpMessage,
                dwTimeout
                ));
}


LONG
WINAPI
phoneGetRing(
    HPHONE hPhone,
    LPDWORD lpdwRingMode,
    LPDWORD lpdwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetRing),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwRingMode,
            (ULONG_PTR) lpdwVolume
        },

        {
            Dword,
            lpDword,
            lpDword
        }
    };


    if (lpdwRingMode == lpdwVolume)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneGetRing"));
}


LONG
WINAPI
phoneGetStatusW(
    HPHONE hPhone,
    LPPHONESTATUS lpPhoneStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetStatus),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpPhoneStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetStatus"));
}


LONG
WINAPI
phoneGetStatusA(
    HPHONE hPhone,
    LPPHONESTATUS lpPhoneStatus
    )
{
    LONG lResult;


    lResult = phoneGetStatusW (hPhone, lpPhoneStatus);

    if (lResult == 0)
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpPhoneStatus,
            &lpPhoneStatus->dwOwnerNameSize
            );
    }

    return lResult;
}


LONG
WINAPI
phoneGetStatus(
    HPHONE hPhone,
    LPPHONESTATUS lpPhoneStatus
    )
{
    return phoneGetStatusA (hPhone, lpPhoneStatus);
}


LONG
WINAPI
phoneGetStatusMessages(
    HPHONE  hPhone,
    LPDWORD lpdwPhoneStates,
    LPDWORD lpdwButtonModes,
    LPDWORD lpdwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetStatusMessages),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwPhoneStates,
            (ULONG_PTR) lpdwButtonModes,
            (ULONG_PTR) lpdwButtonStates
        },

        {
            Dword,
            lpDword,
            lpDword,
            lpDword
        }
    };


    if (lpdwPhoneStates == lpdwButtonModes  ||
        lpdwPhoneStates == lpdwButtonStates  ||
        lpdwButtonModes == lpdwButtonStates)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneGetStatusMessages"));
}


LONG
WINAPI
phoneGetVolume(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetVolume),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) lpdwVolume
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetVolume"));
}


LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP     lphPhoneApp,
    HINSTANCE       hInstance,
    PHONECALLBACK   lpfnCallback,
    LPCSTR          lpszFriendlyAppName,
    LPDWORD         lpdwNumDevs
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszFriendlyAppName)
    {
        if (IsBadStringPtrA (lpszFriendlyAppName, (DWORD) -1))
        {
            LOG((TL_ERROR,
                "phoneInitialize: bad lpszFriendlyAppName (x%p)",
                lpszFriendlyAppName
                ));

            return PHONEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString(
            lpszFriendlyAppName,
            (DWORD) -1
            );
    }
    else
    {
        szTempPtr = NULL;
    }

    //
    // NOTE: the hack below for the lpInitExParam is for 16-bit apps,
    //       since the lpszAppName really points at a
    //       <friendly name>\0<module name>\0 string and we need the
    //       module name in xxxInitialize()
    //

    lResult = (xxxInitialize(
        FALSE,
        (LPVOID) lphPhoneApp,
        hInstance,
        lpfnCallback,
        szTempPtr,
        lpdwNumDevs,
        NULL,
#ifdef _WIN64
        NULL
#else
        (LPLINEINITIALIZEEXPARAMS)
            (((DWORD) lpfnCallback & 0xffff0000) == 0xffff0000 ?
                lpszFriendlyAppName : NULL)
#endif
#if DBG
        ,"phoneInitialize"
#endif
        ));

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneInitializeExW(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
    if (IsBadDwordPtr (lpdwAPIVersion))
    {
        LOG((TL_ERROR,
            "phoneInitializeExW: bad lpdwAPIVersion (x%p)",
            lpdwAPIVersion
            ));

        return PHONEERR_INVALPOINTER;
    }

    return (xxxInitialize(
        FALSE,
        (LPVOID) lphPhoneApp,
        hInstance,
        lpfnCallback,
        lpszFriendlyAppName,
        lpdwNumDevs,
        lpdwAPIVersion,
        (LPVOID) lpPhoneInitializeExParams
#if DBG
        ,"phoneInitializeExW"
#endif
        ));
}


LONG
WINAPI
phoneInitializeExA(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
    LONG    lResult;
    PWSTR   szTempPtr = NULL;


    if (lpszFriendlyAppName)
    {
        if (IsBadStringPtrA (lpszFriendlyAppName, (DWORD) -1))
        {
            LOG((TL_ERROR,
                "phoneInitializeExA: bad lpszFriendlyAppName (x%p)",
                lpszFriendlyAppName
                ));

            return PHONEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString(
            lpszFriendlyAppName,
            (DWORD) -1
            );
    }
    else
    {
        szTempPtr = NULL;
    }

    lResult = phoneInitializeExW(
        lphPhoneApp,
        hInstance,
        lpfnCallback,
        szTempPtr,
        lpdwNumDevs,
        lpdwAPIVersion,
        lpPhoneInitializeExParams
        );

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 7, pNegotiateAPIVersion),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPILowVersion,
            (ULONG_PTR) dwAPIHighVersion,
            (ULONG_PTR) lpdwAPIVersion,
            (ULONG_PTR) lpExtensionID,
            (ULONG_PTR) sizeof(PHONEEXTENSIONID)
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        }
    };

    if (dwAPIHighVersion > TAPI_CURRENT_VERSION)
    {
        funcArgs.Args[3] = TAPI_CURRENT_VERSION;
    }

    if ((LPVOID) lpdwAPIVersion == (LPVOID) lpExtensionID)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneNegotiateAPIVersion"));
}


LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtLowVersion,
    DWORD       dwExtHighVersion,
    LPDWORD     lpdwExtVersion
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 6, pNegotiateExtVersion),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtLowVersion,
            (ULONG_PTR) dwExtHighVersion,
            (ULONG_PTR) lpdwExtVersion
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpDword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return PHONEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "phoneNegotiateExtVersion"));
}


LONG
WINAPI
phoneOpen(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    LPHPHONE    lphPhone,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwPrivilege
    )
{
    DWORD hCallbackInstance = 0;
    LONG    lResult;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 8, pOpen),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lphPhone,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) dwCallbackInstance,
            (ULONG_PTR) dwPrivilege,
            (ULONG_PTR) 0,                  // PHONEOPEN_PARAMS.hRemotePhone
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return PHONEERR_INCOMPATIBLEAPIVERSION;
    }

    if (0 != dwCallbackInstance)
    {
        hCallbackInstance = NewObject (ghHandleTable, (PVOID)dwCallbackInstance, (PVOID)UIntToPtr(hPhoneApp));
        if (0 == hCallbackInstance)
        {
            return PHONEERR_NOMEM;
        }

        funcArgs.Args[5] = hCallbackInstance;
    }

    lResult = DOFUNC (&funcArgs, "phoneOpen");

    if (lResult && 0 != hCallbackInstance)
    {
        DereferenceObject (ghHandleTable, hCallbackInstance, 1);
    }

    return lResult;
}


LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetButtonInfo),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) lpButtonInfo
        },

        {
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetButtonInfo"));
}


LONG
WINAPI
phoneSetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    LONG                lResult;
    LPPHONEBUTTONINFO   lppbi;


    if (IsBadReadPtr( lpButtonInfo, sizeof(PHONEBUTTONINFO)) ||
        IsBadReadPtr( lpButtonInfo, lpButtonInfo->dwTotalSize))
    {
        LOG((TL_ERROR, "Bad lpButtonInfo - not at least sizeof(PHONEBUTTONINFO)"));
        return PHONEERR_INVALPOINTER;
    }


    //
    // See if there's a need to do this, first
    //

    if ( lpButtonInfo->dwButtonTextSize )
    {
       DWORD dwNewStringSize,
             dwOffset = lpButtonInfo->dwButtonTextOffset,
             dwSize = lpButtonInfo->dwButtonTextSize,
             dwTotalSize = lpButtonInfo->dwTotalSize;


       //
       // Check to see if dwButtonTextSize/Offset is valid before
       // conversion (check against size of 1.0 PHONEBUTTONINFO here
       // (9*DWORD), tapisrv will check again for the appropriate version)
       //

       if ((dwOffset < (9 * sizeof (DWORD))) ||
           (dwOffset >= dwTotalSize) ||
           ((dwOffset + dwSize) > dwTotalSize) ||
           ((dwOffset + dwSize) < dwOffset))
       {
           LOG((TL_ERROR, "phoneSetButtonInfo: dwButtonTextSize/Offset invalid"));
           return PHONEERR_OPERATIONFAILED;
       }


       //
       // Assume the worst for size...
       //

       if (!(lppbi = ClientAlloc (lpButtonInfo->dwTotalSize * sizeof(WCHAR))))
       {
           return PHONEERR_NOMEM;
       }

       CopyMemory( lppbi, lpButtonInfo, lpButtonInfo->dwTotalSize );


       //
       // We _KNOW_ that the old structure was as big as the dwTotalSize
       // so we can put our rebuilt string starting there. Make sure
       // to align new wide string on WORD boundary.
       //

       dwNewStringSize = sizeof(WCHAR) * MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            (LPBYTE)lpButtonInfo + lpButtonInfo->dwButtonTextOffset,
            lpButtonInfo->dwButtonTextSize,
            (PWSTR)((LPBYTE)lppbi + ((dwTotalSize + 1) & 0xfffffffe)),
            lpButtonInfo->dwButtonTextSize
            );

       lppbi->dwTotalSize += dwNewStringSize;

       lppbi->dwButtonTextSize   = dwNewStringSize;
       lppbi->dwButtonTextOffset = (dwTotalSize + 1) & 0xfffffffe;
    }
    else
    {
        lppbi = NULL;
    }


    lResult = phoneSetButtonInfoW(
        hPhone,
        dwButtonLampID,
        lppbi ? lppbi : lpButtonInfo
        );

    if (lppbi)
    {
        ClientFree (lppbi);
    }

    return lResult;
}


LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    return phoneSetButtonInfoA (hPhone, dwButtonLampID, lpButtonInfo);
}


LONG
WINAPI
phoneSetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  const lpData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetData),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwDataID,
            (ULONG_PTR) lpData,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetData"));
}


LONG
WINAPI
phoneSetDisplay(
    HPHONE  hPhone,
    DWORD   dwRow,
    DWORD   dwColumn,
    LPCSTR  lpsDisplay,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pSetDisplay),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwRow,
            (ULONG_PTR) dwColumn,
            (ULONG_PTR) lpsDisplay,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetDisplay"));
}


LONG
WINAPI
phoneSetGain(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwGain
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetGain),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) dwGain
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetGain"));
}


LONG
WINAPI
phoneSetHookSwitch(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDevs,
    DWORD   dwHookSwitchMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetHookSwitch),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDevs,
            (ULONG_PTR) dwHookSwitchMode
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    if (!(dwHookSwitchDevs & AllHookSwitchDevs) ||
        (dwHookSwitchDevs & (~AllHookSwitchDevs)))
    {
        return PHONEERR_INVALHOOKSWITCHDEV;
    }

    if (!IsOnlyOneBitSetInDWORD (dwHookSwitchMode) ||
        (dwHookSwitchMode & ~AllHookSwitchModes))
    {
        return PHONEERR_INVALHOOKSWITCHMODE;
    }

    return (DOFUNC (&funcArgs, "phoneSetHookSwitch"));
}


LONG
WINAPI
phoneSetLamp(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    DWORD   dwLampMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetLamp),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) dwLampMode
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetLamp"));
}


LONG
WINAPI
phoneSetRing(
    HPHONE  hPhone,
    DWORD   dwRingMode,
    DWORD   dwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetRing),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwRingMode,
            (ULONG_PTR) dwVolume
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetRing"));
}


LONG
WINAPI
phoneSetStatusMessages(
    HPHONE  hPhone,
    DWORD   dwPhoneStates,
    DWORD   dwButtonModes,
    DWORD   dwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pSetStatusMessages),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwPhoneStates,
            (ULONG_PTR) dwButtonModes,
            (ULONG_PTR) dwButtonStates
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetStatusMessages"));
}


LONG
WINAPI
phoneSetVolume(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetVolume),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) dwVolume
        },

        {
            Dword,
            Dword,
            Dword
        }
    };

return (DOFUNC (&funcArgs, "phoneSetVolume"));
}


LONG
WINAPI
phoneShutdown(
    HPHONEAPP   hPhoneApp
    )
{
    return (xxxShutdown ((HLINEAPP) hPhoneApp, FALSE));
}


//
// ------------------------------- tapiXxx ------------------------------------
//

LONG
WINAPI
tapiRequestDrop(
    HWND    hWnd,
    WPARAM  wRequestID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 2, tRequestDrop),

        {
            (ULONG_PTR) hWnd,
            (ULONG_PTR) wRequestID
        },

        {
            Hwnd,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "tapiRequestDrop"));
}


LONG
WINAPI
tapiRequestMakeCallW(
    LPCWSTR  lpszDestAddress,
    LPCWSTR  lpszAppName,
    LPCWSTR  lpszCalledParty,
    LPCWSTR  lpszComment
    )
{
    LONG        lResult;
    DWORD       hRequestMakeCallAttempted, dwProxyListSize = 512;
    LPVARSTRING pProxyList;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 7, tRequestMakeCall),

        {
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) lpszCalledParty,
            (ULONG_PTR) lpszComment,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) &hRequestMakeCallAttempted
        },

        {
            lpszW,
            lpszW,
            lpszW,
            lpszW,
            lpGet_Struct,
            Dword,
            lpDword
        }
    };


    if (TAPIIsBadStringPtrW (lpszDestAddress, (DWORD) -1) ||
        (lstrlenW (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        return TAPIERR_INVALDESTADDRESS;
    }

    if (!lpszAppName)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszCalledParty)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[2] = Dword;
        funcArgs.Args[2]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszComment)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }


    //
    //
    //

    if (!(pProxyList = ClientAlloc (dwProxyListSize)))
    {
        return TAPIERR_NOREQUESTRECIPIENT;
    }

    pProxyList->dwTotalSize = dwProxyListSize;

    funcArgs.Args[4] = (ULONG_PTR) pProxyList;

    if ((lResult = DOFUNC (&funcArgs, "tapiRequestMakeCall")) == 0)
    {
        //
        //
        //

        if (hRequestMakeCallAttempted != 0)
        {
            WCHAR  *pszProxyName, *pszNextProxyName;
            BOOL    bLastAppInList = FALSE, bStartedProxy = FALSE;


            pszProxyName =
            pszNextProxyName =
                (WCHAR *)(((LPBYTE) pProxyList) + pProxyList->dwStringOffset);


            while (!bLastAppInList)
            {
                while (1)
                {
                    if (*pszNextProxyName == 0)
                    {
                        bLastAppInList = TRUE;
                        break;
                    }
                    else if (*pszNextProxyName == L'"')
                    {
                        *pszNextProxyName = 0;
                        pszNextProxyName++;
                        break;
                    }

                    pszNextProxyName++;
                }

                //
                // Fake layer to get a local struct
                //
                {
                    FARPROC pShellExecuteEx = NULL;
                    HINSTANCE hInst;

                    LPTSTR pszBuffer;
                    DWORD dwSize = lstrlenW(pszProxyName)+1;

                    SHELLEXECUTEINFO sei =
                    {
                        sizeof(SHELLEXECUTEINFO),
                        0,
                        0,              // hWnd
                        NULL,           //"Open"
                        NULL,           // lpFile
                        NULL,
                        NULL,           //Directory
                        SW_MINIMIZE,
                        NULL            //hProcess - huh?
                    };

                    pszBuffer = (LPTSTR)ClientAlloc(dwSize*sizeof(TCHAR));
                    SHUnicodeToTChar(pszProxyName, pszBuffer, dwSize );
                    sei.lpFile = pszBuffer;

                    hInst = LoadLibrary( TEXT("shell32.dll") );
                    if (NULL != hInst)
                    {
                        pShellExecuteEx = GetProcAddress(
                            hInst,
    #ifdef UNICODE
                            "ShellExecuteExW"
    #else
                            "ShellExecuteEx"
    #endif
                            );

                        if (pShellExecuteEx && pShellExecuteEx(&sei) == TRUE)
                        {
                            bStartedProxy = TRUE;
                            ClientFree(pszBuffer);
                            break;
                        }
                        else
#if DBG
                        {
                            LOG((TL_ERROR,
                                "tapiRequestMakeCall: ShellExecuteExW(%ls) error - x%x",
                                pszProxyName,
                                GetLastError()
                                ));
                        }
#else
                            LOG((TL_ERROR,
                                "tapiRequestMakeCall: ShellExecuteExW error - x%x",
                                GetLastError()
                                ));

#endif
                        ClientFree(pszBuffer);
                        FreeLibrary( hInst );
                    }
                    else
                    {
                        LOG((TL_ERROR,
                            "tapiRequestMakeCall: LoadLibrary(shell32.dll) failed - x%x",
                            GetLastError()
                            ));
                    }

                }

                pszProxyName = pszNextProxyName;
            }

            if (bStartedProxy == FALSE)
            {
                //
                // Alert tapisrv that it needs to free the ReqMakeCall inst
                //

                FUNC_ARGS funcArgs =
                {
                    MAKELONG (TAPI_FUNC | SYNC | 7, tRequestMakeCall),

                    {
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) hRequestMakeCallAttempted,
                        (ULONG_PTR) 0
                    },

                    {
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                    }
                };


                LOG((TL_ERROR,
                    "tapiRequestMakeCall: failed to start proxy, deleting request"
                    ));

                lResult = DOFUNC (&funcArgs, "tapiRequestMakeCall_cleanup");
            }
        }
    }

    ClientFree (pProxyList);

    return lResult;
}


LONG
WINAPI
tapiRequestMakeCallA(
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    LONG    lResult;
    PWSTR   szTempPtr1;
    PWSTR   szTempPtr2;
    PWSTR   szTempPtr3;
    PWSTR   szTempPtr4;


    if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1) ||
        (lstrlenA (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        return TAPIERR_INVALDESTADDRESS;
    }

    if ((lpszAppName && IsBadStringPtrA (lpszAppName, (DWORD) -1)) ||
        (lpszCalledParty && IsBadStringPtrA (lpszCalledParty, (DWORD) -1)) ||
        (lpszComment && IsBadStringPtrA (lpszComment, (DWORD) -1)))
    {
        return TAPIERR_INVALPOINTER;
    }

    szTempPtr1= NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    if ( !szTempPtr1 )
    {
        return TAPIERR_INVALPOINTER;
    }

    szTempPtr2= NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    szTempPtr3= NotSoWideStringToWideString (lpszCalledParty, (DWORD) -1);
    szTempPtr4= NotSoWideStringToWideString (lpszComment, (DWORD) -1);

    lResult = tapiRequestMakeCallW(
        szTempPtr1,
        szTempPtr2,
        szTempPtr3,
        szTempPtr4
        );

    ClientFree (szTempPtr1);

    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }

    if (szTempPtr3)
    {
        ClientFree (szTempPtr3);
    }

    if (szTempPtr4)
    {
        ClientFree (szTempPtr4);
    }

    return lResult;
}


LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    return tapiRequestMakeCallA(
                lpszDestAddress,
                lpszAppName,
                lpszCalledParty,
                lpszComment
                );
}


LONG
WINAPI
tapiRequestMediaCallW(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCWSTR lpszDeviceClass,
    LPCWSTR lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCWSTR lpszDestAddress,
    LPCWSTR lpszAppName,
    LPCWSTR lpszCalledParty,
    LPCWSTR lpszComment
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 10, tRequestMediaCall),

        {
            (ULONG_PTR) hWnd,
            (ULONG_PTR) wRequestID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) dwSecure,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) lpszCalledParty,
            (ULONG_PTR) lpszComment,
        },

        {
            Hwnd,
            Dword,
            lpszW,
            lpGet_SizeToFollow,
            Size,
            Dword,
            lpszW,
            lpszW,
            lpszW,
            lpszW
        }
    };


    if (TAPIIsBadStringPtrW (lpszDeviceClass, (UINT) -1) ||
        (lstrlenW (lpszDeviceClass) + 1) > TAPIMAXDEVICECLASSSIZE)
    {
        return TAPIERR_INVALDEVICECLASS;
    }

    if (IsBadWritePtr ((LPVOID) lpDeviceID, dwSize) ||
        dwSize > (TAPIMAXDEVICEIDSIZE * sizeof (WCHAR)))
    {
        return TAPIERR_INVALDEVICEID;
    }

    if (TAPIIsBadStringPtrW (lpszDestAddress, (UINT) -1) ||
        (lstrlenW (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        return TAPIERR_INVALDESTADDRESS;
    }

    if (!lpszAppName)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[7] = Dword;
        funcArgs.Args[7]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszCalledParty)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszComment)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[9] = Dword;
        funcArgs.Args[9]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    return (DOFUNC (&funcArgs, "tapiRequestMediaCall"));
}


LONG
WINAPI
tapiRequestMediaCallA(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCSTR  lpszDeviceClass,
    LPCSTR  lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    LONG    lResult;
    PWSTR   szTempPtr1 = NULL, szTempPtr2 = NULL, szTempPtr3 = NULL,
            szTempPtr4 = NULL, szTempPtr5 = NULL, szTempPtr6 = NULL;


    if (IsBadStringPtrA (lpszDeviceClass, (UINT) -1) ||
        (lstrlenA (lpszDeviceClass) + 1) > TAPIMAXDEVICECLASSSIZE)
    {
        lResult = TAPIERR_INVALDEVICECLASS;
        goto ExitHere;
    }
    else
    {
        szTempPtr1 = NotSoWideStringToWideString(
            lpszDeviceClass,
            (DWORD) -1
            );
    }

    if (IsBadWritePtr ((LPVOID) lpDeviceID, dwSize) ||
        dwSize > TAPIMAXDEVICEIDSIZE)
    {
        lResult = TAPIERR_INVALDEVICEID;
        goto ExitHere;
    }
    else
    {
        dwSize *= 2;
        szTempPtr2 = ClientAlloc (dwSize);
    }

    if (IsBadStringPtrA (lpszDestAddress, (UINT) -1) ||
        (lstrlenA (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        lResult = TAPIERR_INVALDESTADDRESS;
        goto ExitHere;
    }
    else
    {
        szTempPtr3 = NotSoWideStringToWideString(
            lpszDestAddress,
            (DWORD) -1
            );
    }

    if ((lpszAppName && IsBadStringPtrA (lpszAppName, (UINT) -1)) ||
        (lpszCalledParty && IsBadStringPtrA (lpszCalledParty, (UINT) -1)) ||
        (lpszComment && IsBadStringPtrA (lpszComment, (UINT) -1)))
    {
        lResult = TAPIERR_INVALPOINTER;
        goto ExitHere;
    }

    szTempPtr4 = NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    szTempPtr5 = NotSoWideStringToWideString (lpszCalledParty, (DWORD) -1);
    szTempPtr6 = NotSoWideStringToWideString (lpszComment, (DWORD) -1);

    lResult = tapiRequestMediaCallW(
        hWnd,
        wRequestID,
        szTempPtr1,
        szTempPtr2,
        dwSize,
        dwSecure,
        szTempPtr3,
        szTempPtr4,
        szTempPtr5,
        szTempPtr6
        );

ExitHere:
    if (szTempPtr1)
    {
        ClientFree (szTempPtr1);
    }

    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }

    if (szTempPtr3)
    {
        ClientFree (szTempPtr3);
    }

    if (szTempPtr4)
    {
        ClientFree (szTempPtr4);
    }

    if (szTempPtr5)
    {
        ClientFree (szTempPtr5);
    }

    if (szTempPtr6)
    {
        ClientFree (szTempPtr6);
    }

    return lResult;
}


LONG
WINAPI
tapiRequestMediaCall(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCSTR  lpszDeviceClass,
    LPCSTR  lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    return  tapiRequestMediaCallA(
                hWnd,
                wRequestID,
                lpszDeviceClass,
                lpDeviceID,
                dwSize,
                dwSecure,
                lpszDestAddress,
                lpszAppName,
                lpszCalledParty,
                lpszComment
                );
}


//
// ----------------------------------------------------------------------------
//

LONG
WINAPI
GetTapi16CallbackMsg(
    PINIT_DATA  pInitData,
    LPDWORD     pMsg
    )
{
    LONG lResult = 0;


    LOG((TL_TRACE, "GetTapi16CallbackMsg: enter"));

    EnterCriticalSection (&gCriticalSection);

    try
    {
        if (pInitData->dwKey != INITDATA_KEY)
        {
            goto GetTapi16CallbackMsg_leaveCritSec;
        }
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        goto GetTapi16CallbackMsg_leaveCritSec;
    }

    if (pInitData->dwNumUsedEntries > 0)
    {
        CopyMemory(
            pMsg,
            pInitData->pValidEntry,
            sizeof(ASYNC_EVENT_PARAMS)
            );

        pInitData->pValidEntry++;

        if (pInitData->pValidEntry >= (pInitData->pEventBuffer +
                pInitData->dwNumTotalEntries))
        {
            pInitData->pValidEntry = pInitData->pEventBuffer;
        }

        pInitData->dwNumUsedEntries--;

        if (pInitData->dwNumUsedEntries == 0)
        {
            pInitData->bPendingAsyncEventMsg = FALSE;
        }

        lResult = 1;
    }

GetTapi16CallbackMsg_leaveCritSec:

    LeaveCriticalSection (&gCriticalSection);

    LOG((TL_TRACE, "GetTapi16CallbackMsg: exit (result=x%x)", lResult));

    return lResult;
}




//
// ----------------------- Private support routines ---------------------------
//

void
FreeInitData(
    PINIT_DATA  pInitData
    )
{
    EnterCriticalSection (&gCriticalSection);

    if (pInitData && ( pInitData->dwKey != 0xefefefef ) )
    {
        pInitData->dwKey = 0xefefefef;

        LeaveCriticalSection (&gCriticalSection);

        if ((pInitData->dwInitOptions & 0x3) ==
                LINEINITIALIZEEXOPTION_USEEVENT)
        {
            if (pInitData->hEvent)
            {
                //
                // Signal the event to release any threads which might
                // be waiting on it, then close the handle
                //

                SetEvent (pInitData->hEvent);
                CloseHandle (pInitData->hEvent);
            }
        }
        else if ((pInitData->dwInitOptions & 0x3) ==
                    LINEINITIALIZEEXOPTION_USEHIDDENWINDOW)
        {
            // NOTE: let thunk destroy it's own window

            if (pInitData->hwnd && !gbNTVDMClient)
            {
                //
                // If this is the thread which created the window
                // then we can destroy the window in line.  Otherwise,
                // post a message telling the window to destroy itself.
                //

                if (pInitData->dwThreadID == GetCurrentThreadId())
                {
                    DestroyWindow (pInitData->hwnd);
                }
                else
                {
                    PostMessage(
                        pInitData->hwnd,
                        WM_ASYNCEVENT,
                        (WPARAM) gdwInitialTickCount,
                        (LPARAM) 0xffffffff
                        );
                }
            }
        }

        if (pInitData->pEventBuffer)
        {
            ClientFree (pInitData->pEventBuffer);
        }

        DereferenceObject (ghHandleTable, pInitData->hInitData, 1);
		ClientFree (pInitData);
    }
    else
    {
        LeaveCriticalSection (&gCriticalSection);
    }

}

INT_PTR
CALLBACK
TAPIWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (msg)
    {
    case WM_ASYNCEVENT:
    {
        BOOL                bFirstPass = TRUE, bPostMsg = FALSE;
        PINIT_DATA          pInitData = (PINIT_DATA) lParam;


        LOG((TL_TRACE, "TAPIWndProc: received WM_ASYNCEVENT, hwnd=x%p", hwnd));

        if (lParam == (LPARAM) 0xffffffff)
        {
            if (wParam == (WPARAM) gdwInitialTickCount)
            {
                DestroyWindow (hwnd);
            }

            return FALSE;
        }

        while (1)
        {
            //
            // Enter the critical section, verify the pInitData, and
            // see if there are any events in in the queue to process.
            // If so, remove an event from the queue, adjust the
            // ptrs & count, leave the critical section, and call
            // the callback.
            //
            // Note that there is some tricky stuff below to insure
            // that there is always another outstanding WM_ASYNCEVENT
            // msg prior to calling the app's callback (if there are)
            // any more events inthe queue.  This is necessary because
            // some ill-behaved apps have msg loops (to synchronously
            // wait for async request results, etc) within their
            // callbacks, and we don't want to block sending any msgs
            // to them.
            //

            EnterCriticalSection (&gCriticalSection);

            try
            {
                if (pInitData->dwKey != INITDATA_KEY)
                {
                    LOG((TL_ERROR, "TAPIWndProc: bad pInitInst (x%p)", pInitData));
                    LeaveCriticalSection (&gCriticalSection);
                    break;
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                LOG((TL_ERROR, "TAPIWndProc: bad pInitInst (x%p)", pInitData));
                LeaveCriticalSection (&gCriticalSection);
                break;
            }

            if (bFirstPass)
            {
                pInitData->bPendingAsyncEventMsg = FALSE;
                bFirstPass = FALSE;
            }

            if (pInitData->dwNumUsedEntries != 0)
            {
                ASYNC_EVENT_PARAMS      event;
                LINECALLBACK            lpfnCallback;

                CopyMemory(
                    &event,
                    pInitData->pValidEntry,
                    sizeof (ASYNC_EVENT_PARAMS)
                    );

                pInitData->pValidEntry++;

                if (pInitData->pValidEntry >= (pInitData->pEventBuffer +
                        pInitData->dwNumTotalEntries))
                {
                    pInitData->pValidEntry = pInitData->pEventBuffer;
                }

                pInitData->dwNumUsedEntries--;

                if (pInitData->dwNumUsedEntries != 0 &&
                    pInitData->bPendingAsyncEventMsg == FALSE)
                {
                    bPostMsg = TRUE;
                    pInitData->bPendingAsyncEventMsg = TRUE;
                }

                lpfnCallback = pInitData->lpfnCallback;

                LeaveCriticalSection (&gCriticalSection);

                LOG((TL_INFO,
                    "Calling app's callback, hDev=x%x, "\
                        "Msg=%d, dwInst=x%lx P1=x%lx, P2=x%x P3=x%lx",
                    event.hDevice,
                    event.dwMsg,
                    event.dwCallbackInstance,
                    event.dwParam1,
                    event.dwParam2,
                    event.dwParam3
                    ));

                if (bPostMsg)
                {
                    PostMessage (hwnd, WM_ASYNCEVENT, wParam, lParam);
                }

                (*lpfnCallback)(
                    event.hDevice,
                    event.dwMsg,
                    event.dwCallbackInstance,
                    event.dwParam1,
                    event.dwParam2,
                    event.dwParam3
                    );

            }
            else
            {
                LOG((TL_TRACE, "No entries - spurious entry."));

                LeaveCriticalSection (&gCriticalSection);

                break;
            }
        }

        return FALSE;
    }
    default:

        break;
    }

    return (DefWindowProc (hwnd, msg, wParam, lParam));
}

LONG
CreateHiddenWindow(
    HWND   *lphwnd,
    DWORD   dwErrorClass
    )
{
    LONG lResult = 0;

    //
    // Register the hidden window class
    //
    if (!gbHiddenWndClassRegistered)
    {
        DWORD       dwError;
        WNDCLASS    wndclass;


        ZeroMemory(&wndclass, sizeof(WNDCLASS));

        wndclass.lpfnWndProc   = TAPIWndProc;
        wndclass.hInstance     = g_hInst;
        wndclass.lpszClassName = szTapi32WndClass;

        if (!RegisterClass (&wndclass) &&
            ((dwError = GetLastError()) != ERROR_CLASS_ALREADY_EXISTS))
        {
           LOG((TL_ERROR,
               "CreateHiddenWindow: RegisterClass failed, err=%d",
               dwError
               ));
        }
        else
        {
            gbHiddenWndClassRegistered = TRUE;
        }
    }

    if (!(*lphwnd = CreateWindow(
            szTapi32WndClass,   // class name
            NULL,               // title
            WS_OVERLAPPED | WS_MINIMIZE,  // 0,           // dwStyle
            0,                  // x
            0,                  // y
            0,                  // width
            0,                  // height
            (HWND) NULL,        // parent wnd
            (HMENU) NULL,       // menu
            g_hInst,             // instance
            NULL                // params
            )))
    {
        LOG((TL_ERROR, "CreateWindow failed, err=%ld", GetLastError()));

        lResult = gaOpFailedErrors[dwErrorClass];
    }

    return lResult;
}



void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    LOG((TL_TRACE, "midl_user_allocate: enter, size=x%x", len));

    return (ClientAlloc (len));
}


void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    LOG((TL_TRACE, "midl_user_free: enter, p=x%p", ptr));

    ClientFree (ptr);
}

LONG
WINAPI
ReAllocClientResources(
    DWORD dwErrorClass
    )
{
    LONG            lResult;
    DWORD           dwRefCountTemp;


    LOG((TL_TRACE, "AllocClientResources: enter"));

    WaitForSingleObject (ghInitMutex, INFINITE);

    if (0 == gdwRpcRefCount)
    {
        ReleaseMutex (ghInitMutex);
        return TAPIERR_REQUESTFAILED;
    }
    
    dwRefCountTemp = gdwRpcRefCount;
    gdwRpcRefCount = 1;
    FreeClientResources ();
    lResult = AllocClientResources(dwErrorClass);
    if (TAPI_SUCCESS == lResult)
    {
        gdwRpcRefCount = dwRefCountTemp;
    }
    else
    {
        gdwRpcRefCount = 0;
    }

    ReleaseMutex (ghInitMutex);
    return lResult;
}

LONG
WINAPI
AllocClientResources(
    DWORD dwErrorClass
    )
{
    DWORD           dwExceptionCount = 0;
    DWORD           dwError = 0;
    LONG            lResult = gaOpFailedErrors[dwErrorClass];
    SC_HANDLE       hSCMgr = NULL, hTapiSrv = NULL;
    OSVERSIONINFOEX OsVersionEx = { 0 };
    BOOL            bSbsSku = FALSE;

    LOG((TL_TRACE, "AllocClientResources: enter"));
    
    
    // See if we're running on 

    if ((GetVersionEx ((LPOSVERSIONINFO) &OsVersionEx)) &&
         (OsVersionEx.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED))
    {
        bSbsSku = TRUE;             
    }

    //
    // If we're in safeboot mode, tapisrv won't start;
    // fail initialization.  Don't do this check if we're running on SBS.
    //
    if (!bSbsSku && 
        (0 != GetSystemMetrics (SM_CLEANBOOT)))
    {
        lResult = gaOpFailedErrors[dwErrorClass];

        goto AllocClientResources_return;
    }

    //
    // Serialize the following init code
    //

    WaitForSingleObject (ghInitMutex, INFINITE);

    if (0 != gdwRpcRefCount)
    {
        gdwRpcRefCount++;
        lResult = TAPI_SUCCESS;

        goto AllocClientResources_return;
    }

    //
    // Start the TAPISRV.EXE service
    //

    if ((hSCMgr = OpenSCManager(
            NULL,               // local machine
            NULL,               // ServicesActive database
            SC_MANAGER_CONNECT  // desired access
            )) == NULL)
    {
        dwError = GetLastError();
        LOG((TL_ERROR, "OpenSCManager failed, err=%d", dwError ));

        if ( ERROR_ACCESS_DENIED == dwError ||
             ERROR_NOACCESS == dwError
           )
        {
            // if OpenSCManager fails with ACCESS_DENIED, 
            // we still need to try to attach to TAPISRV
            goto AllocClientResources_attachToServer;
        }
        else
        {
            goto AllocClientResources_return;
        }
    }

    if ((hTapiSrv = OpenService(
            hSCMgr,                 // SC mgr handle
            TEXT("TAPISRV"),        // name of service to open
            SERVICE_START |         // desired access
                SERVICE_QUERY_STATUS
            )) == NULL)
    {
        dwError = GetLastError();
        LOG((TL_ERROR, "OpenService failed, err=%d", dwError));

        if ( ERROR_ACCESS_DENIED == dwError ||
             ERROR_NOACCESS == dwError
           )
        {
            // if OpenService fails with ACCESS_DENIED, 
            // we still need to try to attach to TAPISRV
            goto AllocClientResources_attachToServer;
        }
        else
        {
            goto AllocClientResources_cleanup1;
        }
    }

AllocClientResources_queryServiceStatus:

    {
        #define MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV 180

        DWORD   dwNumSecondsSleptStartPending = 0,
                dwNumSecondsSleptStopPending = 0;

        while (1)
        {
            SERVICE_STATUS  status;


            QueryServiceStatus (hTapiSrv, &status);

            switch (status.dwCurrentState)
            {
            case SERVICE_RUNNING:

                LOG((TL_INFO, "Tapisrv running"));
                goto AllocClientResources_attachToServer;

            case SERVICE_START_PENDING:

                Sleep (1000);

                if (++dwNumSecondsSleptStartPending >
                        MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV)
                {
                    LOG((TL_ERROR,
                        "ERROR: Tapisrv stuck SERVICE_START_PENDING"
                        ));

                    goto AllocClientResources_cleanup2;
                }

                break;

            case SERVICE_STOP_PENDING:

                Sleep (1000);

                if (++dwNumSecondsSleptStopPending >
                        MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV)
                {
                    LOG((TL_ERROR,
                        "ERROR: Tapisrv stuck SERVICE_STOP_PENDING"
                        ));

                    goto AllocClientResources_cleanup2;
                }

                break;

            case SERVICE_STOPPED:

                LOG((TL_TRACE, "Starting tapisrv (NT)..."));

                if (!StartService(
                        hTapiSrv,   // service handle
                        0,          // num args
                        NULL        // args
                        ))
                {
                    DWORD dwLastError = GetLastError();


                    if (dwLastError != ERROR_SERVICE_ALREADY_RUNNING)
                    {
                        LOG((TL_ERROR,
                            "StartService(TapiSrv) failed, err=%d",
                            dwLastError
                            ));

                        goto AllocClientResources_cleanup2;
                    }
                }

                break;

            default:

                LOG((TL_ERROR,
                    "error, service status=%d",
                    status.dwCurrentState
                    ));

                goto AllocClientResources_cleanup2;
            }
        }
    }

    //
    // Init the RPC connection
    //

AllocClientResources_attachToServer:

    {
        #define CNLEN              25   // computer name length
        #define UNCLEN        CNLEN+2   // \\computername
        #define PATHLEN           260   // Path
        #define MAXPROTSEQ         20   // protocol sequence "ncacn_np"

        BOOL            bException = FALSE;
        RPC_STATUS      status;
        TCHAR           pszNetworkAddress[UNCLEN+1];
        LPTSTR          pszUuid          = NULL;
        LPTSTR          pszOptions       = NULL;
        LPTSTR          pszStringBinding = NULL;
        LPTSTR          pszBuffer;
        DWORD          dwProcessID = GetCurrentProcessId(), dwSize = 256;
        WCHAR         *pszUserName = ClientAlloc (dwSize * sizeof(WCHAR) );
        WCHAR         *pszComputerName = ClientAlloc(
                            (MAX_COMPUTERNAME_LENGTH+1) * sizeof(WCHAR)
                            );


        pszNetworkAddress[0] = TEXT('\0');

        status = RpcStringBindingCompose(
            pszUuid,
            TEXT("ncalrpc"),
            pszNetworkAddress,
            TEXT("tapsrvlpc"),
            pszOptions,
            &pszStringBinding
            );

        if (status)
        {
            LOG((TL_ERROR,
                "RpcStringBindingCompose failed: err=%d, szNetAddr='%s'",
                status,
                pszNetworkAddress
                ));
            lResult = gaOpFailedErrors[dwErrorClass];
            ClientFree (pszUserName);
            ClientFree (pszComputerName);
            goto AllocClientResources_cleanup2;
        }

        status = RpcBindingFromStringBinding(
            pszStringBinding,
            &hTapSrv
            );

        if (status)
        {
            LOG((TL_ERROR,
                "RpcBindingFromStringBinding failed, err=%d, szBinding='%s'",
                status,
                pszStringBinding
                ));
            lResult = gaOpFailedErrors[dwErrorClass];
            RpcStringFree(&pszStringBinding);
            ClientFree (pszUserName);
            ClientFree (pszComputerName);
            goto AllocClientResources_cleanup2;
        }

        pszBuffer = (LPTSTR)ClientAlloc( (dwSize>(MAX_COMPUTERNAME_LENGTH+1)?dwSize:(MAX_COMPUTERNAME_LENGTH+1) ) * sizeof(TCHAR));
        if ( NULL == pszBuffer )
        {
            LOG((TL_ERROR, "Mem alloc of 0x%lx bytes failed(ca1)", dwSize ));
            lResult = gaOpFailedErrors[dwErrorClass];
            RpcStringFree(&pszStringBinding);
            ClientFree (pszUserName);
            ClientFree (pszComputerName);
            goto AllocClientResources_cleanup2;
        }

        GetUserName(pszBuffer, &dwSize);
        SHTCharToUnicode(pszBuffer, pszUserName, 256);

        dwSize = (MAX_COMPUTERNAME_LENGTH+1);
        GetComputerName( pszBuffer, &dwSize );
        SHTCharToUnicode(pszBuffer, pszComputerName, MAX_COMPUTERNAME_LENGTH+1);

        ClientFree(pszBuffer);

        RpcTryExcept
        {
            LOG((TL_TRACE, "AllocCliRes: calling ClientAttach..."));

            lResult = ClientAttach(
                (PCONTEXT_HANDLE_TYPE *) &gphCx,
                dwProcessID,
                (long *) &ghAsyncEventsEvent,
                pszUserName,
                pszComputerName
                );

            LOG((TL_TRACE, "AllocCliRes: ClientAttach returned x%x", lResult));
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_ERROR,
                "AllocCliRes: ClientAttach caused except=%d",
                RpcExceptionCode()
                ));
            bException = TRUE;
        }
        RpcEndExcept

        ClientFree (pszUserName);
        ClientFree (pszComputerName);

        RpcBindingFree (&hTapSrv);


        RpcStringFree(&pszStringBinding);

        if (bException)
        {

            // 
            // Make sure we don't leak the handle duplicated in ClientAttach
            //
            if (ghAsyncEventsEvent)
            {
                CloseHandle (ghAsyncEventsEvent);
                ghAsyncEventsEvent = NULL;
            }

            //
            // If here chances are that we started the service and it's
            // not ready to receive rpc requests. So we'll give it a
            // little time to get rolling and then try again.
            //

            if (dwExceptionCount < gdwMaxNumRequestRetries)
            {
                Sleep ((++dwExceptionCount > 1 ? gdwRequestRetryTimeout : 0));

                if (hTapiSrv)     // Win NT && successful OpenService()
                {
                    goto AllocClientResources_queryServiceStatus;
                }
                else
                {
                    goto AllocClientResources_attachToServer;
                }
            }
            else
            {
                LOG((TL_ERROR,
                    "AllocCliRes: ClientAttach failed, result=x%x",
                    gaServiceNotRunningErrors[dwErrorClass]
                    ));

                lResult = gaServiceNotRunningErrors[dwErrorClass];
            }
        }
    }

    if (lResult == 0)
    {
        gdwRpcRefCount++;
    }


AllocClientResources_cleanup2:

    if (hTapiSrv) 
    {
        CloseServiceHandle (hTapiSrv);
    }

AllocClientResources_cleanup1:

    if (hSCMgr)
    {
        CloseServiceHandle (hSCMgr);
    }

AllocClientResources_return:

    ReleaseMutex (ghInitMutex);

    LOG((TL_TRACE, "AllocClientResources: exit, returning x%x", lResult));

    return lResult;
}


LONG
PASCAL
xxxShutdown(
    HLINEAPP    hXXXApp,
    BOOL        bLineShutdown
    )
{

//NOTE NOTE NOTE NOTE NOTE NOTE
//NOTE NOTE NOTE NOTE NOTE NOTE
// There is "identical" code in lineShutdownInt - if this changes that should
// probably change as well!!!!!

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, (bLineShutdown ? lShutdown:pShutdown)),

        {
            (ULONG_PTR) hXXXApp
        },

        {
            hXxxApp
        }
    };
    LONG lResult;


    WaitForSingleObject (ghInitMutex, INFINITE);

    lResult = DOFUNC(
        &funcArgs,
        (bLineShutdown ? "lineShutdown" : "phoneShutdown")
        );

    if (lResult == 0)
    {
        PINIT_DATA  pInitData;

        ReleaseAllHandles (ghHandleTable, (PVOID)UIntToPtr(hXXXApp));

        if ((pInitData = ReferenceObject (ghHandleTable, hXXXApp, 0)))
        {
            DereferenceObject (ghHandleTable, hXXXApp, 1);
            FreeInitData (pInitData);
        }

        EnterCriticalSection (&gCriticalSection);

        gdwNumInits--;

        if (gdwNumInits == 0)
        {

            //
            // Tell the async events thread to quit
            //

            gpAsyncEventsThreadParams->bExitThread = TRUE;
            SetEvent (ghAsyncEventsEvent);

            gpAsyncEventsThreadParams = NULL;


            //
            // Safely close any existing generic dialog instances
            //

            if (gpUIThreadInstances)
            {
                PUITHREADDATA   pUIThreadData, pNextUIThreadData;


                pUIThreadData = gpUIThreadInstances;

                while (pUIThreadData)
                {
                    //
                    // Grab a ptr to the next UIThreadData while it's still
                    // safe, wait until the ui dll has indicated that it
                    // is will to receive generic dlg data, then pass it
                    // NULL/0 to tell it to shutdown the dlg inst
                    //

                    pNextUIThreadData = pUIThreadData->pNext;

                    WaitForSingleObject (pUIThreadData->hEvent, INFINITE);

                    LOG((TL_TRACE,
                        "xxxShutdown: calling " \
                            "TUISPI_providerGenericDialogData..."
                        ));

                    (*pUIThreadData->pfnTUISPI_providerGenericDialogData)(
                        pUIThreadData->htDlgInst,
                        NULL,
                        0
                        );

                    LOG((TL_TRACE,
                        "xxxShutdown: " \
                            "TUISPI_providerGenericDialogData returned"
                        ));

                    pUIThreadData = pNextUIThreadData;
                }
            }

            //
            // Free up any other resources we were using
            //

            if (ghWow32Dll)
            {
                FreeLibrary (ghWow32Dll);
                ghWow32Dll = NULL;
            }

            //  Disable tracing after last line shutdown
            TRACELOGDEREGISTER();
        }

        LeaveCriticalSection (&gCriticalSection);
        //
        // Remove the RPC ref count added in lineInitialize
        // 
        FreeClientResources();
    }

    ReleaseMutex (ghInitMutex);

    return lResult;
}


LONG
PASCAL
xxxGetMessage(
    BOOL            bLine,
    HLINEAPP        hXxxApp,
    LPLINEMESSAGE   pMsg,
    DWORD           dwTimeout
    )
{
    LONG        lResult;
    BOOL        bInCriticalSection = FALSE;
    PINIT_DATA  pInitData;


    if (IsBadWritePtr (pMsg, sizeof (LINEMESSAGE)))
    {
        lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxGetMessage_return2;
    }

    if (!(pInitData = (PINIT_DATA) ReferenceObject(
            ghHandleTable,
            hXxxApp,
            INITDATA_KEY
            )))
    {
        LOG((TL_ERROR, "xxxGetMessage:  hXxxApp=x%x invalid", hXxxApp));

        lResult = (bLine ? LINEERR_INVALAPPHANDLE :
            PHONEERR_INVALAPPHANDLE);
        goto xxxGetMessage_return2;
    }

    try
    {
        if ((pInitData->dwInitOptions & 0x3) !=
                LINEINITIALIZEEXOPTION_USEEVENT)
        {
            LOG((TL_ERROR,
                "GetMessage:  This app did not call initex with _USEEVENT"
                ));

            lResult = (bLine ? LINEERR_INVALAPPHANDLE :
                PHONEERR_INVALAPPHANDLE);
            goto xxxGetMessage_return;
        }

        if (pInitData->dwNumUsedEntries)
        {
            EnterCriticalSection (&gCriticalSection);
            bInCriticalSection = TRUE;

            if (pInitData->dwKey == INITDATA_KEY)
            {
                if (pInitData->dwNumUsedEntries)
                {
                    CopyMemory(
                        pMsg,
                        pInitData->pValidEntry,
                        sizeof (ASYNC_EVENT_PARAMS)
                        );

                    pInitData->pValidEntry++;

                    if (pInitData->pValidEntry >= (pInitData->pEventBuffer +
                            pInitData->dwNumTotalEntries))
                    {
                        pInitData->pValidEntry = pInitData->pEventBuffer;
                    }

                    pInitData->dwNumUsedEntries--;


                    //
                    // If the buffer is empty then reset the event
                    // to nonsignaled
                    //

                    if (pInitData->dwNumUsedEntries == 0)
                    {
                        ResetEvent (pInitData->hEvent);
                    }

                    lResult = 0;
                }
                else
                {
                    lResult = (bLine ? LINEERR_OPERATIONFAILED :
                        PHONEERR_OPERATIONFAILED);
                }
            }
            else
            {
                LOG((TL_ERROR, "GetMessage:  bad key2"));

                lResult = (bLine ? LINEERR_INVALAPPHANDLE :
                    PHONEERR_INVALAPPHANDLE);
            }

            LeaveCriticalSection (&gCriticalSection);
            bInCriticalSection = FALSE;
        }
        else
        {
            lResult = (bLine ? LINEERR_OPERATIONFAILED :
                PHONEERR_OPERATIONFAILED);
        }

        if (dwTimeout != 0 && lResult != 0)
        {
xxxGetMessage_wait:

            switch (WaitForSingleObject (pInitData->hEvent, dwTimeout))
            {
            case WAIT_OBJECT_0:

                EnterCriticalSection (&gCriticalSection);
                bInCriticalSection = TRUE;

                if (pInitData->dwKey == INITDATA_KEY)
                {
                    if (pInitData->dwNumUsedEntries)
                    {
                        CopyMemory(
                            pMsg,
                            pInitData->pValidEntry,
                            sizeof (ASYNC_EVENT_PARAMS)
                            );

                        pInitData->pValidEntry++;

                        if (pInitData->pValidEntry >= (pInitData->pEventBuffer+
                                pInitData->dwNumTotalEntries))
                        {
                            pInitData->pValidEntry = pInitData->pEventBuffer;
                        }

                        pInitData->dwNumUsedEntries--;


                        //
                        // If the buffer is empty then reset the event
                        // to nonsignaled
                        //

                        if (pInitData->dwNumUsedEntries == 0)
                        {
                            ResetEvent (pInitData->hEvent);
                        }

                        //
                        // Everything looks good, now.
                        //
                        lResult = 0;
                    }
                    else if (dwTimeout == INFINITE)
                    {
                        LeaveCriticalSection (&gCriticalSection);
                        bInCriticalSection = FALSE;
                        goto xxxGetMessage_wait;
                    }
                }
                else
                {
                    LOG((TL_ERROR, "GetMessage:  bad key1"));
                    lResult = (bLine ? LINEERR_INVALAPPHANDLE :
                        PHONEERR_INVALAPPHANDLE);
                }

                LeaveCriticalSection (&gCriticalSection);
                bInCriticalSection = FALSE;

                break;

            case WAIT_TIMEOUT:
            default:

                lResult = (bLine ? LINEERR_OPERATIONFAILED :
                    PHONEERR_OPERATIONFAILED);
            }
        }
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        LOG((TL_ERROR, "GetMessage:  exception"));

        if (bInCriticalSection)
        {
            LeaveCriticalSection (&gCriticalSection);
        }

        lResult = (bLine ? LINEERR_INVALAPPHANDLE : PHONEERR_INVALAPPHANDLE);
    }

xxxGetMessage_return:

    DereferenceObject (ghHandleTable, hXxxApp, 1);

xxxGetMessage_return2:

    {
        char    szResult[32],
               *pszFuncName = (bLine ? "lineGetMessage" : "phoneGetMessage");
#if DBG
        if (lResult == 0)
        {
            
            LOG((TL_TRACE,
                "%hs: exit, returning msg=%hs\n" \
                    "\thDev=x%01lx, ctx=x%01lx, p1=x%01lx, " \
                    "p2=x%01lx, p3=x%01lx",
                pszFuncName,
                aszMsgs[pMsg->dwMessageID],
                (DWORD)pMsg->hDevice,
                pMsg->dwCallbackInstance,
                pMsg->dwParam1,
                pMsg->dwParam2,
                pMsg->dwParam3
                ));
        }
        else
        {
            LOG((TL_TRACE,
                "%hs: exit, result=%hs",
                pszFuncName,
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
        if (lResult == 0)
        {
            
            LOG((TL_TRACE,
                "%hs: exit, returning msgID=x%x\n" \
                    "\thDev=x%01lx, ctx=x%01lx, p1=x%01lx, " \
                    "p2=x%01lx, p3=x%01lx",
                pszFuncName,
                pMsg->dwMessageID,
                (DWORD)pMsg->hDevice,
                pMsg->dwCallbackInstance,
                pMsg->dwParam1,
                pMsg->dwParam2,
                pMsg->dwParam3
                ));
        }
        else
        {
            LOG((TL_TRACE,
                "%hs: exit, result=x%x",
                pszFuncName,
                lResult
                ));
        }

#endif
    }

    return lResult;
}


/*
#if DBG
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize
    )
#endif
{
    LPVOID  p;


#if DBG
    dwSize += sizeof (MYMEMINFO);
#endif

    p = LocalAlloc (LPTR, dwSize);

#if DBG
    if (p)
    {
        ((PMYMEMINFO) p)->dwLine  = dwLine;
        ((PMYMEMINFO) p)->pszFile = pszFile;

        p = (LPVOID) (((PMYMEMINFO) p) + 1);
    }
#endif

    return p;
}


VOID
WINAPI
ClientFree(
    LPVOID  p
    )
{
    if (!p)
    {
        return;
    }

#if DBG

    //
    // Fill the buffer (but not the MYMEMINFO header) with 0xa1's
    // to facilitate debugging
    //

    {
        LPVOID  p2 = p;


        p = (LPVOID) (((PMYMEMINFO) p) - 1);

        FillMemory(
            p2,
            LocalSize (p) - sizeof (MYMEMINFO),
            0xa1
            );
    }

#endif

    LocalFree (p);
}
*/

#if DBG
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize
    )
#endif
{
    //
    // Alloc 16 extra bytes so we can make sure the pointer we pass back
    // is 64-bit aligned & have space to store the original pointer
    //
#if DBG

    PMYMEMINFO      pHold;
    PDWORD_PTR      pAligned;
    PBYTE           p;

    if (0 == dwSize)
    {
        return NULL;
    }

    p = (PBYTE)LocalAlloc(LPTR, dwSize + sizeof(MYMEMINFO) + 16);

    if (p == NULL)
    {
        return NULL;
    }

    // note note note - this only works because mymeminfo is
    // a 16 bit multiple in size.  if it wasn't, this
    // align stuff would cause problems.
    pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
    *pAligned = (DWORD_PTR) p;
    pHold = (PMYMEMINFO)((DWORD_PTR)pAligned + 8);

    pHold->dwSize = dwSize;
    pHold->dwLine = dwLine;
    pHold->pszFile = pszFile;

    EnterCriticalSection(&csMemoryList);

    if (gpMemLast != NULL)
    {
        gpMemLast->pNext = pHold;
        pHold->pPrev = gpMemLast;
        gpMemLast = pHold;
    }
    else
    {
        gpMemFirst = gpMemLast = pHold;
    }

    LeaveCriticalSection(&csMemoryList);

    return (LPVOID)(pHold + 1);

#else

    LPBYTE  p;
    PDWORD_PTR pAligned;


    if (0 == dwSize)
    {
        return NULL;
    }

    if ((p = (LPBYTE) LocalAlloc (LPTR, dwSize + 16)))
    {
        pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
        *pAligned = (DWORD_PTR) p;
        pAligned = (PDWORD_PTR)((DWORD_PTR)pAligned + 8);
    }
    else
    {
        pAligned = NULL;
    }

    return ((LPVOID) pAligned);
#endif
}


void
WINAPI
ClientFree(
    LPVOID  p
    )
{
#if DBG
    PMYMEMINFO       pHold;

    if (p == NULL)
    {
        return;
    }

    pHold = (PMYMEMINFO)(((LPBYTE)p) - sizeof(MYMEMINFO));

    EnterCriticalSection(&csMemoryList);

    if (pHold->pPrev)
    {
        pHold->pPrev->pNext = pHold->pNext;
    }
    else
    {
        gpMemFirst = pHold->pNext;
    }

    if (pHold->pNext)
    {
        pHold->pNext->pPrev = pHold->pPrev;
    }
    else
    {
        gpMemLast = pHold->pPrev;
    }

    LeaveCriticalSection(&csMemoryList);

    {
        LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)pHold - 8));


        LocalFree (pOrig);
    }
//    LocalFree(pHold);

    return;
#else
    if (p != NULL)
    {
        LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)p - 8));


        LocalFree (pOrig);
    }
#endif

}


#if DBG
void
DumpMemoryList()
{


    PMYMEMINFO       pHold;

    if (gpMemFirst == NULL)
    {
        LOG((TL_INFO, "DumpMemoryList: ALL MEMORY DEALLOCATED"));

        return;
    }

    pHold = gpMemFirst;

    while (pHold)
    {
       LOG((TL_ERROR, "DumpMemoryList: %p not freed - LINE %d FILE %hs!", pHold+1, pHold->dwLine, pHold->pszFile));

       pHold = pHold->pNext;
    }


    if (gbBreakOnLeak)
    {
        DebugBreak();
    }

}
#endif




SIZE_T
WINAPI
ClientSize(
    LPVOID  p
    )
{
    if (p != NULL)
    {
#if DBG
        p = (LPVOID)(((LPBYTE)p) - sizeof(MYMEMINFO));
#endif
        p = (LPVOID)*((PDWORD_PTR)((DWORD_PTR)p - 8));
        return (LocalSize (p) - 16);
    }

    return 0;
}


LONG
WINAPI
FreeClientResources(
    void
    )
{
    //
    // Serialize the following code
    //

    WaitForSingleObject (ghInitMutex, INFINITE);

    if (0 == gdwRpcRefCount)
    {   
        ReleaseMutex (ghInitMutex);
        return TAPIERR_REQUESTFAILED;
    }

    gdwRpcRefCount--;
    if (0 == gdwRpcRefCount)
    {

        //
        // If we've made an rpc connection with tapisrv then cleanly detach
        //

        if (gphCx)
        {
            RpcTryExcept
            {
                ClientDetach (&gphCx);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                // do something?
            }
            RpcEndExcept

            gphCx = NULL;

            // 
            // we also need to close the handle to ghAsyncEventsEvent
            //
            if (ghAsyncEventsEvent)
            {
                SetEvent (ghAsyncEventsEvent);
                CloseHandle(ghAsyncEventsEvent);
                ghAsyncEventsEvent = NULL;
            }
        }
    }

    ReleaseMutex (ghInitMutex);

    return 0;
}


#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN LPTSTR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        TCHAR    buf[1280] = TEXT("TAPI32 (xxxxxxxx): ");
        va_list ap;


        wsprintf( &buf[8], TEXT("%08lx"), GetCurrentThreadId() );
        buf[16] = TEXT(')');

        va_start(ap, lpszFormat);

        wvsprintf(&buf[19],
                   lpszFormat,
                   ap
                  );

        lstrcat (buf, TEXT("\n"));

        OutputDebugString (buf);

        va_end(ap);
    }
}
#endif


LONG
CALLBACK
TUISPIDLLCallback(
    DWORD   dwObjectID,
    DWORD   dwObjectType,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, xUIDLLCallback),

        {
            (ULONG_PTR) dwObjectID,
            (ULONG_PTR) dwObjectType,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "UIDLLCallback"));
}


void
UIThread(
    LPVOID  pParams
    )
{
    DWORD           dwThreadID =  GetCurrentThreadId();
    HANDLE          hTapi32;
    PUITHREADDATA   pUIThreadData = (PUITHREADDATA) pParams;


    LOG((TL_TRACE, "UIThread: enter (tid=%d)", dwThreadID));


    //
    // Call LoadLibrary to increment the reference count in case this
    // thread is still running when this dll gets unloaded
    //

    hTapi32 = LoadLibrary (TEXT("tapi32.dll"));

    LOG((TL_TRACE, "UIThread: calling TUISPI_providerGenericDialog..."));

    (*pUIThreadData->pfnTUISPI_providerGenericDialog)(
        TUISPIDLLCallback,
        pUIThreadData->htDlgInst,
        pUIThreadData->pParams,
        pUIThreadData->dwSize,
        pUIThreadData->hEvent
        );

    LOG((TL_TRACE,
        "UIThread: TUISPI_providerGenericDialog returned (tid=%d)",
        dwThreadID
        ));


    //
    // Remove the ui thread data struct from the global list
    //

    EnterCriticalSection (&gCriticalSection);

    if (pUIThreadData->pNext)
    {
        pUIThreadData->pNext->pPrev = pUIThreadData->pPrev;
    }

    if (pUIThreadData->pPrev)
    {
        pUIThreadData->pPrev->pNext = pUIThreadData->pNext;
    }
    else
    {
        gpUIThreadInstances = pUIThreadData->pNext;
    }

    LeaveCriticalSection (&gCriticalSection);


    //
    // Free the library & buffers, then alert tapisrv
    //

    FreeLibrary (pUIThreadData->hUIDll);

    CloseHandle (pUIThreadData->hThread);

    CloseHandle (pUIThreadData->hEvent);

    if (pUIThreadData->pParams)
    {
        ClientFree (pUIThreadData->pParams);
    }

    {
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 1, xFreeDialogInstance),

            {
                (ULONG_PTR) pUIThreadData->htDlgInst
            },

            {
                Dword
            }
        };


        DOFUNC (&funcArgs, "FreeDialogInstance");
    }

    ClientFree (pUIThreadData);

    LOG((TL_TRACE, "UIThread: exit (tid=%d)", dwThreadID));

    FreeLibraryAndExitThread (hTapi32, 0);
}


LONG
//WINAPI
CALLBACK
LAddrParamsInited(
    LPDWORD lpdwInited
    )
{
    HKEY  hKey;
    HKEY  hKey2;


    //
    // Default to 0, i.e. not initialized
    //

    *lpdwInited = 0;


    //
    // This is called by the modem setup wizard to determine
    // whether they should put up TAPI's Wizard page.
    //

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszTelephonyKey,
            0,
            KEY_READ,
            &hKey2

            ) == ERROR_SUCCESS)
    {
        if (RegOpenKeyEx(
                hKey2,
                gszLocations,
                0,
                KEY_READ,
                &hKey

                ) == ERROR_SUCCESS)
        {

            // query the Locations key for number of locations (subkeys)
            if (RegQueryInfoKey(hKey,
                                NULL,
                                NULL,
                                NULL,
                                lpdwInited,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                ) == ERROR_SUCCESS)
            {

                //
                // Make sure we return a "proper" code
                //

                if ( *lpdwInited > 1 )
                {
                   *lpdwInited = 1;
                }
            }
            RegCloseKey (hKey);
        }

        RegCloseKey (hKey2);
    }

    return 0;
}


LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    );


LONG
CALLBACK
//WINAPI
LOpenDialAsst(
    HWND    hwnd,
    LPCSTR  lpszAddressIn,
    BOOL    fSimple,
    BOOL    fSilentInstall
    )
{
    TCHAR   szBuf[256];
    TCHAR   szWinlogon[64];
    DWORD   dwLengthNeeded;
    HDESK   hDesk;
//   lineTranslateDialog(hLineApp, 0, 0x00020000, hwnd, lpszAddressIn );

    gbTranslateSimple = fSimple;
    gbTranslateSilent = fSilentInstall;

    //
    //  Check to see if we are called from LOGON desktop, if so, simply
    //  make sure we have at least one location
    //
    hDesk = GetThreadDesktop (GetCurrentThreadId ());
    if (hDesk == NULL ||
        !GetUserObjectInformation (
            hDesk,
            UOI_NAME,
            (PVOID)szBuf,
            sizeof(szBuf),
            &dwLengthNeeded
            ) ||
        LoadString (
            g_hInst, 
            IDS_LOGONDESKNAME, 
            szWinlogon, 
            sizeof(szWinlogon)/sizeof(TCHAR)
            ) == 0 ||
        _tcsicmp (szBuf, szWinlogon) == 0)
    {
        return EnsureOneLocation (hwnd);
    }

   return lineTranslateDialogA( 0, 0, 0x00020000, hwnd, lpszAddressIn );
}


/////////////////////////////////////////////////////////////////////
// internalPerformance
//   tapiperf.dll calls this function to get performance data
//   this just calls into tapisrv
/////////////////////////////////////////////////////////////////////
LONG
WINAPI
internalPerformance(
    PPERFBLOCK  pPerfBlock
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, tPerformance),

        {
            (ULONG_PTR) pPerfBlock,
            (ULONG_PTR) sizeof(PERFBLOCK)
        },

        {
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "PerfDataCall"));
}

BOOL 
WaveStringIdToDeviceId(
    LPWSTR  pwszStringID,
    LPCWSTR  pwszDeviceType,
    LPDWORD pdwDeviceId
    )
{
    if (!pwszDeviceType || !pwszStringID)
        return FALSE;

    // get the device id, based on string id and device class
    if ( !_wcsicmp(pwszDeviceType, L"wave/in") ||
         !_wcsicmp(pwszDeviceType, L"wave/in/out")
       )
    {
        return (MMSYSERR_NOERROR == waveInMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));

    } else if (!_wcsicmp(pwszDeviceType, L"wave/out"))
    {
        return (MMSYSERR_NOERROR == waveOutMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    } else if (!_wcsicmp(pwszDeviceType, L"midi/in"))
    {
        return (MMSYSERR_NOERROR == midiInMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    }  else if (!_wcsicmp(pwszDeviceType, L"midi/out"))
    {
        return (MMSYSERR_NOERROR == midiOutMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    }

    return FALSE;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
#if DBG

// Debug only stuff was left as ANSI
char *aszLineErrors[] =
{
    NULL,
    "ALLOCATED",
    "BADDEVICEID",
    "BEARERMODEUNAVAIL",
    "inval err value (0x80000004)",      // 0x80000004 isn't valid err code
    "CALLUNAVAIL",
    "COMPLETIONOVERRUN",
    "CONFERENCEFULL",
    "DIALBILLING",
    "DIALDIALTONE",
    "DIALPROMPT",
    "DIALQUIET",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALADDRESS",                     // 0x80000010
    "INVALADDRESSID",
    "INVALADDRESSMODE",
    "INVALADDRESSSTATE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBEARERMODE",
    "INVALCALLCOMPLMODE",
    "INVALCALLHANDLE",
    "INVALCALLPARAMS",
    "INVALCALLPRIVILEGE",
    "INVALCALLSELECT",
    "INVALCALLSTATE",
    "INVALCALLSTATELIST",
    "INVALCARD",
    "INVALCOMPLETIONID",
    "INVALCONFCALLHANDLE",              // 0x80000020
    "INVALCONSULTCALLHANDLE",
    "INVALCOUNTRYCODE",
    "INVALDEVICECLASS",
    "INVALDEVICEHANDLE",
    "INVALDIALPARAMS",
    "INVALDIGITLIST",
    "INVALDIGITMODE",
    "INVALDIGITS",
    "INVALEXTVERSION",
    "INVALGROUPID",
    "INVALLINEHANDLE",
    "INVALLINESTATE",
    "INVALLOCATION",
    "INVALMEDIALIST",
    "INVALMEDIAMODE",
    "INVALMESSAGEID",                   // 0x80000030
    "inval err value (0x80000031)",      // 0x80000031 isn't valid err code
    "INVALPARAM",
    "INVALPARKID",
    "INVALPARKMODE",
    "INVALPOINTER",
    "INVALPRIVSELECT",
    "INVALRATE",
    "INVALREQUESTMODE",
    "INVALTERMINALID",
    "INVALTERMINALMODE",
    "INVALTIMEOUT",
    "INVALTONE",
    "INVALTONELIST",
    "INVALTONEMODE",
    "INVALTRANSFERMODE",
    "LINEMAPPERFAILED",                 // 0x80000040
    "NOCONFERENCE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOREQUEST",
    "NOTOWNER",
    "NOTREGISTERED",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "RATEUNAVAIL",
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",
    "STRUCTURETOOSMALL",
    "TARGETNOTFOUND",
    "TARGETSELF",
    "UNINITIALIZED",                    // 0x80000050
    "USERUSERINFOTOOBIG",
    "REINIT",
    "ADDRESSBLOCKED",
    "BILLINGREJECTED",
    "INVALFEATURE",
    "NOMULTIPLEINSTANCE",
    "INVALAGENTID",
    "INVALAGENTGROUP",
    "INVALPASSWORD",
    "INVALAGENTSTATE",
    "INVALAGENTACTIVITY",
    "DIALVOICEDETECT"
};

char *aszPhoneErrors[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBUTTONLAMPID",
    "INVALBUTTONMODE",
    "INVALBUTTONSTATE",
    "INVALDATAID",
    "INVALDEVICECLASS",
    "INVALEXTVERSION",
    "INVALHOOKSWITCHDEV",
    "INVALHOOKSWITCHMODE",              // 0x90000010
    "INVALLAMPMODE",
    "INVALPARAM",
    "INVALPHONEHANDLE",
    "INVALPHONESTATE",
    "INVALPOINTER",
    "INVALPRIVILEGE",
    "INVALRINGMODE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOTOWNER",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "inval err value (0x9000001e)",      // 0x9000001e isn't valid err code
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",                   // 0x90000020
    "STRUCTURETOOSMALL",
    "UNINITIALIZED",
    "REINIT"
};

char *aszTapiErrors[] =
{
    "SUCCESS",
    "DROPPED",
    "NOREQUESTRECIPIENT",
    "REQUESTQUEUEFULL",
    "INVALDESTADDRESS",
    "INVALWINDOWHANDLE",
    "INVALDEVICECLASS",
    "INVALDEVICEID",
    "DEVICECLASSUNAVAIL",
    "DEVICEIDUNAVAIL",
    "DEVICEINUSE",
    "DESTBUSY",
    "DESTNOANSWER",
    "DESTUNAVAIL",
    "UNKNOWNWINHANDLE",
    "UNKNOWNREQUESTID",
    "REQUESTFAILED",
    "REQUESTCANCELLED",
    "INVALPOINTER"
};


char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    )
{
    if (lResult == 0)
    {
        wsprintfA (pszResult, "SUCCESS");
    }
    else if (lResult > 0)
    {
        wsprintfA (pszResult, "x%x (completing async)", lResult);
    }
    else if (((DWORD) lResult) <= LINEERR_DIALVOICEDETECT)
    {
        lResult &= 0x0fffffff;

        wsprintfA (pszResult, "LINEERR_%s", aszLineErrors[lResult]);
    }
    else if (((DWORD) lResult) <= PHONEERR_REINIT)
    {
        if (((DWORD) lResult) >= PHONEERR_ALLOCATED)
        {
            lResult &= 0x0fffffff;

            wsprintfA (pszResult, "PHONEERR_%s", aszPhoneErrors[lResult]);
        }
        else
        {
            goto MapResultCodeToText_badErrorCode;
        }
    }
    else if (((DWORD) lResult) <= ((DWORD) TAPIERR_DROPPED) &&
             ((DWORD) lResult) >= ((DWORD) TAPIERR_INVALPOINTER))
    {
        lResult = ~lResult + 1;

        wsprintfA (pszResult, "TAPIERR_%s", aszTapiErrors[lResult]);
    }
    else
    {

MapResultCodeToText_badErrorCode:

        wsprintfA (pszResult, "inval error value (x%x)");
    }

    return pszResult;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplareacodedlg.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplareacodedlg.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

class CAreaCodeRuleDialog
{
public:
    CAreaCodeRuleDialog(BOOL bNew, CAreaCodeRule * pRule);
    ~CAreaCodeRuleDialog();
#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CAreaCodeRuleDialog)
#endif
    INT_PTR DoModal(HWND hwndParent);

protected:
    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwndDlg);
    BOOL OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    void PopulatePrefixList(HWND hwndList);
    void SetPrefixControlsState(HWND hwndDlg, BOOL bAll);

    BOOL ApplyChanges(HWND hwndParent);
    void AddPrefix(HWND hwndParent);
    void RemoveSelectedPrefix(HWND hwndParent);

    BOOL            m_bNew;     // New or Edit in title
    CAreaCodeRule * m_pRule;    // the rule being added/edited
    int             m_iSelectedItem;    // current item selected in the list
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplcallingcardps.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplcallingcardps.cpp
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

// Property Sheet stuff for the main page
#include "cplPreComp.h"
#include "cplCallingCardPS.h"
#include "cplSimpleDialogs.h"
#include <strsafe.h>

#define MaxCallingCardRuleItems 16

CCallingCardPropSheet::CCallingCardPropSheet(BOOL bNew, BOOL bShowPIN, CCallingCard * pCard, CCallingCards * pCards)
{
    m_bNew = bNew;
    m_bShowPIN = bShowPIN;
    m_pCard = pCard;
    m_pCards = pCards;
    m_bWasApplied = FALSE;

    PWSTR pwsz;
    pwsz = pCard->GetLongDistanceRule();
    m_bHasLongDistance = (pwsz && *pwsz);

    pwsz = pCard->GetInternationalRule();
    m_bHasInternational = (pwsz && *pwsz);

    pwsz = pCard->GetLocalRule();
    m_bHasLocal = (pwsz && *pwsz);
}


CCallingCardPropSheet::~CCallingCardPropSheet()
{
}


LONG CCallingCardPropSheet::DoPropSheet(HWND hwndParent)
{
    CCPAGEDATA aPageData[] =
    {
        { this, 0 },
        { this, 1 },
        { this, 2 },
    };

    struct
    {
        int     iDlgID;
        DLGPROC pfnDlgProc;
        LPARAM  lParam;
    }
    aData[] =
    {
        { IDD_CARD_GENERAL,         CCallingCardPropSheet::General_DialogProc,  (LPARAM)this },
        { IDD_CARD_LONGDISTANCE,    CCallingCardPropSheet::DialogProc,          (LPARAM)&aPageData[0] },
        { IDD_CARD_INTERNATIONAL,   CCallingCardPropSheet::DialogProc,          (LPARAM)&aPageData[1] },
        { IDD_CARD_LOCALCALLS,      CCallingCardPropSheet::DialogProc,          (LPARAM)&aPageData[2] },
    };

    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpsp[ARRAYSIZE(aData)];

    // Initialize the header:
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hwndParent;
    psh.hInstance = GetUIInstance();
    psh.hIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(m_bNew?IDS_NEWCALLINGCARD:IDS_EDITCALLINGCARD);
    psh.nPages = ARRAYSIZE(aData);
    psh.nStartPage = 0;
    psh.pfnCallback = NULL;
    psh.phpage = hpsp;

    // Now setup the Property Sheet Page
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = GetUIInstance();

    for (int i=0; i<ARRAYSIZE(aData); i++)
    {
        psp.pszTemplate = MAKEINTRESOURCE(aData[i].iDlgID);
        psp.pfnDlgProc = aData[i].pfnDlgProc;
        psp.lParam = aData[i].lParam;
        hpsp[i] = CreatePropertySheetPage( &psp );
    }

    PropertySheet( &psh );

    return m_bWasApplied?PSN_APPLY:PSN_RESET;
}

// ********************************************************************
// 
// GENERAL page
//
// ********************************************************************

INT_PTR CALLBACK CCallingCardPropSheet::General_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CCallingCardPropSheet* pthis = (CCallingCardPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CCallingCardPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->General_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        pthis->General_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
        return 1;

    case WM_NOTIFY:
        return pthis->General_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a105HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a105HelpIDs);
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::General_OnInitDialog(HWND hwndDlg)
{
    // Set all the edit controls to the inital values
    HWND hwnd;
    TCHAR szText[MAX_INPUT];

    hwnd = GetDlgItem(hwndDlg,IDC_CARDNAME);
    SHUnicodeToTChar(m_pCard->GetCardName(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);

    hwnd = GetDlgItem(hwndDlg,IDC_CARDNUMBER);
    SHUnicodeToTChar(m_pCard->GetAccountNumber(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    hwnd = GetDlgItem(hwndDlg,IDC_PIN);
	if(m_bShowPIN)
	{
    	SHUnicodeToTChar(m_pCard->GetPIN(), szText, ARRAYSIZE(szText));
    	SetWindowText(hwnd, szText);
    }
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    SetTextForRules(hwndDlg);

    return 1;
}

void CCallingCardPropSheet::SetTextForRules(HWND hwndDlg)
{
    TCHAR szText[512];
    int iDlgID = IDC_CARDUSAGE1;
    if ( m_bHasLongDistance )
    {
        // load the "dialing long distance calls." string
        LoadString(GetUIInstance(), IDS_DIALING_LD_CALLS, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    if ( m_bHasInternational )
    {
        // load the "dialing international calls." string
        LoadString(GetUIInstance(), IDS_DIALING_INT_CALLS, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    if ( m_bHasLocal )
    {
        // load the "dialing local calls." string
        LoadString(GetUIInstance(), IDS_DIALING_LOC_CALLS, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    if ( IDC_CARDUSAGE1 == iDlgID )
    {
        // load the "there are no rules defined for this card" string
        LoadString(GetUIInstance(),IDS_NOCCRULES,szText,ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    while (iDlgID <= IDC_CARDUSAGE3)
    {
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), TEXT(""));
        iDlgID++;
    }
}

BOOL CCallingCardPropSheet::General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_CARDNAME:
    case IDC_CARDNUMBER:
    case IDC_PIN:
        switch (wNotifyCode)
        {
        case EN_CHANGE:
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // The only notifies we should receive are from the property sheet
    switch (pnmhdr->code)
    {
    case PSN_APPLY:     // user pressed OK or Apply
        // update all the strings
        HideToolTip();
        return Gerneral_OnApply(hwndDlg);

    case PSN_RESET:     // user pressed Cancel
        HideToolTip();
        break;

    case PSN_SETACTIVE: // user is switching pages
        // the user might have added some rules since switching pages so we
        // need to update the text fields that show which rules are set.
        SetTextForRules(hwndDlg);
        HideToolTip();
        break;
    }
    return 0;
}

BOOL CCallingCardPropSheet::Gerneral_OnApply(HWND hwndDlg)
{
    HWND hwnd;
    DWORD dwStatus;
    PWSTR pwszOldCardNumber;
    PWSTR pwszOldPinNumber;
    WCHAR wsz[MAX_INPUT];
    TCHAR szText[MAX_INPUT];


    LOG((TL_TRACE,  "Gerneral_OnApply:  -- enter"));

    // In order for this to work, I have to first store the new rules into the
    // m_pCard object.  Each page that has been created must be asked to generate
    // it's rule.  We do this in response to the PSM_QUERYSIBLINGS command.
    // Unfortunately, we have to first store a copy of all the data we're about to
    // change.  That way, if the validation fails we can return the CallingCard
    // object to it's original value (so if the user then presses cancel it will
    // be in the correct state).

    // cache the current values for the rules and access numbers
    pwszOldCardNumber = ClientAllocString(m_pCard->GetAccountNumber());
    pwszOldPinNumber = ClientAllocString(m_pCard->GetPIN());

    // now update the object with the value we are about to test.
    hwnd = GetDlgItem(hwndDlg,IDC_CARDNUMBER);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    SHTCharToUnicode(szText, wsz, ARRAYSIZE(wsz));
    m_pCard->SetAccountNumber(wsz);

    hwnd = GetDlgItem(hwndDlg,IDC_PIN);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    SHTCharToUnicode(szText, wsz, ARRAYSIZE(wsz));
    m_pCard->SetPIN(wsz);

    // let the other pages update thier values
    PropSheet_QuerySiblings(GetParent(hwndDlg),0,0);

    // Now we can validate the card.
    dwStatus = m_pCard->Validate();
    if ( dwStatus )
    {
        int iStrID;
        int iDlgItem;
        int iDlgID = 0;

        // Set the current values for the rules and access numbers to our cached values.
        // This is required in case the user later decides to cancel instead of appling.
        m_pCard->SetAccountNumber(pwszOldCardNumber);
        m_pCard->SetPIN(pwszOldPinNumber);
        ClientFree( pwszOldCardNumber );
        ClientFree( pwszOldPinNumber );
        
        // Something isn't right, figure out what.  The order we check these
        // in depends on which tab the error would need to be fixed from.
        // First we check the items that get fixed on the general tab.
        if ( dwStatus & (CCVF_NOCARDNAME|CCVF_NOCARDNUMBER|CCVF_NOPINNUMBER) )
        {
            if ( dwStatus & CCVF_NOCARDNAME )
            {
                iStrID = IDS_MUSTENTERCARDNAME;
                iDlgItem = IDC_CARDNAME;
            }
            else if ( dwStatus & CCVF_NOCARDNUMBER )
            {
                iStrID = IDS_MUSTENTERCARDNUMBER;
                iDlgItem = IDC_CARDNUMBER;
            }
            else
            {
                iStrID = IDS_MUSTENTERPINNUMBER;
                iDlgItem = IDC_PIN;
            }

            iDlgID = IDD_CARD_GENERAL;
        }
        else if ( dwStatus & CCVF_NOCARDRULES )
        {
            // For this problem we stay on whatever page we are already on
            // since this problem can be fixed on one of three different pages.
            iStrID = IDS_NORULESFORTHISCARD;
        }
        else if ( dwStatus & CCVF_NOLONGDISTANCEACCESSNUMBER )
        {
            iStrID = IDS_NOLONGDISTANCEACCESSNUMBER;
            iDlgID = IDD_CARD_LONGDISTANCE;
            iDlgItem = IDC_LONGDISTANCENUMBER;
        }
        else if ( dwStatus & CCVF_NOINTERNATIONALACCESSNUMBER )
        {
            iStrID = IDS_NOINTERNATIONALACCESSNUMBER;
            iDlgID = IDD_CARD_INTERNATIONAL;
            iDlgItem = IDC_INTERNATIONALNUMBER;
        }
        else if ( dwStatus & CCVF_NOLOCALACCESSNUMBER )
        {
            iStrID = IDS_NOLOCALACCESSNUMBER;
            iDlgID = IDD_CARD_LOCALCALLS;
            iDlgItem = IDC_LOCALNUMBER;
        }

        hwnd = GetParent(hwndDlg);
        if ( iDlgID )
        {
            PropSheet_SetCurSelByID(hwnd,iDlgID);
            hwnd = PropSheet_GetCurrentPageHwnd(hwnd);
            hwnd = GetDlgItem(hwnd,iDlgItem);
        }
        else
        {
            hwnd = hwndDlg;
        }
        ShowErrorMessage(hwnd, iStrID);
        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
        return TRUE;
    }

    // Check for the calling card name being unique
    TCHAR szNone[MAX_INPUT];
    LoadString(GetUIInstance(),IDS_NONE, szNone, ARRAYSIZE(szNone));

    hwnd = GetDlgItem(hwndDlg,IDC_CARDNAME);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    if ( 0 == StrCmpIW(szText, szNone) )
    {
        goto buggeroff;
    }
    SHTCharToUnicode(szText, wsz, ARRAYSIZE(wsz));

    CCallingCard * pCard;
    m_pCards->Reset(TRUE);      // TRUE means show "hidden" cards, FALSE means hide them

    while ( S_OK == m_pCards->Next(1,&pCard,NULL) )
    {
        // hidden cards shall remain hidden for ever so we don't check names against those
        if ( !pCard->IsMarkedHidden() )
        {
            // Card0 is the "None (Direct Dial)" card which we don't want to consider
            if ( 0 != pCard->GetCardID() )
            {
                // we don't want to consider ourself either
                if ( pCard->GetCardID() != m_pCard->GetCardID() )
                {
                    // see if the names are identical
                    if ( 0 == StrCmpIW(pCard->GetCardName(), wsz) )
                    {
                        // yes, the name is in conflict
buggeroff:
                        // return altered values to original state
                        m_pCard->SetAccountNumber(pwszOldCardNumber);
                        m_pCard->SetPIN(pwszOldPinNumber);
                        ClientFree( pwszOldCardNumber );
                        ClientFree( pwszOldPinNumber );

                        // display an error message
                        hwnd = GetParent(hwndDlg);
                        PropSheet_SetCurSelByID(hwnd,IDD_CARD_GENERAL);
                        hwnd = PropSheet_GetCurrentPageHwnd(hwnd);
                        hwnd = GetDlgItem(hwnd,IDC_CARDNAME);
                        ShowErrorMessage(hwnd, IDS_NEEDUNIQUECARDNAME);
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
                }
            }
        }
    }

    // card name doesn't conflict, update it.
    m_pCard->SetCardName(wsz);

    m_bWasApplied = TRUE;

    ClientFree( pwszOldCardNumber );
    ClientFree( pwszOldPinNumber );
    return 0;
}


// ********************************************************************
// 
// LONG DISTANCE, INTERNATIONAL, and LOCAL pages
//
// ********************************************************************

INT_PTR CALLBACK CCallingCardPropSheet::DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CCPAGEDATA * pPageData = (CCPAGEDATA *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pPageData = (CCPAGEDATA*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)pPageData); 
        return pPageData->pthis->OnInitDialog(hwndDlg,pPageData->iWhichPage);

    case WM_COMMAND:
        pPageData->pthis->OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam, pPageData->iWhichPage);
        return 1;

    case WM_NOTIFY:
        return pPageData->pthis->OnNotify(hwndDlg, (LPNMHDR)lParam,pPageData->iWhichPage);

    case PSM_QUERYSIBLINGS:
        return pPageData->pthis->UpdateRule(hwndDlg,pPageData->iWhichPage);

    case WM_DESTROY:
        return pPageData->pthis->OnDestroy(hwndDlg);

#define aIDs ((pPageData->iWhichPage==0)?a106HelpIDs:((pPageData->iWhichPage==1)?a107HelpIDs:a108HelpIDs))
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) aIDs);
        break;
#undef aIDs
    }

    return 0;
}

void GetDescriptionForRule(PWSTR pwszRule, PTSTR szText, UINT cchText)
{
    switch (*pwszRule)
    {
    case L',':
        {
            // Check if all characters are commas. If they are not, fall through to the 
            // "dial the specified digits" case
            if(HasOnlyCommasW(pwszRule))
            {
                // add a "wait for x seconds" rule.  Each consecutive ',' adds two seconds to x.
                int iSecondsToWait = lstrlenW(pwszRule)*2;
                TCHAR szFormat[256];
                LPTSTR aArgs[] = {(LPTSTR)UIntToPtr(iSecondsToWait)};

                LoadString(GetUIInstance(),IDS_WAITFORXSECONDS, szFormat, ARRAYSIZE(szFormat));

                FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szFormat, 0,0, szText, cchText, (va_list *)aArgs );

                break;        
            }
        }

        // ATTENTION !!
        // Fall through

    case L'0':
    case L'1':
    case L'2':
    case L'3':
    case L'4':
    case L'5':
    case L'6':
    case L'7':
    case L'8':
    case L'9':
    case L'A':
    case L'a':
    case L'B':
    case L'b':
    case L'C':
    case L'c':
    case L'D':
    case L'd':
    case L'#':
    case L'*':
    case L'+':
    case L'!':
        {
            // Add a "dial the specified digits" rule.  The whole sequence of these digits should
            // be considered to be one rule.
            TCHAR szRule[MAX_INPUT];
            TCHAR szFormat[MAX_INPUT];
            TCHAR szTemp[MAX_INPUT*2]; // big enough for the rule and the format
            LPTSTR aArgs[] = {szRule};

            SHUnicodeToTChar(pwszRule, szRule, ARRAYSIZE(szRule));
            LoadString(GetUIInstance(),IDS_DIALX, szFormat, ARRAYSIZE(szFormat));

            // The formated message might be larger than cchText, in which case we just
            // want to truncate the result.  FormatMessage would simply fail in that case
            // so we format to a larger buffer and then truncate down.
            if (FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    szFormat, 0,0, szTemp, ARRAYSIZE(szTemp), (va_list *)aArgs ))
            {
                StrCpyN(szText, szTemp, cchText);
            }
            else
            {
                szText[0] = 0;
            }
        }
        break;

    default:
        {
            int iStrID;

            switch (*pwszRule)
            {
            case L'J':
                // add a "dial the access number" rule.
                iStrID = IDS_DIALACCESSNUMBER;
                break;

            case L'K':
                // add a "dial the account number" rule.
                iStrID = IDS_DIALACOUNTNUMBER;
                break;

            case L'H':
                // add a "dial the pin number" rule.
                iStrID = IDS_DIALPINNUMBER;
                break;

            case L'W':
                // add a "Wait for dial tone" rule.
                iStrID = IDS_WAITFORDIALTONE;
                break;

            case L'@':
                // add a "Wait for quiet" rule.
                iStrID = IDS_WAITFORQUIET;
                break;

            case L'E':
            case L'F':
            case L'G':
                // add a "dial the destination number" rule.  We look for these three letters together.
                // Only certain combinations of these letters are valid, as indicated below:
                if ( 0 == StrCmpW(pwszRule, L"EFG") )
                {
                    iStrID = IDS_DIAL_CCpACpNUM;
                }
                else if ( 0 == StrCmpW(pwszRule, L"EG") )
                {
                    iStrID = IDS_DIAL_CCpNUM;
                }
                else if ( 0 == StrCmpW(pwszRule, L"FG") )
                {
                    iStrID = IDS_DIAL_ACpNUM;
                }
                else if ( 0 == StrCmpW(pwszRule, L"E") )
                {
                    iStrID = IDS_DIAL_CC;
                }
                else if ( 0 == StrCmpW(pwszRule, L"F") )
                {
                    iStrID = IDS_DIAL_AC;
                }
                else if ( 0 == StrCmpW(pwszRule, L"G") )
                {
                    iStrID = IDS_DIAL_NUM;
                }
                break;

            default:
                // We shouldn't be able to get here"
                LOG((TL_ERROR, "Invalid calling card rule"));
                szText[0] = NULL;
                return;
            }

            LoadString(GetUIInstance(), iStrID, szText, cchText);
        }
        break;
    }
}

void PopulateStepList(HWND hwndList, PWSTR pwszRuleList)
{
    TCHAR szText[MAX_INPUT];
    WCHAR wch;
    PWSTR pwsz;

    int i = 0;

    // Parse the string into a series of rules.  There are only types of rules that we should see
    // in a calling card sting:
    //  J               dial the access number
    //  K               dial the account number
    //  H               dial the pin number
    //  0-9,#,*,+,!,ABCD Dial the digits directly
    //  W               Wait for dial tone
    //  @               Wait for quiet
    //  ,               Wait for two seconds
    //  E               Dial the counrty code
    //  F               Dial the area code
    //  G               Dial the local number (prefix and root)

    // We copy the characters for the given rule into a buffer.  Then we allocate a heap
    // buffer into which these characters get copied.  Each list view item tracks one of
    // these character buffers in it's lParam data.

    LOG((TL_INFO, "Rule to process (%ls)",pwszRuleList));
    while ( *pwszRuleList )
    {
        switch (*pwszRuleList)
        {
        case L'J':
            // add a "dial the access number" rule.
        case L'K':
            // add a "dial the account number" rule.
        case L'H':
            // add a "dial the pin number" rule.
        case L'W':
            // add a "Wait for dial tone" rule.
        case L'@':
            // add a "Wait for quiet" rule.

            // These are all the one character rules.
            pwsz = pwszRuleList+1;
            LOG((TL_INFO, "JKHW@ case (%ls) <%p>",pwsz,pwsz));
            break;

        case L'E':
        case L'F':
        case L'G':
            // add a "dial the destination number" rule.  We look for these three letters together.
            // If we find a consecutive group of these digits then we treat them as one rule.  Only
            // a few combinations of these letters are actually valid rules.  If we find some other
            // combination then we must treat it as a seperate rule instead of a single rule.  We
            // start by looking for the longest valid rules and then check for the shorter ones.
            if ( 0 == StrCmpNW(pwszRuleList, L"EFG", 3) )
            {
                pwsz = pwszRuleList+3;
            }
            else if ( 0 == StrCmpNW(pwszRuleList, L"EG", 2) )
            {
                pwsz = pwszRuleList+2;
            }
            else if ( 0 == StrCmpNW(pwszRuleList, L"FG", 2) )
            {
                pwsz = pwszRuleList+2;
            }
            else
            {
                pwsz = pwszRuleList+1;
            }
            LOG((TL_INFO, "EFG case (%ls)",pwsz));
            break;

        case L',':
            // add a "wait for x seconds" rule.  Each consecutive , adds two seconds to x.
            pwsz = pwszRuleList+1;
            while ( *(pwsz) == L',' )
            {
                pwsz++;
            }
            break;

        case L'0':
        case L'1':
        case L'2':
        case L'3':
        case L'4':
        case L'5':
        case L'6':
        case L'7':
        case L'8':
        case L'9':
        case L'A':
        case L'a':
        case L'B':
        case L'b':
        case L'C':
        case L'c':
        case L'D':
        case L'd':
        case L'#':
        case L'*':
        case L'+':
        case L'!':
            // Add a "dial the specified digits" rule.  The whole sequence of these digits should
            // be considered to be one rule.
            pwsz = pwszRuleList+1;
            while ( ((*pwsz >= L'0') && (*pwsz <= L'9')) ||
                    ((*pwsz >= L'A') && (*pwsz <= L'D')) ||
                    ((*pwsz >= L'a') && (*pwsz <= L'd')) ||
                    (*pwsz == L'#') ||
                    (*pwsz == L'*') ||
                    (*pwsz == L'+') ||
                    (*pwsz == L'!')
                    )
            {
                pwsz++;
            }
            LOG((TL_INFO, "0-9,A-D,#,*,+,! case (%ls)", pwsz));
            break;

        default:
            // We shouldn't be able to get here
            LOG((TL_ERROR, "Invalid calling card rule"));

            // we just ignore this character and go back to the while loop.  Yes, this is a continue
            // inside a switch inside a while loop.  A bit confusing, perhaps, but it's what we want.
            pwszRuleList++;
            continue;
        }

        // we temporarily stick a NULL into wpszRuleList to seperate out one rule
        wch = *pwsz;
        *pwsz = NULL;

        // for each rule, add a list box entry
        LVITEM lvi;
        lvi.mask = LVIF_TEXT|LVIF_PARAM;
        lvi.iItem = i++;
        lvi.iSubItem = 0;
        lvi.pszText = szText;
        lvi.lParam = (LPARAM)ClientAllocString(pwszRuleList);
        GetDescriptionForRule(pwszRuleList, szText, ARRAYSIZE(szText));
        LOG((TL_INFO, "Description for (%ls) is (%s)", pwszRuleList,szText));

        ListView_InsertItem(hwndList, &lvi);

        // restore pwszRuleList to it's former state before continuing or this is going to be a real short ride.
        pwsz[0] = wch;

        // after the above restoration, pwsz points to the head of the next rule (or to a NULL)
        pwszRuleList = pwsz;
    }

    int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if ( ListView_GetItemCount(hwndList) > 0 )
    {
        if (-1 == iSelected)
            iSelected = 0;

        ListView_SetItemState(hwndList, iSelected, LVIS_SELECTED, LVIS_SELECTED);
    }
}

BOOL CCallingCardPropSheet::OnInitDialog(HWND hwndDlg, int iPage)
{
    LOG((TL_TRACE,  "OnInitDialog <%d>",iPage));

    PWSTR pwsz;
    RECT rc;
    HWND hwnd = GetDlgItem(hwndDlg, IDC_LIST);

    GetClientRect(hwnd, &rc);

    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn( hwnd, 0, &lvc );
    
    ListView_SetExtendedListViewStyleEx(hwnd,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    switch ( iPage )
    {
    case 0:
        pwsz = m_pCard->GetLongDistanceRule();
        break;

    case 1:
        pwsz = m_pCard->GetInternationalRule();
        break;

    case 2:
        pwsz = m_pCard->GetLocalRule();
        break;

    default:
        LOG((TL_ERROR, "OnInitDialog: Invalid page ID %d, failing.", iPage));
        return -1;
    }
    PopulateStepList(hwnd, pwsz);

    int iDlgItem;
    switch (iPage)
    {
    case 0:
        iDlgItem = IDC_LONGDISTANCENUMBER;
        pwsz = m_pCard->GetLongDistanceAccessNumber();
        break;

    case 1:
        iDlgItem = IDC_INTERNATIONALNUMBER;
        pwsz = m_pCard->GetInternationalAccessNumber();
        break;

    case 2:
        iDlgItem = IDC_LOCALNUMBER;
        pwsz = m_pCard->GetLocalAccessNumber();
        break;
    }

    TCHAR szText[MAX_INPUT];
    hwnd = GetDlgItem(hwndDlg,iDlgItem);
    SHUnicodeToTChar(pwsz, szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    // disable the buttons since no item is selected by default
    SetButtonStates(hwndDlg,-1);

    return 0;
}

BOOL CCallingCardPropSheet::OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl, int iPage)
{
    HWND hwndList = GetDlgItem(hwndParent, IDC_LIST);

    switch ( wID )
    {
    case IDC_LONGDISTANCENUMBER:
    case IDC_INTERNATIONALNUMBER:
    case IDC_LOCALNUMBER:
        if (EN_CHANGE == wNotifyCode)
        {
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
        }
        break;

    case IDC_MOVEUP:
    case IDC_MOVEDOWN:
    case IDC_REMOVE:
        {
            TCHAR szText[MAX_INPUT];
            int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

            if (-1 != iSelected)
            {
                LVITEM lvi;
                lvi.mask = LVIF_TEXT | LVIF_PARAM;
                lvi.iItem = iSelected;
                lvi.iSubItem = 0;
                lvi.pszText = szText;
                lvi.cchTextMax = ARRAYSIZE(szText);
                ListView_GetItem(hwndList, &lvi);

                ListView_DeleteItem(hwndList, iSelected);

                if ( IDC_MOVEDOWN == wID )
                {
                    iSelected++;
                }
                else
                {
                    iSelected--;
                }

                if ( IDC_REMOVE == wID )
                {
                    ClientFree( (PWSTR)lvi.lParam );
                    if ( ListView_GetItemCount(hwndList) > 0 )
                    {
                        if (-1 == iSelected)
                            iSelected = 0;

                        ListView_SetItemState(hwndList, iSelected, LVIS_SELECTED, LVIS_SELECTED); 
                    }
                    else
                    {
                        // the last rule was deleted, update the "has rule" state
                        switch (iPage)
                        {
                        case 0:
                            m_bHasLongDistance = FALSE;
                            break;

                        case 1:
                            m_bHasInternational = FALSE;
                            break;

                        case 2:
                            m_bHasLocal = FALSE;
                            break;
                        }
                        if ( GetFocus() == hwndCrl )
                        {
                            HWND hwndDef = GetDlgItem(hwndParent,IDC_ACCESSNUMBER);
                            SendMessage(hwndCrl, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
                            SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
                            SetFocus(hwndDef);
                        }
                        EnableWindow(hwndCrl,FALSE);
                    }
                }
                else
                {
                    lvi.mask |= LVIF_STATE;
                    lvi.iItem = iSelected;
                    lvi.state = lvi.stateMask = LVIS_SELECTED;
                    iSelected = ListView_InsertItem(hwndList, &lvi);
                }

                ListView_EnsureVisible(hwndList, iSelected, FALSE);
            }

            SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
        }
        break;

    case IDC_ACCESSNUMBER:
    case IDC_PIN:
    case IDC_CARDNUMBER:
    case IDC_DESTNUMBER:
    case IDC_WAITFOR:
    case IDC_SPECIFYDIGITS:
        {
            TCHAR szText[MAX_INPUT];
            WCHAR wszRule[MAX_INPUT];
            int iItem = ListView_GetItemCount(hwndList);
            LVITEM lvi;
            lvi.mask = LVIF_TEXT | LVIF_PARAM;
            lvi.iItem = iItem;
            lvi.iSubItem = 0;
            lvi.pszText = szText;

            switch ( wID )
            {
                case IDC_ACCESSNUMBER:
                    lvi.lParam = (LPARAM)ClientAllocString(L"J");
                    break;

                case IDC_PIN:
                    lvi.lParam = (LPARAM)ClientAllocString(L"H");
                    break;

                case IDC_CARDNUMBER:
                    lvi.lParam = (LPARAM)ClientAllocString(L"K");
                    break;

                case IDC_DESTNUMBER:
                    {
                        CDestNumDialog dnd(iPage==1, iPage!=2);
                        INT_PTR iRes = dnd.DoModal(hwndParent);
                        if (iRes == (INT_PTR)IDOK)
                        {
                            lvi.lParam = (LPARAM)ClientAllocString(dnd.GetResult());
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    break;

                case IDC_WAITFOR:
                    {
                        CWaitForDialog wd;
                        INT_PTR ipRes = wd.DoModal(hwndParent);
                        if (ipRes == (INT_PTR)IDOK)
                        {
                            int iRes;
                            iRes = wd.GetWaitType();
                            LOG((TL_INFO, "WaitType is %d", iRes));
                            switch (iRes)
                            {
                            case 0:
                                lvi.lParam = (LPARAM)ClientAllocString(L"W");
                                break;

                            case 1:
                                lvi.lParam = (LPARAM)ClientAllocString(L"@");
                                break;

                            default:
                                iRes = iRes/2;
                                if ( ARRAYSIZE(wszRule) <= iRes )
                                {
                                    iRes = ARRAYSIZE(wszRule)-1;
                                }

                                for (int i=0; i<iRes; i++)
                                {
                                    wszRule[i] = L',';
                                }
                                wszRule[i] = NULL;
                                lvi.lParam = (LPARAM)ClientAllocString(wszRule);
                                break;
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    break;

                case IDC_SPECIFYDIGITS:
                    {
                        CEditDialog ed;
                        WCHAR   *pwcSrc, *pwcDest;
                        INT_PTR iRes = ed.DoModal(hwndParent, IDS_SPECIFYDIGITS, IDS_TYPEDIGITS, IDS_DIGITS, 
                            LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA|LIF_ALLOWPLUS|LIF_ALLOWBANG|LIF_ALLOWATOD);
                        if (iRes == (INT_PTR)IDOK)
                        {
                            SHTCharToUnicode(ed.GetString(), wszRule, ARRAYSIZE(wszRule));
                            // Strip the spaces
                            pwcSrc  = wszRule;
                            pwcDest = wszRule;
                            do
                            {
                                if(*pwcSrc != TEXT(' '))    // including the NULL
                                    *pwcDest++ = *pwcSrc;
                            } while(*pwcSrc++);
                            
                            if (!wszRule[0])
                                return 0;

                            lvi.lParam = (LPARAM)ClientAllocString(wszRule);
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    break;
            }

            if (NULL != lvi.lParam)
            {
                GetDescriptionForRule((PWSTR)lvi.lParam, szText, ARRAYSIZE(szText));

                iItem = ListView_InsertItem(hwndList, &lvi);
                ListView_EnsureVisible(hwndList, iItem, FALSE);
                int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
                if ( ListView_GetItemCount(hwndList) > 0 )
                {
                    if (-1 == iSelected)
                        iSelected = 0;

                    ListView_SetItemState(hwndList, iSelected, LVIS_SELECTED, LVIS_SELECTED);
                }
            }

            // a new rule was added, update the "has rule" state
            switch (iPage)
            {
            case 0:
                m_bHasLongDistance = TRUE;
                break;

            case 1:
                m_bHasInternational = TRUE;
                break;

            case 2:
                m_bHasLocal = TRUE;
                break;
            }

            // update the property sheet state
            SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
        }
        break;

    default:
        break;
    }
    return 0;
}

void CCallingCardPropSheet::SetButtonStates(HWND hwndDlg, int iItem)
{
    EnableWindow(GetDlgItem(hwndDlg,IDC_MOVEUP), iItem>0);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MOVEDOWN),
                 (-1!=iItem) && (ListView_GetItemCount(GetDlgItem(hwndDlg,IDC_LIST))-1)!=iItem);
    EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), -1!=iItem);
}

BOOL CCallingCardPropSheet::OnNotify(HWND hwndDlg, LPNMHDR pnmhdr, int iPage)
{
    switch ( pnmhdr->idFrom )
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if (pnmlv->uChanged & LVIF_STATE)
            {
                if (pnmlv->uNewState & LVIS_SELECTED)
                {
                    SetButtonStates(hwndDlg,pnmlv->iItem);
                }
                else
                {
                    SetButtonStates(hwndDlg,-1);
                }
            }
            break;

        default:
            break;
        }
        break;
        #undef pnmlv

    default:
        switch (pnmhdr->code)
        {
        case PSN_APPLY:     // user pressed OK or Apply
            LOG((TL_INFO, "OnApply <%d>", iPage));
        case PSN_RESET:     // user pressed Cancel
        case PSN_KILLACTIVE: // user is switching pages
            HideToolTip();
            break;
        }
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::UpdateRule(HWND hwndDlg, int iPage)
{
    LOG((TL_TRACE,  "UpdateRule <%d>",iPage));
    
    HRESULT hr = S_OK;
    WCHAR wszRule[1024];
    PWSTR pwsz = wszRule;
    HWND hwnd = GetDlgItem(hwndDlg,IDC_LIST);

    // in case there are no rules, we need to NULL the string
    wszRule[0] = L'\0';

    // add up all the items in the list and set the correct string
    int iItems = ListView_GetItemCount(hwnd);
    if (iItems > MaxCallingCardRuleItems)
    {
        iItems = MaxCallingCardRuleItems;
    }

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    for (int i=0; i<iItems && SUCCEEDED(hr); i++)
    {
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);

        hr = StringCchCatExW(pwsz, 1024, (PWSTR)lvi.lParam, NULL, NULL, STRSAFE_NO_TRUNCATION);
        LOG((TL_INFO, "UpdateRule\tRule %d: %ls %s", i, lvi.lParam, SUCCEEDED(hr) ? "SUCCEEDED" : "FAILED"));
    }

    int iDlgItem;

    switch(iPage)
    {
    case 0:
        m_pCard->SetLongDistanceRule(wszRule);
        iDlgItem = IDC_LONGDISTANCENUMBER;
        break;

    case 1:
        m_pCard->SetInternationalRule(wszRule);
        iDlgItem = IDC_INTERNATIONALNUMBER;
        break;

    case 2:
        m_pCard->SetLocalRule(wszRule);
        iDlgItem = IDC_LOCALNUMBER;
        break;
    }

    TCHAR szText[MAX_INPUT];
    hwnd = GetDlgItem(hwndDlg,iDlgItem);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    SHTCharToUnicode(szText, wszRule, ARRAYSIZE(wszRule));

    switch(iPage)
    {
    case 0:
        m_pCard->SetLongDistanceAccessNumber(wszRule);
        break;

    case 1:
        m_pCard->SetInternationalAccessNumber(wszRule);
        break;

    case 2:
        m_pCard->SetLocalAccessNumber(wszRule);
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::OnDestroy(HWND hwndDlg)
{
    HWND hwnd = GetDlgItem(hwndDlg,IDC_LIST);
    
    // Free the memory we allocated and track in the list view
    int iItems = ListView_GetItemCount(hwnd);
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    for (int i=0; i<iItems; i++)
    {
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);

        ClientFree((PWSTR)lvi.lParam);
    }

    return TRUE;
}


BOOL  HasOnlyCommasW(PWSTR pwszStr)
{
    while(*pwszStr)
        if(*pwszStr++ != L',')
            return FALSE;

    return TRUE;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplareacodedlg.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplareacodedlg.cpp
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#include "cplPreComp.h"
#include "cplAreaCodeDlg.h"
#include "cplSimpleDialogs.h"

CAreaCodeRuleDialog::CAreaCodeRuleDialog(BOOL bNew, CAreaCodeRule * pRule)
{
    m_bNew = bNew;
    m_pRule = pRule;
    m_iSelectedItem = -1;
}

CAreaCodeRuleDialog::~CAreaCodeRuleDialog()
{
}

INT_PTR CAreaCodeRuleDialog::DoModal(HWND hwndParent)
{
    return DialogBoxParam( GetUIInstance(), MAKEINTRESOURCE(IDD_NEWAREACODERULE), hwndParent, CAreaCodeRuleDialog::DialogProc, (LPARAM)this );
}

INT_PTR CALLBACK CAreaCodeRuleDialog::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAreaCodeRuleDialog * pthis = (CAreaCodeRuleDialog *)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CAreaCodeRuleDialog *)lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis);
        return pthis->OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);

    case WM_NOTIFY:
        return pthis->OnNotify(hwndDlg, (LPNMHDR)lParam);
    
    case WM_HELP:
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a109HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a109HelpIDs);
    }
    return 0;
}

void CAreaCodeRuleDialog::PopulatePrefixList(HWND hwndList)
{
    TCHAR szText[MAX_INPUT];
    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.pszText = szText;
    int i;
    LPWSTR pszz = m_pRule->GetPrefixList();

    if (pszz)
    {
        while (*pszz)
        {
            SHUnicodeToTChar( pszz, szText, ARRAYSIZE(szText) );
            ListView_InsertItem(hwndList, &lvi);
            pszz += lstrlenW(pszz)+1;
        }
    }
}

void CAreaCodeRuleDialog::SetPrefixControlsState(HWND hwndDlg, BOOL bAll)
{
    HWND hwndList = GetDlgItem(hwndDlg,IDC_PREFIXES);
    EnableWindow(hwndList, !bAll);
    hwndList = GetDlgItem(hwndDlg, IDC_LIST);
    EnableWindow(hwndList, !bAll);
    EnableWindow(GetDlgItem(hwndDlg,IDC_ADD),  !bAll);

    // by default, no prefix is selected so the remove button is always disabled at first
    if (m_iSelectedItem == -1)
    {
        m_iSelectedItem = 0;
    }
    EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), ListView_GetItemCount(hwndList) && !bAll);
    if (!bAll)
    {
        ListView_SetItemState(hwndList, m_iSelectedItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
    }
}

BOOL CAreaCodeRuleDialog::OnInitDialog(HWND hwndDlg)
{
    HWND hwnd;
    TCHAR szText[MAX_INPUT];

    if ( !m_bNew )
    {
        LoadString(GetUIInstance(),IDS_EDITRULE, szText, ARRAYSIZE(szText));
        SetWindowText(hwndDlg, szText);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
    SHUnicodeToTChar(m_pRule->GetAreaCode(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);

    BOOL bAll = m_pRule->HasAppliesToAllPrefixes();
    CheckRadioButton(hwndDlg, IDC_ALLPREFIXES, IDC_LISTEDPREFIXES, bAll?IDC_ALLPREFIXES:IDC_LISTEDPREFIXES);

    // populate the prefix list
    hwnd = GetDlgItem(hwndDlg, IDC_LIST);
    RECT rc;
    GetClientRect(hwnd, &rc);
    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn( hwnd, 0, &lvc );
    PopulatePrefixList(hwnd);
    if (ListView_GetItemCount(hwnd) > 0)
    {
        m_iSelectedItem = 0;
        ListView_SetItemState(hwnd, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
    }

    SetPrefixControlsState(hwndDlg, bAll);

    hwnd = GetDlgItem(hwndDlg,IDC_DIALNUMBER);
    SHUnicodeToTChar(m_pRule->GetNumberToDial(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    if ( m_pRule->HasDialNumber() )
    {
        SendMessage( GetDlgItem(hwndDlg,IDC_DIALCHECK), BM_SETCHECK, BST_CHECKED, 0 );
    }
    else
    {
        EnableWindow(hwnd, FALSE);
    }
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA);

    if ( m_pRule->HasDialAreaCode() )
    {
        SendMessage( GetDlgItem(hwndDlg,IDC_DIALAREACODE), BM_SETCHECK, BST_CHECKED, 0 );
    }

    return 1;
}

BOOL CAreaCodeRuleDialog::OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch (wID)
    {
    case IDOK:
        if (!ApplyChanges(hwndParent) )
        {
            break;
        }
        // fall through

    case IDCANCEL:
        HideToolTip();
        EndDialog(hwndParent,wID);
        break;

    case IDC_ALLPREFIXES:
    case IDC_LISTEDPREFIXES:
        SetPrefixControlsState(hwndParent, IDC_ALLPREFIXES==wID);
        break;

    case IDC_ADD:
        AddPrefix(hwndParent);
        break;

    case IDC_REMOVE:
        RemoveSelectedPrefix(hwndParent);
        break;

    case IDC_DIALCHECK:
        if ( BN_CLICKED == wNotifyCode )
        {
            BOOL bOn = SendMessage(hwndCrl, BM_GETCHECK, 0,0) == BST_CHECKED;
            HWND hwnd = GetDlgItem(hwndParent, IDC_DIALNUMBER);
            EnableWindow(hwnd, bOn);
            if ( bOn )
            {
                SetFocus(hwnd);
            }
        }
        break;

    default:
        return 0;
    }

    return 1;
}

BOOL CAreaCodeRuleDialog::OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    switch (pnmhdr->idFrom)
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( (pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED) )
            {
                m_iSelectedItem = pnmlv->iItem;

                EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), pnmlv->iItem != -1);
            }
            break;

        case NM_DBLCLK:
            if ( -1 == pnmlv->iItem )
            {
                // Do new case
                AddPrefix(hwndDlg);
            }
            break;

        case NM_CLICK:
            if ( (-1 == pnmlv->iItem) && (-1!=m_iSelectedItem) )
            {
                m_iSelectedItem = -1;

                EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), FALSE);
            }
            break;

        default:
            break;

        }
        break;
        #undef pnmlv

    default:
        return 0;
    }
    return 1;
}

BOOL CAreaCodeRuleDialog::ApplyChanges(HWND hwndParent)
{
    TCHAR szAreaCode[MAX_INPUT] = {0};
    TCHAR szBuffer[MAX_INPUT];
    WCHAR wszBuffer[1024];
    PWSTR pwsz;
    HWND hwnd;

    // read the area code
    hwnd = GetDlgItem(hwndParent,IDC_AREACODE);
    GetWindowText(hwnd, szAreaCode, ARRAYSIZE(szAreaCode));
    if ( !*szAreaCode )
    {
        ShowErrorMessage(hwnd, IDS_NEEDANAREACODE);
        return FALSE;
    }

    // read the prefix list
    hwnd = GetDlgItem(hwndParent, IDC_LIST);
    int iItems = ListView_GetItemCount(hwnd);
    int i;
    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;
    lvi.pszText = szBuffer;
    lvi.cchTextMax = ARRAYSIZE(szBuffer);

    UINT cchFree = ARRAYSIZE(wszBuffer);
    wszBuffer[1] = TEXT('\0');  // ensure double NULL termination if iItems is zero
    pwsz = wszBuffer;
    for (i=0; i<iItems; i++)
    {
        UINT cchPrefix;
        lvi.mask = LVIF_TEXT;
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);

        cchPrefix = lstrlen(szBuffer);
        if (cchPrefix >= cchFree)
        {
            // out of space in temp buffer.  Hopefully this will never happen
            LOG((TL_ERROR, "ApplyChanges: Out of space in temp buffer."));
            break;
        }
        SHTCharToUnicode(szBuffer, pwsz, cchFree-1);
        pwsz += cchPrefix+1;
        cchFree -= cchPrefix+1;
    }
    *pwsz = NULL;

    BOOL bAllPrefixes;
    bAllPrefixes = SendMessage( GetDlgItem(hwndParent, IDC_ALLPREFIXES), BM_GETCHECK, 0,0 ) == BST_CHECKED;
    if ( !bAllPrefixes && iItems==0 )
    {
        ShowErrorMessage(GetDlgItem(hwndParent,IDC_ADD), IDS_NEEDPREFIXLIST);
        return FALSE;
    }

    BOOL dDialNumber;
    dDialNumber = SendMessage( GetDlgItem(hwndParent, IDC_DIALCHECK), BM_GETCHECK, 0,0 ) == BST_CHECKED;
    GetWindowText(GetDlgItem(hwndParent,IDC_DIALNUMBER), szBuffer, ARRAYSIZE(szBuffer));
    if ( dDialNumber && IsEmptyOrHasOnlySpaces(szBuffer))
    {
        ShowErrorMessage(GetDlgItem(hwndParent,IDC_DIALNUMBER), IDS_NEEDDIALNUMBER);
        return FALSE;
    }

    // TODO:
    // for each prefix, look for a conflicting rule.
    // if a conflict is found, alert the user.
    // based on the alert optionally ammend the conflicting rule

    // now we have verified the input is valid, go ahead and update everything:

    // save the prefix list even if Applies To All is selected.
    m_pRule->SetPrefixList( wszBuffer, (ARRAYSIZE(wszBuffer)-cchFree+1)*sizeof(WCHAR) );

    // read all verse select prefixes radio button
    m_pRule->SetAppliesToAllPrefixes( bAllPrefixes );

    // Save the area code.
    SHTCharToUnicode(szAreaCode, wszBuffer, ARRAYSIZE(wszBuffer));
    m_pRule->SetAreaCode( wszBuffer );

    // Save the dial number
    SHTCharToUnicode(szBuffer, wszBuffer, ARRAYSIZE(wszBuffer));
    m_pRule->SetNumberToDial( wszBuffer );

    // Save the dial number checkbox
    m_pRule->SetDialNumber( dDialNumber );

    // read the dial area code check box
    BOOL b;
    b = SendMessage( GetDlgItem(hwndParent, IDC_DIALAREACODE), BM_GETCHECK, 0,0 ) == BST_CHECKED;
    m_pRule->SetDialAreaCode( b );

    return TRUE;
}

void CAreaCodeRuleDialog::AddPrefix(HWND hwndParent)
{
    CEditDialog ed;
    INT_PTR iRes = ed.DoModal(hwndParent, IDS_ADDPREFIX, IDS_TYPEPREFIX, IDS_ACPREFIXES, LIF_ALLOWNUMBER|LIF_ALLOWSPACE|LIF_ALLOWCOMMA);
    if ( iRes == (INT_PTR)IDOK )
    {
        LPTSTR psz = ed.GetString();
        if (!psz)
            return; // should be impossible, but better safe than sorry

        // The string can contain multiple prefixes seperated by spaces, parse it
        // up and add one prefix for each chunk
        while (*psz)
        {
            LPTSTR pszNext;
            TCHAR ch;
            HWND hwndList = GetDlgItem(hwndParent, IDC_LIST);

            // trim leading spaces
            while ((*psz == TEXT(' ')) || (*psz == TEXT(',')))
                psz++;

            // check if trimming the spaces toke us to the end of the string
            if ( *psz )
            {
                // find next space and make it a temporary null
                pszNext = psz;
                while (*pszNext && (*pszNext != TEXT(' ')) && (*pszNext != TEXT(',')) )
                    pszNext++;
                ch = *pszNext;
                *pszNext = NULL;

                // add this item to the list
                LVITEM lvi;
                lvi.mask = LVIF_TEXT;
                lvi.pszText = psz;
                lvi.iItem = 0;
                lvi.iSubItem = 0;

                ListView_InsertItem(hwndList, &lvi);

                // replace our tempory null with it's previous value
                *pszNext = ch;

                // advance the psz point
                psz = pszNext;
            }
        }
    }
}

void CAreaCodeRuleDialog::RemoveSelectedPrefix(HWND hwndParent)
{
    if ( -1 != m_iSelectedItem )
    {
        m_iSelectedItem = DeleteItemAndSelectPrevious(hwndParent, IDC_LIST, m_iSelectedItem, IDC_REMOVE, IDC_ADD);
    }
}

int DeleteItemAndSelectPrevious( HWND hwndParent, int iList, int iItem, int iDel, int iAdd )
{
    HWND hwnd = GetDlgItem(hwndParent, iList);
    ListView_DeleteItem(hwnd, iItem);

    // Try to select the previous item, if possible
    iItem--;
    if ( 0 > iItem )
    {
        iItem = 0;
    }
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    if ( ListView_GetItem(hwnd, &lvi) )
    {
        ListView_SetItemState(hwnd, iItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        ListView_EnsureVisible(hwnd, iItem, FALSE);
    }
    else
    {
        iItem = -1;
    }

    hwnd = GetDlgItem(hwndParent,iDel);
    if ( -1 == iItem )
    {
        if ( GetFocus() == hwnd )
        {
            HWND hwndDef = GetDlgItem(hwndParent,iAdd);
            SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
            SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
            SetFocus(hwndDef);
        }
    }
    EnableWindow(hwnd, -1!=iItem);

    return iItem;
}


BOOL  IsEmptyOrHasOnlySpaces(PTSTR pwszStr)
{
    while(*pwszStr)
        if(*pwszStr++ != TEXT(' '))
            return FALSE;

    return TRUE;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplareacodetab.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplareacodetab.cpp
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

//
// Functions used only by the Area Code Rules tab of the New Location Property Sheet.
// Shared functions are in the Location.cpp file.
//
#include "cplPreComp.h"
#include "cplLocationPS.h"


INT_PTR CALLBACK CLocationPropSheet::AreaCode_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CLocationPropSheet* pthis = (CLocationPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CLocationPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->AreaCode_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->AreaCode_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );

    case WM_NOTIFY:
        return pthis->AreaCode_OnNotify(hwndDlg, (LPNMHDR)lParam);
    
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a103HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a103HelpIDs);
        break;
    }

    return 0;
}

void BuildRuleDescription(CAreaCodeRule * pRule, LPTSTR szText, UINT cchSize)
{
    TCHAR szAreaCode[MAX_INPUT];
    TCHAR szNumToDial[MAX_INPUT];

    BOOL hHasDialAreaCode = pRule->HasDialAreaCode();
    BOOL bHasDialNumber = pRule->HasDialNumber();

    // we almost always need these strings so go ahead and convert them
    SHUnicodeToTChar( pRule->GetAreaCode(), szAreaCode, ARRAYSIZE(szAreaCode));
    SHUnicodeToTChar( pRule->GetNumberToDial(), szNumToDial, ARRAYSIZE(szNumToDial));

    // Just a little sanity check so we don't get crappy looking strings.
    if ( bHasDialNumber && !*szNumToDial )
    {
        bHasDialNumber = FALSE;
    }

    int iFormatString;

// TODO: Special default rules processing
//    if ( pRule == special rule that always shows up last )
//    {
//        iFormatString = IDS_DAIL_ONEpAC_ALLOTHER;
//    }
//    else
    if ( pRule->HasAppliesToAllPrefixes() )
    {
        if ( bHasDialNumber )
        {
            if ( hHasDialAreaCode )
            {
                // Dial '%2' plus the area code before the number for all numbers within the %1 area code.
                iFormatString = IDS_DIAL_XpAC_FORALL;
            }
            else
            {
                // Dial '%2' before the number for all numbers within the %1 area code.
                iFormatString = IDS_DIAL_X_FORALL;
            }
        }
        else if ( hHasDialAreaCode )
        {
            // Dial the area code before the number for all numbers within the %1 area code.
            iFormatString = IDS_DIAL_AC_FORALL;
        }
        else
        {
            // Dial only the number for all numbers within the %1 area code.
            iFormatString = IDS_DIAL_NUMONLY_FORALL;
        }
    }
    else
    {
        if ( bHasDialNumber )
        {
            if ( hHasDialAreaCode )
            {
                // Dial '%2' plus the area code before the number for numbers with the selected prefixes within the %1 area code.
                iFormatString = IDS_DIAL_XpAC_FORSELECTED;
            }
            else
            {
                // Dial '%2' before the number for numbers with the selected prefixes within the %1 area code.
                iFormatString = IDS_DIAL_X_FORSELECTED;
            }
        }
        else if ( hHasDialAreaCode )
        {
            // Dial the area code before the number for numbers with the selected prefixes within the %1 area code.
            iFormatString = IDS_DIAL_AC_FORSELECTED;
        }
        else
        {
            // Dial only the number for numbers with the selected prefixes within the %1 area code.
            iFormatString = IDS_DIAL_NUMONLY_FORSELECTED;
        }
    }

    TCHAR szFormatString[512];
    LPTSTR aArgs[] = {szAreaCode,szNumToDial};

    LoadString( GetUIInstance(), iFormatString, szFormatString, ARRAYSIZE(szFormatString) );

    FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szFormatString, 0,0, szText, cchSize, (va_list *)aArgs );
}

void BuildRuleText(CAreaCodeRule * pRule, LPTSTR szText, UINT cchSize)
{
    TCHAR szNumToDial[MAX_INPUT];
    SHUnicodeToTChar( pRule->GetNumberToDial(), szNumToDial, ARRAYSIZE(szNumToDial));

    // Just a little sanity check so we don't get crappy looking strings.
    BOOL bHasDialNumber = pRule->HasDialNumber();
    if ( bHasDialNumber && !*szNumToDial )
    {
        bHasDialNumber = FALSE;
    }

    if ( bHasDialNumber )
    {
        int iFormatString;
        TCHAR szFormatString[512];
        LPTSTR aArgs[] = {szNumToDial};

        if ( pRule->HasDialAreaCode() )
        {
            // both string
            iFormatString = IDS_DIALXPLUSAREACODE;
        }
        else
        {
            // dial number string
            iFormatString = IDS_DIALX;
        }
        LoadString( GetUIInstance(), iFormatString, szFormatString, ARRAYSIZE(szFormatString) );

        FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormatString, 0,0, szText, cchSize, (va_list *)aArgs );
    }
    else if ( pRule->HasDialAreaCode() )
    {
        // area code only string
        LoadString( GetUIInstance(), IDS_DIALAREACODE, szText, cchSize );
    }
    else
    {
        // none of the above string
        LoadString( GetUIInstance(), IDS_DIALNUMBERONLY, szText, cchSize );
    }
}

BOOL CLocationPropSheet::AreaCode_OnInitDialog(HWND hDlg)
{
    // add the three columns to the listview
    RECT rc;
    TCHAR szText[MAX_INPUT];
    HWND hwndList = GetDlgItem(hDlg, IDC_LIST);

    GetClientRect(hwndList, &rc);

    int cxList = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.pszText = szText;

    struct {
        int iStrID;
        int cxPercent;
    } aData[] = {
        { IDS_AREACODE, 20 },
        { IDS_PREFIXES, 20 },
        { IDS_RULE,     60 },
    };

    for (int i=0; i<ARRAYSIZE(aData); i++)
    {
        LoadString(GetUIInstance(), aData[i].iStrID, szText, ARRAYSIZE(szText));
        lvc.iSubItem = i;
        lvc.cx = MulDiv(cxList, aData[i].cxPercent, 100);
        ListView_InsertColumn( hwndList, i, &lvc );
    }

    ListView_SetExtendedListViewStyleEx(hwndList, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    PopulateAreaCodeRuleList( hwndList );

    SetDataForSelectedRule(hDlg);

    return 1;
}

void CLocationPropSheet::SetDataForSelectedRule(HWND hDlg)
{
    TCHAR szText[512];

    // Set the button states
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT),   0!=m_pRule);
    EnableWindow(GetDlgItem(hDlg, IDC_DELETE), 0!=m_pRule);
    if ( m_pRule )
    {
        // Set the description text
        BuildRuleDescription(m_pRule, szText, ARRAYSIZE(szText));
    }
    else
    {
        // text for when no rule is selected:
        LoadString(GetUIInstance(), IDS_SELECTARULE, szText, ARRAYSIZE(szText));
    }
    SetWindowText(GetDlgItem(hDlg, IDC_DESCRIPTIONTEXT), szText);
}

void CLocationPropSheet::AddRuleToList( HWND hwndList, CAreaCodeRule * pRule, BOOL bSelect )
{
    TCHAR szText[512];
    LVITEM lvi;
    SHUnicodeToTChar( pRule->GetAreaCode(), szText, ARRAYSIZE(szText));
    lvi.pszText = szText;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.lParam = (LPARAM)pRule;
    if ( bSelect )
    {
        lvi.mask |= LVIF_STATE;
        lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
        // We added the new rule in the selected state so update m_pRule
        m_pRule = pRule;

        // Since we now have a selected rule, update the button states
        HWND hwndParent = GetParent(hwndList);

        EnableWindow( GetDlgItem(hwndParent, IDC_EDIT),   TRUE );
        EnableWindow( GetDlgItem(hwndParent, IDC_DELETE), TRUE );
    }
    int iItem = ListView_InsertItem(hwndList, &lvi);

    LoadString(GetUIInstance(), pRule->HasAppliesToAllPrefixes()?IDS_ALLPREFIXES:IDS_SELECTEDPREFIXES,
            szText, ARRAYSIZE(szText));
    ListView_SetItemText(hwndList, iItem, 1, szText);

    BuildRuleText( pRule, szText, ARRAYSIZE(szText));
    ListView_SetItemText(hwndList, iItem, 2, szText);
}

void CLocationPropSheet::RemoveRuleFromList(HWND hwndList, BOOL bSelect)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)m_pRule;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);
    if ( -1 != iItem )
    {
        if ( bSelect )
        {
            iItem = DeleteItemAndSelectPrevious( GetParent(hwndList), IDC_LIST, iItem, IDC_DELETE, IDC_NEW );

            if ( -1 != iItem )
            {
                LVITEM lvi;
                lvi.iItem = iItem;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                // Store the currently selected item
                m_pRule = (CAreaCodeRule *)lvi.lParam;
            }
            else
            {
                m_pRule = NULL;
            }
        }
        else
        {
            ListView_DeleteItem(hwndList,iItem);
            m_pRule = NULL;
        }
    }
}

void CLocationPropSheet::PopulateAreaCodeRuleList( HWND hwndList )
{
    m_pLoc->ResetRules();

    int i;
    int iItems;
    CAreaCodeRule * pRule;

    iItems = m_pLoc->GetNumRules();
    for (i=0; i<iItems; i++)
    {
        if ( S_OK == m_pLoc->NextRule(1,&pRule,NULL) )
        {
            AddRuleToList( hwndList, pRule, FALSE );
        }
    }
}

BOOL CLocationPropSheet::AreaCode_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_NEW:
    case IDC_EDIT:
        LaunchNewRuleDialog(IDC_NEW == wID,hwndParent);
        break;

    case IDC_DELETE:
        DeleteSelectedRule(GetDlgItem(hwndParent,IDC_LIST));
        break;

    default:
        return 0;
    }
    return 1;
}

void CLocationPropSheet::LaunchNewRuleDialog(BOOL bNew, HWND hwndParent)
{
    CAreaCodeRule * pRule;
    if ( bNew )
    {
        // Initialize with default values
        pRule = new CAreaCodeRule;
        if ( !pRule )
        {
            return;
        }

        pRule->Initialize(L"",L"1",RULE_APPLIESTOALLPREFIXES,NULL,0);
    }
    else if ( m_pRule )
    {
        // Initialize with m_pRule's values
        pRule = m_pRule;
    }
    else
    {
        // This should be impossible
        return;
    }

    CAreaCodeRuleDialog acrd( bNew, pRule );
    if ( IDOK == acrd.DoModal(hwndParent) )
    {
        // The user changed something
        HWND hwndList = GetDlgItem(hwndParent,IDC_LIST);
        SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);

        if ( bNew )
        {
            m_pLoc->AddRule(pRule);
        }
        else
        {
            // Assert( m_pRule == pRule );
            RemoveRuleFromList(hwndList, FALSE);
        }
        AddRuleToList(hwndList, pRule, TRUE);
        SetDataForSelectedRule(hwndParent);
    }
    else if ( bNew )
    {
        delete pRule;
    }
}

void CLocationPropSheet::DeleteSelectedRule(HWND hwndList)
{
    // First we confirm the delete with the user
    TCHAR szText[1024];
    TCHAR szTitle[128];
    int result;
    HWND hwndParent = GetParent(hwndList);
    
    LoadString(GetUIInstance(), IDS_DELETERULETEXT, szText, ARRAYSIZE(szText));
    LoadString(GetUIInstance(), IDS_CONFIRMDELETE, szTitle, ARRAYSIZE(szTitle));

    result = SHMessageBoxCheck( hwndParent, szText, szTitle, MB_YESNO, IDYES, TEXT("TAPIDeleteAreaCodeRule") );
    if ( IDYES == result )
    {
        // remove the item corresponding to m_pRule from the list
        m_pLoc->RemoveRule(m_pRule);
        RemoveRuleFromList(hwndList, TRUE);

        // Now we want to select the next rule in the list

        HWND hwndParent = GetParent(hwndList);
        SetDataForSelectedRule(hwndParent);
        SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
    }
}

BOOL CLocationPropSheet::AreaCode_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // Let the generic handler have a crack at it first
    OnNotify(hwndDlg, pnmhdr);

    if (pnmhdr->idFrom == IDC_LIST)
    {
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( pnmlv->uChanged & LVIF_STATE )
            {
                if (pnmlv->uNewState & LVIS_SELECTED)
                {
                    LVITEM lvi;
                    lvi.iItem = pnmlv->iItem;
                    lvi.iSubItem = pnmlv->iSubItem;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( pnmhdr->hwndFrom, &lvi );

                    // Store the currently selected item
                    m_pRule = (CAreaCodeRule *)lvi.lParam;
                }
                else
                {
                    m_pRule = NULL;
                }

                SetDataForSelectedRule(hwndDlg);
            }

            break;

        case NM_DBLCLK:
            if ( (-1 == pnmlv->iItem) || !m_pRule )
            {
                // Do new case
                LaunchNewRuleDialog(TRUE,hwndDlg);
            }
            else
            {
                // Do Edit case
                LaunchNewRuleDialog(FALSE,hwndDlg);
            }
            break;

        default:
            break;
        }
        #undef pnmlv
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cpladvancedtab.cpp ===
/*--------------------------------------------------------------------------*\
Module:     drv.cpp

  Purpose:    routines for dealing with drivers and their configuration

  Copyright (c) 1998-1999 Microsoft Corporation
 
    History:
    8/11/93   CBB - Hack-o-rama from NickH's stuff
    10/15/98  ToddB - Major rewrite of ancient crap
\*--------------------------------------------------------------------------*/

#include "cplPreComp.h"
#include "drv.h"
#include "tlnklist.h"

#include <windowsx.h>
#include <shlwapi.h>

#define DBG_ASSERT(x,y)

#define  CPL_SUCCESS                 0
#define  CPL_APP_ERROR               100
#define  CPL_BAD_DRIVER              108

#define  CPL_MAX_STRING             132      // biggest allowed string


//----------
// Externs
//----------

typedef BOOL ( APIENTRY PGETFILEVERSIONINFO(
              LPTSTR  lptstrFilename,     // pointer to filename string
              DWORD  dwHandle,    // ignored
              DWORD  dwLen,       // size of buffer
              LPVOID  lpData      // pointer to buffer to receive file-version info.
              ));
PGETFILEVERSIONINFO *gpGetFileVersionInfo;

typedef DWORD ( APIENTRY PGETFILEVERSIONINFOSIZE(
               LPTSTR  lptstrFilename,     // pointer to filename string
               LPDWORD  lpdwHandle         // pointer to variable to receive zero
               ));
PGETFILEVERSIONINFOSIZE *gpGetFileVersionInfoSize;


//------------
// Public Data
//------------
LPLINEPROVIDERLIST glpProviderList;


//-------------
// Private Data
//-------------
static TCHAR gszVarFileInfo[]     = TEXT("\\VarFileInfo\\Translation");
static TCHAR gszStringFileInfo[]  = TEXT("\\StringFileInfo\\%04x%04x\\FileDescription");
static TCHAR gszDriverFiles[]     = TEXT("\\*.tsp");

// These are proc names passed to GetProcAddress and are therefore ANSI strings
static CHAR gszProviderInstall[] = "TSPI_providerInstall";
static CHAR gszProviderRemove[]  = "TSPI_providerRemove";
static CHAR gszProviderSetup[]   = "TSPI_providerConfig";

TCHAR gszHelpFile[] = TEXT("tapi.hlp");


//----------------------------
// Private Function Prototypes
//----------------------------
BOOL  VerifyProcExists( LPTSTR lpszFile, LPSTR lpszProcName );
UINT  GetProviderFileDesc( LPTSTR lpszFile, LPTSTR lpszDesc, int cchDesc );
BOOL  FillAddDriverList( HWND hwndParent, HWND hwndList );
BOOL  AddProvider( HWND hwndParent, HWND hwndList, LPTSTR lpszDriverFile );
LPTSTR ProviderIDToFilename( DWORD dwProviderID );
BOOL  RefreshProviderList();



/*--------------------------------------------------------------------------*\

  Function:   VerifyProcExists
  
    Purpose:    Verifies that the specified proceedure exists in the
    specified service provider
    
\*--------------------------------------------------------------------------*/
BOOL VerifyProcExists( LPTSTR lpszFile, LPSTR lpszProcName )
{
    BOOL        fResult       = TRUE;
    HINSTANCE   hProviderInst;
    
    SetLastError(0);
    
    hProviderInst = LoadLibrary( lpszFile );
    
    if (  hProviderInst == NULL )
    {
        fResult = FALSE;
        goto  done;
    }  // end if

    if (GetProcAddress( hProviderInst, lpszProcName ) == NULL)
    {
        LOG((TL_ERROR, "GetProcAddress for \"%hs\" failed on file %s", lpszProcName, lpszFile ));
        fResult = FALSE;
        goto  done;
    }   // end if
    
done:
    
    if ( hProviderInst != NULL )
        FreeLibrary( hProviderInst );
    
    return fResult;
}


/*--------------------------------------------------------------------------*\

  Function:   FillDriverList
  
    Purpose:    Use lineGetProviderList to retrieve provider list and
    insert into listbox.
    
\*--------------------------------------------------------------------------*/
BOOL FillDriverList( HWND hwndList )
{
    BOOL uResult;
    UINT uIndex;
    UINT uListIndex;
    LPLINEPROVIDERENTRY lpProviderEntry;
    
    if (!RefreshProviderList())
    {
        LOG((TL_ERROR, "Failing FillDriverList because RefreshProviderList returned FALSE"));
        return FALSE;
    }
    
    DBG_ASSERT( glpProviderList, "Uninitialized Provider List after refresh" );
    
    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );
    SendMessage( hwndList, LB_RESETCONTENT, 0, 0 );
    
    // loop through the provider list
    //-------------------------------
    lpProviderEntry = (LPLINEPROVIDERENTRY)((LPBYTE)glpProviderList +
        glpProviderList->dwProviderListOffset);
    
    //
    // Provider list integrity check
    //
    DBG_ASSERT( glpProviderList->dwTotalSize >= (glpProviderList->dwNumProviders * sizeof( LINEPROVIDERENTRY )),
        "TAPI returned lineProviderList structure that is too small for number of providers" );
    
    for ( uIndex = 0; uIndex < glpProviderList->dwNumProviders; uIndex++ )
    {
        LPTSTR lpszProviderFilename;
        TCHAR  szFriendlyName[CPL_MAX_STRING];
        
        //
        // Another provider list integrity check
        //
        DBG_ASSERT( lpProviderEntry[uIndex].dwProviderFilenameOffset +
            lpProviderEntry[uIndex].dwProviderFilenameSize <=
            glpProviderList->dwTotalSize,
            "TAPI LINEPROVIDERLIST too small to hold provider filename" );
        
        // Get an entry to put in the list box
        //------------------------------------
        lpszProviderFilename = (LPTSTR)((LPBYTE)glpProviderList +
            lpProviderEntry[uIndex].dwProviderFilenameOffset);
        
        // Determine the user-friendly name
        //---------------------------------
        
        uResult = GetProviderFileDesc( lpszProviderFilename, szFriendlyName, ARRAYSIZE(szFriendlyName) );
        
        LOG((TL_INFO, "Provider friendly name: %s", szFriendlyName));
        
        if (uResult != CPL_SUCCESS && uResult != CPL_BAD_DRIVER) // just leave bad driver in list
        {
            uResult = FALSE;
            goto done;
        }
        else
        {
            uResult = TRUE;
        }
        
        // slam it into the list box
        //--------------------------
        uListIndex = (UINT)SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szFriendlyName );
        
        LOG((TL_INFO, "Setting item for index %ld, value=0x%08lx", (DWORD)uListIndex,
            (DWORD)(lpProviderEntry[uIndex].dwPermanentProviderID) ));
        
        SendMessage( hwndList, LB_SETITEMDATA, uListIndex,
            (LPARAM)(lpProviderEntry[uIndex].dwPermanentProviderID) );
    }
    
    if (glpProviderList->dwNumProviders == 0)
    {
        // no providers, add in default string!
        //-------------------------------------
        
        TCHAR szText[CPL_MAX_STRING];
        LoadString(GetUIInstance(),IDS_NOSERVICEPROVIDER,szText,ARRAYSIZE(szText));
        
        uListIndex = (UINT)SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szText);
        SendMessage( hwndList, LB_SETITEMDATA, uListIndex, 0 );
    }
    
    uResult = TRUE;
    
done:
    
    SendMessage( hwndList, LB_SETCURSEL, 0, 0 );    // set focus to the top guy
    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );
    
    return uResult;
}


/*--------------------------------------------------------------------------*\

  Function:   SetupDriver
  
  Purpose:    Calls lineConfigProvider
    
\*--------------------------------------------------------------------------*/
BOOL SetupDriver( HWND hwndParent, HWND hwndList )
{
    LRESULT lResult;
    LRESULT dwProviderID;
    LONG    res;
    
    // get the id and tell tapi to configure the provider
    //---------------------------------------------------
    lResult      = SendMessage( hwndList, LB_GETCURSEL, 0, 0 );
    dwProviderID = SendMessage( hwndList, LB_GETITEMDATA, (WPARAM)lResult, 0L );
    
    if ((dwProviderID == (LRESULT)LB_ERR) || (!dwProviderID))
    {
        LOG((TL_WARN,  "Warning: strange... dwProviderID= 0x%08lx (uResult=0x%08lx)", (DWORD)dwProviderID, (DWORD)lResult));
        return FALSE;
    }
    
    lResult = lineConfigProvider( hwndParent, (DWORD)dwProviderID );
    
    if (lResult)
    {
        LOG((TL_WARN, "Warning: lineConfigProvider failure %#08lx", lResult ));
        return FALSE;
    }
    
    return TRUE;
}


/*--------------------------------------------------------------------------*\

  Function:   RemoveSelectedDriver
  
    Purpose:    Calls lineRemoveProvider
    
\*--------------------------------------------------------------------------*/
BOOL RemoveSelectedDriver( HWND hwndParent, HWND hwndList )
{
    UINT  uResult;
    LRESULT  lResult;
    LRESULT  lrListIndex;
    LRESULT  lrProviderID;
    
    // find the one we should remove
    //------------------------------
    lrListIndex  = SendMessage( hwndList, LB_GETCURSEL, 0, 0 );
    lrProviderID = SendMessage( hwndList, LB_GETITEMDATA, lrListIndex, 0 );
    
    LOG((TL_TRACE, "Removing provider ID = %#08lx", (DWORD)lrProviderID ));
    
    if ((lrProviderID == (LRESULT)LB_ERR) || (!lrProviderID))
    {
        uResult = FALSE;
        goto  done;
    }
    
    // ask TAPI to remove this provider
    //---------------------------------
    lResult = lineRemoveProvider( (DWORD)lrProviderID, hwndParent );
    
    if (lResult)
    {
        LOG((TL_WARN, "Warning: lineRemoveProvider failure %#08lx", lResult ));
        uResult = FALSE;
        goto  done;
    }
    
    // remove him from the list box
    //-----------------------------
    lResult = SendMessage( hwndList, LB_DELETESTRING, lrListIndex, 0 );
    
    if (lResult == LB_ERR )
    {
        uResult = FALSE;
        goto  done;
    }
    
    if ( lResult == 0 )
    {
        // no providers, add in default string!
        //-------------------------------------
        TCHAR szText[CPL_MAX_STRING];
        LoadString(GetUIInstance(),IDS_NOSERVICEPROVIDER,szText,ARRAYSIZE(szText));
        
        lResult = SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szText);
        SendMessage( hwndList, LB_SETITEMDATA, (WPARAM)lResult, 0 );     // mark!
    }
    
    uResult = TRUE;
    
done:
    
    SendMessage( hwndList, LB_SETCURSEL, 0, 0 );    // set focus to the top guy
    UpdateDriverDlgButtons(hwndParent);
    
    return uResult;
}


/*--------------------------------------------------------------------------*\

  Function:   GetProviderFileDesc

    Purpose:    Reads the driver description from it's version info stuff

\*--------------------------------------------------------------------------*/
UINT GetProviderFileDesc( LPTSTR lpszFile, LPTSTR lpszDesc, int cchDesc)
{
    UINT  uResult;
    UINT  uItemSize;
    DWORD dwSize;
    DWORD dwVerHandle;
    LPTSTR lpszBuffer;
    LPBYTE   lpbVerData;
    TCHAR  szItem[1000];

    lpbVerData = NULL;
    lstrcpyn( lpszDesc, lpszFile, cchDesc );   // returns filename as description if we have any errors

    {
        HINSTANCE hVersion = NULL;

        if ( NULL == gpGetFileVersionInfo )
        {
            hVersion = LoadLibrary( TEXT("Version.dll") );
            if ( NULL == hVersion )
            {
                LOG((TL_ERROR, "LoadLibrary('VERSION.DLL') failed! err=0x%08lx", GetLastError() ));
                return FALSE;
            }

            gpGetFileVersionInfo = (PGETFILEVERSIONINFO *)GetProcAddress(
                    hVersion,
#ifdef UNICODE
                    "GetFileVersionInfoW"
#else
                    "GetFileVersionInfoA"
#endif
                    );
            if ( NULL == gpGetFileVersionInfo )
            {
                LOG((TL_ERROR, "GetProcAddress('VERSION.DLL', 'GetFileVersionInfo') failed! err=0x%08lx", GetLastError() ));
                return FALSE;
            }
        }
    
        if ( NULL == gpGetFileVersionInfoSize )
        {
            if ( NULL == hVersion )
            {
                hVersion = LoadLibrary( TEXT("Version.dll") );
            }
        
            if ( NULL == hVersion )  // Is it _STILL_ NULL?
            {
                LOG((TL_ERROR, "LoadLibrary('VERSION.DLL') failed! err=0x%08lx", GetLastError() ));
                return FALSE;
            }
        
            gpGetFileVersionInfoSize = (PGETFILEVERSIONINFOSIZE *)GetProcAddress(
                    hVersion,
#ifdef UNICODE
                    "GetFileVersionInfoSizeW"
#else
                    "GetFileVersionInfoSizeA"
#endif
                    );

            if ( NULL == gpGetFileVersionInfoSize )
            {
                LOG((TL_ERROR, "GetProcAddress('VERSION.DLL', 'GetFileVersionInfoSize') failed! err=0x%08lx", GetLastError() ));
                gpGetFileVersionInfo = NULL;
                FreeLibrary( hVersion );
                return FALSE;
            }
        }
    }
    
    if ((dwSize = gpGetFileVersionInfoSize( lpszFile, &dwVerHandle )) == 0)
    {
        LOG((TL_ERROR, "GetFileVersionInfoSize failure for %s", lpszFile ));
        uResult = CPL_BAD_DRIVER;
        goto  done;
    }
    
    lpbVerData = (LPBYTE)GlobalAllocPtr( GPTR, dwSize + 10 );      
    if ( lpbVerData == NULL )
    {
        uResult = CPL_APP_ERROR;
        goto  done;
    }
    
    if ( gpGetFileVersionInfo( lpszFile, dwVerHandle, dwSize, lpbVerData ) == FALSE )
    {
        LOG((TL_ERROR, "GetFileVersionInfo failure for %s", lpszFile ));
        uResult = CPL_BAD_DRIVER;
        goto  done;
    }
    
    lstrcpy( szItem, gszVarFileInfo );     // bug in VerQueryValue, can't handle static CS based str
    
    {
        HINSTANCE hVersion;
        typedef BOOL ( APIENTRY PVERQUERYVALUE(
            const LPVOID  pBlock,        // address of buffer for version resource
            LPTSTR  lpSubBlock,  // address of value to retrieve
            LPVOID  *lplpBuffer, // address of buffer for version pointer
            PUINT  puLen         // address of version-value length buffer
            ));
        PVERQUERYVALUE *pVerQueryValue = NULL;
        
        
        hVersion = LoadLibrary( TEXT("Version.dll") );
        if ( NULL == hVersion )
        {
            LOG((TL_ERROR, "LoadLibrary('VERSION.DLL') failed! err=0x%08lx", GetLastError() ));
            return FALSE;
        }
        
        pVerQueryValue = (PVERQUERYVALUE *)GetProcAddress( 
                hVersion,
#ifdef UNICODE
                "VerQueryValueW"
#else
                "VerQueryValueA"
#endif
                );

        if ( NULL == pVerQueryValue )
        {
            LOG((TL_ERROR, "GetProcAddress('VERSION.DLL', 'VerQueryValue') failed! err=0x%08lx", GetLastError() ));
            FreeLibrary( hVersion );
            return FALSE;
        }
        
        
        if ((pVerQueryValue( lpbVerData, szItem, (void**)&lpszBuffer, (LPUINT)&uItemSize ) == FALSE) || (uItemSize == 0))
        {
            LOG((TL_ERROR, "ERROR:  VerQueryValue failure for %s on file %s", szItem, lpszFile ));
            uResult = CPL_SUCCESS;     // does not matter if this did not work!
            FreeLibrary( hVersion );
            goto  done;
        }  // end if
        
        
        wsprintf( szItem, gszStringFileInfo, (WORD)*(LPWORD)lpszBuffer, (WORD)*(((LPWORD)lpszBuffer)+1) );
        
        if ((pVerQueryValue( lpbVerData, szItem, (void**)&lpszBuffer, (LPUINT)&uItemSize ) == FALSE) || (uItemSize == 0))
        {
            LOG((TL_ERROR, "ERROR:  VerQueryValue failure for %s on file %s", szItem, lpszFile ));
            uResult = CPL_SUCCESS;     // does not matter if this did not work!
            FreeLibrary( hVersion );
            goto  done;
        }  // end if
        
        FreeLibrary( hVersion );
    }
    
    lstrcpyn( lpszDesc, lpszBuffer, cchDesc );
    
    uResult = CPL_SUCCESS;
    
done:
    
    if ( lpbVerData )
        GlobalFreePtr( lpbVerData );
    
    return uResult;
}



#define MAX_PROVIDER_NAME   14
#define PROVIDERS_KEY       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers")
#define NUM_PROVIDERS       TEXT("NumProviders")

typedef struct
{
    LIST_ENTRY Entry;
    TCHAR szName[MAX_PROVIDER_NAME];
} INSTALLED_PROVIDER, *PINSTALLED_PROVIDER;

typedef struct
{
    LIST_ENTRY Head;
    DWORD      dwEntries;
} LIST_HEAD, *PLIST_HEAD;

void BuildInstalledProviderList (PLIST_HEAD pListHead)
{
 PINSTALLED_PROVIDER pProvider;
 HKEY hKeyProviders;
 DWORD dwNumProviders;
 DWORD cbData;
 DWORD i;
 TCHAR szValueName[24]=TEXT("ProviderFileName");
 TCHAR *pNumber = &szValueName[16];

    InitializeListHead (&pListHead->Head);
    pListHead->dwEntries = 0;

    if (ERROR_SUCCESS !=
        RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROVIDERS_KEY, 0, KEY_READ, &hKeyProviders))
    {
        return;
    }

    cbData = sizeof (dwNumProviders);
    if (ERROR_SUCCESS !=
         RegQueryValueEx (hKeyProviders, NUM_PROVIDERS, NULL, NULL, (PBYTE)&dwNumProviders, &cbData) ||
        0 == dwNumProviders)
    {
        goto CloseKeyAndReturn;
    }

    pProvider = (PINSTALLED_PROVIDER)ClientAlloc (sizeof (INSTALLED_PROVIDER));
    if (NULL == pProvider)
    {
        goto CloseKeyAndReturn;
    }

    for (i = 0; i < dwNumProviders; i++)
    {
        wsprintf (pNumber, TEXT("%d"), i);
        cbData = sizeof(pProvider->szName);
        if (ERROR_SUCCESS ==
            RegQueryValueEx (hKeyProviders, szValueName, NULL, NULL, (PBYTE)pProvider->szName, &cbData))
        {
            InsertHeadList (&pListHead->Head, &pProvider->Entry);
            pListHead->dwEntries ++;
            pProvider = (PINSTALLED_PROVIDER)ClientAlloc (sizeof (INSTALLED_PROVIDER));
            if (NULL == pProvider)
            {
                goto CloseKeyAndReturn;
            }
        }
    }

    ClientFree (pProvider);

CloseKeyAndReturn:
    RegCloseKey (hKeyProviders);
}


/*--------------------------------------------------------------------------*\

  Function:   FillAddDriverList
  
  Purpose:
    
\*--------------------------------------------------------------------------*/
BOOL FillAddDriverList( HWND hwndParent, HWND hwndList )
{
    UINT  uIndex;
    UINT  uResult;
    LPTSTR lpszDrvFile;
    HANDLE hFindFile;
    WIN32_FIND_DATA ftFileInfo;
    TCHAR szFullPath[MAX_PATH+sizeof(gszDriverFiles)/sizeof(TCHAR)];
    TCHAR  szDrvDescription[CPL_MAX_STRING];
    LIST_HEAD InstalledProvidersList;
    PINSTALLED_PROVIDER pProvider;

    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );
    SendMessage( hwndList, LB_RESETCONTENT, 0, 0 );

    // build a list of installed providers,
    // so that we don't allow the user to install them again
    //------------------------------------------------------
    BuildInstalledProviderList (&InstalledProvidersList);

    // get full path to windows/system dir
    //------------------------------------
    uIndex = GetSystemDirectory( szFullPath, MAX_PATH);
    if ((0 == uIndex) || (MAX_PATH < uIndex))
    {
        // Either the function failed,
        // or the path is greater than MAX_PATH
        uResult = FALSE;
        goto  done;
    }
    
    uIndex = (UINT)lstrlen( szFullPath );
    
    if ((uIndex > 0) && (szFullPath[uIndex-1] != '\\'))
        lstrcat( szFullPath, gszDriverFiles );          // add the '\'
    else
        lstrcat( szFullPath, gszDriverFiles + 1 );      // ignore the '\' (root dir)
    
    // find all the entries in the system dir
    //---------------------------------------
    
    hFindFile = FindFirstFile( szFullPath, &ftFileInfo );
    uResult = TRUE;
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        LOG((TL_ERROR, "FindFirstFile failed, 0x%08lx", GetLastError() ));
        uResult = FALSE;
    }
    
    while ( uResult )
    {
        // alloc and set the file name to be assocated with each driver
        //-------------------------------------------------------------
        lpszDrvFile = (LPTSTR)ClientAlloc((lstrlen(ftFileInfo.cFileName)+1)*sizeof(TCHAR));
        if (NULL == lpszDrvFile)
        {
            uResult = FALSE;
            goto  done;
        }
        
        lstrcpy( lpszDrvFile, ftFileInfo.cFileName );
        
        LOG((TL_ERROR, "Examining file %s", lpszDrvFile ));
        
        // if the provider is already installed, skip it
        //----------------------------------------------
        for (pProvider = (PINSTALLED_PROVIDER)InstalledProvidersList.Head.Flink, uIndex = 0;
             uIndex < InstalledProvidersList.dwEntries;
             pProvider = (PINSTALLED_PROVIDER)pProvider->Entry.Flink, uIndex++)
        {
            if (!lstrcmpi (lpszDrvFile, pProvider->szName))
            {
                RemoveEntryList (&pProvider->Entry);
                InstalledProvidersList.dwEntries --;
                ClientFree (pProvider);
                ClientFree (lpszDrvFile);
                goto next_driver;
            }
        }


        // cbb, should we make a full path???
        uResult = GetProviderFileDesc( lpszDrvFile, szDrvDescription, ARRAYSIZE(szDrvDescription) );
        if ( uResult != CPL_SUCCESS )
        {
            LOG((TL_ERROR, "No description for %s.  Default to filename.", lpszDrvFile ));
            
            /* Filename will have to suffice */
            lstrcpy( szDrvDescription, lpszDrvFile );
            uResult = FALSE;
        }
        else
        {
            uResult = TRUE;   
        }
        
        // Verify that provider has install routine
        //-----------------------------------------
        if (!VerifyProcExists( lpszDrvFile, gszProviderInstall ))
        {
            LOG((TL_ERROR, "No Install Proc"));
            goto next_driver;
        }
        
        // slam it into the list box
        //--------------------------
        uIndex = (UINT)SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szDrvDescription );
        if ( uIndex == CB_ERR )
        {
            uResult = FALSE;
            goto  done;
        }
        
        if ( SendMessage( hwndList, LB_SETITEMDATA, uIndex, (LPARAM)lpszDrvFile ) == CB_ERR )
        {
            uResult = FALSE;
            goto  done;
        }
        
next_driver:
        
        uResult = FALSE;
        if (FindNextFile( hFindFile, &ftFileInfo ))
        {
            uResult = TRUE;
        }
    }

    while (InstalledProvidersList.dwEntries > 0)
    {
        pProvider = (PINSTALLED_PROVIDER)RemoveHeadList (&InstalledProvidersList.Head);
        InstalledProvidersList.dwEntries --;
        ClientFree (pProvider);
    }

    uResult = TRUE;
    
done:
    if (0 == SendMessage (hwndList, LB_GETCOUNT, 0, 0))
    {
        if (0 < LoadString (GetUIInstance(), IDS_NO_PROVIDERS, szDrvDescription, ARRAYSIZE(szDrvDescription)))
        {
            SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM)szDrvDescription );
        }
        EnableWindow (GetDlgItem (hwndParent, IDC_ADD), FALSE);
    }
    else
    {
        SendMessage( hwndList, LB_SETCURSEL, 0, 0 );    // set focus to the top guy
        UpdateDriverDlgButtons( hwndParent );
    }
    
    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );
    
    return uResult;
}


/*--------------------------------------------------------------------------*\

  Function:   AddProvider
  
  Purpose:    Call lineAddProvider
    
\*--------------------------------------------------------------------------*/
BOOL AddProvider( HWND hwndParent, HWND hwndList, LPTSTR lpszDriverFile )
{
    UINT  uIndex;
    LONG  lResult;
    DWORD dwProviderID;
    
    if ( lpszDriverFile == NULL )
    {
        DBG_ASSERT( hWnd, "Simultaneously NULL pointer & hwnd" );
        
        // get the stuff from the list box
        //--------------------------------
        uIndex = (UINT)SendMessage( hwndList, LB_GETCURSEL, 0, 0 );
        lpszDriverFile = (LPTSTR)SendMessage( hwndList, LB_GETITEMDATA, uIndex, 0 );
        
        if (lpszDriverFile == NULL)
        {
            return FALSE;
        }
    }

    lResult = lineAddProvider( lpszDriverFile, hwndParent, &dwProviderID );

    if (lResult)
    {
        LOG((TL_ERROR, "Error: lineAddProvider failure %#08lx", lResult ));
        return FALSE;
    }
    
    return TRUE;
}

BOOL
IsUserAdmin()

/*++

Routine Description:

    Determine if current user is a member of the local admin's group

Arguments:

Return Value:

    True if member

--*/

{
    BOOL                        foundEntry = FALSE;
    HANDLE                      hToken = NULL;
    DWORD                       dwInfoSize = 0;
    PTOKEN_GROUPS               ptgGroups = NULL;
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
    PSID                        pSid = NULL;
    DWORD                       i;
    
    //
    //  Get user thread or process token
    //
    
    if (!OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_QUERY,
        FALSE,
        &hToken))
    {       
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) 
        {
            goto ExitHere;
        }
    }

    //
    //  Get user group SIDs
    //
    
    if (!GetTokenInformation(
        hToken,
        TokenGroups,
        NULL,
        0,
        &dwInfoSize
        ))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            goto ExitHere;
        }
    }
    ptgGroups = (PTOKEN_GROUPS) ClientAlloc (dwInfoSize);
    if (ptgGroups == NULL)
    {
        goto ExitHere;
    }
    if (!GetTokenInformation(
        hToken,
        TokenGroups,
        ptgGroups,
        dwInfoSize,
        &dwInfoSize
        ))
    {
        goto ExitHere;
    }

    //
    //  Get the local admin group SID
    //

    if(!AllocateAndInitializeSid(
        &sia,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSid
        )) 
    {
        goto ExitHere;
    }

    //
    //  Compare to see if the user is in admin group
    //
    for (i = 0; i < ptgGroups->GroupCount; ++i)
    {
        if (EqualSid (ptgGroups->Groups[i].Sid, pSid))
        {
            break;
        }
    }
    if (i < ptgGroups->GroupCount)
    {
        foundEntry = TRUE;
    }

ExitHere:
    if (pSid)
    {
        FreeSid (pSid);
    }
    if (ptgGroups)
    {
        ClientFree (ptgGroups);
    }
    if (hToken)
    {
        CloseHandle (hToken);
    }
    return foundEntry;
}

VOID UpdateDriverDlgButtons( HWND hwnd )
{
    //
    // Enable/disable the Remove & Config buttons as appropriate
    //
    
    UINT    uResult;
    LPTSTR   lpszProviderFilename;
    DWORD   dwProviderID;
    BOOL    bAdmin = IsUserAdmin ();
    
    uResult = (UINT) SendDlgItemMessage(
        hwnd,
        IDC_LIST,
        LB_GETCURSEL,
        0,
        0
        );
    
    dwProviderID = (DWORD) SendDlgItemMessage(
        hwnd,
        IDC_LIST,
        LB_GETITEMDATA,
        uResult, 0
        );
    
    lpszProviderFilename = ProviderIDToFilename (dwProviderID);
    
    EnableWindow(
        GetDlgItem (hwnd, IDC_ADD),
        bAdmin
        );
    
    EnableWindow(
        GetDlgItem (hwnd, IDC_REMOVE),
        bAdmin &&
        (lpszProviderFilename != NULL) &&
        VerifyProcExists (lpszProviderFilename, gszProviderRemove)
        );
    
    EnableWindow(
        GetDlgItem( hwnd, IDC_EDIT),
        bAdmin &&
        (lpszProviderFilename != NULL) &&
        VerifyProcExists (lpszProviderFilename, gszProviderSetup)
        );
}



/*--------------------------------------------------------------------------*\

  Function:   AddDriver_DialogProc
  
    Purpose:
    
\*--------------------------------------------------------------------------*/
INT_PTR AddDriver_DialogProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam )
{
    switch( wMessage )
    {
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a114HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a114HelpIDs);
        break;
        
    case WM_INITDIALOG:
        // initalize all the fields
        //-------------------------
        if ( !FillAddDriverList(hWnd, GetDlgItem(hWnd, IDC_DRIVER_LIST)) )
        {
            EndDialog( hWnd, IDCANCEL );
            return TRUE;
        }
        
        if ( SendDlgItemMessage( hWnd, IDC_DRIVER_LIST, LB_GETCOUNT, 0, 0 ) <= 0 )
            EnableWindow( GetDlgItem( hWnd, IDC_ADD ), FALSE );
        
        return TRUE;
        
    case  WM_COMMAND:
        // do some work with the buttons
        //------------------------------
        switch ( GET_WM_COMMAND_ID(wParam, lParam) )
        {
            case  IDC_DRIVER_LIST:
            
                // do the list stuff
                //------------------
                if ((GET_WM_COMMAND_CMD( wParam, lParam ) != LBN_DBLCLK) || (SendDlgItemMessage( hWnd, IDC_DRIVER_LIST, LB_GETCOUNT, 0, 0 ) <= 0 ))
                    break;      // done
                // fall through, threat the double click like an add message
            
            case  IDC_ADD:
            
                // add a new driver
                //-----------------
            
                if ( !AddProvider(hWnd, GetDlgItem(hWnd, IDC_DRIVER_LIST), NULL) )
                {
                    wParam = IDCANCEL;
                }
                else
                {
                    wParam = IDOK;
                }
            
                // fall through, exit the dialog
            
            case  IDOK:
            case  IDCANCEL:
            {
             UINT   uIndex, uCount;
             LPTSTR lpszDriverFile;
             HWND   hwndList = GetDlgItem(hWnd, IDC_DRIVER_LIST);

                uCount = (UINT)SendMessage( hwndList, LB_GETCOUNT, 0, 0 );
                for (uIndex = 0; uIndex < uCount; uIndex++)
                {
                    lpszDriverFile = (LPTSTR)SendMessage( hwndList, LB_GETITEMDATA, uIndex, 0 );
                    if (NULL != lpszDriverFile)
                    {
                        ClientFree (lpszDriverFile);
                    }
                }

                EndDialog( hWnd, wParam );
                break;
            }
        }
        
        return TRUE;
    }
    
    return FALSE;
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL RefreshProviderList()
{
    LONG lResult;


    if (!glpProviderList)
    {
        // Initialize data structure
        
        glpProviderList = (LPLINEPROVIDERLIST)GlobalAllocPtr(GPTR, INITIAL_PROVIDER_LIST_SIZE);
    }

    if (!glpProviderList)
    {
        LOG((TL_ERROR, " RefreshProviderList - glpProviderList is NULL - returning CPL_ERR_MEMORY"));
        return FALSE;
    }

    glpProviderList->dwTotalSize = INITIAL_PROVIDER_LIST_SIZE;
    
    lResult = lineGetProviderList( TAPI_VERSION, glpProviderList );

    if (lResult)
    {
        LOG((TL_ERROR, "Error: lineGetProviderList failure %#08lx", lResult ));
        return FALSE;
    }

    while (glpProviderList->dwNeededSize > glpProviderList->dwTotalSize)
    {
        // Expand data structure as necessary
        LOG((TL_ERROR, " RefreshProviderList - expanding glpProviderList."));
        
        LPLINEPROVIDERLIST lpTemp =
            (LPLINEPROVIDERLIST)GlobalReAllocPtr( glpProviderList,
            (size_t)(glpProviderList->dwNeededSize),
            GPTR);
        
        if (!lpTemp)
            return FALSE;
        
        glpProviderList = lpTemp;
        glpProviderList->dwTotalSize = glpProviderList->dwNeededSize;
        lResult = lineGetProviderList( TAPI_VERSION, glpProviderList );
        
        if (lResult)
        {
            LOG((TL_ERROR, "Error: lineGetProviderList failure %#08lx", lResult ));
            return FALSE;
        }
    }

    LOG((TL_ERROR, "%d providers", glpProviderList->dwNumProviders ));

    return TRUE;
}



LPTSTR ProviderIDToFilename( DWORD dwProviderID )
{
    UINT uIndex;
    LPLINEPROVIDERENTRY lpProviderEntry;
    
    // loop through the provider list
    //-------------------------------
    
    lpProviderEntry = (LPLINEPROVIDERENTRY)((LPBYTE)glpProviderList +
        glpProviderList->dwProviderListOffset);
    
    for ( uIndex = 0; uIndex < glpProviderList->dwNumProviders; uIndex++ )
    {
        if (lpProviderEntry[uIndex].dwPermanentProviderID == dwProviderID)
        {
            // Get an entry to put in the list box
            //------------------------------------
            return (LPTSTR)((LPBYTE)glpProviderList +
                lpProviderEntry[uIndex].dwProviderFilenameOffset);
        }
    }
    
    LOG((TL_ERROR, "Provider ID %d not found in list", dwProviderID ));
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplcallingcardtab.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplcallingcardtab.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

//
// Functions used only by the Calling Card tab of the New Location Property Sheet.
// Shared functions are in the Location.cpp file.
//
#include "cplPreComp.h"
#include "cplLocationPS.h"


INT_PTR CALLBACK CLocationPropSheet::CallingCard_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CLocationPropSheet* pthis = (CLocationPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CLocationPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->CallingCard_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        pthis->CallingCard_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
        return 1;

    case WM_NOTIFY:
        return pthis->CallingCard_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a104HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a104HelpIDs);
        break;
    }

    return 0;
}

BOOL CLocationPropSheet::CallingCard_OnInitDialog(HWND hDlg)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, IDC_LIST);

    GetClientRect(hwnd, &rc);

    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn( hwnd, 0, &lvc );
    
    ListView_SetExtendedListViewStyleEx(hwnd, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    m_dwDefaultCard = m_pLoc->GetPreferredCardID();
    if ( 0 == m_dwDefaultCard )
    {
        // Card0 is the "None (Direct Dial)" card which we want to go away
        m_pLoc->UseCallingCard(FALSE);
    }

    PopulateCardList( hwnd );

	// The PIN is not displayed when it's not safe (at logon time, for ex.)

	m_bShowPIN = TapiIsSafeToDisplaySensitiveData();
	
    SetDataForSelectedCard(hDlg);

    hwnd = GetDlgItem(hDlg,IDC_CARDNUMBER);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    hwnd = GetDlgItem(hDlg,IDC_PIN);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    return 0;
}

int CALLBACK CallingCard_ListSort(LPARAM lItem1, LPARAM lItem2, LPARAM )
{
    if ( !lItem1 )
    {
        return -1;
    }
    if ( !lItem2 )
    {
        return 1;
    }

    CCallingCard * pCard1 = (CCallingCard *)lItem1;
    CCallingCard * pCard2 = (CCallingCard *)lItem2;

    return StrCmpIW(pCard1->GetCardName(),pCard2->GetCardName());
}

void CLocationPropSheet::PopulateCardList( HWND hwndList )
{
    CCallingCard * pCard;

    HIMAGELIST himl = ImageList_Create(16, 16, ILC_COLOR|ILC_MASK, 2, 2);
    HBITMAP hBmp = CreateMappedBitmap(GetUIInstance(), IDB_BUTTONS, 0, NULL, 0);

    if (NULL != hBmp)
    {
        ImageList_AddMasked( himl, hBmp, CLR_DEFAULT);
        DeleteObject( hBmp );
    }

    ListView_SetImageList(hwndList, himl, LVSIL_SMALL);

    // Add our special "none" item
    AddCardToList(hwndList,NULL,FALSE);

    m_Cards.Initialize();
    m_Cards.Reset(TRUE);    // TRUE means show "hidden" cards, FALSE means hide them

    while ( S_OK == m_Cards.Next(1,&pCard,NULL) )
    {
        if ( !pCard->IsMarkedHidden() )
        {
            // Card0 is the "None (Direct Dial)" card which we don't want to show
            if ( 0 != pCard->GetCardID() )
            {
                AddCardToList(hwndList,pCard,FALSE);
            }
        }
    }

    ListView_SortItems(hwndList, CallingCard_ListSort, 0);

    EnsureVisible(hwndList, m_pCard);
}

void CLocationPropSheet::AddCardToList(HWND hwndList, CCallingCard * pCard, BOOL bSelect)
{
    TCHAR szText[MAX_INPUT];
    // basically, bSelect is FALSE when we are first populating the list and TRUE when we
    // add items later.  When the value is FALSE what we really mean is "Select the item
    // only if it is the currently selected item based on the location settings".
    if (pCard)
    {
        SHUnicodeToTChar(pCard->GetCardName(), szText, ARRAYSIZE(szText));
        bSelect = bSelect || ((m_dwDefaultCard != 0) && (m_dwDefaultCard==pCard->GetCardID()));
    }
    else
    {
        LoadString(GetUIInstance(), IDS_NONE, szText, ARRAYSIZE(szText));
        bSelect = bSelect || !(m_dwDefaultCard != 0);
    }

    LVITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.pszText = szText;
    lvi.iImage = 0;
    lvi.lParam = (LPARAM)pCard;

    if ( bSelect )
    {
        lvi.mask |= LVIF_STATE;
        lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        lvi.iImage = 1;
        SetCheck(hwndList, m_pCard, FALSE);
        m_pCard = pCard;
    }

    ListView_InsertItem(hwndList, &lvi);
}

void CLocationPropSheet::SetCheck(HWND hwndList, CCallingCard * pCard, int iImage)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pCard;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        LVITEM lvi;
        lvi.mask = LVIF_IMAGE;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.iImage = iImage;

        ListView_SetItem( hwndList, &lvi );
        ListView_Update( hwndList, iItem ); // need the font to be drawn non-bold
    }
}

void CLocationPropSheet::EnsureVisible(HWND hwndList, CCallingCard * pCard)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pCard;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        ListView_EnsureVisible( hwndList, iItem, FALSE );
    }

}

void CLocationPropSheet::UpdateCardInList(HWND hwndList, CCallingCard * pCard)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pCard;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        TCHAR szText[MAX_INPUT];
        SHUnicodeToTChar( pCard->GetCardName(), szText, ARRAYSIZE(szText) );

        LVITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.pszText = szText;
        lvi.lParam = (LONG_PTR)pCard;

        ListView_SetItem( hwndList, &lvi );
    }
}

void CLocationPropSheet::SetDataForSelectedCard(HWND hDlg)
{
    // if a card is selected, then set the text for:
    //  PIN Number
    //  Card Number
    //  Long Distance Access Number
    //  International Access Number
    if ( m_pCard )
    {
        TCHAR szText[MAX_INPUT];

        if(m_bShowPIN)
        {
        	SHUnicodeToTChar(m_pCard->GetPIN(), szText, ARRAYSIZE(szText));
        	SetWindowText( GetDlgItem(hDlg, IDC_PIN), szText );
        }
        else
        {
	        SetWindowText( GetDlgItem(hDlg, IDC_PIN), TEXT("") );
        }

        SHUnicodeToTChar(m_pCard->GetAccountNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_CARDNUMBER), szText );

        SHUnicodeToTChar(m_pCard->GetLongDistanceAccessNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_LONGDISTANCE), szText );

        SHUnicodeToTChar(m_pCard->GetInternationalAccessNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_INTERNATIONAL), szText );

        SHUnicodeToTChar(m_pCard->GetLocalAccessNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_LOCAL), szText );
    }
    else
    {
        SetWindowText( GetDlgItem(hDlg, IDC_PIN), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_CARDNUMBER), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_LONGDISTANCE), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_INTERNATIONAL), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_LOCAL), TEXT("") );
    }

    // The button state depends on whether a card is selected
    BOOL bEnable = 0!=m_pCard;
    EnableWindow( GetDlgItem(hDlg, IDC_EDIT),       bEnable );
    HWND hwnd = GetDlgItem(hDlg, IDC_DELETE);
    if ( !bEnable && GetFocus() == hwnd )
    {
        HWND hwndDef = GetDlgItem(hDlg, IDC_NEW);
        SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
        SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
        SetFocus(hwndDef);
    }
    EnableWindow( hwnd, bEnable );
    EnableWindow( GetDlgItem(hDlg, IDC_SETDEFAULT), bEnable );

    EnableWindow( GetDlgItem(hDlg, IDC_PIN), bEnable );
    EnableWindow( GetDlgItem(hDlg, IDC_CARDNUMBER), bEnable );
}

BOOL CLocationPropSheet::CallingCard_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_NEW:
    case IDC_EDIT:
        LaunchCallingCardPropSheet(IDC_NEW == wID, hwndParent);
        break;

    case IDC_DELETE:
        DeleteSelectedCard(GetDlgItem(hwndParent,IDC_LIST));
        break;

    case IDC_PIN:
    case IDC_CARDNUMBER:
        if ( EN_CHANGE == wNotifyCode )
        {
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
        }
        break;

    default:
        return 0;
    }
    return 1;
}

void CLocationPropSheet::LaunchCallingCardPropSheet(BOOL bNew, HWND hwndParent)
{
    CCallingCard * pCard;
    if ( bNew )
    {
        TCHAR szCardName[MAX_INPUT];
        WCHAR wszCardName[MAX_INPUT];

        pCard = new CCallingCard;
		if (NULL == pCard)
		{
			// Nothing much to do.
			return;
		}
        LoadString(GetUIInstance(), IDS_NEWCALLINGCARD, szCardName, ARRAYSIZE(szCardName));
        SHTCharToUnicode(szCardName, wszCardName, ARRAYSIZE(wszCardName));
        pCard->Initialize(
            0,
            wszCardName,
            0,
            L"",
            L"",
            L"",
            L"",
            L"",
            L"",
            L"",
            L"" );
    }
    else
    {
        pCard = m_pCard;
        if ( !pCard )
        {
            // must have clicked on the None card, do nothing.  We can only get
            // here when the user double clicks on an item.
            MessageBeep(0);
            return;
        }
    }

    CCallingCardPropSheet ccps( bNew, m_bShowPIN, pCard, &m_Cards );
    int iRes = ccps.DoPropSheet(hwndParent);

    if ( PSN_APPLY == iRes )
    {
        HWND hwndList = GetDlgItem(hwndParent,IDC_LIST);
        if ( bNew )
        {
            pCard->SetCardID(m_Cards.AllocNewCardID());
            m_Cards.AddCard(pCard);
            AddCardToList(hwndList, pCard, TRUE);
        }
        else
        {
            UpdateCardInList(hwndList, pCard);
        }
        ListView_SortItems(hwndList, CallingCard_ListSort, 0);

        EnsureVisible(hwndList, pCard);

		// It's safe to display the PIN number after an Apply in the detail dialog
		m_bShowPIN = TRUE;
        SetDataForSelectedCard(hwndParent);

        SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
    }
    else if (bNew)
    {
        delete pCard;
    }
}

BOOL CLocationPropSheet::CallingCard_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // Let the generic handler have a crack at it first
    OnNotify(hwndDlg, pnmhdr);

    switch (pnmhdr->idFrom)
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( (pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED) )
            {
                LVITEM lvi;
                lvi.iItem = pnmlv->iItem;
                lvi.iSubItem = pnmlv->iSubItem;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CCallingCard * pCard = (CCallingCard *)lvi.lParam;

                // update the location to reflect the selected card
                if ( 0!=pCard )
                {
                    m_dwDefaultCard = pCard->GetCardID();
                }
                else
                {
                    m_dwDefaultCard = 0;
                }

                // clear the previous check using the old m_pCard value
                SetCheck(pnmhdr->hwndFrom, m_pCard, FALSE);

                // Update m_pCard to the currently selected item
                m_pCard = pCard;

                // set the Edit and Delete button states and update the card info
                m_bShowPIN = TapiIsSafeToDisplaySensitiveData();
                SetDataForSelectedCard(hwndDlg);

                // set the newly selected card to checked
                SetCheck(pnmhdr->hwndFrom, m_pCard, TRUE);
            }
            break;

        case NM_DBLCLK:
            // Assert( pCard == m_pCard );
            if ( -1 != pnmlv->iItem )
            {
                // Do edit case
                LaunchCallingCardPropSheet(FALSE,hwndDlg);
            }
            else
            {
                // Do new case
                LaunchCallingCardPropSheet(TRUE,hwndDlg);
            }
            break;

        case NM_CUSTOMDRAW:
            #define lplvcd ((LPNMLVCUSTOMDRAW)pnmhdr)

            if(lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT)
            {
                // Request prepaint notifications for each item.
                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NOTIFYITEMDRAW);
                return CDRF_NOTIFYITEMDRAW;
            }

            if(lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
            {
                LVITEM lvi;
                lvi.iItem = (int)lplvcd->nmcd.dwItemSpec;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CCallingCard * pCard = (CCallingCard *)lvi.lParam;

                if( (!pCard && 0 == m_dwDefaultCard) || 
                    (pCard && pCard->GetCardID() == m_dwDefaultCard) )
                {
                    extern HFONT g_hfontBold;
                    if (g_hfontBold)
                    {
                        SelectObject(lplvcd->nmcd.hdc, g_hfontBold);
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
                        return CDRF_NEWFONT;
                    }
                }

                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_DODEFAULT);
                return CDRF_DODEFAULT;
            }
            return 0;
            #undef lplvcd

        default:
            break;
        }
        break;
        #undef pnmlv

    default:
        switch (pnmhdr->code)
        {
        case PSN_APPLY:
            return CallingCard_OnApply(hwndDlg);

        default:
            break;
        }
        return 0;
    }
    return 1;
}

BOOL CLocationPropSheet::CallingCard_OnApply(HWND hwndDlg)
{
    // if a calling card should be used make sure one is selected
    if ( m_dwDefaultCard != 0 )
    {
        CCallingCard * pCard = m_Cards.GetCallingCard(m_dwDefaultCard);

        if ( !pCard )
        {
            HWND hwndList = GetDlgItem(hwndDlg,IDC_LIST);
            // error, no card is set as the default
            PropSheet_SetCurSelByID(GetParent(hwndDlg),IDD_LOC_CALLINGCARD);
            ShowErrorMessage(hwndList, IDS_NOCARDSELECTED);
            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

        // Store the original values before we change them:
        WCHAR wszOldCardNum[128];
        WCHAR wszOldPIN[128];
        StrCpyNW( wszOldCardNum, pCard->GetAccountNumber(), ARRAYSIZE(wszOldCardNum));
        StrCpyNW( wszOldPIN, pCard->GetPIN(), ARRAYSIZE(wszOldPIN));

        // get the current values:
        TCHAR szText[MAX_INPUT];
        WCHAR wszBuf[MAX_INPUT];

        GetWindowText(GetDlgItem(hwndDlg,IDC_CARDNUMBER), szText, ARRAYSIZE(szText));
        LOG((TL_INFO, "CallingCard_OnApply: Setting card number to %s", szText));
        SHTCharToUnicode(szText, wszBuf, ARRAYSIZE(wszBuf));
        pCard->SetAccountNumber(wszBuf);

        GetWindowText(GetDlgItem(hwndDlg,IDC_PIN), szText, ARRAYSIZE(szText));
        LOG((TL_INFO, "CallingCard_OnApply: Setting pin number to %s", szText));
        SHTCharToUnicode(szText, wszBuf, ARRAYSIZE(wszBuf));
        pCard->SetPIN(wszBuf);

        // check for validity:
        DWORD dwResult = pCard->Validate();
        if ( dwResult )
        {
            HWND hwnd;
            int iStrID;

            // something isn't valid, revert to old card Num and PIN in case
            // the user later decided to cancel
            pCard->SetAccountNumber(wszOldCardNum);
            pCard->SetPIN(wszOldPIN);

            if ( dwResult & CCVF_NOCARDNUMBER)
            {
                hwnd = GetDlgItem(hwndDlg, IDC_CARDNUMBER);
                iStrID = IDS_MUSTENTERCARDNUMBER;
            }
            else if ( dwResult & CCVF_NOPINNUMBER )
            {
                hwnd = GetDlgItem(hwndDlg, IDC_PIN);
                iStrID = IDS_MUSTENTERPINNUMBER;
            }
            else
            {
                hwnd = GetDlgItem(hwndDlg, IDC_LIST);
                iStrID = IDS_INVALIDCARD;
            }
            PropSheet_SetCurSelByID(GetParent(hwndDlg),IDD_LOC_CALLINGCARD);
            ShowErrorMessage(hwnd, iStrID);
            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }
    }

    m_pLoc->SetPreferredCardID(m_dwDefaultCard);
    m_pLoc->UseCallingCard(m_dwDefaultCard != 0);
    m_Cards.SaveToRegistry();
    m_bShowPIN = TRUE;
    m_bWasApplied = TRUE;
    return PSNRET_NOERROR;
}

int DeleteItemAndSelectFirst( HWND hwndParent, int iList, int iItem, int iDel, int iAdd )
{
    HWND hwnd = GetDlgItem(hwndParent, iList);
    ListView_DeleteItem(hwnd, iItem);

    // Try to select the first item, if possible
    iItem = 0;
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    if ( ListView_GetItem(hwnd, &lvi) )
    {
        ListView_SetItemState(hwnd, iItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        ListView_EnsureVisible(hwnd, iItem, FALSE);
    }
    else
    {
        iItem = -1;
    }

    hwnd = GetDlgItem(hwndParent,iDel);
    if ( -1 == iItem )
    {
        if ( GetFocus() == hwnd )
        {
            HWND hwndDef = GetDlgItem(hwndParent,iAdd);
            SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
            SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
            SetFocus(hwndDef);
        }
    }
    EnableWindow(hwnd, -1!=iItem);

    return iItem;
}

void CLocationPropSheet::DeleteSelectedCard(HWND hwndList)
{
    // First we confirm the delete with the user
    TCHAR szText[1024];
    TCHAR szTitle[128];
    int result;
    HWND hwndParent = GetParent(hwndList);
    
    LoadString(GetUIInstance(), IDS_DELETECARDTEXT, szText, ARRAYSIZE(szText));
    LoadString(GetUIInstance(), IDS_CONFIRMDELETE, szTitle, ARRAYSIZE(szTitle));

    result = SHMessageBoxCheck( hwndParent, szText, szTitle, MB_YESNO, IDYES, TEXT("TAPIDeleteCallingCard") );
    if ( IDYES == result )
    {
        // remove the item corresponding to m_pCard from the list
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = (LPARAM)m_pCard;
        int iItem = ListView_FindItem(hwndList, -1, &lvfi);
        if ( -1 != iItem )
        {
            HWND hwndParent = GetParent(hwndList);
            m_Cards.RemoveCard(m_pCard);
            iItem = DeleteItemAndSelectFirst( hwndParent, IDC_LIST, iItem, IDC_DELETE, IDC_ADD );

            if ( -1 != iItem )
            {
                LVITEM lvi;
                lvi.iItem = iItem;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                // Store the currently selected item
                m_pCard = (CCallingCard*)lvi.lParam;
            }
            else
            {
                m_pCard = NULL;
            }

			m_bShowPIN = TapiIsSafeToDisplaySensitiveData();

            SetDataForSelectedCard(hwndParent);
            SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
        }
        else
        {
            // It's really bad if this ever happens (which it shouldn't).  This means our
            // data is in an unknown state and we might do anything (even destroy data).
            LOG((TL_ERROR, "DeleteSelectedCard: Card Not Found!"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplcallingcardps.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplcallingcardps.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once


class CCallingCardPropSheet
{
public:
    CCallingCardPropSheet(BOOL bNew, BOOL bShowPIN, CCallingCard * pCard, CCallingCards * pCards);
    ~CCallingCardPropSheet();
#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCallingCardPropSheet)
#endif
    LONG DoPropSheet(HWND hwndParent);

protected:
    // functions for the general page
    static INT_PTR CALLBACK General_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL General_OnInitDialog(HWND hwndDlg);
    BOOL General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    BOOL Gerneral_OnApply(HWND hwndDlg);
    void SetTextForRules(HWND hwndDlg);

    // functions shared by all the other pages
    static INT_PTR CALLBACK DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL OnInitDialog(HWND hwndDlg, int iPage);
    BOOL OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl, int iPage);
    BOOL OnNotify(HWND hwndDlg, LPNMHDR pnmhdr, int iPage);
    BOOL OnDestroy(HWND hwndDlg);
    void SetButtonStates(HWND hwndDlg, int iItem);
    BOOL UpdateRule(HWND hwndDlg, int iPage);

    BOOL            m_bNew;     // True if this is a new location, false if we're editing an existing one
    BOOL			m_bShowPIN;	// True if it's safe to display the PIN
    CCallingCard *  m_pCard;    // pointer to the location object to use.
    CCallingCards * m_pCards;   // pointer to the list of all cards in the parent
    BOOL            m_bHasLongDistance;
    BOOL            m_bHasInternational;
    BOOL            m_bHasLocal;
    BOOL            m_bWasApplied;
};

typedef struct tagCCPAGEDATA
{
    CCallingCardPropSheet * pthis;
    int iWhichPage;
} CCPAGEDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplgeneraltab.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplgeneraltab.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/


//
// Functions used only by the General tab of the New Location Property Sheet.
// Shared functions are in the Location.cpp file.
//
#include "cplPreComp.h"
#include "cplLocationPS.h"


void UpdateSampleString(HWND hwnd, CLocation * pLoc, PCWSTR pwszAddress, CCallingCard * pCard)
{
    CCallingCard cc;
    LPWSTR pwszDialable;
    LPWSTR pwszDisplayable;
    TCHAR szBuf[512];
    DWORD dwOptions = pLoc->HasCallWaiting() ? LINETRANSLATEOPTION_CANCELCALLWAITING : 0;

    if ( (NULL == pCard) && pLoc->HasCallingCard() )
    {
        if ( SUCCEEDED(cc.Initialize(pLoc->GetPreferredCardID())) )
        {
            pCard = &cc;
        }
    }

    if ( 0 == pLoc->TranslateAddress(pwszAddress, pCard, dwOptions, &dwOptions, NULL, &pwszDialable, &pwszDisplayable) )
    {
        SHUnicodeToTChar(pwszDisplayable, szBuf, ARRAYSIZE(szBuf));
        ClientFree(pwszDialable);
        ClientFree(pwszDisplayable);
    }
    else
    {
        LOG((TL_ERROR, "UpdateSampleString failed to call pLoc->TranslateAddress\n"));
        // REVIEW: Should we load some sort of error string instead?  Perhaps we should featch the
        // error text for the given error code from the message resources in tapiui?
        szBuf[0] = TEXT('\0');
    }
    SetWindowText(hwnd, szBuf);
}

INT_PTR CALLBACK CLocationPropSheet::General_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CLocationPropSheet* pthis = (CLocationPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CLocationPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->General_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->General_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );

    case WM_NOTIFY:
        return pthis->General_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a102HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a102HelpIDs);
        break;
    }

    return 0;
}

BOOL CLocationPropSheet::General_OnInitDialog(HWND hwndDlg)
{
    TCHAR szBuf[1024];
    HWND hwnd;
    hwnd = GetDlgItem( hwndDlg, IDC_LOCATIONNAME );
    SHUnicodeToTChar(m_pLoc->GetName(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);

    hwnd = GetDlgItem( hwndDlg, IDC_COUNTRY );
    m_dwCountryID = m_pLoc->GetCountryID();
    PopulateCountryList( hwnd, m_dwCountryID );

    CCountry * pCountry;
    HRESULT hr;

    hr = CreateCountryObject(m_dwCountryID, &pCountry);
    if ( SUCCEEDED(hr) )
    {
        m_iCityRule = IsCityRule(pCountry->GetLongDistanceRule());
        m_iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
        m_iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
        delete pCountry;
    } else {
        LOG((TL_ERROR, "General_OnInitDialog failed to create country %d", m_dwCountryID));
        m_iCityRule = CITY_OPTIONAL;
        m_iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
        m_iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
    }



    hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
    SHUnicodeToTChar(m_pLoc->GetAreaCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);
    if ( m_iCityRule == CITY_NONE )
    {
        // The selected country does not have area codes
        EnableWindow(hwnd, FALSE);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_LOCALACCESSNUM);
    SHUnicodeToTChar(m_pLoc->GetLocalAccessCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);

    hwnd = GetDlgItem(hwndDlg,IDC_LONGDISTANCEACCESSNUM);
    SHUnicodeToTChar(m_pLoc->GetLongDistanceAccessCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);

    hwnd = GetDlgItem(hwndDlg,IDC_LONGDISTANCECARRIERCODE);
    SHUnicodeToTChar(m_pLoc->GetLongDistanceCarrierCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);
    if ( LONG_DISTANCE_CARRIER_NONE == m_iLongDistanceCarrierCodeRule )
    {
        // The selected country does not have long distance carrier codes
        EnableWindow(hwnd, FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_STATICLDC), FALSE);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_INTERNATIONALCARRIERCODE);
    SHUnicodeToTChar(m_pLoc->GetInternationalCarrierCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);
    if ( INTERNATIONAL_CARRIER_NONE == m_iInternationalCarrierCodeRule )
    {
        // The selected country does not have international carrier codes
        EnableWindow(hwnd, FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_STATICIC), FALSE);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_DISABLESTRING);
    LPWSTR lpwsz = m_pLoc->GetDisableCallWaitingCode();
    SHUnicodeToTChar(lpwsz, szBuf, ARRAYSIZE(szBuf));
    SendMessage(hwnd, CB_LIMITTEXT, CPL_SETTEXTLIMIT, 0);
    PopulateDisableCallWaitingCodes(hwnd, szBuf);
    LimitCBInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);
    if ( NULL == *lpwsz || !m_pLoc->HasCallWaiting() )
    {
        EnableWindow(hwnd, FALSE);
    }
    else
    {
        hwnd = GetDlgItem(hwndDlg,IDC_DISABLECALLWAITING);
        SendMessage(hwnd,BM_SETCHECK, BST_CHECKED, 0);
    }

    CheckRadioButton(hwndDlg,IDC_TONE,IDC_PULSE,m_pLoc->HasToneDialing()?IDC_TONE:IDC_PULSE);

    if (!m_pwszAddress)
    {
        ShowWindow(GetDlgItem(hwndDlg,IDC_PHONENUMBERTEXT), SW_HIDE);
    }

    return 0;
}

BOOL PopulateCountryList(HWND hwndCombo, DWORD dwSelectedCountry)
{
    BOOL bResult = FALSE;
    CCountries CountryList;

    SendMessage(hwndCombo,CB_RESETCONTENT,0,0);

    if ( SUCCEEDED(CountryList.Initialize()) )
    {
        TCHAR szText[1024];
        CCountry * pC;
        DWORD dwCurCountryID;
        LRESULT iIndex;

        CountryList.Reset();
        while ( S_OK == CountryList.Next(1,&pC,NULL) )
        {
            SHUnicodeToTChar(pC->GetCountryName(), szText, ARRAYSIZE(szText));
            iIndex = SendMessage(hwndCombo,CB_ADDSTRING,0,(LPARAM)szText);
            dwCurCountryID = pC->GetCountryID();
            SendMessage(hwndCombo,CB_SETITEMDATA,iIndex,(LPARAM)dwCurCountryID);

            if ( dwCurCountryID == dwSelectedCountry )
            {
                SendMessage(hwndCombo,CB_SETCURSEL,iIndex,0);
                bResult = TRUE;
            }
        }
    }

    // REVIEW: If no country was selected (bResult == FALSE) should we simply select some
    // arbitrary country?  First in the list?  The USA?

    return bResult;
}

BOOL CLocationPropSheet::PopulateDisableCallWaitingCodes(HWND hwndCombo, LPTSTR szSelected)
{
    TCHAR cszTelephonyKey[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
    HKEY hkey;
    int i;

    // These get read from the registry
    // NOTE: This might fail on a tightly locked down system, but there's nothing I can do
    // about that.  Worst case the list of codes is empty and the user just types the code.
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszTelephonyKey,
            0, KEY_QUERY_VALUE, &hkey) )
    {
        TCHAR szDisableCallWaiting[32];
        TCHAR szCode[32];
        DWORD dwType;
        DWORD dwSize;

        for ( i=0; ; i++ )
        {
            // This string is a reg value and is not localized
            wsprintf(szDisableCallWaiting, TEXT("DisableCallWaiting%d"), i);

            dwSize = sizeof(szCode);
            if ( ERROR_SUCCESS != RegQueryValueEx(hkey, szDisableCallWaiting, NULL, &dwType, (LPBYTE)szCode, &dwSize) )
            {
                // when we fail to read an item its most likely because their are no more items,
                // but even if it's some other error we don't know how to handle it anyhow.
                break;
            }

            if ( dwType != REG_SZ )
            {
                // I'll just skip any values that I don't know how to deal with
                continue;
            }

            SendMessage(hwndCombo,CB_ADDSTRING,0,(LPARAM)szCode);
        }
    }

    // and then we add a special one if the current code is not a standard code
    if ( szSelected && *szSelected )
    {
        LRESULT lResult;

        lResult = SendMessage(hwndCombo, CB_FINDSTRINGEXACT, -1, (LPARAM)szSelected);
        if ( lResult == (LRESULT)CB_ERR )
        {
            // if the item wasn't found, we add it
            lResult = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)szSelected);
        }

        SendMessage(hwndCombo, CB_SETCURSEL, lResult, 0);
    }

    return TRUE;
}

BOOL CLocationPropSheet::General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCtl)
{
    WCHAR wszBuf[512];

    switch (wID)
    {
    case IDC_DISABLECALLWAITING:
        if ( BN_CLICKED == wNotifyCode )
        {
            BOOL bOn = SendMessage(hwndCtl, BM_GETCHECK, 0,0) == BST_CHECKED;
            HWND hwnd = GetDlgItem(hwndParent, IDC_DISABLESTRING);
            EnableWindow(hwnd, bOn);
            m_pLoc->UseCallWaiting(bOn);
            if ( bOn )
            {
                SetFocus(hwnd);
            }
            break;
        }
        return 1;

    case IDC_TONE:
    case IDC_PULSE:
        m_pLoc->UseToneDialing(IDC_TONE==wID);
        break;

    case IDC_COUNTRY:
        if ( CBN_SELCHANGE == wNotifyCode )
        {
            LRESULT lrSel = SendMessage(hwndCtl,CB_GETCURSEL,0,0);
            m_dwCountryID = (DWORD)SendMessage(hwndCtl,CB_GETITEMDATA,lrSel,0);
            m_pLoc->SetCountryID(m_dwCountryID);

            CCountry * pCountry;
            HRESULT hr;

            hr = CreateCountryObject(m_dwCountryID, &pCountry);
            if ( SUCCEEDED(hr) )
            {
                m_iCityRule = IsCityRule(pCountry->GetLongDistanceRule());
                m_iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                m_iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                delete pCountry;
            } else {
                LOG((TL_ERROR, "General_OnInitDialog failed to create country %d", m_dwCountryID));
                m_iCityRule = CITY_OPTIONAL;
                m_iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                m_iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
            }


            HWND hwnd = GetDlgItem(hwndParent,IDC_AREACODE);
            if ( m_iCityRule == CITY_NONE )
            {
                SetWindowText(hwnd, TEXT(""));
                m_pLoc->SetAreaCode(L"");
                EnableWindow(hwnd, FALSE);
            }
            else
            {
                EnableWindow(hwnd, TRUE);
            }

            hwnd = GetDlgItem(hwndParent,IDC_LONGDISTANCECARRIERCODE);
            if ( LONG_DISTANCE_CARRIER_NONE == m_iLongDistanceCarrierCodeRule ) 
            {
                SetWindowText(hwnd, TEXT(""));
                m_pLoc->SetLongDistanceAccessCode(L"");
                EnableWindow(hwnd, FALSE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICLDC), FALSE);
            }
            else
            {
                EnableWindow(hwnd, TRUE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICLDC), TRUE);
            }

            hwnd = GetDlgItem(hwndParent,IDC_INTERNATIONALCARRIERCODE);
            if ( INTERNATIONAL_CARRIER_NONE == m_iInternationalCarrierCodeRule ) 
            {
                SetWindowText(hwnd, TEXT(""));
                m_pLoc->SetInternationalCarrierCode(L"");
                EnableWindow(hwnd, FALSE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICIC), FALSE);
            }
            else
            {
                EnableWindow(hwnd, TRUE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICIC), TRUE);
            }
            
            break;
        }
        return 1;

    case IDC_LOCATIONNAME:
    case IDC_AREACODE:
    case IDC_LONGDISTANCECARRIERCODE:
    case IDC_INTERNATIONALCARRIERCODE:
    case IDC_LOCALACCESSNUM:
    case IDC_LONGDISTANCEACCESSNUM:
        if ( EN_CHANGE == wNotifyCode )
        {
            TCHAR szValue[512];
            GetWindowText(hwndCtl, szValue, ARRAYSIZE(szValue));
            SHTCharToUnicode(szValue, wszBuf, ARRAYSIZE(wszBuf));
            switch (wID)
            {
                case IDC_LOCATIONNAME:
                    m_pLoc->SetName(wszBuf);
                    break;

                case IDC_AREACODE:
                    m_pLoc->SetAreaCode(wszBuf);
                    break;

                case IDC_LONGDISTANCECARRIERCODE:
                    m_pLoc->SetLongDistanceCarrierCode(wszBuf);
                    break;

                case IDC_INTERNATIONALCARRIERCODE:
                    m_pLoc->SetInternationalCarrierCode(wszBuf);
                    break;

                case IDC_LOCALACCESSNUM:
                    m_pLoc->SetLocalAccessCode(wszBuf);
                    break;

                case IDC_LONGDISTANCEACCESSNUM:
                    m_pLoc->SetLongDistanceAccessCode(wszBuf);
                    break;
            }
            break;
        }
        return 1;

    case IDC_DISABLESTRING:
        switch ( wNotifyCode )
        {
        case CBN_SELCHANGE:
            {
                TCHAR szDisableCode[128];
                LRESULT lr = SendMessage(hwndCtl, CB_GETCURSEL, 0,0);

                SendMessage(hwndCtl, CB_GETLBTEXT, lr, (LPARAM)szDisableCode);
                SHTCharToUnicode(szDisableCode, wszBuf, ARRAYSIZE(wszBuf));
                m_pLoc->SetDisableCallWaitingCode(wszBuf);
            }
            break;

        case CBN_EDITCHANGE:
            {
                TCHAR szDisableCode[128];

                GetWindowText(hwndCtl, szDisableCode, ARRAYSIZE(szDisableCode));
                SHTCharToUnicode(szDisableCode, wszBuf, ARRAYSIZE(wszBuf));
                m_pLoc->SetDisableCallWaitingCode(wszBuf);
            }
            break;
        default:
            return 1;
        }
        break;

    default:
        return 0;
    }

    if (m_pwszAddress)
    {
        CCallingCard * pCard = NULL;
        if (m_pLoc->HasCallingCard())
        {
            pCard = m_Cards.GetCallingCard(m_pLoc->GetPreferredCardID());
        }
        UpdateSampleString(GetDlgItem(hwndParent, IDC_PHONENUMBERSAMPLE), m_pLoc, m_pwszAddress, pCard);
    }

    m_pLoc->Changed();
    SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);

    return 1;
}

BOOL CLocationPropSheet::General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // Let the generic handler have a crack at it first
    OnNotify(hwndDlg, pnmhdr);

    switch (pnmhdr->code)
    {
    case PSN_APPLY:     // user pressed OK or Apply
        return General_OnApply(hwndDlg);
     
    case PSN_SETACTIVE:
        if (m_pwszAddress)
        {
            CCallingCard * pCard = NULL;
            if (m_pLoc->HasCallingCard())
            {
                pCard = m_Cards.GetCallingCard(m_pLoc->GetPreferredCardID());
            }
            UpdateSampleString(GetDlgItem(hwndDlg, IDC_PHONENUMBERSAMPLE), m_pLoc, m_pwszAddress, pCard);
        }
        break;
    default:
        break;
    }
    return FALSE;
}

// General_OnApply
//
// Called when the user selects OK or APPLY on the prop sheet.
// Return PSNRET_INVALID_NOCHANGEPAGE if anything is wrong.
// Return PSNRET_NOERROR if everything is OK.
BOOL CLocationPropSheet::General_OnApply(HWND hwndDlg)
{
    PWSTR   pwszName;
    int     iCtl;
    int     iErr;

    // First we do the sanity checks.  We return without changing the object if any of these fail.
    //  * The location must have a name
    //  * The location must have an area code if it's not a CityRule
    //  * If "Disable call waiting" is checked, a disable code must have been entered
    //  * A Country must be selected (it should be impossible for this not to be true, but we check to be safe).
    //  * The name, as entered, must be unique
    pwszName = m_pLoc->GetName();
    if ( !*pwszName )
    {
        iCtl = IDC_LOCATIONNAME;
        iErr = IDS_NEEDALOCATIONNAME;
        goto ExitWithError;
    }

    if ( (CITY_MANDATORY==m_iCityRule) && !*(m_pLoc->GetAreaCode()) )
    {
        iCtl = IDC_AREACODE;
        iErr = IDS_NEEDANAREACODE;
        goto ExitWithError;
    }

    if ( (LONG_DISTANCE_CARRIER_MANDATORY == m_iLongDistanceCarrierCodeRule) && 
         !*(m_pLoc->GetLongDistanceCarrierCode()) )
    {
        iCtl = IDC_LONGDISTANCECARRIERCODE;
        iErr = IDS_NEEDALONGDISTANCECARRIERCODE;
        goto ExitWithError;
    }

    if ( (INTERNATIONAL_CARRIER_MANDATORY == m_iInternationalCarrierCodeRule) && 
         !*(m_pLoc->GetInternationalCarrierCode()) )
    {
        iCtl = IDC_INTERNATIONALCARRIERCODE;
        iErr = IDS_NEEDANINTERNATIONALCARRIERCODE;
        goto ExitWithError;
    }

    if ( m_pLoc->HasCallWaiting() && !*(m_pLoc->GetDisableCallWaitingCode()) )
    {
        iCtl = IDC_DISABLESTRING;
        iErr = IDS_NEEDADISABLESTRING;
        goto ExitWithError;
    }

    if ( !m_dwCountryID )
    {
        iCtl = IDC_COUNTRY;
        iErr = IDS_NEEDACOUNTRY;
        goto ExitWithError;
    }

    // We need to ensure that the name is unique.
    CLocation * pLoc;
    m_pLocList->Reset();
    while (S_OK == m_pLocList->Next(1, &pLoc, NULL))
    {
        // exclude ourselves from this comparision.
        if ( pLoc->GetLocationID() != m_pLoc->GetLocationID() )
        {
            // see if the names are identical
            if ( 0 == StrCmpIW(pLoc->GetName(), pwszName))
            {
                // yes, the name is in conflict
                iCtl = IDC_LOCATIONNAME;
                iErr = IDS_NEEDUNIQUENAME;
                goto ExitWithError;
            }
        }
    }

    // everything is OK
    m_bWasApplied = TRUE;

    return PSNRET_NOERROR;

ExitWithError:
    PropSheet_SetCurSelByID(GetParent(hwndDlg),IDD_LOC_GENERAL);
    ShowErrorMessage(GetDlgItem(hwndDlg,iCtl), iErr);
    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cpldialingrulesps.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cpldialingrulesps.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/


// Property Sheet stuff for the main page
#include "cplPreComp.h"
#include "cplLocationPS.h"

#include <setupapi.h>       // for HDEVINFO
#include <winuser.h>        // for HDEVNOTIFY


// Global Variables

HFONT g_hfontBold = NULL;
HINSTANCE g_hInstUI = NULL;

// Prototypes

BOOL CALLBACK SetToForegroundEnumProc( HWND hwnd, LPARAM lParam );
extern "C" INT_PTR CALLBACK LocWizardDlgProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam );

extern "C" LONG EnsureOneLocation (HWND hwnd);

class CDialingRulesPropSheet
{
public:
    CDialingRulesPropSheet(LPCWSTR pwszAddress, DWORD dwAPIVersion);
    ~CDialingRulesPropSheet();

#ifdef	TRACELOG
	DECLARE_TRACELOG_CLASS(CDialingRulesPropSheet)
#endif

    LONG DoPropSheet(HWND hwndParent, int iTab);

protected:
    LONG CheckForOtherInstances();

    static INT_PTR CALLBACK Dailing_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL Dailing_OnInitDialog(HWND hDlg);
    BOOL Dailing_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL Dailing_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    void LaunchLocationPropSheet(BOOL bNew, HWND hwndParent);
    void DeleteSelectedLocation(HWND hwndList);
    void AddLocationToList(HWND hwndList, CLocation *pLoc, BOOL bSelect);
    void UpdateLocationInList(HWND hwndList, CLocation *pLocOld, CLocation *pLocNew);
    void UpdateControlStates(HWND hDlg);
    void SetCheck(HWND hwndList, CLocation * pLoc, int iImage);

    static INT_PTR CALLBACK Advanced_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL Advanced_OnInitDialog(HWND hDlg);
    BOOL Advanced_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);

    HANDLE      m_hMutex;
    DWORD       m_dwDefaultCountryID;
    CLocation * m_pLocSelected; // pointer the the CLocation for the selected item in the list view.
                                // can be NULL if no item is selected.

    CLocations  m_locs;         // The locations data used to build the locations list
    LPCWSTR     m_pwszAddress;  // The address (number) we are translating

    int         m_iSortCol;     // which column to sort by

    DWORD       m_dwAPIVersion; // The version of tapi used to call internalConfig
};


CDialingRulesPropSheet::CDialingRulesPropSheet(LPCWSTR pwszAddress, DWORD dwAPIVersion)
{
    m_pwszAddress = pwszAddress;
    m_hMutex = NULL;
    m_pLocSelected = NULL;
    m_dwDefaultCountryID = GetProfileInt(TEXT("intl"), TEXT("iCountry"), 1);
    m_iSortCol = 0;
    m_dwAPIVersion = dwAPIVersion;
}


CDialingRulesPropSheet::~CDialingRulesPropSheet()
{
    if ( m_hMutex )
        CloseHandle( m_hMutex );
}

typedef struct tagMODEMDLG
{
    HDEVINFO    hdi;
    HDEVNOTIFY  NotificationHandle;
    int         cSel;
    DWORD       dwFlags;
} MODEMDLG, FAR * LPMODEMDLG;


LONG CDialingRulesPropSheet::DoPropSheet(HWND hwndParent, int iTab)
{
    LONG result;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  ahpsp[3];
    PROPSHEETPAGE   apsp[3];
    HINSTANCE       hInstModemUI = NULL;

    DLGPROC         pfnModemDialogProc = NULL;
    MODEMDLG md;
    md.hdi = INVALID_HANDLE_VALUE;
    md.cSel  = 0;
    md.dwFlags = 0;

    result = CheckForOtherInstances();
    if ( result )
    {
        return result;
    }

    // if iTab is -1 then we only show the dialing rules tab and we hide the modem
    // and advanced tabs.  When lineTranslateDialog is called we pass -1 for iTab,
    // when the CPL is invoked we pass the starting page number as iTab.
    if ( -1 != iTab )
    {
        // we can't link directly to modemui.dll because we live inside TAPI,
        // so delay load all the required MODEMUI functions up front.
        hInstModemUI = LoadLibrary(TEXT("modemui.dll"));
		if (!hInstModemUI)
		{
			return FALSE;
		}
            // get proc the functions we need.
        pfnModemDialogProc = (DLGPROC)GetProcAddress(hInstModemUI,"ModemCplDlgProc");
		if ( !pfnModemDialogProc )
		{
			FreeLibrary(hInstModemUI);
			return FALSE;   // Review: Does this return code matter?
		}
    }

    // Review: The old dialing page had some pre-launch configuration to do.
    // Some sort of lineConfigure function or something.  Check if this is needed.

    // We delay the initialization until here
    result = (LONG)m_locs.Initialize();
    if (result && (result != LINEERR_INIFILECORRUPT))
    {
        TCHAR szCaption[MAX_INPUT];
        TCHAR szMessage[512];

        LoadString(GetUIInstance(), IDS_NAME, szCaption, ARRAYSIZE(szCaption));
        LoadString(GetUIInstance(), IDS_CANNOT_START_TELEPHONCPL, szMessage, ARRAYSIZE(szMessage));
        MessageBox(hwndParent, szMessage, szCaption, MB_OK | MB_ICONWARNING);
        return result;
    }

    // If there are no locations, launch the simple location dialog
    if ( 0 == m_locs.GetNumLocations() )
    {
        // if we are in lineTranslateDialog mode, then we display the simple
        int iRes;
        iRes = (int)DialogBoxParam(GetUIInstance(), MAKEINTRESOURCE(IDD_SIMPLELOCATION),NULL,
            LocWizardDlgProc, (LPARAM)m_dwAPIVersion);

        if ( IDOK == iRes )
        {
            // now we need to re-initalize to pick up the new location
            m_locs.Initialize();

            // Now we need to figure out the ID of the location we just created
            CLocation * pLoc;
            m_locs.Reset();
            if ( S_OK == m_locs.Next( 1, &pLoc, NULL ) )
            {
                // Set this ID as the default location
                m_locs.SetCurrentLocationID(pLoc->GetLocationID());
            }

            // we've already made a commited change, so save the result
            m_locs.SaveToRegistry();
            result = NO_ERROR;
        }
        else
        {
            // If this was lineTranslateDialog and the user canceled the simple location
            // dialog then we have already warned them of what might happen.  If this is
            // a down level legacy call then we return an old error code
            if ( m_dwAPIVersion < TAPI_VERSION2_2 )
            {
                // return an old error code that legacy apps understand
                return LINEERR_OPERATIONFAILED;
            }
            else
            {
                // as of TAPI_VERSION2_2 we have a new error value just for this case:
                return LINEERR_USERCANCELLED;
            }
        }
    }

    // Initialize the header:
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hwndParent;
    psh.hInstance = GetUIInstance();
    psh.hIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(IDS_NAME);
    psh.nPages = (-1!=iTab)?3:1;
    psh.nStartPage = (-1!=iTab)?iTab:0;
    psh.pfnCallback = NULL;
    psh.phpage = ahpsp;


    // Now setup the Property Sheet Page
    apsp[0].dwSize = sizeof(apsp[0]);
    apsp[0].dwFlags = PSP_DEFAULT;
    apsp[0].hInstance = GetUIInstance();
    apsp[0].pszTemplate = MAKEINTRESOURCE(IDD_MAIN_DIALINGRULES);
    apsp[0].pfnDlgProc = CDialingRulesPropSheet::Dailing_DialogProc;
    apsp[0].lParam = (LPARAM)this;
    ahpsp[0] = CreatePropertySheetPage (&apsp[0]);

    if ( -1 != iTab )
    {
        apsp[1].dwSize = sizeof(apsp[1]);
        apsp[1].dwFlags = PSP_DEFAULT;
        apsp[1].hInstance = hInstModemUI;
        apsp[1].pszTemplate = MAKEINTRESOURCE(20011);
        apsp[1].pfnDlgProc = pfnModemDialogProc;
        apsp[1].lParam = (LPARAM)&md;
        ahpsp[1] = CreatePropertySheetPage (&apsp[1]);

        apsp[2].dwSize = sizeof(apsp[2]);
        apsp[2].dwFlags = PSP_DEFAULT;
        apsp[2].hInstance = GetUIInstance();
        apsp[2].pszTemplate = MAKEINTRESOURCE(IDD_MAIN_ADVANCED);
        apsp[2].pfnDlgProc = CDialingRulesPropSheet::Advanced_DialogProc;
        apsp[2].lParam = 0;
        ahpsp[2] = CreatePropertySheetPage (&apsp[2]);
    }

    if (-1 == PropertySheet( &psh ))
    {
        result = GetLastError ();
        LOG ((TL_ERROR, "PropertySheet failed, error 0x%x", result));
    }

    // now we're done with modemui, so release it.
    if(hInstModemUI)
        FreeLibrary(hInstModemUI);

    return result;
}

LONG CDialingRulesPropSheet::CheckForOtherInstances()
{
    TCHAR szCaption[MAX_INPUT];
    if ( !LoadString(GetUIInstance(), IDS_NAME, szCaption, 128) )
    {
        return LINEERR_OPERATIONFAILED;
    }

    m_hMutex = CreateMutex (NULL, FALSE, TEXT("tapi_dp_mutex"));
    if (!m_hMutex)
    {
        return LINEERR_OPERATIONFAILED;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        EnumWindows( SetToForegroundEnumProc, (LPARAM)szCaption );
        return LINEERR_INUSE;
    }
    return 0;
}

BOOL CALLBACK SetToForegroundEnumProc( HWND hwnd, LPARAM lParam )
{
    TCHAR szBuf[MAX_INPUT];

    GetWindowText (hwnd, szBuf, 128);

    if (!lstrcmpi (szBuf, (LPTSTR)lParam))
    {
        SetForegroundWindow (hwnd);
        return FALSE;
    }

    return TRUE;
}

extern "C" LONG WINAPI internalConfig( HWND hwndParent, PCWSTR pwsz, INT iTab, DWORD dwAPIVersion )
{
    CDialingRulesPropSheet drps(pwsz, dwAPIVersion);

    return drps.DoPropSheet(hwndParent, iTab);
}


// ********************************************************************
//
// Dialing Rules Property Page functions
//
// ********************************************************************



INT_PTR CALLBACK CDialingRulesPropSheet::Dailing_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CDialingRulesPropSheet* pthis = (CDialingRulesPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CDialingRulesPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis);
        return pthis->Dailing_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->Dailing_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );

    case WM_NOTIFY:
        return pthis->Dailing_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a101HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a101HelpIDs);
        break;
    }

    return 0;
}

int CALLBACK Dialing_ListSort(LPARAM lItem1, LPARAM lItem2, LPARAM lCol)
{
    if (!lItem1)
    {
        return -1;
    }
    if (!lItem2)
    {
        return 1;
    }

    CLocation * pLoc1 = (CLocation *)lItem1;
    CLocation * pLoc2 = (CLocation *)lItem2;

    if ( 1 == lCol)
    {
        // sort based on column 1, the area code
        int iAC1 = StrToIntW(pLoc1->GetAreaCode());
        int iAC2 = StrToIntW(pLoc2->GetAreaCode());

        if (iAC1!=iAC2)
            return iAC1-iAC2;

        // fall through if the area codes are identical
    }

    // sort based on column 0, the location name
    return StrCmpIW(pLoc1->GetName(), pLoc2->GetName());
}

BOOL CDialingRulesPropSheet::Dailing_OnInitDialog(HWND hDlg)
{
    // Setup the header for the list control
    RECT rc;
    TCHAR szText[MAX_INPUT];
    HWND hwndList = GetDlgItem(hDlg, IDC_LIST);

    GetClientRect(hwndList, &rc);

    int cxList = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.pszText = szText;

    struct {
        int iStrID;
        int cxPercent;
    } aData[] = {
        { IDS_LOCATION, 70 },
        { IDS_AREACODE, 30 },
    };

    for (int i=0; i<ARRAYSIZE(aData); i++)
    {
        LoadString(GetUIInstance(), aData[i].iStrID, szText, ARRAYSIZE(szText));
        lvc.iSubItem = i;
        lvc.cx = MulDiv(cxList, aData[i].cxPercent, 100);
        ListView_InsertColumn( hwndList, i, &lvc );
    }

    ListView_SetExtendedListViewStyleEx(hwndList,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    HIMAGELIST himl = ImageList_Create(16, 16, ILC_COLOR|ILC_MASK, 2, 2);
    HBITMAP hBmp = CreateMappedBitmap(GetUIInstance(), IDB_BUTTONS, 0, NULL, 0);
    if (NULL != hBmp)
    {
        ImageList_AddMasked( himl, hBmp, CLR_DEFAULT);
        DeleteObject( hBmp );
    }
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL);

    m_locs.Reset();

    CLocation * pLoc;
    DWORD dwCurLocID = m_locs.GetCurrentLocationID();

    while ( S_OK == m_locs.Next( 1, &pLoc, NULL ) )
    {
        AddLocationToList( hwndList, pLoc, FALSE );

        if ( pLoc->GetLocationID() == dwCurLocID )
        {
            m_dwDefaultCountryID = pLoc->GetCountryID();
        }
    }

    int iItems = m_locs.GetNumLocations();

    UpdateControlStates(hDlg);

    ListView_SortItems( hwndList, Dialing_ListSort, m_iSortCol);

    SetCheck(hwndList, m_pLocSelected, TRUE);

    if (!m_pwszAddress)
    {
        ShowWindow(GetDlgItem(hDlg,IDC_PHONENUMBERTEXT), SW_HIDE);
    }
    else if (m_pLocSelected)
    {
        UpdateSampleString(GetDlgItem(hDlg, IDC_PHONENUMBERSAMPLE), m_pLocSelected, m_pwszAddress, NULL);
    }

    // Select the default item from the location list:
    SetFocus(hwndList);

    return 0;
}

void CDialingRulesPropSheet::UpdateControlStates(HWND hDlg)
{
    int iItems = m_locs.GetNumLocations();

    // Set the button states
    EnableWindow( GetDlgItem(hDlg, IDC_EDIT),   0!=m_pLocSelected );
    EnableWindow( GetDlgItem(hDlg, IDC_SETDEFAULT), 0!=m_pLocSelected );

    // if nothing is selected or there is only one item then you cannot
    // delete that item
    EnableWindow( GetDlgItem(hDlg, IDC_DELETE), ((m_pLocSelected)&&(1<iItems)) );
}

void CDialingRulesPropSheet::AddLocationToList(HWND hwndList, CLocation *pLoc, BOOL bSelected)
{
    TCHAR szText[MAX_INPUT];
    SHUnicodeToTChar( pLoc->GetName(), szText, ARRAYSIZE(szText) );

    LVITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.pszText = szText;
    lvi.iImage = 0;
    lvi.lParam = (LONG_PTR)pLoc;

    bSelected = bSelected || (pLoc->GetLocationID() == m_locs.GetCurrentLocationID());
    if ( bSelected )
    {
        // Set m_pLocSelected to the current location.  It will be selected later.
        lvi.mask |= LVIF_STATE;
        lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        lvi.iImage = 1;
        SetCheck(hwndList, m_pLocSelected, FALSE);
        m_pLocSelected = pLoc;
    }

    int iItem = ListView_InsertItem( hwndList, &lvi );

    SHUnicodeToTChar( pLoc->GetAreaCode(), szText, ARRAYSIZE(szText) );
    ListView_SetItemText( hwndList, iItem, 1, szText );
}

void CDialingRulesPropSheet::UpdateLocationInList(HWND hwndList, CLocation *pLocOld, CLocation *pLocNew)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pLocOld;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem && pLocNew)
    {
        TCHAR szText[MAX_INPUT];
        SHUnicodeToTChar( pLocNew->GetName(), szText, ARRAYSIZE(szText) );

        LVITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.pszText = szText;
        lvi.lParam = (LONG_PTR)pLocNew;

        ListView_SetItem( hwndList, &lvi );

        SHUnicodeToTChar( pLocNew->GetAreaCode(), szText, ARRAYSIZE(szText) );
        ListView_SetItemText( hwndList, iItem, 1, szText );
    }
    else
    {
        ListView_DeleteItem(hwndList, iItem);
    }
}

BOOL CDialingRulesPropSheet::Dailing_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_NEW:
    case IDC_EDIT:
        LaunchLocationPropSheet(IDC_NEW == wID, hwndParent);
        break;

    case IDC_DELETE:
        DeleteSelectedLocation(GetDlgItem(hwndParent,IDC_LIST));
        break;

    default:
        return 0;
    }
    return 1;
}

void CDialingRulesPropSheet::LaunchLocationPropSheet( BOOL bNew, HWND hwndParent )
{
    CLocation * pLoc = new CLocation;

	if (NULL == pLoc)
	{
		return;
	}
 
    if ( bNew )
    {
        WCHAR wszNewLoc[MAX_INPUT];

        // We offer the default name "My Location" only if there are no locations alread defined.
        if ( m_locs.GetNumLocations() > 0 )
        {
            wszNewLoc[0] = TEXT('\0');
        }
        else
        {
            TCHAR szNewLoc[MAX_INPUT];

            LoadString(GetUIInstance(), IDS_MYLOCATION, szNewLoc, ARRAYSIZE(szNewLoc));
            SHTCharToUnicode(szNewLoc, wszNewLoc, ARRAYSIZE(wszNewLoc));
        }
        pLoc->Initialize(wszNewLoc,L"",L"",L"",L"",L"",L"",0,m_dwDefaultCountryID,0,LOCATION_USETONEDIALING);
    }
    else if (m_pLocSelected)
    {
        CAreaCodeRule * pRule;

        pLoc->Initialize(
                m_pLocSelected->GetName(),
                m_pLocSelected->GetAreaCode(),
                m_pLocSelected->GetLongDistanceCarrierCode(),
                m_pLocSelected->GetInternationalCarrierCode(),
                m_pLocSelected->GetLongDistanceAccessCode(),
                m_pLocSelected->GetLocalAccessCode(),
                m_pLocSelected->GetDisableCallWaitingCode(),
                m_pLocSelected->GetLocationID(),
                m_pLocSelected->GetCountryID(),
                m_pLocSelected->GetPreferredCardID(),
                0,
                m_pLocSelected->FromRegistry() );
        pLoc->UseCallingCard(m_pLocSelected->HasCallingCard());
        pLoc->UseCallWaiting(m_pLocSelected->HasCallWaiting());
        pLoc->UseToneDialing(m_pLocSelected->HasToneDialing());

        m_pLocSelected->ResetRules();
        while ( S_OK == m_pLocSelected->NextRule(1,&pRule,NULL) )
        {
            CAreaCodeRule * pNewRule = new CAreaCodeRule;

			if (NULL == pNewRule)
			{
				// No more memory, so get out of the loop.
				break;
			}
            pNewRule->Initialize(
                    pRule->GetAreaCode(),
                    pRule->GetNumberToDial(),
                    0,
                    pRule->GetPrefixList(),
                    pRule->GetPrefixListSize() );
            pNewRule->SetAppliesToAllPrefixes(pRule->HasAppliesToAllPrefixes());
            pNewRule->SetDialAreaCode(pRule->HasDialAreaCode());
            pNewRule->SetDialNumber(pRule->HasDialNumber());

            pLoc->AddRule(pNewRule);
            pLoc->Changed();
        }
    }
    else
    {
        // Out of memory, failed to create pLoc
        delete pLoc;
        return;
    }

    CLocationPropSheet nlps( bNew, pLoc, &m_locs, m_pwszAddress );
    int iRes = nlps.DoPropSheet(hwndParent);

    if ( PSN_APPLY == iRes )
    {
        HWND hwndList = GetDlgItem(hwndParent,IDC_LIST);
        if (bNew)
        {
            // we don't ask for an ID until we really need it to avoid hitting tapisrv
            // any more than we have to.
            pLoc->NewID();
            m_locs.Add(pLoc);
            AddLocationToList(hwndList, pLoc, TRUE);
            UpdateControlStates(hwndParent);
        }
        else
        {
            m_locs.Replace(m_pLocSelected, pLoc);
            UpdateLocationInList(hwndList, m_pLocSelected, pLoc);
            m_pLocSelected = pLoc;
        }
        ListView_SortItems( hwndList, Dialing_ListSort, m_iSortCol);

        if ( m_pwszAddress )
        {
            UpdateSampleString(GetDlgItem(hwndParent, IDC_PHONENUMBERSAMPLE), m_pLocSelected, m_pwszAddress, NULL);
        }
        SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
    }
    else
    {
        delete pLoc;
    }
}

void CDialingRulesPropSheet::DeleteSelectedLocation(HWND hwndList)
{
    // First we confirm the delete with the user
    TCHAR szText[1024];
    TCHAR szTitle[128];
    int result;
    HWND hwndParent = GetParent(hwndList);
    
    LoadString(GetUIInstance(), IDS_DELETELOCTEXT, szText, ARRAYSIZE(szText));
    LoadString(GetUIInstance(), IDS_CONFIRMDELETE, szTitle, ARRAYSIZE(szTitle));

    result = SHMessageBoxCheck( hwndParent, szText, szTitle, MB_YESNO, IDYES, TEXT("TAPIDeleteLocation") );
    if ( IDYES == result )
    {
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = (LPARAM)m_pLocSelected;
        int iItem = ListView_FindItem(hwndList,-1,&lvfi);
        if ( -1 != iItem )
        {
            m_locs.Remove(m_pLocSelected);
            iItem = DeleteItemAndSelectPrevious( hwndParent, IDC_LIST, iItem, IDC_DELETE, IDC_ADD );

            if ( -1 != iItem )
            {
                LVITEM lvi;
                lvi.iItem = iItem;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                // Store the currently selected item
                m_pLocSelected = (CLocation *)lvi.lParam;
            }
            else
            {
                m_pLocSelected = NULL;
            }

            UpdateControlStates(hwndParent);
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
        }
        else
        {
            // It's really bad if this ever happens (which it shouldn't).  This means our
            // data is in an unknown state and we might do anything (even destroy data).
            LOG((TL_ERROR, "DeleteSelectedLocation: Location Not Found!"));
        }
    }
}

void CDialingRulesPropSheet::SetCheck(HWND hwndList, CLocation * pLoc, int iImage)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pLoc;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        LVITEM lvi;
        lvi.mask = LVIF_IMAGE;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.iImage = iImage;

        ListView_SetItem( hwndList, &lvi );
        ListView_EnsureVisible (hwndList, iItem, TRUE);
        ListView_Update( hwndList, iItem ); // need the font to be drawn non-bold
    }
}


BOOL CDialingRulesPropSheet::Dailing_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    switch (pnmhdr->idFrom)
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( (pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED) )
            {
                LVITEM lvi;
                lvi.iItem = pnmlv->iItem;
                lvi.iSubItem = pnmlv->iSubItem;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CLocation * pLoc = (CLocation *)lvi.lParam;

                // pLoc can be NULL if this is our special "empty list item"
                if ( pLoc )
                {
                    m_dwDefaultCountryID = pLoc->GetCountryID();
                    m_locs.SetCurrentLocationID(pLoc->GetLocationID());

                    // clear the previous check
                    SetCheck( pnmhdr->hwndFrom, m_pLocSelected, FALSE );

                    // Store the currently selected item
                    m_pLocSelected = pLoc;

                    // Set the new check
                    SetCheck( pnmhdr->hwndFrom, m_pLocSelected, TRUE );

                    if (m_pwszAddress)
                    {
                        UpdateSampleString(GetDlgItem(hwndDlg, IDC_PHONENUMBERSAMPLE), m_pLocSelected, m_pwszAddress, NULL);
                    }
                }

                UpdateControlStates(hwndDlg);
                SendMessage(GetParent(hwndDlg),PSM_CHANGED,(WPARAM)hwndDlg,0);
            }
            break;

        case NM_DBLCLK:
            if ( !m_pLocSelected )
            {
                // Do new case
                LaunchLocationPropSheet(TRUE,hwndDlg);
            }
            else
            {
                // Do edit case
                LaunchLocationPropSheet(FALSE,hwndDlg);
            }
            break;

        case NM_CUSTOMDRAW:
            #define lplvcd ((LPNMLVCUSTOMDRAW)pnmhdr)

            if(lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT)
            {
                // Request prepaint notifications for each item.
                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NOTIFYITEMDRAW);
                return CDRF_NOTIFYITEMDRAW;
            }

            if(lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
            {
                LVITEM lvi;
                lvi.iItem = (int)lplvcd->nmcd.dwItemSpec;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CLocation * pLoc = (CLocation *)lvi.lParam;

                // pLoc can be NULL if this is our special item
                if(pLoc && pLoc->GetLocationID() == m_locs.GetCurrentLocationID())
                {
                    if (!g_hfontBold)
                    {
                        // we do lazy creation of the font because we need to match whatever
                        // font the listview control is using and we can't tell which font
                        // that is until we actually have the HDC for the listbox.
                        LOGFONT lf;
                        HFONT hfont = (HFONT)GetCurrentObject(lplvcd->nmcd.hdc, OBJ_FONT);
                        GetObject(hfont, sizeof(LOGFONT), &lf);
                        lf.lfWeight += FW_BOLD-FW_NORMAL;
                        g_hfontBold = CreateFontIndirect(&lf);
                    }
                    if (g_hfontBold)
                    {
                        SelectObject(lplvcd->nmcd.hdc, g_hfontBold);
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
                        return CDRF_NEWFONT;
                    }
                }

                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_DODEFAULT);
                return CDRF_DODEFAULT;
            }
            return 0;
            #undef lplvcd

        case LVN_COLUMNCLICK:
            m_iSortCol = pnmlv->iSubItem;
            ListView_SortItems( pnmhdr->hwndFrom, Dialing_ListSort, m_iSortCol);
            break;

        case LVN_GETEMPTYTEXT:
            #define pnmlvi (((NMLVDISPINFO *)pnmhdr)->item)
            LoadString(GetUIInstance(), IDS_CLICKNEW, pnmlvi.pszText, pnmlvi.cchTextMax);
            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,TRUE);
            #undef pnmlvi
            break;

        default:
            break;
        }
        #undef pnmlv
        break;

    default:
        switch (pnmhdr->code)
        {
        case PSN_APPLY:
            // TODO: Ensure that a location is selected in the list
            m_locs.SaveToRegistry();
            break;
        }
        return 0;
    }
    return 1;
}


// ********************************************************************
//
// Advanced Property Page functions (formerly Telephony Drivers page)
//
// ********************************************************************



#include "drv.h"


INT_PTR CALLBACK CDialingRulesPropSheet::Advanced_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CDialingRulesPropSheet* pthis = (CDialingRulesPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CDialingRulesPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis);
        return pthis->Advanced_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->Advanced_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a113HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a113HelpIDs);
        break;
    }

    return 0;
}

BOOL CDialingRulesPropSheet::Advanced_OnInitDialog(HWND hDlg)
{
    UINT  uUpdated;

    if ( !FillDriverList(GetDlgItem(hDlg, IDC_LIST)) )
    {
        EndDialog(hDlg, IDCANCEL);
        return FALSE;
    }

    // DWLP_USER is used to store state information about wheter we have disabled
    // the property sheet's cancel button.  For starters we have not done this.
    SetWindowLong( hDlg, DWLP_USER, FALSE );

    UpdateDriverDlgButtons (hDlg);

    return TRUE;
}

BOOL CDialingRulesPropSheet::Advanced_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch (wID)
    {
    case IDC_ADD:
        // add a new driver
        if ( IDOK == DialogBoxParam(
                GetUIInstance(),
                MAKEINTRESOURCE( IDD_ADD_DRIVER ),
                hwndParent,
                AddDriver_DialogProc,
                0 ) )
        {
            FillDriverList(GetDlgItem(hwndParent, IDC_LIST));

            if (SetWindowLong(hwndParent, DWLP_USER, TRUE) == FALSE)
            {
                // We have performed a non-cancelable action, update the property sheet to reflect this
                PropSheet_CancelToClose( GetParent( hwndParent ) );
            }

            UpdateDriverDlgButtons(hwndParent);

        }  // end if

        break;

    case IDC_LIST:
        if ( LBN_SELCHANGE == wNotifyCode )
        {
            UpdateDriverDlgButtons(hwndParent);
            break;
        }
        else if ( LBN_DBLCLK != wNotifyCode || !IsWindowEnabled( GetDlgItem( hwndParent, IDC_EDIT ) ))
        {
            // we only fall through if the user double clicked on an editable item
            break;
        }

        // fall through

    case IDC_EDIT:
        if ( SetupDriver(hwndParent, GetDlgItem(hwndParent, IDC_LIST)) )
        {
            if ( SetWindowLong( hwndParent, DWLP_USER, TRUE ) == FALSE ) // modified
            {
                PropSheet_CancelToClose( GetParent(hwndParent) );
            }
        }

        break;

    case IDC_REMOVE:
        {
            TCHAR szCaption[MAX_INPUT];
            TCHAR szMessage[512];

            LoadString(GetUIInstance(), IDS_REMOVEPROVIDER, szCaption, ARRAYSIZE(szCaption));
            LoadString(GetUIInstance(), IDS_CONFIRM_DRIVER_REMOVE, szMessage, ARRAYSIZE(szMessage));
            MessageBeep( MB_ICONASTERISK );
            if ( IDYES == MessageBox(hwndParent, szMessage, szCaption, MB_YESNO | MB_DEFBUTTON2) )
            {
                if (SetWindowLong (hwndParent, DWLP_USER, TRUE) == FALSE) // modified
                {
                    PropSheet_CancelToClose( GetParent( hwndParent ) );
                }

                RemoveSelectedDriver( hwndParent, GetDlgItem(hwndParent, IDC_LIST) );

                UpdateDriverDlgButtons (hwndParent);
            }
        }
        break;
    }

    return 1;
}

HINSTANCE GetUIInstance()
{
    if ( NULL == g_hInstUI )
    {
        g_hInstUI = LoadLibrary(TEXT("tapiui.dll"));
        // g_hInstUI = GetModuleHandle(TEXT("tapi32.dll"));
    }

    return g_hInstUI;
}

LONG EnsureOneLocation (HWND hwnd)
{
    CLocations          locs;

    locs.Initialize();

    // If there are no locations, launch the simple location dialog
    if ( 0 == locs.GetNumLocations() )
    {
        // if we are in lineTranslateDialog mode, then we display the simple
        int iRes;
        iRes = (int)DialogBoxParam(GetUIInstance(), MAKEINTRESOURCE(IDD_SIMPLELOCATION),hwnd,
            LocWizardDlgProc, (LPARAM)TAPI_VERSION2_2);

        if ( IDOK == iRes )
        {
            // now we need to re-initalize to pick up the new location
            locs.Initialize();

            // Now we need to figure out the ID of the location we just created
            CLocation * pLoc;
            locs.Reset();
            if ( S_OK == locs.Next( 1, &pLoc, NULL ) )
            {
                // Set this ID as the default location
                locs.SetCurrentLocationID(pLoc->GetLocationID());
            }

            // we've already made a commited change, so save the result
            locs.SaveToRegistry();
        }
        else
        {
            return LINEERR_USERCANCELLED;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplinputlimiter.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplinputlimiter.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

#include "cplPreComp.h"

class CInputLimiter
{
public:
    BOOL SubclassWindow(HWND hwnd, DWORD dwFlags);
    static VOID HideToolTip();

protected:
    BOOL OnChar( HWND hwnd, TCHAR wParam );
    LRESULT OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam);
    BOOL IsValidChar(TCHAR ch, BOOL bPaste);
    BOOL UnsubclassWindow(HWND hwnd);
    void ShowToolTip(HWND hwnd);
    void CreateToolTipWindow(HWND hwnd);
    static LRESULT CALLBACK SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ListenerProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);

    DWORD           m_dwFlags;          // determines which characters are allowed
    WNDPROC         m_pfnSuperProc;     // the super class proc
    static HWND     s_hwndToolTip;      // shared by all instances
    static UINT_PTR s_uTimerID;         // shared timer
    static TCHAR    s_szTipText[512];   // the text to be shown in the tooltip
};

HWND     CInputLimiter::s_hwndToolTip = NULL;
UINT_PTR CInputLimiter::s_uTimerID = 0;
TCHAR    CInputLimiter::s_szTipText[512] = {0};

// Limiting the input on a combo box is a special case because you first
// have to find the edit box and then LimitInput on that.
BOOL CALLBACK FindTheEditBox( HWND hwnd, LPARAM lParam )
{
    // The combo box only has one child, subclass it
    LimitInput(hwnd,(DWORD)lParam);
    return FALSE;
}

BOOL LimitCBInput(HWND hwnd, DWORD dwFlags)
{
    return EnumChildWindows(hwnd, FindTheEditBox, dwFlags);
}

BOOL LimitInput(HWND hwnd, DWORD dwFlags)
{
    CInputLimiter * pil = new CInputLimiter;

    if (!pil)
    {
        return FALSE;
    }

    BOOL bResult = pil->SubclassWindow(hwnd, dwFlags);

    if (!bResult)
    {
        delete pil;
    }

    return bResult;
}

void HideToolTip()
{
    CInputLimiter::HideToolTip();
}

BOOL CInputLimiter::SubclassWindow(HWND hwnd, DWORD dwFlags)
{
    if ( !IsWindow(hwnd) )
        return FALSE;

    m_dwFlags = dwFlags;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);

    m_pfnSuperProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)CInputLimiter::SubclassProc);

    return TRUE;
}

BOOL CInputLimiter::UnsubclassWindow(HWND hwnd)
{
    SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperProc);

    m_dwFlags = 0;

    delete this;

    return TRUE;
}

LRESULT CALLBACK CInputLimiter::SubclassProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CInputLimiter * pthis = (CInputLimiter*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // cache pthis->m_pfnSuperProc because we always need in and
    // pthis might be deleted before we get around to using it
    WNDPROC pfn = pthis->m_pfnSuperProc;

    switch (uMsg)
    {
    case WM_CHAR:
        if (!pthis->OnChar(hwnd, (TCHAR)wParam))
        {
            return 0;
        }
        break;

    case WM_PASTE:
        return pthis->OnPaste(hwnd, wParam, lParam);

    case WM_KILLFOCUS:
        HideToolTip();
        break;

    case WM_DESTROY:
        pthis->UnsubclassWindow(hwnd);
        break;

    default:
        break;
    }

    return CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
}

BOOL CInputLimiter::OnChar( HWND hwnd, TCHAR ch )
{
    // if the char is a good one return TRUE, this will pass the char on to the
    // default window proc.  For a bad character do a beep and then display the
    // ballon tooltip pointing at the control.

    if ( IsValidChar(ch, FALSE) )
        return TRUE;

    // if we get here then an invalid character was entered
    MessageBeep(MB_OK);

    ShowToolTip(hwnd);

    return FALSE;
}

BOOL CInputLimiter::IsValidChar(TCHAR ch, BOOL bPaste)
{
    // certain characters get converted into WM_CHAR messages even though we don't want
    // to consider them.  We check for these characters first.  Currently, this list includes:
    //  backspace
    //  control characters, such as ctrl-x and ctrl-v
    if ( ch == TEXT('\b') )
        return TRUE;

    if ( !bPaste && (0x8000 & GetKeyState(VK_CONTROL)) )
        return TRUE;

    if ( m_dwFlags & LIF_ALLOWALPHA )
    {
        if ( (ch >= TEXT('a') && ch <= TEXT('z')) || (ch >= TEXT('A') && ch <= TEXT('Z')) )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWNUMBER )
    {
        if ( ch >= TEXT('0') && ch <= TEXT('9') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWDASH )
    {
        if ( ch == TEXT('-') || ch == TEXT('(') || ch == TEXT(')'))
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWPOUND )
    {
        if ( ch == TEXT('#') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWSTAR )
    {
        if ( ch == TEXT('*') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWSPACE )
    {
        if ( ch == TEXT(' ') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWCOMMA )
    {
        if ( ch == TEXT(',') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWPLUS )
    {
        if ( ch == TEXT('+') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWBANG )
    {
        if ( ch == TEXT('!') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWATOD )
    {
        if ( (ch >= TEXT('a') && ch <= TEXT('d')) || (ch >= TEXT('A') && ch <= TEXT('D')) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

void CInputLimiter::ShowToolTip(HWND hwnd)
{
    if ( !s_hwndToolTip )
    {
        CreateToolTipWindow(hwnd);
    }

    // Set the tooltip display point
    RECT rc;
    GetWindowRect(hwnd, &rc);
    SendMessage(s_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG((rc.left+rc.right)/2,rc.bottom));

    TOOLINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.hwnd = NULL;
    ti.uId = 1;

    // Set the tooltip text
    UINT iStrID;
    if ( m_dwFlags == LIF_ALLOWNUMBER )
    {
        // use the "0-9" text
        iStrID = IDS_DIGITSONLY;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWSPACE) )
    {
        // use the "0-9, ' '" text
        iStrID = IDS_DIGITLIST;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWSPACE|LIF_ALLOWCOMMA) )
    {
        // use the "0-9, ' ', ','" text
        iStrID = IDS_MULTIDIGITLIST;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWSTAR|LIF_ALLOWPOUND|LIF_ALLOWCOMMA) )
    {
        // use the "0-9, #, *, ','" text
        iStrID = IDS_PHONEPADCHAR;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA) )
    {
        // use the "0-9, #, *, ' ', ','" text
        iStrID = IDS_PHONENUMBERCHAR;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA|LIF_ALLOWPLUS|LIF_ALLOWBANG|LIF_ALLOWATOD) )
    {
        // use the "0-9, A-D, a-d, #, *, +, !, ' ', ',' " text
        iStrID = IDS_PHONENUMBERCHAREXT;
    }
    else
    {
        // We should never reach this point, but if we do then we display a generic invalid character dialog
        iStrID = IDS_ALLPHONECHARS;
    }
    LoadString(GetUIInstance(),iStrID,s_szTipText,ARRAYSIZE(s_szTipText));
    ti.lpszText = s_szTipText;
    SendMessage(s_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

    // Show the tooltip
    SendMessage(s_hwndToolTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

    // Set a timer to hide the tooltip
    if ( s_uTimerID )
    {
        KillTimer(NULL,s_uTimerID);
    }
    s_uTimerID = SetTimer(NULL, 0, 10000, (TIMERPROC)CInputLimiter::TimerProc);
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
void CInputLimiter::CreateToolTipWindow(HWND hwnd)
{
    HWND hwndParent;

    do
    {
        hwndParent = hwnd;
        hwnd = GetParent(hwnd);
    } while (hwnd);

    s_hwndToolTip = CreateWindow(TOOLTIPS_CLASS, NULL,
                                 WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                 CW_USEDEFAULT, CW_USEDEFAULT,
                                 CW_USEDEFAULT, CW_USEDEFAULT,
                                 hwndParent, NULL, GetUIInstance(),
                                 NULL);

    if (s_hwndToolTip)
    {
        SetWindowPos(s_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        TOOLINFO ti = {0};
        RECT     rc = {2,2,2,2};

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRACK | TTF_TRANSPARENT;
        ti.hwnd = NULL;
        ti.uId = 1;
        ti.lpszText = s_szTipText;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(s_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(s_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(s_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, 500);
        SendMessage(s_hwndToolTip, TTM_SETMARGIN, 0, (LPARAM)&rc);
    }
}

VOID CALLBACK CInputLimiter::TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    // When the timer fires we hide the tooltip window
    HideToolTip();
}

void CInputLimiter::HideToolTip()
{
    if ( s_uTimerID )
    {
        KillTimer(NULL,s_uTimerID);
        s_uTimerID = 0;
    }
    if ( s_hwndToolTip )
    {
        PostMessage(s_hwndToolTip, TTM_TRACKACTIVATE, FALSE, 0);
    }
}

LRESULT CInputLimiter::OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // There are hundred of lines of code in user to successfully handle a paste into an edit control.
    // We need to leverage all that code while still disallowing invalid input to result from the paste.
    // As a result, what we need to do is to get the clip board data, validate that data, place the
    // valid data back onto the clipboard, call the default window proc to let user do it's thing, and
    // then restore the clipboard to it's original format.
    if ( OpenClipboard(hwnd) )
    {
        HANDLE hdata;
        UINT iFormat;
        DWORD cchBad = 0;           // count of the number of bad characters

        // REVIEW: Should this be based on the compile type or the window type?
        // Compile time check for the correct clipboard format to use:
        if ( sizeof(WCHAR) == sizeof(TCHAR) )
        {
            iFormat = CF_UNICODETEXT;
        }
        else
        {
            iFormat = CF_TEXT;
        }

        hdata = GetClipboardData(iFormat);

        if ( hdata )
        {
            LPTSTR pszData;
            pszData = (LPTSTR)GlobalLock(hdata);
            if ( pszData )
            {
                DWORD dwSize;
                HANDLE hClone;
                HANDLE hNew;

                // we need to copy the original data because the clipboard owns the hdata
                // pointer.  That data will be invalid after we call SetClipboardData.
                // We start by calculating the size of the data:
                dwSize = (DWORD)GlobalSize(hdata)+sizeof(TCHAR);

                // Use the prefered GlobalAlloc for clipboard data
                hClone = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, dwSize);
                hNew = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, dwSize);
                if ( hClone && hNew )
                {
                    LPTSTR pszClone;
                    LPTSTR pszNew;

                    pszClone = (LPTSTR)GlobalLock(hClone);
                    pszNew = (LPTSTR)GlobalLock(hNew);
                    if ( pszClone && pszNew )
                    {
                        int iNew = 0;

                        // copy the original data as-is
                        memcpy((LPVOID)pszClone, (LPVOID)pszData, (size_t)dwSize - sizeof(TCHAR));
                        // ensure that it's NULL terminated
                        pszClone[ (dwSize/sizeof(TCHAR))-1 ] = NULL;

                        for ( LPTSTR psz = pszClone; *psz; psz++ )
                        {
                            if ( IsValidChar(*psz, TRUE) )
                            {
                                pszNew[iNew++] = *psz;
                            }
                            else
                            {
                                cchBad++;
                            }
                        }
                        pszNew[iNew] = NULL;

                        // If there are any characters in the paste buffer then we paste the validated string
                        if ( *pszNew )
                        {
                            // we always set the new string.  Worst case it's identical to the old string
                            GlobalUnlock(hNew);
                            pszNew = NULL;
                            SetClipboardData(iFormat, hNew);
                            hNew = NULL;

                            // call the super proc to do the paste
                            CallWindowProc(m_pfnSuperProc, hwnd, WM_PASTE, wParam, lParam);

                            // The above call will have closed the clipboard on us.  We try to re-open it.
                            // If this fails it's no big deal, that simply means the SetClipboardData
                            // call below will fail which is good if somebody else managed to open the
                            // clipboard in the mean time.
                            OpenClipboard(hwnd);

                            // and then we always set it back to the original value.
                            GlobalUnlock(hClone);
                            pszClone = NULL;
                            SetClipboardData(iFormat, hClone);
                            hClone = NULL;
                        }
                    }

                    if ( pszClone )
                    {
                        GlobalUnlock(hClone);
                    }

                    if ( pszNew )
                    {
                        GlobalUnlock(hNew);
                    }
                }

                if ( hClone )
                {
                    GlobalFree( hClone );
                }

                if ( hNew )
                {
                    GlobalFree( hNew );
                }

                // at this point we are done with hdata so unlock it
                GlobalUnlock(hdata);
            }
        }
        CloseClipboard();

        if ( cchBad )
        {
            // Show the error balloon
            MessageBeep(MB_OK);

            ShowToolTip(hwnd);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplsimpledialogs.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplsimpledialogs.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

#include "cplPreComp.h"
#include "cplSimpleDialogs.h"

// ****************************************************
//
// CEditDialog
//
// ****************************************************

CEditDialog::CEditDialog()
{
    m_psz = NULL;
}

CEditDialog::~CEditDialog()
{
    if ( m_psz )
    {
        delete m_psz;
    }
}

INT_PTR CEditDialog::DoModal(HWND hwndParent, int iTitle, int iText, int iDesc, DWORD dwFlags)
{
    m_iTitle = iTitle;
    m_iText = iText;
    m_iDesc = iDesc;
    m_dwFlags = dwFlags;

    return DialogBoxParam(GetUIInstance(),
                          MAKEINTRESOURCE(IDD_EDITDIALOG),
                          hwndParent,
                          CEditDialog::DialogProc,
                          (LPARAM)this);
}

LPTSTR CEditDialog::GetString()
{
    return m_psz;
}

INT_PTR CALLBACK CEditDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEditDialog * ped = (CEditDialog *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ped = (CEditDialog *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
        return ped->OnInitDialog(hwnd);

    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDOK:
            ped->OnOK(hwnd);
            // fall through

        case IDCANCEL:
            HideToolTip();
            EndDialog(hwnd, LOWORD(wParam));
            break;
        }
        break;
   
#define aIDs ((ped->m_iTitle == IDS_SPECIFYDIGITS)?a117HelpIDs:a116HelpIDs)
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) aIDs);
        break;
#undef aIDs
    }

    return 0;
}

BOOL CEditDialog::OnInitDialog(HWND hwnd)
{
    TCHAR szText[512];

    LoadString(GetUIInstance(), m_iTitle, szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);

    LoadString(GetUIInstance(), m_iText, szText, ARRAYSIZE(szText));
    SetWindowText(GetDlgItem(hwnd,IDC_TEXT), szText);

    LoadString(GetUIInstance(), m_iDesc, szText, ARRAYSIZE(szText));
    SetWindowText(GetDlgItem(hwnd,IDC_DESCRIPTIONTEXT), szText);

    HWND hwndEdit = GetDlgItem(hwnd,IDC_EDIT);
    SendMessage(hwndEdit, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    SetFocus(hwndEdit);
    LimitInput(hwndEdit,m_dwFlags);

    return 0;
}

void CEditDialog::OnOK(HWND hwnd)
{
    DWORD dwStart;
    DWORD dwEnd;

    HWND hwndEdit = GetDlgItem(hwnd,IDC_EDIT);
    SendMessage(hwndEdit,EM_SETSEL,0,-1);
    SendMessage(hwndEdit,EM_GETSEL,(WPARAM)&dwStart,(LPARAM)&dwEnd);

    dwEnd++;                                // add room for a NULL terminator
    m_psz = new TCHAR[dwEnd];               // allocate the buffer
	if (NULL != m_psz)
	{
		GetWindowText(hwndEdit,m_psz,dwEnd);    // and read in the string
	}
}

// ****************************************************
//
// CWaitForDialog
//
// ****************************************************

CWaitForDialog::CWaitForDialog()
{
    m_iRes = -1;
}

CWaitForDialog::~CWaitForDialog()
{
}

INT_PTR CWaitForDialog::DoModal(HWND hwndParent)
{
    return DialogBoxParam(GetUIInstance(),
                          MAKEINTRESOURCE(IDD_WAITFORDIALOG),
                          hwndParent,
                          CWaitForDialog::DialogProc,
                          (LPARAM)this);
}

int CWaitForDialog::GetWaitType()
{
    return m_iRes;
}

INT_PTR CALLBACK CWaitForDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWaitForDialog * pwd = (CWaitForDialog *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pwd = (CWaitForDialog *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
        return pwd->OnInitDialog(hwnd);

    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_WAITFORDIALTONE:
        case IDC_WAITFORVOICE:
            EnableWindow(GetDlgItem(hwnd, IDC_TIME), FALSE);
            break;

        case IDC_WAITFORTIME:
            EnableWindow(GetDlgItem(hwnd, IDC_TIME), TRUE);
            break;

        case IDOK:
            pwd->OnOK(hwnd);
            // fall through

        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            break;
        }
        break;
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a111HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a111HelpIDs);
        break;
    }

    return 0;
}

BOOL CWaitForDialog::OnInitDialog(HWND hwndDlg)
{
    HWND hwnd;

    SendMessage(GetDlgItem(hwndDlg,IDC_WAITFORDIALTONE),BM_SETCHECK,BST_CHECKED,0);

    hwnd = GetDlgItem(hwndDlg, IDC_TIME);
    SetDlgItemInt(hwndDlg, IDC_TIME, 2, FALSE);
    SendMessage(hwnd, EM_SETLIMITTEXT, 2, 0);
    EnableWindow(hwnd, FALSE);
    LimitInput(hwnd, LIF_ALLOWNUMBER);

    hwnd = GetDlgItem(hwndDlg, IDC_TIMESPIN);
    SendMessage(hwnd, UDM_SETRANGE32, 2, 98);
    SendMessage(hwnd, UDM_SETPOS, 0, MAKELONG(2, 0) );
    UDACCEL accel;
    accel.nSec = 0;
    accel.nInc = 2;
    SendMessage(hwnd, UDM_SETACCEL, 1, (LPARAM)&accel );

    return 0;
}

void CWaitForDialog::OnOK(HWND hwnd)
{
    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_WAITFORDIALTONE),BM_GETCHECK,0,0) )
    {
        m_iRes = 0;
    }
    else if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_WAITFORVOICE),BM_GETCHECK,0,0) )
    {
        m_iRes = 1;
    }
    else
    {
        m_iRes = GetDlgItemInt(hwnd, IDC_TIME, NULL, FALSE);
        if ( m_iRes < 2 )
        {
            m_iRes = 2;
        }
    }
}

// ****************************************************
//
// CDestNumDialog
//
// ****************************************************

CDestNumDialog::CDestNumDialog(BOOL bDialCountryCode, BOOL bDialAreaCode)
{
    m_wsz[0] = NULL;
    m_bDialCountryCode = bDialCountryCode;
    m_bDialAreaCode = bDialAreaCode;
}

CDestNumDialog::~CDestNumDialog()
{
}

INT_PTR CDestNumDialog::DoModal(HWND hwndParent)
{
    return DialogBoxParam(GetUIInstance(),
                          MAKEINTRESOURCE(IDD_DESTNUMDIALOG),
                          hwndParent,
                          CDestNumDialog::DialogProc,
                          (LPARAM)this);
}

PWSTR CDestNumDialog::GetResult()
{
    return m_wsz;
}

INT_PTR CALLBACK CDestNumDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDestNumDialog * pwd = (CDestNumDialog *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pwd = (CDestNumDialog *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
        return pwd->OnInitDialog(hwnd);

    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDOK:
            pwd->OnOK(hwnd);
            // fall through

        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            break;
        }
        break;
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a112HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a112HelpIDs);
        break;
    }

    return 0;
}

BOOL CDestNumDialog::OnInitDialog(HWND hwnd)
{
    SendMessage(GetDlgItem(hwnd,IDC_AREACODE),BM_SETCHECK,m_bDialAreaCode ? BST_CHECKED : BST_UNCHECKED,0);
    SendMessage(GetDlgItem(hwnd,IDC_COUNTRYCODE),BM_SETCHECK,m_bDialCountryCode ? BST_CHECKED : BST_UNCHECKED,0);
    SendMessage(GetDlgItem(hwnd,IDC_LOCALNUMBER),BM_SETCHECK,BST_CHECKED,0);
    return 0;
}

void CDestNumDialog::OnOK(HWND hwnd)
{
    int i = 0;

    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_COUNTRYCODE),BM_GETCHECK,0,0) )
    {
        m_wsz[i++] = L'E';
    }

    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_AREACODE),BM_GETCHECK,0,0) )
    {
        m_wsz[i++] = L'F';
    }

    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_LOCALNUMBER),BM_GETCHECK,0,0) )
    {
        m_wsz[i++] = L'G';
    }

    m_wsz[i] = NULL;
}

void ShowErrorMessage(HWND hwnd, int iErr)
{
    TCHAR szCaption[128];
    TCHAR szText[1024];

    LoadString(GetUIInstance(), IDS_ERRORCAPTION, szCaption, ARRAYSIZE(szCaption));
    LoadString(GetUIInstance(), iErr, szText, ARRAYSIZE(szText));

    MessageBeep(MB_ICONEXCLAMATION);
    MessageBox(hwnd, szText, szCaption, MB_OK | MB_ICONEXCLAMATION);
    SetFocus(hwnd);
}

BOOL WinHelpEnabled()
{
    DWORD   cb;
    TCHAR   szName[MAX_PATH];
    BOOL    fWinHelpEnabled = FALSE;
    HDESK   hDesk;

    //
    // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
    // The context sensitive help needs to be disabled in winlogon
    //  
    szName[0] = 0;

    hDesk = GetThreadDesktop(GetCurrentThreadId());
    
    if (hDesk)
    {
        if (GetUserObjectInformation(hDesk, UOI_NAME, szName, sizeof(szName), &cb))
        {
            if (_tcscmp(TEXT("Winlogon"), szName) != 0)
            {
                // This is not winlogon; we can enable context sensitive help
                fWinHelpEnabled = TRUE;
            }
        }
    }

    return (fWinHelpEnabled);
}

BOOL TapiCplWinHelp(HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
    if (WinHelpEnabled())
    {
        return WinHelp(hWndMain, lpszHelp, uCommand, dwData);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplprecomp.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplprecomp.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

#define TAPI_CURRENT_VERSION 0x00030000

#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <cpl.h>
#include <prsht.h>
#include <commctrl.h>
#include <comctrlp.h>

#include "cplResource.h"
#include "HelpArray.h"

// TAPI class definitions
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "card.h"
#include "rules.h"
#include "location.h"
// for TapiIsSafeToDisplaySensitiveData
#include "tregupr2.h"


typedef struct tagPSPINFO
{
    int     iDlgID;
    DLGPROC pfnDlgProc;
} PSPINFO;

// we limit all input strings to 128 characters.  This includes phone numbers, area codes, pin numbers,
// access numbers, any type of input field.  This was chosen simply for versatility and simplicity.
#define MAX_INPUT           128
#define CPL_SETTEXTLIMIT    (MAX_INPUT-1)

#define LIF_ALLOWALPHA      0x00000001  // a-z, A-Z
#define LIF_ALLOWNUMBER     0x00000002  // 0-9
#define LIF_ALLOWDASH       0x00000004  // "-", "(", and ")"
#define LIF_ALLOWPOUND      0x00000008  // "#"
#define LIF_ALLOWSTAR       0x00000010  // "*"
#define LIF_ALLOWSPACE      0x00000020  // " "
#define LIF_ALLOWCOMMA      0x00000040  // ","
#define LIF_ALLOWPLUS       0x00000080  // "+"
#define LIF_ALLOWBANG       0x00000100  // "!"
#define LIF_ALLOWATOD       0x00000200  // a-d, A-D

BOOL LimitInput(HWND hwnd, DWORD dwFalgs);      // edit (or whatever) control version
BOOL LimitCBInput(HWND hwnd, DWORD dwFlags);    // ComboBox version
void HideToolTip();                             // called to ensure that any visable LimitInput tooltip is hidden
void ShowErrorMessage(HWND hwnd, int iErr);     // beeps, displays a message box with an error string, and set focus to the given window
HINSTANCE GetUIInstance();                      // returns a handle to the UI module

HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry);
// return values for IsCityRule
#define CITY_MANDATORY  (1)
#define CITY_OPTIONAL   (-1)
#define CITY_NONE       (0)

int IsCityRule(PWSTR lpRule);              // sees if an area code is required
BOOL  IsEmptyOrHasOnlySpaces(PTSTR);            // sees if a string is empty or has only spaces
BOOL  HasOnlyCommasW(PWSTR);                    // sees if a string has only commas

BOOL IsLongDistanceCarrierCodeRule(LPWSTR lpRule);
BOOL IsInternationalCarrierCodeRule(LPWSTR lpRule);
// PopulateCountryList
//
// Used to fill a combo box with the list of available countries.  The item
// data for each item will countain the countries ID (not a CCountry object pointer)
BOOL PopulateCountryList(HWND hwndCombo, DWORD dwSelectedCountry);

// DeleteItemAndSelectPrevious
//
// In all of our list boxes we have to worry about deleting the selected item and then moving the
// selection to the previous item in the list.  This usually happens in response to pressing a
// delete button, which often causes that delete button to become disabled, so we also have to
// worry about moving focus away from the delete button and onto a good default location.
//
// Deletes iItem from listbox iList in dialog hwndParent.  If the listbox becomes empty it moves
// focus to iAdd if iDel currently has the focus.
int DeleteItemAndSelectPrevious( HWND hwndParent, int iList, int iItem, int iDel, int iAdd );

// Function to check if context-sensitive help needs to be enabled and call WinHelp
BOOL TapiCplWinHelp(HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

extern TCHAR gszHelpFile[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cpllocationps.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cpllocationps.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

// Property Sheet stuff for the main page
#include "cplPreComp.h"
#include "cplLocationPS.h"


CLocationPropSheet::CLocationPropSheet(BOOL bNew, CLocation * pLoc, CLocations * pLocList, LPCWSTR pwszAdd)
{
    m_bNew = bNew;
    m_pLoc = pLoc;
    m_pLocList = pLocList;
    m_dwCountryID = 0;
    m_pRule = NULL;
    m_pCard = NULL;
    m_bWasApplied = FALSE;
    m_bShowPIN = FALSE;
    m_pwszAddress = pwszAdd;
}


CLocationPropSheet::~CLocationPropSheet()
{
}


LONG CLocationPropSheet::DoPropSheet(HWND hwndParent)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpsp[3];

    // Initialize the header:
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hwndParent;
    psh.hInstance = GetUIInstance();
    psh.hIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(m_bNew?IDS_NEWLOCATION:IDS_EDITLOCATION);
    psh.nPages = 3;
    psh.nStartPage = 0;
    psh.pfnCallback = NULL;
    psh.phpage = hpsp;

    // Now setup the Property Sheet Page
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = GetUIInstance();
    psp.lParam = (LPARAM)this;

    PSPINFO aData[3] =
    {
        { IDD_LOC_GENERAL,       CLocationPropSheet::General_DialogProc },
        { IDD_LOC_AREACODERULES, CLocationPropSheet::AreaCode_DialogProc },
        { IDD_LOC_CALLINGCARD,   CLocationPropSheet::CallingCard_DialogProc },
    };

    for (int i=0; i<3; i++)
    {
        psp.pszTemplate = MAKEINTRESOURCE(aData[i].iDlgID);
        psp.pfnDlgProc = aData[i].pfnDlgProc;
        hpsp[i] = CreatePropertySheetPage( &psp );
    }

    PropertySheet( &psh );

    return m_bWasApplied?PSN_APPLY:PSN_RESET;
}

BOOL CLocationPropSheet::OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    switch (pnmhdr->code)
    {
    case PSN_APPLY:         // user pressed OK or Apply
    case PSN_RESET:         // user pressed Cancel
    case PSN_KILLACTIVE:    // user is switching pages
        HideToolTip();
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplsimpledialogs.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplsimpledialogs.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

// Simple dialog class that shows a dialog with a title, a string, and an edit box.
// Input into the edit box is limited according to the flags.  The text from the
// edit box is available to the class creator after the dialog is dismissed.  This
// class is used for "Specify Digits" and "Add Prefix".
//
// Sample usage:
//  CEditDialog ed;
//  ed.DoModal(hwnd,IDS_TITLE,IDS_TEXT,LIF_NUMBER);
//  ed.GetString();

class CEditDialog
{
public:
    CEditDialog();
    ~CEditDialog();

    INT_PTR DoModal(HWND hwndParent, int iTitle, int iText, int iDesc, DWORD dwFlags);
    LPTSTR GetString();
protected:
    LPTSTR  m_psz;      // pointer to allocated buffer for string result
    int     m_iTitle;   // resource id to load for title
    int     m_iText;    // resource id to load for body text
    int     m_iDesc;    // resource id to load for description of edit field (should contain a "&")
    DWORD   m_dwFlags;  // limit input flags, or zero to allow all input

    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
    BOOL OnInitDialog(HWND hwnd);
    void OnOK(HWND hwnd);
};

// The simple dialog that pops up to ask what we are waiting for.  It presents
// a bunch of radio buttons for each choice and a spin button for the seconds.

class CWaitForDialog
{
public:
    CWaitForDialog();
    ~CWaitForDialog();

    INT_PTR DoModal(HWND hwndParent);
    int GetWaitType();
protected:
    int     m_iRes;     // Integer return value

    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
    BOOL OnInitDialog(HWND hwnd);
    void OnOK(HWND hwnd);
};

// This dialog presents the user with choices for what parts of the destination
// number need to be dialed.  It cat's the results into a WCHAR buffer which
// can then be retreived.

class CDestNumDialog
{
public:
    CDestNumDialog(BOOL bDialCountryCode, BOOL bDialAreaCode);
    ~CDestNumDialog();

    INT_PTR DoModal(HWND hwndParent);
    PWSTR GetResult();
protected:
    WCHAR   m_wsz[4];     // return value is from 1 to 3 wide characters, null terminated
    BOOL    m_bDialCountryCode; // initial value for "Dial Country Code" checkbox
    BOOL    m_bDialAreaCode;    // initial value for "Dial Area Code" checkbox

    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
    BOOL OnInitDialog(HWND hwnd);
    void OnOK(HWND hwnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cplsimplelocation.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplsimplelocation.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/
//
// The dialog proc for the SimpleLocation page.  This is used as a page
// inside the Modem wizard (in modemui.dll) and as a dialog from tapi
// when there are no locations.
//

#include "cplPreComp.h"
#include "cplResource.h"

HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry);
int IsCityRule(LPWSTR lpRule);

int IsCityRule(DWORD dwCountryID)
{
    CCountry * pCountry;
    HRESULT hr;

    hr = CreateCountryObject(dwCountryID, &pCountry);
    if ( SUCCEEDED(hr) )
    {
        int ret = IsCityRule(pCountry->GetLongDistanceRule());
        delete pCountry;
        return ret;
    }
    
    // in the error case we return optional as a compromise that works
    // for any possible case (though no optimally).
    LOG((TL_ERROR, "IsCityRule(DWORD dwCountryID) failed to create country %d", dwCountryID ));
    return CITY_OPTIONAL;
}

//***************************************************************************
extern "C"
INT_PTR
CALLBACK
LocWizardDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static DWORD dwVersion;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            HWND hwnd;

            // we either pass in zero or the TAPI version as the lParam.
            dwVersion = (DWORD)lParam;

            DWORD dwDefaultCountryID = GetProfileInt(TEXT("intl"), TEXT("iCountry"), 1);
            hwnd = GetDlgItem(hwndDlg, IDC_COUNTRY);
            PopulateCountryList(hwnd, dwDefaultCountryID);

            CCountry * pCountry;
            HRESULT hr;
            int     iCityRule;
            int     iLongDistanceCarrierCodeRule;
            int     iInternationalCarrierCodeRule;

            hr = CreateCountryObject(dwDefaultCountryID, &pCountry);
            if ( SUCCEEDED(hr) )
            {
                iCityRule = IsCityRule( pCountry->GetLongDistanceRule() );
                iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                delete pCountry;
            } else 
            {
                LOG((TL_ERROR, "LocWizardDlgProc failed to create country %d", dwDefaultCountryID));
                iCityRule = CITY_OPTIONAL;
                iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
            }

            hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
            SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
            LimitInput(hwnd, LIF_ALLOWNUMBER);
            if ( iCityRule == CITY_NONE )
            {
                SetWindowText(hwnd, TEXT(""));
                EnableWindow(hwnd, FALSE);
            }

            hwnd = GetDlgItem(hwndDlg,IDC_CARRIERCODE);
            SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
            LimitInput(hwnd, LIF_ALLOWNUMBER);
            if ( (LONG_DISTANCE_CARRIER_NONE == iLongDistanceCarrierCodeRule) &&
                 (INTERNATIONAL_CARRIER_NONE == iInternationalCarrierCodeRule) )
            {
                SetWindowText(hwnd, TEXT(""));
                EnableWindow(GetDlgItem(hwndDlg, IDC_STATICCC), FALSE);
                EnableWindow(hwnd, FALSE);
            }

            hwnd = GetDlgItem(hwndDlg,IDC_LOCALACCESSNUM);
            SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
            LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);

            BOOL bUseToneDialing = TRUE;
            CheckRadioButton(hwndDlg,IDC_TONE,IDC_PULSE,bUseToneDialing?IDC_TONE:IDC_PULSE);

            SetForegroundWindow (hwndDlg);

            return TRUE; // auto set focus
        }

    case WM_NOTIFY:
        // If we are controlling the property page then we will recieve WM_NOTIFY
        // messages from it.
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_WIZFINISH:
        case PSN_KILLACTIVE:
            // This dialog is shown in different places depending on if this is a legacy modem install
            // or a PNP modem install.  In the PNP case, the dialog shows on a single page wizard that
            // has a "finsih" button, in the legacy case it shows in the middle of a series of pages and
            // has a "next" button.  We get different notify messages based on which case we are in, but
            // luckly both of those notifies can be handled with the same code (ie they use the same
            // return codes to mean "don't leave this page yet").  This is why we treat both PSN_WIZFINISH
            // and PSN_KILLACTIVE in the same mannor.
            wParam = IDOK;
            break;

        case PSN_SETACTIVE:
            return TRUE;

        default:
            return FALSE;
        }

        // fall through.  This causes WM_NOTIFY:PSN_KILLACTIVE to be treated exactly
        // the same as WM_COMMAND:IDOK.

    case WM_COMMAND:
        // we get lots of WM_COMMAND messages, but the only one we care about is the
        // "OK" button that dismisses us in dialog mode
        switch ( LOWORD(wParam) )
        {
        case IDOK:
            {
                HWND    hwnd;
                TCHAR   szBuffer[128];
                WCHAR   wszAreaCode[32];
                WCHAR   wszCarrierCode[32];
                DWORD   dwCountryID;

                // verify all the input
                hwnd = GetDlgItem( hwndDlg, IDC_COUNTRY );
                LRESULT lr = SendMessage( hwnd, CB_GETCURSEL, 0, 0 );
                dwCountryID = (DWORD)SendMessage( hwnd, CB_GETITEMDATA, lr, 0 );

                if ( CB_ERR == dwCountryID )
                {
                    // No country is selected
                    ShowErrorMessage(hwnd, IDS_NEEDACOUNTRY);

                    // if we are a wizard page, prevent swicthing pages
                    if ( uMsg == WM_NOTIFY )
                    {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    }
                    return TRUE;
                }

                CCountry * pCountry;
                HRESULT hr;
                int     iCityRule;
                int     iLongDistanceCarrierCodeRule;
                int     iInternationalCarrierCodeRule;

                hr = CreateCountryObject(dwCountryID, &pCountry);
                if ( SUCCEEDED(hr) )
                {
                    iCityRule = IsCityRule(pCountry->GetLongDistanceRule());
                    iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                    iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                    delete pCountry;
                } else {
                    LOG((TL_ERROR, "LocWizardDlgProc failed to create country %d", dwCountryID));
                    iCityRule = CITY_OPTIONAL;
                    iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                    iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
                }


                hwnd = GetDlgItem(hwndDlg, IDC_AREACODE);
                GetWindowText( hwnd, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszAreaCode, ARRAYSIZE(wszAreaCode) );

                // if the selected country requires an area code && no area code is given
                if ( (CITY_MANDATORY==iCityRule) && !*wszAreaCode )
                {
                    // complain that the area code is missing.
                    ShowErrorMessage(hwnd, IDS_NEEDANAREACODE);

                    // if we are a wizard page, prevent swicthing pages
                    if ( uMsg == WM_NOTIFY )
                    {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    }
                    return TRUE;
                }


                hwnd = GetDlgItem(hwndDlg, IDC_CARRIERCODE);
                GetWindowText( hwnd, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszCarrierCode, ARRAYSIZE(wszCarrierCode) );

                // if the selected country requires a carrier code && no carrier code is given
                if ( ((LONG_DISTANCE_CARRIER_MANDATORY == iLongDistanceCarrierCodeRule) ||
                      (INTERNATIONAL_CARRIER_MANDATORY == iInternationalCarrierCodeRule)) &&
                     !*wszCarrierCode )
                {
                    // complain that the carrier code is missing.
                    ShowErrorMessage(hwnd, IDS_NEEDACARRIERCODE);

                    // if we are a wizard page, prevent swicthing pages
                    if ( uMsg == WM_NOTIFY )
                    {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    }
                    return TRUE;
                }

                // if we get here then the input is all valid
                WCHAR       wszLocationName[128];
                WCHAR       wszAccessCode[32];
                BOOL        bUseTone;

                LoadString( GetUIInstance(), IDS_MYLOCATION, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszLocationName, ARRAYSIZE(wszLocationName) );


                hwnd = GetDlgItem(hwndDlg, IDC_LOCALACCESSNUM);
                GetWindowText( hwnd, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszAccessCode, ARRAYSIZE(wszAccessCode) );

                hwnd = GetDlgItem( hwndDlg, IDC_TONE );
                bUseTone = (BST_CHECKED == SendMessage(hwnd, BM_GETCHECK, 0,0));

                // Create a location.
                CLocation location;

                // Initialize it with the values from the dialog
                location.Initialize(
                        wszLocationName,
                        wszAreaCode,
                        iLongDistanceCarrierCodeRule?wszCarrierCode:L"",
                        iInternationalCarrierCodeRule?wszCarrierCode:L"",
                        wszAccessCode,
                        wszAccessCode,
                        L"",
                        0,
                        dwCountryID,
                        0,
                        bUseTone?LOCATION_USETONEDIALING:0 );
                location.NewID();

                // Write it to the registry
                location.WriteToRegistry();

                if ( uMsg == WM_COMMAND )
                {
                    EndDialog(hwndDlg, IDOK);
                }
            }
            break;

        case IDCANCEL:
            // Do a version check, if the version is < 2.2 then we 
            // need to provide a strong warning message about legacy apps
            // not working correctly without this information.  Only upon
            // a confirmation from the user will we then end the dialog.
            if ( dwVersion < TAPI_VERSION2_2 )
            {
                int ret;
                TCHAR szText[1024];
                TCHAR szCaption[128];

                LoadString( GetUIInstance(), IDS_NOLOCWARNING, szText, ARRAYSIZE(szText) );
                LoadString( GetUIInstance(), IDS_NOLOCCAPTION, szCaption, ARRAYSIZE(szCaption) );

                ret = MessageBox(hwndDlg, szText, szCaption, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 );
                if ( IDYES != ret )
                {
                    return TRUE;
                }
            }
            EndDialog(hwndDlg, IDCANCEL);
            break;

        case IDC_COUNTRY:
            if ( CBN_SELCHANGE == HIWORD(wParam) )
            {
                HWND    hwnd;
                DWORD   dwCountryID;
                int     iCityRule;

                hwnd = GetDlgItem( hwndDlg, IDC_COUNTRY );
                LRESULT lr = SendMessage( hwnd, CB_GETCURSEL, 0, 0 );
                dwCountryID = (DWORD)SendMessage( hwnd, CB_GETITEMDATA, lr, 0 );

                CCountry * pCountry;
                HRESULT hr;
                int     iLongDistanceCarrierCodeRule;
                int     iInternationalCarrierCodeRule;

                hr = CreateCountryObject(dwCountryID, &pCountry);
                if ( SUCCEEDED(hr) )
                {
                    iCityRule = IsCityRule( pCountry->GetLongDistanceRule() );
                    iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                    iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                    delete pCountry;
                } else 
                {
                    LOG((TL_ERROR, "LocWizardDlgProc failed to create country %d", dwCountryID));
                    iCityRule = CITY_OPTIONAL;
                    iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                    iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
                }

                hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
                if ( iCityRule == CITY_NONE )
                {
                    SetWindowText(hwnd, TEXT(""));
                    EnableWindow(hwnd, FALSE);
                }
                else
                {
                    EnableWindow(hwnd, TRUE);
                }

                hwnd = GetDlgItem(hwndDlg, IDC_CARRIERCODE);
                if ( (LONG_DISTANCE_CARRIER_NONE == iLongDistanceCarrierCodeRule) &&
                     (INTERNATIONAL_CARRIER_NONE == iInternationalCarrierCodeRule) )
                {
                    SetWindowText(hwnd, TEXT(""));
                    EnableWindow(hwnd, FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_STATICCC), FALSE);
                }
                else
                {
                    EnableWindow(hwnd, TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_STATICCC), TRUE);
                }
            }
            break;
        }
        break;
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        TapiCplWinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a115HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        TapiCplWinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a115HelpIDs);
        break;

    default:
        // message is not handled, return FALSE.
        return FALSE;
    }

    // message was handled. return TRUE.
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\cpllocationps.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cpllocationps.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

#include "cplAreaCodeDlg.h"
#include "cplCallingCardPS.h"

void UpdateSampleString(HWND hwnd, CLocation * pLoc, PCWSTR pwszAddress, CCallingCard * pCard);
class CLocationPropSheet
{
public:
    CLocationPropSheet(BOOL bNew, CLocation * pLoc, CLocations * pLocList, LPCWSTR pwszAdd);
    ~CLocationPropSheet();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CLocationPropSheet)
#endif

    
	LONG DoPropSheet(HWND hwndParent);

protected:
    BOOL OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);

    static INT_PTR CALLBACK General_DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL General_OnInitDialog(HWND hwndDlg);
    BOOL General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCtl);
    BOOL General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    BOOL General_OnApply(HWND hwndDlg);
    BOOL PopulateDisableCallWaitingCodes(HWND hwndCombo, LPTSTR szSelected);

    static INT_PTR CALLBACK AreaCode_DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL AreaCode_OnInitDialog(HWND hwndDlg);
    BOOL AreaCode_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL AreaCode_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    void PopulateAreaCodeRuleList(HWND hwndList);
    void LaunchNewRuleDialog(BOOL bNew, HWND hwndParent);
    void DeleteSelectedRule(HWND hwndList);
    void AddRuleToList(HWND hwndList, CAreaCodeRule * pRule, BOOL bSelect);
    void RemoveRuleFromList(HWND hwndList, BOOL bSelect);
    void SetDataForSelectedRule(HWND hDlg);

    static INT_PTR CALLBACK CallingCard_DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL CallingCard_OnInitDialog(HWND hwndDlg);
    BOOL CallingCard_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL CallingCard_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    BOOL CallingCard_OnApply(HWND hwndDlg);
    void PopulateCardList(HWND hwndList);
    void LaunchCallingCardPropSheet(BOOL bNew, HWND hwndParent);
    void DeleteSelectedCard(HWND hwndList);
    void AddCardToList(HWND hwndList, CCallingCard * pCard, BOOL bSelect);
    void UpdateCardInList(HWND hwndList, CCallingCard * pCard);
    void SetDataForSelectedCard(HWND hDlg);
    void SetCheck(HWND hwndList, CCallingCard * pCard, int iImage);
    void EnsureVisible(HWND hwndList, CCallingCard * pCard);

    BOOL        m_bWasApplied;      // Set to true if we are applied, false if we are canceled
    BOOL        m_bNew;             // True if this is a new location, false if we're editing an existing one
    BOOL		m_bShowPIN;			// True if it's safe to show the PIN
    CLocation * m_pLoc;             // pointer to the location object to use.
    CLocations* m_pLocList;         // pointer to the list of all locations, need to ensure a unique name
    PCWSTR      m_pwszAddress;
    
    // These tapi objects need to live for the life of the property sheet or we will AV.
    CCallingCards   m_Cards;        // Needed for the "Calling Card" page.

    // These pointers point into the above TAPI objects
    CAreaCodeRule * m_pRule;
    CCallingCard *  m_pCard;
    DWORD           m_dwDefaultCard;
    DWORD           m_dwCountryID;  // the selected countries ID
    int             m_iCityRule;    // We cache the result of calling IsCityRule on the currently selected country
    int             m_iLongDistanceCarrierCodeRule;     //We cache the result of calling isLongDistanceCarrierCodeRule
    int             m_iInternationalCarrierCodeRule;    //We cache the result of calling isInternationalCarrierCodeRule
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\dial.cpp ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  dial.cpp
                                                              
****************************************************************************/

#include <windows.h>
#include <windowsx.h>

#if WINNT
#else
#include <help.h>
#endif

#include "tchar.h"
#include "prsht.h"
#include "stdlib.h"
#include "tapi.h"
#include "tspi.h"
#include "client.h"
#include "clntprivate.h"
#include "card.h"
#include "location.h"
#include "rules.h"
#include "countrygroup.h"
#include <shlwapi.h>
#include <shlwapip.h>   // from private\inc


#undef   lineGetTranslateCaps
#undef   lineSetTollList
#undef   lineTranslateAddress
#undef   tapiGetLocationInfo
#undef   lineGetCountry
#undef   lineTranslateDialog



// moved here from loc_comn.h
#define     MAXLEN_NAME     96

#ifdef __cplusplus
extern "C"{
#endif

BOOL    gbTranslateSimple = FALSE;
BOOL    gbTranslateSilent = FALSE;


TCHAR gszTelephonyKey[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");
TCHAR gszRegKeyNTServer[]  = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");

TCHAR gszLocation[]        = TEXT("Location");
TCHAR gszLocations[]       = TEXT("Locations");
const TCHAR gszNullString[]      = TEXT("");

TCHAR gszNumEntries[]      = TEXT("NumEntries");
TCHAR gszCurrentID[]       = TEXT("CurrentID");
TCHAR gszNextID[]          = TEXT("NextID");

TCHAR gszID[]              = TEXT("ID");
TCHAR gszFlags[]           = TEXT("Flags");
TCHAR gszCallingCard[]     = TEXT("CallingCard");
TCHAR gszCards[]           = TEXT("Cards");
TCHAR gszCard[]            = TEXT("Card");

#ifdef __cplusplus
}
#endif

LONG CreateCurrentLocationObject(CLocation **pLocation,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions);

HRESULT ReadLocations( PLOCATIONLIST *ppLocationList,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions
                     );
LONG PASCAL ReadCountries( LPLINECOUNTRYLIST *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         );



LONG BreakupCanonicalW( PWSTR  pAddressIn,
                        PWSTR  *pCountry,
                        PWSTR  *pCity,
                        PWSTR  *pSubscriber
                        );

static LONG  GetTranslateCapsCommon(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps,
    BOOL                bUnicode
    );

static  void   LayDownTollList(CLocation *pLocation,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair, 
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         );
static void LayDownString( PCWSTR   pInString,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair, 
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         );

static PWSTR    CopyStringWithExpandJAndK(PWSTR pszRule, PWSTR pszAccessNr, PWSTR pszAccountNr);
static BOOL     IsATollListAreaCodeRule(CAreaCodeRule *pRule, PWSTR pszLocationAreaCode);
static BOOL     FindTollPrefixInLocation(CLocation *pLocation,
                                         PWSTR  pPrefix,
                                         CAreaCodeRule **ppRule, 
                                         PWSTR *ppWhere);
static PWSTR    FindPrefixInMultiSZ(PWSTR pPrefixList, PWSTR pPrefix);

LONG PASCAL  WriteLocations( PLOCATIONLIST  pLocationList,
                             DWORD      dwChangedFlags
                           );


extern "C" char * PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );



LONG
PASCAL
IsThisAPIVersionInvalid(
    DWORD dwAPIVersion
    )
{
   switch (dwAPIVersion)
   {
   case TAPI_VERSION3_1:
   case TAPI_VERSION3_0:
   case TAPI_VERSION2_2:
   case TAPI_VERSION2_1:
   case TAPI_VERSION2_0:
   case TAPI_VERSION1_4:
   case TAPI_VERSION1_0:

       return 0;

   default:

       break;
   }

   return LINEERR_INCOMPATIBLEAPIVERSION;
}


//***************************************************************************
//
//  TAPI API Interfaces
//
//***************************************************************************




//***************************************************************************
LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    )
{
    PWSTR szAddressInW = NULL;
    LONG  lResult;


    LOG((TL_TRACE, "Entering lineTranslateDialogA"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   hwndOwner=x%p", hwndOwner));
    LOG((TL_INFO, "   lpszAddressIn=x%p", lpszAddressIn));


    if ( lpszAddressIn )
    {
        if ( IsBadStringPtrA(lpszAddressIn, 512) )
        {
            LOG((TL_ERROR, "Bad string pointer passed to lineTranslateDialog"));
            return LINEERR_INVALPOINTER;
        }
        else
        {
            szAddressInW = MultiToWide( lpszAddressIn );
        }
    }

    //
    // Win9x ?
    //

#ifndef _WIN64

    if ((GetVersion() & 0x80000000) &&
        (0xffff0000 == ((DWORD) hwndOwner & 0xffff0000)))
    {
       //
       // Yeah.  It don't play no ffff.
       //

       hwndOwner = (HWND) ( (DWORD)hwndOwner & 0x0000ffff );
    }

#endif

    lResult = lineTranslateDialogW(
        hLineApp,
        dwDeviceID,
        dwAPIVersion,
        hwndOwner,
        szAddressInW
        );

    if ( szAddressInW )
    {
       ClientFree( szAddressInW );
    }

    return lResult;
}




//***************************************************************************
LONG
WINAPI
lineTranslateDialog(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    )
{
    return lineTranslateDialogA(
                 hLineApp,
                 dwDeviceID,
                 dwAPIVersion,
                 hwndOwner,
                 lpszAddressIn
    );
}


extern "C" LONG WINAPI internalConfig( HWND hwndParent, PCWSTR pwsz, INT iTab, DWORD dwAPIVersion );

//***************************************************************************
LONG
WINAPI
lineTranslateDialogW(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCWSTR     lpszAddressIn
    )
{
    PLOCATIONLIST       pLocTest = NULL;
    LONG                lResult = 0;


    LOG((TL_TRACE, "Entering lineTranslateDialogW"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   hwndOwner=x%p", hwndOwner));
    LOG((TL_INFO, "   lpszAddressIn=x%p", lpszAddressIn));

    // stuff that the old lineTranslateDialog did so I'm just copying it:
    lResult = IsThisAPIVersionInvalid( dwAPIVersion );
    if ( lResult )
    {
        LOG((TL_ERROR, "Bad dwAPIVersion - 0x%08lx", dwAPIVersion));
        return lResult;
    }


    if ( lpszAddressIn && TAPIIsBadStringPtrW(lpszAddressIn, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAddressIn pointer (0x%p)", lpszAddressIn));
        return LINEERR_INVALPOINTER;
    }


    if (hwndOwner && !IsWindow (hwndOwner))
    {
        LOG((TL_ERROR, "  hwndOwner is bogus"));
        return LINEERR_INVALPARAM;
    }

    // Let TAPISRV test the params for us
    lResult = ReadLocations(&pLocTest,
                            hLineApp,
                            dwDeviceID,
                            dwAPIVersion,
                            CHECKPARMS_DWHLINEAPP|
                            CHECKPARMS_DWDEVICEID|
                            CHECKPARMS_DWAPIVERSION|
                            CHECKPARMS_ONLY);

    if (pLocTest != NULL)
    {
        ClientFree( pLocTest);
    }
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    return internalConfig(hwndOwner, lpszAddressIn, -1, dwAPIVersion);
}



//***************************************************************************
LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LONG lResult;

    lResult = lineGetTranslateCapsA(
        hLineApp,
        dwAPIVersion,
        lpTranslateCaps
        );

    //
    // Some 1.x apps like Applink (as of version 7.5b) don't call
    // lineTranslateDialog when they get a LINEERR_INIFILECORRUPT
    // result back from the request (spec says they should call
    // lineTranslateDialog), so we do that here for them, otherwise
    // some (like Applink) blow up
    //
    // While it's kind of ugly & intrusive, this is a less awkward
    // fix than placing a bogus location entry in the registry &
    // setting an Inited flag == 0 like tapi 1.x does
    //
    // There are cases in which this hack can break the caller (ex. MSWORKS)
    // The gbDisableGetTranslateCapsHack flag set to TRUE prevents the hack to be applied
    // See bug 306143
 
    if (lResult == LINEERR_INIFILECORRUPT && !gbDisableGetTranslateCapsHack)
    {
        lineTranslateDialog(
            hLineApp,
            0,
            dwAPIVersion,
            GetActiveWindow(),
            NULL
            );

        lResult = lineGetTranslateCapsA(
            hLineApp,
            dwAPIVersion,
            lpTranslateCaps
            );
    }

    return lResult;


}



//***************************************************************************
LONG
WINAPI
lineGetTranslateCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LONG    lResult = 0;    
    
    LOG((TL_TRACE, "Entering lineGetTranslateCapsA"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   lpTranslateCaps=x%p", lpTranslateCaps));

    lResult = GetTranslateCapsCommon(hLineApp, dwAPIVersion, lpTranslateCaps, FALSE);
    
    #if DBG
    {
        char szResult[32];


        LOG((TL_TRACE,
            "lineGetTranslateCapsA: result = %hs",
            MapResultCodeToText (lResult, szResult)
            ));
    }
    #else
        LOG((TL_TRACE,
            "lineGetTranslateCapsA: result = x%x",
            lResult
            ));
    #endif
    return lResult;
}

//***************************************************************************
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LONG    lResult = 0;
    
    LOG((TL_TRACE, "Entering lineGetTranslateCapsW"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   lpTranslateCaps=x%p", lpTranslateCaps));

    lResult =  GetTranslateCapsCommon(  hLineApp,
                                        dwAPIVersion,
                                        lpTranslateCaps,
                                        TRUE);
    

    #if DBG
    {
        char szResult[32];


        LOG((TL_TRACE,
            "lineGetTranslateCapsW: result = %hs",
            MapResultCodeToText (lResult, szResult)
            ));
    }
    #else
        LOG((TL_TRACE,
            "lineGetTranslateCapsW: result = x%x",
            lResult
            ));
    #endif

    return lResult;
}





//***************************************************************************


LONG
WINAPI
lineTranslateAddressA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
    WCHAR szTempStringW[512];
    LONG  lResult;


    if ( IsBadStringPtrA(lpszAddressIn, 512) )
    {
        LOG((TL_ERROR,
            "Invalid pszAddressIn pointer passed into lineTranslateAddress"
            ));

        return LINEERR_INVALPOINTER;
    }

    MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpszAddressIn,
        -1,
        szTempStringW,
        512
        );

    lResult = lineTranslateAddressW(
        hLineApp,
        dwDeviceID,
        dwAPIVersion,
        szTempStringW,
        dwCard,
        dwTranslateOptions,
        lpTranslateOutput
        );

    if ( 0 == lResult )
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpTranslateOutput,
            &lpTranslateOutput->dwDialableStringSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpTranslateOutput,
            &lpTranslateOutput->dwDisplayableStringSize
            );
    }

    return lResult;
}


LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
    LONG lResult;


    lResult = lineTranslateAddressA(
        hLineApp,
        dwDeviceID,
        dwAPIVersion,
        lpszAddressIn,
        dwCard,
        dwTranslateOptions,
        lpTranslateOutput
        );

    //
    // Some 1.x apps like Applink (as of version 7.5b) don't call
    // lineTranslateDialog when they get a LINEERR_INIFILECORRUPT
    // result back from the request (spec says they should call
    // lineTranslateDialog), so we do that here for them, otherwise
    // some (like Applink) blow up
    //
    // While it's kind of ugly & intrusive, this is a less awkward
    // fix than placing a bogus location entry in the registry &
    // setting an Inited flag == 0 like tapi 1.x does
    //

    if (lResult == LINEERR_INIFILECORRUPT)
    {
        lineTranslateDialog(
            hLineApp,
            0,
            dwAPIVersion,
            GetActiveWindow(),
            NULL
            );

        lResult = lineTranslateAddressA(
            hLineApp,
            dwDeviceID,
            dwAPIVersion,
            lpszAddressIn,
            dwCard,
            dwTranslateOptions,
            lpTranslateOutput
            );
    }

    return lResult;

}




//***************************************************************************
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{                   
    CLocation    *  pLocation = NULL;
    CCallingCard *  pCallingCard = NULL;
    DWORD           dwTranslateResults;
    DWORD           dwDestCountryCode;
    PWSTR           pszDialableString = NULL;
    PWSTR           pszDisplayableString = NULL;
    LONG            lResult = 0;
    HRESULT         hr=S_OK;    

    DWORD           dwCardToUse = 0;

    DWORD           dwDialableSize;
    DWORD           dwDisplayableSize;
    DWORD           dwNeededSize;
    
    LOG((TL_TRACE,  "Entering lineTranslateAddress"));



    lResult = IsThisAPIVersionInvalid( dwAPIVersion );
    if ( lResult )
    {
        LOG((TL_ERROR, "Bad dwAPIVersion - 0x%08lx", dwAPIVersion));
        return lResult;
    }


    if ( TAPIIsBadStringPtrW(lpszAddressIn,256) )
    {
        LOG((TL_ERROR, "Invalid pointer - lpszAddressInW"));
        lResult = LINEERR_INVALPOINTER;
        return lResult;
    }


    if ( dwTranslateOptions &
              ~(LINETRANSLATEOPTION_CARDOVERRIDE |
                LINETRANSLATEOPTION_CANCELCALLWAITING |
                LINETRANSLATEOPTION_FORCELOCAL |
                LINETRANSLATEOPTION_FORCELD) )
    {
        LOG((TL_ERROR, "  Invalid dwTranslateOptions (unknown flag set)"));
        lResult = LINEERR_INVALPARAM;
        return lResult;
    }


    if (  ( dwTranslateOptions & ( LINETRANSLATEOPTION_FORCELOCAL |
                                   LINETRANSLATEOPTION_FORCELD) )
                               ==
                                 ( LINETRANSLATEOPTION_FORCELOCAL |
                                   LINETRANSLATEOPTION_FORCELD)
      )
    {
        LOG((TL_ERROR, "  Invalid dwTranslateOptions (both FORCELOCAL & FORCELD set!)"));
        lResult = LINEERR_INVALPARAM;
        return lResult;
    }


    //
    // Is the structure at least a minimum size?
    //

    if (IsBadWritePtr(lpTranslateOutput, sizeof(LINETRANSLATEOUTPUT)))
    {
        LOG((TL_ERROR, "  Leaving lineTranslateAddress  INVALIDPOINTER"));
        lResult = LINEERR_INVALPOINTER;
        return lResult;
    }

    if (lpTranslateOutput->dwTotalSize < sizeof(LINETRANSLATEOUTPUT))
    {
        LOG((TL_ERROR, "  Leaving lineTranslateAddress  STRUCTURETOOSMALL"));
        lResult = LINEERR_STRUCTURETOOSMALL;
        return lResult;
    }

    if (IsBadWritePtr(lpTranslateOutput, lpTranslateOutput->dwTotalSize) )
    {
        LOG((TL_ERROR,
            "  Leaving lineTranslateAddress lpTanslateOutput->dwTotalSize bad"
            ));

        lResult = LINEERR_INVALPOINTER;
        return lResult;
    }


    //
    // Should we let some bad stuff slide?
    //

    if ( dwAPIVersion < 0x00020000 )
    {
        hLineApp = NULL;
    }





    lResult = CreateCurrentLocationObject(&pLocation,
                                          hLineApp,
                                          dwDeviceID,
                                          dwAPIVersion,
                                          CHECKPARMS_DWHLINEAPP|
                                          CHECKPARMS_DWDEVICEID|
                                          CHECKPARMS_DWAPIVERSION);
    if(FAILED(lResult))
    {
        //lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }

    if ( dwTranslateOptions & LINETRANSLATEOPTION_CARDOVERRIDE)
    {
        dwCardToUse = dwCard;
    }
    else
    {
        if(pLocation->HasCallingCard() )
        {
            dwCardToUse = pLocation->GetPreferredCardID();
        }
    }
    if (dwCardToUse != 0)
    {
        pCallingCard = new CCallingCard;
        if(pCallingCard)
        {
            if( FAILED(pCallingCard->Initialize(dwCardToUse)) )
            {
                delete pCallingCard;
                delete pLocation;
                lResult = LINEERR_INVALCARD;
                return lResult;
            }
        }
    }

    lResult = pLocation->TranslateAddress((PWSTR)lpszAddressIn,
                                          pCallingCard,
                                          dwTranslateOptions,
                                          &dwTranslateResults,
                                          &dwDestCountryCode,
                                          &pszDialableString,
                                          &pszDisplayableString
                                         );

    if (lResult == 0)

    {
        dwDialableSize = sizeof(WCHAR) * (lstrlenW(pszDialableString) + 1);
        dwDisplayableSize = sizeof(WCHAR) * (lstrlenW(pszDisplayableString) + 1);

        dwNeededSize = dwDialableSize +
                       dwDisplayableSize +
                       3 + // For potential alignment problem
                       sizeof(LINETRANSLATEOUTPUT);


        lpTranslateOutput->dwNeededSize = dwNeededSize;

        lpTranslateOutput->dwCurrentCountry = pLocation->GetCountryID();

        lpTranslateOutput->dwDestCountry    = dwDestCountryCode; // country code, not the ID !!

        if (dwNeededSize <= lpTranslateOutput->dwTotalSize)
        {
            lpTranslateOutput->dwUsedSize = dwNeededSize;

            lpTranslateOutput->dwDialableStringSize      = dwDialableSize;

            lpTranslateOutput->dwDialableStringOffset    =
                sizeof(LINETRANSLATEOUTPUT);

            lpTranslateOutput->dwDisplayableStringSize   = dwDisplayableSize;

            lpTranslateOutput->dwDisplayableStringOffset =
                sizeof(LINETRANSLATEOUTPUT) + dwDialableSize;

            // lpTranslateOutput->dwDisplayableStringOffset =
            //     (sizeof(LINETRANSLATEOUTPUT) + dwDialableSize
            //     + 3) & 0xfffffffc;

            lpTranslateOutput->dwTranslateResults        = dwTranslateResults;

            wcscpy ((WCHAR *)(lpTranslateOutput + 1), pszDialableString);

            //
            // Be ultra paranoid and make sure the string is DWORD aligned
            //

            wcscpy(
                (LPWSTR)(((LPBYTE)(lpTranslateOutput + 1) +
                    dwDialableSize)),
                    // + 3 )     & 0xfffffffc)
                 pszDisplayableString
                 );
        }
        else
        {
            lpTranslateOutput->dwUsedSize = sizeof(LINETRANSLATEOUTPUT);

            lpTranslateOutput->dwTranslateResults =
            lpTranslateOutput->dwDialableStringSize =
            lpTranslateOutput->dwDialableStringOffset =
            lpTranslateOutput->dwDisplayableStringSize =
            lpTranslateOutput->dwDisplayableStringOffset = 0;
         }
    }

//cleanup:


    if ( pszDisplayableString )
    {
        ClientFree( pszDisplayableString );
    }
    if ( pszDialableString )
    {   
        ClientFree( pszDialableString );
    }
    if (pLocation != NULL)
    {
        delete pLocation;
    }
    if (pCallingCard != NULL)
    {
        delete pCallingCard;
    }

/*
    //
    // If success & there's an LCR hook for this function then call it
    // & allow it to override our results if it wants to
    //

    if (lResult == 0  &&
        IsLeastCostRoutingEnabled()  &&
        pfnLineTranslateAddressWLCR)
    {
        lResult = (*pfnLineTranslateAddressWLCR)(
            hLineApp,
            dwDeviceID,
            dwAPIVersion,
            lpszAddressIn,
            dwCard,
            dwTranslateOptions,
            lpTranslateOutput
            );
    }
 */
    return (lResult);
}





//***************************************************************************
LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP    hLineApp,
    DWORD       dwLocationID
    )
{

    UINT n;
    PUINT pnStuff;
    PLOCATIONLIST pLocationList;
    PLOCATION  pEntry;
    LONG lResult = 0;
    HRESULT hr;
    DWORD dwCurrentLocationID = 0;
    DWORD dwNumEntries = 0;
    DWORD dwCount = 0;


    LOG((TL_TRACE,
        "lineSetCurrentLocation: enter, hApp=x%x, dwLoc=x%x",
        hLineApp,
        dwLocationID
        ));

    // Let TAPISRV test the params for us
     hr = ReadLocations(&pLocationList,       
                       hLineApp,                   
                       0,                   
                       0,                  
                       CHECKPARMS_DWHLINEAPP      
                      );

    if SUCCEEDED( hr) 
    {
        // current location
        dwCurrentLocationID  = pLocationList->dwCurrentLocationID;   

        
        
        //
        // If (specified loc == current loc) then simply return SUCCESS.
        //
        // Ran into a problem with the Equis (Reuters) DownLoader app in
        // which it would call this func, we'd pass the info to tapisrv,
        // tapisrv would send a LINE_LINEDEVSTATE\TRANSLATECHANGE msg,
        // and the app would respond by doing a lineSetCurrentLocation
        // again, effectively winding up in an infinite loop.  Fyi, tapi
        // 1.x did not send a DEVSTATE\TRANSLATECHANGE msg if the
        // specified locationID == the current location ID.
        //
    
        if (dwLocationID == dwCurrentLocationID)
        {
            lResult = 0;
        }
        else
        {
            hr = E_FAIL;  // fail if we don't find the requested loc
    
            // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
            pEntry = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           
    
            // Number of locations ?
            dwNumEntries =  pLocationList->dwNumLocationsInList;
    
            // Find the current location
            for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
            {
        
                if(pEntry->dwPermanentLocationID == dwLocationID)
                {
                    hr = S_OK;
                    break;
                }
    
                // Try next location in list
                //pEntry++;
                pEntry = (PLOCATION) ((BYTE*)(pEntry) + pEntry->dwUsedSize);           
    
            }

            if SUCCEEDED( hr) 
            {
                LOG((TL_INFO, "lineSetCurrentLocation - reqired location found %d",
                        dwCurrentLocationID));


                // write new value
                // finished with TAPI memory block so release
                if ( pLocationList != NULL )
                        ClientFree( pLocationList );


                // Allocate the memory buffer;
                pLocationList = (PLOCATIONLIST) ClientAlloc( sizeof(LOCATIONLIST) );
                if (pLocationList != NULL)
                {
                    // buffer size 
                    pLocationList->dwTotalSize  = sizeof(LOCATIONLIST);
                    pLocationList->dwNeededSize = sizeof(LOCATIONLIST);
                    pLocationList->dwUsedSize   = sizeof(LOCATIONLIST);
            
                    pLocationList->dwCurrentLocationID     = dwLocationID;
                    pLocationList->dwNumLocationsAvailable = 0;
                    
                    pLocationList->dwNumLocationsInList = 0;
                    pLocationList->dwLocationListSize   = 0;
                    pLocationList->dwLocationListOffset = 0;
            
                    WriteLocations( pLocationList, CHANGEDFLAGS_CURLOCATIONCHANGED);
                }


            }
            else
            {
                LOG((TL_ERROR, "lineSetCurrentLocation - required location not found "));
                lResult = LINEERR_INVALLOCATION;
            }
        }
    }
    else
    {
        lResult = hr;
    }
    

        
    // finished with TAPI memory block so release
    if ( pLocationList != NULL )
            ClientFree( pLocationList );


    LOG((TL_TRACE, "Leaving lineSetCurrentLocation"));
    return lResult;
}





//***************************************************************************
LONG
WINAPI
lineSetTollList(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    LPCSTR      lpszAddressIn,
    DWORD       dwTollListOption
    )
{
    return lineSetTollListA(
                    hLineApp,
                    dwDeviceID,
                    lpszAddressIn,
                    dwTollListOption
    );
}



//***************************************************************************
LONG
WINAPI
lineSetTollListA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    LPCSTR      lpszAddressIn,
    DWORD       dwTollListOption
    )
{
    WCHAR  szAddressInW[512];

    if ( IsBadStringPtrA(lpszAddressIn, 512) )
    {
        LOG((TL_ERROR, "Bad string pointer passed to lineSetTollListA"));
        return LINEERR_INVALPOINTER;
    }

    MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpszAddressIn,
                        -1,
                        szAddressInW,
                        512
                      );

    return lineSetTollListW(
                           hLineApp,
                           dwDeviceID,
                           szAddressInW,
                           dwTollListOption
                         );
}


//***************************************************************************
LONG
WINAPI
lineSetTollListW(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    PCWSTR      pszAddressIn,
    DWORD       dwTollListOption
    )
{
    
    PWSTR       pAddressIn = NULL;
    
    PWSTR       pAreaCode;
    PWSTR       pCountryCode;
    PWSTR       pSubscriber;

    CLocation   *pLocation = NULL;

    BOOL        bPrefixPresent;
    CAreaCodeRule   *pRule = NULL;
    PWSTR       pWhere = NULL;

    LONG        lResult;

    // Test the parameters
    if ((dwTollListOption != LINETOLLLISTOPTION_ADD) &&
        (dwTollListOption != LINETOLLLISTOPTION_REMOVE))
    {
        LOG((TL_ERROR, "Bad dwTollListOption in lineSetTollListW"));
        return LINEERR_INVALPARAM;
    }

    if ( TAPIIsBadStringPtrW(pszAddressIn, 256) )
    {
       LOG((TL_ERROR, "Bad pszAddressIn (0x%p)in lineSetTollListW", pszAddressIn));
       return LINEERR_INVALPOINTER;
    }
   //
   // Now, do we have a canonical number to deal with ?
   //
    if ( *pszAddressIn != L'+' )  // Check the first char
    {
        //
        // Nope, not canonical
        //
        LOG((TL_ERROR, "Address not canonical in lineSetTollListW"));
        return LINEERR_INVALADDRESS;
    }
    
    // Alloc a copy of the string
    pAddressIn = ClientAllocString((PWSTR)pszAddressIn);
    if ( !pAddressIn )
    {
       LOG((TL_ERROR, "Memory allocation failed"));
       return LINEERR_NOMEM;
    }
    // separate the string components
    lResult = BreakupCanonicalW(pAddressIn + 1,
                                &pCountryCode,
                                &pAreaCode,
                                &pSubscriber
                                );
    if(lResult)
    {
        goto forced_exit;
    }
    // test the prefix validity.
    // assuming 3 digits..
    if(! (iswdigit(pSubscriber[0]) &&
          iswdigit(pSubscriber[1]) &&
          iswdigit(pSubscriber[2]) &&
          pSubscriber[3]         ))
    {
        LOG((TL_ERROR, "lineSetTollListW: The prefix is not valid"));
        lResult = LINEERR_INVALADDRESS;
        goto forced_exit;
    }
    
    // get the current location object
    lResult = CreateCurrentLocationObject(&pLocation,
                                          hLineApp,
                                          dwDeviceID,
                                          0,
                                          CHECKPARMS_DWHLINEAPP|
                                          CHECKPARMS_DWDEVICEID);
    if(FAILED(lResult))
    {
        //lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        goto forced_exit;
    }

    // are the number and the current location with country code 1 ? 
    // is this number in the same area code ?
    if(pLocation->GetCountryCode() != 1 ||
       pCountryCode[0] != L'1' ||
       pCountryCode[1] != L'\0' ||
       wcscmp(pLocation->GetAreaCode(), pAreaCode) !=0 )
    {
        lResult = 0;
        goto forced_exit;
    }

    // terminate the 3 digit prefix
    pSubscriber[3] = L'\0';
    pSubscriber[4] = L'\0';

    // is there the prefix in any location toll rules ?
    bPrefixPresent = FindTollPrefixInLocation(  pLocation,
                                                pSubscriber,
                                                &pRule,
                                                &pWhere);

    if(dwTollListOption == LINETOLLLISTOPTION_ADD)
    {
        // add toll prefix
        if(bPrefixPresent)
        {
            ;// Do nothing
            lResult = 0;
        }
        else
        {
            // if we have already a toll rule, try to add the prefix to it
            if(pRule)
            {
                PWSTR   pList;
                DWORD   dwSize = pRule->GetPrefixListSize();
                // alloc a bigger list
                pList = (PWSTR)ClientAlloc(dwSize + 4*sizeof(WCHAR));
                if(pList==NULL)
                {
                    lResult = LINEERR_NOMEM;
                    goto forced_exit;
                }
                // copy the old one
                memcpy((PBYTE)pList, (PBYTE)pRule->GetPrefixList(), dwSize);
                // add our prefix
                memcpy((PBYTE)pList + dwSize-sizeof(WCHAR), (PBYTE)pSubscriber, 5*sizeof(WCHAR));
                // set the new list
                lResult = pRule->SetPrefixList(pList, dwSize + 4*sizeof(WCHAR));

                ClientFree(pList);
                if(FAILED(lResult))
                {
                    lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
                    goto forced_exit;
                }
            }
            // else a new rule must be created
            else
            {
                pRule = new CAreaCodeRule();
                if(pRule == NULL)
                {
                    lResult = LINEERR_NOMEM;
                    goto forced_exit;
                }

                lResult = pRule->Initialize(  pAreaCode,
                                    L"1",
                                    RULE_DIALNUMBER | RULE_DIALAREACODE,
                                    pSubscriber,
                                    5*sizeof(WCHAR)
                                    );
                if(FAILED(lResult))
                {
                    delete pRule;
                    lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
                    goto forced_exit;
                }
                // add the rule to the location
                pLocation->AddRule(pRule);
            }
        }
    }
    else
    {
        // delete the toll prefix
        if(bPrefixPresent)
        {
            DWORD   dwSize = pRule->GetPrefixListSize();
            // we have at least a toll rule present. If our prefix is the only one in that rule,
            // delete the entire rule
            if(dwSize<=5*sizeof(WCHAR)) 
            {
                // Delete the rule
                pLocation->RemoveRule(pRule);

                lResult = 0;
            }
            else
            {
                PWSTR   pList;
                PWSTR   pOld;
                DWORD   dwHeadSize;
                DWORD   dwTailSize;
                        
                pList = (PWSTR)ClientAlloc(dwSize - 4*sizeof(WCHAR));
                if(pList==NULL)
                {
                    lResult = LINEERR_NOMEM;
                    goto forced_exit;
                }

                pOld = pRule->GetPrefixList();

                dwHeadSize = (DWORD)((PBYTE)pWhere - (PBYTE)pOld);
                dwTailSize = dwSize - dwHeadSize - 4*sizeof(WCHAR);

                // copy the first part of the old list
                memcpy((PBYTE)pList, (PBYTE)pOld, dwHeadSize);
                // copy the rest of the list
                memcpy((PBYTE)pList+dwHeadSize, (PBYTE)pWhere + 4*sizeof(WCHAR), dwTailSize);
                // set the new list
                lResult = pRule->SetPrefixList(pList, dwSize - 4*sizeof(WCHAR));

                ClientFree(pList);
                if(FAILED(lResult))
                {
                    lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
                    goto forced_exit;
                }

            }

        }
        else
        {
            // prefix not present. Do nothing.
            lResult = 0;
        }
    }

    // Save
    lResult = pLocation->WriteToRegistry();
    if(FAILED(lResult))
    {
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        goto forced_exit;
    }


    
forced_exit:

    if(pLocation)
        delete pLocation;
    if(pAddressIn)
        ClientFree(pAddressIn);

    return lResult;
}





//***************************************************************************
LONG
WINAPI
tapiGetLocationInfoW(
                     LPWSTR   lpszCountryCode,
                     LPWSTR   lpszCityCode
                     )
{
    CLocation * pLocation;
    LONG        lResult = 0;
    WCHAR     * p;
    WCHAR     * q;
    DWORD       i;
    
    if (IsBadWritePtr( lpszCountryCode, 16) )
    {
        LOG((TL_ERROR,
            "tapiGetLocationInfoW: lpszCountryCode is not a valid, 8-byte pointer"
            ));
        
        return TAPIERR_REQUESTFAILED;
    }
    
    if (IsBadWritePtr( lpszCityCode, 16) )
    {
        LOG((TL_ERROR,
            "tapiGetLocationInfoW: lpszCityCode is not a valid, 8-byte pointer"
            ));
        
        return TAPIERR_REQUESTFAILED;
    }
    
    lResult = CreateCurrentLocationObject(&pLocation,0,0,0,0);
    if(FAILED(lResult))
    {
        return TAPIERR_REQUESTFAILED;
    }
    
    TCHAR szTempChar[8];
    
    wsprintf(
        szTempChar,
        TEXT("%d"),
        pLocation->GetCountryCode()
        );
    
    SHTCharToUnicode(szTempChar, lpszCountryCode, 8);
    
    //
    // Make sure not to return > (7 chars + NULL char)
    //
    p = (WCHAR *) lpszCityCode;
    q = (WCHAR *) pLocation->GetAreaCode();
    
    for (i = 0; (i < 7) && ((p[i] = q[i]) != L'\0'); i++);
    p[7] = L'\0';
    
    delete pLocation;
    
    return 0;
}



//***************************************************************************
LONG
WINAPI
tapiGetLocationInfoA(
    LPSTR   lpszCountryCode,
    LPSTR   lpszCityCode
    )
{

   WCHAR szCountryCodeW[8];
   WCHAR szCityCodeW[8];
   LONG lResult;


   LOG((TL_TRACE, "Entering tapiGetLocationInfoA"));
   LOG((TL_INFO, "   lpszCountryCode=%p", lpszCountryCode ));
   LOG((TL_INFO, "   lpszCityCode=%p", lpszCityCode ));


   if (IsBadWritePtr( lpszCountryCode, 8) )
   {
      LOG((TL_ERROR, "tapiGetLocationInfo: lpszCountryCode is not a valid, 8-byte pointer"));
      return TAPIERR_REQUESTFAILED;
   }


   if (IsBadWritePtr( lpszCityCode, 8) )
   {
      LOG((TL_ERROR, "tapiGetLocationInfo: lpszCityCode is not a valid, 8-byte pointer"));
      return TAPIERR_REQUESTFAILED;
   }

   lResult = tapiGetLocationInfoW(
                                   szCountryCodeW,
                                   szCityCodeW
                                  );

   if ( 0 == lResult )
   {
      WideCharToMultiByte(
                           GetACP(),
                           0,
                           szCountryCodeW,
                           -1,
                           lpszCountryCode,
                           8,
                           NULL,
                           NULL
                         );

      WideCharToMultiByte(
                           GetACP(),
                           0,
                           szCityCodeW,
                           -1,
                           lpszCityCode,
                           8,
                           NULL,
                           NULL
                         );
   }

   return lResult;
}


//***************************************************************************
LONG
WINAPI
tapiGetLocationInfo(
    LPSTR   lpszCountryCode,
    LPSTR   lpszCityCode
    )
{
    return tapiGetLocationInfoA(
               lpszCountryCode,
               lpszCityCode
    );
}







//***************************************************************************
//
//  RAS Private Interfaces
//
//***************************************************************************

#ifndef NORASPRIVATES

//***************************************************************************
LOCATION*
LocationFromID(
    IN LOCATION* pLocs,
    IN UINT      cLocs,
    IN DWORD     dwID )
{
return NULL;
}



//***************************************************************************
LOCATION*
LocationFromName(
    IN LOCATION* pLocs,
    IN UINT      cLocs,
    IN WCHAR*    pszName )
{
return NULL;
}


//***************************************************************************
//
//  internalCreateDefLocation
//
//      This API is created to be used by OOBE team internally.
//  It expectes a LOCATIONLIST with at least one LOCATION
//  specified in it. and pLocation->dwCurrentLocationID needs to
//  match dwPermanentLocationID of at least one of the location
//  entries specified in the location list.
//
extern "C"
HRESULT APIENTRY
internalCreateDefLocation(
    PLOCATIONLIST  pLocationList
    )
{
    HRESULT                 hr = S_OK;
    DWORD                   dw;
    PLOCATION               pEntry;

    //  Basic parameter check
    if (pLocationList == NULL ||
        pLocationList->dwNumLocationsInList < 1 ||
        pLocationList->dwUsedSize == 0 ||
        pLocationList->dwUsedSize > pLocationList->dwTotalSize ||
        pLocationList->dwTotalSize < 
            sizeof(LOCATIONLIST) + sizeof(LOCATION) ||
        pLocationList->dwLocationListSize < sizeof(LOCATION)
        )
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    //  Check the validity of the dwCurrentLocationID
    pEntry = (PLOCATION)((LPBYTE)pLocationList +
        pLocationList->dwLocationListOffset);
    for (dw = 0; dw < pLocationList->dwNumLocationsInList; ++dw)
    {
        if (pEntry->dwPermanentLocationID == 
            pLocationList->dwCurrentLocationID)
        {
            break;
        }
        pEntry = (PLOCATION)((LPBYTE)pEntry + pEntry->dwUsedSize);
    }
    if (dw >= pLocationList->dwNumLocationsInList)
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    hr = (HRESULT) WriteLocations (
        pLocationList, 
        CHANGEDFLAGS_CURLOCATIONCHANGED
        );

ExitHere:
    return hr;
}

extern "C"
DWORD APIENTRY
internalNewLocationW(
    IN WCHAR* pszName )

{
    LONG            lResult = 0;

    CLocation       *pLocation = NULL; 
    CLocation       *pNewLocation = NULL;
    CAreaCodeRule   *pAreaCodeRule = NULL;
    CAreaCodeRule   *pNewRule = NULL;
        
    // Validate    
    if (!pszName || lstrlenW( pszName ) > MAXLEN_NAME)
        return LINEERR_INVALPARAM;

    // Read the current location
    lResult = CreateCurrentLocationObject(&pLocation,0,0,0,0);
    if(FAILED(lResult))
    {
        //lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }

    // Create the new object
    pNewLocation = new CLocation();
    if(pNewLocation==NULL)
    {
        delete pLocation;
        LOG((TL_ERROR, "Cannot allocate a CLocation object"));
        return LINEERR_NOMEM;
    }
    // Clone the location (w/o the ID)
    lResult = pNewLocation->Initialize( pszName,
                                        pLocation->GetAreaCode(),
                                        pLocation->GetLongDistanceCarrierCode(),
                                        pLocation->GetInternationalCarrierCode(),
                                        pLocation->GetLongDistanceAccessCode(),
                                        pLocation->GetLocalAccessCode(),
                                        pLocation->GetDisableCallWaitingCode(),
                                        0,
                                        pLocation->GetCountryID(),
                                        pLocation->GetPreferredCardID(),
                                        (pLocation->HasCallingCard() ? LOCATION_USECALLINGCARD : 0) |
                                        (pLocation->HasCallWaiting() ? LOCATION_HASCALLWAITING : 0) |
                                        (pLocation->HasToneDialing() ? LOCATION_USETONEDIALING : 0) ,
                                        FALSE);
    if(FAILED(lResult))
    {
        delete pLocation;
        delete pNewLocation;
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }

    // Set the ID
    lResult = pNewLocation->NewID();
    if(FAILED(lResult))
    {
        delete pLocation;
        delete pNewLocation;
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }
    // Copy the area code rules
    pLocation->ResetRules();
    while(S_OK == pLocation->NextRule(1, &pAreaCodeRule, NULL))
    {    
        pNewRule = new CAreaCodeRule;
        pNewRule->Initialize(pAreaCodeRule->GetAreaCode(),
                             pAreaCodeRule->GetNumberToDial(),
                             pAreaCodeRule->GetOptions(),
                             pAreaCodeRule->GetPrefixList(),
                             pAreaCodeRule->GetPrefixListSize()
                            );
        pNewLocation->AddRule(pNewRule);
    }

    // Save the new location
    lResult = pNewLocation->WriteToRegistry();
    if(FAILED(lResult))
    {
        delete pLocation;
        delete pNewLocation;
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }
    
    delete pLocation;

    delete pNewLocation;

    return 0;
}



//***************************************************************************
extern "C"
DWORD APIENTRY
internalRemoveLocation(
    IN DWORD dwID )
{
    CLocations *pLocationList = NULL;
    DWORD       dwCurID;

    HRESULT         Result;

    LOG((TL_TRACE, "Entering internalRemoveLocation"));
    LOG((TL_INFO, "   dwID=0x%d", dwID));

    // Read the location list
    pLocationList = new CLocations();
    if(pLocationList==NULL)
    { 
        LOG((TL_ERROR, "Cannot allocate a CLocations object"));
        return LINEERR_NOMEM;
    }

    Result = pLocationList->Initialize();
    if(FAILED(Result))
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.Initialize() failed - HRESULT=0x%08lx", Result));
        return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_INIFILECORRUPT;
    }

    // Cannot delete the last location
    if(pLocationList->GetNumLocations() <2)
    {
        delete pLocationList;
        return LINEERR_INVALPARAM;
    }

    // If we're deleting the current location make the first location the
    //    current location, or if we're deleting the first the second.
    dwCurID = pLocationList->GetCurrentLocationID();

    if(dwCurID==dwID)
    {
        CLocation   *pLocation;
        // find the first location
        pLocationList->Reset();
        pLocationList->Next(1, &pLocation, NULL);
        
        // are we deleting the first
        if(pLocation->GetLocationID()==dwID)
            // try the second
            pLocationList->Next(1, &pLocation, NULL);
        
        // change the current location
        pLocationList->SetCurrentLocationID(pLocation->GetLocationID());
    }

    // Delete the location
    pLocationList->Remove(dwID);

    // Save
    Result = pLocationList->SaveToRegistry();
    if(FAILED(Result))
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.SaveToRegistry() failed - HRESULT=0x%08lx", Result));
        return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
    }

    delete pLocationList;

    return 0;
    
}



//***************************************************************************
extern "C"
DWORD APIENTRY
internalRenameLocationW(
    IN WCHAR* pszOldName,
    IN WCHAR* pszNewName )
{

    CLocations      *pLocationList;
    CLocation       *pLocation;

    HRESULT         Result;
    DWORD           dwError;

    // Test the arguments
    if(!pszOldName || !pszNewName || wcslen(pszNewName) > MAXLEN_NAME)
        return LINEERR_INVALPARAM;

    // Read the locations
    pLocationList = new CLocations();
    if(pLocationList==NULL)
    { 
        LOG((TL_ERROR, "Cannot allocate a CLocations object"));
        return LINEERR_NOMEM;
    }

    Result = pLocationList->Initialize();
    if(FAILED(Result))
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.Initialize() failed - HRESULT=0x%08lx", Result));
        return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_INIFILECORRUPT;
    }

    // find the specified location
    dwError = LINEERR_INVALPARAM;   // skeptical approach
    pLocationList->Reset();
    while(pLocationList->Next(1, &pLocation, NULL)==S_OK)
    {
        if(wcscmp(pLocation->GetName(), pszOldName)==0)
        {
            // found it, change it
            Result = pLocation->SetName(pszNewName);
            if(FAILED(Result))
            {
                delete pLocationList;
                LOG((TL_ERROR, "CLocations.SetName(Name) failed - HRESULT=0x%08lx", Result));
                return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
            }
            // save
            Result = pLocationList->SaveToRegistry();
            if(FAILED(Result))
            {
                delete pLocationList;
                LOG((TL_ERROR, "CLocations.SetName(Name) failed - HRESULT=0x%08lx", Result));
                return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
            }
            
            dwError = 0;

            break;
        }
    }

    delete pLocationList;

    return dwError;

}

#endif // !NORASPRIVATES



//***************************************************************************
//
//  Helper functions
//
//***************************************************************************

LONG BreakupCanonicalW( PWSTR  pAddressIn,
                        PWSTR  *pCountry,
                        PWSTR  *pCity,
                        PWSTR  *pSubscriber
                        )
{
    LONG  lResult = 0;
    PWSTR pCountryEnd;
    PWSTR pAreaEnd;


    //
    // Get past any (illegal) leading spaces
    //
    while ( *pAddressIn == L' ' )
    {
        pAddressIn++;
    }


    //
    // Leading zeros are very bad.  Don't allow them.
    // We're now at the first non-space.  Better not be a '0'.
    //
    if ( *pAddressIn == L'0' )
    {
        //
        // There are leading zeros!
        //
        LOG((TL_ERROR, "   Canonical numbers are not allowed to have leading zeros"));
        lResult = LINEERR_INVALADDRESS;
        goto cleanup;
    }


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    //
    // Parse the canonical number into its component pieces
    //

    //
    // Do country first
    //
    *pCountry = pAddressIn;

    // At least one digit must be present
    if(!(iswdigit(*pAddressIn)))
    {
        LOG((TL_ERROR, "   Canonical numbers must have a valid country code"));
        lResult = LINEERR_INVALADDRESS;
        goto cleanup;
    }

    //
    // Now get to past this
    //
    while (iswdigit(*pAddressIn) )
    {
          pAddressIn++;
    }

    // Save the end of the country code 
    pCountryEnd = pAddressIn;

    //
    // We hit something that's not a digit...
    // There must be only one space here, but we allow any number of spaces (including none)
    //
    while (*pAddressIn == L' ')
    {
        pAddressIn++;
    }

    // Test the area code delimiter
    if ( *pAddressIn == L'(')
    {
        pAddressIn++;

        // Skip any illegal spaces
        while (*pAddressIn == L' ')
        {
            pAddressIn++;
        }
/*
        // At least one digit must be present
        if(!(iswdigit(*pAddressIn)))
        {
            LOG((TL_ERROR, TEXT("   Canonical numbers must have a valid area code between ()")));
            lResult = LINEERR_INVALADDRESS;
            goto cleanup;
        }
*/
        //
        // This must be the beginning of the area code
        //
        *pCity = pAddressIn;

        //
        // Now get to past this
        //
        while (iswdigit(*pAddressIn) )
        {
            pAddressIn++;
        }

        // Save the end pointer
        pAreaEnd = pAddressIn;

        // Skip any illegal spaces
        while (*pAddressIn == L' ')
        {
            pAddressIn++;
        }

        if(*pAddressIn != L')')
        {
            LOG((TL_ERROR, "   Canonical numbers must have a ')' after the area code"));
            lResult = LINEERR_INVALADDRESS;
            goto cleanup;
        }

        pAddressIn++;

        *pAreaEnd = L'\0';

        // Return the same NULL string for an empty area code
        if(*pCity == pAreaEnd)
            *pCity = NULL;
        
    }
    else
    {
        // there's no area code
        *pCity = NULL;

    }

    // Skip spaces
    while (*pAddressIn == L' ')
    {
        pAddressIn++;
    }

    *pCountryEnd = L'\0';

    //
    // Nothing left to do but put the icing on the cake
    //
    *pSubscriber = pAddressIn;

    if (
        TAPIIsBadStringPtrW( *pSubscriber, 512 )
       ||
        lstrlenW( *pSubscriber ) == 0
       )
    {
        //
        // Obviously not canonical
        //
        LOG((TL_ERROR, "   Canonical numbers must have a subscriber number"));
        lResult = LINEERR_INVALADDRESS;
        goto cleanup;
    }


cleanup:

    return lResult;
}


static void LayDownString( PCWSTR   pInString,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair,     // this is the Len & Offset pair
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         )
{

#define LDS_FAST_BUF_SIZE 48

    DWORD   dwLength;
    PSTR    pTempString = NULL;
    char    achFastBuf[LDS_FAST_BUF_SIZE];
 
    if(bUnicode)
    {
        dwLength = (lstrlenW( pInString ) + 1)*sizeof(WCHAR);
    }
    else
    {


        dwLength = WideCharToMultiByte(
                        GetACP(),
                        0,
                        pInString,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL
                      );

        if (dwLength == 0)
        {
            return;
        }


    }

    
    // Make sure we're starting on some boundary
    //
    *ppCurrentIndex = (PBYTE) (((ULONG_PTR)( *ppCurrentIndex + TALIGN_COUNT))  &  (~TALIGN_COUNT));

    if(*ppCurrentIndex + dwLength <= pFirstByteAfter)
    {
        pPair[0] = dwLength;
        pPair[1] = (DWORD)(*ppCurrentIndex - pBuffer);

        if(bUnicode)
        {
            wcscpy( (PWSTR)*ppCurrentIndex, pInString );
        }
        else
        {
            //
            // Get some space in which to convert Unicode to local
            //
            pTempString = (dwLength > LDS_FAST_BUF_SIZE ?
                (PSTR)ClientAlloc (dwLength) : (PSTR) achFastBuf);


            if ( !pTempString )
            {
                pPair[0] = 0;
                pPair[1] = 0;
                return;
            }

            WideCharToMultiByte(
                               GetACP(),
                               0,
                               pInString,
                               -1,
                               pTempString,
                               dwLength,
                               NULL,
                               NULL
                             );

            lstrcpyA( (PSTR)*ppCurrentIndex, pTempString );

            if (pTempString != (PSTR) achFastBuf)
            {
                ClientFree (pTempString);
            }
        }
    }
    
    *ppCurrentIndex += dwLength;

}

static PWSTR    CopyStringWithExpandJAndK(PWSTR pszRule, PWSTR pszAccessNr, PWSTR pszAccountNr)
{
    DWORD   dwLength=0;
    PWSTR   pResult = NULL;

    PWCHAR  pCrt, pOut;
    WCHAR   c;

    DWORD   dwAccessNrLen, dwAccountNrLen;

    dwAccessNrLen = wcslen(pszAccessNr);
    dwAccountNrLen = wcslen(pszAccountNr);

    // Find the space to alloc
    pCrt = pszRule;
    
    while(*pCrt)
    {
        c = *pCrt++;

        if(c == L'J' || c == L'j')
        {
            dwLength += dwAccessNrLen;
        }
        else if (c == L'K' || c == L'k')
        {
            dwLength += dwAccountNrLen;
        }
        else
            dwLength++;
    }
    // WCHARs and NULL term
    dwLength = (dwLength+1)*sizeof(WCHAR);

    // Alloc
    pResult = (PWSTR)ClientAlloc(dwLength); // allocates zeroed memory
    if(pResult == NULL)
        return NULL;

    // Create result
    pCrt = pszRule;
    pOut = pResult;

    while(*pCrt)
    {
        c = *pCrt++;

        if(c == L'J' || c == L'j')
        {
            wcscat(pOut, pszAccessNr);
            pOut += dwAccessNrLen;
        }
        else if (c == L'K' || c == L'k')
        {
            wcscat(pOut, pszAccountNr);
            pOut += dwAccountNrLen;
        }
        else
            *pOut++ = c;
    }
 
    return pResult;
}


static  void   LayDownTollList(CLocation *pLocation,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair, 
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         )
{
    DWORD   dwLength;
    DWORD   dwTotalLength;
    DWORD   dwListLength;
    PBYTE   pDest;
    AreaCodeRulePtrNode     *pNode;
    PWSTR   pszLocationAreaCode;
    DWORD   dwCountryCode;
    BOOL    bFirst;
    CAreaCodeRule           *pRule;
    DWORD   dwIndex;


    pszLocationAreaCode = pLocation->GetAreaCode();
    dwCountryCode = pLocation->GetCountryCode();

    // Make sure we're starting on some boundary
    //
    *ppCurrentIndex = (PBYTE) (((ULONG_PTR)( *ppCurrentIndex + TALIGN_COUNT ))  &  (~TALIGN_COUNT));

    // Save the destination pointer
    pDest = *ppCurrentIndex;

    bFirst = TRUE;
    dwTotalLength = 0;

    // Only for US, Canada, Antigua etc.
    if(pLocation->GetCountryCode() == 1)
    {
        // Find all rules which could be considered toll rules
        pNode = pLocation->m_AreaCodeRuleList.head();

        while( !pNode->beyond_tail() )
        {
        
            pRule = pNode->value();

            if( IsATollListAreaCodeRule(pRule, pszLocationAreaCode)) 
            {
                // Get the size of the prefixes, in bytes
                dwListLength = pRule->GetPrefixListSize();

                if(bUnicode)
                {
                    WCHAR   *pCrt;
                    WCHAR   *pOut;
                    // we strip the last two nulls
                    dwLength = dwListLength - 2*sizeof(WCHAR);
                    // if this is not the first rule, a comma should be added
                    if(!bFirst)
                        dwLength += sizeof(WCHAR);
                    
                    dwTotalLength += dwLength;

                    // we have to convert the single nulls in commas
                    if(*ppCurrentIndex + dwLength  <= pFirstByteAfter)
                    {
                        
                        if(!bFirst)
                        {
                            *(WCHAR *)(*ppCurrentIndex) = L',';
                            *ppCurrentIndex += sizeof(WCHAR);
                        }

                        pCrt = pRule->GetPrefixList();

                        dwListLength /= sizeof(WCHAR);
                        dwListLength--;
                        dwListLength--;
                        // now dwListLength is the length in characters without the two ending nulls
                        // replace nulls with commas
                        for (dwIndex =0; dwIndex<dwListLength; dwIndex++)
                        {
                            if(*pCrt)
                                *(WCHAR *)(*ppCurrentIndex) = *pCrt;
                            else
                                *(WCHAR *)(*ppCurrentIndex) = L',';
                            pCrt++;
                            *ppCurrentIndex += sizeof(WCHAR);
                        }
                    }

                }
                else
                {
                    WCHAR   *pList;
                    
                    dwListLength /= sizeof(WCHAR);
                    dwListLength--;
                    dwListLength--;
                    // now dwListLength is the length in characters without the two ending nulls


                    // Length needed
                    pList = pRule->GetPrefixList();
                    dwLength = WideCharToMultiByte(
                                        GetACP(),
                                        0,
                                        pList,
                                        dwListLength,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL
                                        );

                    // if this is not the first rule, a comma should be added
                    if(!bFirst)
                        dwLength+=sizeof(CHAR);
                    
                    dwTotalLength += dwLength;

                    if(*ppCurrentIndex + dwLength  <= pFirstByteAfter)
                    {
                     
                        if(!bFirst)
                        {
                            *(CHAR *)(*ppCurrentIndex) = ',';
                            *ppCurrentIndex += sizeof(CHAR);

                            dwLength-=sizeof(CHAR); // temporary - the conversion and the null filling routines
                                                    // should'nt take into account the space for the separating comma

                        }
                        
                        // convert
                        WideCharToMultiByte(GetACP(),
                                            0,
                                            pList,
                                            dwListLength,
                                            (PSTR)(*ppCurrentIndex),
                                            dwLength,
                                            NULL,
                                            NULL
                                            );
                       
                        // Replace inplace the nulls with commas
                                           
                        for (dwIndex =0; dwIndex<dwLength; dwIndex++)
                        {
                            if(*(CHAR *)(*ppCurrentIndex)=='\0')
                                    *(CHAR *)(*ppCurrentIndex) = ',';

                            *ppCurrentIndex += sizeof(CHAR);
                        }

                        if(!bFirst)
                            dwLength+=sizeof(CHAR); // restore

                    }

                }

                bFirst = FALSE;
            }

            pNode = pNode->next();
        }

    }

    // space for a terminating NULL
    dwLength = bUnicode ? sizeof(WCHAR) : 1;
    
    dwTotalLength += dwLength;

    if(*ppCurrentIndex + dwLength <= pFirstByteAfter)
    {
        if(bUnicode)    
            *(WCHAR *)(*ppCurrentIndex) = L'\0';
        else
            *(CHAR *)(*ppCurrentIndex) = '\0';

        *ppCurrentIndex += dwLength;
        
        pPair[0] = (DWORD)(*ppCurrentIndex - pDest);
        pPair[1] = (DWORD)(pDest - pBuffer);
    }

    // Update the current pointer whatever the buffer size is
    *ppCurrentIndex = pDest + dwTotalLength;

}




static LONG
GetTranslateCapsCommon(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps,
    BOOL                bUnicode
    )
{

    LONG                lResult = 0; // good for HRESULTs too
    CLocations          *pLocationList = NULL; 
    CCallingCards       *pCardList = NULL;
    
    DWORD               dwNumLocations;
    DWORD               dwNumCards;

    DWORD               dwLenChar;

    CCallingCard        *pCard = NULL;
    CLocation           *pLocation;

    DWORD               dwTotalSize;
    DWORD               dwFinalSize;
    DWORD               dwLocationsSize;
    DWORD               dwLocationsStart;
    DWORD               dwCardsSize;
    DWORD               dwCardsStart;

    DWORD               dwCurrentLocationID;
    DWORD               dwPreferredCardID;
    DWORD               dwTempCardID;

    BOOL                bOldTapi;
    BOOL                bBufferTooSmall;

    LINELOCATIONENTRY   *pLineLocationEntry;
    LINECARDENTRY       *pLineCardEntry;
    PBYTE               pCurrentIndex;
    PBYTE               pCurrentIndexSave;
    PBYTE               pFirstByteAfter;

    DWORD               dwLocEntryLength;
    DWORD               dwCardEntryLength;

    DWORD               dwIndex;
    DWORD               dwAlignOffset;
    PLOCATIONLIST       pLocTest;


    lResult = IsThisAPIVersionInvalid( dwAPIVersion );
    if ( lResult )
    {
       LOG((TL_ERROR, "Bad dwAPIVersion - 0x%08lx", dwAPIVersion));
       return lResult;
    }

    if ( IsBadWritePtr(lpTranslateCaps, sizeof(DWORD)*3) )
    {
        LOG((TL_ERROR, "lpTranslateCaps not a valid pointer"));
        return LINEERR_INVALPOINTER;
    }

    if ( IsBadWritePtr(lpTranslateCaps, lpTranslateCaps->dwTotalSize) )
    {
        LOG((TL_ERROR, "lpTranslateCaps not a valid pointer (dwTotalSize)"));
        return LINEERR_INVALPOINTER;
    }

    LOG((TL_INFO, "lpTranslateCaps->dwTotalSize = %d",lpTranslateCaps->dwTotalSize));

    if ( lpTranslateCaps->dwTotalSize < sizeof(LINETRANSLATECAPS))
    {
        LOG((TL_ERROR, "Not even enough room for the fixed portion"));
        return LINEERR_STRUCTURETOOSMALL;
    }

    // Let TAPISRV test the params for us
    lResult = ReadLocations(&pLocTest,
                            hLineApp,
                            0,
                            dwAPIVersion,
                            CHECKPARMS_DWHLINEAPP|
                            CHECKPARMS_DWAPIVERSION|
                            CHECKPARMS_ONLY);

    if (pLocTest != NULL)
    {
        ClientFree( pLocTest);
    }
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    // Read the location list
    pLocationList = new CLocations();
    if(pLocationList==NULL)
    {
        LOG((TL_ERROR, "Cannot allocate a CLocations object"));
        return LINEERR_NOMEM;
    }

    lResult = pLocationList->Initialize();
    if(lResult != ERROR_SUCCESS)
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.Initialize() failed - HRESULT=0x%08lx", lResult));
        return lResult == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_INIFILECORRUPT;
    }

    // Read the calling card list
    pCardList = new CCallingCards();
    if(pCardList==NULL)
    {
        delete pLocationList;
        LOG((TL_ERROR, "Cannot allocate a CCallingCards object"));
        return LINEERR_NOMEM;
    }

    lResult = pCardList->Initialize();
    if(lResult != ERROR_SUCCESS)
    {
        delete pCardList;
        delete pLocationList;
        LOG((TL_ERROR, "CCallingCards.Initialize() failed - HRESULT=0x%08lx", lResult));
        return lResult == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
    }

    // The char length in bytes depends on bUnicode
    dwLenChar = bUnicode ? sizeof(WCHAR) : sizeof(CHAR);
    // The structures for TAPI<=1.3 ar smaller
    bOldTapi = (dwAPIVersion<0x00010004);

    dwLocEntryLength = (DWORD)(bOldTapi ? 7*sizeof(DWORD) : sizeof(LINELOCATIONENTRY));
    dwCardEntryLength = (DWORD)(bOldTapi ? 3*sizeof(DWORD) : sizeof(LINECARDENTRY));

    dwNumLocations = pLocationList->GetNumLocations();
    dwNumCards = pCardList->GetNumCards();

    dwCurrentLocationID = pLocationList->GetCurrentLocationID();
    dwPreferredCardID = 0;
    // Size provided by the caller  
    dwTotalSize = lpTranslateCaps->dwTotalSize;
    // First byte after the buffer provided by the caller
    pFirstByteAfter = (PBYTE)lpTranslateCaps + dwTotalSize;
    bBufferTooSmall = FALSE;

    dwLocationsStart = sizeof(LINETRANSLATECAPS);
    // The size of the locations part
    dwLocationsSize = dwNumLocations * dwLocEntryLength;
    // The strings included in locations are stored after the array of LINELOCATIONENTRY structures
    pCurrentIndex = ((PBYTE)lpTranslateCaps)+
                        dwLocationsStart + 
                        dwLocationsSize;

    // do the first pointer alignment here. This initial offset will help at the end
    pCurrentIndexSave = pCurrentIndex;
    pCurrentIndex = (PBYTE) (((ULONG_PTR)( pCurrentIndex + TALIGN_COUNT ))  &  (~TALIGN_COUNT));
    dwAlignOffset = (DWORD)(pCurrentIndex - pCurrentIndexSave);

    // Test the space for the array
    if(pCurrentIndex > pFirstByteAfter)
        bBufferTooSmall = TRUE;

    // First, process the locations
    pLocationList->Reset();
    dwIndex = 0;
    while(S_OK==pLocationList->Next(1, &pLocation, NULL))
    {
        pLineLocationEntry = (LINELOCATIONENTRY *)(((PBYTE)lpTranslateCaps)+dwLocationsStart+dwIndex*dwLocEntryLength);
        
        // string values
        LayDownString(  pLocation->GetName(),
                        (PBYTE)lpTranslateCaps,
                        &pCurrentIndex,
                        &pLineLocationEntry->dwLocationNameSize,
                        bUnicode,
                        pFirstByteAfter
                        );
        
        LayDownString(  pLocation->GetAreaCode(),
                        (PBYTE)lpTranslateCaps,
                        &pCurrentIndex,
                        &pLineLocationEntry->dwCityCodeSize,
                        bUnicode,
                        pFirstByteAfter
                        );

        
        if(!bOldTapi)
        {
            LayDownString(  pLocation->GetLocalAccessCode(),
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwLocalAccessCodeSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            LayDownString(  pLocation->GetLongDistanceAccessCode(),
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwLongDistanceAccessCodeSize,
                            bUnicode,
                            pFirstByteAfter
                            );
            // Toll list
            LayDownTollList(pLocation,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwTollPrefixListSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            LayDownString(  pLocation->GetDisableCallWaitingCode(),
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwCancelCallWaitingSize,
                            bUnicode,
                            pFirstByteAfter
                            );

        }

        if(pLocation->HasCallingCard())
        {
           dwTempCardID = pLocation->GetPreferredCardID();
            // Extract the preferred calling card if current location
            if(pLocation->GetLocationID() == dwCurrentLocationID)
                dwPreferredCardID = dwTempCardID;
        }
        else
            dwTempCardID =0;
   
        //Other non string values
        if(!bBufferTooSmall)
        {
            
            pLineLocationEntry->dwPermanentLocationID = pLocation->GetLocationID();
            
            pLineLocationEntry->dwPreferredCardID = dwTempCardID;

            pLineLocationEntry->dwCountryCode = pLocation->GetCountryCode();

            if(!bOldTapi)
            {
                pLineLocationEntry->dwCountryID = pLocation->GetCountryID();
                pLineLocationEntry->dwOptions = pLocation->HasToneDialing() ? 0 : LINELOCATIONOPTION_PULSEDIAL;
            }
        }

        dwIndex++;
    }

    // Align the pointer
    pCurrentIndex = (PBYTE) (((ULONG_PTR)( pCurrentIndex + TALIGN_COUNT ))  &  (~TALIGN_COUNT));

    // Process the cards
    dwCardsStart = (DWORD)(pCurrentIndex - ((PBYTE)lpTranslateCaps));
    // The size of the cards part
    dwCardsSize = dwCardEntryLength * dwNumCards;

    pCurrentIndex += dwCardsSize;
    // Test the space for the array
    if(pCurrentIndex > pFirstByteAfter)
        bBufferTooSmall = TRUE;

    // including the hidden cards
    pCardList->Reset(TRUE);
    dwIndex = 0;
    while(S_OK==pCardList->Next(1, &pCard, NULL))
    {
        PWSTR   pszTemp = NULL;
        
        pLineCardEntry = (LINECARDENTRY *)(((PBYTE)lpTranslateCaps)+dwCardsStart+dwIndex*dwCardEntryLength);
        
        // String values
        LayDownString(  pCard->GetCardName(),
                        (PBYTE)lpTranslateCaps,
                        &pCurrentIndex,
                        &pLineCardEntry->dwCardNameSize,
                        bUnicode,
                        pFirstByteAfter
                        );
        if(!bOldTapi)
        {
            // Convert rules to old format (w/o J and K spec)    
            pszTemp = CopyStringWithExpandJAndK(pCard->GetLocalRule(), 
                                                pCard->GetLocalAccessNumber(),
                                                pCard->GetAccountNumber());
            if(pszTemp==NULL)
            {
                delete pCardList;
                delete pLocationList;
                LOG((TL_ERROR, "CopyStringWithExpandJAndK failed to allocate memory"));
                return LINEERR_NOMEM;
            }

            LayDownString(  pszTemp,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineCardEntry->dwSameAreaRuleSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            ClientFree(pszTemp);

            LOG((TL_INFO, "About to do CopyStringWithExpandJAndK"));
            pszTemp = CopyStringWithExpandJAndK(   pCard->GetLongDistanceRule(),
                                                   pCard->GetLongDistanceAccessNumber(),
                                                   pCard->GetAccountNumber() );
            LOG((TL_INFO, "Did CopyStringWithExpandJAndK"));

            if(pszTemp==NULL)
            {
                delete pCardList;
                delete pLocationList;
                LOG((TL_ERROR, "CopyStringWithExpandJAndK failed to allocate memory"));
                return LINEERR_NOMEM;
            }

            LayDownString(  pszTemp,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineCardEntry->dwLongDistanceRuleSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            ClientFree(pszTemp);
           
            pszTemp = CopyStringWithExpandJAndK(pCard->GetInternationalRule(),
                                                pCard->GetInternationalAccessNumber(),
                                                pCard->GetAccountNumber());
            if(pszTemp==NULL)
            {
                delete pCardList;
                delete pLocationList;
                LOG((TL_ERROR, "CopyStringWithExpandJAndK failed to allocate memory"));
                return LINEERR_NOMEM;
            }

            LayDownString(  pszTemp,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineCardEntry->dwInternationalRuleSize,
                            bUnicode,
                            pFirstByteAfter
                            );
            
            ClientFree(pszTemp);
        }

        // Other non-string fields
        if(!bBufferTooSmall)
        {
            pLineCardEntry->dwPermanentCardID = pCard->GetCardID();

            if(!bOldTapi)
            {
                pLineCardEntry->dwCardNumberDigits = wcslen(pCard->GetPIN());
                pLineCardEntry->dwOptions = (pCard->IsMarkedPermanent() ? LINECARDOPTION_PREDEFINED : 0)
                                          | (pCard->IsMarkedHidden() ?  LINECARDOPTION_HIDDEN : 0);
            }

        }

        dwIndex++;
    }

    dwFinalSize = (DWORD)(pCurrentIndex - (PBYTE)lpTranslateCaps);

    //   Uhh, the goal is to have the same needed size whatever the alignment of the lpTranslateCaps is..
    //   A nongoal is to provide similar returned content (in terms of alignments, pads etc) for 
    // different alignment of lpTranslateCaps
    //   
    dwFinalSize += (TALIGN_COUNT - dwAlignOffset);

    
    if(dwFinalSize>dwTotalSize)
    {
        lpTranslateCaps->dwUsedSize   = sizeof (LINETRANSLATECAPS);
        // Fix for alignment problems
        lpTranslateCaps->dwNeededSize = dwFinalSize;

        ZeroMemory(
            &lpTranslateCaps->dwNumLocations,
            dwTotalSize - 3 * sizeof (DWORD)
            );
        lpTranslateCaps->dwCurrentLocationID = dwCurrentLocationID;
        lpTranslateCaps->dwCurrentPreferredCardID = dwPreferredCardID;

        LOG((TL_ERROR, "Buffer too small"));
        LOG((TL_ERROR, "lpTranslateCaps->dwTotalSize = %d",lpTranslateCaps->dwTotalSize));
        LOG((TL_ERROR, "lpTranslateCaps->dwNeededSize = %d",lpTranslateCaps->dwNeededSize));


    }
    else
    {
        lpTranslateCaps->dwUsedSize   = dwFinalSize;
        lpTranslateCaps->dwNeededSize = dwFinalSize;


        lpTranslateCaps->dwNumLocations = dwNumLocations;
        lpTranslateCaps->dwNumCards = dwNumCards;
        lpTranslateCaps->dwCurrentLocationID = dwCurrentLocationID;

        lpTranslateCaps->dwLocationListOffset = dwLocationsStart;
        lpTranslateCaps->dwLocationListSize = dwLocationsSize;

        lpTranslateCaps->dwCardListOffset = dwCardsStart;
        lpTranslateCaps->dwCardListSize = dwCardsSize;

        lpTranslateCaps->dwCurrentPreferredCardID = dwPreferredCardID;

        LOG((TL_INFO, "Buffer OK"));
        LOG((TL_INFO, "lpTranslateCaps->dwTotalSize = %d",lpTranslateCaps->dwTotalSize));
        LOG((TL_INFO, "lpTranslateCaps->dwNeededSize = %d",lpTranslateCaps->dwNeededSize));
    }

    delete pCardList;
    delete pLocationList;

    return 0;
}


static  BOOL    FindTollPrefixInLocation(CLocation *pLocation,
                                         PWSTR  pPrefix,
                                         CAreaCodeRule **ppRule, 
                                         PWSTR *ppWhere)
{
    BOOL    bPrefixFound = FALSE;
    AreaCodeRulePtrNode     *pNode;
    CAreaCodeRule           *pCrtRule = NULL;
    PWSTR                   pLocationAreaCode;
    PWSTR                   pWhere;

    pLocationAreaCode = pLocation->GetAreaCode();

    // Enumerate the area code rules
    // If a rule is appropriate for a toll list, we search the prefix
    pNode = pLocation->m_AreaCodeRuleList.head();

    while( !pNode->beyond_tail() )
    {
        pCrtRule = pNode->value();

        if(IsATollListAreaCodeRule(pCrtRule, pLocationAreaCode))
        { 
            // Set this even we don't find the prefix.
            // The caller could be interested in the presence of toll rules
            *ppRule = pCrtRule;
            // Try to find the prefix
            pWhere = FindPrefixInMultiSZ(pCrtRule->GetPrefixList(), pPrefix);
            if(pWhere)
            {
                *ppWhere = pWhere;
                return TRUE;
            }

        }
        pNode = pNode->next();
    }

    return FALSE;
}





static BOOL IsATollListAreaCodeRule(CAreaCodeRule *pRule, PWSTR pszLocationAreaCode)
{
    // conditions for toll rules:
    //
    // location.Country code == 1 (to be tested outside) AND
    // Area Code to dial == Current Area Code AND
    // NumberToDial == 1   AND
    // BeforeDialingDialNumberToDial == TRUE AND
    // BeforeDialingDialAreaCode == TRUE AND
    // IncludeAllPrefixesForThisAreaCode == FALSE
    return  pRule->HasDialNumber() 
         && !pRule->HasAppliesToAllPrefixes()
         && pRule->HasDialAreaCode()
         && 0==wcscmp(pszLocationAreaCode, pRule->GetAreaCode()) 
         && 0==wcscmp(pRule->GetNumberToDial(), L"1") 
             ;
}

static PWSTR FindPrefixInMultiSZ(PWSTR pPrefixList, PWSTR pPrefix)
{

    PWSTR   pCrt;
    PWSTR   pListCrt;
    PWSTR   pStart;

    pListCrt = pPrefixList;

    while(TRUE)
    {
        pCrt = pPrefix;
        pStart = pListCrt;

        while(*pCrt == *pListCrt)
        {
            if(!*pCrt)
                // found
                return pStart;

            pCrt++;
            pListCrt++;
        }
        
        while(*pListCrt++);

        if(!*pListCrt)
            // not found
            return NULL;
    }    

}




/****************************************************************************

 Function : CreateCurrentLocationObject

****************************************************************************/
LONG CreateCurrentLocationObject(CLocation **pLocation,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions)
{
    PLOCATIONLIST   pLocationList = NULL;
    
    PLOCATION       pEntry = NULL;
    PWSTR           pszLocationName = NULL;            
    PWSTR           pszAreaCode = NULL;
    PWSTR           pszLongDistanceCarrierCode = NULL;         
    PWSTR           pszInternationalCarrierCode = NULL;         
    PWSTR           pszLocalAccessCode = NULL;         
    PWSTR           pszLongDistanceAccessCode = NULL;  
    PWSTR           pszCancelCallWaitingCode = NULL;   
    DWORD           dwPermanentLocationID = 0;   
    CLocation     * pNewLocation = NULL;
    
    PAREACODERULE   pAreaCodeRuleEntry = NULL;
    PWSTR           pszNumberToDial = NULL;
    PWSTR           pszzPrefixesList = NULL;
    DWORD           dwNumRules = 0; 
    CAreaCodeRule * pAreaCodeRule = NULL;

    DWORD           dwCount = 0;
    DWORD           dwNumEntries = 0;
    DWORD           dwCurrentLocationID = 0;

    HRESULT         hr;

    
    // Let TAPISRV test the params for us
    hr = ReadLocations(&pLocationList,       
                       hLineApp,                   
                       dwDeviceID,                   
                       dwAPIVersion,                  
                       dwOptions      
                      );

    if SUCCEEDED( hr) 
    {
        hr = E_FAIL;  // fail if we don't find the current loc

        // current location
        dwCurrentLocationID  = pLocationList->dwCurrentLocationID;   
         
        // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
        pEntry = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           

        // Number of locations ?
        dwNumEntries =  pLocationList->dwNumLocationsInList;

        // Find the current location
        for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
        {
    
            if(pEntry->dwPermanentLocationID == dwCurrentLocationID)
            {
                hr = S_OK;
                break;
            }

            // Try next location in list
            //pEntry++;
            pEntry = (PLOCATION) ((BYTE*)(pEntry) + pEntry->dwUsedSize);           

        }
        if SUCCEEDED( hr) 
        {
            LOG((TL_INFO, "CreateCurrentLocationObject - current location found %d",
                    dwCurrentLocationID));

            // Pull Location Info out of LOCATION structure
            pszLocationName           = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocationNameOffset);
            pszAreaCode               = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwAreaCodeOffset);
            pszLongDistanceCarrierCode= (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceCarrierCodeOffset);
            pszInternationalCarrierCode= (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwInternationalCarrierCodeOffset);
            pszLocalAccessCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocalAccessCodeOffset);
            pszLongDistanceAccessCode = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceAccessCodeOffset);
            pszCancelCallWaitingCode  = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwCancelCallWaitingOffset);
        
        
            // create our new Location Object                
            pNewLocation = new CLocation;
            if (pNewLocation)
            {
                // initialize the new Location Object
                hr = pNewLocation->Initialize(
                                            pszLocationName, 
                                            pszAreaCode,
                                            pszLongDistanceCarrierCode,
                                            pszInternationalCarrierCode,
                                            pszLongDistanceAccessCode, 
                                            pszLocalAccessCode, 
                                            pszCancelCallWaitingCode , 
                                            pEntry->dwPermanentLocationID,
                                            pEntry->dwCountryID,
                                            pEntry->dwPreferredCardID,
                                            pEntry->dwOptions
                                            );
                    
                if( SUCCEEDED(hr) )
                {
                    // Find position of 1st AREACODERULE structure in the LOCATIONLIST structure 
                    pAreaCodeRuleEntry = (PAREACODERULE) ((BYTE*)(pEntry) 
                                                          + pEntry->dwAreaCodeRulesListOffset );           
                   
                    dwNumRules = pEntry->dwNumAreaCodeRules;           
                
                    for (dwCount = 0; dwCount != dwNumRules; dwCount++)
                    {
                        // Pull Rule Info out of AREACODERULE structure
                        pszAreaCode      = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwAreaCodeOffset);
                        pszNumberToDial  = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwNumberToDialOffset);
                        pszzPrefixesList = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwPrefixesListOffset);
        
                        // create our new AreaCodeRule Object                
                        pAreaCodeRule = new CAreaCodeRule;
                        if (pAreaCodeRule)
                        {
                            // initialize the new AreaCodeRule Object
                            hr = pAreaCodeRule->Initialize ( pszAreaCode,
                                                             pszNumberToDial,
                                                             pAreaCodeRuleEntry->dwOptions,
                                                             pszzPrefixesList, 
                                                             pAreaCodeRuleEntry->dwPrefixesListSize
                                                           );
                            if( SUCCEEDED(hr) )
                            {
                                pNewLocation->AddRule(pAreaCodeRule);
                            }
                            else // rule initialization failed
                            {
                                delete pAreaCodeRule;
                                LOG((TL_ERROR, "CreateCurrentLocationObject - rule create failed"));
                            }
                        } 
                        else // new CAreaCodeRule failed
                        {
                            LOG((TL_ERROR, "CreateCurrentLocationObject - rule create failed"));
                        }
    
                        // Try next rule in list
                        pAreaCodeRuleEntry++;
                        
                    }
                }
                else // location initialize failed
                {
                    delete pNewLocation;
                    pNewLocation = NULL;
    
                    LOG((TL_ERROR, "CreateCurrentLocationObject - location create failed"));
                    hr =LINEERR_OPERATIONFAILED;
                    // hr = E_FAIL;
                }
            }
            else // new CLocation failed
            {
                LOG((TL_ERROR, "CreateCurrentLocationObject - location create failed"));
                hr = LINEERR_NOMEM;
                //hr = E_OUTOFMEMORY;
    
            }
        }
        else
        {
            LOG((TL_ERROR, "CreateCurrentLocationObject - current location not found"));
            hr =LINEERR_OPERATIONFAILED;
            //hr = E_FAIL;
        }
    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "CreateCurrentLocationObject - ReadLocation create failed"));
        // hr = E_FAIL;
    }

    // finished with TAPI memory block so release
    if ( pLocationList != NULL )
            ClientFree( pLocationList );


    *pLocation = pNewLocation;
    return hr;
}    



/****************************************************************************

 Function : CreateCountryObject

****************************************************************************/

HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry)
{
    LPLINECOUNTRYLIST_INTERNAL   pCountryList = NULL;
    
    LPLINECOUNTRYENTRY_INTERNAL  pEntry = NULL;
    PWSTR               pszCountryName = NULL;          
    PWSTR               pszInternationalRule = NULL;     
    PWSTR               pszLongDistanceRule = NULL;     
    PWSTR               pszLocalRule = NULL;            
    CCountry          * pCountry = NULL;
    
    DWORD               dwCount = 0;
    DWORD               dwNumEntries = 0;
    LONG                lResult;
    HRESULT             hr;
    


    lResult = ReadCountriesAndGroups( &pCountryList, dwCountryID, 0);
    if (lResult == 0) 
    {
         
        // Find position of 1st LINECOUNTRYENTRY structure in the LINECOUNTRYLIST structure 
        pEntry = (LPLINECOUNTRYENTRY_INTERNAL) ((BYTE*)(pCountryList) + pCountryList->dwCountryListOffset );           
        // Pull Country Info out of LINECOUNTRYENTRY structure
        pszCountryName       = (PWSTR) ((BYTE*)(pCountryList) 
                                               + pEntry->dwCountryNameOffset);
        pszInternationalRule = (PWSTR) ((BYTE*)(pCountryList) 
                                               + pEntry->dwInternationalRuleOffset);
        pszLongDistanceRule  = (PWSTR) ((BYTE*)(pCountryList) 
                                             + pEntry->dwLongDistanceRuleOffset);
        pszLocalRule         = (PWSTR) ((BYTE*)(pCountryList) 
                                               + pEntry->dwSameAreaRuleOffset);
    
    
        // create our new CCountry Object                
        pCountry = new CCountry;
        if (pCountry)
        {
            // initialize the new CCountry Object
            hr = pCountry->Initialize(pEntry->dwCountryID,
                                      pEntry->dwCountryCode,
                                      pEntry->dwCountryGroup,
                                      pszCountryName,
                                      pszInternationalRule,
                                      pszLongDistanceRule,
                                      pszLocalRule
                                     );

            if( SUCCEEDED(hr) )
            {
                *ppCountry = pCountry;
            }
            else // country initialization failed
            {
                delete pCountry;
                LOG((TL_ERROR, "CreateCountryObject - country create failed"));
            }
        } 
        else // new CCountry failed
        {
            LOG((TL_ERROR, "CreateCountryObject - country create failed"));
        }

    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "CreateCountryObject - ReadCountries failed"));
        hr = E_FAIL;
    }

    // finished with TAPI memory block so release
    if ( pCountryList != NULL )
    {
        ClientFree( pCountryList );
    }

    return hr;
    

}    

/****************************************************************************

 Function : ReadLocations

****************************************************************************/
HRESULT ReadLocations( PLOCATIONLIST *ppLocationList,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions
                     )
{
    HRESULT     hr = S_OK;
    long        lResult;
    DWORD       dwSize = sizeof(LOCATIONLIST) + 500;

    
    *ppLocationList = (PLOCATIONLIST) ClientAlloc( dwSize );

    if (NULL == *ppLocationList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppLocationList)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, tReadLocations),

        {
            (ULONG_PTR)hLineApp,
            (ULONG_PTR)dwDeviceID,
            (ULONG_PTR)dwAPIVersion,
            (ULONG_PTR)dwOptions,
            (ULONG_PTR)*ppLocationList     // (DWORD) pLocationSpace
        },

        {
            hXxxApp_NULLOK,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult =  (DOFUNC (&funcArgs, "TReadLocations"));
    
        if ((lResult == 0) && ((*ppLocationList)->dwNeededSize > (*ppLocationList)->dwTotalSize))
        {
            // Didn't Work , adjust buffer size & try again    
            LOG((TL_ERROR, "ReadLocations failed - buffer too small"));
            dwSize = (*ppLocationList)->dwNeededSize;
    
            ClientFree( *ppLocationList );
    
            *ppLocationList = (PLOCATIONLIST) ClientAlloc( dwSize );
            if (*ppLocationList == NULL)
            {
                LOG((TL_ERROR, "ReadLocations failed - repeat ClientAlloc failed"));
                hr =  E_OUTOFMEMORY;
                break;
            }
            else
            {
                (*ppLocationList)->dwTotalSize = dwSize;
                funcArgs.Args[4] = (ULONG_PTR)*ppLocationList;
            }
        }
        else
        {
            hr = (HRESULT)lResult;    
            break;
        }
    } // end while(TRUE)

    
    
    return hr;

}

/****************************************************************************

 Function : WriteLocations

****************************************************************************/
    
LONG PASCAL  WriteLocations( PLOCATIONLIST  pLocationList,
                             DWORD      dwChangedFlags
                           )
{
    PSTR     pString;
    UINT  n;
    LONG  lResult;


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, tWriteLocations),
        {
            (ULONG_PTR)pLocationList->dwNumLocationsInList,
            (ULONG_PTR)dwChangedFlags,
            (ULONG_PTR)pLocationList->dwCurrentLocationID,
            (ULONG_PTR)pLocationList
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    lResult =  (DOFUNC (&funcArgs, "TWriteLocations"));

    return lResult;
}



/****************************************************************************

 Function : ReadCountries

****************************************************************************/
LONG PASCAL ReadCountries( LPLINECOUNTRYLIST *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         )
{
    LONG lTapiResult;
    UINT nBufSize = 0x8000;   //Start with a buffer of 16K
    UINT n;
    LPLINECOUNTRYLIST pNewLCL;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountry),

        {
            0,
            TAPI_VERSION_CURRENT,
            (ULONG_PTR)dwDestCountryID,
            0
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    //
    // Try until success or the buffer is huge
    //
    for ( lTapiResult = 1, n = 0;
          lTapiResult && (n < 5);
          n++ )
    {

        pNewLCL = (LPLINECOUNTRYLIST)ClientAlloc( nBufSize );

        if(!pNewLCL)
            return LINEERR_NOMEM;


        pNewLCL->dwTotalSize = nBufSize;


        //
        // Put new values in structure for TAPISRV
        //
        funcArgs.Args[0] = (ULONG_PTR)nCountryID;
        funcArgs.Args[3] = (ULONG_PTR)pNewLCL;


        //
        // Call TAPISRV to get the country list
        //
        lTapiResult =  DOFUNC (&funcArgs, "lineGetCountry");


        //
        // If the call succeeded, but the buffer was too small, or if the
        // call failed, do it again...
        //
        if (
              (lTapiResult == LINEERR_STRUCTURETOOSMALL)
            ||
              (pNewLCL->dwNeededSize > nBufSize)
           )
        {
            //
            // Complain to anyone who'll listen that this should be tuned
            // to start with a larger buffer so we don't have to do this multiple
            // times....
            //
            LOG((TL_ERROR, "  TUNING PROBLEM: We're about to call lineGetCountry()"));
            LOG((TL_ERROR, "                  _again_ because the buffer wasn't big enough"));
            LOG((TL_ERROR, "                  the last time.  FIX THIS!!!  (0x%lx)", nBufSize));


            lTapiResult = 1; // Force error condition if size was bad...
            nBufSize += 0x4000;  // Try a bit bigger
            ClientFree( pNewLCL );
        }
        else
        {
           //
           // We didn't work for some other reason
           //
           break;
        }
    }

    *ppLCL = pNewLCL;

    return lTapiResult;
}

/****************************************************************************

 Function : ReadCountriesAndGroups

****************************************************************************/
LONG PASCAL ReadCountriesAndGroups( LPLINECOUNTRYLIST_INTERNAL *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         )
{
    LPLINECOUNTRYLIST_INTERNAL  pLCL = NULL;
    LPLINECOUNTRYENTRY_INTERNAL pLCountry;
    LONG                        lResult;
    LPDWORD                     pCountryIDs;
    FUNC_ARGS                   funcArgs =
    {   
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountryGroup),
        {
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0
        },

        {
            lpSet_SizeToFollow,
            Size,
            lpGet_SizeToFollow,
            Size
        }
    };

    //
    // read the countries
    //
    lResult = ReadCountries( (LPLINECOUNTRYLIST *)&pLCL, nCountryID, dwDestCountryID );
    if (lResult)
    {
        LOG((TL_ERROR, "ReadCountriesAndGroups: ReadCountries failed with %d", lResult));
        return lResult;        

    }
    
    //
    // create the array of country IDs
    //
    pCountryIDs = (LPDWORD)ClientAlloc( sizeof(DWORD) * pLCL->dwNumCountries );
    if(!pCountryIDs)
    {
        ClientFree( pLCL );
        return LINEERR_NOMEM;
    }
    
    pLCountry = (LPLINECOUNTRYENTRY_INTERNAL) ((LPBYTE)pLCL + pLCL->dwCountryListOffset);
    for( DWORD dwIdx = 0; dwIdx < pLCL->dwNumCountries; dwIdx++, pLCountry++ )
    {
        *(pCountryIDs + dwIdx) = pLCountry->dwCountryID;
    }
    
    funcArgs.Args[0] = funcArgs.Args[2] = (ULONG_PTR)pCountryIDs;
    funcArgs.Args[1] = funcArgs.Args[3] = (ULONG_PTR)(sizeof(DWORD) * pLCL->dwNumCountries);

    //
    // Call TAPISRV to get the country groups
    // At return pCountryIDs will have the country groups
    //
    lResult =  DOFUNC (&funcArgs, "lineGetCountryGroups");

    if (lResult)
    {
        LOG((TL_TRACE, "ReadCountriesAndGroups: lineGetCountryGroups failed with %d", lResult));
        //
        // consider all the country groups undefined (0)
        //
        memset( pCountryIDs, 0, sizeof(DWORD) * pLCL->dwNumCountries );

        lResult = ERROR_SUCCESS;
    }
    
    pLCountry = (LPLINECOUNTRYENTRY_INTERNAL) ((LPBYTE)pLCL + pLCL->dwCountryListOffset);
    for( DWORD dwIdx = 0; dwIdx < pLCL->dwNumCountries; dwIdx++, pLCountry++ )
    {
        pLCountry->dwCountryGroup = *(pCountryIDs + dwIdx);
    }

    *ppLCL = pLCL;
    ClientFree( pCountryIDs );
    return lResult;
}


//***************************************************************************
//   Returns LONG_DISTANCE_CARRIER_MANDATORY if rule contains an 'L' or 'l' 
//          (ie long distance carrier code - mandatory),
//   Returns LONG_DISTANCE_CARRIER_OPTIONAL if rule contains an 'N' or 'n'
//          (ie long distance carrier code - optional),
//   Returns LONG_DISTANCE_CARRIER_NONE if rule contains neither
//
int IsLongDistanceCarrierCodeRule(LPWSTR lpRule)
{
   WCHAR c;

   while ((c = *lpRule++) != '\0')
   {
      if (c == 'L' || c == 'l') return LONG_DISTANCE_CARRIER_MANDATORY;
      if (c == 'N' || c == 'n') return LONG_DISTANCE_CARRIER_OPTIONAL;
   }
   return LONG_DISTANCE_CARRIER_NONE;
}


//***************************************************************************
//   Returns INTERNATIONAL_CARRIER_MANDATORY if rule contains an 'M' or 'm' 
//          (ie international carrier code - mandatory),
//   Returns INTERNATIONAL_CARRIER_OPTIONAL if rule contains an 'S' or 's' 
//          (ie international carrier code - optional),
//   Returns INTERNATIONAL_CARRIER_NONE if rule contains neither
//
int IsInternationalCarrierCodeRule(LPWSTR lpRule)
{
   WCHAR c;

   while ((c = *lpRule++) != '\0')
   {
      if (c == 'M' || c == 'm') return INTERNATIONAL_CARRIER_MANDATORY;
      if (c == 'S' || c == 's') return INTERNATIONAL_CARRIER_OPTIONAL;
   }
   return INTERNATIONAL_CARRIER_NONE;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
//   Returns CITY_MANDATORY if rule contains an F (ie city code mandatory),
//   Returns CITY_OPTIONAL if rule contains an I (ie city code optional)
//   Returns CITY_NONE if rule contains neither
//
int IsCityRule(LPWSTR lpRule)
{
   WCHAR c;

   while ((c = *lpRule++) != '\0')
   {
      if (c == 'F') return CITY_MANDATORY;
      if (c == 'I') return CITY_OPTIONAL;
   }
   return CITY_NONE;
}


// Initializes/uninitializes the defined node pools based on the templates from list.h
//

void ListNodePoolsInitialize(void)
{
    NodePool<CCallingCard *>::initialize();
    NodePool<CCountry *>::initialize();
    NodePool<CLocation *>::initialize();
    NodePool<CAreaCodeRule*>::initialize();
}



void ListNodePoolsUninitialize(void)
{
    NodePool<CCallingCard *>::uninitialize();
    NodePool<CCountry *>::uninitialize();
    NodePool<CLocation *>::uninitialize();
    NodePool<CAreaCodeRule*>::uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\drv.h ===
/*--------------------------------------------------------------------------*\
   Include File:  drv.h

   Public header for dealing with service prodivers, or drivers in english

   Copyright (c) 1995-1999 Microsoft Corporation
      
\*--------------------------------------------------------------------------*/

#ifndef  PH_DRV
#define  PH_DRV

#include <tapi.h>

//----------            
// Constants
//----------
#define TAPI_VERSION               0x00010004
#define INITIAL_PROVIDER_LIST_SIZE 1024
//#define INITIAL_PROVIDER_LIST_SIZE sizeof(LINEPROVIDERLIST)



//----------------------------
// Public Function Prototypes
//----------------------------
BOOL RemoveSelectedDriver( HWND hwndParent, HWND hwndList );
BOOL FillDriverList(  HWND hwndList );
BOOL SetupDriver( HWND hwndParent, HWND hwndList );
VOID UpdateDriverDlgButtons( HWND hwnd );
INT_PTR AddDriver_DialogProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam );


#define CPL_MAX_STRING  132      // biggest allowed string


#endif   // PH_DRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\location.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  location.cpp
                                                              
     Abstract:  Location Object implementation
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#include <windows.h>
#include <objbase.h>

#include "tapi.h"
#include "tspi.h"
#include "client.h"
#include "location.h"
#include "clntprivate.h"
#include "countrygroup.h"
#include <strsafe.h>

#define MaxDialStringSize 500

LONG PASCAL ReadCountries( LPLINECOUNTRYLIST *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         );

HRESULT ReadLocations( PLOCATIONLIST *ppLocationList,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions
                     );
LONG PASCAL  WriteLocations( PLOCATIONLIST  pLocationList,
                             DWORD      dwChangedFlags
                           );

LONG BreakupCanonicalW( PWSTR  pAddressIn,
                       PWSTR  *pCountry,
                       PWSTR  *pCity,
                       PWSTR  *pSubscriber
                       );


DWORD TapiPackString(LPBYTE pStructure, 
                     DWORD dwOffset,
                     DWORD dwTotalSize,
                     PWSTR pszString,
                     PDWORD pdwOffset,
                     PDWORD pdwSize
                     );

LONG AppendDigits( PWSTR pDest,
                   PWSTR pSrc,
                   PWSTR pValidChars
                 );


HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry);
int IsCityRule(LPWSTR lpRule);


LONG ApplyRule (PWSTR pszDialString,
                PWSTR pszDisplayString, 
                PWSTR pszRule,
                PWSTR pszDestLDRule,    // used for Area code adjustments
                PWSTR pszLongDistanceCarrier,
                PWSTR pszInternationalCarrier,
                PWSTR pszCountry,     
                PWSTR pszCity,        
                PWSTR pszSubscriber,
                PWSTR pCardName,
                PWSTR pCardAccessNumber,
                PWSTR pCardAccountNumber,
                PWSTR pCardPINNumber
                );


BOOL PrefixMatch(PWSTR pszPrefix,PWSTR pszSubscriberString, PDWORD pdwMatched);
BOOL AreaCodeMatch(PWSTR pszAreaCode1, PWSTR pszAreaCode2, PWSTR pszRule);
PWSTR SkipLDAccessDigits(PWSTR pszAreaCode, PWSTR pszLDRule);

#define LOCAL           1
#define LONG_DISTANCE   2
#define INTERNATIONAL   3



const WCHAR  csSCANTO[]      = L"\r";
const WCHAR  csDISPSUPRESS[] = L"TtPp,Ww@?!$";
const WCHAR  csBADCO[]       = L"AaBbCcDdPpTtWw*#!,@$?;()";
const WCHAR  csSCANSUB[]     = L"^|/";




/*
 ***************************************************************************
 *********************                          ****************************
 ********************     CLocation Class        ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/



/****************************************************************************

    Class : CLocation         
   Method : Constructer

****************************************************************************/
CLocation::CLocation()
{
    m_pszLocationName = NULL;

    m_pszLongDistanceAccessCode = NULL;
    m_pszLocalAccessCode = NULL;
    m_pszDisableCallWaitingCode = NULL;
    m_pszAreaCode = NULL;
    m_bFromRegistry = FALSE;
    m_bChanged = FALSE;
    m_dwNumRules = 0;
    m_hEnumNode = m_AreaCodeRuleList.head();
    m_pszTAPIDialingRule = NULL;
}



/****************************************************************************

    Class : CLocation         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CLocation::~CLocation()
{
    if ( m_pszLocationName != NULL )
    {
         ClientFree(m_pszLocationName);
    }   

    if ( m_pszLongDistanceAccessCode != NULL )
    {
         ClientFree(m_pszLongDistanceAccessCode);
    }   

    if ( m_pszLocalAccessCode != NULL )
    {
         ClientFree(m_pszLocalAccessCode);
    }   

    if ( m_pszDisableCallWaitingCode != NULL )
    {
         ClientFree(m_pszDisableCallWaitingCode);
    }   

    if ( m_pszAreaCode != NULL )
    {
         ClientFree(m_pszAreaCode);
    }   

    if ( m_pszTAPIDialingRule != NULL )
    {
         ClientFree(m_pszTAPIDialingRule);
    }   

    if (m_pszLongDistanceCarrierCode != NULL)
    {
        ClientFree (m_pszLongDistanceCarrierCode);
    }

    if (m_pszInternationalCarrierCode != NULL)
    {
        ClientFree (m_pszInternationalCarrierCode);
    }
    
    // clean up Area Code List
    AreaCodeRulePtrNode *node;

    node = m_AreaCodeRuleList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_AreaCodeRuleList.flush();

}



/****************************************************************************

    Class : CLocation         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CLocation::Initialize
                  (                                         
                    PWSTR pszLocationName,                  
                    PWSTR pszAreaCode,
                    PWSTR pszLongDistanceCarrierCode,
                    PWSTR pszInternationalCarrierCode,
                    PWSTR pszLongDistanceAccessCode,        
                    PWSTR pszLocalAccessCode,               
                    PWSTR pszDisableCallWaitingCode,        
                    DWORD dwLocationID,                     
                    DWORD dwCountryID,  
                    DWORD dwPreferredCardID,                
                    DWORD dwOptions ,
                    BOOL  bFromRegistry
                    
                   )
{
    
    m_pszLocationName = ClientAllocString( pszLocationName );
    if (m_pszLocationName == NULL)
    {
        LOG(( TL_ERROR, "Initialize - alloc m_pszLocationName failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszLongDistanceAccessCode = ClientAllocString( pszLongDistanceAccessCode );
    if (m_pszLongDistanceAccessCode == NULL)
    {
        ClientFree(m_pszLocationName);

        LOG(( TL_ERROR, "Initialize - alloc m_pszLongDistanceAccessCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszLocalAccessCode = ClientAllocString( pszLocalAccessCode );
    if (m_pszLocalAccessCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszLocalAccessCode failed" ));
        return E_OUTOFMEMORY;
    }
    
    m_pszDisableCallWaitingCode = ClientAllocString( pszDisableCallWaitingCode );
    if (m_pszDisableCallWaitingCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszDisableCallWaitingCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszAreaCode = ClientAllocString( pszAreaCode );
    if (m_pszAreaCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);
        ClientFree(m_pszDisableCallWaitingCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszAreaCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszLongDistanceCarrierCode = ClientAllocString( pszLongDistanceCarrierCode );
    if (m_pszLongDistanceCarrierCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);
        ClientFree(m_pszDisableCallWaitingCode);
        ClientFree(m_pszAreaCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszLongDistanceCarrierCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszInternationalCarrierCode = ClientAllocString( pszInternationalCarrierCode );
    if (m_pszInternationalCarrierCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);
        ClientFree(m_pszDisableCallWaitingCode);
        ClientFree(m_pszAreaCode);
        ClientFree(m_pszLongDistanceCarrierCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszInternationalCarrierCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_dwLocationID = dwLocationID;
    m_dwCountryID = dwCountryID ? dwCountryID : 1; // workaround for a bogus country ID
    m_dwPreferredCardID = dwPreferredCardID; 
    m_dwOptions = dwOptions; 
    m_bFromRegistry = bFromRegistry;
    if (m_bFromRegistry == FALSE)
    {
        m_bChanged = TRUE;
    }

    return S_OK;
}



/****************************************************************************

    Class : CLocation         
   Method : UseCallWaiting

****************************************************************************/
void CLocation::UseCallWaiting(BOOL bCw) 
{
    if(bCw)
    {    
        m_dwOptions |= LOCATION_HASCALLWAITING;
    }
    else
    {
        m_dwOptions &= ~LOCATION_HASCALLWAITING;
    }
    m_bChanged = TRUE;
}



/****************************************************************************

    Class : CLocation         
   Method : UseCallingCard

****************************************************************************/
void CLocation::UseCallingCard(BOOL bCc) 
{
    if(bCc)
    {    
        m_dwOptions |= LOCATION_USECALLINGCARD;
    }
    else
    {
        m_dwOptions &= ~LOCATION_USECALLINGCARD;
    }
    m_bChanged = TRUE;
}
   


/****************************************************************************

    Class : CLocation         
   Method : UseToneDialing

****************************************************************************/
void CLocation::UseToneDialing(BOOL bCc) 
{
    if(bCc)
    {    
        m_dwOptions |= LOCATION_USETONEDIALING;
    }
    else
    {
        m_dwOptions &= ~LOCATION_USETONEDIALING;
    }
    m_bChanged = TRUE;
}



/****************************************************************************

    Class : CLocation         
   Method : setName

****************************************************************************/
STDMETHODIMP CLocation::SetName(PWSTR pszLocationName)
{
    HRESULT hr = S_OK;


    if (m_pszLocationName != NULL)
        {
        ClientFree(m_pszLocationName);
        m_pszLocationName = NULL;
        }

    if(pszLocationName != NULL)
    {
        m_pszLocationName = ClientAllocString( pszLocationName );
        if (m_pszLocationName == NULL)
        {
    
            LOG(( TL_ERROR, "setName - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;
    
    return hr;
}



/****************************************************************************

    Class : CLocation         
   Method : setAreaCode

****************************************************************************/
STDMETHODIMP CLocation::SetAreaCode(PWSTR pszAreaCode)
{
    HRESULT hr = S_OK;


    if (m_pszAreaCode != NULL)
        {
        ClientFree(m_pszAreaCode);
        m_pszAreaCode = NULL;
        }

    if(pszAreaCode != NULL)
    {
        m_pszAreaCode = ClientAllocString( pszAreaCode );
        if (m_pszAreaCode == NULL)
        {
    
            LOG(( TL_ERROR, "setAreaCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;
    
    return hr;
}





/****************************************************************************

    Class : CLocation         
   Method : SetLongDistanceCarrierCode

****************************************************************************/
STDMETHODIMP CLocation::SetLongDistanceCarrierCode(PWSTR pszLongDistanceCarrierCode)
{
    HRESULT hr = S_OK;


    if (m_pszLongDistanceCarrierCode != NULL)
        {
        ClientFree(m_pszLongDistanceCarrierCode);
        m_pszLongDistanceCarrierCode = NULL;
        }

    if(pszLongDistanceCarrierCode != NULL)
    {
        m_pszLongDistanceCarrierCode = ClientAllocString( pszLongDistanceCarrierCode );
        if (m_pszLongDistanceCarrierCode == NULL)
        {
    
            LOG(( TL_ERROR, "setLongDistanceCarrierCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : SetInternationalCarrierCode

****************************************************************************/
STDMETHODIMP CLocation::SetInternationalCarrierCode(PWSTR pszInternationalCarrierCode)
{
    HRESULT hr = S_OK;


    if (m_pszInternationalCarrierCode != NULL)
        {
        ClientFree(m_pszInternationalCarrierCode);
        m_pszInternationalCarrierCode = NULL;
        }

    if(pszInternationalCarrierCode != NULL)
    {
        m_pszInternationalCarrierCode = ClientAllocString( pszInternationalCarrierCode );
        if (m_pszInternationalCarrierCode == NULL)
        {
    
            LOG(( TL_ERROR, "setInternationalCarrierCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : setLongDistanceAccessCode

****************************************************************************/
STDMETHODIMP CLocation::SetLongDistanceAccessCode(PWSTR pszLongDistanceAccessCode)
{
    HRESULT hr = S_OK;


    if (m_pszLongDistanceAccessCode != NULL)
        {
        ClientFree(m_pszLongDistanceAccessCode);
        m_pszLongDistanceAccessCode = NULL;
        }

    if(pszLongDistanceAccessCode != NULL)
    {
        m_pszLongDistanceAccessCode = ClientAllocString( pszLongDistanceAccessCode );
        if (m_pszLongDistanceAccessCode == NULL)
        {
    
            LOG(( TL_ERROR, "setLongDistanceAccessCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : setLocalAccessCode

****************************************************************************/
STDMETHODIMP CLocation::SetLocalAccessCode(PWSTR pszLocalAccessCode)
{
    HRESULT hr = S_OK;


    if (m_pszLocalAccessCode != NULL)
        {
        ClientFree(m_pszLocalAccessCode);
        m_pszLocalAccessCode = NULL;
        }

    if(pszLocalAccessCode != NULL)
    {
        m_pszLocalAccessCode = ClientAllocString( pszLocalAccessCode );
        if (m_pszLocalAccessCode == NULL)
        {
    
            LOG(( TL_ERROR, "setLocalAccessCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : SetDisableCallWaitingCode

****************************************************************************/
STDMETHODIMP CLocation::SetDisableCallWaitingCode(PWSTR pszDisableCallWaitingCode)
{
    HRESULT hr = S_OK;


    if (m_pszDisableCallWaitingCode != NULL)
        {
        ClientFree(m_pszDisableCallWaitingCode);
        m_pszDisableCallWaitingCode = NULL;
        }

    if(pszDisableCallWaitingCode != NULL)
    {
        m_pszDisableCallWaitingCode = ClientAllocString( pszDisableCallWaitingCode );
        if (m_pszDisableCallWaitingCode == NULL)
        {
    
            LOG(( TL_ERROR, "SetDisableCallWaitingCodee - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}




/****************************************************************************

    Class : CLocation         
   Method : WriteToRegistry

****************************************************************************/
STDMETHODIMP CLocation::WriteToRegistry()
{
    HRESULT         hr = S_OK;
     
    DWORD           dwTotalSizeNeeded = 0 ;
    DWORD           dwSize=0, dwOffset = 0;
    PLOCATIONLIST   pLocationList = NULL;
    PLOCATION       pEntry = NULL;

    // static size
    dwTotalSizeNeeded = sizeof(LOCATIONLIST);

    dwSize = TapiSize();
    dwTotalSizeNeeded += dwSize;

    // Allocate the memory buffer;
    pLocationList = (PLOCATIONLIST) ClientAlloc( dwTotalSizeNeeded );
    if (pLocationList != NULL)
    {
        // buffer size 
        pLocationList->dwTotalSize  = dwTotalSizeNeeded;
        pLocationList->dwNeededSize = dwTotalSizeNeeded;
        pLocationList->dwUsedSize   = dwTotalSizeNeeded;

        pLocationList->dwCurrentLocationID     = 0;
        pLocationList->dwNumLocationsAvailable = 1;
        
        //list size & offset
        dwOffset   = sizeof(LOCATIONLIST);

        pLocationList->dwNumLocationsInList = 1;
        pLocationList->dwLocationListSize   = dwSize;
        pLocationList->dwLocationListOffset = dwOffset;

        // point to the location entry in list
        pEntry = (PLOCATION)(((LPBYTE)pLocationList) + dwOffset);
        // fill out structure
        TapiPack(pEntry, dwSize);

        WriteLocations( pLocationList, 0);

        // finished with TAPI memory block so release
        if ( pLocationList != NULL )
        {
            ClientFree( pLocationList );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



/****************************************************************************

    Class : CLocation
   Method : RemoveRule

****************************************************************************/
void CLocation::RemoveRule(CAreaCodeRule *pRule)
{
    AreaCodeRulePtrNode * node = m_AreaCodeRuleList.head();

    while( !node->beyond_tail() )
    {
        if ( pRule == node->value() )
        {
            node->remove();
            delete pRule;
            m_dwNumRules--;
            break;
        }
        node = node->next();
    }
    m_bChanged = TRUE;
}



/****************************************************************************

    Class : CLocation
   Method : ResetRules

****************************************************************************/
HRESULT CLocation::ResetRules(void)
{
    m_hEnumNode = m_AreaCodeRuleList.head();
    return S_OK;
}



/****************************************************************************

    Class : CLocation
   Method : NextRule

****************************************************************************/
HRESULT CLocation::NextRule(DWORD  NrElem, CAreaCodeRule **ppRule, DWORD *pNrElemFetched)
{
    DWORD   dwIndex = 0;

    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;

    if(ppRule==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        *ppRule++ = m_hEnumNode->value();
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
}



/****************************************************************************

    Class : CLocation
   Method : SkipRule

****************************************************************************/
HRESULT CLocation::SkipRule(DWORD  NrElem)
{
    DWORD   dwIndex = 0;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}



/****************************************************************************

    Class : CLocation
   Method : TapiSize
            Number of bytes needed to pack this into a TAPI structure to send
            to TAPISRV.
            If the object has not changed while in memory, we won't save it so
            return a zero size.

****************************************************************************/
DWORD CLocation::TapiSize()
{
    AreaCodeRulePtrNode * node = m_AreaCodeRuleList.head();
    CAreaCodeRule       * pRule = NULL;
    DWORD                 dwSize=0;

    if(m_bChanged)
    {
        // Calc size of Location info
        dwSize = ALIGN(sizeof(LOCATION));
        dwSize += ALIGN((lstrlenW(m_pszLocationName) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszAreaCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszLongDistanceCarrierCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszInternationalCarrierCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszLongDistanceAccessCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszLocalAccessCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszDisableCallWaitingCode) + 1) * sizeof(WCHAR));


        while( !node->beyond_tail() )
        {
            // Add in size of each Area Code Rule
            pRule = node->value();
            if (pRule != NULL)
            {
                // this should come back aligned as well
                dwSize += pRule->TapiSize();
            }
            node = node->next();
        }
    }
    else  // no change so don't save this
    {
        dwSize = 0;
    }
    return dwSize;
}



/****************************************************************************

    Class : CLocation
   Method : TapiPack
            Pack this object into a TAPI structure.
            Return number of bytes used.
            If the object has not changed while in memory, we won't save it so
            do mothing except return a zero size.

****************************************************************************/
DWORD CLocation::TapiPack(PLOCATION pLocation, DWORD dwTotalSize)
{
    AreaCodeRulePtrNode * node;
    CAreaCodeRule       * pRule = NULL;
    DWORD                 dwSize =0, dwOffSet =0;
    PAREACODERULE         pEntry = NULL;

    if(m_bChanged)
    {
        m_bFromRegistry = TRUE;

        /////////////////////////////////////////////////////////////////////
        // Process fized part of Location info
        dwOffSet = sizeof(LOCATION);

        pLocation->dwPermanentLocationID= m_dwLocationID;
        pLocation->dwCountryCode = m_dwCountryCode;
        pLocation->dwCountryID = m_dwCountryID;
        pLocation->dwPreferredCardID = m_dwPreferredCardID;
        pLocation->dwOptions = m_dwOptions;

        /////////////////////////////////////////////////////////////////////
        // Process strings

        // name
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszLocationName,
                                   &pLocation->dwLocationNameOffset,
                                   &pLocation->dwLocationNameSize
                                  );

        //area code
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszAreaCode,
                                   &pLocation->dwAreaCodeOffset,
                                   &pLocation->dwAreaCodeSize
                                  );

        //LD carrier code
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszLongDistanceCarrierCode,
                                   &pLocation->dwLongDistanceCarrierCodeOffset,
                                   &pLocation->dwLongDistanceCarrierCodeSize
                                  );
        
        //International carrier code
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszInternationalCarrierCode,
                                   &pLocation->dwInternationalCarrierCodeOffset,
                                   &pLocation->dwInternationalCarrierCodeSize
                                  );
        


        //LD access
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszLongDistanceAccessCode,
                                   &pLocation->dwLongDistanceAccessCodeOffset,
                                   &pLocation->dwLongDistanceAccessCodeSize
                                  );
        
        // Local access
        dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                   dwOffSet, 
                                   dwTotalSize,
                                   m_pszLocalAccessCode,
                                   &pLocation->dwLocalAccessCodeOffset,
                                   &pLocation->dwLocalAccessCodeSize
                                  );
    
        // CallWaiting
        dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                   dwOffSet, 
                                   dwTotalSize,
                                   m_pszDisableCallWaitingCode,
                                   &pLocation->dwCancelCallWaitingOffset,
                                   &pLocation->dwCancelCallWaitingSize
                                  );
    
    
        /////////////////////////////////////////////////////////////////////
        // Process Area Code Rules
    
        pLocation->dwNumAreaCodeRules = m_dwNumRules;
        pLocation->dwAreaCodeRulesListOffset = dwOffSet;
        //pLocation->dwAreaCodeRulesListSize;
    
        // point to the 1st rule
        pEntry = (PAREACODERULE)(((LPBYTE)pLocation) + dwOffSet);
        
        //point strings past rule area
        dwOffSet += ALIGN(( sizeof(AREACODERULE) * m_dwNumRules )); 
    
        // run through list
        node = m_AreaCodeRuleList.head(); 
        while( !node->beyond_tail() )
        {
            
            // Add in size of each Area Code Rule
            pRule = node->value();
            if (pRule != NULL)
            {
                pEntry->dwOptions = pRule->GetOptions();
    
                // Area code
                dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                           dwOffSet, 
                                           dwTotalSize,
                                           pRule->GetAreaCode(),
                                           &pEntry->dwAreaCodeOffset,
                                           &pEntry->dwAreaCodeSize
                                          );
            
                // num to Call
                dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                           dwOffSet, 
                                           dwTotalSize,
                                           pRule->GetNumberToDial(),
                                           &pEntry->dwNumberToDialOffset,
                                           &pEntry->dwNumberToDialSize
                                          );
                
                // prefix list
                dwSize = pRule->GetPrefixListSize();
                pEntry->dwPrefixesListSize = dwSize;
                pEntry->dwPrefixesListOffset = dwOffSet;
                
                CopyMemory((PVOID)(((LPBYTE)pLocation) + dwOffSet),
                                   pRule->GetPrefixList() ,
                                   dwSize);
                dwOffSet += ALIGN(dwSize);
    
            }
    
    
            node = node->next();
            pEntry++;

        }
    
        // offset gives how many bytes we used
        pLocation->dwUsedSize = dwOffSet;
    }
    else  // no change so don't save this
    {
        dwOffSet = 0;
    }
    return  dwOffSet;
}




/****************************************************************************

    Class : CLocation         
   Method : NewID
            gets new ID from server

****************************************************************************/
HRESULT CLocation::NewID()
{
    LONG lResult;
    DWORD dwId = 0;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, tAllocNewID),
        {
            (DWORD_PTR)&dwId
        },

        {
            lpDword
        }
    };

   //
   // Yes, let TAPISRV do it without danger of AV interruption from
   // another thread
   //

   lResult = DOFUNC (&funcArgs, "TAllocNewID");
   if(lResult == 0)
   {
        m_dwLocationID = dwId;
   }

   return (HRESULT)lResult;
}


/****************************************************************************

    Class : CLocation         
   Method : GetCountryCode
            gets GetCountryCode from server

****************************************************************************/
DWORD CLocation::GetCountryCode() 
{
    CCountry * pCountry = NULL;        
    
    if(SUCCEEDED( CreateCountryObject(m_dwCountryID, &pCountry)) )
    {
        m_dwCountryCode = pCountry->GetCountryCode();
        delete pCountry;
    }

    return m_dwCountryCode;
}



/****************************************************************************

    Class : CLocation         
   Method : TranslateAddress
            This is what its all there for, take a input number & figure out
            the dialable & display strings

****************************************************************************/
LONG CLocation::TranslateAddress(PCWSTR       pszAddressIn,
                                 CCallingCard *pCallingCard,
                                 DWORD        dwTranslateOptions,
                                 PDWORD       pdwTranslateResults,
                                 PDWORD       pdwDestCountryCode,
                                 PWSTR      * pszDialableString,
                                 PWSTR      * pszDisplayableString
                                )
{
    PWSTR       pszDialString = NULL;
    PWSTR       pszDisplayString = NULL;
    PWSTR       pszInputString = NULL;
    PWSTR       pszRule = NULL;
    PWSTR       pszDestLDRule = NULL;
    PWSTR       pszCountry = NULL;     
    PWSTR       pszCity = NULL;        
    PWSTR       pszSubscriber = NULL;  
    
    PWSTR       pCardName = NULL;
    PWSTR       pCardAccessNumber = NULL;
    PWSTR       pCardAccountNumber = NULL;
    PWSTR       pCardPINNumber = NULL;


    LONG        lResult = 0;
    HRESULT     hr= S_OK;
    CCountry  * pCountry = NULL;
    CCountry  * pDestCountry = NULL;
    DWORD       dwAccess;
    DWORD       dwDestCountryCode;

    BOOL        bSpaceExists, bOutOfMem = FALSE;
    



    *pdwTranslateResults = 0;
    if(pdwDestCountryCode)
        *pdwDestCountryCode = 0;


    //////////////////////////////////////////////////////////////
    // Allocate space for our strings
    //
    
    pszDialString = (PWSTR)ClientAlloc( MaxDialStringSize * sizeof(WCHAR) );
    if (pszDialString == NULL)
    {
       LOG((TL_TRACE, "TranslateAddress DialString alloc failed"));
       return LINEERR_NOMEM;
    }
  
    pszDisplayString = (PWSTR)ClientAlloc( MaxDialStringSize * sizeof(WCHAR) );
    if (pszDisplayString == NULL)
    {
       LOG((TL_TRACE, "TranslateAddress DisplayString alloc failed"));
  
       ClientFree(pszDialString);
  
       return LINEERR_NOMEM;
    }

    
    *pszDialableString = pszDialString;

    *pszDisplayableString = pszDisplayString;
  
    bSpaceExists = TRUE;    // for suppressing a first space
    
    //////////////////////////////////////////////////////////////
    // Copy the string to our local buffer so we can mangle it
    //
    pszInputString = ClientAllocString(pszAddressIn);
    if (pszInputString == NULL)
    {
       LOG((TL_TRACE, "TranslateAddress InputString alloc failed"));
  
       ClientFree(pszDialString);
       ClientFree(pszDisplayString);
  
       return LINEERR_NOMEM;
    }
  
  
  
    //////////////////////////////////////////////////////////////
    // Mark off the end
    //
    // Isolate the piece of pszInputString that we will operate upon in
    // This piece stops at first CR or \0.
    //
    pszInputString[wcscspn(pszInputString,csSCANTO)] = L'\0';
  

    ////////////////////////////////
    // Set T or P, if not set in input
    //////////////////////////////////////////////////////////////
    // Easy case: first put the T or P in the beginning of the
    // dialable string
    //
    if ( HasToneDialing() )
    {
        *pszDialString = L'T';
    }
    else
    {
        *pszDialString = L'P';
    }

    

    //////////////////////////////////////////////////////////////
    // Set Call Waiting
    //if  location supports call Waiting AND (TranslateOptions | LINETRANSLATIONOPTION_CANCELCALLWAIT)
    if((dwTranslateOptions & LINETRANSLATEOPTION_CANCELCALLWAITING)  && HasCallWaiting() )
    {
       hr = StringCchCatExW(pszDialString, MaxDialStringSize, m_pszDisableCallWaitingCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
       bOutOfMem = bOutOfMem || FAILED(hr);
       hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, m_pszDisableCallWaitingCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
       bOutOfMem = bOutOfMem || FAILED(hr);
       
       bSpaceExists = FALSE;
    }

    

    //////////////////////////////////////////////////////////////
    // Now, do we have a canonical number to deal with, or is it junk?
    //
    if ( *pszInputString == L'+' )  // Check the real _first_ char
    {
      //
      // Ok, it's canonical
      //
      
      //
      // Skip the plus
      //
    
        lResult = BreakupCanonicalW( pszInputString + 1,    
                                     &pszCountry,
                                     &pszCity,
                                     &pszSubscriber   
                                    );                        
    
        if (lResult == 0)
        {
            // It's canonical
            *pdwTranslateResults |= LINETRANSLATERESULT_CANONICAL;
    
            
            hr = CreateCountryObject(m_dwCountryID, &pCountry);
            if(SUCCEEDED( hr) )
            {
                //////////////////////////////////////////////////////////////
                // set LINETRANSLATERESULT result codes
                dwDestCountryCode = (DWORD)_wtol((const wchar_t*) pszCountry);
                if (dwDestCountryCode == pCountry->GetCountryCode() )
                {
                    // In country Call
                  
                    pszDestLDRule = pCountry->GetLongDistanceRule();
                    //if ( ( 
                    //      CurrentCountry.LongDistanceRule.AreaCodes == Optional  
                    //      OR  CurrentCountry.LongDistanceRule.AreaCodes == Manditory && cityCode != NULL
                    //     )  
                    //    AND AreaCodeString != CurrentLocation.AreaCodeString )
                    if ( ( (IsCityRule(pszDestLDRule) == CITY_OPTIONAL) ||
                           ( (IsCityRule(pszDestLDRule) == CITY_MANDATORY) && (pszCity != NULL) ) ) &&
                         (!AreaCodeMatch(pszCity, m_pszAreaCode, pszDestLDRule))
                       )
                    {
                        // Long Distance Call
                        *pdwTranslateResults |= LINETRANSLATERESULT_LONGDISTANCE;
                    }
                    else // Local Call
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_LOCAL;
                    }
                }
                else // International Call
                {
                    // find the LD rule of the destination country using the country code (we don't have the country ID)
                    hr = CreateCountryObject(dwDestCountryCode, &pDestCountry);
                    if(SUCCEEDED(hr))
                    {
                        if ( pCountry->GetCountryGroup() != 0 &&
                             pCountry->GetCountryGroup() == pDestCountry->GetCountryGroup()
                           )
                        {
                            // if countries are in the same group, we need to
                            // apply long distance rule instead of international
                            *pdwTranslateResults |= LINETRANSLATERESULT_LONGDISTANCE;
                        }
                        else
                        {
                            *pdwTranslateResults |= LINETRANSLATERESULT_INTERNATIONAL;
                        }

                        pszDestLDRule = pDestCountry->GetLongDistanceRule();
                    }
                    else
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_INTERNATIONAL;
                        // FALL THROUGH if error    
                    }
                }
            }
            if(SUCCEEDED( hr) )
            {
                // If the caller needs the destination country code
                if(pdwDestCountryCode)
                    *pdwDestCountryCode = dwDestCountryCode;
                
                //////////////////////////////////////////////////////////////
                // Now we no what type of call, find the correct rule
                // Take in to account LINETRANSLATIONOPTION over-rides
                FindRule(
                        *pdwTranslateResults, 
                        dwTranslateOptions,
                        pCallingCard,  
                        pCountry,
                        pszCity, 
                        pszSubscriber,
                        &pszRule,
                        &dwAccess
                        );
    
                //////////////////////////////////////////////////////////////
                // Add access String to output string
                if (dwAccess == LOCAL)
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, m_pszLocalAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);

                    if(*m_pszLocalAccessCode)
                    {
                        if(!bSpaceExists)
                        {
                            hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                            bOutOfMem = bOutOfMem || FAILED(hr);
                        }
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, m_pszLocalAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                        bSpaceExists = FALSE;
                    }
                }
                else // LONG_DISTANCE or INTERNATIONAL
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, m_pszLongDistanceAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    if(*m_pszLongDistanceAccessCode)
                    {
                        if(!bSpaceExists)
                        {
                            hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                            bOutOfMem = bOutOfMem || FAILED(hr);
                        }
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, m_pszLongDistanceAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                        bSpaceExists = FALSE;
                    }
                }
                
                //////////////////////////////////////////////////////////////
                // If there's a card get its values
                if(pCallingCard != NULL)
                {
                    switch(dwAccess)
                    {
                        case INTERNATIONAL:  
                            pCardAccessNumber = pCallingCard->GetInternationalAccessNumber();
                            break;
                        case LONG_DISTANCE:  
                            LOG((TL_TRACE, "TranslateAddress: About to do pCallingCard->GetLongDistanceAccessNumber"));
                            pCardAccessNumber = pCallingCard->GetLongDistanceAccessNumber();
                            LOG((TL_TRACE, "TranslateAddress: Did pCallingCard->GetLongDistanceAccessNumber"));
                            break;
                        default:  
                            pCardAccessNumber = pCallingCard->GetLocalAccessNumber();
                            break;
                    }
                    pCardName = pCallingCard->GetCardName();
                    pCardAccountNumber = pCallingCard->GetAccountNumber();
                    pCardPINNumber = pCallingCard->GetPIN();
                
                }
                
                if(!bSpaceExists)
                {
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                }

                //////////////////////////////////////////////////////////////
                // Got the rule , now apply it
                if (ApplyRule (pszDialString,
                           pszDisplayString, 
                           pszRule,
                           pszDestLDRule,
                           m_pszLongDistanceCarrierCode,
                           m_pszInternationalCarrierCode,
                           pszCountry,     
                           pszCity,        
                           pszSubscriber,
                           pCardName,
                           pCardAccessNumber,
                           pCardAccountNumber,
                           pCardPINNumber
                          ))
                {
                    bOutOfMem = TRUE;
                }
                else
                {

                    //
                    // Set LINETRANSLATERESULT_consts based on translation
                    // results
                    //
                    if (wcschr (pszDialString, L'$'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALBILLING;
                    }
                    if (wcschr (pszDialString, L'W'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALDIALTONE;
                    }
                    if (wcschr (pszDialString, L'?'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALPROMPT;
                    }
                    if (wcschr (pszDialString, L'@'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALQUIET;
                    }
                    if (wcschr (pszDialString, L':'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_VOICEDETECT;
                    }
                }
            }
            else // bad country code
            {
                lResult = LINEERR_INVALCOUNTRYCODE;

                ClientFree(*pszDialableString);
                ClientFree(*pszDisplayableString);

                *pszDialableString = *pszDisplayableString =  NULL;
            }

            if(pCountry)
                delete pCountry;
            if(pDestCountry)
                delete pDestCountry;
            
        }
        else // bad canonical address
        {
            lResult = LINEERR_INVALADDRESS;

            ClientFree(*pszDialableString);
            ClientFree(*pszDisplayableString);

            *pszDialableString = *pszDisplayableString =  NULL;
        }
    }
    else  // non-canonical string
    {
     PWSTR pszInputStringLocal = pszInputString;

        // if the string starts with T,P,t or p, skip the
        // first character.
        if (*pszInputString == L'T' ||
            *pszInputString == L'P' ||
            *pszInputString == L't' ||
            *pszInputString == L'p')
        {
            pszInputStringLocal++;
        }

        hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszInputStringLocal, NULL, NULL, STRSAFE_NO_TRUNCATION);
        bOutOfMem = bOutOfMem || FAILED(hr);
        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszInputString, NULL, NULL, STRSAFE_NO_TRUNCATION);
        bOutOfMem = bOutOfMem || FAILED(hr);
    }


    /////////////////////////////////////////////////////////////////////
    // Clean up
    //
    if (bOutOfMem)
    {
        lResult = LINEERR_NOMEM;
        ClientFree(*pszDialableString);
        ClientFree(*pszDisplayableString);
        *pszDialableString = *pszDisplayableString =  NULL;
    }

    if(pszInputString != NULL)
    {
        ClientFree(pszInputString);
    }

    return lResult;
}



/****************************************************************************

    Class : CLocation         
   Method : FindRule
            Decide which TAPI dial string rule to apply

            in                      
              dwTranslateResults      
              dwTranslateOptions              
              pCard           
              pCountry      
              AreaCodeString        
              SubscriberString      
            out                     
              ppRule                  
              dwAccess               

****************************************************************************/
void CLocation::FindRule(
                        DWORD          dwTranslateResults, 
                        DWORD          dwTranslateOptions,
                        CCallingCard * pCard,  
                        CCountry     * pCountry,
                        PWSTR          pszAreaCodeString, 
                        PWSTR          pszSubscriberString,
                        PWSTR        * ppszRule,
                        PDWORD         dwAccess
                        )           
{                       
    CRuleSet * pCardRuleSet;
    CRuleSet * pCountryRuleSet;

    //if using Card
    if(pCard != NULL)
    {
        // Apply card rules
        pCardRuleSet = pCard->GetRuleSet();
        LOG((TL_INFO, "FindRule - using (eventually) card %ls", pCard->GetCardName() ));
    }
    else
    {
        pCardRuleSet = NULL;
    }

    pCountryRuleSet =  pCountry->GetRuleSet();

// use card rule if card is specified. If a specific rule is empty, fallback to country rule
#define     SUITABLE_RULE(x)     \
    ( (pCard && pCardRuleSet->x && *(pCardRuleSet->x) ) ? \
       pCardRuleSet->x : pCountryRuleSet->x )


    // Forced Long Distance Call
    if (dwTranslateOptions & LINETRANSLATEOPTION_FORCELD)
    {
        *dwAccess = LONG_DISTANCE;
    
        *ppszRule = SUITABLE_RULE(m_pszLongDistanceRule);
        
        LOG((TL_INFO, "FindRule - force long distance"));
    }
    
    
    // Force Local Call
    else if (dwTranslateOptions & LINETRANSLATEOPTION_FORCELOCAL)
    {
        *dwAccess = LOCAL;
     
        *ppszRule = SUITABLE_RULE(m_pszLocalRule);
        
        LOG((TL_INFO, "FindRule - force local"));
    }
    
    
    // International Call
    else if (dwTranslateResults & LINETRANSLATERESULT_INTERNATIONAL)
    {
        *dwAccess = INTERNATIONAL;
      
        *ppszRule = SUITABLE_RULE(m_pszInternationalRule);
        
        LOG((TL_INFO, "FindRule - international"));
    }
    

    // In Country, Long Distance Call or Local
    else 
    {
        CAreaCodeRule       * pCrtRule = NULL;
        AreaCodeRulePtrNode * pNode = NULL;
        PWSTR                 pszPrefix = NULL;
        DWORD                 dwNumMatchedDigits = 0;
        DWORD                 dwBestMatchedDigits = 0;
        DWORD                 dwBestThisRule = 0;
        BOOL                  bFoundApplicableRule = FALSE;
        BOOL                  bMatchThisRule = FALSE;
        BOOL                  bThisPrefixMatchThisRule = FALSE;
        
        // Enumerate the area code rules
        pNode = m_AreaCodeRuleList.head();
        while( !pNode->beyond_tail() )
        {
            pCrtRule = pNode->value();
            if(pCrtRule!=NULL)
            {
                // does this rule match the area code we're calling ?
                if(AreaCodeMatch(pszAreaCodeString, pCrtRule->GetAreaCode(), pCountry->GetLongDistanceRule()))
                { 
                    LOG((TL_INFO, "FindRule - ACRule applies"));
                    bMatchThisRule = FALSE;
                    dwBestThisRule = 0;
                    if( pCrtRule->HasAppliesToAllPrefixes() )
                    {
                        bMatchThisRule = TRUE;
                        dwNumMatchedDigits = 0;   
                        LOG((TL_INFO, "FindRule - there's a all prefix rule"));
                    }
                    else  // is there a specific prefix rule ?
                    {
                        pszPrefix = pCrtRule->GetPrefixList();
                        while(*pszPrefix != '\0')
                        {
                            bThisPrefixMatchThisRule= PrefixMatch(pszPrefix,
                                                        pszSubscriberString,
                                                    &dwNumMatchedDigits);
                            if(bThisPrefixMatchThisRule)
                            {
                                LOG((TL_INFO, "FindRule:   there's a specific prefix rule %d digit match"
                                            ,dwNumMatchedDigits));
                                            
                                bMatchThisRule = TRUE;
                                if(dwNumMatchedDigits > dwBestThisRule )
                                {
                                    dwBestThisRule= dwNumMatchedDigits;
                                }
                            }
                            pszPrefix = wcschr( pszPrefix, '\0');
                            pszPrefix++;
                        }
                    }
                    
                    // have we got a better match than we've had before ?
                    if(bMatchThisRule && (dwBestThisRule >= dwBestMatchedDigits) )
                    {
                        // We have the best prefix match so far so use this rule
                        dwBestMatchedDigits = dwBestThisRule;
                        bFoundApplicableRule = TRUE;

                        
                        LOG((TL_INFO, "FindRule:  going with the %d digit match" ,dwBestMatchedDigits));

                        *ppszRule = NULL;

                        // Card overides, so if using Card
                        if(pCard != NULL)
                        {
                            LOG((TL_INFO, "FindRule:  card override (eventually)"));
                            if ( pCrtRule->HasDialNumber() )
                            {
                                *ppszRule = pCardRuleSet->m_pszLongDistanceRule;
                            }
                            else
                            {
                                *ppszRule = pCardRuleSet->m_pszLocalRule;
                            }  
                        }
                        if(!(*ppszRule && **ppszRule))
                        // build a tapirulestring for this rule entry
                        // this might be necessary if the calling card has no suitable rule
                        {
                            if(m_pszTAPIDialingRule != NULL)
                            {
                                ClientFree(m_pszTAPIDialingRule);
                            }
                            if (S_OK ==
                                CreateDialingRule(&m_pszTAPIDialingRule,
                                                  pCrtRule->HasDialNumber()?pCrtRule->GetNumberToDial():NULL,
                                                  pCrtRule->HasDialAreaCode() 
                                                 ))
                            {
                                *ppszRule = m_pszTAPIDialingRule;
                                LOG((TL_INFO, "FindRule:  built a rule string - %ls",m_pszTAPIDialingRule));
                            }

                        }

                        // Set the correct access, based on the selected rule
                        if ( pCrtRule->HasDialNumber() )
                        {
                            *dwAccess = LONG_DISTANCE;
                        }
                        else
                        {
                            *dwAccess = LOCAL;
                        }
                    } // no better match

                }  // no not calling this area code
    
            }
            pNode = pNode->next();

        }
    
        // Did we have a match at all ?
        if(bFoundApplicableRule == FALSE) 
        {
            // No area code rule matched, so go with country default rule
            if (dwTranslateResults & LINETRANSLATERESULT_LONGDISTANCE)
            {
                // long Distance
                *dwAccess = LONG_DISTANCE;
                *ppszRule = SUITABLE_RULE(m_pszLongDistanceRule);
        
                LOG((TL_TRACE, "FindRule - long distance default"));
            }
            else  // Local
            {
                *dwAccess = LOCAL;
                *ppszRule = SUITABLE_RULE(m_pszLocalRule);
        
                LOG((TL_TRACE, "FindRule - local default"));
            }
    
        }
    
    }

}

#undef SUITABLE_RULE


/*
 ***************************************************************************
 *********************                          ****************************
 ********************    CLocations  Class       ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/


/****************************************************************************

    Class : CLocations         
   Method : Constructer

****************************************************************************/
CLocations::CLocations()
{
    m_dwNumEntries = 0;
    m_hEnumNode = m_LocationList.head();
    
}


/****************************************************************************

    Class : CLocations         
   Method : Destructer

****************************************************************************/
CLocations::~CLocations()
{
    CLocationNode *node;

    node = m_LocationList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_LocationList.flush();

    node = m_DeletedLocationList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_DeletedLocationList.flush();

}



/****************************************************************************

    Class : CLocations         
   Method : Initialize
            Read the location list from registry via TAPISRV & build our 
            object list.

****************************************************************************/
HRESULT CLocations::Initialize(void)
{
    PLOCATIONLIST   pLocationList = NULL;
    
    PLOCATION       pEntry = NULL;
    PWSTR           pszLocationName = NULL;            
    PWSTR           pszAreaCode = NULL;                
    PWSTR           pszLongDistanceCarrierCode = NULL;         
    PWSTR           pszInternationalCarrierCode = NULL;         
    PWSTR           pszLocalAccessCode = NULL;         
    PWSTR           pszLongDistanceAccessCode = NULL;  
    PWSTR           pszCancelCallWaitingCode = NULL;   
    DWORD           dwPermanentLocationID = 0;   
    CLocation     * pNewLocation = NULL;
    
    PAREACODERULE   pAreaCodeRuleEntry = NULL;
    PWSTR           pszNumberToDial = NULL;
    PWSTR           pszzPrefixesList = NULL;
    DWORD           dwNumRules = 0; 
    CAreaCodeRule * pAreaCodeRule = NULL;

    DWORD           dwNumEntries = 0;
    DWORD           dwCount,dwCount2 = 0;
    HRESULT         hr;
    

    
    hr = ReadLocations(&pLocationList,       
                       0,                   
                       0,                   
                       0,                  
                       0      
                      );

    if SUCCEEDED( hr) 
    {
        // current location
        m_dwCurrentLocationID  = pLocationList->dwCurrentLocationID;   
         
        // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
        pEntry = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           

        // Number of locations ?
        dwNumEntries =  pLocationList->dwNumLocationsInList;

        for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
        {
    
            // Pull Location Info out of LOCATION structure
            pszLocationName           = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocationNameOffset);
            pszAreaCode               = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwAreaCodeOffset);
            pszLongDistanceCarrierCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceCarrierCodeOffset);
            pszInternationalCarrierCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwInternationalCarrierCodeOffset);
            pszLocalAccessCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocalAccessCodeOffset);
            pszLongDistanceAccessCode = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceAccessCodeOffset);
            pszCancelCallWaitingCode  = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwCancelCallWaitingOffset);
        
        
            // create our new Location Object                
            pNewLocation = new CLocation;
            if (pNewLocation)
            {
                // initialize the new Location Object
                hr = pNewLocation->Initialize(
                                            pszLocationName, 
                                            pszAreaCode,
                                            pszLongDistanceCarrierCode,
                                            pszInternationalCarrierCode,
                                            pszLongDistanceAccessCode, 
                                            pszLocalAccessCode, 
                                            pszCancelCallWaitingCode , 
                                            pEntry->dwPermanentLocationID,
                                            pEntry->dwCountryID,
                                            pEntry->dwPreferredCardID,
                                            pEntry->dwOptions,
                                            TRUE
                                            );
                    
                if( SUCCEEDED(hr) )
                {
                    // Find position of 1st AREACODERULE structure in the LOCATIONLIST structure 
                    pAreaCodeRuleEntry = (PAREACODERULE) ((BYTE*)(pEntry) 
                                                          + pEntry->dwAreaCodeRulesListOffset );           
                   
                    dwNumRules = pEntry->dwNumAreaCodeRules;           
                
                    for (dwCount2 = 0; dwCount2 != dwNumRules; dwCount2++)
                    {
                        // Pull Rule Info out of AREACODERULE structure
                        pszAreaCode      = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwAreaCodeOffset);
                        pszNumberToDial  = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwNumberToDialOffset);
                        pszzPrefixesList = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwPrefixesListOffset);
        
                        // create our new AreaCodeRule Object                
                        pAreaCodeRule = new CAreaCodeRule;
                        if (pAreaCodeRule)
                        {
                            // initialize the new AreaCodeRule Object
                            hr = pAreaCodeRule->Initialize ( pszAreaCode,
                                                             pszNumberToDial,
                                                             pAreaCodeRuleEntry->dwOptions,
                                                             pszzPrefixesList, 
                                                             pAreaCodeRuleEntry->dwPrefixesListSize
                                                           );
                            if( SUCCEEDED(hr) )
                            {
                                pNewLocation->AddRule(pAreaCodeRule);
                            }
                            else // rule initialization failed
                            {
                                delete pAreaCodeRule;
                                LOG((TL_ERROR, "Initialize: CreateCurrentLoctionObject - rule create failed"));
                            }
                        } 
                        else // new CAreaCodeRule failed
                        {
                            LOG((TL_ERROR, "CreateCurrentLoctionObject - rule create failed"));
                        }
    
                        // Try next rule in list
                        pAreaCodeRuleEntry++;
                        
                    }

                    Add(pNewLocation);             

                }
                else // location initialize failed
                {
                    delete pNewLocation;
                    pNewLocation = NULL;
    
                    LOG((TL_ERROR, "CreateCurrentLoctionObject - location create failed"));
                }
            }
            else // new CLocation failed
            {
                LOG((TL_ERROR, "CreateCurrentLoctionObject - location create failed"));
    
            }

            // Try next location in list
            //pEntry++;
            pEntry = (PLOCATION) ((BYTE*)(pEntry) + pEntry->dwUsedSize);           

        }

    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "CreateCurrentLoctionObject - ReadLocation create failed"));
    }

    // finished with TAPI memory block so release
    if ( pLocationList != NULL )
            ClientFree( pLocationList );

    return hr;
}


/****************************************************************************

    Class : CLocations         
   Method : SaveToRegistry
            Save object list back to registry via TAPISRV again

****************************************************************************/
HRESULT CLocations::SaveToRegistry(void)
{
    HRESULT         hr = S_OK;
     
    DWORD           dwTotalSizeNeeded = 0, dwNumEntries= 0 ;
    DWORD           dwSize=0, dwOffset = 0;
    CLocationNode * node = NULL; 
    CLocation     * pLocation = NULL;

    PLOCATIONLIST   pLocationList = NULL;
    PLOCATION       pEntry = NULL;

    // static size
    dwTotalSizeNeeded = sizeof(LOCATIONLIST);
    dwNumEntries = 0;

    // Now add in size of each Location (includes rules)
    node = m_LocationList.head(); 
    while( !node->beyond_tail() )
    {
        pLocation = node->value();
        if (pLocation != NULL)
        {
            dwSize= pLocation->TapiSize();
            dwTotalSizeNeeded += dwSize;
            if(dwSize)
            {
                // only save if dwSize >0, i.e. object has changed
                dwNumEntries++;
            }
        }
        node = node->next();
    }

    // Now add in size of each deleted Location
    node = m_DeletedLocationList.head(); 
    while( !node->beyond_tail() )
    {
        pLocation = node->value();
        if (pLocation != NULL)
        {
            dwSize= pLocation->TapiSize();
            dwTotalSizeNeeded += dwSize;
            if(dwSize)
            {
                // only save if dwSize > 0, i.e. object has changed
                dwNumEntries++;
            }
        }
        node = node->next();
    }


    // Allocate the memory buffer;
    pLocationList = (PLOCATIONLIST) ClientAlloc( dwTotalSizeNeeded );
    if (pLocationList != NULL)
    {
    
        // buffer size 
        pLocationList->dwTotalSize  = dwTotalSizeNeeded;
        pLocationList->dwNeededSize = dwTotalSizeNeeded;
        pLocationList->dwUsedSize   = dwTotalSizeNeeded;

        pLocationList->dwCurrentLocationID     = m_dwCurrentLocationID;
        pLocationList->dwNumLocationsAvailable = dwNumEntries;
        
        //list size & offset
        dwOffset   = sizeof(LOCATIONLIST);

        pLocationList->dwNumLocationsInList = dwNumEntries;
        pLocationList->dwLocationListSize   = dwTotalSizeNeeded - sizeof(LOCATIONLIST);
        pLocationList->dwLocationListOffset = dwOffset;



        // Now add in each Location (includes rules)
        node = m_LocationList.head(); 
        while( !node->beyond_tail() )
        {
            // point to the location entry in list
            pEntry = (PLOCATION)(((LPBYTE)pLocationList) + dwOffset);

            pLocation = node->value();
            if (pLocation != NULL)
            {
                // fill out structure
                dwOffset += pLocation->TapiPack(pEntry, dwTotalSizeNeeded - dwOffset);
            }

            node = node->next();
        }


        // Now add in each deleted Location 
        node = m_DeletedLocationList.head(); 
        while( !node->beyond_tail() )
        {
            // point to the location entry in list
            pEntry = (PLOCATION)(((LPBYTE)pLocationList) + dwOffset);

            pLocation = node->value();
            if (pLocation != NULL)
            {
                // fill out structure
                dwOffset += pLocation->TapiPack(pEntry, dwTotalSizeNeeded - dwOffset);
            }

            node = node->next();
        }


        WriteLocations( pLocationList,CHANGEDFLAGS_CURLOCATIONCHANGED);
    
        // finished with TAPI memory block so release
        if ( pLocationList != NULL )
        {
            ClientFree( pLocationList );
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}


/****************************************************************************

    Class : CLocations         
   Method : Remove (with CLocation *)
            If location object was read from the registry we must keep it
            around so we can remove its entry when writing back to the registry.
            If it only existed in memory we can just delete it.

****************************************************************************/
void CLocations::Remove(CLocation * pLocation)
{
    CLocationNode *node = m_LocationList.head(); 

    while( !node->beyond_tail() )
    {
        if ( pLocation == node->value() ) 
        {
            node->remove();
            m_dwNumEntries--;
            
            pLocation->Changed();

            if( pLocation->FromRegistry() )
            {
                // set name to null so server knows to delete it
                pLocation->SetName(NULL);
                m_DeletedLocationList.tail()->insert_after(pLocation);
            }
            else
            {
                delete pLocation;
            }
            break;
        }

        node = node->next();
    }
    
}

/****************************************************************************

    Class : CLocations         
   Method : Remove (with DWORD)
            If location object was read from the registry we must keep it
            around so we can remove its entry when writing back to the registry.
            If it only existed in memory we can just delete it.

****************************************************************************/
void CLocations::Remove(DWORD dwID)
{
    CLocationNode *node = m_LocationList.head(); 
    CLocation   *pLocation;

    while( !node->beyond_tail() )
    {
        if ( dwID == node->value()->GetLocationID() ) 
        {
            pLocation = node->value();

            node->remove();
            m_dwNumEntries--;
            
            pLocation->Changed();

            if( pLocation->FromRegistry() )
            {
                // set name to null so server knows to delete it
                pLocation->SetName(NULL);
                m_DeletedLocationList.tail()->insert_after(pLocation);
            }
            else
            {
                delete pLocation;
            }
            break;
        }

        node = node->next();
    }
    
}



/****************************************************************************

    Class : CLocations         
   Method : Replace
            Replace pLocOld with pLocNew.  These locations must have the same
            location ID.

****************************************************************************/
void CLocations::Replace(CLocation * pLocOld, CLocation * pLocNew)
{
    if ( pLocOld->GetLocationID() != pLocNew->GetLocationID() )
    {
        LOG((TL_ERROR, "Replace: Illegal"));
        return;
    }

    CLocationNode *node = m_LocationList.head(); 

    while( !node->beyond_tail() )
    {
        if ( pLocOld == node->value() ) 
        {
//            node->remove();
//            m_LocationList.tail()->insert_after(pLocNew);
            node->value() = pLocNew;

            delete pLocOld;
            break;
        }

        node = node->next();
    }
}



/****************************************************************************

    Class : CLocations         
   Method : Add
            Put it in the list

****************************************************************************/
void CLocations::Add(CLocation * pLocation)
{
    m_LocationList.tail()->insert_after(pLocation); 
    m_dwNumEntries++;
    
}



/****************************************************************************

    Class : CLocations         
   Method : Reset
            Set enumerator to start    

****************************************************************************/
HRESULT CLocations::Reset(void)
{
    m_hEnumNode = m_LocationList.head();
    return S_OK;
}



/****************************************************************************

    Class : CLocations         
   Method : Next
            get next location in list

****************************************************************************/
HRESULT CLocations::Next(DWORD  NrElem, CLocation **ppLocation, DWORD *pNrElemFetched)
{
    DWORD   dwIndex = 0;
    
    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;

    if(ppLocation==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        *ppLocation++ = m_hEnumNode->value();
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }
    
    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
    
}



/****************************************************************************

    Class : CLocations         
   Method : Skip
            Miss a few    

****************************************************************************/
HRESULT CLocations::Skip(DWORD  NrElem)
{
    DWORD   dwIndex = 0;
    
    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}





/*
 ***************************************************************************
 *********************                          ****************************
 ********************     CCountry Class         ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/


/****************************************************************************

    Class : CCountry         
   Method : Constructer

****************************************************************************/
CCountry::CCountry()
{
    m_dwCountryID = 0;
    m_dwCountryCode = 0;
    m_dwCountryGroup = 0;
    m_pszCountryName = NULL;
}



/****************************************************************************

    Class : CCountry         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CCountry::~CCountry()
{
    if ( m_pszCountryName != NULL )
    {
         ClientFree(m_pszCountryName);
    }   
}



/****************************************************************************

    Class : CCountry         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CCountry::Initialize
                  (                                         
                   DWORD dwCountryID,
                   DWORD dwCountryCode,
                   DWORD dwCountryGroup,
                   PWSTR pszCountryName,
                   PWSTR pszInternationalRule,
                   PWSTR pszLongDistanceRule,
                   PWSTR pszLocalRule
                  )
{
    HRESULT hr = S_OK;


    m_dwCountryID = dwCountryID;
    m_dwCountryCode = dwCountryCode; 
    m_dwCountryGroup = dwCountryGroup;
    
    m_pszCountryName = ClientAllocString( pszCountryName );
    if (m_pszCountryName == NULL)
    {
        LOG(( TL_ERROR, "Initialize - alloc pszLocationName failed" ));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = m_Rules.Initialize(pszInternationalRule,
                           pszLongDistanceRule,
                           pszLocalRule
                          );
    
        if(FAILED(hr) )
        {    
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
                                                        




/*
 ***************************************************************************
 *********************                          ****************************
 ********************    CCountries Class        ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/


/****************************************************************************

    Class : CCountries         
   Method : Constructer

****************************************************************************/
CCountries::CCountries()
{
    m_dwNumEntries = 0;
    m_hEnumNode = m_CountryList.head();
    
}


/****************************************************************************

    Class : CCountries         
   Method : Destructer

****************************************************************************/
CCountries::~CCountries()
{
    CCountryNode *node;

    node = m_CountryList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_CountryList.flush();

}



/****************************************************************************

    Class : CCountries         
   Method : Initialize
            Read the countries list from registry via TAPISRV & build our 
            object list.


****************************************************************************/
HRESULT CCountries::Initialize(void)
{

    LPLINECOUNTRYLIST_INTERNAL pCountryList = NULL;
    
    LPLINECOUNTRYENTRY_INTERNAL pEntry = NULL;
    PWSTR               pszCountryName = NULL;          
    PWSTR               pszInternationalRule = NULL;     
    PWSTR               pszLongDistanceRule = NULL;     
    PWSTR               pszLocalRule = NULL;            
    CCountry          * pCountry = NULL;
    
    DWORD               dwCount = 0;
    DWORD               dwNumEntries = 0;
    LONG                lResult;
    HRESULT             hr;
    


    lResult = ReadCountriesAndGroups( &pCountryList, 0, 0);
    if (lResult == 0) 
    {
         
        // Find position of 1st LINECOUNTRYENTRY structure in the LINECOUNTRYLIST structure 
        pEntry = (LPLINECOUNTRYENTRY_INTERNAL) ((BYTE*)(pCountryList) + pCountryList->dwCountryListOffset );           
    
        dwNumEntries =  pCountryList->dwNumCountries;
        for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
        {

            // Pull Country Info out of LINECOUNTRYENTRY structure
            pszCountryName       = (PWSTR) ((BYTE*)(pCountryList) 
                                                   + pEntry->dwCountryNameOffset);
            pszInternationalRule = (PWSTR) ((BYTE*)(pCountryList) 
                                                   + pEntry->dwInternationalRuleOffset);
            pszLongDistanceRule  = (PWSTR) ((BYTE*)(pCountryList) 
                                                 + pEntry->dwLongDistanceRuleOffset);
            pszLocalRule         = (PWSTR) ((BYTE*)(pCountryList) 
                                                   + pEntry->dwSameAreaRuleOffset);
        
        
            // create our new CCountry Object                
            pCountry = new CCountry;
            if (pCountry)
            {
                // initialize the new CCountry Object
                hr = pCountry->Initialize(pEntry->dwCountryID,
                                          pEntry->dwCountryCode,
                                          pEntry->dwCountryGroup,
                                          pszCountryName,
                                          pszInternationalRule,
                                          pszLongDistanceRule,
                                          pszLocalRule
                                         );

                if( SUCCEEDED(hr) )
                {
                    m_CountryList.tail()->insert_after(pCountry);
                    m_dwNumEntries++;
                }
                else // country initialization failed
                {
                    delete pCountry;
                    LOG((TL_ERROR, "Initialize - country create failed"));
                }
            } 
            else // new CCountry failed
            {
                LOG((TL_ERROR, "Initialize - country create failed"));
            }

            // Try next country in list
            pEntry++;
        }
    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "Initialize - ReadCountries failed"));
        hr = (HRESULT)lResult;
    }

    // finished with TAPI memory block so release
    if ( pCountryList != NULL )
    {
        ClientFree( pCountryList );
    }

    return hr;

}



/****************************************************************************

    Class : CCountries         
   Method : Reset

****************************************************************************/
HRESULT CCountries::Reset(void)
{
    m_hEnumNode = m_CountryList.head();
    return S_OK;
}



/****************************************************************************

    Class : CCountries         
   Method : Next

****************************************************************************/
HRESULT CCountries::Next(DWORD  NrElem, CCountry **ppCcountry, DWORD *pNrElemFetched)
{
    DWORD   dwIndex = 0;
    
    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;

    if(ppCcountry==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        *ppCcountry++ = m_hEnumNode->value();
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }
    
    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
    
}



/****************************************************************************

    Class : CCountries         
   Method : Skip

****************************************************************************/
HRESULT CCountries::Skip(DWORD  NrElem)
{
    DWORD   dwIndex = 0;
    
    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}
























/*
 ***************************************************************************
 *********************                          ****************************
 ********************          Helper            ***************************
 ********************         Functions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/






/****************************************************************************

 Function : ApplyRule
            Parse though a tapi rule string & build dialable & displayable
            strings from the required components.

            out pszDialString      
                pszDisplayString
            
            in  pszRule
                pszLongDistanceCarrier
                pszInternationalCarrier
                pszCountry
                pszCity
                pszSubscriber
                pszCardName
                pszCardAccessNumber
                pszCardAccountNumber
                pszCardPINNumber

****************************************************************************/
LONG ApplyRule (PWSTR pszDialString,
                PWSTR pszDisplayString,
                PWSTR pszRule,
                PWSTR pszDestLDRule,
                PWSTR pszLongDistanceCarrier,
                PWSTR pszInternationalCarrier,
                PWSTR pszCountry,
                PWSTR pszCity,     
                PWSTR pszSubscriber,
                PWSTR pszCardName,
                PWSTR pszCardAccessNumber,
                PWSTR pszCardAccountNumber,
                PWSTR pszCardPINNumber
                )
{
    WCHAR  * pRuleChar;
    DWORD    dwEndString;
    PWSTR    pszAdjustedCity;
    PWSTR    pszSubaddress;
    WCHAR    wcSubaddrSep;

    BOOL    bSpaceExists, bOutOfMem = FALSE;
    HRESULT hr = S_OK;
    
    bSpaceExists = TRUE;

    for (pRuleChar = pszRule; *pRuleChar != '\0' && !bOutOfMem; pRuleChar++)
    {
        switch(*pRuleChar)
        {
            //Dial the Long Distance Carrier Code
            case 'L':
            case 'l':
            case 'N':
            case 'n':
            {
                if (pszLongDistanceCarrier)
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszLongDistanceCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);

                    if (!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszLongDistanceCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }
            //Dial the International Carrier Code
            case 'M':
            case 'm':
            case 'S':
            case 's':
            {
                if (pszInternationalCarrier)
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszInternationalCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);

                    if (!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszInternationalCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }
            // Dial the Country Code
            case 'E':
            case 'e':
            {
                hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszCountry, NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem || FAILED(hr);

                if(!bSpaceExists)
                {
                     hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                     bOutOfMem = bOutOfMem || FAILED(hr);
                }
                hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszCountry, NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem || FAILED(hr);
                hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem || FAILED(hr);
                bSpaceExists = TRUE;
                break;
            }

            // Dial the City/Area Code
            case 'F':
            case 'f':
            case 'I':
            case 'i':
            {
                // adjust the area code (see bug 279092)
                pszAdjustedCity = SkipLDAccessDigits(pszCity, pszDestLDRule);

                if(pszAdjustedCity && *pszAdjustedCity!=L'\0')
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszAdjustedCity, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);

                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszAdjustedCity, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }
            
            // Dial the Subscriber Number
            case 'G':
            case 'g':
            {
                // we let through digits & "AaBbCcDdPpTtWw*#!,@$?;()"
                // but after a '|' or '^' we let all through

                pszSubaddress = pszSubscriber + wcscspn(pszSubscriber, (PWSTR)csSCANSUB);
                wcSubaddrSep = *pszSubaddress;
                *pszSubaddress = L'\0';
                
                if (AppendDigits( pszDialString, pszSubscriber, (PWSTR)csBADCO))
                {
                    bOutOfMem = TRUE;
                }
                else
                {
                    if(wcSubaddrSep != L'\0')
                    {
                        *pszSubaddress = wcSubaddrSep;
                        hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszSubaddress, NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszSubscriber, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    bSpaceExists = FALSE;
                }
                break;
            }

            // Dial the Calling Card Access Number
            case 'J':
            case 'j':
            {
                // just let through digits
                if (AppendDigits( pszDialString, pszCardAccessNumber, L""))
                {
                    bOutOfMem = TRUE;
                }
                else
                {
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszCardAccessNumber, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }

            // Dial the Calling Card Account Number
            case 'K':
            case 'k':
            {
                // just let through digits
                if (AppendDigits( pszDialString, pszCardAccountNumber, L""))
                {
                    bOutOfMem = TRUE;
                }
                else
                {
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem || FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L"[", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszCardName, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L"] ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }

            // Dial the Calling Card PIN Number
            case 'H':
            case 'h':
            {
                hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszCardPINNumber, NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem || FAILED(hr);

                if(!bSpaceExists)
                {
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem || FAILED(hr);
                }
                hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L"**** ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem || FAILED(hr);
                bSpaceExists = TRUE;
                break;
            }

            // Just append the character to the dial/display string
            default:
            {
                dwEndString = lstrlenW(pszDialString);
                if (dwEndString < MaxDialStringSize - 1)
                {
                    pszDialString[dwEndString] = *pRuleChar;
                    pszDialString[dwEndString+1] = '\0';
                }
                else
                {
                    bOutOfMem = TRUE;
                }

                // don't display certain chars
                if (!wcschr(csDISPSUPRESS,*pRuleChar))
                {
                    dwEndString = lstrlenW(pszDisplayString);
                    if (dwEndString < MaxDialStringSize - 1)
                    {
                        pszDisplayString[dwEndString] = *pRuleChar;
                        pszDisplayString[dwEndString+1] = '\0';
                    }
                    else
                    {
                        bOutOfMem = TRUE;
                    }
                }
                bSpaceExists = FALSE;
                break;
            }
        }
    }

    if (bOutOfMem)
    {
        return LINEERR_NOMEM;
    }

    return 0;
}



/****************************************************************************

 Function : TapiPackString
            Takes a string & copys it to a tapi location + offset
            updates the entry offset & size dwords
            returns size of copied string (used to adjust offset for next string)

****************************************************************************/
DWORD TapiPackString(LPBYTE pStructure, 
                     DWORD dwOffset, 
                     DWORD dwTotalSize,
                     PWSTR pszString,
                     PDWORD pdwOffset,
                     PDWORD pdwSize
                     )
{
    DWORD dwSize;

    dwSize = ALIGN((lstrlenW(pszString) + 1) * sizeof(WCHAR));
    if (NULL != pszString)
    {
        StringCchCopyEx((PWSTR)(pStructure + dwOffset), (dwTotalSize - dwOffset)/sizeof(WCHAR), pszString, NULL, NULL, STRSAFE_NO_TRUNCATION);
    }
    else
    {
        *(PWSTR)(pStructure + dwOffset) = L'\0';        
    }
    *pdwOffset = dwOffset;
    *pdwSize = dwSize;

    return dwSize;
}



/****************************************************************************

 Function : PrefixMatch
            Checks if Subscriber number starts with the given prefix
            Takes into account the only the digits.
            returns FALSE if not matched, else TRUE & number of matched chars

****************************************************************************/
BOOL PrefixMatch(PWSTR pszPrefix,PWSTR pszSubscriberString, PDWORD pdwMatched)
{
    DWORD dwCount =0;
    PWSTR pPrefixChar = pszPrefix;
    PWSTR pSSChar = pszSubscriberString;

    // The prefix must be contiguous (without commas etc.)
    while( (*pPrefixChar != '\0') && (*pSSChar != '\0') )
    {

        if(iswdigit(*pSSChar))
        {
            if(*pPrefixChar == *pSSChar) 
            {
                dwCount++;
                pPrefixChar++;
                pSSChar++;
            }
            else // no match
            {
                dwCount= 0;
                break;
            }
        }
        else
        {
            // This was not a digit, skip it
            pSSChar++;
        }
    }

    // just in case subscriber string was shorter than the prefix
    if(*pPrefixChar != '\0')
    {
        dwCount = 0;
    }

    // return values
    *pdwMatched = dwCount;

    if(dwCount !=0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}





/****************************************************************************

 Function : AppendDigits
            Copies only digits up to end of string. 
            Simply exit if string is NULL

****************************************************************************/
LONG AppendDigits( PWSTR pDest,
                   PWSTR pSrc,
                   PWSTR pValidChars
                 )
{
    WCHAR  * pSrcChar;
    WCHAR  * pDestChar;
    LONG     lReturn = 0;
    

    if (pSrc != NULL)
    {
        pDestChar = pDest + lstrlenW(pDest);
        pSrcChar  = pSrc;

        while (*pSrcChar != '\0' && (pDestChar - pDest < MaxDialStringSize - 1))
        {
            if ( iswdigit(*pSrcChar) || (wcschr(pValidChars, *pSrcChar)) )
            {
                *pDestChar++ = *pSrcChar;
            }
            pSrcChar++;
        }
        if (*pSrcChar != '\0')
        {
            lReturn = LINEERR_NOMEM;
        }
    }
    return lReturn;
}


/****************************************************************************

 Function : AreaCodeMatch
            Compares two areas codes. Returns TRUE if they are the same.
            Adjusts internally the area codes using the LD rule given as a parameter. 
            See bug 279092

****************************************************************************/
BOOL AreaCodeMatch(PWSTR pszAreaCode1, PWSTR pszAreaCode2, PWSTR pszRule)
{
    PWSTR   pszAdjustedAreaCode1;
    PWSTR   pszAdjustedAreaCode2;
	BOOL	bRet = FALSE;

    pszAdjustedAreaCode1 = SkipLDAccessDigits(pszAreaCode1, pszRule);
    pszAdjustedAreaCode2 = SkipLDAccessDigits(pszAreaCode2, pszRule);

	if (NULL != pszAdjustedAreaCode1 &&
		NULL != pszAdjustedAreaCode2)
	{
		bRet = (0==lstrcmpW(pszAdjustedAreaCode1, pszAdjustedAreaCode2));
	}

	return bRet;
}



/****************************************************************************

 Function : SkipLDAccessDigits
            Skips the characters from an area code which corespond to a LD access prefix
            Returns a pointer to the correct area code.
            Presumes that the first digits of the rule are in fact the LD acces prefix.
            See bug 279092

****************************************************************************/

PWSTR SkipLDAccessDigits(PWSTR pszAreaCode, PWSTR pszLDRule)
{

    if(pszAreaCode!=NULL)
    {

        // A space in the rule prevents the matching/striping mechanism
        // Uncomment if you don't want that.
        // while(*pszLDRule == L' ')
        //  pszLDRule++;

        //
        // A long distance rule may have a L/l or N/n at the beginning, need to skip it
        //
        if (*pszLDRule == L'L' ||
            *pszLDRule == L'l' ||
            *pszLDRule == L'N' ||
            *pszLDRule == L'n'
           )
        {
            pszLDRule++;
        }

        while(*pszLDRule && iswdigit(*pszLDRule) && *pszAreaCode==*pszLDRule)
        {
            pszAreaCode++;
            pszLDRule++;
        }
    }
    return pszAreaCode;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\location.h ===
/****************************************************************************
 
  Copyright (c) 1998  Microsoft Corporation
                                                              
  Module Name:  location.h
                                                              
     Abstract:  Location Object definitions
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#ifndef __LOCATION_H_
#define __LOCATION_H_


#include "utils.h"
#include "loc_comn.h"                                                   
#include "rules.h"
#include "card.h"


#define CITY_MANDATORY (1)
#define CITY_OPTIONAL (-1)
#define CITY_NONE (0)

#define LONG_DISTANCE_CARRIER_MANDATORY (1)
#define LONG_DISTANCE_CARRIER_OPTIONAL (-1)
#define LONG_DISTANCE_CARRIER_NONE (0)

#define INTERNATIONAL_CARRIER_MANDATORY (1)
#define INTERNATIONAL_CARRIER_OPTIONAL (-1)
#define INTERNATIONAL_CARRIER_NONE (0)


//***************************************************************************
//
//  Class Definition - CCountry
//
//***************************************************************************
class CCountry
{

private:
    DWORD       m_dwCountryID;
    DWORD       m_dwCountryCode;
    DWORD       m_dwCountryGroup;
    PWSTR       m_pszCountryName;
    CRuleSet    m_Rules;



public:
    CCountry();
    ~CCountry();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCountry)
#endif

    STDMETHOD(Initialize) ( DWORD dwCountryID,
                            DWORD dwCountryCode,
                            DWORD dwCountryGroup,
                            PWSTR pszCountryName,
                            PWSTR pszInternationalRule,
                            PWSTR pszLongDistanceRule,
                            PWSTR pszLocalRule
                          ); 

    PWSTR GetInternationalRule(){return m_Rules.m_pszInternationalRule;}
    PWSTR GetLongDistanceRule(){return m_Rules.m_pszLongDistanceRule;}
    PWSTR GetLocalRule(){return m_Rules.m_pszLocalRule;}
    CRuleSet * GetRuleSet(){return &m_Rules;}
    DWORD GetCountryID(){return m_dwCountryID;}
    DWORD GetCountryCode(){return m_dwCountryCode;}
    DWORD GetCountryGroup(){return m_dwCountryGroup;}
    PWSTR GetCountryName(){return m_pszCountryName;}

};


//***************************************************************************
// Fill out the list template

typedef LinkedList<CCountry *> CCountryList;
typedef ListNode<CCountry *> CCountryNode;


//***************************************************************************
//
//  Class Definition - CCountries
//
//***************************************************************************
class CCountries
{
private:

    DWORD               m_dwNumEntries;
    CCountryList        m_CountryList;

    CCountryNode      * m_hEnumNode;

    

public:
    CCountries();
    ~CCountries();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCountries)
#endif

    HRESULT     Initialize(void);

    // a sort of enumerator
    HRESULT     Reset(void);
    HRESULT     Next(DWORD  NrElem, CCountry ** ppCountry, DWORD *pNrElemFetched);
    HRESULT     Skip(DWORD  NrElem);
    

};




//***************************************************************************
//
//  Class Definition - CLocation
//
//***************************************************************************
class CLocation
{
private:
        
    PWSTR            m_pszLocationName;
    PWSTR            m_pszAreaCode;

    PWSTR            m_pszLongDistanceCarrierCode;
    PWSTR            m_pszInternationalCarrierCode;
    PWSTR            m_pszLongDistanceAccessCode;
    PWSTR            m_pszLocalAccessCode;
    PWSTR            m_pszDisableCallWaitingCode;

    DWORD            m_dwLocationID;
    DWORD            m_dwCountryID;
    DWORD            m_dwCountryCode;
    DWORD            m_dwPreferredCardID;
    DWORD            m_dwOptions;
    BOOL             m_bFromRegistry;    // Was this read from the registry
                                         //  or only existed in memory, i.e
                                         //  how do we delete it.

    BOOL             m_bChanged;         // has this entry changed while in
                                         //  memory, if not we don't write it
                                         //  back to server.
    DWORD            m_dwNumRules;


    PWSTR            m_pszTAPIDialingRule;   // temp store used when processing rules

    AreaCodeRulePtrNode * m_hEnumNode;

public:
    AreaCodeRulePtrList m_AreaCodeRuleList;


public:
    CLocation(); 
    ~CLocation();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CLocation)
#endif

    STDMETHOD(Initialize) ( PWSTR pszLocationName,
                            PWSTR pszAreaCode,
                            PWSTR pszLongDistanceCarrierCode,
                            PWSTR pszInternationalCarrierCode,
                            PWSTR pszLongDistanceAccessCode,
                            PWSTR pszLocalAccessCode,
                            PWSTR pszDisableCallWaitingCode,
                            DWORD dwLocationID,
                            DWORD dwCountryID,
                            DWORD dwPreferredCardID,
                            DWORD dwOptions,
                            BOOL  bFromRegistry = FALSE
                           );


    BOOL HasCallWaiting() {return  m_dwOptions & LOCATION_HASCALLWAITING;}
    void UseCallWaiting(BOOL bCw);

    BOOL HasCallingCard(){return  m_dwOptions & LOCATION_USECALLINGCARD;}                        
    void UseCallingCard(BOOL bCc);

    BOOL HasToneDialing(){return  m_dwOptions & LOCATION_USETONEDIALING;}                        
    void UseToneDialing(BOOL bCc);
   
    PWSTR GetName(){return m_pszLocationName;}
    STDMETHOD (SetName)(PWSTR pszLocationName);

    PWSTR GetAreaCode(){return m_pszAreaCode;}
    STDMETHOD (SetAreaCode)(PWSTR pszAreaCode);

    PWSTR GetLongDistanceCarrierCode(){return m_pszLongDistanceCarrierCode;}
    STDMETHOD (SetLongDistanceCarrierCode)(PWSTR pszLongDistanceCarrierCode);

    PWSTR GetInternationalCarrierCode(){return m_pszInternationalCarrierCode;}
    STDMETHOD (SetInternationalCarrierCode)(PWSTR pszInternationalCarrierCode);

    PWSTR GetLongDistanceAccessCode(){return m_pszLongDistanceAccessCode;}
    STDMETHOD (SetLongDistanceAccessCode)(PWSTR pszLongDistanceAccessCode);
   
    PWSTR GetLocalAccessCode(){return m_pszLocalAccessCode;}
    STDMETHOD (SetLocalAccessCode)(PWSTR pszLocalAccessCode);
   
    PWSTR GetDisableCallWaitingCode(){return m_pszDisableCallWaitingCode;}
    STDMETHOD (SetDisableCallWaitingCode)(PWSTR pszDisableCallWaitingCode);


    DWORD GetLocationID() {return m_dwLocationID;}
    
    DWORD GetCountryID() {return m_dwCountryID;}
    void SetCountryID(DWORD dwID) {m_dwCountryID = dwID;}

    DWORD GetCountryCode();
    //void SetCountryCode(DWORD dwCode) {m_dwCountryCode = dwCode;}

    DWORD GetPreferredCardID() {return m_dwPreferredCardID;}
    void SetPreferredCardID(DWORD dwID) {m_dwPreferredCardID = dwID;}

    BOOL FromRegistry(){return  m_bFromRegistry;}
             

    LONG TranslateAddress(PCWSTR         pszAddressIn,
                          CCallingCard * pCallingCard,
                          DWORD          dwTranslateOptions,
                          PDWORD         pdwTranslateResults,
                          PDWORD         pdwDestCountryCode,
                          PWSTR        * pszDialableString,
                          PWSTR        * pszDisplayableString
                         );

    void CLocation::FindRule(
                             DWORD          dwTranslateResults, 
                             DWORD          dwTranslateOptions,
                             CCallingCard * pCard,  
                             CCountry     * pCountry,
                             PWSTR          AreaCodeString, 
                             PWSTR          SubscriberString,
                             PWSTR        * ppRule,
                             PDWORD         dwAccess
                            );




    STDMETHOD(WriteToRegistry)();

    void AddRule(CAreaCodeRule *pNewRule) {m_AreaCodeRuleList.tail()->insert_after(pNewRule);
                                           m_dwNumRules++;
                                           m_bChanged = TRUE;
                                           }
    void RemoveRule(CAreaCodeRule *pRule);
    HRESULT ResetRules(void);
    HRESULT NextRule(DWORD  NrElem, CAreaCodeRule **ppRule, DWORD *pNrElemFetched);
    HRESULT SkipRule(DWORD  NrElem);

    DWORD TapiSize();
    DWORD TapiPack(PLOCATION pLocation, DWORD dwTotalSize);
    DWORD GetNumRules(){return m_dwNumRules;}
    void  Changed(){m_bChanged=TRUE;}
    HRESULT NewID();  // gets new ID from server


};


typedef LinkedList<CLocation *> CLocationList;
typedef ListNode<CLocation *> CLocationNode;


//***************************************************************************
//
//  Class Definition - CLocations
//
//***************************************************************************
class CLocations
{
private:
    
    DWORD           m_dwCurrentLocationID;

    DWORD           m_dwNumEntries;
    CLocationList   m_LocationList;
    CLocationList   m_DeletedLocationList;  // we need to remember these, so we 
                                            //   can delete their reistry entry

    CLocationNode * m_hEnumNode;

    

public:
    CLocations();
    ~CLocations();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CLocations)
#endif

    HRESULT Initialize(void);
    void Remove(CLocation * pLocation);
    void Remove(DWORD dwID);
    void Replace(CLocation * pLocOld, CLocation * pLocNew);
    void Add(CLocation * pLocation);
    HRESULT SaveToRegistry(void);

    DWORD GetCurrentLocationID() {return m_dwCurrentLocationID;}
    void SetCurrentLocationID(DWORD dwLocationID) {m_dwCurrentLocationID = dwLocationID;}

    DWORD GetNumLocations(void) const { return m_dwNumEntries; } ;

    HRESULT Reset(void);
    HRESULT Next(DWORD  NrElem, CLocation **ppLocation, DWORD *pNrElemFetched);
    HRESULT Skip(DWORD  NrElem);
    

};








#endif //__LOCATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\helparray.h ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  helparray.h
                                                              
****************************************************************************/

// a-jmike 2/4/99 VER: HR2
#define IDH_NOHELP	((DWORD) -1)
#define IDH_ADD_PROVIDER_ADD	1001
#define IDH_ADD_PROVIDER_LIST	1002
#define IDH_ADDPREFIX_PREFIXES	1003
#define IDH_AREACODERULE_ADD	1004
#define IDH_AREACODERULE_ALLPREFIXES	1005
#define IDH_AREACODERULE_AREACODE	1006
#define IDH_AREACODERULE_DIALAREACODE	1007
#define IDH_AREACODERULE_DIALNUMBER	1008
#define IDH_AREACODERULE_LIST	1009
#define IDH_AREACODERULE_LISTEDPREFIXES	1010
#define IDH_AREACODERULE_REMOVE	1011
#define IDH_AREACODERULE_SAMPLENUMBER	1012
#define IDH_CARD_ACCESSNUMBER	1013
#define IDH_CARD_CARDNUMBER	1014
#define IDH_CARD_DESTNUMBER	1015
#define IDH_CARD_GENERAL_CARDDETAILS	1016
#define IDH_CARD_GENERAL_CARDNAME	1017
#define IDH_CARD_GENERAL_CARDNUMBER	1018
#define IDH_CARD_GENERAL_PIN	1019
#define IDH_CARD_INTERNATIONALNUMBER	1020
#define IDH_CARD_LIST	1021
#define IDH_CARD_LOCALNUMBER	1022
#define IDH_CARD_LONGDISTANCENUMBER	1023
#define IDH_CARD_MOVEDOWN	1024
#define IDH_CARD_MOVEUP	1025
#define IDH_CARD_PIN	1026
#define IDH_CARD_REMOVE	1027
#define IDH_CARD_SPECIFYDIGITS	1028
#define IDH_CARD_WAITFORPROMPT	1029
#define IDH_DESTNUMBER_AREACODE	1030
#define IDH_DESTNUMBER_COUNTRYCODE	1031
#define IDH_DESTNUMBER_LOCALNUMBER	1032
#define IDH_EDITDIALOG_DIGITS	1033
#define IDH_LOC_AREACODERULES_DELETE	1034
#define IDH_LOC_AREACODERULES_DESCRIPTIONTEXT	1035
#define IDH_LOC_AREACODERULES_EDIT	1036
#define IDH_LOC_AREACODERULES_LIST	1037
#define IDH_LOC_AREACODERULES_NEW	1038
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS	1039
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS_INTERNATIONAL	1040
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LOCAL	1041
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LONG	1042
#define IDH_LOC_CALLINGCARD_CARDNUMBER	1043
#define IDH_LOC_CALLINGCARD_DELETE	1044
#define IDH_LOC_CALLINGCARD_EDIT	1045
#define IDH_LOC_CALLINGCARD_LIST	1046
#define IDH_LOC_CALLINGCARD_NEW	1047
#define IDH_LOC_CALLINGCARD_PIN	1048
#define IDH_LOC_GENERAL_ACCESS_LOCAL	1049
#define IDH_LOC_GENERAL_ACCESS_LONG	1050
#define IDH_LOC_GENERAL_AREACODE	1051
#define IDH_LOC_GENERAL_COUNTRY	1052
#define IDH_LOC_GENERAL_DIALINGRULES_GRP	1053
#define IDH_LOC_GENERAL_DIALUSING	1054
#define IDH_LOC_GENERAL_DISABLECALLWAITING	1055
#define IDH_LOC_GENERAL_LOCATIONNAME	1056
#define IDH_LOC_GENERAL_PHONENUMBERSAMPLE	1057
#define IDH_MAIN_ADVANCED_ADD	1058
#define IDH_MAIN_ADVANCED_EDIT	1059
#define IDH_MAIN_ADVANCED_LIST	1060
#define IDH_MAIN_ADVANCED_REMOVE	1061
#define IDH_MAIN_DIALINGRULES_DELETE	1062
#define IDH_MAIN_DIALINGRULES_EDIT	1063
#define IDH_MAIN_DIALINGRULES_LIST	1064		
#define IDH_MAIN_DIALINGRULES_NEW	1065		
#define IDH_MAIN_DIALINGRULES_PHONENUMBERSAMPLE	1066		
#define IDH_SPECIFYDIGITS_EDIT	1067		
#define IDH_WAITFORDIALOG_WAITFORDIALTONE	1068		
#define IDH_WAITFORDIALOG_WAITFORTIME	1069		
#define IDH_WAITFORDIALOG_WAITFORVOICE	1070		
#define IDH_LOC_LONGDISTANCE_CARRIERCODE 1071
#define IDH_LOC_INTERNATIONAL_CARRIERCODE 1072
#define IDH_LOC_GENERAL_CARRIERCODE 1073

// Dialing Rules Dialog Box (IDD_MAIN_DIALINGRULES == 101)			
const DWORD a101HelpIDs[]=			
{			
	IDC_PHONENUMBERTEXT,	IDH_MAIN_DIALINGRULES_PHONENUMBERSAMPLE,	// Dialing Rules: Phone number will be dialed as: (Static)
	IDC_PHONENUMBERSAMPLE,	IDH_MAIN_DIALINGRULES_PHONENUMBERSAMPLE,	// Dialing Rules:  (Static)
	IDC_NEW,	IDH_MAIN_DIALINGRULES_NEW,	// Dialing Rules: &New... (Button)
	IDC_EDIT,	IDH_MAIN_DIALINGRULES_EDIT,	// Dialing Rules: &Edit... (Button)
	IDC_DELETE,	IDH_MAIN_DIALINGRULES_DELETE,	// Dialing Rules: &Delete (Button)
	IDC_LIST,	IDH_MAIN_DIALINGRULES_LIST,	// Dialing Rules:  (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Dialing Rules:  (Static)
	0, 0		
};			

// General Dialog Box (IDD_LOC_GENERAL == 102)			
const DWORD a102HelpIDs[]=			
{			
	IDC_TONE,	IDH_LOC_GENERAL_DIALUSING,	// General: &Tone (Button)
	IDC_DISABLESTRING,	IDH_LOC_GENERAL_DISABLECALLWAITING,	// General:  (ComboBox)
	2003,	IDH_LOC_GENERAL_DIALINGRULES_GRP,	// General: When dialing from this location, use the following rules: (Static)
	IDC_PULSE,	IDH_LOC_GENERAL_DIALUSING,	// General: &Pulse (Button)
	IDC_LOCATIONNAME,	IDH_LOC_GENERAL_LOCATIONNAME,	// General:  (Edit)
	IDC_PHONENUMBERTEXT,	IDH_LOC_GENERAL_PHONENUMBERSAMPLE,	// General: Phone number will be dialed as: (Static)
	IDC_COUNTRY,	IDH_LOC_GENERAL_COUNTRY,	// General:  (ComboBox)
	IDC_PHONENUMBERSAMPLE,	IDH_LOC_GENERAL_PHONENUMBERSAMPLE,	// General:  (Static)
	IDC_LOCALACCESSNUM,	IDH_LOC_GENERAL_ACCESS_LOCAL,	// General:  (Edit)
	IDC_NOHELP,	IDH_NOHELP,	// General:  (Static)
	IDC_AREACODE,	IDH_LOC_GENERAL_AREACODE,	// General:  (Edit)
	IDC_LONGDISTANCEACCESSNUM,	IDH_LOC_GENERAL_ACCESS_LONG,	// General:  (Edit)
	IDC_INTERNATIONALCARRIERCODE, IDH_LOC_INTERNATIONAL_CARRIERCODE, 
	IDC_LONGDISTANCECARRIERCODE, IDH_LOC_LONGDISTANCE_CARRIERCODE,
	2001,	IDH_NOHELP,	// General: Specify the location from which you will be dialing. (Static)
	IDC_DISABLECALLWAITING,	IDH_LOC_GENERAL_DISABLECALLWAITING,	// General: To disable call &waiting, dial: (Button)
	2002,	IDH_LOC_GENERAL_DIALINGRULES_GRP,	// General: Dialing rules (Button)
	0, 0		
};			

// Area Code Rules Dialog Box (IDD_LOC_AREACODERULES == 103)			
const DWORD a103HelpIDs[]=			
{			
	IDC_DESCRIPTIONTEXT,	IDH_LOC_AREACODERULES_DESCRIPTIONTEXT,	// Area Code Rules:  (Static)
	2006,	IDH_LOC_AREACODERULES_DESCRIPTIONTEXT,	// Area Code Rules: Description (Button)
	IDC_NEW,	IDH_LOC_AREACODERULES_NEW,	// Area Code Rules: &New... (Button)
	IDC_EDIT,	IDH_LOC_AREACODERULES_EDIT,	// Area Code Rules: &Edit... (Button)
	IDC_DELETE,	IDH_LOC_AREACODERULES_DELETE,	// Area Code Rules: &Delete (Button)
	IDC_LIST,	IDH_LOC_AREACODERULES_LIST,	// Area Code Rules:  (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Area Code Rules: An area code rule determines how phone numbers are dialed from your current area code to other area codes and within your area code. (Static)
	0, 0		
};			

// Calling Card Dialog Box (IDD_LOC_CALLINGCARD == 104)			
const DWORD a104HelpIDs[]=			
{			
	IDC_CARDNUMBER,	IDH_LOC_CALLINGCARD_CARDNUMBER,	// Calling Card:  (Edit)
	IDC_LONGDISTANCE,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LONG,	// Calling Card:  (Static)
	IDC_PIN,	IDH_LOC_CALLINGCARD_PIN,	// Calling Card:  (Edit)
	IDC_INTERNATIONAL,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS_INTERNATIONAL,	// Calling Card:  (Static)
	IDC_LOCAL,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LOCAL,	// Calling Card:  (Static)
	IDC_NEW,	IDH_LOC_CALLINGCARD_NEW,	// Calling Card: &New... (Button)
	IDC_EDIT,	IDH_LOC_CALLINGCARD_EDIT,	// Calling Card: &Edit... (Button)
	IDC_DELETE,	IDH_LOC_CALLINGCARD_DELETE,	// Calling Card: &Delete (Button)
	IDC_LIST,	IDH_LOC_CALLINGCARD_LIST,	// Calling Card:  (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Calling Card: Select the calling card you will use, or click New to add a different card. (Static)
	2001,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS,	// Calling Card: Access phone numbers for: (Button)
	0, 0		
};			

// General Dialog Box (IDD_CARD_GENERAL == 105)			
const DWORD a105HelpIDs[]=			
{			
	IDC_CARDNUMBER,	IDH_CARD_GENERAL_CARDNUMBER,	// General:  (Edit)
	IDC_PIN,	IDH_CARD_GENERAL_PIN,	// General:  (Edit)
	IDC_CARDNAME,	IDH_CARD_GENERAL_CARDNAME,	// General:  (Edit)
	IDC_CARDUSAGE,	IDH_CARD_GENERAL_CARDDETAILS,	
	IDC_CARDUSAGE1,	IDH_CARD_GENERAL_CARDDETAILS,	
	IDC_CARDUSAGE2,	IDH_CARD_GENERAL_CARDDETAILS,	// General:  (Static)
	IDC_CARDUSAGE3,	IDH_CARD_GENERAL_CARDDETAILS,	// General:  (Static)
	IDC_NOHELP,	IDH_NOHELP,	// General:  (Static)
	2001,	IDH_CARD_GENERAL_CARDDETAILS,	// General: Calling card details: (Button)
	0, 0		
};			

// Long Distance Dialog Box (IDD_CARD_LONGDISTANCE == 106)			
const DWORD a106HelpIDs[]=			
{			
	IDC_WAITFOR,	IDH_CARD_WAITFORPROMPT,	// Long Distance: &Wait for Prompt... (Button)
	IDC_CARDNUMBER,	IDH_CARD_CARDNUMBER,	// Long Distance: A&ccount Number (Button)
	IDC_PIN,	IDH_CARD_PIN,	// Long Distance: &PIN (Button)
	IDC_DESTNUMBER,	IDH_CARD_DESTNUMBER,	// Long Distance: &Destination Number... (Button)
	IDC_LONGDISTANCENUMBER,	IDH_CARD_LONGDISTANCENUMBER,	// Long Distance:  (Edit)
	IDC_SPECIFYDIGITS,	IDH_CARD_SPECIFYDIGITS,	// Long Distance: &Specify Digits... (Button)
	IDC_MOVEUP,	IDH_CARD_MOVEUP,	// Long Distance: Move &Up (Button)
	IDC_MOVEDOWN,	IDH_CARD_MOVEDOWN,	// Long Distance: &Move Down (Button)
	IDC_REMOVE,	IDH_CARD_REMOVE,	// Long Distance: &Delete (Button)
	IDC_ACCESSNUMBER,	IDH_CARD_ACCESSNUMBER,	// Long Distance: Access &Number (Button)
	IDC_LIST,	IDH_CARD_LIST,	// Long Distance: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Long Distance: Use the buttons below to enter the dialing steps for making long-distance calls.  Enter these steps in the exact order as they appear on your calling card. (Static)
	0, 0		
};			

// International Dialog Box (IDD_CARD_INTERNATIONAL == 107)			
const DWORD a107HelpIDs[]=			
{			
	IDC_WAITFOR,	IDH_CARD_WAITFORPROMPT,	// International: &Wait for Prompt... (Button)
	IDC_CARDNUMBER,	IDH_CARD_CARDNUMBER,	// International: A&ccount Number (Button)
	IDC_PIN,	IDH_CARD_PIN,	// International: &PIN (Button)
	IDC_DESTNUMBER,	IDH_CARD_DESTNUMBER,	// International: D&estination Number... (Button)
	IDC_SPECIFYDIGITS,	IDH_CARD_SPECIFYDIGITS,	// International: &Specify Digits... (Button)
	IDC_INTERNATIONALNUMBER,	IDH_CARD_INTERNATIONALNUMBER,	// International:  (Edit)
	IDC_MOVEUP,	IDH_CARD_MOVEUP,	// International: Move &Up (Button)
	IDC_MOVEDOWN,	IDH_CARD_MOVEDOWN,	// International: &Move Down (Button)
	IDC_REMOVE,	IDH_CARD_REMOVE,	// International: &Delete (Button)
	IDC_ACCESSNUMBER,	IDH_CARD_ACCESSNUMBER,	// International: Access &Number (Button)
	IDC_LIST,	IDH_CARD_LIST,	// International: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// International: Use the buttons below to enter the dialing steps for making international calls.  Enter these steps in the exact order as they appear on your calling card. (Static)
	0, 0		
};			

// Local Calls Dialog Box (IDD_CARD_LOCALCALLS == 108)			
const DWORD a108HelpIDs[]=			
{			
	IDC_WAITFOR,	IDH_CARD_WAITFORPROMPT,	// Local Calls: &Wait for Prompt... (Button)
	IDC_CARDNUMBER,	IDH_CARD_CARDNUMBER,	// Local Calls: A&ccount Number (Button)
	IDC_PIN,	IDH_CARD_PIN,	// Local Calls: &PIN (Button)
	IDC_DESTNUMBER,	IDH_CARD_DESTNUMBER,	// Local Calls: D&estination Number... (Button)
	IDC_SPECIFYDIGITS,	IDH_CARD_SPECIFYDIGITS,	// Local Calls: &Specify Digits... (Button)
	IDC_MOVEUP,	IDH_CARD_MOVEUP,	// Local Calls: Move &Up (Button)
	IDC_MOVEDOWN,	IDH_CARD_MOVEDOWN,	// Local Calls: &Move Down (Button)
	IDC_REMOVE,	IDH_CARD_REMOVE,	// Local Calls: &Delete (Button)
	IDC_ACCESSNUMBER,	IDH_CARD_ACCESSNUMBER,	// Local Calls: Access &Number (Button)
	IDC_LOCALNUMBER,	IDH_CARD_LOCALNUMBER,	// Local Calls:  (Edit)
	IDC_LIST,	IDH_CARD_LIST,	// Local Calls: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Local Calls: Use the buttons below to enter the dialing steps for making local calls. Enter these steps in the exact order as they appear on your calling card. To make local calls without using your calling card, leave this section blank. (Static)
	0, 0		
};			

// New Area Code Rule Dialog Box (IDD_NEWAREACODERULE == 109)			
const DWORD a109HelpIDs[]=			
{			
	2001,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule: Area code (Static)
	2002,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule: Prefix (Static)
	2003,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule:  (Static)
	2004,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule:  (Static)
	2005,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule: X - X X X - X X X - X X X X (Static)
	IDC_ALLPREFIXES,	IDH_AREACODERULE_ALLPREFIXES,	// New Area Code Rule: &Include all the prefixes within this area code (Button)
	IDC_LISTEDPREFIXES,	IDH_AREACODERULE_LISTEDPREFIXES,	// New Area Code Rule: Include &only the prefixes in the list below: (Button)
	IDC_REMOVE,	IDH_AREACODERULE_REMOVE,	// New Area Code Rule: D&elete (Button)
	IDC_ADD,	IDH_AREACODERULE_ADD,	// New Area Code Rule: &Add... (Button)
	IDC_DIALAREACODE,	IDH_AREACODERULE_DIALAREACODE,	// New Area Code Rule: Include the area &code (Button)
	IDC_DIALNUMBER,	IDH_AREACODERULE_DIALNUMBER,	// New Area Code Rule:  (Edit)
	IDC_LIST,	IDH_AREACODERULE_LIST,	// New Area Code Rule: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// New Area Code Rule: This area code rule will only apply to calls made to the area code and prefix combination you specify below. (Static)
	IDC_AREACODE,	IDH_AREACODERULE_AREACODE,	// New Area Code Rule:  (Edit)
	IDC_DIALCHECK,	IDH_AREACODERULE_DIALNUMBER,	// New Area Code Rule: &Dial: (Button)
	0, 0		
};			

// Wait for Dialog Box (IDD_WAITFORDIALOG == 111)			
const DWORD a111HelpIDs[]=			
{			
	IDC_WAITFORVOICE,	IDH_WAITFORDIALOG_WAITFORVOICE,	// Wait for: Wait for a &voice message to complete (Button)
	IDC_WAITFORTIME,	IDH_WAITFORDIALOG_WAITFORTIME,	// Wait for: Wait for a specific length of &time: (Button)
	IDC_TIMESPIN,	IDH_WAITFORDIALOG_WAITFORTIME,	// Wait for: Spin1 (msctls_updown32)
	IDC_TIME,	IDH_WAITFORDIALOG_WAITFORTIME,	// Wait for: 0 (Edit)
	IDC_WAITFORDIALTONE,	IDH_WAITFORDIALOG_WAITFORDIALTONE,	// Wait for: Wait for a &dial tone (Button)
	IDC_NOHELP,	IDH_NOHELP,	// Wait for: Select the type of prompt to wait for before continuing with the dialing sequence. (Static)
	0, 0		
};			

// Destination number Dialog Box (IDD_DESTNUMDIALOG == 112)			
const DWORD a112HelpIDs[]=			
{			
	IDC_COUNTRYCODE,	IDH_DESTNUMBER_COUNTRYCODE,	// Destination number: Dial the &country code (Button)
	IDC_LOCALNUMBER,	IDH_DESTNUMBER_LOCALNUMBER,	// Destination number: Dial the &number (Button)
	IDC_NOHELP,	IDH_NOHELP,	// Destination number: This step will place the destination number that you will be dialing into the calling card sequence.  When dialing the destination number, which parts of the number do you want to dial? (Static)
	IDC_AREACODE,	IDH_DESTNUMBER_AREACODE,	// Destination number: Dial the &area code (Button)
	0, 0		
};			

// Advanced Dialog Box (IDD_MAIN_ADVANCED == 113)			
const DWORD a113HelpIDs[]=			
{			
	IDC_REMOVE,	IDH_MAIN_ADVANCED_REMOVE,	// Advanced: &Remove (Button)
	IDC_ADD,	IDH_MAIN_ADVANCED_ADD,	// Advanced: A&dd... (Button)
	IDC_EDIT,	IDH_MAIN_ADVANCED_EDIT,	// Advanced: &Configure... (Button)
	IDC_LIST,	IDH_MAIN_ADVANCED_LIST,	// Advanced:  (ListBox)
	IDC_NOHELP,	IDH_NOHELP,	// Advanced:  (Static)
	0, 0		
};			

// Add Driver Dialog Box (IDD_ADD_DRIVER == 114)			
const DWORD a114HelpIDs[]=			
{			
	IDC_ADD,	IDH_ADD_PROVIDER_ADD,	// Add Driver: &Add (Button)
	IDC_DRIVER_LIST,	IDH_ADD_PROVIDER_LIST,	// Add Driver:  (ListBox)
	IDC_NOHELP,	IDH_NOHELP,	// Add Driver: Select the driver you wish to install from the list below, and click Add. (Static)
	0, 0		
};			

// Location Information Dialog Box (IDD_SIMPLELOCATION == 115)			
const DWORD a115HelpIDs[]=			
{			
	IDC_TONE,	IDH_LOC_GENERAL_DIALUSING,	// Location Information: &Tone dialing (Button)
	IDC_PULSE,	IDH_LOC_GENERAL_DIALUSING,	// Location Information: &Pulse dialing (Button)
	IDB_SIMPLELOCATION,	IDH_NOHELP,	// Location Information:  (Static)
	IDC_COUNTRY,	IDH_LOC_GENERAL_COUNTRY,	// Location Information:  (ComboBox)
	IDC_LOCALACCESSNUM,	IDH_LOC_GENERAL_ACCESS_LOCAL,	// Location Information:  (Edit)
	IDC_NOHELP,	IDH_NOHELP,	// Location Information: Before you can make any phone or modem connections, Windows needs the following information about your current location. (Static)
	IDC_AREACODE,	IDH_LOC_GENERAL_AREACODE,	// Location Information:  (Edit)
	IDC_CARRIERCODE, IDH_LOC_GENERAL_CARRIERCODE,
	0, 0		
};		

// Untitled Dialog Box (IDD_EDITPREFIX == 116) for editing the prefix		
const DWORD a116HelpIDs[]=		
{		
	IDC_DESCRIPTIONTEXT,	IDH_ADDPREFIX_PREFIXES,
	IDC_TEXT,	IDH_ADDPREFIX_PREFIXES,
	IDC_EDIT,	IDH_ADDPREFIX_PREFIXES,
	0, 0	
};		

// Untitled Dialog Box (IDD_EDITDIGITS == 117) for editing the digits		
const DWORD a117HelpIDs[]=		
{		
	IDC_DESCRIPTIONTEXT,	IDH_SPECIFYDIGITS_EDIT,
	IDC_TEXT,	IDH_SPECIFYDIGITS_EDIT,	
	IDC_EDIT,	IDH_SPECIFYDIGITS_EDIT,	
	0, 0		
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\makefile.inc ===
$(O)\tapsrvrpc.c: ..\idl\$(O)\tapsrv_c.c
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\perfctr.h ===
/****************************************************************************
 
  Copyright (c) 1996-1999 Microsoft Corporation
                                                              
  Module Name:  perfctr.h
              
****************************************************************************/

//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values for the device they belong to, 
//  in order to determine the absolute location of the counter and 
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the 
//  counter name and Explain text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define TAPIOBJ                 0
#define NUMLINES                2
#define CURRENTOPENS            4
#define TOTALOUTGOINGCALLS      6
#define TOTALINCOMINGCALLS      8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\list.h ===
/*
 *	File:	list.h
 *	Author:	John R. Douceur
 *	Date:	19 November 1997
 *  Copyright (c) 1997-1999 Microsoft Corporation
 */

#ifndef _INC_LIST

#define _INC_LIST

#include <malloc.h>

template<class Class> class LinkedList;
template<class Class> class NodePool;

template<class Class> class ListNode
{
public:

	bool before_head() const {return previous_node == 0;}
	bool beyond_tail() const {return next_node == 0;}

	Class &value() {return node_value;}

	ListNode<Class> *next() const {return next_node;}
	ListNode<Class> *previous() const {return previous_node;}

	ListNode<Class> *insert_before();
	ListNode<Class> *insert_after();

	ListNode<Class> *insert_before(Class object);
	ListNode<Class> *insert_after(Class object);

	ListNode<Class> *insert_before(ListNode<Class> *node);
	ListNode<Class> *insert_after(ListNode<Class> *node);

	ListNode<Class> *insert_before(LinkedList<Class> *list);
	ListNode<Class> *insert_after(LinkedList<Class> *list);

	void remove();
	ListNode<Class> *remove_forward();
	ListNode<Class> *remove_backward();

	friend class LinkedList<Class>;
	friend class NodePool<Class>;

	~ListNode() {}

private:
	ListNode() {}

	Class node_value;
	ListNode *next_node;
	ListNode *previous_node;
};

template<class Class> class LinkedList
{
public:

	LinkedList();

	~LinkedList();

	ListNode<Class> *head() const {return list_head.next_node;}

	ListNode<Class> *tail() const {return list_tail.previous_node;}

	bool is_empty() const {return list_head.next_node->next_node == 0;}

	void flush();

	friend class ListNode<Class>;
	friend class NodePool<Class>;

private:

	ListNode<Class> list_head;
	ListNode<Class> list_tail;
};

template<class Class> struct NodeGroup
{
	NodeGroup<Class> *next_group;
	ListNode<Class> nodes[1];
};

template<class Class> class NodePool
{
public:

	friend class ListNode<Class>;
	friend class LinkedList<Class>;

	static void initialize(void);
	static void uninitialize(void);

private:

	static ListNode<Class> *allocate();

	static void deallocate(ListNode<Class> *node);
	static void deallocate(LinkedList<Class> *list);

	static	CRITICAL_SECTION	critical_section;

	static int group_size;
	static const int max_group_size;
	static NodeGroup<Class> *group_list;
	static ListNode<Class> *node_list;
};

template<class Class> const int NodePool<Class>::max_group_size = 1024;


template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before()
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->previous_node = previous_node;
	node->next_node = this;
	previous_node->next_node = node;
	previous_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after()
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->next_node = next_node;
	node->previous_node = this;
	next_node->previous_node = node;
	next_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before(
	Class object)
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->previous_node = previous_node;
	node->next_node = this;
	node->node_value = object;
	previous_node->next_node = node;
	previous_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after(
	Class object)
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->next_node = next_node;
	node->previous_node = this;
	node->node_value = object;
	next_node->previous_node = node;
	next_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before(
	ListNode<Class> *node)
{
	node->previous_node->next_node = node->next_node;
	node->next_node->previous_node = node->previous_node;
	node->previous_node = previous_node;
	node->next_node = this;
	previous_node->next_node = node;
	previous_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after(
	ListNode<Class> *node)
{
	node->previous_node->next_node = node->next_node;
	node->next_node->previous_node = node->previous_node;
	node->next_node = next_node;
	node->previous_node = this;
	next_node->previous_node = node;
	next_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before(
	LinkedList<Class> *list)
{
	if (!list->is_empty())
	{
		ListNode<Class> *old_head = list->list_head.next_node;
		previous_node->next_node = old_head;
		old_head->previous_node = previous_node;
		previous_node = list->list_tail.previous_node;
		previous_node->next_node = this;
		list->list_head.next_node = &list->list_tail;
		list->list_tail.previous_node = &list->list_head;
		return old_head;
	}
	else
	{
		return this;
	}
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after(
	LinkedList<Class> *list)
{
	if (!list->is_empty())
	{
		ListNode<Class> *old_tail = list->list_tail.previous_node;
		next_node->previous_node = old_tail;
		old_tail->next_node = next_node;
		next_node = list->list_head.next_node;
		next_node->previous_node = this;
		list->list_tail.previous_node = &list->list_head;
		list->list_head.next_node = &list->list_tail;
		return old_tail;
	}
	else
	{
		return this;
	}
}

template<class Class>
void
ListNode<Class>::remove()
{
	previous_node->next_node = next_node;
	next_node->previous_node = previous_node;
	NodePool<Class>::deallocate(this);
}

template<class Class>
ListNode<Class> *
ListNode<Class>::remove_forward()
{
	ListNode<Class> *node = next_node;
	previous_node->next_node = next_node;
	next_node->previous_node = previous_node;
	NodePool<Class>::deallocate(this);
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::remove_backward()
{
	ListNode<Class> *node = previous_node;
	previous_node->next_node = next_node;
	next_node->previous_node = previous_node;
	NodePool<Class>::deallocate(this);
	return node;
}


template<class Class>
LinkedList<Class>::LinkedList()
{
	list_head.next_node = &list_tail;
	list_head.previous_node = 0;
	list_tail.next_node = 0;
	list_tail.previous_node = &list_head;
}

template<class Class>
LinkedList<Class>::~LinkedList()
{
	NodePool<Class>::deallocate(this);
}

template<class Class>
void
LinkedList<Class>::flush()
{
	NodePool<Class>::deallocate(this);
}


template<class Class> int NodePool<Class>::group_size = 1;
template<class Class> NodeGroup<Class> * NodePool<Class>::group_list = 0;
template<class Class> ListNode<Class> * NodePool<Class>::node_list = 0;
template<class Class> CRITICAL_SECTION NodePool<Class>::critical_section = {0};

template<class Class>
void NodePool<Class>::initialize()
{
	InitializeCriticalSection(&critical_section);
}

template<class Class>
void NodePool<Class>::uninitialize()
{
	DeleteCriticalSection(&critical_section);
}

template<class Class>
ListNode<Class> *
NodePool<Class>::allocate()
{

	EnterCriticalSection(&critical_section);
	
	if (node_list == 0)
	{
		NodeGroup<Class> *node_group =
			(NodeGroup<Class> *)malloc(sizeof(NodeGroup<Class>) +
			(group_size - 1) * sizeof(ListNode<Class>));
		while (node_group == 0 && group_size > 1)
		{
			group_size /= 2;
			node_group =
				(NodeGroup<Class> *)malloc(sizeof(NodeGroup<Class>) +
				(group_size - 1) * sizeof(ListNode<Class>));
		}
		if (node_group == 0)
		{
			LeaveCriticalSection(&critical_section);
			return 0;
		}
		node_group->next_group = group_list;
		group_list = node_group;
		for (int index = 0; index < group_size; index++)
		{
			node_group->nodes[index].next_node = node_list;
			node_list = &node_group->nodes[index];
		}
		group_size *= 2;
		if (group_size > max_group_size)
		{
			group_size = max_group_size;
		}
	}
	ListNode<Class> *node = node_list;
	node_list = node->next_node;
	
	LeaveCriticalSection(&critical_section);
	
	return node;
}

template<class Class>
void
NodePool<Class>::deallocate(
	ListNode<Class> *node)
{
	EnterCriticalSection(&critical_section);

	node->next_node = node_list;
	node_list = node;

	LeaveCriticalSection(&critical_section);
}

template<class Class>
void
NodePool<Class>::deallocate(
	LinkedList<Class> *list)
{
	EnterCriticalSection(&critical_section);
	
	if (!list->is_empty())
	{
		list->list_tail.previous_node->next_node = node_list;
		node_list = list->list_head.next_node;
		list->list_tail.previous_node = &list->list_head;
		list->list_head.next_node = &list->list_tail;
	}
	
	LeaveCriticalSection(&critical_section);

}

#endif	/* _INC_LIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\resource.h ===
/****************************************************************************
 
  Copyright (c) 1999 Microsoft Corporation
                                                              
  Module Name:  resource.h
                                                
***************************************************************************/


#ifndef CLIENT_RESOURCE
#define CLIENT_RESOURCE

#define IDS_DEFAULT_STATUS 1000
#define IDS_LOGONDESKNAME  1001

#endif // CLIENT_RESOURCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\utils.h ===
#ifndef __CLIENT_UTILS_H__
#define __CLIENT_UTILS_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef TRACELOG
	#include <tchar.h>
	#include <stdio.h>
	#include <stdarg.h>
	#include <windows.h>
	#include <winbase.h>
    #include <rtutils.h>
	#include "tapi.h"

	
    #define MAXDEBUGSTRINGLENGTH 1024

    #define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL  TRACELogRegister(LPCTSTR szName);
    void  TRACELogDeRegister();
    void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

    extern char *TraceLevel(DWORD dwDbgLevel);
    extern void TAPIFormatMessage(HRESULT hr, LPVOID lpMsgBuf);

    #define TRACELOGREGISTER(arg) TRACELogRegister(arg)
    #define TRACELOGDEREGISTER() TRACELogDeRegister()
	#define LOG(arg) TRACELogPrint arg

	extern char    sg_szTraceName[100];
	extern DWORD   sg_dwTracingToDebugger;
	extern DWORD   sg_dwDebuggerMask;
    extern DWORD   sg_dwTraceID;

    #define DECLARE_TRACELOG_CLASS(x)                                                                   \
        void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)                          \
        {																								\
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			va_list arglist;																			\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] (%p) %s::",							\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  this,																			\
						  _T(#x));																		\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				lstrcatA (szTraceBuf, "\n");															\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] (%p) %s::%s", TraceLevel(dwDbgLevel), this, _T(#x), lpszFormat);	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
        }                                                                                               \
                                                                                                        \
        void  TRACELogPrint(IN DWORD dwDbgLevel,IN HRESULT hr, IN LPCSTR lpszFormat, IN ...)            \
        {                                                                                               \
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			LPVOID  lpMsgBuf = NULL;																	\
			va_list arglist;																			\
																										\
			TAPIFormatMessage(hr, &lpMsgBuf);															\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] (%p) %s::",							\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  this,																			\
						  _T(#x)																		\
						  );																			\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				wsprintfA(&szTraceBuf[lstrlenA(szTraceBuf)],											\
						  " Returned[%lx] %s\n",														\
						  hr,																			\
						  lpMsgBuf);																	\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] (%p) %s::%s  Returned[%lx] %s", TraceLevel(dwDbgLevel), this, _T(#x), lpszFormat,hr, lpMsgBuf );	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
																										\
			if(lpMsgBuf != NULL)																		\
			{																							\
				LocalFree( lpMsgBuf );																	\
			}																							\
        }																								\
                                                                                                        \
        static void  StaticTRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)             \
        {																								\
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			va_list arglist;																			\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] %s::",									\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  _T(#x));																		\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				lstrcatA (szTraceBuf, "\n");															\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] %s::%s", TraceLevel(dwDbgLevel), _T(#x), lpszFormat);		\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
        }                                                                                               \
                                                                                                        \
        static void StaticTRACELogPrint(IN DWORD dwDbgLevel,IN HRESULT hr, IN LPCSTR lpszFormat, IN ...)      \
        {                                                                                               \
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			LPVOID  lpMsgBuf = NULL;																	\
			va_list arglist;																			\
																										\
			TAPIFormatMessage(hr, &lpMsgBuf);															\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] %s::",									\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  _T(#x)																		\
						  );																			\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				wsprintfA(&szTraceBuf[lstrlenA(szTraceBuf)],											\
						  " Returned[%lx] %s\n",														\
						  hr,																			\
						  lpMsgBuf);																	\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] %s::%s  Returned[%lx] %s", TraceLevel(dwDbgLevel), _T(#x), lpszFormat,hr, lpMsgBuf );	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
																										\
			if(lpMsgBuf != NULL)																		\
			{																							\
				LocalFree( lpMsgBuf );																	\
			}																							\
        }

#else // TRACELOG not defined

    #define TRACELOGREGISTER(arg)
    #define TRACELOGDEREGISTER()
    #define LOG(arg)
	#define STATICLOG(arg)
    #define DECLARE_TRACELOG_CLASS(x)

#endif // TRACELOG

#ifdef __cplusplus
}
#endif

#endif //__CLIENT_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\cpl\cpl.cpp ===
// The CPL basics
#include "precomp.h"

// Prototypes

LONG OnCPlInit();
LONG OnCPlGetCount();
LONG OnCPlInquire( int i, CPLINFO * pci );
LONG OnCPlDblClk( int i, HWND hwndParent, LPTSTR pszCmdLine );
LONG OnCPlStop( int i, LPARAM lData );
LONG OnCPlExit();

void DisplayDialingRulesPropertyPage(HWND hwndCPl, int iTab);


// Global Variables

HINSTANCE g_hInst;


// DllMain
//
// This is the DLL entry point, called whenever the DLL is loaded.

extern "C" BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved )
{
    // Perform actions based on the reason for calling.
    switch( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hinstDLL;
        break;

    case DLL_THREAD_ATTACH:
     // Do thread-specific initialization.
        break;

    case DLL_THREAD_DETACH:
     // Do thread-specific cleanup.
        break;

    case DLL_PROCESS_DETACH:
     // Perform any necessary cleanup.
        break;

    default:
        break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}


// CPlApplet
//
// This is the main entry point for a CPl applet.  This exported function
// is called by the control panel.

LONG APIENTRY CPlApplet(
    HWND    hwndCPl,
    UINT    uMsg,
    LPARAM  lParam1,
    LPARAM  lParam2
)
{
    switch (uMsg )
    {
    case CPL_INIT:
        return OnCPlInit();

    case CPL_GETCOUNT:
        return OnCPlGetCount();

    case CPL_INQUIRE:
        return OnCPlInquire((int)lParam1, (CPLINFO*)lParam2);

    case CPL_DBLCLK:
        lParam2 = 0;
        //fall through

    case CPL_STARTWPARMS:
        return OnCPlDblClk((int)lParam1, hwndCPl, (LPTSTR)lParam2);

    case CPL_STOP:
        return OnCPlStop((int)lParam1, lParam2);

    case CPL_EXIT:
        return OnCPlExit();
    }

    return 0;
}

 
// OnCPlInit
//
// Before any required initialization.
// Return zero to abort the CPl and non-zero on successful initialization.
   
LONG OnCPlInit()
{
    return (0 == GetSystemMetrics (SM_CLEANBOOT))?TRUE:FALSE;
}


// OnCPlGetCount
//
// Returns the number of CPl dialogs implemented by this DLL.

LONG OnCPlGetCount()
{
    return 1;
}


// OnCPlInquire
//
// Fills out a CPLINFO structure with information about the CPl dialog.
// This information includes the name, icon, and description.

LONG OnCPlInquire( int i, CPLINFO * pci )
{
    pci->idIcon = IDI_TELEPHONE;
    pci->idName = IDS_NAME;
    pci->idInfo = IDS_DESCRIPTION;
    pci->lData  = 0;
    return 0;
}


// OnCPlDblClk
//
// This message is sent whenever our CPl is selected.  In response we display
// our UI and handle input.  This is also used when we are started with parameters
// in which case we get passed a command line.

LONG OnCPlDblClk( int i, HWND hwndCPl, LPTSTR pszCmdLine )
{
    int iTab = 0;

    if ( pszCmdLine )
    {
        iTab = *pszCmdLine - TEXT('0');
        if ( (iTab < 0) || (iTab > 2) )
        {
            iTab = 0;
        }
    }

    DisplayDialingRulesPropertyPage(hwndCPl, iTab);

    return TRUE;
}


// OnCPlStop
//
// Any resource allocated on a per-dialog basis in OnCPlInquire should be
// freed in this function.  The lData member of the CPLINFO structure that
// was initialized in OnCPlInit is passed to this function.

LONG OnCPlStop( int i, LPARAM lData )
{
    return 0;
}


// OnCPlExit
//
// This is the final message we recieve.  Any memory that was allocated in
// OnCPlInit should be freed here.  Release any resources we are holding.

LONG OnCPlExit()
{
    return 0;
}

typedef LONG (WINAPI *CONFIGPROC)(HWND, PWSTR, INT, DWORD);

void DisplayDialingRulesPropertyPage(HWND hwndCPl, int iTab)
{
    // Load tapi32 and call InternalConfig of something like that
    HINSTANCE hTapi = LoadLibrary(TEXT("TAPI32.DLL"));
    if ( hTapi )
    {
        CONFIGPROC pfnInternalConfig = (CONFIGPROC)GetProcAddress(hTapi, "internalConfig");
        if ( pfnInternalConfig )
        {
            pfnInternalConfig( hwndCPl, NULL, iTab, TAPI_CURRENT_VERSION );
            return;
        }
    }

    // TODO: Show some sort of error dialog?  Maybe something that says "your
    // tapi32.dll is missing or corrupt, please reinstall."
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\tapireg.c ===
/****************************************************************************
 
  Copyright (c) 1996-1999 Microsoft Corporation
                                                              
  Module Name:  tapireg.c
                                                              
****************************************************************************/

#ifndef UNICODE

// These wrappers are only used when compiling for ANSI.

#include <windows.h>
#include <windowsx.h>

#include <tapi.h>
#include <tspi.h>

#include "utils.h"
#include "client.h"
#include "private.h"

#include "loc_comn.h"

//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG TAPIRegQueryValueExW(
                           HKEY hKey,
                           const CHAR *SectionName,
                           LPDWORD lpdwReserved,
                           LPDWORD lpType,
                           LPBYTE  lpData,
                           LPDWORD lpcbData
                          )
{
    WCHAR *szTempBuffer;
    LONG  lResult;

    lResult = RegQueryValueEx(
                     hKey,
                     SectionName,
                     lpdwReserved,
                     lpType,
                     lpData,
                     lpcbData
                   );

     //
     // Any problems?
     //
     if ( lResult )
     {
         //
         // Yup.  Go away.
         //
         return lResult;
     }

     if (
           (REG_SZ == *lpType)
         &&
           (NULL != lpData)
        )
     {
         if ( NULL == (szTempBuffer = LocalAlloc( LPTR, *lpcbData * sizeof(WCHAR)) ) )
         {
             LOG((TL_ERROR, "Alloc failed - QUERYVALW - 0x%08lx", *lpcbData));
             return ERROR_NOT_ENOUGH_MEMORY;
         }

         MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpData,
                        -1,
                        szTempBuffer,
                        *lpcbData
                        );

         wcscpy( (PWSTR) lpData, szTempBuffer );

         LocalFree( szTempBuffer );

//         *lpcbData = ( lstrlenW( (PWSTR)lpData ) + 1 ) * sizeof(WCHAR);
     }

    //
    // Need to adjust the size here because lpData might be NULL, but
    // the size needs to reflect WIDE CHAR size (cause we were using
    // the ANSI version of ReqQuery)
    //
    *lpcbData = (*lpcbData + 1) * sizeof(WCHAR);

    return 0;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG TAPIRegSetValueExW(
                         HKEY    hKey,
                         const CHAR    *SectionName,
                         DWORD   dwReserved,
                         DWORD   dwType,
                         LPBYTE  lpData,
                         DWORD   cbData
                        )
{
    CHAR *szTempBuffer;
    DWORD dwSize;
    LONG  lResult;


    //
    // Only convert the data if this is a Unicode string
    //
    if ( REG_SZ == dwType )
    {
        dwSize = WideCharToMultiByte(
                  GetACP(),
                  0,
                  (PWSTR)lpData,
                  cbData,
                  NULL,
                  0,
                  NULL,
                  NULL
               );

        if ( NULL == (szTempBuffer = LocalAlloc( LPTR, dwSize )) )
        {
            LOG((TL_ERROR, "Alloc failed - SETVALW - 0x%08lx", dwSize));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwSize = WideCharToMultiByte(
                  GetACP(),
                  0,
                  (PWSTR)lpData,
                  cbData,
                  szTempBuffer,
                  dwSize,
                  NULL,
                  NULL
               );
    }

    
    lResult = RegSetValueExA(
                  hKey,
                  SectionName,
                  dwReserved,
                  dwType,
                  (REG_SZ == dwType) ?
                        szTempBuffer :
                        lpData,
                  cbData
                 );

    if (REG_SZ == dwType)
    {
        LocalFree( szTempBuffer );
    }

    return lResult;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
int TAPILoadStringW(
                HINSTANCE hInst,
                UINT      uID,
                PWSTR     pBuffer,
                int       nBufferMax
               )
{
   int nResult;
   PSTR szTempString;

   if ( NULL == ( szTempString = LocalAlloc( LPTR, nBufferMax ) ) )
   {
      LOG((TL_ERROR, "Alloc failed myloadstr - (0x%lx)", nBufferMax ));
      return 0;
   }

   nResult = LoadStringA(
                hInst,
                uID,
                szTempString,
                nBufferMax
                );

   //
   // "... but more importantly: did we get a charge?"
   //
   if ( nResult )
   {
       MultiByteToWideChar(
                     GetACP(),
                     MB_PRECOMPOSED,
                     szTempString,
                     nResult + 1,   //For null...
                     pBuffer,
                     nBufferMax
                     );
   }

   return nResult;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
HINSTANCE TAPILoadLibraryW(
                           PWSTR     pLibrary
                           )
{
    PSTR pszTempString;
    HINSTANCE hResult;
    DWORD  dwSize;
    
    
    dwSize = WideCharToMultiByte(
        GetACP(),
        0,
        pLibrary,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );
    
    if ( NULL == (pszTempString = LocalAlloc( LPTR, dwSize )) )
    {
        LOG((TL_ERROR, "Alloc failed - LoadLibW - 0x%08lx", dwSize));
        return NULL;
    }
    
    WideCharToMultiByte(
        GetACP(),
        0,
        pLibrary,
        dwSize,
        pszTempString,
        dwSize,
        NULL,
        NULL
        );
    
    
    hResult = LoadLibraryA( pszTempString );
    
    LocalFree( pszTempString );
    
    return hResult;
}



//
// Swiped this from NT - process.c
//
BOOL
WINAPI
TAPIIsBadStringPtrW(
    LPCWSTR lpsz,
    UINT cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCWSTR EndAddress;
    LPCWSTR StartAddress;
    WCHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*2) - 2);
        try {
            c = *(volatile WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile WCHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}


#endif  // not UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\rules.h ===
/****************************************************************************
 
  Copyright (c) 1998  Microsoft Corporation
                                                              
  Module Name:  rules.h
                                                              
     Abstract:  Rules Object definitions
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#ifndef __RULES_H_
#define __RULES_H_

#include "utils.h"
#include "list.h"
#include "loc_comn.h"
#include "client.h"
#include "clntprivate.h"
class CAreaCodeProcessingRule;



//***************************************************************************
//
//  Class Definition - CRuleSet
//
//***************************************************************************
class CRuleSet
{

public:
    PWSTR   m_pszInternationalRule;
    PWSTR   m_pszLongDistanceRule;
    PWSTR   m_pszLocalRule;


    CRuleSet();
    ~CRuleSet();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CRuleSet)
#endif

    STDMETHOD(Initialize) ( PWSTR pszInternationalRule,
                            PWSTR pszLongDistanceRule,
                            PWSTR pszLocalRule
                          ); 

};



//***************************************************************************
//
//  Class Definition - CAreaCodeRule
//
//***************************************************************************
class CAreaCodeRule
{
private:

    PWSTR               m_pszAreaCode;
    PWSTR               m_pszNumberToDial;
    DWORD               m_dwOptions;
    PWSTR               m_pszzPrefixList;   // contains  REG_MULTI_SZ  data
                                            // An array of null-terminated strings,
                                            //  terminated by two null characters. 
    DWORD               m_dwPrefixListSize; // Size, in bytes, of the prefix list



public:
    CAreaCodeRule(); 
    ~CAreaCodeRule();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CAreaCodeRule)
#endif

    STDMETHOD(Initialize) ( PWSTR pszAreaCode,
                            PWSTR pszNumberToDial,
                            DWORD dwOptions,
                            PWSTR pszzPrefixList, 
                            DWORD dwPrefixListSize
                           );


    BOOL HasDialAreaCode() {return  m_dwOptions & RULE_DIALAREACODE;}
    void SetDialAreaCode(BOOL bDa);

    BOOL HasDialNumber() {return  m_dwOptions & RULE_DIALNUMBER;}
    void SetDialNumber(BOOL bDn);

    BOOL HasAppliesToAllPrefixes(){return  m_dwOptions & RULE_APPLIESTOALLPREFIXES;}                        
    void SetAppliesToAllPrefixes(BOOL bApc);
   
    PWSTR GetAreaCode(){return m_pszAreaCode;}
    STDMETHOD (SetAreaCode)(PWSTR pszAreaCode);

    PWSTR GetNumberToDial(){return m_pszNumberToDial;}
    STDMETHOD (SetNumberToDial)(PWSTR pszNumberToDial);
   
    DWORD GetPrefixListSize(){return m_dwPrefixListSize;}
    PWSTR GetPrefixList(){return m_pszzPrefixList;}
    STDMETHOD (SetPrefixList)(PWSTR pszzPrefixList, DWORD dwSize);
    DWORD TapiSize();
    DWORD GetOptions(){return m_dwOptions;}

    void BuildProcessingRule(CAreaCodeProcessingRule * pRule);

    
};

/////////////////////////////////////////////
// Fill out the list template
//
 
typedef LinkedList<CAreaCodeRule*> AreaCodeRulePtrList;
typedef ListNode<CAreaCodeRule*>   AreaCodeRulePtrNode;









//***************************************************************************

STDMETHODIMP CreateDialingRule
                            ( 
                              PWSTR *pszRule,
                              PWSTR pszNumberToDial,
                              BOOL bDialAreaCode
                            );


                            

#if DBG
#define ClientAllocString( __psz__ ) ClientAllocStringReal( __psz__, __LINE__, __FILE__ )
PWSTR ClientAllocStringReal(PCWSTR psz, 
                            DWORD dwLine,
                            PSTR  pszFile
                           );

#else

#define ClientAllocString( __psz__ ) ClientAllocStringReal( __psz__ )
PWSTR ClientAllocStringReal(PCWSTR psz );

#endif


#endif //__RULES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\rules.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  rules.cpp
                                                              
     Abstract:  Rules Object implementation
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

//#define unicode
#include <windows.h>
#include <objbase.h>

#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "rules.h"





/****************************************************************************

    Class : CRuleSet         
   Method : Constructer

****************************************************************************/
CRuleSet::CRuleSet()
{
    m_pszInternationalRule = NULL;
    m_pszLongDistanceRule = NULL;
    m_pszLocalRule = NULL;
}



/****************************************************************************

    Class : CRuleSet         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CRuleSet::~CRuleSet()
{
    if ( m_pszInternationalRule != NULL )
    {
         ClientFree(m_pszInternationalRule);
    }   

    if ( m_pszLongDistanceRule != NULL )
    {
         ClientFree(m_pszLongDistanceRule);
    }   

    if ( m_pszLocalRule != NULL )
    {
         ClientFree(m_pszLocalRule);
    }   
}



/****************************************************************************

    Class : CRuleSet         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CRuleSet::Initialize
                  (
                   PWSTR pszInternationalRule,
                   PWSTR pszLongDistanceRule,
                   PWSTR pszLocalRule
                  )
{
    //////////////////////////////////////////////////
    // copy the international Rule
    //
    m_pszInternationalRule = ClientAllocString( pszInternationalRule );
    if (m_pszInternationalRule == NULL)
    {
        LOG(( TL_ERROR, "Initialize create m_pszInternationalRule failed" ));
        return E_OUTOFMEMORY;
    }


    //////////////////////////////////////////////////
    // copy the long Distance Rule
    //
    m_pszLongDistanceRule = ClientAllocString( pszLongDistanceRule );
    if (m_pszLongDistanceRule == NULL)
    {
        ClientFree(m_pszInternationalRule);

        LOG(( TL_ERROR, "Initialize create m_pszLongDistanceRule failed" ));
        return E_OUTOFMEMORY;
    }

    
    //////////////////////////////////////////////////
    // copy the local Rule
    //
    m_pszLocalRule = ClientAllocString( pszLocalRule );
    if (m_pszLocalRule == NULL)
    {
        ClientFree(m_pszInternationalRule);
        ClientFree(m_pszLongDistanceRule);
        
        LOG(( TL_ERROR, "Initialize create m_pszLocalRule failed" ));
        return E_OUTOFMEMORY;
    }
        

    return S_OK;
    
}



/****************************************************************************
/****************************************************************************


/****************************************************************************

    Class : CAreaCodeRule         
   Method : Constructer

****************************************************************************/
CAreaCodeRule::CAreaCodeRule()
{
    m_pszAreaCode = NULL;
    m_pszNumberToDial = NULL;
    m_pszzPrefixList = NULL;
}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CAreaCodeRule::~CAreaCodeRule()
{
    if ( m_pszAreaCode != NULL )
    {
         ClientFree(m_pszAreaCode);
    }   

    if ( m_pszNumberToDial != NULL )
    {
         ClientFree(m_pszNumberToDial);
    }   

    if ( m_pszzPrefixList != NULL )
    {
         ClientFree(m_pszzPrefixList);
    }   

}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CAreaCodeRule::Initialize
                                    ( 
                                      PWSTR pszAreaCode,
                                      PWSTR pszNumberToDial,
                                      DWORD dwOptions,
                                      PWSTR pszzPrefixList, 
                                      DWORD dwPrefixListSize
                                    )
{
    
    HRESULT hr = S_OK;

    
    //////////////////////////////////////////////////
    // copy the AreaCode
    //
    m_pszAreaCode = ClientAllocString( pszAreaCode );
    if (m_pszAreaCode == NULL)
    {
        LOG(( TL_ERROR, "Initialize create m_pszAreaCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszNumberToDial = ClientAllocString( pszNumberToDial );
    if (m_pszNumberToDial == NULL)
    {
        LOG(( TL_ERROR, "Initialize create m_pszNumberToDial failed" ));
        return E_OUTOFMEMORY;
    }

    m_dwOptions = dwOptions;

    SetPrefixList(pszzPrefixList, dwPrefixListSize);

    return hr;

}




/****************************************************************************

    Class : CAreaCodeRule         
   Method : SetAreaCode

****************************************************************************/
STDMETHODIMP CAreaCodeRule::SetAreaCode(PWSTR pszAreaCode)
{
    HRESULT hr = S_OK;


    if (m_pszAreaCode != NULL)
        {
        ClientFree(m_pszAreaCode);
        m_pszAreaCode = NULL;
        }

    if(pszAreaCode != NULL)
    {
        m_pszAreaCode = ClientAllocString( pszAreaCode );
        if (m_pszAreaCode == NULL)
        {
            LOG(( TL_ERROR, "SetAreaCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;

}


/****************************************************************************

    Class : CAreaCodeRule         
   Method : SetAreaCode

****************************************************************************/
STDMETHODIMP CAreaCodeRule::SetNumberToDial(PWSTR pszNumberToDial)
{
    HRESULT hr = S_OK;


    if (m_pszNumberToDial != NULL)
        {
        ClientFree(m_pszNumberToDial);
        m_pszNumberToDial = NULL;
        }

    if(pszNumberToDial != NULL)
    {
        m_pszNumberToDial = ClientAllocString( pszNumberToDial );
        if (m_pszNumberToDial == NULL)
        {
            LOG(( TL_ERROR, "SetNumberToDial - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;

}
   


/****************************************************************************

    Class : CAreaCodeRule         
   Method : SetPrefixList

****************************************************************************/
STDMETHODIMP CAreaCodeRule::SetPrefixList(PWSTR pszzPrefixList, DWORD dwSize)
{
    HRESULT hr = S_OK;


    if (m_pszzPrefixList != NULL)
        {
        ClientFree(m_pszzPrefixList);
        m_pszzPrefixList = NULL;
        m_dwPrefixListSize = 0;
        }

    if(pszzPrefixList != NULL)
    {
        m_pszzPrefixList = (PWSTR) ClientAlloc(dwSize);
        if (m_pszzPrefixList != NULL)
        {
            CopyMemory(m_pszzPrefixList, pszzPrefixList, dwSize);
            // set the size !
            m_dwPrefixListSize = dwSize;

        }
        else    
        {
            LOG(( TL_ERROR, "SetPrefixList - alloc  failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;

}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : UseCallingCard

****************************************************************************/
void CAreaCodeRule::SetDialAreaCode(BOOL bDa) 
{
    if(bDa)
    {    
        m_dwOptions |= RULE_DIALAREACODE;
    }
    else
    {
        m_dwOptions &= ~RULE_DIALAREACODE;
    }
}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : UseCallingCard

****************************************************************************/
void CAreaCodeRule::SetDialNumber(BOOL bDn) 
{
    if(bDn)
    {    
        m_dwOptions |= RULE_DIALNUMBER;
    }
    else
    {
        m_dwOptions &= ~RULE_DIALNUMBER;
    }
}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : UseCallingCard

****************************************************************************/
void CAreaCodeRule::SetAppliesToAllPrefixes(BOOL bApc) 
{
    if(bApc)
    {    
        m_dwOptions |= RULE_APPLIESTOALLPREFIXES;
    }
    else
    {
        m_dwOptions &= ~RULE_APPLIESTOALLPREFIXES;
    }
}


/****************************************************************************

    Class : CAreaCodeRule         
   Method : TapiSize
            Number of bytes needed to pack this into a TAPI structure to send
            to TAPISRV

****************************************************************************/
DWORD CAreaCodeRule::TapiSize()
{
    DWORD dwSize=0;

    // Calc size ofArea Code Rule
    dwSize = ALIGN(sizeof(AREACODERULE));
    dwSize += ALIGN((lstrlenW(m_pszAreaCode) + 1) * sizeof(WCHAR));
    dwSize += ALIGN((lstrlenW(m_pszNumberToDial) + 1) * sizeof(WCHAR));
    dwSize += ALIGN(m_dwPrefixListSize);

    return dwSize;
}









/****************************************************************************
/****************************************************************************



/****************************************************************************

 Function : CreateDialingRule
            Create TAPI dialing rule - "xxxxFG" from number to dial
            & area code if required & subcriber number

****************************************************************************/
STDMETHODIMP CreateDialingRule
                            ( 
                              PWSTR * pszRule,
                              PWSTR pszNumberToDial,
                              BOOL bDialAreaCode
                            )

{
    HRESULT hr = S_OK;
	PWSTR pszRule1= NULL;

    //////////////////////////////////////////////////
    // Create the dialing Rule
    // alloc enough space for number + "FG"
    //
    pszRule1 = (PWSTR) ClientAlloc(
                                  (lstrlenW(pszNumberToDial) + 3 ) 
                                  * sizeof (WCHAR)
                                 );
    if (pszRule1 != NULL)
    {
        // copy number "xxxx"
        if(pszNumberToDial != NULL)                                         
        {
            lstrcpyW(pszRule1, pszNumberToDial);
        }
        
        // Area code ?  "xxxxF"
        if (bDialAreaCode)
        {
            lstrcatW(pszRule1, L"F");   
        }
        
        // Subcriber Nmber "xxxxFG" or "xxxxG"
        lstrcatW(pszRule1, L"G");  

    }
    else    
    {
        LOG(( TL_ERROR, "CreateDialingRule - Alloc pszRule failed" ));
        hr = E_OUTOFMEMORY;
    }

	*pszRule = pszRule1;
    return hr;
}




/****************************************************************************

 Function : ClientAllocString
            Copys string.         
            Allocate space for new string using ClientAlloc
            Returns pointer to new string or NULL

****************************************************************************/
#if DBG
    PWSTR ClientAllocStringReal(PCWSTR psz, 
                                DWORD dwLine,
                                PSTR  pszFile
                               )
#else
    PWSTR ClientAllocStringReal(PCWSTR psz )
#endif
{
    PWSTR pszNewString = NULL;

    if (psz != NULL)
    {
        #if DBG
            pszNewString = (PWSTR) ClientAllocReal((lstrlenW(psz)+1)* sizeof (WCHAR),dwLine,pszFile );
        #else
            pszNewString = (PWSTR) ClientAlloc((lstrlenW(psz)+1)* sizeof (WCHAR) );
        #endif
        if (pszNewString != NULL)
        {
            lstrcpyW(pszNewString, psz);
        }
        else    
        {
            LOG(( TL_ERROR, "ClientAllocString Alloc string failed" ));
        }
    }

    return pszNewString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\tapimmc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    tapimmc.c

Abstract:

    Client-side implementation of TAPI MMC support APIs

Author:

    Dan Knudson (DanKn)    10-Dec-1997

Revision History:


Notes:

--*/

#include "windows.h"
#include "stdarg.h"
#include "stdio.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "tapimmc.h"
#include "client.h"
#include "clntprivate.h"
#include "tapsrv.h"
#include "lmcons.h"
#include "resource.h"

#define MMCAPP_KEY ((DWORD) 'CmMt')

typedef struct _MMCAPP
{
    DWORD       dwKey;

    BOOL        bLocal;

    HLINEAPP                hLineApp;

    DWORD       dwAPIVersion;

    HANDLE      hReinitializeEvent;

    PCONTEXT_HANDLE_TYPE    phCtx;       //  RPC handle context

    BOOL        bNoServiceControl;

} MMCAPP, *PMMCAPP;


LONG
WINAPI
FreeClientResources(
    void
    );


PMMCAPP
PASCAL
IsValidMmcApp(
    HMMCAPP hMmcApp
    )
{
    PMMCAPP pMmcApp = NULL;

    try
    {
        if (((PMMCAPP) hMmcApp)->dwKey == MMCAPP_KEY)
        {
            pMmcApp = (PMMCAPP) hMmcApp;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        // do nothing
    }

    return pMmcApp;
}


LONG
WINAPI
MMCAddProvider(
    HMMCAPP hMmcApp,
    HWND    hwndOwner,
    LPCWSTR lpszProviderFilename,
    LPDWORD lpdwProviderID
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineAddProviderW(
            lpszProviderFilename,
            hwndOwner,
            lpdwProviderID
            );
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineAddProviderW(
            lpszProviderFilename,
            hwndOwner,
            lpdwProviderID
            );
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCConfigProvider(
    HMMCAPP hMmcApp,
    HWND    hwndOwner,
    DWORD   dwProviderID
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineConfigProvider (hwndOwner, dwProviderID);
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineConfigProvider (hwndOwner, dwProviderID);
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetAvailableProviders(
    HMMCAPP                 hMmcApp,
    LPAVAILABLEPROVIDERLIST lpProviderList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetAvailableProviders),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpProviderList
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetAvailableProviders");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetAvailableProviders");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetLineInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetLineInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetLineInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


#define MAX_DEFAULT_STATUS 64

extern HINSTANCE  g_hInst;

LONG
WINAPI
MMCGetLineStatus(
    HMMCAPP     hMmcApp,
    HWND        hwndOwner,
    DWORD       dwStatusLevel,
    DWORD       dwProviderID,
    DWORD       dwPermanentLineID,
    LPVARSTRING lpStatusBuffer
    )
{
    static WCHAR szDefStatus[MAX_DEFAULT_STATUS] = L"";
    static int cbCount;

    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        return LINEERR_INVALAPPHANDLE;
    }

    if (!lpStatusBuffer ||
        IsBadWritePtr (lpStatusBuffer, sizeof (*lpStatusBuffer)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpStatusBuffer->dwTotalSize < sizeof (*lpStatusBuffer))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (0 == cbCount ||
        0 == szDefStatus[0])
    {
        cbCount = LoadString (g_hInst, IDS_DEFAULT_STATUS, szDefStatus, MAX_DEFAULT_STATUS);
        cbCount = (cbCount+1)<<1;   // + 1 because LoadString does not count the terminating NULL;
                                    // <<1 because we need the size in bytes, not characters, and WCHAR is 2 bytes.
    }

    lpStatusBuffer->dwNeededSize = sizeof (*lpStatusBuffer) + cbCount;

    if (lpStatusBuffer->dwTotalSize >= lpStatusBuffer->dwNeededSize)
    {
        lpStatusBuffer->dwStringFormat = STRINGFORMAT_UNICODE;
        lpStatusBuffer->dwStringSize   = cbCount;
        lpStatusBuffer->dwStringOffset = sizeof (*lpStatusBuffer);

        wcscpy ((WCHAR *) (lpStatusBuffer + 1), szDefStatus);
    }
    else
    {
        lpStatusBuffer->dwUsedSize = sizeof (*lpStatusBuffer);

        lpStatusBuffer->dwStringFormat =
        lpStatusBuffer->dwStringSize   =
        lpStatusBuffer->dwStringOffset = 0;
    }

    return 0;
}


LONG
WINAPI
MMCGetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetPhoneInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetPhoneInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetPhoneInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetPhoneStatus(
    HMMCAPP     hMmcApp,
    HWND        hwndOwner,
    DWORD       dwStatusLevel,
    DWORD       dwProviderID,
    DWORD       dwPermanentLineID,
    LPVARSTRING lpStatusBuffer
    )
{
    static WCHAR szDefStatus[MAX_DEFAULT_STATUS] = L"";
    static int cbCount;

    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        return LINEERR_INVALAPPHANDLE;
    }

    if (!lpStatusBuffer ||
        IsBadWritePtr (lpStatusBuffer, sizeof (*lpStatusBuffer)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpStatusBuffer->dwTotalSize < sizeof (*lpStatusBuffer))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (0 == cbCount ||
        0 == szDefStatus[0])
    {
        cbCount = LoadString (g_hInst, IDS_DEFAULT_STATUS, szDefStatus, MAX_DEFAULT_STATUS);
        cbCount = (cbCount+1)<<1;   // + 1 because LoadString does not count the terminating NULL;
                                    // <<1 because we need the size in bytes, not characters, and WCHAR is 2 bytes.
    }

    lpStatusBuffer->dwNeededSize = sizeof (*lpStatusBuffer) + cbCount;

    if (lpStatusBuffer->dwTotalSize >= lpStatusBuffer->dwNeededSize)
    {
        lpStatusBuffer->dwStringFormat = STRINGFORMAT_UNICODE;
        lpStatusBuffer->dwStringSize   = cbCount;
        lpStatusBuffer->dwStringOffset = sizeof (*lpStatusBuffer);

        wcscpy ((WCHAR *) (lpStatusBuffer + 1), szDefStatus);
    }
    else
    {
        lpStatusBuffer->dwUsedSize = sizeof (*lpStatusBuffer);

        lpStatusBuffer->dwStringFormat =
        lpStatusBuffer->dwStringSize   =
        lpStatusBuffer->dwStringOffset = 0;
    }

    return 0;
}


LONG
WINAPI
MMCGetProviderList(
    HMMCAPP             hMmcApp,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineGetProviderListW(
            pMmcApp->dwAPIVersion,
            lpProviderList
            );
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineGetProviderListW(
            pMmcApp->dwAPIVersion,
            lpProviderList
            );
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetServerConfig),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpConfig
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetServerConfig");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetServerConfig");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

    if (lpConfig && pMmcApp && pMmcApp->bNoServiceControl)
    {
        lpConfig->dwFlags |= TAPISERVERCONFIGFLAGS_NOSERVICECONTROL;
    }

ExitHere:
    return lResult;
}

LONG
WINAPI
EnsureTapiService(LPCWSTR lpszComputerName, DWORD * pdwServiceState)
{
    SC_HANDLE       hSCMgr = NULL; 
    SC_HANDLE       hTapiSrv = NULL;
    LONG            lResult = 0;
    DWORD           dwNumSecondsSleptStartPending = 0,
                    dwNumSecondsSleptStopPending = 0;
    SERVICE_STATUS  status;
    BOOL            bBreakOut = FALSE;

    if ((hSCMgr = OpenSCManagerW(
                    lpszComputerName,   // Machine name
                    NULL,               // ServicesActive database
                    SC_MANAGER_CONNECT  // desired access
                    )) == NULL)
    {
        lResult = GetLastError();
        LOG((TL_ERROR, "OpenSCManager failed, err=%d", lResult));
        goto ExitHere;
    }

    if ((hTapiSrv = OpenServiceW(
                    hSCMgr,                 // SC mgr handle
                    L"TAPISRV",             // name of service to open
                    SERVICE_START |         // desired access
                    SERVICE_QUERY_STATUS |
                    SERVICE_STOP |
                    SERVICE_CHANGE_CONFIG
                    )) == NULL)
    {
        lResult = GetLastError() | 0x80000000;
        LOG((TL_ERROR, "OpenService failed, err=%d", GetLastError()));
        goto ExitHere;
    }

    while (1)
    {
        QueryServiceStatus (hTapiSrv, &status);

        switch (status.dwCurrentState)
        {
        case SERVICE_RUNNING:
            LOG((TL_INFO, "Tapisrv running"));
            bBreakOut = TRUE;
            break;

        case SERVICE_START_PENDING:
            Sleep (1000);
            if (++dwNumSecondsSleptStartPending > 180)
            {
                //  Wait for no longer than 3 minutes
                LOG((TL_ERROR, "ERROR: Tapisrv stuck SERVICE_START_PENDING"));
                bBreakOut = TRUE;
            }
            break;

        case SERVICE_STOP_PENDING:
            Sleep (1000);
            if (++dwNumSecondsSleptStopPending > 180)
            {
                //  Wait for no more than 3 minutes
                LOG((TL_ERROR, "ERROR: Tapisrv stuck SERVICE_STOP_PENDING"));
                bBreakOut = TRUE;
            }
            break;

        case SERVICE_STOPPED:
            LOG((TL_INFO, "Starting tapisrv (NT)..."));
            if (!StartService(
                        hTapiSrv,   // service handle
                        0,          // num args
                        NULL        // args
                        ))
            {
                lResult = GetLastError();
                if (lResult != ERROR_SERVICE_ALREADY_RUNNING)
                {
                    LOG((TL_ERROR,
                        "StartService(TapiSrv) failed, err=%d",
                        lResult
                        ));
                    bBreakOut = TRUE;
                }
                else
                {
                    lResult = 0;
                }
            }
            break;

        default:
            LOG((TL_ERROR, "error, service status=%d",
                    status.dwCurrentState));
            lResult = GetLastError();
            bBreakOut = TRUE;
            break;
        }

        if (bBreakOut)
        {
            break;
        }
    }
    if (pdwServiceState)
    {
        *pdwServiceState = status.dwCurrentState;
    }

ExitHere:
    if (hSCMgr)
        CloseServiceHandle(hSCMgr);
    if (hTapiSrv)
        CloseServiceHandle(hTapiSrv);
    return lResult;
}

LONG
WINAPI
MMCInitialize(
    LPCWSTR     lpszComputerName,
    LPHMMCAPP   lphMmcApp,
    LPDWORD     lpdwAPIVersion,
    HANDLE      hReinitializeEvent
    )
{
    LONG            lResult = 0;
    LONG            lSrvResult = 0;
    DWORD           dwSize;
    WCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L"";
    PMMCAPP         pMmcApp;


    if ((lpszComputerName  &&
            IsBadStringPtrW (lpszComputerName, 0xffffffff)) ||
        IsBadWritePtr (lphMmcApp, sizeof (*lphMmcApp)) ||
        IsBadWritePtr (lpdwAPIVersion, sizeof (*lpdwAPIVersion)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (!(pMmcApp = ClientAlloc (sizeof (*pMmcApp))))
    {
        return LINEERR_NOMEM;
    }

    dwSize = sizeof (szComputerName) / sizeof (WCHAR);

    GetComputerNameW (szComputerName, &dwSize);

    lSrvResult = EnsureTapiService(lpszComputerName, NULL);

    if (!lpszComputerName || _wcsicmp (lpszComputerName, szComputerName) == 0)
    {
        pMmcApp->bLocal = TRUE;
    }
    else
    {
        //  We need to manage another computer
        
        RPC_STATUS      status, status2;
        BOOL            bRet;
        BOOL            bException = FALSE;
        HANDLE          hAsyncEventsEvent = NULL;
        LPWSTR          pszStringBinding;
        WCHAR           szUserName[UNLEN + 1];

        dwSize = sizeof(szUserName) / sizeof(WCHAR);
        bRet = GetUserNameW(szUserName, &dwSize);
        if (!bRet)
        {
            lResult = GetLastError();
            LOG((TL_ERROR, "GetUserNameW failed: err=%d", lResult));
            goto ExitHere;
        }
        

        //  Init the RPC connection with the server
        status = RpcStringBindingComposeW (
                                    NULL,               //  ObjUuid
                                    L"ncacn_np",        //  ProtSeq
                                    (LPWSTR)lpszComputerName,   //  NetworkAddr
                                    L"\\pipe\\tapsrv",  //  EndPoint
                                    NULL,               //  Options
                                    &pszStringBinding); //  StringBinding
        if (status)
        {
            LOG((TL_ERROR, "RpcStringBindingCompose failed: err=%d", status));
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        status = RpcBindingFromStringBindingW(
                                    pszStringBinding,   //  StringBinding
                                    &hTapSrv);          //  Binding
        status2 = RpcStringFreeW(&pszStringBinding);
        if (status || status2)
        {
            LOG((TL_ERROR, "RpcBindingFromStringBinding failed: err=%d", status));
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        status = RpcBindingSetAuthInfoW (
                                    hTapSrv,            //  hBinding
                                    NULL,               //  ServerPrincName
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, //  AuthnLevel
                                    RPC_C_AUTHN_WINNT,  //  AuthService
                                    NULL,               //  AuthIdentity
                                    0);                 //  AuthzService
        if (status)
        {
            LOG((TL_ERROR, "RpcBindingSetAuthInfo failed: err=%d", status));
            RpcBindingFree(hTapSrv);
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        RpcTryExcept
        {
            LOG((TL_TRACE,  "MMCInitialize: calling ClientAttach..."));

            lResult = ClientAttach(
                &(pMmcApp->phCtx),
                0xfffffffd,         //  Indicate to the server this is from MMC client
                                    //  on another machine
                (long *)&hAsyncEventsEvent,
                szUserName,
                szComputerName
                );

            LOG((TL_TRACE,  "MMCInitialize: ClientAttach returned x%x", lResult));
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_TRACE, 
                "MMCInitialize: ClientAttach caused except=%d",
                RpcExceptionCode()
                ));
            bException = TRUE;
        }
        RpcEndExcept

        status = RpcBindingFree(&hTapSrv);
        if (status || bException)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        if (lResult)
        {
            goto ExitHere;
        }
        
        pMmcApp->bLocal = FALSE;
    }

    //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
    if (!(pMmcApp->bLocal) && !SetTlsPCtxHandle(pMmcApp->phCtx))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    {
        DWORD                   dwNumLines;
        LINEINITIALIZEEXPARAMS  initExParams;


        initExParams.dwTotalSize = sizeof (initExParams);
        initExParams.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;

        lResult = lineInitializeExW(
            &pMmcApp->hLineApp,
            NULL,
            NULL,
            NULL,
            &dwNumLines,
            lpdwAPIVersion,
            &initExParams
            );

        pMmcApp->dwAPIVersion = *lpdwAPIVersion;
    }

    //  Clear the PCONTEXT_TYPE_HANDLE in TLS
    if (!(pMmcApp->bLocal) && !SetTlsPCtxHandle(NULL))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
    }
    
ExitHere:
    if (lResult == 0)
    {
        pMmcApp->dwKey = MMCAPP_KEY;

        *lphMmcApp = (HMMCAPP) pMmcApp;
    }
    else
    {
        ClientFree (pMmcApp);
    }

    if (lSrvResult && (lResult == 0))
    {
        //
        //  We have no problem in connecting to the remote computer
        //  but we can not manipulate its TAPI service, i.e start service
        //  tell the app about it.
        //
        pMmcApp->bNoServiceControl = TRUE;
        
    }

    return lResult;
}


LONG
WINAPI
MMCRemoveProvider(
    HMMCAPP hMmcApp,
    HWND    hwndOwner,
    DWORD   dwProviderID
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineRemoveProvider (dwProviderID, hwndOwner);
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineRemoveProvider (dwProviderID, hwndOwner);
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCSetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mSetLineInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpSet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetLineInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetLineInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCSetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mSetPhoneInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpSet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCSetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mSetServerConfig),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpConfig
        },

        {
            hXxxApp,
            lpSet_Struct
        }
    };
    LONG    lResult;
    DWORD   dwFlags;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (lpConfig && pMmcApp)
    {
        dwFlags = lpConfig->dwFlags;
        lpConfig->dwFlags &= (~TAPISERVERCONFIGFLAGS_NOSERVICECONTROL);
    }

    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetServerConfig");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetServerConfig");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

    if (lpConfig && pMmcApp)
    {
        lpConfig->dwFlags = dwFlags;
    }

ExitHere:
    return lResult;
}

LONG
WINAPI
MMCGetDeviceFlags(
    HMMCAPP             hMmcApp,
    BOOL                bLine,
    DWORD               dwProviderID,
    DWORD               dwPermanentDeviceID,
    DWORD               * pdwFlags,
    DWORD               * pdwDeviceID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, mGetDeviceFlags),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) bLine,
            (ULONG_PTR) dwProviderID,
            (ULONG_PTR) dwPermanentDeviceID,
            (ULONG_PTR) pdwFlags,
            (ULONG_PTR) pdwDeviceID,
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpDword
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}

LONG
WINAPI
MMCShutdown(
    HMMCAPP hMmcApp
    )
{
    LONG    lResult = 0;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        pMmcApp->dwKey = 0xfffffffe;

        lResult = lineShutdown (pMmcApp->hLineApp);

        ClientFree (pMmcApp);


        //
        // #196350 - After enabling tapi as a server the MMC does a
        // FreeLibrary on us, thinking that we'll terminate our rpc
        // connection with the tapisrv, so it can shutdown tapisrv
        // and restart it w/ different credentials, etc.  However,
        // the MMC is linked with CSCUI.DLL, who in turn links with
        // a RAS DLL, who in turn links with TAPI32.DLL, therefore
        // we never actually get unloaded.  Since we don't otherwise
        // deal with the service going down at this point, we want
        // to manually call FreeClientResources() to make it seem
        // like we've never been talking to tapisrv.
        //

        // Not needed anymore, now lineShutdown closes the RPC connection
        // FreeClientResources();
    }
    else if (pMmcApp->phCtx)
    {
        pMmcApp->dwKey = 0xfffffffe;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineShutdown (pMmcApp->hLineApp);
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
        }
        
        RpcTryExcept
        {
            ClientDetach (&(pMmcApp->phCtx));
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            // do something?
        }
        RpcEndExcept

        pMmcApp->phCtx = NULL;
        ClientFree (pMmcApp);
    }

ExitHere:
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\client\utils.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif


#ifdef TRACELOG


DWORD   sg_dwTraceID = INVALID_TRACEID;
char    sg_szTraceName[100];   // saves name of dll

DWORD   sg_dwTracingToDebugger = 0;
DWORD   sg_dwTracingToConsole  = 0;
DWORD   sg_dwTracingToFile     = 0;
DWORD   sg_dwDebuggerMask      = 0;


BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID)
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}

 

char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
        case TL_TRACE: return "TRACE";
        case TL_EVENT: return "EVENT";
        default:       return " ??? ";
    }
}


#endif // TRACELOG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\cpl\precomp.h ===
#pragma once

#include <windows.h>
#include <cpl.h>
#include <tapi.h>
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\cpl\resource.h ===
// Used by telephon.rc
//
#define IDS_NAME                        1
#define IDS_DESCRIPTION                 2
#define IDI_TELEPHONE                   100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\cplresource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cplresource.rc
//
#define IDS_NAME                        1
#define IDS_DESCRIPTION                 2
#define IDS_LOCATION                    3
#define IDS_CLICKNEW                    4
#define IDS_NEWLOCATION                 5
#define IDS_EDITLOCATION                6
#define IDS_NEWCALLINGCARD              7
#define IDS_EDITCALLINGCARD             8
#define IDS_AREACODE                    9
#define IDS_PREFIXES                    10
#define IDS_RULE                        11
#define IDS_PHONEPADCHAR                12
#define IDS_PHONENUMBERCHAR             13
#define IDS_DIGITSONLY                  14
#define IDS_ALLPHONECHARS               15
#define IDS_DIALX                       16
#define IDS_DIALXPLUSAREACODE           17
#define IDS_DIALAREACODE                18
#define IDS_DIALNUMBERONLY              19
#define IDS_ALLPREFIXES                 20
#define IDS_SELECTEDPREFIXES            21
#define IDS_EDITRULE                    22
#define IDS_SELECTARULE                 23
#define IDS_DIAL_XpAC_FORALL            24
#define IDS_DIAL_X_FORALL               25
#define IDS_DIAL_AC_FORALL              26
#define IDS_DIAL_NUMONLY_FORALL         27
#define IDS_DIAL_XpAC_FORSELECTED       28
#define IDS_DIAL_X_FORSELECTED          29
#define IDS_DIAL_AC_FORSELECTED         30
#define IDS_DIAL_NUMONLY_FORSELECTED    31
#define IDS_DIAL_ONEpAC_ALLOTHER        32
#define IDS_ADDPREFIX                   33
#define IDS_TYPEPREFIX                  34
#define IDS_SPECIFYDIGITS               35
#define IDS_TYPEDIGITS                  36
#define IDS_DIGITLIST                   37
#define IDS_WAITFORXSECONDS             38
#define IDS_DIALACCESSNUMBER            39
#define IDS_DIALACOUNTNUMBER            40
#define IDS_DIALPINNUMBER               41
#define IDS_WAITFORDIALTONE             42
#define IDS_WAITFORQUIET                43
#define IDS_DIAL_CCpACpNUM              44
#define IDS_DIAL_CCpNUM                 45
#define IDS_DIAL_ACpNUM                 46
#define IDS_DIAL_CC                     47
#define IDS_DIAL_AC                     48
#define IDS_DIAL_NUM                    49
#define IDS_DIALING_LD_CALLS            50
#define IDS_DIALING_INT_CALLS           51
#define IDS_DIALING_LOC_CALLS           52
#define IDS_NOCCRULES                   53
#define IDS_NEEDALONGDISTANCECARRIERCODE 54
#define IDS_NEEDALOCATIONNAME           55
#define IDS_NEEDANAREACODE              56
#define IDS_NEEDADISABLESTRING          57
#define IDS_NEEDACOUNTRY                58
#define IDS_ERRORCAPTION                59
#define IDS_NEEDUNIQUENAME              60
#define IDS_INVALIDCARD                 61
#define IDS_NOCARDSELECTED              62
#define IDS_MUSTENTERCARDNAME           63
#define IDS_MUSTENTERCARDNUMBER         64
#define IDS_MUSTENTERPINNUMBER          65
#define IDS_NORULESFORTHISCARD          66
#define IDS_NOLONGDISTANCEACCESSNUMBER  67
#define IDS_NOINTERNATIONALACCESSNUMBER 68
#define IDS_NOLOCALACCESSNUMBER         69
#define IDS_NONE                        70
#define IDS_CONFIRM_DRIVER_REMOVE       71
#define IDS_NOSERVICEPROVIDER           72
#define IDS_NEEDPREFIXLIST              73
#define IDS_DIGITS                      74
#define IDS_ACPREFIXES                  75
#define IDS_MULTIDIGITLIST              76
#define IDS_CONFIRMDELETE               77
#define IDS_DELETELOCTEXT               78
#define IDS_DELETECARDTEXT              79
#define IDS_DELETERULETEXT              80
#define IDS_NEEDDIALNUMBER              81
#define IDS_NEEDUNIQUECARDNAME          82
#define IDS_NOLOCWARNING                83
#define IDS_NOLOCCAPTION                84
#define IDS_MYLOCATION                  85
#define IDS_NO_PROVIDERS                86
#define IDS_PHONENUMBERCHAREXT          87
#define IDS_NEEDANINTERNATIONALCARRIERCODE 88
#define IDS_NEEDACARRIERCODE            89
#define IDS_TAPI_SEC_PROMPT             90
#define IDS_REND_SEC_PROMPT             91
#define IDS_MADCAP_SEC_PROMPT           92
#define IDS_PLUGTERM_SEC_PROMPT         93
#define IDD_MAIN_DIALINGRULES           101
#define IDD_LOC_GENERAL                 102
#define IDD_LOC_AREACODERULES           103
#define IDD_LOC_CALLINGCARD             104
#define IDD_CARD_GENERAL                105
#define IDD_CARD_LONGDISTANCE           106
#define IDD_CARD_INTERNATIONAL          107
#define IDD_CARD_LOCALCALLS             108
#define IDD_NEWAREACODERULE             109
#define IDD_EDITDIALOG                  110
#define IDD_WAITFORDIALOG               111
#define IDD_DESTNUMDIALOG               112
#define IDD_MAIN_ADVANCED               113
#define IDD_ADD_DRIVER                  114
#define IDD_SIMPLELOCATION              115
#define IDI_TELEPHONE                   201
#define IDI_HOUSE                       202
#define IDI_CARD                        203
#define IDB_BUTTONS                     301
#define IDB_SIMPLELOCATION              302
#define IDD_WIZ_DIALINFO                400
#define IDD_TAPI_SECURITY_DIALOG        500
#define IDC_SECURITY_WARNING_ICON       501
#define IDC_SECURITY_WARNING_TEXT       502
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  503
#define IDI_SECURITY                    504
#define ID_YES                          505
#define ID_NO                           506
#define IDS_TYPEPREFIX2                 700
#define IDC_CARDUSAGE1                  1000
#define IDC_CARDUSAGE2                  1001
#define IDC_CARDUSAGE3                  1002
#define IDC_TEXT                        1003
#define IDC_SETDEFAULT                  1004
#define IDC_ADD                         1005
#define IDC_COUNTRY                     1006
#define IDC_DIALNUMBER                  1007
#define IDC_LOCALNUMBER                 1008
#define IDC_WAITFORDIALTONE             1009
#define IDC_LOCALACCESSNUM              1010
#define IDC_LONGDISTANCEACCESSNUM       1011
#define IDC_DIALCHECK                   1012
#define IDC_DISABLESTRING               1013
#define IDC_ALLPREFIXES                 1014
#define IDC_LISTEDPREFIXES              1015
#define IDC_WAITFORVOICE                1016
#define IDC_WAITFOR                     1017
#define IDC_CARDNUMBER                  1018
#define IDC_PIN                         1019
#define IDC_DESTNUMBER                  1020
#define IDC_SPECIFYDIGITS               1021
#define IDC_MOVEUP                      1022
#define IDC_MOVEDOWN                    1023
#define IDC_REMOVE                      1024
#define IDC_ACCESSNUMBER                1025
#define IDC_STEPS                       1026
#define IDC_COUNTRYCODE                 1027
#define IDC_USECALLINGCARD              1028
#define IDC_DIALAREACODE                1029
#define IDC_NEW                         1030
#define IDC_EDIT                        1031
#define IDC_DELETE                      1032
#define IDC_LIST                        1033
#define IDC_AREACODE                    1034
#define IDC_DISABLECALLWAITING          1035
#define IDC_TONE                        1036
#define IDC_PULSE                       1037
#define IDC_LOCATIONNAME                1038
#define IDC_DESCRIPTIONTEXT             1039
#define IDC_SAMPLENUMBER                1041
#define IDC_LONGDISTANCE                1042
#define IDC_INTERNATIONAL               1043
#define IDC_LONGDISTANCENUMBER          1044
#define IDC_INTERNATIONALNUMBER         1045
#define IDC_CALLINGCARDUSAGE            1046
#define IDC_CARDNAME                    1047
#define IDC_WAITFORTIME                 1048
#define IDC_TIMESPIN                    1049
#define IDC_TIME                        1050
#define IDC_LOCAL                       1051
#define IDC_PHONENUMBERTEXT             1052
#define IDC_PHONENUMBERSAMPLE           1053
#define IDC_CALLSFROM                   1054
#define IDC_DRIVER_LIST                 1055
#define IDC_CARDUSAGE                   1056
#define IDC_PREFIXES                    1057
#define IDC_CARRIERCODE                 1058
#define IDC_LONGDISTANCECARRIERCODE     1059
#define IDC_INTERNATIONALCARRIERCODE    1060
#define IDC_STATICLDC                   1061
#define IDC_STATICIC                    1062
#define IDC_STATICCC                    1063
#define IDS_CANNOT_START_TELEPHONCPL    1064
#define IDS_REMOVEPROVIDER              1065


#define IDC_NOHELP                      2000
#define RC_CARD_ID_BASE                 15800

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1057
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\explib\wave.cpp ===
/*
*) Functions to simplify recording & playback of wave file/data to a line/phone
*) Put the code in TAPI32L.LIB?  Then only apps that need it, get it

    +) tapiMakeNoise(
                      DWORD  Device Type: PHONE/LINE/WAVE, etc?
                      HANDLE Device Handle,
                      DWORD  NoiseType:   BUFFER/FILENAME/HFILE(readfile directly?)/MMIOHANDLE
                      HANDLE hArray - array of type NoiseTypes that are to be played serially
                      DWORD  Flags:
                              fSYNC
                              fSTOP_EXISTING_PLAYING_IF_ANY
                    );

        -) How to handle hardware assist?  IE: Hey, hardware, play prompt #7 - how would an 
                       app know how/when to request that?

        -) What about proprietary wave formats? How to know what proprietary formats the hardware supports?
                Just try it?

        -) What about conversions?  How to know what conversions the hardware can do

        -) How about a notification method?  Such that an app can know when the wave is done.

        -)


*/        
        
        
        
        
#define STRICT

#include "windows.h"
#include "windowsx.h"
#include "mmsystem.h"
#include "tapi.h"


#if DBG

VOID
DbgPrtWave(
    IN DWORD  dwDbgLevel,
    IN PTCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
//    if (dwDbgLevel <= gdwDebugLevel)
    {
        TCHAR    buf[1280];
        va_list ap;


        va_start(ap, lpszFormat);

        wsprintf(buf, TEXT("CallUpW (0x%08lx) - "), GetCurrentThreadId() );

        wvsprintf (&buf[23],
                   lpszFormat,
                   ap
                  );

        lstrcat (buf, TEXT("\n"));

        OutputDebugString (buf);

        va_end(ap);
    }
}

#define WDBGOUT(_x_) DbgPrtWave _x_

#else

#define WDBGOUT(_x_)

#endif


//****************************************************************************
//****************************************************************************
//****************************************************************************
unsigned long WINAPI WaveThread( LPVOID junk );

void CALLBACK WaveOutCallback(
    HWAVE  hWave,    // handle of waveform device
    UINT  uMsg,    // sent message
    DWORD  dwInstance,    // instance data
    DWORD  dwParam1,    // application-defined parameter
    DWORD  dwParam2    // application-defined parameter
   );



enum 
{
    DEVICE_WAVEID,
    DEVICE_WAVEHANDLE,
    DEVICE_HLINE,
    DEVICE_HPHONE,
    DEVICE_HCALL
};
enum
{
    SOURCE_WAVEFILE,
    SOURCE_MSDOSFILE,
    SOURCE_MEM
};
class WaveDevice;
class WaveOperation;

#define OPERATIONSTATUS_DONTPLAYTHIS 0x00000001



#define MAX_NUM_BUFFERS (8)
#define BUFFER_SIZE (8192)
typedef    struct {
               ULONG           uBufferLength;
               WaveOperation * poWaveOperation;
               PBYTE           pBuffer;
           } MISCINFO;



//****************************************************************************
//****************************************************************************
LONG gfInited = 0;
BOOLEAN     gfShutdown = FALSE;
WaveDevice *gpoWaveDeviceList = NULL;
HANDLE      ghFreeBufferEvent = 0;
HANDLE      ghWaveThread = NULL;
MISCINFO   *gDoneBuffersToBeProcessed[MAX_NUM_BUFFERS + 1];
CRITICAL_SECTION gCriticalSection;

//****************************************************************************
//****************************************************************************
//****************************************************************************

class WaveOperation
{
    public:
    
        DWORD   dwSourceType;
        union
        {
            PTSTR  psz;
            
            PBYTE  pb;
            
            HANDLE h;

            LONG   l;
            
        } SourceThing;
        
        class WaveOperation * pNextWaveOperationInList;
        
        class WaveDevice    * poWaveDevice;
        
        HANDLE    hSyncEvent;
        
        DWORD   dwStatus;
        
        DWORD   cFileSize;
        DWORD   cDataRemaining;
        DWORD   cDataDonePlaying;
        BOOLEAN fInited;

        LONG WaveOperation::InitOperation(
                                            class WaveDevice * poWaveDevice,
                                            DWORD dwSoundTypeIn,
                                            LONG  lSourceThing
                                         );
                                         
        virtual LONG     InitSpecific( void ) = 0;
        virtual ULONG    GetData( PBYTE pBuffer, ULONG uBufferSize ) = 0;
        virtual void     FreeSpecific( void ) = 0;
        
        inline  WaveOperation * GetpNext();
        inline  void            SetpNext( WaveOperation * );
        
        inline  HANDLE GetSyncEvent();
        inline  void   SetSyncEvent( HANDLE );
        
        inline void ProcessDoneBuffer( MISCINFO * pMiscInfo );
        inline ULONG BytesNotDonePlaying( void );
};


//****************************************************************************
//****************************************************************************
//****************************************************************************
class WaveDevice
{
    ULONG     uDeviceId;
    DWORD     dwDeviceType;
    HANDLE    hDevice;
    
    HWAVEOUT  hWaveOut;
    CRITICAL_SECTION  CriticalSection;
    
    ULONG uUsageCount;
    
    class WaveDevice     * pNextWaveDeviceInList;

    class WaveOperation  *  CurrentWaveOperation;
    class WaveOperation  *  LastWaveOperation;
    
    

    ULONG     Head;
    ULONG     Tail;

    ULONG     NumFreeBuffers;
    ULONG     cBufferSize;

    PBYTE     FreeQueue[MAX_NUM_BUFFERS];
    WAVEHDR   WaveHeader[MAX_NUM_BUFFERS];
    MISCINFO  MiscInfo[MAX_NUM_BUFFERS];

    DWORD     dwStatusBits;

    
    public:

        inline ULONG GetNumFreeBuffers( void );
        DWORD GetStatus( void );
        void TerminateAllOperations( void );
        LONG KillWaveDevice( BOOLEAN fWaitForThreadTermination );
        LONG CloseWaveDevice();
        LONG InitWaveDevice( ULONG  uDeviceId );
        LONG OpenWaveDevice( WAVEFORMATEX * pWaveFormat );
    
        inline  WaveDevice * GetpNext();
        inline  void         SetpNext( WaveDevice * );
        
        LONG QueueOperation( class WaveOperation * );
        class WaveOperation * NextOperation();

        ULONG PlaySomeData( BOOL fPrimeOnly );

        inline void ReturnToFreeBufferQueue( PBYTE pBuffer );
        inline void IncrementBytesPlayed( ULONG cCount );
        inline ULONG GetWaveDeviceId( void );
        
        inline CRITICAL_SECTION * GetCriticalSection( void );

//        static void CALLBACK WaveOutCallback(
//                       HWAVE  hWave,    // handle of waveform device
//                       UINT   uMsg,     // sent message
//                       DWORD  dwInstance,    // instance data
//                       DWORD  dwParam1,    // application-defined parameter
//                       DWORD  dwParam2    // application-defined parameter
//                      );

        void  IncUsageCount( void );
        void  DecUsageCount( void );
        UINT  GetUsageCount( void );
};


//****************************************************************************
LONG WaveDevice::InitWaveDevice( ULONG  uDevId )
{
    LONG lResult = 0;
    ULONG n;


    WDBGOUT((4, "Entering InitWaveDevice"));


    // 
    // Alloc some buffers
    // 
    Head = 0;
    Tail = 0;
    NumFreeBuffers = 0;

    uUsageCount = 0;
    
    dwStatusBits = 0;

    cBufferSize = BUFFER_SIZE;
    
    uDeviceId = uDevId;

    for ( n = 0; n < MAX_NUM_BUFFERS; n++ )
    {
        FreeQueue[n] = (PBYTE)LocalAlloc(LPTR, cBufferSize);
        
        if ( NULL == FreeQueue[n] )
        {
            WDBGOUT((1, "Mem alloc failed.  Size= 0x%08lx", cBufferSize));
        
            while ( n )
            {
                LocalFree( FreeQueue[n-1] );
                n--;
            }
            
            return( LINEERR_NOMEM );
        }
        
        NumFreeBuffers++;

    }


    InitializeCriticalSection( &CriticalSection );
    
    
    CurrentWaveOperation = NULL;
    LastWaveOperation = NULL;

    
    return( lResult );
}

    
//****************************************************************************
inline ULONG WaveDevice::GetWaveDeviceId( void )
{
    return uDeviceId;
}


//****************************************************************************
inline ULONG WaveDevice::GetNumFreeBuffers( void )
{
    return NumFreeBuffers;
}


//****************************************************************************
LONG WaveDevice::OpenWaveDevice( WAVEFORMATEX * pWaveFormat )
{
    ULONG u;
    LONG lResult;
    
    WDBGOUT((4, "Entering OpenWaveDevice"));
    
    lResult = (LONG)waveOutOpen(
                 &hWaveOut,
                 uDeviceId,
                 pWaveFormat,
                 (DWORD)WaveOutCallback,
                 (DWORD)this,
                 CALLBACK_FUNCTION | WAVE_MAPPED
               );

//{
//    TCHAR buf[500];
//    wsprintf( buf, "woo on %lx ret=0x%lx", uDeviceId, lResult);
//    MessageBox(GetFocus(), buf, buf, MB_OK);
//}      


    
    if ( lResult )
    {
        WDBGOUT((1, "waveOutOpen returned 0x%08lx", lResult ));
        return( LINEERR_NOMEM);  //TODO LATER: Diff ret codes?
    }
    
    for ( u = 0; u < NumFreeBuffers; u++ )
    {
        WaveHeader[u].lpData = (LPSTR)FreeQueue[u];

        WaveHeader[u].dwBufferLength = cBufferSize;

        WaveHeader[u].dwFlags = 0;

        lResult = waveOutPrepareHeader(
                              hWaveOut,
                              &(WaveHeader[u]),
                              sizeof(WAVEHDR)
                            );
        if ( lResult )
        {
            WDBGOUT((1, TEXT("waveOutPrepareHeader returned 0x%08lx"), lResult ));
            return( LINEERR_NOMEM);  //TODO LATER: Diff ret codes?
        }
    
    }

    WDBGOUT((4, TEXT("Leaving OpenWaveDevice result = 0x0")));
    return( 0 );
}
    
    
////****************************************************************************
//LONG WaveDevice::RestartDevice( WAVEFORMATEX * pWaveFormat )
//{
//    ULONG n;
//    
//
//    WDBGOUT((4, "Entering RestartDevice"));
//
//
//    //  Reset wave device
//    WDBGOUT((4, TEXT("Resetting the wave device...")));
//    waveOutReset( hWaveOut );
//
//    //
//    // Wait until all of the outstanding buffers are back.
//    //
//    WDBGOUT((4, TEXT("Waiting for all buffers to be returned...")));
//    while ( NumFreeBuffers < MAX_NUM_BUFFERS )
//    {
//        Sleep(0);
//    }
//
//    WDBGOUT((4, TEXT("Closing the wave device...")));
//    waveOutClose( hWaveOut );
//
//    
//
//    return( 0 );
//}
//
    

//****************************************************************************
LONG WaveDevice::CloseWaveDevice()
{

    WDBGOUT((4, "Entering CloseWaveDevice"));


    //  Reset wave device
    WDBGOUT((4, TEXT("Resetting the wave device...")));
    waveOutReset( hWaveOut );

    //
    // Wait until all of the outstanding buffers are back.
    //
    WDBGOUT((4, TEXT("Waiting for all buffers to be returned...")));
    while ( NumFreeBuffers < MAX_NUM_BUFFERS )
    {
        Sleep(0);
    }

    WDBGOUT((4, TEXT("Closing the wave device...")));
    waveOutClose( hWaveOut );
    
    return( 0 );
}

    
//****************************************************************************
LONG WaveDevice::KillWaveDevice( BOOLEAN fWaitForThreadTermination )
{
    ULONG n;
    WaveDevice * poTempDevice;

    

    WDBGOUT((4, "Entering KillWaveDevice"));


    
    //  Reset wave device
    WDBGOUT((4, TEXT("Resetting the wave device...")));
    waveOutReset( hWaveOut );

    //
    // Wait until all of the outstanding buffers are back.
    //
    WDBGOUT((4, TEXT("Waiting for all buffers to be returned...")));
    while ( NumFreeBuffers < MAX_NUM_BUFFERS )
    {
        Sleep(0);
    }

    WDBGOUT((4, TEXT("Closing the wave device...")));
    waveOutClose( hWaveOut );
    
    //
    // Free the memory for all of the buffers
    //
    for ( n=0; n<MAX_NUM_BUFFERS; n++ )
    {
        LocalFree( FreeQueue[n] );

        FreeQueue[n] = NULL;
    }
    
    
    //
    // Remove the device from the global list
    //
    poTempDevice = gpoWaveDeviceList;
    
    if ( poTempDevice == this )
    {
        gpoWaveDeviceList = GetpNext();
    }
    else
    {
        while (    poTempDevice
                &&
                  ( (*poTempDevice).GetpNext() != this )
              )
        {
            poTempDevice =(*poTempDevice).GetpNext();
        }

        //
        // The next one in the list is it.  Remove the link.
        //
        if ( poTempDevice != NULL )
        {
           //
           // Adjust the list pointers
           //
           (*poTempDevice).SetpNext( GetpNext() );
        }
    }

    DeleteCriticalSection( &CriticalSection );

    delete this;
    


    //
    // Are all of the devices dead and buried?
    //
    if ( NULL == gpoWaveDeviceList )
    {
        gfShutdown = TRUE;
//TODO NOW: fix this        gfInited   = 0;
    
        //
        // Signal the other thread to come down
        //
        SetEvent( ghFreeBufferEvent );
        
        //
        // Wait 'till the thread is dead?
        //
        if ( fWaitForThreadTermination )
        {
            WaitForSingleObject( ghWaveThread, INFINITE );
        }
        
        CloseHandle( ghWaveThread );
        
        //
        // Zero this so we start fresh next time.
        //
//        ghWaveThread = NULL;
    }
    
    
    
    return( 0 );
}


    
//****************************************************************************
inline DWORD WaveDevice::GetStatus( void )
{
    return dwStatusBits;
}

    
//****************************************************************************
inline void WaveDevice::TerminateAllOperations( void )
{
    WaveOperation *poWaveOperation;
    
    WDBGOUT((3, TEXT("Entering TerminateAllOps")));
    
    EnterCriticalSection( &CriticalSection );
    
    poWaveOperation = CurrentWaveOperation;
    
    while ( poWaveOperation )
    {
        WDBGOUT((4, TEXT("Tainting oper: 0x%08lx"), poWaveOperation ));
        
        (*poWaveOperation).dwStatus |= OPERATIONSTATUS_DONTPLAYTHIS;
        
        poWaveOperation = (*poWaveOperation).GetpNext();
    }

    //
    //  Reset wave device to force all the buffers in
    //
    WDBGOUT((4, TEXT("Resetting the wave device...")));
    waveOutReset( hWaveOut );

    LeaveCriticalSection( &CriticalSection );
    
    WDBGOUT((3, TEXT("Leaving TerminateAllOps")));
}

    
//****************************************************************************
inline CRITICAL_SECTION * WaveDevice::GetCriticalSection( void )
{
   return &CriticalSection;
}


//****************************************************************************
inline WaveDevice * WaveDevice::GetpNext()
{
    return( pNextWaveDeviceInList );
    
}


//****************************************************************************
inline void WaveDevice::SetpNext(WaveDevice * pWaveDevice)
{
    pNextWaveDeviceInList = pWaveDevice;
}


//****************************************************************************
inline void  WaveDevice::IncUsageCount( void )
{
    uUsageCount++;
};
                
                      
//****************************************************************************
inline void  WaveDevice::DecUsageCount( void )
{
    uUsageCount--;
};
                
                      
//****************************************************************************
inline UINT  WaveDevice::GetUsageCount( void )
{
    return uUsageCount;
};
                
                      
//****************************************************************************
LONG WaveDevice::QueueOperation( class WaveOperation *poNewWaveOperation )
{

    WDBGOUT((3, TEXT("Entering QueueOperation")));
    
    EnterCriticalSection( &CriticalSection );
    

    (*poNewWaveOperation).SetpNext( NULL );

    //
    // Add operation to list
    //
    if ( LastWaveOperation )
    {
        (*LastWaveOperation).SetpNext( poNewWaveOperation );
    }

    LastWaveOperation = poNewWaveOperation;

    if ( NULL == CurrentWaveOperation )
    {
        CurrentWaveOperation = poNewWaveOperation;
    }
    
    
    LeaveCriticalSection( &CriticalSection );
    
    WDBGOUT((4, TEXT("Created new oper: 0x%08lx"), poNewWaveOperation));
    
    WDBGOUT((3, TEXT("Leaving QueueOperation")));
    return( 0 );
}
    

//****************************************************************************
class WaveOperation * WaveDevice::NextOperation()
{
    //
    // This function will get rid of the operation at the top of this wave
    // device's operation queue, and will update the queue to reflect the next
    // as now the first.
    //


    WDBGOUT((3, TEXT("Entering NextOperation")));


    EnterCriticalSection( &CriticalSection );
    
    if ( CurrentWaveOperation )
    {
        WaveOperation * poWaveOperation;
        WaveOperation * poTempOperation;
        
        poWaveOperation = (*CurrentWaveOperation).GetpNext();
        delete CurrentWaveOperation;
        
        while ( poWaveOperation )
        {
            //
            // If we can play this operation, break outta this loop
            //
            if ( !( (*poWaveOperation).dwStatus & OPERATIONSTATUS_DONTPLAYTHIS) )
            {
WDBGOUT((55, TEXT("How much break?")));
                break;
            }
            
            //
            // We're not supposed to play this operation
            //
            
            if ( (*poWaveOperation).hSyncEvent )
            {
                WDBGOUT((5, TEXT("Caller was waiting.  Signaling...")));
                SetEvent( (*poWaveOperation).hSyncEvent );
            }

            
            poTempOperation = (*poWaveOperation).GetpNext();
            
            delete poWaveOperation;
            
            poWaveOperation = poTempOperation;
            
        }
        
WDBGOUT((55, TEXT("Not too much")));
        CurrentWaveOperation = poWaveOperation;
    }
WDBGOUT((55, TEXT("was it Too much?")));
   
    //
    // The CurrentWaveOperation may have been "NULLED" out by the previous stuff
    //
    if ( NULL == CurrentWaveOperation )
    {
        LastWaveOperation = NULL;
    }

    LeaveCriticalSection( &CriticalSection );

    WDBGOUT((4, TEXT("Leaving NextOperation - returning 0x%08lx"), CurrentWaveOperation));

    return( CurrentWaveOperation );
}    
        
       

//****************************************************************************
inline void WaveDevice::ReturnToFreeBufferQueue( PBYTE pBuffer )
{
    FreeQueue[Tail] = pBuffer;
    
    //
    // If we're at the end of the list, wrap.
    //
    Tail = ( Tail + 1 )  % MAX_NUM_BUFFERS;

    NumFreeBuffers++;
}                             


//****************************************************************************
inline void WaveDevice::IncrementBytesPlayed( ULONG cCount )
{

//    //
//    // If there is an operation on the dying queue, this must be from it
//    //
//    if ( DyingWaveOperation )
//    {
//        //
//        // Is it dead yet?
//        //
//        if ( 0 == DyingWaveOperation->BytesNotDonePlaying() )
//        {
//           WaveOperation * poNextOperation;
//
//           EnterCriticalSection( &CriticalSection );
//
//           //
//           // Yes, it's dead.
//           //
//           poNextOperation = DyingWaveOperation->GetpNext();
//
//           //
//           // Was the caller waiting (ie: was it sync) ?
//           //
//           if ( (*DyingWaveOperation).GetSyncEvent() )
//           {
//               SetEvent( (*DyingWaveOperation).GetSyncEvent() );
//           }
//        
//           delete DyingWaveOperation;
//
//           DyingWaveOperation = poNextOperation;
//
//           LeaveCriticalSection( &CriticalSection );
//        }
//    }
//  
    //TODO LATER: Keep a total count of bytes played out this device?

}

                       
//****************************************************************************
//****************************************************************************
//****************************************************************************



//****************************************************************************
LONG WaveOperation::InitOperation(
                                          class WaveDevice * poWaveDeviceIn,
                                          DWORD dwSourceTypeIn,
                                          LONG  lSourceThing
                                        )
{
    WDBGOUT((4, TEXT("Entering InitOperation")));

    dwSourceType   = dwSourceTypeIn;
    SourceThing.l  = lSourceThing;
    poWaveDevice   = poWaveDeviceIn;
    
    pNextWaveOperationInList = NULL;
    
    (*poWaveDevice).IncUsageCount();

    dwStatus = 0;

    fInited = FALSE;
        
    return(0);
}                                 
                                 
    
//****************************************************************************
inline HANDLE WaveOperation::GetSyncEvent()
{
    return( hSyncEvent );
}


//****************************************************************************
inline void WaveOperation::SetSyncEvent( HANDLE hEvent )
{
    hSyncEvent = hEvent;
    return;
}


//****************************************************************************
inline WaveOperation * WaveOperation::GetpNext()
{
    return( pNextWaveOperationInList );
    
}


//****************************************************************************
inline void WaveOperation::SetpNext(WaveOperation * pWaveOperation)
{
    pNextWaveOperationInList = pWaveOperation;
}


//****************************************************************************
inline void WaveOperation::ProcessDoneBuffer( MISCINFO * pMiscInfo )
{
    ULONG nBytesQueued;
           
    WDBGOUT((3, TEXT("Entering ProcessDoneBuffer")));

    cDataDonePlaying += pMiscInfo->uBufferLength;

    WDBGOUT((11, TEXT("Now - size=0x%08lx  done=0x%08lx"),
                  cFileSize,
                  cDataDonePlaying));


    (*poWaveDevice).IncrementBytesPlayed( pMiscInfo->uBufferLength );
    (*poWaveDevice).ReturnToFreeBufferQueue( pMiscInfo->pBuffer );

    //
    // Has someone decided this wave should stop?
    //
    if ( dwStatus & OPERATIONSTATUS_DONTPLAYTHIS )
    {
        if ( (*poWaveDevice).GetNumFreeBuffers() != MAX_NUM_BUFFERS )
        {
            WDBGOUT((4, TEXT("Bailing from ProcessDoneBuffer - dontplay")));
            return;
        }
        
        cDataDonePlaying = cFileSize;
    }

    //
    // Is this thing already dead?
    //
    if ( cDataDonePlaying >= cFileSize )
    {

        WDBGOUT((4, TEXT("Done playing this:0x%08lx"), this ));


        //
        // Was the caller waiting (ie: was it sync) ?
        //
        if ( hSyncEvent )
        {
            WDBGOUT((5, TEXT("Caller was waiting.  Signaling...")));
            SetEvent( hSyncEvent );
        }

//TODO LATER: PERFORMANCE: If the next format is the same as this one, don't close the device

        (*poWaveDevice).CloseWaveDevice();


        (*poWaveDevice).DecUsageCount();


        EnterCriticalSection( &gCriticalSection );
        
        //
        // Was this the last oper?
        //
        if ( (*poWaveDevice).GetUsageCount() == 0 )
        {
            WDBGOUT((4, TEXT("Last oper out...")));

            (*poWaveDevice).KillWaveDevice(FALSE);
        }
        else
        {
           WaveOperation * pNewOperation;
           
           //
           // Move up the next operation
           //
           while ( TRUE )
           {
               pNewOperation = (*poWaveDevice).NextOperation();
               
               if ( NULL == pNewOperation )
               {
                  if ( (*poWaveDevice).GetUsageCount() == 0 )
                  {
                      WDBGOUT((4, TEXT("No more ops to run...")));

                      (*poWaveDevice).KillWaveDevice(FALSE);
                  }
                  
                  //
                  // All operations done.  Go away.
                  //
                  WDBGOUT((3, TEXT("All operations seem to be done...")));
                  break;
               }
               
               WDBGOUT((3, TEXT("Playing data from new op...")));
               nBytesQueued = (*poWaveDevice).PlaySomeData( FALSE );
               
               if ( nBytesQueued )
               {
                  //
                  // There were some bytes played.  Break the loop...
                  //
                  break;
               }
               
               //
               // Was the caller waiting (ie: was it sync) ?
               //
               if ( pNewOperation->hSyncEvent )
               {
                   WDBGOUT((3, TEXT("No data in new op and caller is waiting...")));
                   SetEvent( pNewOperation->hSyncEvent );
               }

               //
               // Update the counter.  This op is, for all intents and purposes, done.
               //
               (*poWaveDevice).DecUsageCount();
        
               WDBGOUT((3, TEXT("No data in new op.  Looking for next...")));
           }
           
        }

        FreeSpecific();

        delete this;
        
        LeaveCriticalSection( &gCriticalSection );
    }
    else
    {
        WDBGOUT((3, TEXT("Playing data from same op...")));
        (*poWaveDevice).PlaySomeData( FALSE );
    }
    
    WDBGOUT((3, TEXT("Leaving ProcessDoneBuffer")));
}


//****************************************************************************

                       
//****************************************************************************
inline ULONG WaveOperation::BytesNotDonePlaying( void )
{
    return cFileSize - cDataDonePlaying;
}

                       
//****************************************************************************
//****************************************************************************
class BufferWave: public WaveOperation
{
    PBYTE   pData;  // Pointer to the data to play
    PBYTE   pCurrentPointer;
    
    public:
        LONG BufferWave::InitSpecific( void );
        ULONG GetData( PBYTE pBuffer, ULONG uBufferSize );
        void BufferWave::FreeSpecific( void );
};


//****************************************************************************
LONG BufferWave::InitSpecific( void )
{
    pData = SourceThing.pb;
    
    pCurrentPointer = pData;
    
    return(0);
}


//****************************************************************************
ULONG BufferWave::GetData( PBYTE pBuffer, ULONG uBufferSize )
{
    ULONG uBytesToPlay;

    uBytesToPlay = (cDataRemaining > uBufferSize) ?
                        uBufferSize    :
                        cDataRemaining;

    cDataRemaining -= uBytesToPlay;
    
    memcpy( pBuffer, pCurrentPointer, uBytesToPlay );
    
    pCurrentPointer += uBytesToPlay;
    
    return( uBytesToPlay );
}



//****************************************************************************
void BufferWave::FreeSpecific( void )
{
    return;
}


//****************************************************************************
//****************************************************************************
class WaveFile: public WaveOperation
{
    HMMIO hmmio;
    
    public:
        LONG WaveFile::InitSpecific( void );
        ULONG GetData( PBYTE pBuffer, ULONG uBufferSize );
        void WaveFile::FreeSpecific( void );
};


//****************************************************************************
LONG WaveFile::InitSpecific( void )
{
    MMCKINFO    mmckinfoParent;   /* parent chunk information structure */ 
    MMCKINFO    mmckinfoSubchunk; /* subchunk information structure    */ 
    DWORD       dwFmtSize;        /* size of "fmt" chunk               */ 
    WAVEFORMATEX Format;          /* pointer to memory for "fmt" chunk */ 
    LONG         lResult;


    WDBGOUT((4, TEXT("Entering WaveFile::InitSpecific")));


    hmmio = mmioOpen(
                      SourceThing.psz,
                      NULL,
                      MMIO_READ
                    );

    //
    // Did the open go ok?
    //
    if ( NULL == hmmio )
    {
       //
       // Nope.
       //
       WDBGOUT((1, TEXT("Error during mmioOpen of [%s] - err=0x%08lx"),
                   (SourceThing.psz == NULL) ? "" : SourceThing.psz,
                   GetLastError() ));

       return LINEERR_OPERATIONFAILED;
    }


    /* 
     * Locate a "RIFF" chunk with a "WAVE" form type 
     * to make sure the file is a WAVE file. 
     */ 
    mmckinfoParent.fccType = mmioFOURCC('W', 'A', 'V', 'E'); 

	WDBGOUT((11, TEXT("Descend WAVE")));
    if ( mmioDescend(
                      hmmio,
                      (LPMMCKINFO) &mmckinfoParent,
                      NULL, 
                      MMIO_FINDRIFF)
       )
    { 
       WDBGOUT((1, TEXT("This is not a WAVE file - [%s]"),
                   (SourceThing.psz == NULL) ? "" : SourceThing.psz));
       mmioClose( hmmio, 0); 
       return LINEERR_INVALPARAM; 
    } 


    /* 
     * Find the "fmt " chunk (form type "fmt "); it must be 
     * a subchunk of the "RIFF" parent chunk. 
     */ 
    mmckinfoSubchunk.ckid = mmioFOURCC('f', 'm', 't', ' '); 

	WDBGOUT((11, TEXT("Descend FMT")));
    if ( mmioDescend(
                      hmmio,
                      &mmckinfoSubchunk,
                      &mmckinfoParent,
                      MMIO_FINDCHUNK)
       )
    { 
       WDBGOUT((1, TEXT("WAVE file has no \"fmt\" chunk")));
       mmioClose(hmmio, 0); 
       return LINEERR_INVALPARAM; 
    } 


     /* 
      * Get the size of the "fmt " chunk--allocate and lock memory for it. 
      */ 
     dwFmtSize = mmckinfoSubchunk.cksize; 


	WDBGOUT((11, TEXT("read fmt")));
    /* Read the "fmt " chunk. */ 
     mmioRead(
                   hmmio,
                   (HPSTR)&Format,
                   sizeof(Format) );
 //   {
 //      WDBGOUT((1, TEXT("Failed to read format chunk.")));
 //      mmioClose(pMyWaveFile->hmmio, 0); 
 //      return 1; 
 //   }



	WDBGOUT((11, TEXT("Ascend fmt")));
    /* Ascend out of the "fmt " subchunk. */ 
    mmioAscend(hmmio, &mmckinfoSubchunk, 0); 


    
    /* 
    * Find the data subchunk. The current file position 
    * should be at the beginning of the data chunk. 
    */ 
    mmckinfoSubchunk.ckid = mmioFOURCC('d', 'a', 't', 'a'); 

	WDBGOUT((11, TEXT("Descend DATA")));
    if ( mmioDescend(
                      hmmio,
                      &mmckinfoSubchunk,
                      &mmckinfoParent, 
                      MMIO_FINDCHUNK)
       )
    {
       WDBGOUT((1, TEXT("WAVE file has no data chunk.")));
       mmioClose(hmmio, 0); 
       return LINEERR_INVALPARAM; 
    } 
   
    /* Get the size of the data subchunk. */ 
    cFileSize      = mmckinfoSubchunk.cksize; 
    cDataRemaining = mmckinfoSubchunk.cksize; 

    cDataDonePlaying = 0;

    
	WDBGOUT((11, TEXT("OpenWaveDev")));
    lResult = poWaveDevice->OpenWaveDevice( &Format );
    

//    if ( cDataRemaining == 0L)
//    {
//       WDBGOUT((1, TEXT("The data chunk contains no data.")));
//       mmioClose(hmmio, 0); 
//       return 0;  //TODO LATER: Right?  It's not an error...
// It'll just get 0 bytes on the first read...
//    } 

    return( lResult );
}



//****************************************************************************
ULONG WaveFile::GetData( PBYTE pBuffer, ULONG uBufferSize )
{
    ULONG uBytesToPlay;
    ULONG uBytesRead;


    WDBGOUT((11, TEXT("Entering WaveFile::GetData")));


    //
    // Have we done anything yet?
    //
    if ( !fInited )
    {
        if ( InitSpecific() )
        {
            return( 0 );
        }
        fInited = TRUE;
    }
    
   
    uBytesToPlay = (cDataRemaining > uBufferSize) ?
                        uBufferSize    :
                        cDataRemaining;


    if ( 0 == uBytesToPlay )
    {
        return 0;
    }


    /* Read the waveform data subchunk. */ 
    uBytesRead = mmioRead(
                           hmmio,
                           (LPSTR)pBuffer,
                           uBytesToPlay
                         );


    if ( uBytesRead != uBytesToPlay )
    {
        WDBGOUT((1, TEXT("Failed to properly read data chunk.")));
        mmioClose(hmmio, 0); 
        return 0;
    } 

    cDataRemaining -= uBytesToPlay;
    
    return( uBytesToPlay );
}


//****************************************************************************
void WaveFile::FreeSpecific( void )
{
    mmioClose(hmmio, 0); 
    return;
}


//****************************************************************************
//****************************************************************************
class DosFile: public WaveOperation
{
    HANDLE   hFile;
    
    public:
        LONG DosFile::InitSpecific( void );
        ULONG GetData( PBYTE pBuffer, ULONG uBufferSize );
        void DosFile::FreeSpecific( void );
};

//****************************************************************************
LONG DosFile::InitSpecific( void )
{
    BOOL fResult;
//    WIN32_FILE_ATTRIBUTE_DATA FileInfo;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    
    hFile = CreateFile(
                        SourceThing.psz,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                      );

    if ( 0 == hFile )
    {
        WDBGOUT((1, TEXT("Error doing OpenFile( lpszName ) GetLastError=0x%)8lx"),
                       SourceThing.psz, GetLastError() ));
                       
        return( LINEERR_OPERATIONFAILED );
    }

//    fResult = GetFileAttributesEx( SourceThing.psz,
//                                   GetFileExInfoStandard,
//                                   (PVOID) &FileInfo
//                                 );
  
    fResult = GetFileInformationByHandle( hFile, &FileInfo );
    
    if ( fResult )
    {
        //TODO LATER: Handle > 4 gig files

        //
        // Uh, we don't really handle gigabyte files...
        //
        if ( FileInfo.nFileSizeHigh )
        {
            cFileSize      = (DWORD)-1;
            cDataRemaining = (DWORD)-1;
        }
        else
        {
            cFileSize      = FileInfo.nFileSizeLow;
            cDataRemaining = FileInfo.nFileSizeLow;
        }
    }
    else
    {
        cFileSize      = 0;
        cDataRemaining = 0;
    }

    cDataDonePlaying = 0;

    return(0);
}


//****************************************************************************
ULONG DosFile::GetData( PBYTE pBuffer, ULONG uBufferSize )
{
    BOOL fResult;
    UINT uBytesRead = 0;

    fResult = ReadFile( hFile,
                        pBuffer,
                        uBufferSize,
                        (LPDWORD)&uBytesRead,
                        NULL
                      );

    if ( fResult )
    {
        if ( 0 == uBytesRead )
        {
            //
            // We're at the end of the file
            //
            cDataRemaining = 0;
        }
        else
        {
            cDataRemaining -= uBytesRead;
        }
    }

    return( uBytesRead );
}


//****************************************************************************
void DosFile::FreeSpecific( void )
{
    CloseHandle( hFile );
    return;
}




//****************************************************************************
//****************************************************************************
//****************************************************************************
ULONG WaveDevice::PlaySomeData( BOOL fPrimeOnly )
{
    ULONG uBufferedBytes = 0;
    ULONG uTotalQueuedSize = 0;
    PBYTE pBuffer = NULL;
    LONG lResult;
    CRITICAL_SECTION *pCriticalSection;

        
    WDBGOUT((3, TEXT("Entering PlaySomeData")));

    pCriticalSection = &CriticalSection;
    EnterCriticalSection( pCriticalSection );

    if ( NULL != CurrentWaveOperation )
    {
    
        //
        // Is it OK to play this thing?
        //
        if ( !((*CurrentWaveOperation).dwStatus & OPERATIONSTATUS_DONTPLAYTHIS) )
        {
            while ( NumFreeBuffers )
            {
                uBufferedBytes = (*CurrentWaveOperation).GetData( FreeQueue[Head], cBufferSize );
                              
                WDBGOUT((11, "GetData on 0x%08lx gave %ld bytes for buffer #%d",
                          CurrentWaveOperation,
                          uBufferedBytes,
                          Head));

                if ( 0 == uBufferedBytes )
                {
					WDBGOUT((10, TEXT("breakin 'cause 0 bytes...")));
                    break;
                }
                
				WDBGOUT((10, TEXT("past if...")));
                uTotalQueuedSize += uBufferedBytes;
                
                MiscInfo[Head].uBufferLength    = uBufferedBytes;
                MiscInfo[Head].poWaveOperation  = CurrentWaveOperation;
                MiscInfo[Head].pBuffer          = FreeQueue[Head];
                WaveHeader[Head].dwUser         = (DWORD) &MiscInfo[Head];
                WaveHeader[Head].dwBufferLength = uBufferedBytes;
   
                lResult = waveOutWrite( hWaveOut,
                                        &WaveHeader[Head],
                                        sizeof(WAVEHDR)
                                      );
                if ( lResult )
                {
                    //
                    // Something's wrong.  Quit this operation.
                    //
                    uTotalQueuedSize = 0;
                    uBufferedBytes = 0;
                    WDBGOUT((1, TEXT("waveOutWrite returned 0x%08lx"), lResult));
                    break;
                }

                Head = (Head + 1) % MAX_NUM_BUFFERS;

                NumFreeBuffers--;

                //
                // Are we just "priming" the pump?
                //
//                if ( fPrimeOnly )
//                {
//                    WDBGOUT((4, TEXT("Leaving PlaySomeData - primed (size=%08ld)"), uTotalQueuedSize ));
//                    LeaveCriticalSection( pCriticalSection );
//                    return uTotalQueuedSize;
//                }

            }
        }
#if DBG
        else
        {
			WDBGOUT((10, TEXT("I've been asked not to play this operation (0x%08lx)"), CurrentWaveOperation));
        }
        
#endif        
        
		WDBGOUT((10, TEXT("past while numfreebuffers...")));
        

        //
        // We got here because we're out of buffers, or the operation is done
        //
        if ( 0 != uBufferedBytes )
        {
            //
            // Must be here because we ran out of buffers...
            //
            LeaveCriticalSection( pCriticalSection );
            return( uTotalQueuedSize );
        }

        
        //
        // We get here when the current operation is all done
        // (or, at least, all of its remaining data is queued in the
        // wave driver)
        //
    }    
    
    //
    // If we got here, it's because we're out of things to do
    //

    LeaveCriticalSection( pCriticalSection );


    WDBGOUT((4, TEXT("Leaving PlaySomeData - no currop (size=%08ld)"), uTotalQueuedSize ));

    return uTotalQueuedSize;
//    return( 0 );
}


//****************************************************************************
//****************************************************************************
//****************************************************************************
void CALLBACK WaveOutCallback(
    HWAVE  hWave,    // handle of waveform device
    UINT  uMsg,    // sent message
    DWORD  dwInstance,    // instance data
    DWORD  dwParam1,    // application-defined parameter
    DWORD  dwParam2    // application-defined parameter
   )
{
    UINT n;

    switch ( uMsg )
    {
        case WOM_DONE:
        {
            class WaveDevice * poWaveDevice =
                        (class WaveDevice *)dwInstance;

            MISCINFO * pMiscInfo = (MISCINFO *)((LPWAVEHDR)dwParam1)->dwUser;

            
            WDBGOUT((11, TEXT("Got DoneWithBuff msg for 0x%08lx in 0x%08lx"),
                           *(LPDWORD)dwParam1,
                           dwParam1));


//            EnterCriticalSection( &gBufferCriticalSection );

            n = 0;

//TODO NOW: If this buffer won't fit, it'll get lost.  This can easily happen
//            when there are >1 wave devices playing.

            while (
                     ( n < MAX_NUM_BUFFERS )
                   &&
                     ( gDoneBuffersToBeProcessed[n] != NULL )
                  )
            {
               n++;
            }

            gDoneBuffersToBeProcessed[n] = pMiscInfo;

//            LeaveCriticalSection( &gBufferCriticalSection );

            SetEvent( ghFreeBufferEvent );
        }    
        break;

            
        case WOM_OPEN:
            WDBGOUT((11, TEXT("Got Waveout Open")));
            break;

            
        case WOM_CLOSE:
            WDBGOUT((11, TEXT("Got Waveout Close")));
            break;
    }
}    





//****************************************************************************
//****************************************************************************
//****************************************************************************
//LONG tapiMakeNoise(
//                      DWORD  Device Type: PHONE/LINE/WAVE, etc?
//                      HANDLE Device Handle,
//                      DWORD  NoiseType:   BUFFER/FILENAME/HFILE(readfile directly?)/MMIOHANDLE
//                      HANDLE hArray - array of type NoiseTypes that are to be played serially
//                      DWORD  Flags:
//                              fSYNC
//                              fSTOP_EXISTING_PLAYING_IF_ANY
//                    );


// SOME FLAGS FOR THIS FUNC
#define PLAY_SYNC 0x00000001
#define KILL_ALL_NOISE 0x80000000

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

LONG WINAPI tapiPlaySound(
                    DWORD  dwDeviceType,
                    HANDLE hDevice,
                    DWORD  dwSoundType,
                    HANDLE hArray,
                    DWORD  dwFlags
                  )
{
    HANDLE hSyncEvent = NULL;
    class WaveDevice * poWaveDevice;
    class WaveOperation * poWaveOperation;
    LONG fAreWeInited;
    LONG lResult = 0;
    ULONG uNormalizedWaveId = 0;
//    BOOLEAN fNeedToPrimeDevice = FALSE;

    WDBGOUT((3, "Entering tapiPlaySound"));
    WDBGOUT((5, "    dwDeviceType: %ld", dwDeviceType));
    WDBGOUT((5, "    hDevice:      0x%08lx", hDevice));
    WDBGOUT((5, "    dwSoundType:  %ld", dwSoundType));
    WDBGOUT((5, "    hArray:       0x%08lx", hArray));
    WDBGOUT((5, "    dwFlags:      0x%08lx", dwFlags));

    
    fAreWeInited = InterlockedExchange(
                                        &gfInited,
                                        TRUE
                                      );  
    
    if ( 0 == fAreWeInited )
    {
        InitializeCriticalSection( &gCriticalSection );
    }
    

    if ( 0 == ghFreeBufferEvent )
    {
        ghFreeBufferEvent = CreateEvent(
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        NULL
                                      );
            

        if ( NULL == ghFreeBufferEvent )
        {
            WDBGOUT((1, "CreateEvent2 failed: GetLastError = 0x%08lx", GetLastError()));
            return  LINEERR_NOMEM;
        }
    }


    //
    // Normalize to a wave device (and validate dwDeviceType at the same time)
    //
    switch ( dwDeviceType )
    {
        case DEVICE_WAVEID:
        {
            uNormalizedWaveId = (ULONG) hDevice;
        }
        break;


        case DEVICE_WAVEHANDLE:
        {
        }
        break;


        case DEVICE_HLINE:
        case DEVICE_HCALL:
        {
        
           DWORD  VarString[ 8 ] = 
           {
             sizeof(VarString),
             0,
             0,
             STRINGFORMAT_BINARY,
             0,
             0,
             0
           };


           if ( 0 == (lResult = lineGetID(
              (HLINE)hDevice,
              0,
              (HCALL)hDevice,
              (DEVICE_HCALL == dwDeviceType) ?
                    LINECALLSELECT_CALL :
                    LINECALLSELECT_LINE,
              (LPVARSTRING)&VarString,
              TEXT("wave/out")
            ) ) )
           {
              uNormalizedWaveId = (DWORD) ((LPBYTE)VarString)[ ((LPVARSTRING)&VarString)->dwStringOffset ];
           }
           else 
           {
              WDBGOUT((1, "lineGetID failed - 0x%08lx", lResult));
              
              return  LINEERR_INVALPARAM;
           }

        }
        break;


        case DEVICE_HPHONE:
        {
        }
        break;


        default:
        WDBGOUT((1, "Invalid dwDeviceType (0x%08lx) passed in.", dwDeviceType));
        return LINEERR_BADDEVICEID;
    }


    EnterCriticalSection( &gCriticalSection );

    poWaveDevice = gpoWaveDeviceList;

    while ( poWaveDevice )
    {
        if ( (*poWaveDevice).GetWaveDeviceId() == uNormalizedWaveId )
        {
            //
            // We found it!
            //
            break;
        }

        //
        // ...and I still haven't found what I'm lookin' for.
        //
        poWaveDevice = (*poWaveDevice).GetpNext();
    }


    //
    // So, was it not in our list already?
    //
    if ( NULL == poWaveDevice )
    {
       //
       // No, add a new device object to the list
       //

       poWaveDevice = new WaveDevice;

       lResult = (*poWaveDevice).InitWaveDevice( uNormalizedWaveId );

       if ( lResult )
       {
            WDBGOUT((1, TEXT("InitWaveDevice returned 0x%08lx"), lResult));
//TODO: Diff error codes for diff causes...
            LeaveCriticalSection( &gCriticalSection );
            return LINEERR_RESOURCEUNAVAIL;
       }

       (*poWaveDevice).SetpNext( gpoWaveDeviceList );
       
       gpoWaveDeviceList = poWaveDevice;
    }
    


    //
    // If the caller wants to cancel all currently queued and playing
    // sound on this device, do it now
    //
    if ( KILL_ALL_NOISE & dwFlags )
    {
        (*poWaveDevice).TerminateAllOperations();
        WDBGOUT((4, "Caller was asking to terminate the wave device.  Done."));
        
//        LeaveCriticalSection( &gCriticalSection );
//            
//	  	return( 0 );
    }



// t-mperh 6/30 was all commented before - not sure why
//
    //
    // If the user passed in a NULL for hArray, we'll (for now?) assume
    // he wants a no-op (or 'twas a TERMINATE request).
    //
    if ( NULL == hArray )
    {
        WDBGOUT((3, "Leaving tapiPlaySound - NULL thing"));
        LeaveCriticalSection( &gCriticalSection );
        return  0;
    }

//**************************************************************
//NOTE: The above code fixed a problem of passing in NULL names.
// This caused an OPEN to fail and this stuff would get stuck.
// There must still be a bug that will show up when someone calls with
// a bad filename or a file that plays 0 bytes.
//**************************************************************



    switch ( dwSoundType )
    {
        case SOURCE_WAVEFILE:
        {
            poWaveOperation = new WaveFile;
        }
        break;
        
        
        case SOURCE_MSDOSFILE:
        {
            poWaveOperation = new DosFile;
        }
        break;
    
        
        case SOURCE_MEM:
        {
            poWaveOperation = new BufferWave;
        }
        break;
    
        
        default:
        {
            WDBGOUT((1, "Invalid dwSourceType - 0x%08lx", dwSoundType));
            LeaveCriticalSection( &gCriticalSection );
            return LINEERR_INVALPARAM;
        }
    }
   
    
    if ( NULL == ghWaveThread )
    {
        DWORD dwThreadID;

        ghWaveThread = CreateThread(
                                    NULL,
                                    0,
                                    WaveThread,
                                    NULL,
                                    0,
                                    &dwThreadID
                                  );
        if ( 0 != lResult )
        {
            WDBGOUT((1, "Create thread failed! GetLastError()=0x%lx", GetLastError() ));
            LeaveCriticalSection( &gCriticalSection );
            return  LINEERR_NOMEM;
        }

    }


    //
    // Init global operation
    //
    (*poWaveOperation).InitOperation(
                                      poWaveDevice,
                                      dwSoundType,
                                      (LONG)hArray
                                    );  
    
    (*poWaveDevice).QueueOperation( poWaveOperation );
    
    
    if ( dwFlags & PLAY_SYNC )
    {
        hSyncEvent = CreateEvent(
                                  NULL,
                                  TRUE,
                                  FALSE,
                                  NULL
                                );
        
        if ( NULL == hSyncEvent )
        {
            WDBGOUT((1, TEXT("CreateEvent failed: GetLastError = 0x%08lx"), GetLastError()));
            
            delete poWaveOperation;
            LeaveCriticalSection( &gCriticalSection );
            return( LINEERR_NOMEM );
        }
        
        (*poWaveOperation).SetSyncEvent( hSyncEvent );
    }
    
    
    //
    // If all of the buffers are idle, we'll have to prime...
    //
    if ( MAX_NUM_BUFFERS == (*poWaveDevice).GetNumFreeBuffers() )
    {
        WDBGOUT((4, TEXT("Priming")));
        
        if ( 0 == (*poWaveDevice).PlaySomeData( TRUE ) )
        {
            WaveOperation * poWaveOperation;
            
            WDBGOUT((4, TEXT("No data played for this wave!")));
            
            
            poWaveOperation = (*poWaveDevice).NextOperation();
            
            while (poWaveOperation)
            {
               if ( (*poWaveDevice).PlaySomeData(TRUE) )
               {
                  break;
               }
               
               poWaveOperation = (*poWaveDevice).NextOperation();
            }
            
            //
            // If fNeedToPrimeDevice was true, this must be the first (and only,
            // since we're still in the critical section) operation
            // And, since there was no data (or we failed for any reason),
            // we should shut down the wave device here.
            
            // Now leave the critical section so we can wait for the WAVETHREAD
            // to finish and so that thread can do work to clean up
            LeaveCriticalSection( &gCriticalSection );
            (*poWaveDevice).KillWaveDevice(TRUE);
            EnterCriticalSection( &gCriticalSection );
            
            //
            // Fake out the event
            //
            if ( hSyncEvent )
            {
                WDBGOUT((5, TEXT("Faking hSyncEvent...")));
                SetEvent( hSyncEvent );
            }
        }
    }
#if DBG
    else
    {
        WDBGOUT((4, TEXT("Not priming because %ln buffers are out"),
                    (*poWaveDevice).GetNumFreeBuffers() ));
    }    
#endif    

    
    LeaveCriticalSection( &gCriticalSection );
    
    if ( hSyncEvent )
    {
        WDBGOUT((5, TEXT("Waiting for the wave to finish (event=0x%08lx)"),
                      hSyncEvent));
                      
        WaitForSingleObject( hSyncEvent, INFINITE );
        
        //
        // When it gets back, the thing is done playing
        //
        CloseHandle( hSyncEvent );
    }
    
    
    WDBGOUT((4, TEXT("Leaving tapiPlaySound - retcode = 0x0")));
    return( 0 );
}    

    


#ifdef __cplusplus
}            /* End Assume C declarations for C++ */
#endif  /* __cplusplus */


    
//****************************************************************************
//****************************************************************************
//****************************************************************************
unsigned long WINAPI WaveThread( LPVOID junk )
{
    UINT n;

    WDBGOUT((3, "WaveThread starting..."));

    do
    {
        WDBGOUT((3, "WaveThread waiting..."));
        WaitForSingleObject( ghFreeBufferEvent, INFINITE );


        //
        // First, deal with any finished buffers
        //
        n = 0;
//        while ( gDoneBuffersToBeProcessed[n] != NULL )

        EnterCriticalSection( &gCriticalSection );
                
        while ( n < MAX_NUM_BUFFERS )
        {
            if ( gDoneBuffersToBeProcessed[n] != NULL )
            {
                MISCINFO *pMiscInfo = gDoneBuffersToBeProcessed[n];

                pMiscInfo->poWaveOperation->ProcessDoneBuffer( pMiscInfo );
                gDoneBuffersToBeProcessed[n] = NULL;
            }

            n++;
        }

        LeaveCriticalSection( &gCriticalSection );

//        poWaveDevice = gpoWaveDeviceList;
//
//        while ( poWaveDevice )
//        {
//            UINT nBytesQueued = 0;
//
//            while ( nBytesQueued == 0 )
//            {
//                //
//                // Now play some new data
//                //
//                nBytesQueued = (*poWaveDevice).PlaySomeData( FALSE );
//
//                //
//                // And is the entire wave done?
//                //
//                if ( 0 == nBytesQueued )
//                {
//                    WaveOperation * poNewCurrent;
//                
//                    poNewCurrent = (*poWaveDevice).NextOperation();
//                        
//                    if ( NULL == poNewCurrent )
//                    {
//    if ( NULL == gpoWaveDeviceList )
//    {
//        gfShutdown = TRUE;
//        gfInited   = 0;
//    }
//                        break;
//                    }
//                }
//            }
//
//
//            poWaveDevice = (*poWaveDevice).GetpNext();
//        }

    } while ( !gfShutdown );

    WDBGOUT((5, TEXT("Oh, I guess we're done now...")));
    
    CloseHandle( ghFreeBufferEvent );
    ghFreeBufferEvent = 0;

    gfShutdown = FALSE;
    
    
    WDBGOUT((3, TEXT("WaveThread ending...")));

    ghWaveThread = NULL;
       
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\clntprivate.h ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  private.h
         
****************************************************************************/

#pragma once

#include "tapsrv.h"

#ifdef __cplusplus
extern "C"{
#endif

//***************************************************************************
//***************************************************************************
//***************************************************************************
void AllocNewID( HKEY MainKey, LPDWORD lpdw );
void PASCAL WideStringToNotSoWideString( LPBYTE lpBase, LPDWORD lpdwThing );
PWSTR PASCAL MultiToWide( LPCSTR  lpStr );
PWSTR PASCAL NotSoWideStringToWideString( LPCSTR lpStr, DWORD dwLength );



//***************************************************************************
//***************************************************************************
//***************************************************************************
typedef enum
{
    Dword,
    lpDword,
    hXxxApp,
    hXxxApp_NULLOK,
//    lpsz,
    lpszW,
    lpGet_SizeToFollow,
    lpSet_SizeToFollow,
    lpSet_Struct,
    lpGet_Struct,
    Size,
    Hwnd

} ARG_TYPE;


typedef struct _FUNC_ARGS
{
    DWORD               Flags;

    ULONG_PTR           Args[MAX_TAPI_FUNC_ARGS];

    BYTE                ArgTypes[MAX_TAPI_FUNC_ARGS];

} FUNC_ARGS, *PFUNC_ARGS;


typedef struct _UI_REQUEST_THREAD_PARAMS
{
    BOOL                bRequestCompleted;

    PFUNC_ARGS          pFuncArgs;

    LONG                lResult;

} UI_REQUEST_THREAD_PARAMS, *PUI_REQUEST_THREAD_PARAMS;


typedef struct _INIT_DATA
{
    DWORD               dwKey;

    DWORD               dwInitOptions;

    union
    {
        HWND            hwnd;

        HANDLE          hEvent;

        HANDLE          hCompletionPort;
    };

    union
    {
        LINECALLBACK    lpfnCallback;

        DWORD           dwCompletionKey;
    };

    HLINEAPP            hXxxApp;

    BOOL                bPendingAsyncEventMsg;

    DWORD               dwNumTotalEntries;

    DWORD               dwNumUsedEntries;

    PASYNC_EVENT_PARAMS pEventBuffer;

    PASYNC_EVENT_PARAMS pValidEntry;

    PASYNC_EVENT_PARAMS pFreeEntry;

    DWORD               dwNumLines;

    BOOL                bLine;

    DWORD               dwThreadID;

    DWORD               hInitData;

} INIT_DATA, *PINIT_DATA;


//
//  Private Error codes
//

#define TAPIERR_NOSERVICECONTROL    0xF100
#define TAPIERR_INVALRPCCONTEXT     0xF101

#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN LPTSTR DbgMessage,
    IN ...
    );

extern DWORD   gdwDebugLevel;

#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    );

#else

#define DBGOUT(arg)

#define DOFUNC(arg1,arg2) DoFunc(arg1)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    );

#endif

BOOL
WINAPI
SetTlsPCtxHandle(
    PCONTEXT_HANDLE_TYPE phCtxHandle
    );

PCONTEXT_HANDLE_TYPE
WINAPI
GetTlsPCtxHandle(
    void
    );

#ifdef __cplusplus
}
#endif


#if DBG

#define DWORD_CAST(v,f,l) (((v)>MAXDWORD)?(DbgPrt(0,L"DWORD_CAST: information will be lost during cast from %p in file %s, line %d",(v),(f),(l)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))

#else
#define DWORD_CAST(v,f,l)   (DWORD)(v)
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\g723uids.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    g723uids.h

Abstract:

    Include File for g723.

--*/

//
// GUIDs
//

// G.723.1 Codec Filter Object
// {24532D00-FCD8-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_IntelG723Codec,
0x24532d00, 0xfcd8, 0x11cf, 0xa7, 0xd3, 0x0, 0xa0, 0xc9, 0x5, 0x66, 0x83);

// G.723.1 Codec Filter Property Page Object
// {24532D01-FCD8-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_IntelG723CodecPropertyPage,
0x24532d01, 0xfcd8, 0x11cf, 0xa7, 0xd3, 0x0, 0xa0, 0xc9, 0x5, 0x66, 0x83);

// G.723.1 Compressed Speech Format
// {E4D13050-0E80-11d1-B094-00A0C95BED34}
DEFINE_GUID(MEDIASUBTYPE_G723Audio,
0xe4d13050, 0xe80, 0x11d1, 0xb0, 0x94, 0x0, 0xa0, 0xc9, 0x5b, 0xed, 0x34);

// {9D3C85D1-F877-11d0-B083-00A0C95BED34}
DEFINE_GUID(CLSID_IntelG723CodecAbout,
0x9d3c85d1, 0xf877, 0x11d0, 0xb0, 0x83, 0x0, 0xa0, 0xc9, 0x5b, 0xed, 0x34);

// G.723.1 codec license IF
// {899308D0-F7B1-11d0-B082-00A0C95BED34}
DEFINE_GUID(IID_IG723CodecLicense,
0x899308d0, 0xf7b1, 0x11d0, 0xb0, 0x82, 0x0, 0xa0, 0xc9, 0x5b, 0xed, 0x34);

#ifndef INC_G723UIDS
#define INC_G723UIDS

DECLARE_INTERFACE_(IG723CodecLicense, IUnknown)
{
    STDMETHOD(put_LicenseKey)
        ( THIS_
          DWORD magicword0,  // [in] magic word 0
          THIS_
          DWORD magicword1   // [in] magic word 1
        ) PURE;

    STDMETHOD(put_AccessKey)
        ( THIS_
          int accesskey      // [in] access key
        ) PURE;

    STDMETHOD(get_AccessKeyState)
        ( THIS_
          BOOL *flag         // [out] boolean flag
        ) PURE;
};

#define G723KEY_PSword0	0xcd4d8488 // full licence key 0
#define G723KEY_PSword1	0xd4c9b9ae // full licence key 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\clientr.h ===
//
// (c) 1995 Microsoft Corporation.  Portions Copyright Intel/Microsoft 1992-93.  All Rights Reserved."
//
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TELEPHON.RC
//
#define IDS_DC_GL_DRIVER_SETUP          1
#define IDS_DT_GL_DRIVER_LIST           2
#define IDCL_CR_HELP                    3
#define IDS_DC_GL_LOCATION              4
#define ID_CURRENT                      4
#define IDS_DT_GL_LOC_LIST              5
#define IDS_DC_GL_CALL_CARD             6
#define ID_NEW                          6
#define IDS_DT_GL_CARD_LIST             7
#define IDS_TITLE                       8
#define IDS_STATUS_LINE                 9
#define IDHELP                          9
#define IDS_HELP_FILE                   10
#define IDS_CLOSE                       11
#define IDS_CUSTOMIZE                   12
#define IDS_ADD_LOCATION                13
#define IDS_EDIT_LOCATION               14
#define IDS_WRN_REMOVE_CARD             15
#define IDS_ERR_APPLICATION             16
#define IDS_ERR_MEMORY                  17
#define IDS_ERR_ALREADY_IN_LIST         18
#define IDS_ERR_READ_PRIV_INI           19
#define IDS_ERR_WRITE_INI               20
#define IDS_ERR_INVALID_INI             21
#define IDS_ERR_WRITE_WIN_INI           22
#define IDS_WRN_INVALID_STR             23
#define IDS_WRN_INVALID_EX_NUM_STR      24
#define IDS_WRN_INVALID_NUM             25
#define IDS_ERR_INVALID_TAPIADDR        26
#define IDS_WRN_INI_READ_ONLY           27
#define IDS_DT_DS_NO_DRIVER             28
#define IDS_ERR_NO_DRIVER               29
#define IDS_ERR_BAD_DRIVER              30
#define IDS_NONE                        31
#define IDS_ADD_CALLING_CARD            32
#define IDS_EDIT_CALLING_CARD           33

#define IDS_CARD_REMOVE                 34
#define REMOVE_CARD       IDS_CARD_REMOVE
#define IDS_LOCATION_REMOVE             35
#define REMOVE_LOCATION   IDS_LOCATION_REMOVE

#define IDS_DRIVER_REMOVE               36
#define IDS_ERR_INVALID_INI_LOCATIONS   37
#define IDS_ERR_INVALID_INI_CARDS       38
#define IDD_BROWSE_TEMPLATE             38
#define IDS_ERR_INVALID_INI_DRIVERS     39

#ifndef CHICAGO
#define IDS_ERR_INVALID_INI_COUNTRIES   40
#endif

#define IDS_WRN_AREA_CODE_REQUIRED      41
#define IDS_WRN_INVALID_NUM_STR         42
#define IDS_WRN_INVALID_LOCATION_CARD   43
#define IDS_WRN_DRIVER_IN_USE           44
#define IDS_ERR_DRIVER_FAILED           45
#define IDS_ERR_MULTIPLE_INST           46

#define IDS_DIAL_ASST                   47
#define IDS_ERR_UPDATE_LOCATION          48
#define IDS_ERR_UPDATE_CARD              49
#define IDS_WRN_LOCATION_NAME_REQUIRED  50
#define IDS_WRN_CANNOT_CHANGE_DEF_LOC   51
#define IDS_WRN_LOCATION_NAME_REQUIRED  50

#define IDS_PROVIDERERROR_NOT_AN_SP     52
#define IDS_PROVIDERERROR_TOO_OLD       53
#define IDS_PROVIDERERROR_FAILED_INIT   54
#define IDS_WRN_CARD_NAME_REQUIRED       55
#define IDS_WRN_QUITING_WIZ            56

#define IDS_WRN_CANT_REMOVE_LAST_CARD   57

#define IDS_WRN_CARD_NUMBER_REQUIRED    58
#define IDS_MSG_SIMPLEMSG_MDMINSTALLED  59
#define IDS_NOCALLINGCARD               60
#define IDS_DL_DUP_NAME                 61
#define IDS_DL_NULL_NAME                62
#define IDS_DL_DUP_NAME_CAPTION         63
#define IDS_DL_NULL_NAME_CAPTION        64

#define IDD_TOLL_LIST                   104
#define IDD_CREDIT_CARD                 105
#define IDD_DIALING_RULES               106
#define IDI_TELEPHONY                   108
#define IDD_COPY_DIAL_RULES             109
#define IDD_ADD_DRIVER                  111
#define IDD_DEFINE_LOCATION             112
#define IDD_DEFINE_LOCATION_SIMPLE      113
#define IDD_DRIVER_SETUP                116
#define IDD_INSTALL_DRIVER              117
#define IDB_BITMAP1                     120
#define IDD_DEBUG_OUT                   121
#define ID_LIST                         303
#define LB_UNLISTED                     306

#define IDS_WRN_TITLE_WARNING           350
#define IDS_WRN_TITLE_NAMEINUSE         351
#define IDS_WRN_TITLE_INVALCHAR         352
#define IDS_WRN_TITLE_SURE              353
#define IDS_WRN_TITLE_REQUIRED          354
#define IDS_WRN_RULESNEEDED             355

#define IDCC_TM_CURR_LOCATION           1000
#define IDD_INSERT_DISK                 1000
#define IDD_BROWSE                      1001
#define IDD_UNLISTED_DRIVERS            1002
#define IDD_UPDATE                      1003
#define IDD_RESTART                     1004
#define IDD_EXISTS                      1005
#define IDCB_TM_MULT_LOCATIONS          1007
#define IDCB_TM_DRIVER_SETUP            1008
#define IDCB_TM_HELP                    1009
#define IDCB_GL_REMOVE                  1011
#define IDCB_TL_REMOVE                  1012
#define IDCB_TL_ADD                     1013
#define IDCB_TL_HELP                    1014
#define IDCK_TL_USE_AREA_CODE           1015
#define IDCT_GL_LIST_TEXT               1017
#define IDCB_CC_CUSTOMIZE               1018
#define IDCB_CC_HELP                    1019
#define IDCE_CC_CARD_NAME               1020
#define IDCE_CC_CARD_NUM                1021
#define IDCB_DR_COPY_FROM               1022
#define IDCE_CC_PASSWORD_CARD_NUM       1022
#define IDCB_DR_HELP                    1023
#define IDCE_DR_LOCAL_NUM               1024
#define IDCE_DR_LONG_NUM                1025
#define IDCE_DR_INTERNATIONAL_NUM       1026
#define IDCL_CR_RULE_LIST               1031
#define IDCB_AD_ADD                     1032
#define IDCB_AD_BROWSE                  1033
#define IDCH_AD_HELP                    1034
#define IDCE_DL_NAME                    1035
#define IDCE_DL_OUTSIDEACCESS           1036
#define IDCE_DL_LONGDISTANCEACCESS      1037
#define IDCE_DL_AREACODE                1038
#define psh15                           0x040e
#define IDCC_DL_COUNTRY                 1039
#define IDCC_DL_CALLING_CARD            1040
#define chx1                            0x0410
#define IDCB_DL_TOLL_LIST               1041
#define IDCL_AD_DRIVER_LIST             1042
#define IDCB_DL_CALLCARD_SETUP          1052
#define IDCB_DL_HELP                    1053
#define IDCC_TL_TOLL_LIST               1055
#define IDCB_DS_EDIT                    1056
#define IDCL_DS_LIST                    1057
#define IDCB_DS_ADD                     1058
#define IDCB_DS_REMOVE                  1059
#define IDCB_DS_HELP                    1060
#define IDCK_DR_HIDE_CARD               1061
#define IDCS_TM_LOCAL_CALLS             1062
#define IDCS_TM_LONG_DIST_CALLS         1063
#define IDCS_TM_AREA_CODE               1064
#define IDCS_TM_COUNTRY_CODE            1065
#define IDCS_TM_CALLING_CARD            1066
#define IDCB_INSTALL_BROWSE             1067
#define IDC_BUTTON2                     1068
#define IDCB_ID_HELP                    1068
#define IDCE_PATHNAME                   1069
#define IDT_DEBUG                       1070
#define IDCB_TM_CALLCARD_SETUP          1081
#define IDCB_GL_EDIT                    1083
#define stc1                            0x0440
#define stc2                            0x0441
#define IDCB_GL_ADD                     1109
#define IDCB_GL_HELP                    1112
#define lst1                            0x0460
#define IDCL_GL_LIST                    1121
#define lst2                            0x0461
#define cmb1                            0x0470
#define cmb2                            0x0471
#define edt1                            0x0480
#define ctlLast                         0x04ff
#define IDS_NAME                        2001
#define IDS_NAME2                       2002
#define IDS_NOINF                       2003
#define IDS_NOINF2                      2004
#define IDS_OUTOFDISK                   2005
#define IDS_NOINF3                      2006
#define IDS_NAME3                       2007
#define IDS_RESTARTTEXT                 2015
#define IDS_UPDATED                     2031
#define IDS_UNLISTED                    2034
#define IDS_UNABLE_TOINSTALL            2049
#define IDS_FILEINUSEADD                2053
#define IDS_FILEINUSEREM                2055
#define IDS_FILEINUSEREM2               2056
#define IDS_DRIVER_EXISTS               2058
#define IDS_DIAL_ASST_NOT_SET                2059
#define IDS_WRN_DIAL_ASST_NOT_SET        2060
#define ID_STATUS2                      4002
#define IDS_FILENOTINDIR                0x2001
#define IDS_DISKMSG                     0x2002
#define IDS_FILEMSG                     0x2003
#define IDS_DISKFILEMSG                 0x2004
#define IDH_DLG_ADD_UNKNOWN             8803
#define IDD_PATH                        0x3002
#define IDD_TEXT                        0x3003
#define IDD_ICON                        0x3004
#define IDS_NEWLOCATION                 0x3005
#define IDC_STATIC                      -1

#define IDCC_DL_NAME                5000
#define IDCB_DL_NEW_LOCATION                 5001
#define IDCK_DL_IN_LOCAL                     5002
#define IDCB_DL_REMOVE_LOCATION          5003
#define IDCB_DL_CHANGE_CARD              5004
#define IDCK_DL_CALLINGCARD              5005
#define IDCK_DL_CALLWAITING             5006
#define IDCK_DL_PULSE_DIAL               5007
#define IDCC_DL_CALLWAITING             5008
#define IDCE_DL_CALLINGCARD              5009
#define IDCS_DL_NAME                     5010
#define IDCS_DL_AREACODE                 5011
#define IDCS_DL_COUNTRY                  5012
#define IDCS_DL_OUTSIDE                  5013
#define IDCS_DL_OUTSIDEACCESS            5014
#define IDCS_DL_LONGDISTANCEACCESS       5015

#define IDCS_DL_SILENTTEXT               5016
#define IDCS_DL_CREATED_LOCATION         5017


#define IDCC_DR_CARD_NAME               6000
#define IDCE_DR_CARD_NUM                6001
#define IDCK_DR_IN_LOCAL                     6002
#define IDCB_DR_NEW_CARD                     6003
#define IDCB_DR_REMOVE_CARD              6004
#define IDCB_DR_ADVANCED                     6005
#define IDCS_DR_CARD_NAME                   6006
#define IDCS_DR_CARD_NUM                    6007
#define IDCS_DR_LOCAL_NUM                   6008
#define IDCS_DR_LONG_NUM                    6009
#define IDCS_DR_INTERNATIONAL_NUM           6010
#define IDCB_DR_DUMMY                                                6011



#define IDCR_PULSE                          6050
#define IDCR_TONE                           6051
#define IDCS_PULSE                          6052
#define IDCS_TONE                           6053
#define IDCR_CC_DIALZERO                    6054
#define IDCR_CC_DIALACCESSNUM               6055

#define IDD_NEW_LOCATION                    7000
#define IDCE_NL_NEW_LOCATION                7001
#define IDCS_NL_NEW_LOCATION                7002

#define IDD_NEW_CARD                        8000
#define IDCE_NC_NEW_CARD                    8001
#define IDCS_NC_NEW_CARD                    8002
#define IDCS_CR_RULE_LIST                   8003

#define IDCS_DIAL_NUMBER_TEXT               9000
#define IDCS_DL_DIAL_NUMBER                 9001
#define IDCS_DR_DIAL_NUMBER                 9002
#define IDCS_LOC_BMP                        9100
#define IDCL_LOC_BMP                        9101
#define IDCL_LOC_SIMPLE_BMP                 9102

#define IDD_CALLING_CARD_CHANGE             9150

/* ALERT! Do NOT change this value. It is used by the RNA guys
 * to identify the Dialing info dialog for their Modems Wizard.
 */
#define IDD_WIZ_DIALINFO                                        400


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1071
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif


#define RC_CARD_ID_BASE         15800
#define RC_COUNTRY_ID_BASE      16000

#define DIALINGPROPERTIES_NAME 4446




//#if WINNT

// id's for TAPI Dial Helper (5100-5199)

// (copied from HELP.H)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
//#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// NOTE: Telephony Drivers dlg/propsheet uses help IDs 5122-5128
#define IDH_TAPI_NEW_PREFIX             5129
#define IDH_TAPI_DIGITSTODIAL           5130
#define IDH_TAPI_CC_LDPHONENUMBER       5131
#define IDH_TAPI_CC_IPHONENUMBER        5132
#define IDH_TAPI_CC_LDSTEPSBUTTON       5133
#define IDH_TAPI_CC_ISTEPSBUTTON        5134
#define IDH_TAPI_DIALINGRULES           5135
#define IDH_TAPI_CARDNAME               5136
#define IDH_TAPI_USE_CALLINGCARD        5137
#define IDH_TAPI_NEW_TOLLPREFIX         5138
#define IDH_TAPI_REMOVE_TOLLPREFIX      5139
#define IDH_TAPI_NEW_10DIGITAC          5140
#define IDH_TAPI_REMOVE_10DIGITAC       5141
#define IDH_TAPI_NEW_ACFIELD            5142
#define IDH_TAPI_CCSTEP_DIAL            5143
#define IDH_TAPI_CCSTEP_WAIT            5144
#define IDH_TAPI_10DIGITDIALING         5145

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\client.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    client.h

Abstract:

    Header file for tapi client module

Author:

    Dan Knudson (DanKn)    01-Apr-1994

Revision History:

--*/


#pragma once

#define TAPI_VERSION1_0           0x00010003
#define TAPI_VERSION1_4           0x00010004
#define TAPI_VERSION2_0           0x00020000
#define TAPI_VERSION2_1           0x00020001
#define TAPI_VERSION2_2           0x00020002
#define TAPI_VERSION3_0           0x00030000
#define TAPI_VERSION3_1           0x00030001
#define TAPI_VERSION_CURRENT      TAPI_VERSION3_1

#ifdef _WIN64
#define TALIGN_MASK                 0xfffffff8
#define TALIGN_COUNT                7
#else
#define TALIGN_MASK                 0xfffffffc
#define TALIGN_COUNT                3
#endif
#define ALIGN(a)                    (((a)+TALIGN_COUNT)&TALIGN_MASK)

#define NUM_ARGS_MASK             0x0000000f

#define LINE_FUNC                 0x00000010
#define PHONE_FUNC                0x00000020
#define TAPI_FUNC                 0x00000000

#define ASYNC                     0x00000040
#define SYNC                      0x00000000

#define INCL_CONTEXT              0x00000080

#define INITDATA_KEY              ((DWORD) 'INIT')
#define TPROXYREQUESTHEADER_KEY   ((DWORD) 'REQH')

#define WM_ASYNCEVENT             (WM_USER+111)

#define DEF_NUM_EVENT_BUFFER_ENTRIES    16

#define WAVE_STRING_ID_BUFFER_SIZE      256

#define TAPI_SUCCESS                    0
#define TAPI_NO_DATA                    ((DWORD)-1)
#define MAX_TAPI_FUNC_ARGS              13

#define REMOVEPROVIDER                  0
#define CONFIGPROVIDER                  1
#define ADDPROVIDER                     2
#define TAPI16BITSUCCESS                -2

#define INITIAL_CLIENT_THREAD_BUF_SIZE  512
#define WM_TAPI16_CALLBACKMSG           (WM_USER+101)

#define IsOnlyOneBitSetInDWORD(dw) (dw && !(((DWORD)dw) & (((DWORD)dw) - 1)))

#define AllCallSelect                \
    (LINECALLSELECT_CALL           | \
    LINECALLSELECT_ADDRESS         | \
    LINECALLSELECT_LINE)

#define AllDigitModes                \
    (LINEDIGITMODE_PULSE           | \
    LINEDIGITMODE_DTMF             | \
    LINEDIGITMODE_DTMFEND)

#define AllForwardModes              \
    (LINEFORWARDMODE_UNCOND        | \
    LINEFORWARDMODE_UNCONDINTERNAL | \
    LINEFORWARDMODE_UNCONDEXTERNAL | \
    LINEFORWARDMODE_UNCONDSPECIFIC | \
    LINEFORWARDMODE_BUSY           | \
    LINEFORWARDMODE_BUSYINTERNAL   | \
    LINEFORWARDMODE_BUSYEXTERNAL   | \
    LINEFORWARDMODE_BUSYSPECIFIC   | \
    LINEFORWARDMODE_NOANSW         | \
    LINEFORWARDMODE_NOANSWINTERNAL | \
    LINEFORWARDMODE_NOANSWEXTERNAL | \
    LINEFORWARDMODE_NOANSWSPECIFIC | \
    LINEFORWARDMODE_BUSYNA         | \
    LINEFORWARDMODE_BUSYNAINTERNAL | \
    LINEFORWARDMODE_BUSYNAEXTERNAL | \
    LINEFORWARDMODE_BUSYNASPECIFIC)

#define AllTerminalModes             \
    (LINETERMMODE_BUTTONS          | \
    LINETERMMODE_LAMPS             | \
    LINETERMMODE_DISPLAY           | \
    LINETERMMODE_RINGER            | \
    LINETERMMODE_HOOKSWITCH        | \
    LINETERMMODE_MEDIATOLINE       | \
    LINETERMMODE_MEDIAFROMLINE     | \
    LINETERMMODE_MEDIABIDIRECT)

#define AllToneModes                 \
    (LINETONEMODE_CUSTOM           | \
    LINETONEMODE_RINGBACK          | \
    LINETONEMODE_BUSY              | \
    LINETONEMODE_BEEP              | \
    LINETONEMODE_BILLING)

#define AllHookSwitchDevs            \
    (PHONEHOOKSWITCHDEV_HANDSET    | \
    PHONEHOOKSWITCHDEV_SPEAKER     | \
    PHONEHOOKSWITCHDEV_HEADSET)

#define AllHookSwitchModes           \
    (PHONEHOOKSWITCHMODE_ONHOOK    | \
    PHONEHOOKSWITCHMODE_MIC        | \
    PHONEHOOKSWITCHMODE_SPEAKER    | \
    PHONEHOOKSWITCHMODE_MICSPEAKER)

#define AllLampModes                 \
    (PHONELAMPMODE_BROKENFLUTTER   | \
    PHONELAMPMODE_FLASH            | \
    PHONELAMPMODE_FLUTTER          | \
    PHONELAMPMODE_OFF              | \
    PHONELAMPMODE_STEADY           | \
    PHONELAMPMODE_WINK             | \
    PHONELAMPMODE_DUMMY)

#define AllMediaModes                \
    (LINEMEDIAMODE_UNKNOWN         | \
    LINEMEDIAMODE_INTERACTIVEVOICE | \
    LINEMEDIAMODE_AUTOMATEDVOICE   | \
    LINEMEDIAMODE_DIGITALDATA      | \
    LINEMEDIAMODE_G3FAX            | \
    LINEMEDIAMODE_G4FAX            | \
    LINEMEDIAMODE_DATAMODEM        | \
    LINEMEDIAMODE_TELETEX          | \
    LINEMEDIAMODE_VIDEOTEX         | \
    LINEMEDIAMODE_TELEX            | \
    LINEMEDIAMODE_MIXED            | \
    LINEMEDIAMODE_TDD              | \
    LINEMEDIAMODE_ADSI             | \
    LINEMEDIAMODE_VOICEVIEW        | \
    LINEMEDIAMODE_VIDEO)


typedef enum
{
    xGetAsyncEvents,
    xGetUIDllName,
    xUIDLLCallback,
    xFreeDialogInstance,

    lAccept,
    lAddToConference,
    lAgentSpecific,
    lAnswer,
    lBlindTransfer,
    lClose,
    lCompleteCall,
    lCompleteTransfer,
//    lConditionalMediaDetection,  //remotesp
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
    lDrop,
    lForward,
    lGatherDigits,
    lGenerateDigits,
    lGenerateTone,
    lGetAddressCaps,
    lGetAddressID,
    lGetAddressStatus,
    lGetAgentActivityList,
    lGetAgentCaps,
    lGetAgentGroupList,
    lGetAgentStatus,
    lGetAppPriority,
    lGetCallAddressID,          // remotesp only
    lGetCallInfo,
    lGetCallStatus,
    lGetConfRelatedCalls,
    lGetCountry,
    lGetDevCaps,
    lGetDevConfig,
    lGetIcon,
    lGetID,
    lGetLineDevStatus,
    lGetNewCalls,
    lGetNumAddressIDs,          // remotesp only
    lGetNumRings,
    lGetProviderList,
    lGetRequest,
    lGetStatusMessages,
//In TAPI32.DLL now:    lGetTranslateCaps,
    lHandoff,
    lHold,
    lInitialize,
    lMakeCall,
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
    lPark,
    lPickup,
    lPrepareAddToConference,
    lProxyMessage,
    lProxyResponse,
    lRedirect,
    lRegisterRequestRecipient,
    lReleaseUserUserInfo,
    lRemoveFromConference,
    lSecureCall,
//    lSelectExtVersion,
    lSendUserUserInfo,
    lSetAgentActivity,
    lSetAgentGroup,
    lSetAgentState,
    lSetAppPriority,
    lSetAppSpecific,
    lSetCallData,
    lSetCallParams,
    lSetCallPrivilege,
    lSetCallQualityOfService,
    lSetCallTreatment,
//In TAPI32.DLL now:    lSetCurrentLocation,
    lSetDefaultMediaDetection,  // remotesp only
    lSetDevConfig,
    lSetLineDevStatus,
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
//In TAPI32.DLL now:    lSetTollList,
    lSetupConference,
    lSetupTransfer,
    lShutdown,
    lSwapHold,
//In TAPI32.DLL now:    lTranslateAddress,
    lUncompleteCall,
    lUnhold,
    lUnpark,

    pClose,
    pDevSpecific,
    pGetButtonInfo,
    pGetData,
    pGetDevCaps,
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetID,
    pGetIcon,
    pGetLamp,
    pGetRing,
    pGetStatus,
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
//    pSelectExtVersion,      // remotesp
    pSetButtonInfo,
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

//In TAPI32.DLL now:    tGetLocationInfo,
    tRequestDrop,
    tRequestMakeCall,
    tRequestMediaCall,
//    tMarkLineEvent,
    tReadLocations,
    tWriteLocations,
    tAllocNewID,
    tPerformance,
    lConditionalMediaDetection,  //remotesp
    lSelectExtVersion,
    pSelectExtVersion,      // remotesp
//    lOpenInt,
//    lShutdownInt,

    //
    // Ordinals for tapi 2.1 ended here.  the lOpenInt & lShutdownInt
    // were Win95 local-machine-only hacks which have since been removed
    //

    xNegotiateAPIVersionForAllDevices, // remotesp

    mGetAvailableProviders,
    mGetLineInfo,
    mGetPhoneInfo,
    mGetServerConfig,
    mSetLineInfo,
    mSetPhoneInfo,
    mSetServerConfig,

    //
    // Ordinals for 2.1 update (nt4 sp4) ended here.
    //

    lMSPIdentify,
    lReceiveMSPData,

    lGetCallHubTracking,
    lGetCallIDs,
    lGetHubRelatedCalls,
    lSetCallHubTracking,
    xPrivateFactoryIdentify,
    lDevSpecificEx,
    lCreateAgent,
    lCreateAgentSession,
    lGetAgentInfo,
    lGetAgentSessionInfo,
    lGetAgentSessionList,
    lGetQueueInfo,
    lGetGroupList,
    lGetQueueList,
    lSetAgentMeasurementPeriod,
    lSetAgentSessionState,
    lSetQueueMeasurementPeriod,
    lSetAgentStateEx,
    lGetProxyStatus,
    lCreateMSPInstance,
    lCloseMSPInstance,

    //
    //  Funcs for TAPI 3.1
    //
    tSetEventMasksOrSubMasks,
    tGetEventMasksOrSubMasks,
    tSetPermissibleMasks,
    tGetPermissibleMasks,

    mGetDeviceFlags,

    lGetCountryGroup,

    lGetIDEx,

    pGetIDEx,

    //
    // The following is always the last one in the list
    //

    xLastFunc

} FUNC_TYPE;



typedef struct _CLIENT_THREAD_INFO
{
    LIST_ENTRY  TlsList;

    LPBYTE      pBuf;

    DWORD       dwBufSize;

} CLIENT_THREAD_INFO, *PCLIENT_THREAD_INFO;


typedef struct _TAPI32_MSG
{
    //
    // The following union is used:
    //
    //   1. by requests from client to server to specify a function type
    //   2. by acks from server to client to specify a return value
    //   3. by async msgs from server to client to specify msg type
    //

    union
    {
        DWORD       Req_Func;

        DWORD       Ack_ReturnValue;

        DWORD       Msg_Type;

    } u;


    //
    // The following...
    //

	DWORD       unsused;


    //
    // Function paramters
    //

    DWORD       Params[MAX_TAPI_FUNC_ARGS];


} TAPI32_MSG, *PTAPI32_MSG;


typedef struct _ASYNCEVENTMSG
{
    DWORD                   TotalSize;
    DWORD                   InitContext;
    DWORD                   fnPostProcessProcHandle;
    DWORD                   hDevice;

    DWORD                   Msg;
    DWORD                   OpenContext;

    union {
    
        DWORD           Param1;
    };

    union {
    
        DWORD           Param2;
    };

    union {
    
        DWORD           Param3;
    };

    union {
    
        DWORD           Param4;
    };

} ASYNCEVENTMSG, *PASYNCEVENTMSG;


typedef void (PASCAL *POSTPROCESSPROC)(PASYNCEVENTMSG pMsg);


typedef struct _ASYNC_EVENT_PARAMS
{
    DWORD                   hDevice;
    DWORD                   dwMsg;
    ULONG_PTR               dwCallbackInstance;
    ULONG_PTR               dwParam1;

    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;

} ASYNC_EVENT_PARAMS, *PASYNC_EVENT_PARAMS;


typedef LONG (PASCAL *TUISPIPROC)();


typedef struct _UITHREADDATA
{
    HTAPIDIALOGINSTANCE     htDlgInst;
    HINSTANCE               hUIDll;
    HANDLE                  hThread;
    HANDLE                  hEvent;

    LPVOID                  pParams;
    DWORD                   dwSize;
    TUISPIPROC              pfnTUISPI_providerGenericDialog;
    TUISPIPROC              pfnTUISPI_providerGenericDialogData;

    struct _UITHREADDATA   *pPrev;
    struct _UITHREADDATA   *pNext;

} UITHREADDATA, *PUITHREADDATA;


typedef struct _PROXYREQUESTHEADER
{
    DWORD                   dwKey;

    DWORD                   dwInstance;

} PROXYREQUESTHEADER, *PPROXYREQUESTHEADER;


#if DBG
extern TCHAR    gszDebug[];
#endif
extern const TCHAR    gszCurrentLocation[];
extern const TCHAR    gszNullString[];

#ifdef __cplusplus
extern "C"{
#endif

#if DBG
#define ClientAlloc( __size__ ) ClientAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

#else
#define ClientAlloc( __size__ ) ClientAllocReal( __size__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize
    );

#endif
    
SIZE_T
WINAPI
ClientSize(
    LPVOID  lp
    );

void
WINAPI
ClientFree(
    LPVOID  lp
    );



LONG
WINAPI
MarkLineEvent(
    DWORD           dwApiVersion,
    DWORD           ptLine,
    DWORD           ptLineClientToExclude,
    DWORD           dwMsg,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwParam3
    );

void ListNodePoolsInitialize(void);
void ListNodePoolsUninitialize(void);

extern  BOOL gbDisableGetTranslateCapsHack;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\explib\tapilib.c ===
#if DBG
#define InternalDebugOut(_x_) DbgPrtEXPLIB _x_
#else
#define InternalDebugOut(_x_)
#endif

#define STRICT

#include <windows.h>
#include <windowsx.h>

//#include "stdlib.h"
#include "tapi.h"

HINSTANCE ghTapi32 = NULL;
DWORD     gdwDebugLevel = 0;

typedef LONG (WINAPI *TAPIPROC)();

#undef   lineBlindTransfer
#undef   lineConfigDialog
#undef   lineConfigDialogEdit
#undef   lineDial
#undef   lineForward
#undef   lineGatherDigits
#undef   lineGenerateDigits
#undef   lineGetAddressCaps
#undef   lineGetAddressID
#undef   lineGetAddressStatus
#undef   lineGetCallInfo
#undef   lineGetDevCaps
#undef   lineGetDevConfig
#undef   lineGetIcon
#undef   lineGetID
#undef   lineGetLineDevStatus
#undef   lineGetRequest
#undef   lineGetTranslateCaps
#undef   lineHandoff
#undef   lineMakeCall
#undef   lineOpen
#undef   linePark
#undef   linePickup
#undef   linePrepareAddToConference
#undef   lineRedirect
#undef   lineSetDevConfig
#undef   lineSetTollList
#undef   lineSetupConference
#undef   lineSetupTransfer
#undef   lineTranslateAddress
#undef   lineUnpark
#undef   phoneConfigDialog
#undef   phoneGetButtonInfo
#undef   phoneGetDevCaps
#undef   phoneGetIcon
#undef   phoneGetID
#undef   phoneGetStatus
#undef   phoneSetButtonInfo
#undef   tapiGetLocationInfo
#undef   tapiRequestMakeCall
#undef   tapiRequestMediaCall
#undef   lineAddProvider
#undef   lineGetAppPriority
#undef   lineGetCountry
#undef   lineGetProviderList
#undef   lineSetAppPriority
#undef   lineTranslateDialog



//**************************************************************************
//**************************************************************************
//**************************************************************************
#if DBG
VOID
DbgPrtEXPLIB(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static BOOLEAN fBeenThereDoneThat = FALSE;

    if ( !fBeenThereDoneThat )
    {
            HKEY  hKey;


            gdwDebugLevel=0;

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony",
                    0,
                    KEY_ALL_ACCESS,
                    &hKey

                    ) == ERROR_SUCCESS)
            {
                DWORD dwDataSize = sizeof(DWORD), dwDataType;

                RegQueryValueEx(
                    hKey,
                    "Tapi32libDebugLevel",
                    0,
                    &dwDataType,
                    (LPBYTE)&gdwDebugLevel,
                    &dwDataSize
                    );

                RegCloseKey (hKey);
            }
    }


    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[1280] = "TAPI32.LIB: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[12],
                   lpszFormat,
                   ap
                  );

        lstrcat (buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }
}
#endif

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG PASCAL GetTheFunctionPtr( LPSTR lpszFunction, TAPIPROC *ppfn )
{
   InternalDebugOut((4, "Looking for: [%s]", lpszFunction));

   if ( !ghTapi32 )
   {
      ghTapi32 = LoadLibrary("TAPI32.DLL");
      
      //
      // If this failed, we won't try again
      //
      if ( 0 == ghTapi32 )
      {
         InternalDebugOut((1, "Can't LoadLibrary(""TAPI32.DLL"") !"));
         ghTapi32 = (HINSTANCE)-1;
      }
   }


   if ( ghTapi32 != (HINSTANCE)-1 )
   {
      *ppfn = (TAPIPROC) GetProcAddress( ghTapi32, lpszFunction );
   }
   else
   {
      return LINEERR_OPERATIONUNAVAIL;
   }


   if ( NULL == *ppfn )
   {
      InternalDebugOut((1, "Can't find function: [%s]", lpszFunction));
      return LINEERR_OPERATIONUNAVAIL;
   }

   return 0;
}
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAccept", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddProvider(
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddProvider", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszProviderFilename,
                   hwndOwner,
                   lpdwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddProviderA(
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddProviderA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszProviderFilename,
                   hwndOwner,
                   lpdwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddProviderW(
    LPCWSTR             lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddProviderW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszProviderFilename,
                   hwndOwner,
                   lpdwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddToConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   hConsultCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAgentSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAgentSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwAgentExtensionIDIndex,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAnswer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineBlindTransfer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineBlindTransferA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineBlindTransferA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddressW,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineBlindTransferW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddressW,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineClose(
    HLINE               hLine
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineClose", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCompleteCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpdwCompletionID,
                   dwCompletionMode,
                   dwMessageID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCompleteTransfer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hConsultCall,
                   lphConfCall,
                   dwTransferMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialog", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogEdit(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogEdit", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass,
                   lpDeviceConfigIn,
                   dwSize,
                   lpDeviceConfigOut
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogEditA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogEditA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass,
                   lpDeviceConfigIn,
                   dwSize,
                   lpDeviceConfigOut
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogEditW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass,
                   lpDeviceConfigIn,
                   dwSize,
                   lpDeviceConfigOut
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigProvider(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigProvider", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hwndOwner,
                   dwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentA(                                               // TAPI v2.2
    HLINE               hLine,
    LPSTR               lpszAgentID,
    LPSTR               lpszAgentPIN,
    LPHAGENT            lphAgent
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpszAgentID,
                   lpszAgentPIN,
                   lphAgent
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentW(                                               // TAPI v2.2
    HLINE               hLine,
    LPWSTR              lpszAgentID,
    LPWSTR              lpszAgentPIN,
    LPHAGENT            lphAgent
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpszAgentID,
                   lpszAgentPIN,
                   lphAgent
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentSessionA(                                        // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPSTR               lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentSessionA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   lpszAgentPIN,
                   dwWorkingAddressID,
                   lpGroupID,
                   lphAgentSession
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentSessionW(                                               // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPWSTR              lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentSessionW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   lpszAgentPIN,
                   dwWorkingAddressID,
                   lpGroupID,
                   lphAgentSession
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDeallocateCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDevSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDevSpecificFeature", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwFeature,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDial", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDialA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDialA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDialW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDrop", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLI